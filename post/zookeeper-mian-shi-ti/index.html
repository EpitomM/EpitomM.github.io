<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>面试题系列 —— Zookeeper | SSM</title>
<link rel="shortcut icon" href="https://epitomm.github.io/favicon.ico?v=1589017479735">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://epitomm.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="面试题系列 —— Zookeeper | SSM - Atom Feed" href="https://epitomm.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="1. 谈谈你对 Zookeeper 的认识
Zookeeper 是一个分布式协调服务的开源框架。主要用来解决分布式集群中应用系统的一致性问题，例如怎样避免同时操作同一数据造成脏读的问题。
ZooKeeper 本质上是一个分布式的小文件存储系..." />
    <meta name="keywords" content="面试题,Zookeeper" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://epitomm.github.io">
  <img class="avatar" src="https://epitomm.github.io/images/avatar.png?v=1589017479735" alt="">
  </a>
  <h1 class="site-title">
    SSM
  </h1>
  <p class="site-description">
    热心善良的老学姐
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              面试题系列 —— Zookeeper
            </h2>
            <div class="post-info">
              <span>
                2020-03-14
              </span>
              <span>
                14 min read
              </span>
              
                <a href="https://epitomm.github.io/tag/1hfOEuf6o1/" class="post-tag">
                  # 面试题
                </a>
              
                <a href="https://epitomm.github.io/tag/qvTCL8SyH/" class="post-tag">
                  # Zookeeper
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://epitomm.github.io/post-images/zookeeper-mian-shi-ti.png" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="1-谈谈你对-zookeeper-的认识">1. 谈谈你对 Zookeeper 的认识</h1>
<p><code>Zookeeper</code> 是一个<strong>分布式协调服务</strong>的开源框架。主要用来解决分布式集群中应用系统的<strong>一致性</strong>问题，例如怎样避免同时操作同一数据造成脏读的问题。</p>
<p><strong><code>ZooKeeper</code> 本质上是一个分布式的小文件存储系统</strong>。提供基于类似于文件系统的目录树方式的数据存储，并且可以对树中的节点进行有效管理。从而用来维护和监控你存储的数据的状态变化。通过监控这些数据状态的变化，从而可以达到基于数据的集群管理。诸如：统一命名服务、分布式配置管理、分布式消息队列、分布式锁、分布式协调等功能。</p>
<h2 id="zookeeper-集群角色">Zookeeper 集群角色</h2>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/zk%E9%9B%86%E7%BE%A4%E8%A7%92%E8%89%B2.png" alt="" loading="lazy"></figure>
<h3 id="leader">Leader:</h3>
<p>Zookeeper 集群工作的核心</p>
<p><strong>事务请求</strong>（写操作）的唯一调度和处理者，保证集群事务处理的顺序性；</p>
<p>集群内部各个服务器的<strong>调度者</strong>。</p>
<blockquote>
<p>对于 create，setData，delete 等有写操作的请求，则需要统一转发给 leader 处理，leader 需要决定编号、执行操作，这个过程称为一个<strong>事务</strong>。</p>
</blockquote>
<h3 id="follower">Follower:</h3>
<p><strong>处理客户端非事务（读操作）请求，转发事务请求给 Leader；</strong></p>
<p><strong>参与集群 Leader 选举投票。</strong></p>
<p>此外，针对访问量比较大的 zookeeper 集群，还可新增观察者角色。</p>
<h3 id="observer">Observer:</h3>
<p>观察者角色，观察 Zookeeper 集群的最新状态变化并将这些状态同步过来，其对于非事务请求可以进行独立处理，对于事务请求，则会转发给 Leader 服务器进行处理。</p>
<p><strong>不会参与任何形式的投票</strong>只提供非事务服务，通常用于在不影响集群事务处理能力的前提下提升集群的非事务处理能力。</p>
<h1 id="2-zookeeper-特性">2. ZooKeeper 特性</h1>
<ol>
<li><strong>全局数据一致</strong>：集群中每个服务器保存一份相同的数据副本，<code>client</code> 无论连接到哪个服务器，展示的数据都是一致的，这是最重要的特征；<br>
<img src="https://epitomm.github.io/post-images/zk%E5%85%A8%E5%B1%80%E4%B8%80%E8%87%B4%E6%80%A7.png" alt="" loading="lazy"></li>
<li><strong>可靠性</strong>：如果消息【<strong>增、删、改、查</strong>】被其中一台服务器接受，那么将被所有的服务器接受。<br>
<img src="https://epitomm.github.io/post-images/zk%E5%8F%AF%E9%9D%A0%E6%80%A7.png" alt="" loading="lazy"></li>
<li><strong>顺序性</strong>：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息 a 在消息 b 前发布，则在所有 <code>Server</code> 上消息 a 都将在消息 b 前被发布；偏序是指如果一个消息 b 在消息 a 后被同一个发送者发布，a 必将排在 b 前面。</li>
<li><strong>数据更新原子性</strong>：一次数据更新要么成功（半数以上节点成功），要么失败，不存在中间状态。</li>
<li><strong>实时性</strong>：<code>Zookeeper</code> 保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。</li>
</ol>
<h1 id="3-zookeeper-数据模型">3． ZooKeeper 数据模型</h1>
<p><code>ZooKeeper</code> 的数据模型，在结构上和标准文件系统的非常相似，拥有一个层次的命名空间，都是采用<strong>树形层次结构</strong>，<code>ZooKeeper</code> 树中的每个节点被称为— <strong><code>Znode</code></strong>。和文件系统的目录树一样，<code>ZooKeeper</code> 树中的每个节点可以拥有子节点。但也有不同之处：</p>
<ol>
<li><strong><code>Znode</code> 兼具文件和目录两种特点</strong>。既像文件一样维护着数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分，并可以具有子 <code>Znode</code>。用户对 <code>Znode</code> 具有增、删、改、查等操作（权限允许的情况下）。</li>
<li><strong><code>Znode</code> 具有原子性操作</strong>，读操作将获取与节点相关的所有数据，写操作也将替换掉节点的所有数据。另外，每一个节点都拥有自己的 ACL(访问控制列表)，这个列表规定了用户的权限，即限定了特定用户对目标节点可以执行的操作。</li>
<li><strong><code>Znode</code> 存储数据大小有限制</strong>。<code>ZooKeeper</code> 虽然可以关联一些数据，但并没有被设计为常规的数据库或者大数据存储，相反的是，它用来管理调度数据，比如分布式应用中的配置文件信息、状态信息、汇集位置等等。这些数据的共同特性就是它们都是很小的数据，<strong>通常以 KB 为大小单位</strong>。ZooKeeper 的服务器和客户端都被设计为严格检查并限制每个 Znode 的数据大小至多 1M，当时常规使用中应该远小于此值。</li>
<li><strong><code>Znode</code> 通过路径引用</strong>，如同 <code>Unix</code> 中的文件路径。<strong>路径必须是绝对的</strong>，因此他们必须<strong>由斜杠字符来开头</strong>。除此以外，他们必须是唯一的，也就是说每一个路径只有一个表示，因此这些路径不能改变。在 <code>ZooKeeper</code> 中，路径由 <code>Unicode</code> 字符串组成，并且有一些限制。字符串&quot;/zookeeper&quot;用以保存管理信息，比如关键配额信息。</li>
</ol>
<h2 id="31数据结构图">3.1．数据结构图</h2>
<p><img src="https://epitomm.github.io/post-images/1584240732240.jpg" alt="" loading="lazy"><br>
图中的每个节点称为一个 <code>Znode</code>。 每个 <code>Znode</code> 由 3 部分组成:</p>
<ul>
<li><code>stat</code>：此为状态信息, 描述该 <code>Znode</code> 的版本, 权限等信息</li>
<li><code>data</code>：与该 <code>Znode</code> 关联的数据</li>
<li><code>children</code>：该 <code>Znode</code> 下的子节点</li>
</ul>
<h2 id="32节点类型">3.2．节点类型</h2>
<p><code>Znode</code> 有两种，分别为<strong>临时节点</strong>和<strong>永久节点</strong>。</p>
<p>节点的类型<strong>在创建时即被确定，并且不能改变。</strong></p>
<p><strong>临时节点</strong>：该节点的生命周期依赖于创建它们的会话。一旦<strong>会话结束，临时节点将被自动删除</strong>，当然可以也可以手动删除。<strong>临时节点不允许拥有子节点</strong>。</p>
<p><strong>永久节点</strong>：该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，他们才能被删除。</p>
<p><code>Znode</code> 还有一个<strong>序列化</strong>的特性，如果创建的时候指定的话，该 <code>Znode</code> 的名字后面会<strong>自动追加一个不断增加的序列号</strong>。序列号对于此节点的父节点来说是唯一的，这样便会<strong>记录每个子节点创建的先后顺序</strong>。它的格式为“%10d”(10 位数字，没有数值的数位用 0 补充，例如“0000000001”)。</p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/1584240804281.jpg" alt="" loading="lazy"></figure>
<p>这样便会存在四种类型的 <code>Znode</code> 节点，分别对应：</p>
<ul>
<li><code>PERSISTENT</code>：永久节点</li>
<li><code>EPHEMERAL</code>：临时节点</li>
<li><code>PERSISTENT_SEQUENTIAL</code>：永久节点、序列化</li>
<li><code>EPHEMERAL_SEQUENTIAL</code>：临时节点、序列化</li>
</ul>
<h1 id="4-zookeeper-watcher">4． ZooKeeper Watcher</h1>
<p><code>ZooKeeper</code> 提供了分布式数据<strong>发布/订阅功能</strong>，一个典型的发布/订阅模型系统定义了一种一对多的订阅关系，能让多个订阅者同时监听某一个主题对象，当这个主题对象自身状态变化时，会通知所有订阅者，使他们能够做出相应的处理。</p>
<p><code>ZooKeeper</code> 中，引入了 <strong>Watcher 机制来实现这种分布式的通知功能</strong> 。 <code>ZooKeeper</code> 允许客户端向服务端注册一个 <code>Watcher</code> 监听，当服务端的一些事件触发了这个 <code>Watcher</code>，那么就会向指定客户端发送一个事件通知来实现分布式的通知功能。</p>
<p>触发事件种类很多，如：节点创建，节点删除，节点改变，子节点改变等。</p>
<p>总的来说可以概括 <code>Watcher</code> 为以下三个过程：<strong>客户端向服务端注册 <code>Watcher</code>、服务端事件发生触发 <code>Watcher</code>、客户端回调 <code>Watcher</code> 得到触发事件情况</strong></p>
<h2 id="41-watch-机制特点">4.1． Watch 机制特点</h2>
<h3 id="一次性触发"><strong>一次性触发</strong></h3>
<p>事件发生触发监听，一个 <code>watcher event</code> 就会被发送到设置监听的客户端，这种效果是一次性的，后续再次发生同样的事件，不会再次触发。</p>
<h3 id="事件封装"><strong>事件封装</strong></h3>
<p><code>ZooKeeper</code> 使用 <code>WatchedEvent</code> 对象来封装服务端事件并传递。</p>
<p><code>WatchedEvent</code> 包含了每一个事件的三个基本属性：</p>
<p><strong>通知状态（<code>keeperState</code>），事件类型（<code>EventType</code>）和节点路径（<code>path</code>）</strong></p>
<h3 id="event-异步发送"><strong>event 异步发送</strong></h3>
<p><code>watcher</code> 的通知事件从服务端发送到客户端是异步的。</p>
<h3 id="先注册再触发"><strong>先注册再触发</strong></h3>
<p><code>Zookeeper</code> 中的 <code>watch</code> 机制，必须客户端先去服务端注册监听，这样事件发送才会触发监听，通知给客户端。</p>
<h1 id="5-zookeeper-选举机制">5． ZooKeeper 选举机制</h1>
<p><code>zookeeper</code> 默认的算法是 <code>FastLeaderElection</code>，采用投票数大于半数则胜出的逻辑。</p>
<h2 id="51-概念">5.1． 概念</h2>
<p><strong>服务器 ID</strong></p>
<ul>
<li>比如有三台服务器，编号分别是 1,2,3。</li>
<li>编号越大在选择算法中的权重越大。</li>
</ul>
<p><strong>选举状态</strong></p>
<ul>
<li><code>LOOKING</code>，竞选状态。</li>
<li><code>FOLLOWING</code>，随从状态，同步 <code>leader</code> 状态，参与投票。</li>
<li><code>OBSERVING</code>，观察状态,同步 <code>leader</code> 状态，不参与投票。</li>
<li><code>LEADING</code>，领导者状态。</li>
</ul>
<p><strong>数据 ID</strong></p>
<ul>
<li>服务器中存放的最新数据 <code>version</code>。</li>
<li>值越大说明数据越新，在选举算法中数据越新权重越大。</li>
</ul>
<p><strong>逻辑时钟</strong></p>
<p>也叫投票的次数，同一轮投票过程中的逻辑时钟值是相同的。每投完一次票这个数据就会增加，然后与接收到的其它服务器返回的投票信息中的数值相比，根据不同的值做出不同的判断。</p>
<h2 id="52-全新集群选举">5.2． 全新集群选举</h2>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/1584240883089.png" alt="" loading="lazy"></figure>
<p>假设目前有 5 台服务器，<strong>每台服务器均没有数据</strong>，它们的编号分别是1,2,3,4,5,<strong>按编号依次启动</strong>，它们的选择举过程如下：</p>
<ul>
<li>服务器 1 启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器 1 的状态一直属于 <code>Looking</code>。</li>
<li>服务器 2 启动，给自己投票，同时与之前启动的服务器 1 交换结果，由于服务器 2 的编号大所以服务器 2 胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是 <code>LOOKING</code>。</li>
<li>服务器 3 启动，给自己投票，同时与之前启动的服务器 1,2 交换信息，由于服务器 3 的编号最大所以服务器 3 胜出，此时投票数正好大于半数，所以服务器 3 成为领导者，服务器 1,2 成为小弟。</li>
<li>服务器 4 启动，给自己投票，同时与之前启动的服务器 1,2,3 交换信息，尽管服务器 4 的编号大，但之前服务器 3 已经胜出，所以服务器 4 只能成为小弟。</li>
<li>服务器 5 启动，后面的逻辑同服务器 4 成为小弟。</li>
</ul>
<h2 id="53-非全新集群选举">5.3． 非全新集群选举</h2>
<p>对于运行正常的 <code>zookeeper</code> 集群，中途有机器 <code>down</code> 掉，需要重新选举时，选举过程就需要加入<strong>数据 ID</strong>、<strong>服务器 ID</strong> 和<strong>逻辑时钟</strong>。</p>
<p>数据 ID：数据新的 <code>version</code> 就大，数据每次更新都会更新 <code>version</code>。</p>
<p>服务器 ID：就是我们配置的 <code>myid</code> 中的值，每个机器一个。</p>
<p>逻辑时钟：这个值从 0 开始递增,每次选举对应一个值。 如果在同一次选举中,这个值是一致的。</p>
<p>这样选举的标准就变成：</p>
<p>1、逻辑时钟小的选举结果被忽略，重新投票；</p>
<p>2、统一逻辑时钟后，数据 id 大的胜出；</p>
<p>3、数据 id 相同的情况下，服务器 id 大的胜出；根据这个规则选出 <code>leader</code>。</p>
<h1 id="6-zookeeper-典型应用">6． ZooKeeper 典型应用</h1>
<h2 id="61-数据发布与订阅配置中心">6.1． 数据发布与订阅（配置中心）</h2>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/1584241030128.png" alt="" loading="lazy"></figure>
<p>发布与订阅模型，即所谓的配置中心，顾名思义就是<strong>发布者将数据发布到 ZK节点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新</strong>。</p>
<p>应用在启动的时候会主动来获取一次配置，同时，在节点上注册一个 <code>Watcher</code>，这样一来，以后每次配置有更新的时候，都会实时通知到订阅的客户端，从来达到获取最新配置信息的目的。比如：</p>
<p>分布式搜索服务中，索引的元信息和服务器集群机器的节点状态存放在 ZK 的一些指定节点，供各个客户端订阅使用。</p>
<p>注意：适合<strong>数据量很小的场景</strong>，这样数据更新可能会比较快。</p>
<h2 id="62-命名服务naming-service">6.2． 命名服务(Naming Service)</h2>
<p>在分布式系统中，<strong>通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息</strong>。被命名的实体通常可以是集群中的机器，提供的服务地址，远程对象等等——这些我们都可以统称他们为名字（Name）。其中较为常见的就是一些分布式服务框架中的服务地址列表。通过<strong>调用 ZK 提供的创建节点的 API</strong>，能够很容易创建一个<strong>全局唯一的 path</strong>，这个 path 就可以作为一个名称。</p>
<p>阿里巴巴集团开源的分布式服务框架 <strong>Dubbo 中使用 ZooKeeper 来作为其命名服务</strong>，维护全局的服务地址列表。</p>
<h2 id="63-分布式锁">6.3． 分布式锁</h2>
<p>分布式锁，这个主要得益于 <code>ZooKeeper</code> 保证了数据的强一致性。锁服务可以分为两类，一个是<strong>保持独占</strong>，另一个是<strong>控制时序</strong>。</p>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/1584241059824.png" alt="" loading="lazy"></figure>
<p>所谓<strong>保持独占</strong>，就是所有试图来获取这个锁的客户端，最终只有一个可以成功获得这把锁。通常的做法是把 zk 上的一个 <code>znode</code> 看作是一把锁，通过 <code>create znode</code> 的方式来实现。所有客户端都去创建 <code>/distribute_lock</code> <strong>临时非序列化</strong>节点，最终成功创建的那个客户端也即拥有了这把锁。</p>
<p><strong>控制时序</strong>，就是所有试图来获取这个锁的客户端，最终都是会被安排执行，只是有个全局时序了。做法和上面基本类似，只是这里<code>/distribute_lock</code> 已经预先存在，客户端在它下面创建<strong>临时有序</strong>节点（这个可以通过节点的属性控制：<code>CreateMode.EPHEMERAL_SEQUENTIAL</code> 来指定）。Zk 的父节点（<code>/distribute_lock</code>）维持一份 <code>sequence</code>,保证子节点创建的时序性，从而也形成了每个客户端的全局时序。</p>
<h1 id="7-zab-协议">7． ZAB 协议？</h1>
<p>ZAB 协议是为分布式协调服务 Zookeeper 专门设计的一种支持崩溃恢复的原子广播协议。<br>
ZAB 协议包括两种基本的模式：<strong>崩溃恢复</strong>和<strong>消息广播</strong>。<br>
当整个 zookeeper 集群刚刚启动或者 Leader 服务器宕机、重启或者网络故障导致不存在过半的服务器与 Leader 服务器保持正常通信时，所有进程（服务器）进入崩溃恢复模式，首先选举产生新的 Leader 服务器，然后集群中 Follower 服务器开始与新的 Leader 服务器进行数据同步，当集群中超过半数机器与该 Leader服务器完成数据同步之后，退出恢复模式进入消息广播模式，Leader 服务器开始接收客户端的事务请求生成事物提案来进行事务请求处理。</p>
<h1 id="7-cap-定理">7． CAP 定理？</h1>
<p>一个分布式系统不可能同时满足以下三种,<strong>一致性</strong>（C:Consistency）,<strong>可用性</strong>（A:Available）,<strong>分区容错性</strong>（P:Partition Tolerance）.在此ZooKeeper保证的是CP，ZooKeeper不能保证每次服务请求的可用性，在极端环境下，ZooKeeper可能会丢弃一些请求，消费者程序需要重新请求才能获得结果。另外在进行leader选举时集群都是不可用，所以说，ZooKeeper不能保证服务可用性。（Base理论CA强一致性和最终一致性）</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#1-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-zookeeper-%E7%9A%84%E8%AE%A4%E8%AF%86">1. 谈谈你对 Zookeeper 的认识</a>
<ul>
<li><a href="#zookeeper-%E9%9B%86%E7%BE%A4%E8%A7%92%E8%89%B2">Zookeeper 集群角色</a>
<ul>
<li><a href="#leader">Leader:</a></li>
<li><a href="#follower">Follower:</a></li>
<li><a href="#observer">Observer:</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-zookeeper-%E7%89%B9%E6%80%A7">2. ZooKeeper 特性</a></li>
<li><a href="#3-zookeeper-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B">3． ZooKeeper 数据模型</a>
<ul>
<li><a href="#31%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BE">3.1．数据结构图</a></li>
<li><a href="#32%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B">3.2．节点类型</a></li>
</ul>
</li>
<li><a href="#4-zookeeper-watcher">4． ZooKeeper Watcher</a>
<ul>
<li><a href="#41-watch-%E6%9C%BA%E5%88%B6%E7%89%B9%E7%82%B9">4.1． Watch 机制特点</a>
<ul>
<li><a href="#%E4%B8%80%E6%AC%A1%E6%80%A7%E8%A7%A6%E5%8F%91"><strong>一次性触发</strong></a></li>
<li><a href="#%E4%BA%8B%E4%BB%B6%E5%B0%81%E8%A3%85"><strong>事件封装</strong></a></li>
<li><a href="#event-%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81"><strong>event 异步发送</strong></a></li>
<li><a href="#%E5%85%88%E6%B3%A8%E5%86%8C%E5%86%8D%E8%A7%A6%E5%8F%91"><strong>先注册再触发</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-zookeeper-%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6">5． ZooKeeper 选举机制</a>
<ul>
<li><a href="#51-%E6%A6%82%E5%BF%B5">5.1． 概念</a></li>
<li><a href="#52-%E5%85%A8%E6%96%B0%E9%9B%86%E7%BE%A4%E9%80%89%E4%B8%BE">5.2． 全新集群选举</a></li>
<li><a href="#53-%E9%9D%9E%E5%85%A8%E6%96%B0%E9%9B%86%E7%BE%A4%E9%80%89%E4%B8%BE">5.3． 非全新集群选举</a></li>
</ul>
</li>
<li><a href="#6-zookeeper-%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8">6． ZooKeeper 典型应用</a>
<ul>
<li><a href="#61-%E6%95%B0%E6%8D%AE%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83">6.1． 数据发布与订阅（配置中心）</a></li>
<li><a href="#62-%E5%91%BD%E5%90%8D%E6%9C%8D%E5%8A%A1naming-service">6.2． 命名服务(Naming Service)</a></li>
<li><a href="#63-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">6.3． 分布式锁</a></li>
</ul>
</li>
<li><a href="#7-zab-%E5%8D%8F%E8%AE%AE">7． ZAB 协议？</a></li>
<li><a href="#7-cap-%E5%AE%9A%E7%90%86">7． CAP 定理？</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://epitomm.github.io/post/gridea-jian-ce-yuan-cheng-lian-jie-shi-bai/">
              <h3 class="post-title">
                Gridea 检测远程连接失败
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '974bd77fbbd52c2a0647',
    clientSecret: '6344370ca1314dbd553f45e75a2121a160ef1c44',
    repo: 'EpitomM.github.io',
    owner: 'EpitomM',
    admin: ['EpitomM'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/EpitomM/EpitomM.github.io" target="_blank">EpitomM</a>
  <a class="rss" href="https://epitomm.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
