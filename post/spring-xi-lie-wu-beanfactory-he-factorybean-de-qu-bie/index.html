<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Spring系列（五）BeanFactory和FactoryBean的区别 | SSM</title>
<link rel="shortcut icon" href="https://epitomm.github.io/favicon.ico?v=1589443179957">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://epitomm.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Spring系列（五）BeanFactory和FactoryBean的区别 | SSM - Atom Feed" href="https://epitomm.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="BeanFactory 和 FactoryBean 的区别？

BeanFactory 是 Spring 提供的一个工厂，能够产生对象。通过 getBean(&quot;xxx&quot;) 能够得到一个 Bean。
FactoryBean..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://epitomm.github.io">
  <img class="avatar" src="https://epitomm.github.io/images/avatar.png?v=1589443179957" alt="">
  </a>
  <h1 class="site-title">
    SSM
  </h1>
  <p class="site-description">
    热心善良的老学姐
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Spring系列（五）BeanFactory和FactoryBean的区别
            </h2>
            <div class="post-info">
              <span>
                2020-05-05
              </span>
              <span>
                12 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="beanfactory-和-factorybean-的区别">BeanFactory 和 FactoryBean 的区别？</h1>
<ul>
<li>BeanFactory 是 Spring 提供的一个工厂，能够产生对象。通过 getBean(&quot;xxx&quot;) 能够得到一个 Bean。</li>
<li>FactoryBean 是一个 Bean：把一个对象交给 Spring 管理，就可以称之为一个 Bean，就是一个对象，FactoryBean 就是一个受 Spring 管理的对象。
<ul>
<li>当一个类的依赖关系很复杂，而我们想对外提供简单的关系，就让外部可以使用时，就使用 FactoryBean，经典场景：MyBatis 中的 SqlSessionFactoryBean 对象。</li>
<li>如果类实现了 FactoryBean，那么 Spring 容器当中存在两个对象，一个是 getObject() 方法返回的对象（name=当前类名）；还有一个是当前对象（name=&amp;+当前类名）。</li>
</ul>
</li>
</ul>
<h1 id="spring-中声明一个-bean-的方式">Spring 中声明一个 Bean 的方式</h1>
<ul>
<li>
<bean>
</li>
<li>@Service</li>
<li>@Bean</li>
</ul>
<h1 id="factorybean">FactoryBean</h1>
<pre><code class="language-java">// 表明这是一个 xml 文件
@Configuration
// 注解扫描包
@ComponentScan(&quot;com.ssm&quot;)
public class SpringConfig {
}
</code></pre>
<p>如果类实现了 FactoryBean，那么 Spring 容器当中存在两个对象，一个是 getObject() 方法返回的对象 TempDaoFactoryBean；还有一个是当前对象 DaoFactoryBean。</p>
<p>在 Spring 容器中存储时，存储的 name 值是：</p>
<p>getObject() 得到对象：TempDaoFactoryBean 存的名字是当前类指定的名字：daoFactoryBean；</p>
<p>当前对象 DaoFactoryBean 是 &quot;&amp;&quot; + 当前类的名字：&amp;daoFactoryBean</p>
<pre><code class="language-java">@Component(&quot;daoFactoryBean&quot;)
public class DaoFactoryBean implements FactoryBean {

    public void testBean(){
        System.out.println(&quot;testBean...&quot;);
    }

    @Override
    public Object getObject() throws Exception {
        return new TempDaoFactoryBean();
    }

    @Override
    public Class&lt;?&gt; getObjectType() {
        return TempDaoFactoryBean.class;
    }

    @Override
    public boolean isSingleton() {
        return true;
    }
}
</code></pre>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        DaoFactoryBean daoFactoryBean = (DaoFactoryBean) context.getBean(&quot;daoFactoryBean&quot;);
        daoFactoryBean.testBean();
    }
}
</code></pre>
<pre><code>Exception in thread &quot;main&quot; java.lang.ClassCastException: com.ssm.dao.TempDaoFactoryBean cannot be cast to com.ssm.dao.DaoFactoryBean	at com.ssm.test.Test.main(Test.java:13)
</code></pre>
<p>ClassCastException：类型转换异常。将一个对象通过 @Component(&quot;daoFactoryBean&quot;) 放到 Spring 容器中，然后通过context.getBean(&quot;daoFactoryBean&quot;) 结果却类型转换异常。</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        TempDaoFactoryBean daoFactoryBean = (TempDaoFactoryBean) context.getBean(&quot;daoFactoryBean&quot;);
        daoFactoryBean.test();

    }
}
</code></pre>
<pre><code>FactoryBean...
</code></pre>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        TempDaoFactoryBean daoFactoryBean = (TempDaoFactoryBean) context.getBean(&quot;daoFactoryBean&quot;);
        daoFactoryBean.test();

        DaoFactoryBean bean = (DaoFactoryBean) context.getBean(&quot;&amp;daoFactoryBean&quot;);
        bean.testBean();

    }
}
</code></pre>
<pre><code>FactoryBean...
testBean...
</code></pre>
<h2 id="final-string-beanname-transformedbeannamename">final String beanName = transformedBeanName(name);</h2>
<ul>
<li>通过 name 获取 beanName</li>
</ul>
<p>通过 name 获取 beanName，这里不使用 name 直接作为 beanName 有两个原因：</p>
<p>1.name 可能会以 &amp; 字符开头，表名调用者想获取 FactoryBean 本身，而非 FactoryBean 实现类锁创建的 bean。在 Spring 工厂中，FactoryBean 的实现类和其他的普通 bean 存储方式是一致的，即&lt;beanName, bean&gt;，beanName 中是没有 &amp; 这个字符的。所以我们需要将 name 的首字符 &amp; 移除，这样才能从缓存里取到 FactoryBean 实例。</p>
<p>2.还是别名的问题 <alias>.，转换需要</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/transformedBeanName.png" alt="图片" loading="lazy"></figure>
<p>如果有一个类相当复杂，里面有很多依赖，就要配置很多 <property>，有可能有的依赖还得不到。</p>
<pre><code class="language-xml">&lt;bean id=&quot;temp&quot; class=&quot;com.ssm.dao.TempDaoFactoryBean&quot;&gt;
  &lt;!--假设这个类内有很多属性，就要配置很多 &lt;property&gt;--&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="language-java">public class TempDaoFactoryBean{
  Util util;
  Config config;
  String str1;
  String str2;
}
</code></pre>
<p>假如上述类是第三方框架写的，由于是第三方框架代码，不可能到它的源码上去添加@Component注解：</p>
<p>解决办法1.在 xml 配置这个类；</p>
<p>解决办法2.通过 JavConfig 把它 new 出来，然后添加一个 @Bean 标签</p>
<pre><code class="language-java">// 表明这是一个 xml 文件
@Configuration
// 注解扫描包
@ComponentScan(&quot;com.ssm&quot;)
public class SpringConfig {

    @Bean
    public DataSource dataSource(){
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
        dataSource.setUsername(&quot;root&quot;);
        dataSource.setPassword(&quot;123456&quot;);
        dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);
        return dataSource;
    }

    @Bean
    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){
        SqlSessionFactoryBean sqlSessionFactoryBean =  new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource);
        return sqlSessionFactoryBean;
    }
}
</code></pre>
<h1 id="比如在-spring-中引入第三方工具-mybatis">比如在 Spring 中引入第三方工具 Mybatis</h1>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7.png" alt="图片" loading="lazy"></figure>
<p>1.在 bean 中配置一个 SqlSessionFactory</p>
<pre><code class="language-xml">&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.apache.ibatis.session.defaults.DefaultSqlSessionFactory&quot;&gt;&lt;/bean&gt;
</code></pre>
<p>2.我们发现 SqlSessionFactory 依赖了 Configuration，于是在 <bean> 配置 Configuration</p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/SqlSessionFactory%E4%BE%9D%E8%B5%96Configuration.png" alt="图片" loading="lazy"></figure>
<pre><code class="language-xml">&lt;bean id=&quot;configuration&quot; class=&quot;org.apache.ibatis.session.Configuration&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.apache.ibatis.session.defaults.DefaultSqlSessionFactory&quot;&gt;
    &lt;constructor-arg ref=&quot;configuration&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre>
<p>3.Configuration 有超级多依赖，就需要在 <bean> 内添加很多 <property></p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/Configuration%E6%9C%89%E5%BE%88%E5%A4%9A%E4%BE%9D%E8%B5%96.png" alt="图片" loading="lazy"></figure>
<pre><code class="language-xml">&lt;bean id=&quot;configuration&quot; class=&quot;org.apache.ibatis.session.Configuration&quot;&gt;
  &lt;property&gt;&lt;/property&gt;
  &lt;property&gt;&lt;/property&gt;
  &lt;property&gt;&lt;/property&gt;
  &lt;property&gt;&lt;/property&gt;
  // ......
  &lt;property&gt;&lt;/property&gt;
  &lt;property&gt;&lt;/property&gt;
  &lt;property&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.apache.ibatis.session.defaults.DefaultSqlSessionFactory&quot;&gt;
    &lt;constructor-arg ref=&quot;configuration&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre>
<p>如此自己配置第三方依赖，操作太过复杂，最好的办法是 MyBatis 自己把 Configuration 这些复杂依赖关系都维护好，我们直接引入即可：</p>
<pre><code class="language-xml">&lt;bean id=&quot;dao&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/bean&gt;
</code></pre>
<p>但是 MyBatis 无法更改我们的配置文件，所以它没有地方去配置，于是它提供了一个 SqlSessionFactoryBean 类，在这个类中把这些依赖关系都维护好了。</p>
<h2 id="sqlsessionfactorybean">SqlSessionFactoryBean</h2>
<p>Mybatis在 SqlSessionFactoryBean 内部维护了各种依赖关系：</p>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/SqlSessionFactoryBean.png" alt="图片" loading="lazy"></figure>
<p>最终返回的对象是 SqlSessionFactory</p>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/SqlSessionFactoryBean%E8%BF%94%E5%9B%9ESqlSessionFactory.png" alt="图片" loading="lazy"></figure>
<p>afterPropertiesSet()</p>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/afterPropertiesSet.png" alt="图片" loading="lazy"></figure>
<p>buildSqlSessionFactory()</p>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/buildSqlSessionFactory.png" alt="图片" loading="lazy"></figure>
<p>MyBatis 内部通过 SqlSessionFactoryBean 维护了各种依赖关系，我们只需直接使用 SqlSessionFactoryBean 对象即可获得 SqlSessionFactory，无需再手动维护各种依赖。</p>
<h2 id="mybatis-通过-sqlsessionfactorybeansetdatasourcedatasource">MyBatis 通过 sqlSessionFactoryBean.setDataSource(dataSource);</h2>
<pre><code class="language-java">@Bean
public DataSource dataSource(){
    DriverManagerDataSource dataSource = new DriverManagerDataSource();
    dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
    dataSource.setUsername(&quot;root&quot;);
    dataSource.setPassword(&quot;123456&quot;);
    dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);
    return dataSource;
}
@Bean
public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){
    SqlSessionFactoryBean sqlSessionFactoryBean =  new SqlSessionFactoryBean();
    sqlSessionFactoryBean.setDataSource(dataSource);
    return sqlSessionFactoryBean;
}
</code></pre>
<h2 id="自定义通过-tempdaofactorybeansetmsg1str">自定义通过 TempDaoFactoryBean.setMsg1(str);</h2>
<p>1.JavaConfig 配置文件</p>
<pre><code class="language-java">// 表明这是一个 xml 文件
@Configuration
// 注解扫描包
@ComponentScan(&quot;com.ssm&quot;)
// 扫描 xml 配置文件
@ImportResource(&quot;classpath:spring.xml&quot;)
public class SpringConfig {
}
</code></pre>
<p>2.配置文件 xml 内配置 DaoFactoryBean 对象</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
       
    &lt;bean id=&quot;daoFactory&quot; class=&quot;com.ssm.dao.DaoFactoryBean&quot;&gt;
        &lt;property name=&quot;msg&quot; value=&quot;msg1,msg2,msg3&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>3.DaoFactoryBean 内有一属性 msg</p>
<pre><code class="language-java">public class DaoFactoryBean implements FactoryBean {
    private String msg;
    public void setMsg(String msg) {
        this.msg = msg;
    }
    @Override
    public Object getObject() throws Exception {
        TempDaoFactoryBean temp = new TempDaoFactoryBean();
        String[] msgArray = msg.split(&quot;,&quot;);
        temp.setMsg1(msgArray[0]);
        temp.setMsg2(msgArray[1]);
        temp.setMsg3(msgArray[2]);
        return temp;
    }
    @Override
    public Class&lt;?&gt; getObjectType() {
        return TempDaoFactoryBean.class;
    }
    @Override
    public boolean isSingleton() {
        return true;
    }
}
</code></pre>
<p>4.TempDaoFactoryBean 内有三个属性：msg1、msg2、msg3</p>
<pre><code class="language-java">public class TempDaoFactoryBean {

    private String msg1;
    private String msg2;
    private String msg3;

    public void test(){
        System.out.println(&quot;FactoryBean...&quot;);
    }

    public void setMsg1(String msg1) {
        this.msg1 = msg1;
    }

    public void setMsg2(String msg2) {
        this.msg2 = msg2;
    }

    public void setMsg3(String msg3) {
        this.msg3 = msg3;
    }

    public String getMsg1() {
        return msg1;
    }

    public String getMsg2() {
        return msg2;
    }

    public String getMsg3() {
        return msg3;
    }
}
</code></pre>
<p>5.测试类</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        TempDaoFactoryBean temp = (TempDaoFactoryBean) context.getBean(&quot;daoFactory&quot;);
        System.out.println(temp.getMsg1());

    }
}
</code></pre>
<p>6.测试结果：</p>
<pre><code>msg1
</code></pre>
<pre><code class="language-java">@PostConstruct // 当 bean 实例化时，回调这个注解修饰的方法，进行初始化操作，比如 Redis 预热场景。
public void init(){
}
</code></pre>
<h1 id="spring-如何完成扫描">Spring 如何完成扫描</h1>
<h2 id="如何初始化-spring-环境">如何初始化 Spring 环境？</h2>
<ul>
<li>xml：ClassPathXmlApplicationContext；
<ul>
<li>类的扫描</li>
<li>单独 bean 的注册：在 xml 中写一个<bean>，只要这个 xml 被解析，Spring 就帮助完成了 bean 的声明（定义<bean>）和注册（Spring 会自动创建一个对象放到容器中）</li>
</ul>
</li>
<li>注解 Annotation：必须借助 xml:&lt;context:component-scan base-package=&quot;com.ssm&quot;/&gt;或 JavaConfig:@ComponentScan 完成对类的扫描；</li>
<li>JavaConfig：AnnotationConfigApplicationContext。
<ul>
<li>类的扫描</li>
<li>类的定义：如果只是写了一个@Component，并没有扫描这个类，称为只是定义一个 bean，并没有类的注册（因为没有被扫描 ）</li>
</ul>
</li>
</ul>
<p>为什么要初始化 Spring 环境？</p>
<p>把我们交给 Spring 管理的类实例化</p>
<pre><code class="language-java">@Servicepublic class IndexService {}
</code></pre>
<pre><code class="language-java">// 表明这是一个 xml 文件
@Configuration
// 注解扫描包
@ComponentScan(&quot;com.ssm&quot;)
public class SpringConfig {
</code></pre>
<p>register() 可以注册两种类型的 bean：1.加了 @Configuration 的 bean；2.普通的 bean</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();

        context.register(SpringConfig.class);
        context.refresh();

        // register() 可以注册两种类型的 bean：加了 @Configuration 的 bean；普通的 bean
//        context.register(TestService.class);
        IndexService indexService = (IndexService) context.getBean(&quot;indexService&quot;);
        System.out.println(indexService);
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>com.ssm.service.IndexService@1a451d4d
</code></pre>
<p>AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);</p>
<p>![图片](https://epitomm.github.io/post-images/通过配置文件new AnnotationConfigApplicationContext.png)<br>
<img src="https://epitomm.github.io/post-images/register.png" alt="图片" loading="lazy"></p>
<p>context.register(SpringConfig.class);</p>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/register.png" alt="图片" loading="lazy"></figure>
<p>配置文件不扫描包，使用 register() 单独注册某个类</p>
<pre><code class="language-java">// 表明这是一个 xml 文件
@Configuration
// 注解扫描包
//@ComponentScan(&quot;com.ssm&quot;)
public class SpringConfig {
</code></pre>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
        // register() 注册加了 @Configuration 的 bean
        context.register(SpringConfig.class);
        // register() 注册普通的 bean
        context.register(IndexService.class);
        context.refresh();

        IndexService indexService = (IndexService) context.getBean(&quot;indexService&quot;);
        System.out.println(indexService);
    }
}
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/%E8%AF%BB%E5%8F%96JavaConfig%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/AnnotationConfigApplicationContext%E6%BA%90%E7%A0%81.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/register%E6%BA%90%E7%A0%81.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/register%E6%BA%90%E7%A0%81_2.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/registerBean%E6%BA%90%E7%A0%81.png" alt="图片" loading="lazy"></figure>
<p>context.scan(&quot;com.ssm&quot;); 也可以完成扫描：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();

        context.register(SpringConfig.class);
        context.scan(&quot;com.ssm&quot;);
        context.refresh();

        IndexService indexService = (IndexService) context.getBean(&quot;indexService&quot;);
        System.out.println(indexService);

    }
}
</code></pre>
<p><img src="https://epitomm.github.io/post-images/scan%E6%BA%90%E7%A0%81.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/scan%E6%BA%90%E7%A0%81_2.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/doScan.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/doScan%E6%89%AB%E6%8F%8F%E5%AE%8C%E6%88%90.png" alt="图片" loading="lazy"></p>
<p>进行类的扫描时，添加一个依赖，就可以按索引扫描，加快扫描速度。<br>
<img src="https://epitomm.github.io/post-images/findCandidateComponents.png" alt="图片" loading="lazy"></p>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/scanCandidateComponents.png" alt="图片" loading="lazy"></figure>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
public @interface Anno {
    public String value();
}
</code></pre>
<pre><code class="language-java">@Anno(&quot;userServiceImpl&quot;)
public class UserServiceImpl implements UserService {
</code></pre>
<pre><code class="language-java">public class AnnotationConfigApplicationContext {

    public void scan(String basePackage){
        // 1.通过文件名得到 .class 文件，然后去掉 .class 就是最终的类名
        // 得到根目录
        String rootPath = this.getClass().getResource(&quot;/&quot;).getPath();
        // 2. 将 com.ssm 变为 com/ssm/
        String basePackagePath = basePackage.replaceAll(&quot;\\.&quot;,&quot;\\\\&quot;);

        File file = new File(rootPath + &quot;//&quot; + basePackagePath);
        // 得到所有文件名的数组
        String[] names = file.list();
        for (String name : names) {
            // 去掉文件的 .class 就得到了类名
            name = name.replaceAll(&quot;.class&quot;,&quot;&quot;);
            // 得到所有的文件名
            try {
                Class&lt;?&gt; clazz = Class.forName(basePackage + &quot;.&quot; + name);
                // 判断是否属于 @Service、@Component...
                // 判断是否加了 @Anno 注解
                if(clazz.isAnnotationPresent(Anno.class)){
                    Anno annotation = (Anno)clazz.getAnnotation(Anno.class);
                    System.out.println(annotation.value());
                    System.out.println(clazz.newInstance());
                }
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            } catch (InstantiationException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<pre><code class="language-java">public class TestAnno {
    public static void main(String[] args) throws SpringException {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
        context.scan(&quot;com.ssm.service.impl&quot;);
    }
}
</code></pre>
<pre><code>userServiceImpl
com.ssm.service.impl.UserServiceImpl@1d44bcfa
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#beanfactory-%E5%92%8C-factorybean-%E7%9A%84%E5%8C%BA%E5%88%AB">BeanFactory 和 FactoryBean 的区别？</a></li>
<li><a href="#spring-%E4%B8%AD%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA-bean-%E7%9A%84%E6%96%B9%E5%BC%8F">Spring 中声明一个 Bean 的方式</a></li>
<li><a href="#factorybean">FactoryBean</a>
<ul>
<li><a href="#final-string-beanname-transformedbeannamename">final String beanName = transformedBeanName(name);</a></li>
</ul>
</li>
<li><a href="#%E6%AF%94%E5%A6%82%E5%9C%A8-spring-%E4%B8%AD%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7-mybatis">比如在 Spring 中引入第三方工具 Mybatis</a>
<ul>
<li><a href="#sqlsessionfactorybean">SqlSessionFactoryBean</a></li>
<li><a href="#mybatis-%E9%80%9A%E8%BF%87-sqlsessionfactorybeansetdatasourcedatasource">MyBatis 通过 sqlSessionFactoryBean.setDataSource(dataSource);</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%80%9A%E8%BF%87-tempdaofactorybeansetmsg1str">自定义通过 TempDaoFactoryBean.setMsg1(str);</a></li>
</ul>
</li>
<li><a href="#spring-%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E6%89%AB%E6%8F%8F">Spring 如何完成扫描</a>
<ul>
<li><a href="#%E5%A6%82%E4%BD%95%E5%88%9D%E5%A7%8B%E5%8C%96-spring-%E7%8E%AF%E5%A2%83">如何初始化 Spring 环境？</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://epitomm.github.io/post/spring-xi-lie-si-xml-mo-ni-springioc/">
              <h3 class="post-title">
                Spring系列（四）XML模拟SpringIOC
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '974bd77fbbd52c2a0647',
    clientSecret: '6344370ca1314dbd553f45e75a2121a160ef1c44',
    repo: 'EpitomM.github.io',
    owner: 'EpitomM',
    admin: ['EpitomM'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/EpitomM/EpitomM.github.io" target="_blank">EpitomM</a>
  <a class="rss" href="https://epitomm.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
