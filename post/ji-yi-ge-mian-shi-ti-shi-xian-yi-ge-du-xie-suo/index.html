<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>记一个面试题 —— 实现一个读写锁 | SSM</title>
<link rel="shortcut icon" href="https://epitomm.github.io/favicon.ico?v=1587280044737">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://epitomm.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="记一个面试题 —— 实现一个读写锁 | SSM - Atom Feed" href="https://epitomm.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="用共享对象实现写优先的读者写者锁
首先，我们实现一个读者/写者锁。类似于一个普通的互斥锁，一个读者/写者锁(RWLock)保护共享数据。然而，它会做如下的优化。为了最大化性能，一个 RWLock 允许多个“读者”线程同时访问共享数据。任意数..." />
    <meta name="keywords" content="面试题" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://epitomm.github.io">
  <img class="avatar" src="https://epitomm.github.io/images/avatar.png?v=1587280044737" alt="">
  </a>
  <h1 class="site-title">
    SSM
  </h1>
  <p class="site-description">
    热心善良的老学姐
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              记一个面试题 —— 实现一个读写锁
            </h2>
            <div class="post-info">
              <span>
                2020-04-10
              </span>
              <span>
                5 min read
              </span>
              
                <a href="https://epitomm.github.io/tag/1hfOEuf6o1/" class="post-tag">
                  # 面试题
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://epitomm.github.io/post-images/ji-yi-ge-mian-shi-ti-shi-xian-yi-ge-du-xie-suo.png" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="用共享对象实现写优先的读者写者锁">用共享对象实现写优先的读者写者锁</h1>
<p>首先，我们实现一个读者/写者锁。类似于一个普通的互斥锁，一个读者/写者锁(RWLock)保护共享数据。然而，它会做如下的优化。为了最大化性能，一个 RWLock 允许多个“读者”线程同时访问共享数据。任意数量的线程可以在同一时间安全地读共享数据，只要没有线程在修改数据。然而，任意时刻，至多只能有 1 个写者线程可以持有 RWLock（读者线程只能读共享数据，写者线程既可以写也可以读共享数据）。当一个写者线程持有 RWLock，它可以安全地修改数据，因为锁保证了不会有其他的线程同时持有该锁。读者写者锁常常被用于数据库，它们被用于支持对数据库的更快的搜索查询，同时也支持不太频繁的更新。另一个常见的应用是在操作系统内核中，核心的数据结构常常被许多线程读但更新却不太频繁。为了将我们的互斥锁一般化为一个读者/写者锁，我们实现了一个新类型的共享对象，RWLock，来保护对共享数据的访问。RWLock 采用了我们标准化的同步构建模块：互斥锁和条件变量来实现。<br>
一个线程想要（原子地）读共享数据，其过程如下：</p>
<pre><code>rwLock-&gt;startRead();
read shared data
rwLock-&gt;doneRead();
</code></pre>
<p>类似的，一个线程想要（原子地）写共享数据，其过程如下：</p>
<pre><code>rwLock-&gt;startWrite();
Read and write shared data
rwLock-&gt;doneWrite();
</code></pre>
<p>为了设计 RWLock 类，我们首先定义它的接口（如上面代码所示），和它的共享状态。这里，对象的行为可以通过<strong>正在读和正在写的线程的数量和等待读和等代写的线程的数量</strong>来刻画。所以，我们需要 4 个整数来追踪这些值。 代码 5.9 展示了 RWLock 类的成员和接口. 接下来，我们通过提出以下的问题来添加同步变量，“什么时候方法需要等待？”首先，我们添加一个互斥锁：保证当有线程在访问 RWLock 的方法的时候，其他访问 RWLock 的方法的线程必须等待。接下来，我们观察到 startRead 或 startWrite 可能需要等待，因此我们为每种情况添加了一个条件变量：readGo 和 writeGo.</p>
<h2 id="读者写者锁的接口和成员变量">读者/写者锁的接口和成员变量</h2>
<pre><code>class RWLock{
    private:
        //Synchronization variables
        Lock lock;
        CV readGo;
        CV writeGo;

        // State variables
        int activeReaders;
        int activeWriters;
        int waitingReaders;
        int waitingWriters;
    public:
        RWLock();
        ~RWLock(){};
        void startRead();
        void doneRead();
        void startWrite();
        void doneWrite();
    private:
        bool readShouldWait();
        bool writeShouldWait();
} 
</code></pre>
<p>代码 5.9：  我们的读者/写者锁的接口和成员变量<br>
RWLock: doneRead 和 doneWrite 不需要等待（不包括获取互斥锁）。因此，这些方法不需要额外的条件变量。<br>
现在我们实现 RWLock。<br>
首先，我们先给每个方法添加上锁的获取和锁的释放。如下图所示：</p>
<pre><code>void RWLock :: startRead(){
    lock.acquire();

    lock.release();
}

void RWLock::doneRead(){
    lock.acquire();

    lock.release();
}
</code></pre>
<p>RWLock::startWrite 和 RWLock::doneWrite 也类似。</p>
<p>由于我们知道 startRead 和 startWrite 必须等待，因此我们可以在每个方法的中间写上while(…){wait();}的循环。然后，我们开始思考其中的细节，例如循环等待的判断条件。代码 5.10 展示了完整的解法。</p>
<h2 id="读者写者锁完整代码">读者写者锁完整代码</h2>
<pre><code>// Wait until no active or waiting writers,then proceed
void RWLock::startRead(){
    lock.acquire();
    waitingReaders++;
    while(readShouldWait()){
        readGo.Wait(&amp;lock);
    }
    waitingReaders--;
    activeReaders++;
    lock.release();
}

// Done reading.If no other active readers,a write may proceed.
void RWLock::doneRead(){
    lock.acquire();
    activeReaders--;
    if(activeReaders == 0 &amp;&amp; waitingWriters &gt; 0){
        writeGo.signal();
    }
    lock.release();
}

// Read waits if any active or waiting write(&quot;writers preferred&quot;).
bool RWLock::readShouldWait(){
    return (activeWriters &gt; 0 || waitingWriters &gt; 0);
}

// Wait until no active read or write then proceed;
void RWLock::startWrite(){
    lock.acquire();
    waitingWriterw++;
    while(writeShouldWait()){
        writeGo.Wait(&amp;lock);
    }
    waitingWriters--;
    activeWriters++;
    lock.release();
}

// Done writing. A waiting write or read may proceed.
void RWLock::doneWrite(){
    lock.acquire();
    activeWriters--;
    assert(activeWriters == 0);
    if(waitingWriters &gt; 0){
        writeGo.signal();
    }else{
        readGo.broadcast();
    }
    lock.release();
}

// Write waits for active read or write.
bool RWLock::writeShouldWait(){
    return(activeWriters &gt; 0 || activeReaders &gt; 0);
}
</code></pre>
<p>代码 5.10：  一个读者写者锁的实现</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E7%94%A8%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%E5%86%99%E4%BC%98%E5%85%88%E7%9A%84%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%94%81">用共享对象实现写优先的读者写者锁</a>
<ul>
<li><a href="#%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%94%81%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">读者/写者锁的接口和成员变量</a></li>
<li><a href="#%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%94%81%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">读者写者锁完整代码</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://epitomm.github.io/post/redis-chi-jiu-hua/">
              <h3 class="post-title">
                Redis 持久化
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '974bd77fbbd52c2a0647',
    clientSecret: '6344370ca1314dbd553f45e75a2121a160ef1c44',
    repo: 'EpitomM.github.io',
    owner: 'EpitomM',
    admin: ['EpitomM'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/EpitomM/EpitomM.github.io" target="_blank">EpitomM</a>
  <a class="rss" href="https://epitomm.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
