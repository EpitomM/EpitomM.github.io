<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>面试题系列 —— MySQL 数据库 | SSM</title>
<link rel="shortcut icon" href="https://epitomm.github.io/favicon.ico?v=1585793144174">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://epitomm.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="面试题系列 —— MySQL 数据库 | SSM - Atom Feed" href="https://epitomm.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="1.存储引擎

MySQL 默认的存储引擎是 InnoDB

MyISAM 和 InnoDB 的区别




MyISAM
InnoDB




是否支持行级锁
只有表级锁
支持行级锁和表级锁，默认为行级锁


查询性能
强调的是性能，每次..." />
    <meta name="keywords" content="MySQL,面试题" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://epitomm.github.io">
  <img class="avatar" src="https://epitomm.github.io/images/avatar.png?v=1585793144174" alt="">
  </a>
  <h1 class="site-title">
    SSM
  </h1>
  <p class="site-description">
    热心善良的老学姐
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              面试题系列 —— MySQL 数据库
            </h2>
            <div class="post-info">
              <span>
                2020-03-27
              </span>
              <span>
                22 min read
              </span>
              
                <a href="https://epitomm.github.io/tag/RX6u4Mtbp/" class="post-tag">
                  # MySQL
                </a>
              
                <a href="https://epitomm.github.io/tag/1hfOEuf6o1/" class="post-tag">
                  # 面试题
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://epitomm.github.io/post-images/mian-shi-ti-xi-lie-mysql-shu-ju-ku.jpg" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="1存储引擎">1.存储引擎</h1>
<ul>
<li>MySQL 默认的存储引擎是 InnoDB</li>
</ul>
<h2 id="myisam-和-innodb-的区别">MyISAM 和 InnoDB 的区别</h2>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">MyISAM</th>
<th style="text-align:left">InnoDB</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>是否支持行级锁</strong></td>
<td style="text-align:left">只有<strong>表级锁</strong></td>
<td style="text-align:left">支持<strong>行级锁和表级锁</strong>，默认为行级锁</td>
</tr>
<tr>
<td style="text-align:left">查询性能</td>
<td style="text-align:left">强调的是性能，每次查询具有原子性，执行速度快</td>
<td style="text-align:left">使用了聚簇索引、或需要访问的数据可以放入内存的应用下速度快</td>
</tr>
<tr>
<td style="text-align:left"><strong>是否支持事务</strong></td>
<td style="text-align:left">不支持</td>
<td style="text-align:left">支持</td>
</tr>
<tr>
<td style="text-align:left"><strong>是否支持崩溃后的安全恢复</strong></td>
<td style="text-align:left">不支持</td>
<td style="text-align:left">支持。事务、回滚、崩溃修复能力和事务安全型表</td>
</tr>
<tr>
<td style="text-align:left">是否支持外键</td>
<td style="text-align:left">不支持</td>
<td style="text-align:left">支持</td>
</tr>
<tr>
<td style="text-align:left">是否支持 MVCC</td>
<td style="text-align:left">不支持</td>
<td style="text-align:left">支持。应对高并发事务，MVCC比单纯的加锁更高效。MVCC只在READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作；MVCC 可以使用乐观锁和悲观锁来实现。</td>
</tr>
<tr>
<td style="text-align:left">其他功能</td>
<td style="text-align:left">全文索引、压缩、空间函数</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h1 id="2索引">2.索引</h1>
<h2 id="1-聚簇索引与非聚簇索引">(1) 聚簇索引与非聚簇索引</h2>
<ul>
<li>MyISAM：B+ 树叶子节点的 data 域存放的是<strong>数据记录的地址</strong>。在索引检索的时候，首先按照 B+ 树搜索算法搜索索引，如果指定的 key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为 “<strong>非聚簇索引</strong>”。</li>
<li>InnoDB：其数据本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按照 B+ 树组织的一个索引结构。B+ 树叶子节点的 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 <strong>InnoDB 表数据文件本身就是主索引</strong>。这被称为“<strong>聚簇索引</strong>”（或“聚集索引”）。而其余的索引都作为辅助索引，<strong>辅助索引的 data 域存储相应记录主键的值</strong>而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</li>
</ul>
<h2 id="2-hash-索引与-b-数索引">(2) Hash 索引与 B+ 数索引</h2>
<h3 id="hash-索引">Hash 索引</h3>
<ul>
<li>Hash 索引仅仅能满足 &quot;=&quot;、“IN” 的等值查询，不能使用范围查询。</li>
<li>Hash 索引不能利用组合索引的部分索引键查询。</li>
<li>Hash 索引遇到大量 Hash 值相等的情况后性能不一定就会比 B+ 树高。</li>
</ul>
<h3 id="b-树索引">B+ 树索引</h3>
<p>B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，<strong>在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题</strong>。</p>
<h1 id="3什么是事务">3.什么是事务？</h1>
<p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
<h1 id="4事务的四大特征">4.事务的四大特征</h1>
<ul>
<li>原子性（Atomicity）：事务被视为不可分割的最小单元。事务的所有操作要么全部成功提交，要么全部失败回滚。</li>
<li>一致性（Consistency）：数据库在事务执行前后保持一致性状态，多个事务对同一个数据读取的结果是相同的。</li>
<li>隔离性（Isolation）：一个事务所做的修改在最终提交以前，对其他事务是不可见的。</li>
<li>持久性（Durability）：一旦事务提交，则其所做的修改将永远保存在数据库中。即使系统发生崩溃，事务执行的结果页不能丢失。</li>
</ul>
<hr>
<ul>
<li>只有满足一致性，事务的执行结果才是正确的。</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个失误并行执行，事务不仅要满足原子性，还要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对数据库崩溃的情况。</li>
</ul>
<p><strong>AUTOCOMMIT</strong></p>
<p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用 START TRASACTION 语句来开启一个事务，那么每个查询都会被当作一个事务自动提交。</p>
<h1 id="5并发事务带来哪些问题">5.并发事务带来哪些问题？</h1>
<h2 id="1-丢失修改">(1) 丢失修改</h2>
<p>T1 和 T2 两个事务都对一个数据进行修改， T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9.png" alt="图片" loading="lazy"></figure>
<h2 id="2-读脏数据">(2) 读脏数据</h2>
<p>T1 修改一个数据，T2 随后读取这个数据，如果 T1 撤销了这次修改，那么 T2 读取到的数据是脏数据。</p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E8%84%8F%E8%AF%BB.png" alt="图片" loading="lazy"></figure>
<h2 id="3-不可重复读">(3) 不可重复读</h2>
<p>T2 读取一个数据，T1 对这个数据进行了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.png" alt="图片" loading="lazy"></figure>
<h2 id="4-幻影读">(4) 幻影读</h2>
<p>T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围内的数据，此时读取的结果和第一次读取的结果不同。</p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E5%B9%BB%E8%AF%BB.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>不可重复读和幻读的区别：<br>
不可重复读的重点是修改，比如多次读取一条记录发现其中的某些列的值被修改；幻读的重点在于新增或者删除，比如多次读取同一范围发现记录增多或减少了。</p>
</blockquote>
<hr>
<p>产生并发不一致问题主要原因是破坏了事务的隔离性，解决方法时通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>
<h1 id="6事务的隔离级别有哪些">6.事务的隔离级别有哪些？</h1>
<h2 id="1-读未提交read-uncommitted">(1) 读未提交（READ UNCOMMITTED）</h2>
<p>事务中的修改，即使没有提交，对其他事务也是可见的。</p>
<h2 id="2-读已提交read-committed">(2) 读已提交（READ COMMITTED）</h2>
<p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p>
<h2 id="3-可重复读repeatable-read">(3) 可重复读（REPEATABLE READ）</h2>
<p>一个事务在第一次读取过某条记录后，即使其他事务修改了该记录的值并且提交，该<strong>事物之后再读该条记录时，读到的仍是第一次读到的值</strong>。而不是每次都读到不同的数据，这就是可重复读。</p>
<h2 id="4-可串行化serializable">(4) 可串行化（SERIALIZABLE）</h2>
<p>强制事务串行执行。</p>
<p>需要加锁实现，而其它隔离级别通常不需要。</p>
<table>
<thead>
<tr>
<th style="text-align:left">隔离级别</th>
<th style="text-align:left">脏读</th>
<th style="text-align:left">不可重复读</th>
<th style="text-align:left">幻影读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">读未提交</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
</tr>
<tr>
<td style="text-align:left">读已提交</td>
<td style="text-align:left">×</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
</tr>
<tr>
<td style="text-align:left">可重复读</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
<td style="text-align:left">√</td>
</tr>
<tr>
<td style="text-align:left">可串行化</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
</tr>
</tbody>
</table>
<p>MySQL InnoDB 存储引擎默认的隔离级别是<strong>可重复读</strong>。InnoDB 存储引擎在可重读事务隔离级别下使用的是 Next-Key Lock 算法，因此可以避免幻读的产生。</p>
<h1 id="7-锁机制与-innodb-锁算法">7. 锁机制与 InnoDB 锁算法</h1>
<p>MyISAM 和 InnoDB 存储引擎使用的锁</p>
<ul>
<li>MyISAM 使用表级锁</li>
<li>InnoDB 支持行级锁和表级锁，默认使用表级锁</li>
</ul>
<p>行级锁和表级锁的对比：</p>
<ul>
<li>表级锁：MySQL 中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源耗费也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发率最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li>
<li>行级锁：MySQL 中锁定粒度最小的一种锁，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li>
</ul>
<p>InnoDB 存储引擎的锁的算法有三种：</p>
<ul>
<li>Record Lock：单个行记录上的锁</li>
<li>Gap Lock：间隙锁，锁定一个范围，不包括记录本身。GAP锁的⽬的，是为了防⽌同⼀事务的两次当前读，出现幻读的情况。</li>
<li>Next-key Lock：Record + Gap 锁定一个范围，包含记录本身。对于⾏的查询，都是采⽤该⽅ 法，主要⽬的是解决幻读的问题。</li>
</ul>
<p>相关知识点：</p>
<p>1.innodb对于行的查询使用next-key lock</p>
<p>2.Next-locking keying为了解决Phantom Problem幻读问题</p>
<p>3.当查询的索引含有唯一属性时，将next-key lock降级为record key</p>
<p>4.Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生5.有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock）A.将事务隔离级别设置为RCB.将参数innodb_locks_unsafe_for_binlog设置为1</p>
<h1 id="8介绍一下两段锁协议">8.介绍一下两段锁协议</h1>
<ul>
<li>阶段一：<strong>加锁阶段</strong>。在这阶段，事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁。</li>
<li>阶段二：<strong>解锁阶段</strong>。在这阶段，事务可以释放任何数据项上的任何类型的琐，但是不能再申请任何锁。</li>
</ul>
<blockquote>
<p>注意：两段锁协议可能会导致死锁。<br>
<img src="https://epitomm.github.io/post-images/%E4%B8%A4%E6%AE%B5%E9%94%81%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E9%94%81.png" alt="图片" loading="lazy"></p>
</blockquote>
<h1 id="9介绍一下多版本并发控制mvcc">9.介绍一下多版本并发控制（MVCC）</h1>
<p>多版本并发控制（MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现读已提交和可重复读这两种隔离级别。而读未提交总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<p>对于使用 InnoDB 存储引擎的表来说，它的聚簇索引记录中都包三个隐藏列：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>列名</strong></th>
<th style="text-align:center"><strong>是否必须</strong></th>
<th style="text-align:center"><strong>占用空间</strong></th>
<th style="text-align:center"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">row_id</td>
<td style="text-align:center">否</td>
<td style="text-align:center">6字节</td>
<td style="text-align:center">行ID，唯一标识一条记录</td>
</tr>
<tr>
<td style="text-align:center">transaction_id</td>
<td style="text-align:center">是</td>
<td style="text-align:center">6字节</td>
<td style="text-align:center">事务ID</td>
</tr>
<tr>
<td style="text-align:center">roll_pointer</td>
<td style="text-align:center">是</td>
<td style="text-align:center">7字节</td>
<td style="text-align:center">回滚指针</td>
</tr>
</tbody>
</table>
<ul>
<li>trx_id：每次对某条记录进行改动时，都会把对应的 <strong>事务 id</strong> 赋值给 trx_id 列。</li>
<li>roll_pointer：每次对某条记录进行改动时，这个隐藏列都会存一个指针，可以通过这个指针找到该记录修改前的信息（<strong>回滚指针</strong>）。</li>
</ul>
<h2 id="readview">ReadView</h2>
<p>对于使用READ UNCOMMITTED隔离级别的事务来说，直接读取记录的最新版本就好了，对于使用 SERIALIZABLE隔离级别的事务来说，使用加锁的方式来访问记录。对于使用READ COMMITTED 和 REPEATABLE READ 隔离级别的事务来说，就需要用到我们上边所说的版本链了，核心问题就是：<strong>需要判断一<strong><strong>下</strong></strong>版本链中的哪个版本是<strong><strong>当</strong></strong>前事务可见的</strong>。</p>
<p>ReadView 中主要包含4个比较重要的内容：</p>
<ol>
<li>m_ids：表示在生成 ReadView 时当前系统中<strong>活****跃的（未提交的）读写事务的事务id列表</strong>。</li>
<li>min_trx_id：表示在生成 ReadView 时当前系统中<strong>活跃的读写<strong><strong>事</strong></strong>务中最小的事务id</strong>，也就是m_ids 中的最小值。</li>
<li>max_trx_id：表示生成 ReadView 时系统中应该**分配给下一个事务的 id**** **<strong>值</strong>。</li>
<li>creator_trx_id：表示<strong>生<strong><strong>成</strong></strong>该 ReadView 的事务的事务id</strong>。</li>
</ol>
<blockquote>
<p>注意max_trx_id并不是m_ids中的最大值，事务id是递增分配的。比方说现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，m_ids就包括1和2，min_trx_id的值就是1，max_trx_id的值就是4。</p>
</blockquote>
<h2 id="read-commited-实现方式">READ COMMITED 实现方式</h2>
<p><strong>每次读取数据前都生成一个ReadView</strong></p>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4MVCC.png" alt="图片" loading="lazy"></figure>
<h2 id="repeatable-read-实现方式">REPEATABLE READ 实现方式</h2>
<p><strong>在第一次读取数据时生成一个ReadView，第二次读取数据时使用第一次生成的 ReadView。</strong></p>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BBMVCC.png" alt="图片" loading="lazy"></figure>
<h2 id="mvcc总结">MVCC总结</h2>
<p>MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用 READ COMMITTD、 REPEATABLE READ 这两种隔离级别的事务在执行普通的 SEELCT 操作时访问记录的版本链的过程。可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。READ COMMITTD、REPEATABLE READ 这两个隔离级别的一个很大不同就是：<strong>生成ReadView 的时机不同</strong>，READ COMMITTD 在每一次进行普通 SELECT 操作前都会</p>
<p>生成一个 ReadView，而 REPEATABLE READ 只在第一次进行普通 SELECT 操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。</p>
<h1 id="10next-key-locks">10.Next-Key Locks</h1>
<p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p>
<p>MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p>
<h2 id="record-locks">Record Locks</h2>
<p>锁定一个记录上的索引，而不是记录本身。</p>
<p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p>
<h2 id="gap-locks">Gap Locks</h2>
<p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p>
<pre><code>SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
</code></pre>
<h2 id="next-key-locks">Next-Key Locks</h2>
<p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p>
<pre><code>(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +∞)
</code></pre>
<h1 id="11大表优化">11.大表优化</h1>
<p>当 MySQL 单表记录数过大时，数据库的 CRUD 性能会明显下降，一些常见的优化措施如下：</p>
<h2 id="限定数据的范围">限定数据的范围</h2>
<p>务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询历史订单的时候，我们可以控制在一个月的范围内；</p>
<h2 id="读写分离">读/写分离</h2>
<p>经典的数据库拆分方案，主库负责写，从库负责读；</p>
<h2 id="垂直分区">垂直分区</h2>
<p>根据数据库里面数据表的相关性进行拆分。例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>
<p>简单来说垂直拆分是指数据表<strong>列的拆分</strong>，把一张列比较多的表拆分为多张表。如下图所示，这样来说大家应该就更容易理解了。</p>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E5%9E%82%E7%9B%B4%E5%88%86%E5%8C%BA.png" alt="图片" loading="lazy"></figure>
<ul>
<li>垂直拆分的优点：可以使得列数据变小，在查询时减少读取的 Block 数，减少 I/O 次数。此外，垂直分区可以简化表的结构，易于维护。</li>
<li>垂直拆分的缺点：主键会出现冗余，需要管理冗余列，并会引起 join 操作，可以通过在应用层进行 join 来解决。此外，垂直分区会让食物变得更加复杂。</li>
</ul>
<h2 id="水平分区">水平分区</h2>
<p>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。水平拆分可以支撑非常大的数据量。</p>
<p>水平拆分是指数据表<strong>行的拆分</strong>，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/%E6%B0%B4%E5%B9%B3%E5%88%86%E5%8C%BA.png" alt="图片" loading="lazy"></figure>
<p>水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以水平拆分最好分库。</p>
<p>水平拆分能够支持非常大的数据量存储，应用端改造也少，但分片事务难以解决，跨节点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</p>
<p>下面补充一下数据库分片的两种常见方案：</p>
<ul>
<li>客户端代理：分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。当当网的Sharding-JDBC、阿里的TDDL是两种比较常用的实现。</li>
<li>中间件代理：在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。我们现在谈的Mycat、360的Atlas、网易的DDB等等都是这种架构的实现。</li>
</ul>
<p>详细内容可以参考：MySQL大表优化方案：<a href="https://segmentfault.com/a/1190000006158186">https://segmentfault.com/a/1190000006158186</a></p>
<h1 id="12分库分表之后id-主键如何处理">12.分库分表之后，id 主键如何处理？</h1>
<p>因为要分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全剧唯一的 id 来支持。</p>
<p>生成全局 id 有一下这几种方式：</p>
<ul>
<li><strong>UUID</strong>：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标识，比如文件的名字。</li>
<li><strong>数据库自增 id</strong>：两台数据库分别设置不同步长，生成不重复 ID 的策略来实现高可用。这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。</li>
<li><strong>利用 redis 生成 id</strong>：性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。</li>
<li>......</li>
</ul>
<h1 id="13查询语句不同元素where-join-limit-group-by-having等的先后执行顺序">13.查询语句不同元素（where、join、limit、group by、having等）的先后执行顺序？</h1>
<p>查询中使用到的关键字主要包含六个，并且它们的书写顺序依次为：</p>
<p>select —— from —— where —— group by —— having  —— order by</p>
<p>其中 select 和 from 是必须的，其他关键词是可选的，这六个关键词的执行顺序与 sql 语句的书写顺序并不是一样的，而是按照下面的顺序来执行。</p>
<ul>
<li>from：需要从哪个数据库表检索数据</li>
<li>where：过滤表中的数据条件</li>
<li>group by：如何将上面过滤出的数据进行分组</li>
<li>having：对上面已经分组的数据进行过滤的条件</li>
<li>select：查看结果集中的哪个列，或者列的计算结果</li>
<li>order by：按照什么顺序来查看返回的数据</li>
</ul>
<p>from 后面的表关联，是自右向左解析，而 where 条件的解析顺序是自下向上的。</p>
<p>也就是说，在写 SQL 的时候，尽量把数据量小的表放在最右边来进行关联（用小表去匹配大表），而把筛选出销量数据的条件尽量放在 where 语句的最左边（用小表去匹配大表）。</p>
<h1 id="14关系型数据库与非关系型数据库">14.关系型数据库与非关系型数据库</h1>
<p>(1) 关系型数据库</p>
<ul>
<li>使用 SQL 语句方便的在一个表以及多个表之间做非常<strong>复杂的数据查询</strong>。</li>
<li>支持事务，对于<strong>安全性能很高</strong>的数据访问要求得以实现。</li>
</ul>
<p>(2) 非关系型数据库</p>
<ul>
<li>NoSQL 基于键值对，不需要经过 SQL 层的解析，<strong>性能高</strong>。</li>
<li>给予减会对，数据之间没有耦合性，<strong>容易水平扩展</strong>。</li>
</ul>
<h1 id="15b-树的数据结构">15.B+ 树的数据结构？</h1>
<p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。</p>
<p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p>
<p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。</p>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/B+%E6%A0%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="图片" loading="lazy"></figure>
<h1 id="16为什么使用-b-树索引而不用红黑树">16.为什么使用 B+ 树索引，而不用红黑树？</h1>
<p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：</p>
<p>（一）更少的查找次数</p>
<p>平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。</p>
<p>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。</p>
<p>（二）利用磁盘预读特性</p>
<p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。</p>
<p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。</p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/IZpRNTKs3EHiXO-vYphk1w">为什么MySQL的索引要使用B+树而不是其它树形结构?比如B树？</a><br>
因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变（有些资料也称为扇出）<br>
指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；</p>
</blockquote>
<h1 id="17mysql-读写分离-主从复制">17.MySQL 读写分离、主从复制</h1>
<h2 id="读写分离-2">读写分离</h2>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB.png" alt="图片" loading="lazy"></figure>
<p>MySQL 读写分离基本原理是让 <strong>master 数据库处理写操作，slave 数据库处理读操作</strong>。master 将写操作的变更同步到各个 slave 节点。</p>
<h2 id="主从复制原理">主从复制原理</h2>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png" alt="图片" loading="lazy"></figure>
<ul>
<li>master服务器将数据的改变记录二进制binlog日志，当master上的数据发生改变时，则将其改变写入二进制日志中；</li>
<li>slave服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/OThread请求master二进制事件</li>
<li>同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I/OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。</li>
</ul>
<p>参考链接：</p>
<p><a href="https://cyc2018.github.io/CS-Notes/#/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86">https://cyc2018.github.io/CS-Notes/#/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86</a></p>
<p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/MySQL.md">https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/MySQL.md</a></p>
<blockquote>
<p>MyBatis如何防止SQL注入的？<br>
mybatis的#{}和<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 21: …以及order by注入问题
#̲{}：相当于JDBC中的Pre…'>{}的区别以及order by注入问题
#{}：相当于JDBC中的PreparedStatement
</span>{}：是输出变量的值<br>
简单说，#{}是经过预编译的，是安全的；${}是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入。</p>
</blockquote>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#1%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E">1.存储引擎</a>
<ul>
<li><a href="#myisam-%E5%92%8C-innodb-%E7%9A%84%E5%8C%BA%E5%88%AB">MyISAM 和 InnoDB 的区别</a></li>
</ul>
</li>
<li><a href="#2%E7%B4%A2%E5%BC%95">2.索引</a>
<ul>
<li><a href="#1-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95">(1) 聚簇索引与非聚簇索引</a></li>
<li><a href="#2-hash-%E7%B4%A2%E5%BC%95%E4%B8%8E-b-%E6%95%B0%E7%B4%A2%E5%BC%95">(2) Hash 索引与 B+ 数索引</a>
<ul>
<li><a href="#hash-%E7%B4%A2%E5%BC%95">Hash 索引</a></li>
<li><a href="#b-%E6%A0%91%E7%B4%A2%E5%BC%95">B+ 树索引</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1">3.什么是事务？</a></li>
<li><a href="#4%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E5%BE%81">4.事务的四大特征</a></li>
<li><a href="#5%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98">5.并发事务带来哪些问题？</a>
<ul>
<li><a href="#1-%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9">(1) 丢失修改</a></li>
<li><a href="#2-%E8%AF%BB%E8%84%8F%E6%95%B0%E6%8D%AE">(2) 读脏数据</a></li>
<li><a href="#3-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB">(3) 不可重复读</a></li>
<li><a href="#4-%E5%B9%BB%E5%BD%B1%E8%AF%BB">(4) 幻影读</a></li>
</ul>
</li>
<li><a href="#6%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B">6.事务的隔离级别有哪些？</a>
<ul>
<li><a href="#1-%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4read-uncommitted">(1) 读未提交（READ UNCOMMITTED）</a></li>
<li><a href="#2-%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4read-committed">(2) 读已提交（READ COMMITTED）</a></li>
<li><a href="#3-%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BBrepeatable-read">(3) 可重复读（REPEATABLE READ）</a></li>
<li><a href="#4-%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96serializable">(4) 可串行化（SERIALIZABLE）</a></li>
</ul>
</li>
<li><a href="#7-%E9%94%81%E6%9C%BA%E5%88%B6%E4%B8%8E-innodb-%E9%94%81%E7%AE%97%E6%B3%95">7. 锁机制与 InnoDB 锁算法</a></li>
<li><a href="#8%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E4%B8%A4%E6%AE%B5%E9%94%81%E5%8D%8F%E8%AE%AE">8.介绍一下两段锁协议</a></li>
<li><a href="#9%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6mvcc">9.介绍一下多版本并发控制（MVCC）</a>
<ul>
<li><a href="#readview">ReadView</a></li>
<li><a href="#read-commited-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">READ COMMITED 实现方式</a></li>
<li><a href="#repeatable-read-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">REPEATABLE READ 实现方式</a></li>
<li><a href="#mvcc%E6%80%BB%E7%BB%93">MVCC总结</a></li>
</ul>
</li>
<li><a href="#10next-key-locks">10.Next-Key Locks</a>
<ul>
<li><a href="#record-locks">Record Locks</a></li>
<li><a href="#gap-locks">Gap Locks</a></li>
<li><a href="#next-key-locks">Next-Key Locks</a></li>
</ul>
</li>
<li><a href="#11%E5%A4%A7%E8%A1%A8%E4%BC%98%E5%8C%96">11.大表优化</a>
<ul>
<li><a href="#%E9%99%90%E5%AE%9A%E6%95%B0%E6%8D%AE%E7%9A%84%E8%8C%83%E5%9B%B4">限定数据的范围</a></li>
<li><a href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB">读/写分离</a></li>
<li><a href="#%E5%9E%82%E7%9B%B4%E5%88%86%E5%8C%BA">垂直分区</a></li>
<li><a href="#%E6%B0%B4%E5%B9%B3%E5%88%86%E5%8C%BA">水平分区</a></li>
</ul>
</li>
<li><a href="#12%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B9%8B%E5%90%8Eid-%E4%B8%BB%E9%94%AE%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86">12.分库分表之后，id 主键如何处理？</a></li>
<li><a href="#13%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E4%B8%8D%E5%90%8C%E5%85%83%E7%B4%A0where-join-limit-group-by-having%E7%AD%89%E7%9A%84%E5%85%88%E5%90%8E%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F">13.查询语句不同元素（where、join、limit、group by、having等）的先后执行顺序？</a></li>
<li><a href="#14%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93">14.关系型数据库与非关系型数据库</a></li>
<li><a href="#15b-%E6%A0%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">15.B+ 树的数据结构？</a></li>
<li><a href="#16%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-b-%E6%A0%91%E7%B4%A2%E5%BC%95%E8%80%8C%E4%B8%8D%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91">16.为什么使用 B+ 树索引，而不用红黑树？</a></li>
<li><a href="#17mysql-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6">17.MySQL 读写分离、主从复制</a>
<ul>
<li><a href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB-2">读写分离</a></li>
<li><a href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86">主从复制原理</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://epitomm.github.io/post/mian-shi-ti-xi-lie-jvm/">
              <h3 class="post-title">
                面试题系列 —— JVM
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '974bd77fbbd52c2a0647',
    clientSecret: '6344370ca1314dbd553f45e75a2121a160ef1c44',
    repo: 'EpitomM.github.io',
    owner: 'EpitomM',
    admin: ['EpitomM'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/EpitomM/EpitomM.github.io" target="_blank">EpitomM</a>
  <a class="rss" href="https://epitomm.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
