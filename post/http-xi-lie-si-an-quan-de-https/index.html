<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>HTTP系列（四）安全的HTTPS | SSM</title>
<link rel="shortcut icon" href="https://epitomm.github.io/favicon.ico?v=1588930316792">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://epitomm.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="HTTP系列（四）安全的HTTPS | SSM - Atom Feed" href="https://epitomm.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="一、HTTP 与 HTTPS


HTTP 协议：超文本传输协议，应用层协议，HTTP 协议通过 请求-响应的方式，在客户端和服务端之间进行通信。HTTP 协议传输明文，不安全。
明文信息传输
小风向向小萌发出一个请求 “小萌，我喜欢你！”..." />
    <meta name="keywords" content="HTTP,计算机网络" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://epitomm.github.io">
  <img class="avatar" src="https://epitomm.github.io/images/avatar.png?v=1588930316792" alt="">
  </a>
  <h1 class="site-title">
    SSM
  </h1>
  <p class="site-description">
    热心善良的老学姐
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              HTTP系列（四）安全的HTTPS
            </h2>
            <div class="post-info">
              <span>
                2020-04-28
              </span>
              <span>
                12 min read
              </span>
              
                <a href="https://epitomm.github.io/tag/LXiZFuZAY/" class="post-tag">
                  # HTTP
                </a>
              
                <a href="https://epitomm.github.io/tag/QxXq3bhNg/" class="post-tag">
                  # 计算机网络
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="一-http-与-https">一、HTTP 与 HTTPS</h1>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/HTTPS_1.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/HTTPS_2.png" alt="图片" loading="lazy"></figure>
<p>HTTP 协议：超文本传输协议，应用层协议，HTTP 协议通过 请求-响应的方式，在客户端和服务端之间进行通信。HTTP 协议传输<strong>明文</strong>，不安全。</p>
<h2 id="明文信息传输">明文信息传输</h2>
<p>小风向向小萌发出一个请求 “小萌，我喜欢你！” 来表白。</p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E6%98%8E%E6%96%87%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93.png" alt="图片" loading="lazy"></figure>
<h3 id="中间人攻击">中间人攻击</h3>
<p>但是由于传输信息是明文，这个信息可能被某个中间人恶意拦截甚至篡改：<strong>中间人攻击</strong>。</p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E6%98%8E%E6%96%87%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93_%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB.png" alt="图片" loading="lazy"></figure>
<h2 id="加密信息传输">加密信息传输</h2>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93.png" alt="图片" loading="lazy"></figure>
<h3 id="加密算法">加密算法</h3>
<ul>
<li>对称加密：加密、解密使用同一个秘钥</li>
<li>非对称加密：加密、解密使用不同的秘钥，公钥加密私钥解密</li>
</ul>
<h3 id="对称加密传输">对称加密传输</h3>
<p>小风和小萌事先约定好一种加密方式，并且约定一个随机生成的秘钥，后续通信信息的发送方使用秘钥对信息进行加密，信息的接收方使用同一个秘钥对接收到的密文进行解密。</p>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>小风发送聊天请求，小萌回复给小风一个秘钥，小风后面发送的信息都先使用秘钥加密后再发送。后续发送信息都是不可读的密文了。</p>
</blockquote>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93_2.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>如果不知道秘钥，即使拦截到了信息，也没有办法解析和篡改。<br>
但是这样做并不是绝对安全的，虽然在后续的通信中对明文进行了加密，但是<strong>第一次约定加密方式、约定加密方式之后的秘钥的传输</strong>还是用明文。如果第一次通信就已经被拦截了，那么秘钥就会泄露给中间人， 中间人仍可以解密后续所有通信内容。</p>
</blockquote>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93_%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB.png" alt="图片" loading="lazy"></figure>
<h2 id="非对称加密传输">非对称加密传输</h2>
<p>非对称加密的一组秘钥中包含一个公钥和一个私钥，既可以公钥加密私钥解密，也可以私钥加密公钥解密。</p>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_1.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>在小风和小萌建立通信时，小萌首先把自己的公钥 KEY1 发送给小风。</p>
</blockquote>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_2.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>收到小萌的公钥后，小风自己生成一个用于对称加密的公钥 KEY2，这个秘钥是为了后续聊天加密来用的，就是上次被中间人发现的那个秘钥，为了安全不再明文约定发送，而是用刚才接收到的公钥 KEY1 对 KEY2 进行加密，得到 VA3=KEY1(KEY2)，把 VA3 发送给小萌。</p>
</blockquote>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_3.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>小萌可以用自己的非对称加密的私钥，解开公钥 KEY1 的加密，获得了 KEY2 的内容，从此以后用 KEY2 进行加密通信。</p>
</blockquote>
<p>在这个通信过程中，即使中间人一开始就截获了公钥 KEY1，由于不知道私钥是什么，也没有办法去解密。</p>
<h3 id="总结">总结</h3>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_%E6%80%BB%E7%BB%93.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>发送方和接收方都有一套自己的公钥和私钥，公钥是所有人都知道的，私钥只有自己知道。<br>
<strong>发送方使用接收方的公钥进行加密，接收方使用自己的私钥对接收的密文进行解密。</strong></p>
</blockquote>
<h3 id="中间人攻击-2">中间人攻击</h3>
<p>中间人不知道小萌的私钥是什么，但是它截获了小萌的公钥 KEY1 后，可以自己另外生成一对公钥和私钥，把自己的公钥 KEY3 发送给小风，</p>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB_1.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>小风以为 KEY3 就是小萌的公钥，用 KEY3 加密自己生成的对称加密的公钥 KEY2 得到 VA4=KEY3(KEY2)，发送给小萌，中间人用自己的私钥解开 KEY3 加密，获得了 KEY2，然后用小萌发来的 KEY1 重新加密，得到 VAL5，发给小萌。</p>
</blockquote>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB_2.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>两个人的后续通信尽管一直在用 KEY2 做对称加密，但是中间人已经掌握了 KEY2，就可以轻松地解密获取内容了。</p>
</blockquote>
<h2 id="证书机构">证书机构</h2>
<p><img src="https://epitomm.github.io/post-images/%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84_2.png" alt="图片" loading="lazy"></p>
<blockquote>
<p>小萌把自己的公钥 KEY1 发给证书颁发机构去申请证书，证书颁发机构自己有一对公钥和私钥，机构利用自己的私钥来加密 KEY1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过了机构的私钥加密，这样制作完成一个证书，机构把这个证书发给服务端小萌。</p>
</blockquote>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84_3.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>当后续小风向小萌请求通信时，小萌不再返回自己的公钥，而是直接把自己申请的证书返回给小风。</p>
</blockquote>
<figure data-type="image" tabindex="16"><img src="https://epitomm.github.io/post-images/%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84_4.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>小风收到证书后， 验证证书的真伪，各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥，所以，小风只需要知道是哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书的签名。接下来小风按照同样的签名规则，自己生成一个证书签名，如果两个签名一致，说明证书有效，验证成功后，小风就可以放心地再次利用机构的公钥解密出服务端小萌的公钥 KEY1，小风生成自己对应的对称加密的秘钥 KEY2，并且用服务端公钥 KEY1 加密 KEY2 生成 VA3，发送给小萌。</p>
</blockquote>
<figure data-type="image" tabindex="17"><img src="https://epitomm.github.io/post-images/%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84_5.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>小萌用自己的私钥解开加密得到对称加密的秘钥 KEY2，于是两个人可以开始用 KEY2 进行对称加密通信。</p>
</blockquote>
<h1 id="二-https-协议概述">二、HTTPS 协议概述</h1>
<ul>
<li>HTTPS可以认为是HTTP+TLS。</li>
<li>TLS是传输层加密协议，它的前身是SSL协议。</li>
</ul>
<blockquote>
<p>我们默认 TLS 和 SSL 指的是一个东西。</p>
</blockquote>
<figure data-type="image" tabindex="18"><img src="https://epitomm.github.io/post-images/SSL.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>TLS 建立在 传输层和应用层之间，TLS 实际上是 TCP 之上建立了一个加密通道，TLS 协议主要有五个部分：应用数据层协议、握手协议、报警协议、加密消息确认协议、心跳协议。<br>
目前常用的 HTTP 协议是 HTTP1.1，常用的 TLS 协议版本有：TLS1.2、TLS1.1、TLS1.0 和 SSL3.0 这样几个版本。其中 SSL3.0 由于某种攻击，认为 SSL3.0 协议是不安全的。TLS1.0 也存在部分安全漏洞，TLS1.1 和 TLS1.2 暂时没有已知的安全漏洞。</p>
</blockquote>
<h2 id="https-功能介绍">HTTPS 功能介绍</h2>
<blockquote>
<p>HTTP 本身是明文传输，没有经过任何安全处理，比如在百度搜索一个关键字：小米手机，中间人能够查看这个消息并且有可能打电话推销；在使用百度的过程中，搜索返回的结果页面有广告。这里的中间者主要指网络节点，用户数据在浏览器和百度服务器中间传输必须要经过的那些节点。比如 wifi 热点、路由器、防火墙、反向代理、缓存服务器等，在 HTTP 协议下，中间人可随意窃听用户的搜索内容，窃取客户隐私甚至篡改网页，HTTPS 协议就是这些攻击的克星。</p>
</blockquote>
<ul>
<li>内容加密</li>
</ul>
<blockquote>
<p>浏览器到服务器的内容是以加密的形式传输的，中间者无法查看。</p>
<ul>
<li>非对称秘钥交换</li>
<li>对称内容加密<br>
对称加密的第一步：协商加密算法和秘钥，中间人依然可以在第一次通信时，截获加密方式和秘钥，这样有对称内容加密就安全了一些。<br>
非对称加密用公钥和私钥的方式把正常通信的秘钥 KEY2 协商好，但是在协商过程中，有一步骤是服务器把自己的公钥 KEY1 用明文传给客户端，</li>
</ul>
</blockquote>
<ul>
<li>身份认证</li>
</ul>
<blockquote>
<p>证书的存在保证用户访问的是你想访问的服务，在使用慕课看视频，HTTPS 证书保证了此时访问的一定是慕课网，即使被 DNS 劫持到了第三方站点，也会提醒用户没有访问慕课服务，有可能被劫持。</p>
</blockquote>
<ul>
<li>数据完整性</li>
</ul>
<blockquote>
<p>防止内容被第三方冒充或篡改。</p>
</blockquote>
<h2 id="https-原理介绍">HTTPS 原理介绍</h2>
<ul>
<li>内容加密</li>
</ul>
<p>非对称密钥交换</p>
<blockquote>
<p>非对称加密：公钥和私钥的方式把正常通信的 KEY2 协商好，协商的过程中，服务器把自己的公钥 KEY1 用明文传递给客户端，这里面涉及很多高级算法：对称加密的两种模式：流式加密、分组加密。在秘钥交换的过程中，中间人可以截获 KEY1，换成自己的公钥 KEY3，这样一来中间人依然可以获取正常通信时的秘钥，于是引入了数字证书。</p>
</blockquote>
<p>对称内容加密</p>
<blockquote>
<p>对称加密：协商加密算法和秘钥，中间人可以在第一次通信时拦截加密方式和秘钥。</p>
</blockquote>
<ul>
<li>身份认证</li>
</ul>
<p>数字证书</p>
<blockquote>
<p>服务端向权威机构申请证书。<br>
客户端和服务端通信时，服务端先把证书传递给客户端，客户端收到证书后，用证书机构的公钥解密证书签名，然后用签名生成的规则再生成一个签名，对比一致就是真整数，不一致就是假证书。<br>
如果确认是真证书，解密服务器公钥 KEY1，再生成通信用的秘钥 KEY2，用服务器端的公钥 KEY1 加密，发给服务端。</p>
</blockquote>
<h1 id="三-https-使用成本">三、HTTPS 使用成本</h1>
<ul>
<li>证书费用以及更新维护</li>
<li>HTTPS 降低用户访问速度</li>
<li>消耗CPU资源，需要增加大量机器</li>
</ul>
<h1 id="四-https-对性能的影响">四、HTTPS 对性能的影响</h1>
<ul>
<li>协议交互所增加的网络RTT</li>
</ul>
<blockquote>
<p>RTT：往返时延。从发送端发送数据开始，到发送端收到来自接收端的确认总共经过的时延。</p>
</blockquote>
<ul>
<li>加解密相关的计算耗时</li>
</ul>
<h2 id="网络耗时">网络耗时</h2>
<figure data-type="image" tabindex="19"><img src="https://epitomm.github.io/post-images/HTTP%E7%BD%91%E7%BB%9C%E8%80%97%E6%97%B6.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>HTTP 协议访问网站，交互延迟如上图，用户只需要完成 TCP 三次握手，建立 TCP 连接就能直接发送 HTTP 请求获取应用层数据了。除此之外在访问网络的过程中，也没有需要消耗计算资源的地方。</p>
</blockquote>
<figure data-type="image" tabindex="20"><img src="https://epitomm.github.io/post-images/HTTPS%E7%BD%91%E7%BB%9C%E8%80%97%E6%97%B6.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>HTTPS 访问流程如上图。<br>
① TCP 三次握手建立连接，一个 RTT<br>
② HTTP GET 请求服务端返回 302跳转到 HTTPS，一个 RTT 和 302 跳转时延。因为用户不会手动输入 https 访问网站，比如说百度，用户一般输入 baidu.com，而不会直接输入：https://www.baidu.com，所以服务端只能返回 302 强制浏览器跳转到 HTTPS。<br>
③ 而浏览器处理 302 跳转本身也需要耗时，这个耗时暂且不算，302 跳转到 https 服务器之后，由于端口和服务器不一样，所以需要重新完成三次握手，建立 TCP 连接。耗时一个 RTT。<br>
④ TLS 完全握手阶段1，耗时一个 RTT，这个阶段主要完成加密套件的协商和证书的身份确认。这个阶段下，服务端和浏览器会协商出来相同的秘钥交换算法、对称加密算法、内容一致性校验算法、证书签名算法等。<br>
浏览器获取到证书后，校验证书的有效性，比如证书是否过期，是否撤销等，浏览器首先获取证书里的 CA 域名，如果 CA 域名没有命中缓存的话，浏览器需要解析 CA 域名的 DNS，这个 DNS 解析至少耗费一个 RTT。DNS 解析到 ip 后，三次握手，建立 CA 站点的 TCP 连接，耗时一个 RTT，接着浏览器发送 Ocsp 请求获取响应，耗时一个 RTT,<br>
Ocsp：在线证书状态协议，维护服务器和其他网络资源安全性的两种普遍模式之一。另外一个叫做 CRL 证书注销列表。当用户试图访问一个服务器时，在线证书状态协议发送一个对于证书状态信息的请求，服务器会回复一个有效、过期或者未知的响应。协议规定了服务器和客户端应用程序的通信语法，在线证书状态协议给用户到期的证书一个宽限期，这样他们就可以在更新以前的一段时间继续访问到这个服务器。这里就需要发起对于证书状态信息的请求，也需要消耗一个 RTT。<br>
⑤ TLS 完全握手阶段2：秘钥协商，耗时一个 RTT 和计算时间，这个完全握手结束后，浏览器和服务器之间进行应用层也就是 HTTP 的数据传输。这和 HTTP 的方式几乎是相同的。<br>
一共耗时 7 个 RTT。<br>
如果不是第一次请求，比如 CA 域名解析，如果有缓存的话，就无需进行 DNS 解析，就可以减少一个 RTT。</p>
</blockquote>
<h2 id="计算耗时">计算耗时</h2>
<ul>
<li>浏览器计算耗时</li>
</ul>
<blockquote>
<p>浏览器解析证书签名，秘钥交换，应用层数据加密、解密，一致性的交换</p>
</blockquote>
<ul>
<li>服务端计算耗时</li>
</ul>
<blockquote>
<p>秘钥交换，应用层数据加密、解密耗时。<br>
由于客户端 CPU 和操作系统种类比较多，所以计算耗时不能一概而论。</p>
</blockquote>
<h1 id="五-https-常见问题">五、HTTPS 常见问题</h1>
<ul>
<li>https加密是不是需要我在电脑上安装证书/保存密码？</li>
</ul>
<blockquote>
<p>不需要，操作系统、浏览器把这些操作都做好了</p>
</blockquote>
<ul>
<li>https 不就是在http后面加个s，很难么？</li>
</ul>
<blockquote>
<p>HTTPS 包含证书、流量转发、负载均衡......<br>
小型网站不难，大型网站很难</p>
</blockquote>
<ul>
<li>https 解决了所有劫持问题吗？</li>
</ul>
<blockquote>
<p>https 是为了解决中间人攻击，假设在 https 页面中加载了 http 资源，http 资源还是有劫持的风险，客户端、局域网的风险也很大，恶意插件、木马、路由器、DNS 也都非常脆弱。HTTPS 能够在绝大部分下保证互联网访问数据传输的安全性。</p>
</blockquote>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E4%B8%80-http-%E4%B8%8E-https">一、HTTP 与 HTTPS</a>
<ul>
<li><a href="#%E6%98%8E%E6%96%87%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93">明文信息传输</a>
<ul>
<li><a href="#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB">中间人攻击</a></li>
</ul>
</li>
<li><a href="#%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93">加密信息传输</a>
<ul>
<li><a href="#%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95">加密算法</a></li>
<li><a href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93">对称加密传输</a></li>
</ul>
</li>
<li><a href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93">非对称加密传输</a>
<ul>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
<li><a href="#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB-2">中间人攻击</a></li>
</ul>
</li>
<li><a href="#%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84">证书机构</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-https-%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0">二、HTTPS 协议概述</a>
<ul>
<li><a href="#https-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D">HTTPS 功能介绍</a></li>
<li><a href="#https-%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D">HTTPS 原理介绍</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-https-%E4%BD%BF%E7%94%A8%E6%88%90%E6%9C%AC">三、HTTPS 使用成本</a></li>
<li><a href="#%E5%9B%9B-https-%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D">四、HTTPS 对性能的影响</a>
<ul>
<li><a href="#%E7%BD%91%E7%BB%9C%E8%80%97%E6%97%B6">网络耗时</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E8%80%97%E6%97%B6">计算耗时</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-https-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">五、HTTPS 常见问题</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://epitomm.github.io/post/http-xi-lie-san-shou-xi-http-xie-yi-jie-gou-he-tong-xun-yuan-li/">
              <h3 class="post-title">
                HTTP 系列（三）熟悉 HTTP 协议结构和通讯原理
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '974bd77fbbd52c2a0647',
    clientSecret: '6344370ca1314dbd553f45e75a2121a160ef1c44',
    repo: 'EpitomM.github.io',
    owner: 'EpitomM',
    admin: ['EpitomM'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/EpitomM/EpitomM.github.io" target="_blank">EpitomM</a>
  <a class="rss" href="https://epitomm.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
