<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Spring系列（二）SpringAOP 应用 | SSM</title>
<link rel="shortcut icon" href="https://epitomm.github.io/favicon.ico?v=1589017479735">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://epitomm.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Spring系列（二）SpringAOP 应用 | SSM - Atom Feed" href="https://epitomm.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="自定义注解
xml 的作用？
答：描述数据。
举例：数据库中有一张 user 表，项目中有一个 User 类，如何将 User 类与 user 表关联？
答：使用 xml 来描述元数据。
那为什么还要有自定义注解呢？因为xml 开发过程过于..." />
    <meta name="keywords" content="Spring" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://epitomm.github.io">
  <img class="avatar" src="https://epitomm.github.io/images/avatar.png?v=1589017479735" alt="">
  </a>
  <h1 class="site-title">
    SSM
  </h1>
  <p class="site-description">
    热心善良的老学姐
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Spring系列（二）SpringAOP 应用
            </h2>
            <div class="post-info">
              <span>
                2020-05-02
              </span>
              <span>
                35 min read
              </span>
              
                <a href="https://epitomm.github.io/tag/A43qp3xVg/" class="post-tag">
                  # Spring
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="自定义注解">自定义注解</h1>
<h2 id="xml-的作用">xml 的作用？</h2>
<p>答：<strong>描述数据</strong>。<br>
举例：数据库中有一张 user 表，项目中有一个 User 类，如何将 User 类与 user 表<strong>关联</strong>？<br>
答：使用 xml 来描述元数据。<br>
那为什么还要有自定义注解呢？因为xml 开发过程过于复杂。</p>
<h2 id="自定义注解-2">自定义注解</h2>
<h3 id="一-准备阶段">一、准备阶段</h3>
<h4 id="1定义实体类">1.定义实体类</h4>
<pre><code class="language-java">package com.ssm.entity;

import com.ssm.anno.Entity;

public class CityEntity {

    private Integer id;
    private String name;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
</code></pre>
<h4 id="2定义工具类">2.定义工具类</h4>
<pre><code class="language-java">package com.ssm.util;

public class CommonUtil {
    /**
     * 通过一个对象构建一条查询的 sql 语句
     * @param obj
     */
    public static String buildQuerySqlForEntity(Object obj){

        // 表名、字段应该根据传入的值动态变化，不应该写死
        // 办法：在实体类 CityEntity 中加入注解 @Table（需要导入JPA），我们使用自定义注解来实现
        String sql = &quot;select * from ? where id=? and name=?&quot;;

        return null;
    }
}
</code></pre>
<h4 id="3测试方法">3.测试方法</h4>
<pre><code class="language-java">package com.ssm.util;

public class CommonUtil {
    /**
     * 通过一个对象构建一条查询的 sql 语句
     * @param obj
     */
    public static String buildQuerySqlForEntity(Object obj){

        // 表名、字段应该根据传入的值动态变化，不应该写死
        // 办法：在实体类 CityEntity 中加入注解 @Table（需要导入JPA），我们使用自定义注解来实现
        String sql = &quot;select * from ? where id=? and name=?&quot;;

        return null;
    }
}
</code></pre>
<h3 id="二-自定义注解基本功能">二、自定义注解——基本功能</h3>
<h4 id="1自定义注解">1.自定义注解</h4>
<pre><code class="language-java">public @interface Entity {
    public String value();
}
</code></pre>
<h4 id="2实体类添加注解">2.实体类添加注解</h4>
<pre><code class="language-java">// 注解里面的 value 方法，返回值是 String 类型
@Entity(value = &quot;city&quot;)
public class CityEntity {
</code></pre>
<h3 id="三-自定义注解元注解">三、自定义注解——元注解</h3>
<h4 id="1实体类体会元注解">1.实体类体会元注解</h4>
<pre><code class="language-java">//@Override   
// @Override' not applicable to type：@Override 不适用修饰类
public class CityEntity {

// @Override   
// Method does not override method from its superclass：没有父类重写的方法。表名 @Override 注解可用于修饰方法
    public void setId(Integer id) {
        this.id = id;
    }    
</code></pre>
<p>分析得知：@Override 注解可用于修饰方法，不可用于修饰类。<br>
于是我们来改动一下我们的自定义注解 @Entity，让它只能用于修饰类，不能用于修饰方法。</p>
<h4 id="2修改自定义注解类">2.修改自定义注解类</h4>
<pre><code class="language-java">// @Entity 注解能够出现的目标位置：TYPE：类
@Target(ElementType.TYPE)
// @Target({ElementType.TYPE, ElementType.FIELD})：指定多个可以出现的位置：类、
public @interface Entity {
    public String value();
}
</code></pre>
<h3 id="四-获得注解内的值">四、获得注解内的值</h3>
<pre><code class="language-java">package com.ssm.util;

import com.ssm.anno.Entity;

import java.lang.annotation.Annotation;

public class CommonUtil {
    public static String buildQuerySqlForEntity(Object obj){
        // 得到类的类对象
        Class clazz = obj.getClass();
        // setup1 判断是否加了这个注解
        if(clazz.isAnnotationPresent(Entity.class)){
            // setup2 得到注解
            Entity entity = (Entity) clazz.getDeclaredAnnotation(Entity.class);
            // setup3 调用方法
            String value = entity.value();
            System.out.println(value);  // city
        }

        // 表名、字段应该根据传入的值动态变化，不应该写死
        // 办法：在实体类 CityEntity 中加入注解 @Table（需要导入JPA），我们使用自定义注解来实现
        String sql = &quot;select * from ? where id=? and name=?&quot;;

        return null;
    }
}
</code></pre>
<h2 id="注解生命周期">注解生命周期</h2>
<h3 id="retentionretentionpolicysource">@Retention(RetentionPolicy.SOURCE)</h3>
<p>注解的生命周期：默认情况下仅仅存在于 Java 源码中，即@Retention(RetentionPolicy.SOURCE)，当 JVM 一旦把它编译成字节码，注解会自动丢失。<br>
<img src="https://epitomm.github.io/post-images/%E6%B3%A8%E8%A7%A3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9FSOURCE.png" alt="图片" loading="lazy"></p>
<h3 id="retentionretentionpolicyclass">@Retention(RetentionPolicy.CLASS)</h3>
<p>会存在于 .class 文件中，但是在代码被运行时还是会被 JVM 忽略。<br>
<img src="https://epitomm.github.io/post-images/%E6%B3%A8%E8%A7%A3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9FCLASS.png" alt="图片" loading="lazy"><br>
测试：</p>
<pre><code class="language-java">package com.ssm.util;

import com.ssm.anno.Entity;

public class CommonUtil {

    public static String buildQuerySqlForEntity(Object obj){
        // 得到类的类对象
        Class clazz = obj.getClass();
        // setup1 判断是否加了这个注解
        boolean b = clazz.isAnnotationPresent(Entity.class); // false
        System.out.println(b);

        return null;
    }
}
</code></pre>
<h3 id="retentionretentionpolicyruntime">@Retention(RetentionPolicy.RUNTIME)</h3>
<p>只有当注解的生命周期声明为 RUNTIME 时，在执行时才会被 JVM 发觉到。<br>
boolean b = clazz.isAnnotationPresent(Entity.class);//true</p>
<h1 id="aop-是什么">AOP 是什么</h1>
<p>与OOP对比，面向切面，传统的OOP开发中的代码逻辑是自上而下的，而这些过程会产生一些横切性问题，这些横切性的问题和我们的主业务逻辑关系不大，这些横切性问题不会影响到主逻辑实现的，但是会散落到代码的各个部分，难以维护。AOP是处理一些横切性问题，AOP的编程思想就是把这些问题和主业务逻辑分开，达到与主业务逻辑解耦的目的。使代码的重用性和开发效率更高。<br>
<img src="https://epitomm.github.io/post-images/AOP%E6%98%AF%E4%BB%80%E4%B9%88.png" alt="图片" loading="lazy"></p>
<h2 id="aop-的应用场景">AOP 的应用场景</h2>
<ol>
<li>日志记录</li>
<li>权限验证</li>
<li>效率检查</li>
<li>事务管理</li>
<li>exception</li>
</ol>
<h2 id="springaop-的底层技术">SpringAOP 的底层技术</h2>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">JDK动态代理</th>
<th style="text-align:center">CGLIB代理</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">编译时期的织入还是运行时期的织入?</td>
<td style="text-align:center">运行时期织入</td>
<td style="text-align:center">运行时期织入</td>
</tr>
<tr>
<td style="text-align:center">初始化时期织入还是获取对象时期织入？</td>
<td style="text-align:center">初始化时期织入</td>
<td style="text-align:center">初始化时期织入</td>
</tr>
</tbody>
</table>
<h2 id="springaop-和-aspectj-的关系">SpringAOP 和 AspectJ 的关系</h2>
<p>AOP 是一种概念<br>
SpringAOP、AspectJ 都是 AOP 的实现，SpringAOP 有自己的语法，但是语法复杂，所以SpringAOP 借助了AspectJ 的注解，但是底层实现还是自己的<br>
AspectJ 是静态注入：编译（.java -&gt; .class）时就完成了注入，SpringAOP是动态注入：运行时才注入</p>
<pre><code>spring AOP提供两种编程风格
@AspectJ support         ------------&gt;利用aspectj的注解
Schema-based AOP support -----------&gt;xml aop:config 命名空间

证明:spring,通过源  码分析了,我们可以知道spring底层使用的是JDK或者CGLIB来完成的代理,并且在官网上spring给出了aspectj的文档,和springAOP是不同的
</code></pre>
<p>如果您只需要建议在Spring bean上执行操作，那么Spring AOP是正确的选择。如果需要通知Spring容器没有管理的对象(通常是域对象)，则需要使用AspectJ。<br>
Spring AOP的概念<br>
参考链接：<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-introduction-defn">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-introduction-defn</a></p>
<ul>
<li>aspect:一定要给spring去管理  抽象  aspectj-&gt;类</li>
<li>pointcut:切点表示连接点的集合  -----------------&gt;   表 （我的理解：PointCut是JoinPoint的谓语，这是一个动作，主要是告诉通知连接点在哪里，切点表达式决定 JoinPoint 的数量）</li>
<li>Joinpoint:连接点   目标对象中的方法 ----------------&gt;    记录（我的理解：JoinPoint是要关注和增强的方法，也就是我们要作用的点）</li>
<li>Weaving :把代理逻辑加入到目标对象上的过程叫做织入</li>
<li>target 目标对象 原始对象</li>
<li>aop Proxy 代理对象  包含了原始对象的代码和增加后的代码的那个对象</li>
<li>advice:通知    (位置 + logic)</li>
</ul>
<h2 id="aspect-切面">Aspect 切面</h2>
<blockquote>
<p>Aspect: A modularization of a concern that cuts across multiple classes. Transaction management is a good example of a crosscutting concern in enterprise Java applications. In Spring AOP, aspects are implemented by using regular classes (the schema-based approach) or regular classes annotated with the @Aspect annotation (the @AspectJ style).</p>
</blockquote>
<p>切面是：通知、切点、连接点的载体。通知、连接点要放到哪里去，好比 Java 中的属性、方法、构造方法，这些东西要放到哪里去？放到一个类里面，这个类就是方法以及参数属性的载体。切面就是连接点、切点、通知的载体，把这些连接点、切点、通知所在的位置称之为一个切面。</p>
<h2 id="join-point-连接点">Join point 连接点</h2>
<blockquote>
<p>Join point: A point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution.</p>
</blockquote>
<p>连接点：程序执行过程中的一个点，如方法的执行或异常的处理。在Spring AOP中，连接点总是表示方法执行。<br>
<img src="https://epitomm.github.io/post-images/AOP%E8%BF%9E%E6%8E%A5%E7%82%B9.png" alt="图片" loading="lazy"><br>
ProceedingJoinPoint 和 JoinPoint 的区别:<br>
ProceedingJoinPoint  继承了JoinPoint ,proceed()这个是aop代理链执行的方法。并扩充实现了proceed()方法，用于继续执行连接点。JoinPoint 仅能获取相关参数，无法执行连接点。<br>
JoinPoint 的方法：</p>
<ol>
<li>java.lang.Object[] getArgs()：获取连接点方法运行时的入参列表；</li>
<li>Signature getSignature() ：获取连接点的方法签名对象；</li>
<li>java.lang.Object getTarget() ：获取连接点所在的目标对象；</li>
<li>java.lang.Object getThis() ：获取代理对象本身；<br>
proceed()有重载,有个带参数的方法,可以修改目标方法的的参数</li>
</ol>
<p>Advice 通知<br>
Advice: Action taken by an aspect at a particular join point. Different types of advice include “around”, “before” and “after” advice. (Advice types are discussed later.) Many AOP frameworks, including Spring, model an advice as an interceptor and maintain a chain of interceptors around the join point.<br>
<img src="https://epitomm.github.io/post-images/AOP%E9%80%9A%E7%9F%A5.png" alt="图片" loading="lazy"></p>
<ul>
<li>advice通知类型:</li>
<li>Before 连接点执行之前，但是无法阻止连接点的正常执行，除非该段执行抛出异常</li>
<li>After  连接点正常执行之后，执行过程中正常执行返回退出，非异常退出</li>
<li>After throwing  执行抛出异常的时候</li>
<li>After (finally)  无论连接点是正常退出还是异常退出，都会执行</li>
<li>Around advice: 围绕连接点执行，例如方法调用。这是最有用的切面方式。around通知可以在方法调用之前和之后执行自定义行为。它还负责选择是继续加入点还是通过返回自己的返回值或抛出异常来快速建议的方法执行。</li>
</ul>
<h3 id="after">After</h3>
<pre><code class="language-java">@After(&quot;pointCutTarget()&quot;)
public void after(){
    System.out.println(&quot;after&quot;);
}
</code></pre>
<h3 id="before">Before</h3>
<pre><code class="language-java">@Before(&quot;pointCut()&quot;)
public void before(JoinPoint joinPoint){
    System.out.println(&quot;before&quot;);
    System.out.println(joinPoint.getThis());
    System.out.println(joinPoint.getTarget());
}
</code></pre>
<p>断点调试：<br>
1、joinPoint.getThis()<br>
<img src="https://epitomm.github.io/post-images/%E8%BF%9E%E6%8E%A5%E7%82%B9%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_1.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/%E8%BF%9E%E6%8E%A5%E7%82%B9%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_2.png" alt="图片" loading="lazy"><br>
2、joinPoint.getTarget()<br>
<img src="https://epitomm.github.io/post-images/%E8%BF%9E%E6%8E%A5%E7%82%B9%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_3.png" alt="图片" loading="lazy"></p>
<h3 id="around">Around</h3>
<p>在通知中拿到连接点，然后执行连接点。</p>
<pre><code class="language-java">@Around(&quot;pointCut()&quot;)
// ProceedingJoinPoint：正在进行的 JointPoint：正在增强的方法
public void around(ProceedingJoinPoint pjp) throws Throwable {
    System.out.println(&quot;around...before&quot;);
    // 拿到方法并执行它
    pjp.proceed();
    System.out.println(&quot;around...after&quot;);
}
</code></pre>
<p>测试结果：</p>
<pre><code>around...before
query
around...after
</code></pre>
<h3 id="xml-通知">XML 通知</h3>
<p>1、编写 xml，定义切面、连接点、通知</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                         http://www.springframework.org/schema/beans/spring-beans.xsd
                         http://www.springframework.org/schema/aop
                         http://www.springframework.org/schema/aop/spring-aop.xsd
                         http://www.springframework.org/schema/context
                         http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:component-scan base-package=&quot;com.ssm&quot;/&gt;
    &lt;!-- 定义一个切面 --&gt;
    &lt;aop:config&gt;
        &lt;!-- 定义一个连接点 --&gt;
        &lt;aop:pointcut id=&quot;allDao&quot; expression=&quot;execution(* com.ssm.dao.*.*(..))&quot;/&gt;
        &lt;!-- 通知包含两部分：位置 pointcut-ref 、逻辑 ref --&gt;
        &lt;aop:aspect id=&quot;aspect&quot; ref=&quot;xmlBean&quot;&gt;
            &lt;aop:before pointcut-ref=&quot;allDao&quot;
                    method=&quot;before&quot;/&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;

    &lt;bean id=&quot;xmlBean&quot; class=&quot;com.ssm.app.XMLAopBean&quot;/&gt;
    &lt;bean id=&quot;indexDao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p>2、编写通知的逻辑</p>
<pre><code class="language-java">public class XMLAopBean {
    public void before(){
        System.out.println(&quot;xml before...&quot;);
    }
}
</code></pre>
<p>3、测试</p>
<pre><code class="language-java">public class TestXML {
    public static void main(String[] args) throws IOException {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
        IndexDao dao = (IndexDao) context.getBean(&quot;indexDao&quot;);
        dao.query(&quot;hello&quot;);
    }
}
</code></pre>
<p>4、运行结果</p>
<pre><code>xml before...
query
hello
</code></pre>
<h4 id="环绕通知中改变参数值">环绕通知中改变参数值</h4>
<p>1、传递进来的参数为 &quot;hello&quot;</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws IOException {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        IndexDao dao = (IndexDao) context.getBean(&quot;indexDao&quot;);
        dao.query(&quot;hello&quot;);
    }
}
</code></pre>
<p>2、在环绕通知内将参数修改为  hello  world</p>
<pre><code class="language-java">@Around(&quot;pointCut()&quot;)
// ProceedingJoinPoint：正在进行的 JointPoint：正在增强的方法 
public void around(ProceedingJoinPoint pjp) throws Throwable {
    Object[] args = pjp.getArgs();
    if(args != null &amp;&amp; args.length &gt; 0){
        for (int i = 0; i &lt; args.length; i++) {
            args[i] += &quot; world&quot;;
        }
    }
    System.out.println(&quot;around...before&quot;);
    // 拿到方法并执行它
    pjp.proceed(args);
    System.out.println(&quot;around...after&quot;);
}
</code></pre>
<p>3、输出参数值</p>
<pre><code class="language-java">@Repository(&quot;indexDao&quot;)
public class IndexDaoImpl implements IndexDao {
    @Override
    public void query(String str){
        System.out.println(&quot;query&quot;);
        System.out.println(str);
    }
}
</code></pre>
<p>4、输出结果：</p>
<pre><code>around...before
query
hello world
around...after
</code></pre>
<h2 id="pointcut-切点">Pointcut 切点</h2>
<blockquote>
<p>Pointcut: A predicate that matches join points. Advice is associated with a pointcut expression and runs at any join point matched by the pointcut (for example, the execution of a method with a certain name). The concept of join points as matched by pointcut expressions is central to AOP, and Spring uses the AspectJ pointcut expression language by default.</p>
</blockquote>
<p>切点：连接点的集合。<br>
<img src="https://epitomm.github.io/post-images/AOP%E5%88%87%E7%82%B9.png" alt="图片" loading="lazy"></p>
<h2 id="introduction">Introduction</h2>
<blockquote>
<p>Introduction: Declaring additional methods or fields on behalf of a type. Spring AOP lets you introduce new interfaces (and a corresponding implementation) to any advised object. For example, you could use an introduction to make a bean implement an IsModified interface, to simplify caching. (An introduction is known as an inter-type declaration in the AspectJ community.)</p>
</blockquote>
<h3 id="实例">实例</h3>
<p>1、准备一个 IndexDao 接口</p>
<pre><code class="language-java">public interface IndexDao {
    void query(String str);
}
</code></pre>
<p>2、准备一个 IndexDao 接口的实现类</p>
<pre><code class="language-java">@Repository(&quot;indexDao&quot;)
public class IndexDaoImpl implements IndexDao {
    @Override
    public void query(String str){
        System.out.println(&quot;query&quot;);
        System.out.println(str);
    }
}
</code></pre>
<p>3、再准备一个接口 OrderDAO，并把它注入到 Spring 容器中</p>
<pre><code class="language-java">@Repository(&quot;orderDao&quot;)
public class OrderDao {
}
</code></pre>
<p>4、引入</p>
<pre><code class="language-java">@Component
// 切面
@Aspect
public class NotVeryUsefulAspect {
     // 找到 com.ssm.dao 下的所有类，让它引入 IndexDao 接口的 IndexDaoImpl 实现，
    // 即让 class OrderDao implements IndexDao，并且方法的具体实现与 IndexDaoImpl 相同
    @DeclareParents(value=&quot;com.ssm.dao.*&quot;, defaultImpl= IndexDaoImpl.class)
    public static IndexDao indexDao;
}
</code></pre>
<p>5、测试</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws IOException {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        IndexDao dao = (IndexDao) context.getBean(&quot;orderDao&quot;);
        dao.query(&quot;hello&quot;);
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>query
hello
</code></pre>
<p>6、分析：orderDao 内并没有方法，但是获得容器内的 OrderDao 对象后却可以正常调用  query() 方法，原因就是使用了 Introduction。</p>
<h2 id="aspect-instantiation-models">Aspect Instantiation Models</h2>
<p>使用方式如下：<br>
@Aspect(&quot;perthis(this(com.chenss.dao.IndexDaoImpl))&quot;)<br>
要求：</p>
<ol>
<li>AspectJ对象的注入类型为prototype</li>
<li>目标对象也必须是prototype的<br>
原因为：只有目标对象是原型模式的，每次getBean得到的对象才是不一样的，由此针对每个对象就会产生新的切面对象，才能产生不同的切面结果。</li>
</ol>
<h3 id="示例">示例</h3>
<p>1、多例的 IndexDaoImpl</p>
<pre><code class="language-java">@Repository(&quot;indexDao&quot;)
@Scope(&quot;prototype&quot;)
public class IndexDaoImpl implements IndexDao {
</code></pre>
<p>2、单例的切面</p>
<pre><code class="language-java">@Component
@Aspect
public class NotVeryUsefulAspect {
    // 切点 com.ssm.dao 下的子包下的任意类的任意方法 任意返回值 任意修饰符
    @Pointcut(&quot;execution(* com.ssm.dao.*.*(..))&quot;)
    public void pointCut(){
    }

    @Around(&quot;pointCut()&quot;)
    // ProceedingJoinPoint：正在进行的 JointPoint：正在增强的方法
    public void around(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println(&quot;this.hashCode = &quot; + this.hashCode());
        Object[] args = pjp.getArgs();
        if(args != null &amp;&amp; args.length &gt; 0){
            for (int i = 0; i &lt; args.length; i++) {
                args[i] += &quot; world&quot;;
            }
        }
        System.out.println(&quot;around...before&quot;);
        // 拿到方法并执行它
        pjp.proceed(args);
        System.out.println(&quot;around...after&quot;);
    }
}
</code></pre>
<p>3、测试类</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws IOException {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        IndexDao dao = (IndexDao) context.getBean(&quot;indexDao&quot;);
        IndexDao dao1 = (IndexDao) context.getBean(&quot;indexDao&quot;);
        // com.ssm.dao.impl.IndexDaoImpl@24aed80c : com.ssm.dao.impl.IndexDaoImpl@3a52dba3
        System.out.println(dao+&quot; : &quot;+dao1);
        dao.query(&quot;hello&quot;);
        System.out.println(&quot; - - - - - - - - - - - &quot;);
        dao1.query(&quot;hi&quot;);
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>com.ssm.dao.impl.IndexDaoImpl@24aed80c : com.ssm.dao.impl.IndexDaoImpl@3a52dba3
this.hashCode = 1792550665
around...before
query
hello world
around...after
 - - - - - - - - - - - 
this.hashCode = 1792550665
around...before
query
hi world
around...after
</code></pre>
<p>4、分析：<br>
当 IndexDaoImpl 设置为原型时，两次 context.getBean(&quot;indexDaoImpl&quot;) 得到的 IndexDaoImpl 是不同的对象。但是不同的 bean 对象得到的切面却是完全相同的。</p>
<p>更改：AspectJ 对象的注入类型为 prototype，为所有代理对象是 IndexDaoImpl 的单独创建一个切点出来</p>
<pre><code class="language-java">@Component
// 为所有代理对象是 IndexDaoImpl 的单独创建一个切点出来
@Aspect(&quot;perthis(this(com.ssm.dao.impl.IndexDaoImpl))&quot;)
@Scope(&quot;prototype&quot;)
public class NotVeryUsefulAspect {
</code></pre>
<p>CJLIB 动态代理</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
// 开启 AspectJ 语法支持
@EnableAspectJAutoProxy(proxyTargetClass=true)
public class AppConfig {
}
</code></pre>
<p>运行结果：</p>
<pre><code>com.ssm.dao.impl.IndexDaoImpl@672872e1 : com.ssm.dao.impl.IndexDaoImpl@32910148
this.hashCode = 254801937
around...before
query
hello world
around...after
 - - - - - - - - - - - 
this.hashCode = 90767234
around...before
query
hi world
around...after
</code></pre>
<h2 id="target-object目标对象">Target object：目标对象</h2>
<blockquote>
<p>Target object: An object being advised by one or more aspects. Also referred to as the “advised object”. Since Spring AOP is implemented by using runtime proxies, this object is always a proxied object.</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/AOP%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1.png" alt="图片" loading="lazy"></figure>
<h2 id="aop-proxy-代理对象">AOP proxy 代理对象</h2>
<blockquote>
<p>AOP proxy: An object created by the AOP framework in order to implement the aspect contracts (advise method executions and so on). In the Spring Framework, an AOP proxy is a JDK dynamic proxy or a CGLIB proxy.</p>
</blockquote>
<h2 id="weaving">Weaving</h2>
<blockquote>
<p>Weaving: linking aspects with other application types or objects to create an advised object. This can be done at compile time (using the AspectJ compiler, for example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks, performs weaving at runtime.</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/AOP%E7%BB%87%E5%85%A5.png" alt="图片" loading="lazy"></figure>
<h1 id="springaop-支持-aspectj">SpringAOP 支持 AspectJ</h1>
<p>AOP 和 SpringAOP 的 关系？SpringAOP 是 AOP 的一种实现。<br>
实现 AOP 的技术：AspectJ、SpringAOP<br>
SpringAOP 和 AspectJ 的关系？Spring 原先版本的 AOP 语法过于繁琐，于是 Spring 借助了 AspectJ 的语法，底层技术还是用的 Spring 底层的技术。<br>
参考资料：<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-ataspectj">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-ataspectj</a></p>
<h2 id="0-导入-spring-依赖">0、导入 Spring 依赖</h2>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
  &lt;version&gt;5.0.9.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>准备一个 IndexDao：</p>
<pre><code class="language-java">@Repository
public class IndexDao {
    public void query(){
        System.out.println(&quot;query&quot;);
    }
}
</code></pre>
<h2 id="1-启用aspectj支持">1、启用@AspectJ支持</h2>
<p>使用Java Configuration启用@AspectJ支持<br>
要使用Java @Configuration启用@AspectJ支持，请添加@EnableAspectJAutoProxy注释</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
@EnableAspectJAutoProxy
public class AppConfig {

}
</code></pre>
<p>使用XML配置启用@AspectJ支持<br>
要使用基于xml的配置启用@AspectJ支持，可以使用aop:aspectj-autoproxy元素</p>
<pre><code class="language-xml">&lt;aop:aspectj-autoproxy/&gt;
</code></pre>
<h2 id="2-声明一个aspect">2、声明一个Aspect</h2>
<p>引入 Aspect 依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
  &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
  &lt;version&gt;1.9.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>声明一个@Aspect注释类，并且定义成一个bean交给Spring管理。</p>
<pre><code class="language-java">@Component
@Aspect
public class UserAspect {
}
</code></pre>
<h2 id="3-声明一个pointcut">3、声明一个PointCut</h2>
<p>切入点表达式由@Pointcut注释表示。切入点声明由两部分组成:一个签名包含名称和任何参数，以及一个切入点表达式，该表达式确定我们对哪个方法执行感兴趣。</p>
<pre><code class="language-java">@Pointcut(&quot;execution(* transfer(..))&quot;)// 切入点表达式
private void anyOldTransfer() {}// 切入点签名
</code></pre>
<p>切入点确定感兴趣的 join points（连接点），从而使我们能够控制何时执行通知。Spring AOP只支持Spring bean的方法执行 join points（连接点），所以您可以将切入点看作是匹配Spring bean上方法的执行。</p>
<pre><code class="language-java">/**
 * 申明Aspect，并且交给spring容器管理
 */
@Component
@Aspect
public class UserAspect {
    /**
     * 申明切入点，匹配UserDao所有方法调用
     * execution匹配方法执行连接点
     * within:将匹配限制为特定类型中的连接点
     * args：参数
     * target：目标对象
     * this：代理对象
     */
    @Pointcut(&quot;execution(* com.yao.dao.UserDao.*(..))&quot;)
    public void pintCut(){
        System.out.println(&quot;point cut&quot;);
    }
</code></pre>
<h2 id="4-声明一个advice通知">4、声明一个Advice通知</h2>
<p>advice通知与pointcut切入点表达式相关联，并在切入点匹配的方法执行@Before之前、@After之后或前后运行。</p>
<pre><code class="language-java">/**
 * 申明Aspect，并且交给spring容器管理
 */
@Component
@Aspect
public class UserAspect {
    /**
     * 申明切入点，匹配UserDao所有方法调用
     * execution匹配方法执行连接点
     * within:将匹配限制为特定类型中的连接点
     * args：参数
     * target：目标对象
     * this：代理对象
     */
    @Pointcut(&quot;execution(* com.yao.dao.UserDao.*(..))&quot;)
    public void pintCut(){
        System.out.println(&quot;point cut&quot;);
    }
    /**
     * 申明before通知,在pintCut切入点前执行
     * 通知与切入点表达式相关联，
     * 并在切入点匹配的方法执行之前、之后或前后运行。
     * 切入点表达式可以是对指定切入点的简单引用，也可以是在适当位置声明的切入点表达式。
     */
    @Before(&quot;com.yao.aop.UserAspect.pintCut()&quot;)
    public void beforeAdvice(){
        System.out.println(&quot;before&quot;);
    }
}
</code></pre>
<p>测试类：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        IndexDao dao = context.getBean(IndexDao.class);
        dao.query();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>before
query
</code></pre>
<h1 id="各种连接点-joinpoint-的意义">各种连接点 JoinPoint 的意义:</h1>
<h2 id="execution">execution</h2>
<p>用于匹配方法执行连接点，最小粒度方法，在aop中主要使用。</p>
<pre><code class="language-java">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern)
          throws-pattern?)
</code></pre>
<p>这里问号表示当前项可以有也可以没有，其中各项的语义如下：<br>
modifiers-pattern：方法的可见性，如public，protected；<br>
ret-type-pattern：方法的返回值类型，如int，void等；<br>
declaring-type-pattern：方法所在类的全路径名，如com.spring.Aspect；<br>
name-pattern：方法名类型，如 buisinessService()；<br>
param-pattern：方法的参数类型，如java.lang.String；<br>
throws-pattern：方法抛出的异常类型，如java.lang.Exception；</p>
<h3 id="examples">Examples</h3>
<p>@Pointcut(&quot;execution(* com.chenss.dao.<em>.</em>(..))&quot;)//匹配com.chenss.dao包下的任意接口和类的任意方法【方法返回值类型任意，方法所在类的全路径名：com.chenss.dao，方法名类型任意，方法的参数类型任意】<br>
@Pointcut(&quot;execution(public * com.chenss.dao.<em>.</em>(..))&quot;)//匹配com.chenss.dao包下的任意接口和类的public方法<br>
@Pointcut(&quot;execution(public * com.chenss.dao.<em>.</em>())&quot;)//匹配com.chenss.dao包下的任意接口和类的public 无方法参数的方法<br>
@Pointcut(&quot;execution(* com.chenss.dao.<em>.</em>(java.lang.String, ..))&quot;)//匹配com.chenss.dao包下的任意接口和类的第一个参数为String类型的方法<br>
@Pointcut(&quot;execution(* com.chenss.dao.<em>.</em>(java.lang.String))&quot;)//匹配com.chenss.dao包下的任意接口和类的只有一个参数，且参数为String类型的方法<br>
@Pointcut(&quot;execution(* com.chenss.dao.<em>.</em>(java.lang.String))&quot;)//匹配com.chenss.dao包下的任意接口和类的只有一个参数，且参数为String类型的方法<br>
@Pointcut(&quot;execution(public * <em>(..))&quot;)//匹配任意的public方法<br>
@Pointcut(&quot;execution(</em> te*(..))&quot;)//匹配任意的以te开头的方法<br>
@Pointcut(&quot;execution(* com.chenss.dao.IndexDao.<em>(..))&quot;)//匹配com.chenss.dao.IndexDao接口中任意的方法<br>
@Pointcut(&quot;execution(</em> com.chenss.dao..<em>.</em>(..))&quot;)//匹配com.chenss.dao包及其子包中任意的方法</p>
<p>关于这个表达式的详细写法,可以脑补也可以参考官网很容易的,可以作为一个看spring官网文档的入门,打破你害怕看官方文档的心理,其实你会发觉官方文档也是很容易的<br>
<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-pointcuts-examples">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-pointcuts-examples</a></p>
<p>由于Spring切面粒度最小是达到方法级别，而execution表达式可以用于明确指定方法返回类型，类名，方法名和参数名等与方法相关的信息，并且在Spring中，大部分需要使用AOP的业务场景也只需要达到方法级别即可，因而execution表达式的使用是最为广泛的。</p>
<h2 id="within">within</h2>
<p>表达式的最小粒度为类<br>
within与execution相比，粒度更大，仅能实现到包和接口、类级别。而execution可以精确到方法的返回值，参数个数、修饰符、参数类型等</p>
<pre><code class="language-java">@Pointcut(&quot;within(com.chenss.dao.*)&quot;)//匹配com.chenss.dao包中的任意方法
@Pointcut(&quot;within(com.chenss.dao..*)&quot;)//匹配com.chenss.dao包及其子包中的任意方法
</code></pre>
<h2 id="args">args</h2>
<blockquote>
<p>args: Limits matching to join points (the execution of methods when using Spring AOP) where the arguments are instances of the given types.</p>
</blockquote>
<p>限制连接点的匹配(使用Spring AOP时方法的执行)，其中的参数是给定类型的实例。<br>
args表达式的作用是匹配指定参数类型和指定参数数量的方法,与包名和类名无关</p>
<pre><code class="language-java">/**
 * args同execution不同的地方在于：
 * args匹配的是运行时传递给方法的参数类型
 * execution(* *(java.io.Serializable))匹配的是方法在声明时指定的方法参数类型。
 */
@Pointcut(&quot;args(java.io.Serializable)&quot;)//匹配运行时传递的参数类型为指定类型的、且参数个数和顺序匹配
@Pointcut(&quot;@args(com.chenss.anno.Chenss)&quot;)//接受一个参数，并且传递的参数的运行时类型具有@Classified
</code></pre>
<h2 id="this">this</h2>
<blockquote>
<p>this: Limits matching to join points (the execution of methods when using Spring AOP) where the bean reference (Spring AOP proxy) is an instance of the given type.</p>
</blockquote>
<p>限制连接点(使用Spring AOP时方法的执行)的匹配，其中bean引用(Spring AOP代理)是给定类型的实例。<br>
<strong>this JDK代理时，指向接口和代理类proxy，cglib代理时 指向接口和子类(不使用proxy)</strong></p>
<h2 id="target">target</h2>
<p>target: Limits matching to join points (the execution of methods when using Spring AOP) where the target object (application object being proxied) is an instance of the given type.<br>
限制对连接点(使用Spring AOP时方法的执行)的匹配，其中目标对象(代理的应用程序对象)是给定类型的实例。<br>
<strong>target  指向接口和子类</strong>。</p>
<pre><code class="language-java">/**
 * 此处需要注意的是，如果配置设置proxyTargetClass=false，或默认为false，则是用JDK代理，否则使用的是CGLIB代理
 * JDK代理的实现方式是基于接口实现，代理类继承Proxy，实现接口。
 * 而CGLIB继承被代理的类来实现。
 * 所以使用target会保证目标不变，关联对象不会受到这个设置的影响。
 * 但是使用this对象时，会根据该选项的设置，判断是否能找到对象。
 */
@Pointcut(&quot;target(com.chenss.dao.IndexDaoImpl)&quot;)//目标对象，也就是被代理的对象。限制目标对象为com.chenss.dao.IndexDaoImpl类
@Pointcut(&quot;this(com.chenss.dao.IndexDaoImpl)&quot;)//当前对象，也就是代理对象，代理对象时通过代理目标对象的方式获取新的对象，与原值并非一个
@Pointcut(&quot;@target(com.chenss.anno.Chenss)&quot;)//具有@Chenss的目标对象中的任意方法
@Pointcut(&quot;@within(com.chenss.anno.Chenss)&quot;)//等同于@targ
</code></pre>
<p>这个比较难.......<br>
proxy模式里面有两个重要的术语<br>
proxy Class<br>
target Class<br>
CGLIB和JDK有区别    JDK是基于接口   cglib是基于继承，所有this可以在cglib作用</p>
<h2 id="annotation">@annotation</h2>
<p>这个很简单........<br>
作用<strong>方法</strong>级别<br>
上述所有表达式都有@ 比如@Target(里面是一个注解类xx,表示所有加了xx注解的类,和包名无关)<br>
注意:上述所有的表达式可以混合使用,|| &amp;&amp; !</p>
<pre><code class="language-java">@Before(&quot;pointCutWithin()&amp;&amp;!pointCutArgs()&quot;)
</code></pre>
<pre><code class="language-java">@Pointcut(&quot;@annotation(com.chenss.anno.Chenss)&quot;)//匹配带有com.chenss.anno.Chenss注解的方法
</code></pre>
<p>如下面这个方法：</p>
<pre><code class="language-java">@Chenss
public void query(String str){
</code></pre>
<h2 id="bean">bean</h2>
<pre><code class="language-java">@Pointcut(&quot;bean(dao1)&quot;)//名称为dao1的bean上的任意方法
@Pointcut(&quot;bean(dao*)&quot;)
</code></pre>
<h1 id="aop-proxies">AOP Proxies</h1>
<p>参考链接：<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-introduction-proxies">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-introduction-proxies</a></p>
<blockquote>
<p>Spring AOP defaults to using standard JDK dynamic proxies for AOP proxies. This enables any interface (or set of interfaces) to be proxied.</p>
</blockquote>
<p>Spring AOP 默认使用标准 JDK 动态代理来完成 AOP 代理。这允许代理任何接口(或一组接口)。</p>
<h2 id="问题引入">问题引入</h2>
<p>1、定义一个接口</p>
<pre><code class="language-java">public interface IndexDao {
    void query(String str);
}
</code></pre>
<p>2、自定义一个注解</p>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
public @interface Luban {
}
</code></pre>
<p>3、定义切面，@annotation 连接点</p>
<pre><code class="language-java">@Component
// 切面
@Aspect
public class NotVeryUsefulAspect {
    @Pointcut(&quot;@annotation(com.ssm.anno.Luban)&quot;)
    public void pointCutAnno(){
    }
    /**
     * 通知
     *  通知位置：pointCut() 的前面
     *  通知内容
     */
    @Before(&quot;pointCutAnno()&quot;)
    public void before(){
        System.out.println(&quot;before&quot;);
    }
}
</code></pre>
<p>4、接口实现类，使用注解增强 query 方法</p>
<pre><code class="language-java">@Repository(&quot;indexDao&quot;)
public class IndexDaoImpl implements IndexDao {
    @Override
    @Luban
    public void query(String str){
        System.out.println(&quot;query&quot;);
    }
}
</code></pre>
<p>5、配置文件类</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
// 开启 AspectJ 语法支持
@EnableAspectJAutoProxy
public class AppConfig {
}
</code></pre>
<p>6、测试类</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        IndexDao dao = (IndexDao) context.getBean(&quot;indexDao&quot;);
        System.out.println(dao instanceof IndexDaoImpl);
        dao.query(&quot;111&quot;);
    }
}
</code></pre>
<p>7、运行结果：</p>
<pre><code>false
before
query
</code></pre>
<p>8、分析：为什么我们将一个 IndexDaoImpl 放入 Spring 容器（@Repository），然后再从 Spring 容器内取出来（context.getBean(&quot;indexDao&quot;)）类型却不是 IndexDaoImpl 了呢？<br>
9、在配置类中加上：@EnableAspectJAutoProxy(proxyTargetClass = true) 后，设置代理方式为 cglib 代理：</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
// 开启 AspectJ 语法支持
@EnableAspectJAutoProxy(proxyTargetClass = true)
public class AppConfig {
}
</code></pre>
<p>System.out.println(dao instanceof IndexDaoImpl); 返回 true 了。<br>
注：proxyTargetClass 默认是 false，所以 dao instanceof IndexDaoImpl 返回 false。</p>
<pre><code class="language-java">boolean proxyTargetClass() default false;
</code></pre>
<h2 id="spring-aop-默认使用标准-jdk-动态代理来完成-aop-代理">Spring AOP 默认使用标准 JDK 动态代理来完成 AOP 代理</h2>
<p>当我们使用 JDK 动态代理时，即 @EnableAspectJAutoProxy(proxyTargetClass = false)，从 Spring 容器中取出来的对象与放进去的对象不一致：context.getBean(&quot;indexDao&quot;) instanceof IndexDaoImpl 返回 false。<br>
但是 context.getBean(&quot;indexDao&quot;) instanceof indexDao 返回 true，因为 JDK 动态代理底层用的是接口。<br>
context.getBean(&quot;indexDao&quot;) instanceof Proxy 也返回 true。<br>
实现代理的办法</p>
<ul>
<li>继承</li>
<li>聚合接口（JDK 动态代理基于聚合）</li>
<li>动态代理</li>
</ul>
<h3 id="jdk-动态代理为什么只能是基于接口不能用继承">JDK 动态代理为什么只能是基于接口，不能用继承？</h3>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws IOException {
        Class&lt;?&gt;[] interfaces = new Class[]{IndexDao.class};
        byte[] bytes = ProxyGenerator.generateProxyClass(&quot;SSM&quot;,interfaces);
        File file = new File(&quot;C:\\Users\\Only\\Test.class&quot;);
        FileOutputStream fw = new FileOutputStream(file);
        fw.write(bytes);
        fw.flush();
        fw.close();
    }
}
</code></pre>
<p>注意：ProxyGenerator 的使用是基于 JDK8 的，如果使用 JDK10 会报 “找不到符号” 错误，参考：<a href="https://blog.csdn.net/weixin_46034990/article/details/105892718">https://blog.csdn.net/weixin_46034990/article/details/105892718</a><br>
JDK 底层源码已经帮这个对象自动继承了一个 Proxy 对象了，由于 Java 是单继承，所以不可能再去继承目标对象，所以只能实现目标对象的接口。<br>
<img src="https://epitomm.github.io/post-images/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.png" alt="图片" loading="lazy"><br>
基于上图可以看出，这个代理对象等于 IndexDao、也等于 Proxy，但是不等于 IndexDaoImpl，这也就解释了上述 【context.getBean(&quot;indexDao&quot;) instanceof IndexDaoImpl 返回 false。context.getBean(&quot;indexDao&quot;) instanceof indexDao 返回 true、context.getBean(&quot;indexDao&quot;) instanceof Proxy 也返回 true。】的原因。</p>
<h2 id="this-切点">this 切点</h2>
<p>this 表示<strong>代理对象</strong>的匹配类型<br>
前提：使用 JDK 动态代理，即 @EnableAspectJAutoProxy(proxyTargetClass = false)</p>
<pre><code class="language-java">@Component
// 切面
@Aspect
public class NotVeryUsefulAspect {
    // this 表示代理对象的匹配类型，使用 JDK 动态代理后，代理对象的类型是：Proxy、IndexDao，但不是 IndexDaoImpl
    @Pointcut(&quot;this(com.ssm.dao.IndexDao)&quot;)
    public void pointCutThis(){
        System.out.println(&quot;point cut&quot;);
    }
    /**
     * 通知
     *  通知位置：pointCut() 的前面
     *  通知内容
     */
    @Before(&quot;pointCutThis()&quot;)
    public void before(){
        System.out.println(&quot;before&quot;);
    }
}
</code></pre>
<p>增强成功：</p>
<pre><code>before
query
</code></pre>
<pre><code class="language-java">// this 表示代理对象的匹配类型，使用 JDK 动态代理后，代理对象的类型是：Proxy、IndexDao，但不是 IndexDaoImpl
@Pointcut(&quot;this(com.ssm.dao.impl.IndexDaoImpl)&quot;)
public void pointCutThis(){
    System.out.println(&quot;point cut&quot;);
}

@Before(&quot;pointCutThis()&quot;)
public void before(){
    System.out.println(&quot;before&quot;);
}
</code></pre>
<p>增强失败：</p>
<pre><code>query
</code></pre>
<h1 id="spring-aop-xml实现方式的注意事项">Spring AOP XML实现方式的注意事项:</h1>
<ol>
<li>在aop:config中定义切面逻辑，允许重复出现，重复多次，以最后出现的逻辑为准，但是次数以出现的次数为准</li>
<li>aop:aspect ID重复不影响正常运行，依然能够有正确结果</li>
<li>aop:pointcut ID重复会出现覆盖，以最后出现的为准。不同aop:aspect内出现的pointcut配置，可以相互引用</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/aop
                           http://www.springframework.org/schema/aop/spring-aop.xsd
                           http://www.springframework.org/schema/context
                           http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!-- 定义开始进行注解扫描 --&gt;
    &lt;context:component-scan base-package=&quot;com.chenss&quot;&gt;&lt;/context:component-scan&gt;

    &lt;!-- 定义AspectJ对象使用的逻辑类，类中提供切面之后执行的逻辑方法 --&gt;
    &lt;bean id=&quot;aspectAop&quot; class=&quot;com.chenss.aspectj.Aspect&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;aspectAop2&quot; class=&quot;com.chenss.aspectj.Aspect2&quot;&gt;&lt;/bean&gt;

    &lt;bean id=&quot;indexDao&quot; class=&quot;com.chenss.entity.IndexDao&quot;&gt;&lt;/bean&gt;

    &lt;!--在Config中定义切面逻辑，允许重复出现，重复多次，以最后出现的逻辑为准，但是次数以出现的次数为准--&gt;
    &lt;aop:config&gt;
        &lt;!-- aop:aspect ID重复不影响正常运行，依然能够有正确结果 --&gt;
        &lt;!-- aop:pointcut ID重复会出现覆盖，以最后出现的为准。不同aop:aspect内出现的pointcut配置，可以相互引用 --&gt;
        &lt;aop:aspect id=&quot;aspect&quot; ref=&quot;aspectAop&quot;&gt;
            &lt;aop:pointcut id=&quot;aspectCut&quot; expression=&quot;execution(* com.chenss.entity.*.*())&quot;/&gt;
            &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;aspectCut&quot;&gt;&lt;/aop:before&gt;
      
            &lt;aop:pointcut id=&quot;aspectNameCut&quot; expression=&quot;execution(* com.chenss.entity.*.*(java.lang.String, ..))&quot;/&gt;
            &lt;aop:before method=&quot;before2&quot; pointcut-ref=&quot;aspectNameCut&quot;&gt;&lt;/aop:before&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3">自定义注解</a>
<ul>
<li><a href="#xml-%E7%9A%84%E4%BD%9C%E7%94%A8">xml 的作用？</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3-2">自定义注解</a>
<ul>
<li><a href="#%E4%B8%80-%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5">一、准备阶段</a>
<ul>
<li><a href="#1%E5%AE%9A%E4%B9%89%E5%AE%9E%E4%BD%93%E7%B1%BB">1.定义实体类</a></li>
<li><a href="#2%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E7%B1%BB">2.定义工具类</a></li>
<li><a href="#3%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95">3.测试方法</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD">二、自定义注解——基本功能</a>
<ul>
<li><a href="#1%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3">1.自定义注解</a></li>
<li><a href="#2%E5%AE%9E%E4%BD%93%E7%B1%BB%E6%B7%BB%E5%8A%A0%E6%B3%A8%E8%A7%A3">2.实体类添加注解</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%85%83%E6%B3%A8%E8%A7%A3">三、自定义注解——元注解</a>
<ul>
<li><a href="#1%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%BD%93%E4%BC%9A%E5%85%83%E6%B3%A8%E8%A7%A3">1.实体类体会元注解</a></li>
<li><a href="#2%E4%BF%AE%E6%94%B9%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E7%B1%BB">2.修改自定义注解类</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E8%8E%B7%E5%BE%97%E6%B3%A8%E8%A7%A3%E5%86%85%E7%9A%84%E5%80%BC">四、获得注解内的值</a></li>
</ul>
</li>
<li><a href="#%E6%B3%A8%E8%A7%A3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">注解生命周期</a>
<ul>
<li><a href="#retentionretentionpolicysource">@Retention(RetentionPolicy.SOURCE)</a></li>
<li><a href="#retentionretentionpolicyclass">@Retention(RetentionPolicy.CLASS)</a></li>
<li><a href="#retentionretentionpolicyruntime">@Retention(RetentionPolicy.RUNTIME)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#aop-%E6%98%AF%E4%BB%80%E4%B9%88">AOP 是什么</a>
<ul>
<li><a href="#aop-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">AOP 的应用场景</a></li>
<li><a href="#springaop-%E7%9A%84%E5%BA%95%E5%B1%82%E6%8A%80%E6%9C%AF">SpringAOP 的底层技术</a></li>
<li><a href="#springaop-%E5%92%8C-aspectj-%E7%9A%84%E5%85%B3%E7%B3%BB">SpringAOP 和 AspectJ 的关系</a></li>
<li><a href="#aspect-%E5%88%87%E9%9D%A2">Aspect 切面</a></li>
<li><a href="#join-point-%E8%BF%9E%E6%8E%A5%E7%82%B9">Join point 连接点</a>
<ul>
<li><a href="#after">After</a></li>
<li><a href="#before">Before</a></li>
<li><a href="#around">Around</a></li>
<li><a href="#xml-%E9%80%9A%E7%9F%A5">XML 通知</a>
<ul>
<li><a href="#%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%E4%B8%AD%E6%94%B9%E5%8F%98%E5%8F%82%E6%95%B0%E5%80%BC">环绕通知中改变参数值</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#pointcut-%E5%88%87%E7%82%B9">Pointcut 切点</a></li>
<li><a href="#introduction">Introduction</a>
<ul>
<li><a href="#%E5%AE%9E%E4%BE%8B">实例</a></li>
</ul>
</li>
<li><a href="#aspect-instantiation-models">Aspect Instantiation Models</a>
<ul>
<li><a href="#%E7%A4%BA%E4%BE%8B">示例</a></li>
</ul>
</li>
<li><a href="#target-object%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1">Target object：目标对象</a></li>
<li><a href="#aop-proxy-%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1">AOP proxy 代理对象</a></li>
<li><a href="#weaving">Weaving</a></li>
</ul>
</li>
<li><a href="#springaop-%E6%94%AF%E6%8C%81-aspectj">SpringAOP 支持 AspectJ</a>
<ul>
<li><a href="#0-%E5%AF%BC%E5%85%A5-spring-%E4%BE%9D%E8%B5%96">0、导入 Spring 依赖</a></li>
<li><a href="#1-%E5%90%AF%E7%94%A8aspectj%E6%94%AF%E6%8C%81">1、启用@AspectJ支持</a></li>
<li><a href="#2-%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AAaspect">2、声明一个Aspect</a></li>
<li><a href="#3-%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AApointcut">3、声明一个PointCut</a></li>
<li><a href="#4-%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AAadvice%E9%80%9A%E7%9F%A5">4、声明一个Advice通知</a></li>
</ul>
</li>
<li><a href="#%E5%90%84%E7%A7%8D%E8%BF%9E%E6%8E%A5%E7%82%B9-joinpoint-%E7%9A%84%E6%84%8F%E4%B9%89">各种连接点 JoinPoint 的意义:</a>
<ul>
<li><a href="#execution">execution</a>
<ul>
<li><a href="#examples">Examples</a></li>
</ul>
</li>
<li><a href="#within">within</a></li>
<li><a href="#args">args</a></li>
<li><a href="#this">this</a></li>
<li><a href="#target">target</a></li>
<li><a href="#annotation">@annotation</a></li>
<li><a href="#bean">bean</a></li>
</ul>
</li>
<li><a href="#aop-proxies">AOP Proxies</a>
<ul>
<li><a href="#%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5">问题引入</a></li>
<li><a href="#spring-aop-%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%E6%A0%87%E5%87%86-jdk-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9D%A5%E5%AE%8C%E6%88%90-aop-%E4%BB%A3%E7%90%86">Spring AOP 默认使用标准 JDK 动态代理来完成 AOP 代理</a>
<ul>
<li><a href="#jdk-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E8%83%BD%E6%98%AF%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E4%B8%8D%E8%83%BD%E7%94%A8%E7%BB%A7%E6%89%BF">JDK 动态代理为什么只能是基于接口，不能用继承？</a></li>
</ul>
</li>
<li><a href="#this-%E5%88%87%E7%82%B9">this 切点</a></li>
</ul>
</li>
<li><a href="#spring-aop-xml%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">Spring AOP XML实现方式的注意事项:</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://epitomm.github.io/post/spring-ioc/">
              <h3 class="post-title">
                Spring系列（一）Spring IoC 应用
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '974bd77fbbd52c2a0647',
    clientSecret: '6344370ca1314dbd553f45e75a2121a160ef1c44',
    repo: 'EpitomM.github.io',
    owner: 'EpitomM',
    admin: ['EpitomM'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/EpitomM/EpitomM.github.io" target="_blank">EpitomM</a>
  <a class="rss" href="https://epitomm.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
