<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>HTTP 系列（二）熟悉 HTTP 协议结构和通讯原理 | SSM</title>
<link rel="shortcut icon" href="https://epitomm.github.io/favicon.ico?v=1587702993890">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://epitomm.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="HTTP 系列（二）熟悉 HTTP 协议结构和通讯原理 | SSM - Atom Feed" href="https://epitomm.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="HTTP 特点
支持 客户/服务器 模式
客户/服务器模式工作的方式是由客户端向服务器发出请求，服务器端响应请求，并进行相应服务。

简单快速

客户向服务器请求服务时，只需传送请求方法和路径
请求方法常用的有GET、HEAD、POST。每..." />
    <meta name="keywords" content="HTTP,计算机网络" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://epitomm.github.io">
  <img class="avatar" src="https://epitomm.github.io/images/avatar.png?v=1587702993890" alt="">
  </a>
  <h1 class="site-title">
    SSM
  </h1>
  <p class="site-description">
    热心善良的老学姐
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              HTTP 系列（二）熟悉 HTTP 协议结构和通讯原理
            </h2>
            <div class="post-info">
              <span>
                2020-04-23
              </span>
              <span>
                21 min read
              </span>
              
                <a href="https://epitomm.github.io/tag/LXiZFuZAY/" class="post-tag">
                  # HTTP
                </a>
              
                <a href="https://epitomm.github.io/tag/QxXq3bhNg/" class="post-tag">
                  # 计算机网络
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="http-特点">HTTP 特点</h1>
<h2 id="支持-客户服务器-模式">支持 客户/服务器 模式</h2>
<p>客户/服务器模式工作的方式是由客户端向服务器发出请求，服务器端响应请求，并进行相应服务。</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/client-server.png" alt="图片" loading="lazy"></figure>
<h2 id="简单快速">简单快速</h2>
<ul>
<li>客户向服务器请求服务时，只需传送<strong>请求方法和路径</strong></li>
<li>请求方法常用的有<strong>GET、HEAD、POST</strong>。每种方法规定了客户与服务器联系的类型不同</li>
<li>由于HTTP协议简单，使得HTTP服务器的程序规模小，因而<strong>通信速度很快</strong></li>
</ul>
<h2 id="灵活">灵活</h2>
<ul>
<li><strong>HTTP允许传输任意类型的数据对象</strong></li>
<li>正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记</li>
</ul>
<h2 id="无连接">无连接</h2>
<ul>
<li>无连接的含义是限制<strong>每次连接只处理一个请求</strong></li>
<li>服务器处理完客户的请求，并收到客户的应答后，即断开连接</li>
<li>采用这种方式可以<strong>节省传输时间</strong></li>
</ul>
<h2 id="无状态">无状态</h2>
<ul>
<li>HTTP协议是无状态协议</li>
<li>无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大</li>
<li>另一方面，在服务器不需要先前信息时它的应答就较快</li>
</ul>
<h1 id="uri-与-url">URI 与 URL</h1>
<p>Q：我们输入在浏览器里的Web地址应该叫URL还是URI？</p>
<p>小A：我们访问的就是<strong>URL</strong>！</p>
<p>小B：不！其实那时<strong>URI</strong>好不好！</p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/URI.png" alt="图片" loading="lazy"></figure>
<ul>
<li>URI：一个紧凑的字符串用来标示抽象或物理资源</li>
<li>A URI 可以进一步被分为定位符、名字或两者都是</li>
<li>术语&quot;Uniform Resource Locator&quot;（URL）是URI的子集，除了确定一个资源，还提供一种定位该资源的主要访问机制（如其网络“位置”）</li>
</ul>
<h2 id="维基百科解释">维基百科解释</h2>
<ul>
<li>URI可以分为URL，URN或同时具备locators 和names特性的一个东西</li>
<li>URN作用就好像一个人的<strong>名字</strong>，URL就像一个人的<strong>地址</strong></li>
<li>换句话说：URN确定了东西的身份，URL提供了找到它的方式</li>
</ul>
<blockquote>
<p>一家公司的总经理有一张名片，上面写了 “北京 xxx 公司总经理张三”、办公室地址 “北京市海淀区长安街35号 xx 楼 xxx 办公室”。<br>
头衔：北京 xxx 公司总经理 —— 张三，建立一个映射，这个头衔就是 URI，<strong>只要看到一个 URI 就知道它代表什么</strong>。<br>
<a href="http://www.baidu.cn">www.baidu.cn</a> —— 百度网，<a href="http://www.baidu.com">www.baidu.com</a> 就是一个 URI<br>
admin@qq.com —— 代表某个人的 QQ 邮箱，admin@qq.com 也是一个 URI<br>
<strong>URI 是一个网络资源的头衔</strong>，是一个统称，通过 URI 可以把网络世界里的每一个事务都加以标记并且区分开来。<br>
“北京 xxx 公司总经理” 是一个 URI，我们知道这个头衔对应的是张三，但是我们不能去找到这个人，因为不知道他的地址，要定位到他就必须要知道他的办公室地址。反映到网络世界，网络世界中的每个资源不只有头衔，还要能够被人访问，所以网络地址也是必须的，否则这个网络资源的存在就没有任何意义了，这个<strong>网络地址就叫做 URL</strong>。</p>
</blockquote>
<ul>
<li>URL是URI的一种，但不是所有的URI都是URL</li>
<li>URI和URL最大的差别是“访问机制（HTTP 还是 FTP）&quot;</li>
<li>URN 是唯一标识的一部分，是身份信息</li>
</ul>
<h2 id="安能辨我是雌雄">安能辨我是雌雄</h2>
<ul>
<li>ftp://ftp.is.co.za/rfc/rfc1808.txt
<ul>
<li>URL，提供了访问机制是 FTP</li>
</ul>
</li>
<li>http://www.ietf.org/rfc/rfc2396.txt
<ul>
<li>URL，提供了访问机制是 HTTP</li>
</ul>
</li>
<li>Idap://[2001:db8::7]/c=GB?objectClass?one
<ul>
<li>URL，提供了访问机制 LDAP</li>
</ul>
</li>
<li>mailto:John.Doe@example.com
<ul>
<li>URL，通过邮件进行访问</li>
</ul>
</li>
<li>news:comp.infosystems.www.servers.unix
<ul>
<li>URL</li>
</ul>
</li>
<li>tel:+1-816-555-1212
<ul>
<li>URI：电话号码可以标识某一个人，但是没有访问机制</li>
</ul>
</li>
<li>telnet://192.0.2.16:80/
<ul>
<li>URL，访问机制 telnet</li>
</ul>
</li>
<li>urn:oasis:names:specification:docbook:dtd:xml:4.1.2
<ul>
<li>URL，地址中已经显示了 urn，没有自己的访问方式</li>
</ul>
</li>
</ul>
<h1 id="http-报文结构分析-请求报文">HTTP 报文结构分析 - 请求报文</h1>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>报文头和报文体中间有一行空行<br>
报文体内是表单的数据，不同参数之间使用 &amp; 进行拼接</p>
</blockquote>
<h2 id="http-报文头">HTTP 报文头</h2>
<ul>
<li>HTTP的报文头大体可以分为四类，分别是：通用报文头、请求报文头、响应报文头和实体报文头</li>
<li>在HTTP/1.1里一共规范了47种报文头字段</li>
</ul>
<h3 id="通用报文头">通用报文头</h3>
<table>
<thead>
<tr>
<th style="text-align:left">首部字段名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Cache-Control</td>
<td style="text-align:left">控制缓存的行为</td>
</tr>
<tr>
<td style="text-align:left">Connection</td>
<td style="text-align:left">逐跳首部、连接的管理</td>
</tr>
<tr>
<td style="text-align:left">Date</td>
<td style="text-align:left">创建报文的日期时间</td>
</tr>
<tr>
<td style="text-align:left">Pragma</td>
<td style="text-align:left">报文指令</td>
</tr>
<tr>
<td style="text-align:left">Trailer</td>
<td style="text-align:left">报文末端的首部一览</td>
</tr>
<tr>
<td style="text-align:left">Transfer-Encoding</td>
<td style="text-align:left">指定报文主体的传输编码方式</td>
</tr>
<tr>
<td style="text-align:left">Upgrade</td>
<td style="text-align:left">升级为其他协议</td>
</tr>
<tr>
<td style="text-align:left">Via</td>
<td style="text-align:left">代理服务器的相关信息</td>
</tr>
<tr>
<td style="text-align:left">Warning</td>
<td style="text-align:left">错误通知</td>
</tr>
</tbody>
</table>
<h3 id="请求报文头">请求报文头</h3>
<table>
<thead>
<tr>
<th style="text-align:left">首部字段名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Accept</td>
<td style="text-align:left">用户代理可处理的媒体类型</td>
</tr>
<tr>
<td style="text-align:left">Accept-Charset</td>
<td style="text-align:left">优先的字符集</td>
</tr>
<tr>
<td style="text-align:left">Accept-Encoding</td>
<td style="text-align:left">优先的内容编码</td>
</tr>
<tr>
<td style="text-align:left">Accept-Language</td>
<td style="text-align:left">优先的语言（自然语言）</td>
</tr>
<tr>
<td style="text-align:left">Authorization</td>
<td style="text-align:left">Web 认证信息</td>
</tr>
<tr>
<td style="text-align:left">Expect</td>
<td style="text-align:left">期待服务器的特定行为</td>
</tr>
<tr>
<td style="text-align:left">From</td>
<td style="text-align:left">用户的电子邮箱地址</td>
</tr>
<tr>
<td style="text-align:left">Host</td>
<td style="text-align:left">请求资源所在服务器</td>
</tr>
<tr>
<td style="text-align:left">If-Match</td>
<td style="text-align:left">比较实体标记（ETag）</td>
</tr>
<tr>
<td style="text-align:left">If-Modified-Since</td>
<td style="text-align:left">比较资源的更新时间</td>
</tr>
<tr>
<td style="text-align:left">If-None-Match</td>
<td style="text-align:left">比较实体标记（与 If-Match 相反）</td>
</tr>
<tr>
<td style="text-align:left">If-Range</td>
<td style="text-align:left">资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td style="text-align:left">If-Unmodified-Since</td>
<td style="text-align:left">比较资源的更新时间（与 If-Modified-Since相反）</td>
</tr>
<tr>
<td style="text-align:left">Max-Forwards</td>
<td style="text-align:left">最大传输逐跳数</td>
</tr>
<tr>
<td style="text-align:left">Proxy-Authorization</td>
<td style="text-align:left">代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td style="text-align:left">Range</td>
<td style="text-align:left">实体的字节范围请求</td>
</tr>
<tr>
<td style="text-align:left">Referrer</td>
<td style="text-align:left">对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td style="text-align:left">TE</td>
<td style="text-align:left">传输编码的优先级</td>
</tr>
<tr>
<td style="text-align:left">User-Agent</td>
<td style="text-align:left">HTTP 客户端程序的信息</td>
</tr>
</tbody>
</table>
<h3 id="响应报文头">响应报文头</h3>
<table>
<thead>
<tr>
<th style="text-align:left">首部字段名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Accept-Ranges</td>
<td style="text-align:left">是否接受字节范围请求</td>
</tr>
<tr>
<td style="text-align:left">Age</td>
<td style="text-align:left">推算资源创建经过时间</td>
</tr>
<tr>
<td style="text-align:left">ETag</td>
<td style="text-align:left">资源的匹配信息</td>
</tr>
<tr>
<td style="text-align:left">Location</td>
<td style="text-align:left">令客户端重定向至指定 URI</td>
</tr>
<tr>
<td style="text-align:left">Proxy-Authenticate</td>
<td style="text-align:left">代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td style="text-align:left">Retry-After</td>
<td style="text-align:left">对再次发起请求的时机要求</td>
</tr>
<tr>
<td style="text-align:left">Server</td>
<td style="text-align:left">HTTP服务器的安装信息</td>
</tr>
<tr>
<td style="text-align:left">Vary</td>
<td style="text-align:left">代理服务器缓存的管理信息</td>
</tr>
<tr>
<td style="text-align:left">WWW-Authenticate</td>
<td style="text-align:left">服务器对客户端的认证信息</td>
</tr>
</tbody>
</table>
<h3 id="实体报文头">实体报文头</h3>
<table>
<thead>
<tr>
<th style="text-align:left">首部字段名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Allow</td>
<td style="text-align:left">资源可支持的 HTTP 方法</td>
</tr>
<tr>
<td style="text-align:left">Content-Encoding</td>
<td style="text-align:left">实体主体使用的编码方式</td>
</tr>
<tr>
<td style="text-align:left">Content-Language</td>
<td style="text-align:left">实体主体的自然语言</td>
</tr>
<tr>
<td style="text-align:left">Content-Length</td>
<td style="text-align:left">实体主体的大小（单位：字节）</td>
</tr>
<tr>
<td style="text-align:left">Content-Location</td>
<td style="text-align:left">替代对应资源的 URI</td>
</tr>
<tr>
<td style="text-align:left">Content-MD5</td>
<td style="text-align:left">实体主体的报文摘要</td>
</tr>
<tr>
<td style="text-align:left">Content-Range</td>
<td style="text-align:left">实体主体的位置范围</td>
</tr>
<tr>
<td style="text-align:left">Content-Type</td>
<td style="text-align:left">实体主体的媒体类型</td>
</tr>
<tr>
<td style="text-align:left">Expires</td>
<td style="text-align:left">实体主体过期的日期时间</td>
</tr>
<tr>
<td style="text-align:left">Last-Modified</td>
<td style="text-align:left">资源的最后修改日期时间</td>
</tr>
</tbody>
</table>
<h2 id="accept">ACCEPT</h2>
<ul>
<li>作用：<strong>浏览器端可以接受的媒体类型</strong></li>
</ul>
<p>Accept:<strong>text/html</strong> 代表浏览器可以接受服务器回发的类型为 text/html 也就是我们常说的 html 文档，如果服务器无法返回 text/html 类型的数据，服务器应该返回一个406错误（Non Acceptable）</p>
<p>如果想要给显示的媒体类型增加优先级，则使用q=来额外表示权重值）；重值 q 的范围是0~1（可精确到小数点后 3 位），且 1 为最大值。不指定权重 q 值时，默认权重为 q=1.0。当服务器提供多种内容时，将会首先返回权重值最高的媒体类型。</p>
<h2 id="accept-encoding">Accept-Encoding</h2>
<ul>
<li>作用：浏览器申明自己接收的<strong>编码方法</strong>，通常指定<strong>压缩</strong>方法，是否支持压缩，支持什么压缩方法（gzip，deflate）
<ul>
<li>Accept-Encoding:gzip，deflate</li>
</ul>
</li>
<li>作用：浏览器申明自己接收的语言
<ul>
<li>Accept-Language:zh-cn, zh; q=0.7, en-us, en; q=0.3</li>
<li>客户端在服务器有中文版资源的情况下，会请求其返回中文版对应的响应，没有中文版时，则请求返回英文版响应</li>
</ul>
</li>
<li><strong>Connection:keep-alive</strong> ：当一个网页打开完成后，客户端和服务器之间<strong>用于传输HTTP数据的TCP连接不会关闭</strong>，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。</li>
<li>Connection:close 代表<strong>一个Request</strong>完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭，当客户端再次发送Request，需要重新建立TCP连接</li>
</ul>
<h2 id="host">Host</h2>
<ul>
<li>作用：请求报头域主要用于指定被请求资源的 <strong>Internet主机和端口号</strong>，它通常从HTTP URL中提取出来的</li>
</ul>
<p>我们在浏览器中输入：http://www.fljf.com:8080 刘览器发送的请求消息中，就会包含Host请求报头域，如下：Host：www.fljf.com:8080</p>
<h2 id="referer">Referer</h2>
<p>当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理</p>
<h2 id="user-agent">User-Agent</h2>
<ul>
<li>作用：告诉HTTP服务器，客户端使用的操作系统和浏览器的名称和版本</li>
<li>很多情况下我们会通过User-Agnet来判断浏览器类型，从而进行不同的兼容设计</li>
</ul>
<h2 id="content-type">Content-Type</h2>
<ul>
<li>作用：说明了报文体内对象的媒体类型</li>
</ul>
<p>text/html：HTML格式</p>
<p>text/plain：纯文本格式</p>
<p>text/xml：XML格式</p>
<p>image/gif：gif图片格式</p>
<p>image/jpeg：jpg图片格式</p>
<p>image/png：png图片格式</p>
<p>application/xhtml+xml：XHTML格式</p>
<p>application/xml：XML数据格式</p>
<p>application/atom+xml：Atom XML聚合格式</p>
<p>application/json：JSON数据格式</p>
<p>application/pdf：pdf格式</p>
<p>application/msword：Word文档格式</p>
<p>application/octet-stream：二进制流数据（如常见的文件下载）</p>
<p>application/x-www-form-urlencoded：表单提交</p>
<h1 id="http-报文结构分析-响应报文">HTTP 报文结构分析 - 响应报文</h1>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.png" alt="图片" loading="lazy"></figure>
<h1 id="http-请求方法剖析">HTTP 请求方法剖析</h1>
<p>HTTP/1.1常用方法</p>
<p>①GET</p>
<p>② POST</p>
<p>③ PUT</p>
<p>④HEAD</p>
<p>⑤ DELETE</p>
<p>⑥OPTIONS</p>
<p>⑦TRACE</p>
<p>③ CONNECT</p>
<h2 id="get-获取资源">GET 获取资源</h2>
<ul>
<li>GET方法用来请求访问已被URI识别的资源</li>
<li>指定的资源经服务器端解析后返回响应内容</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/GET%E8%AF%B7%E6%B1%82.png" alt="图片" loading="lazy"></figure>
<ul>
<li>GET方法也可以用来提交表单和其他数据</li>
<li>http://localhost/login.php?username=aa&amp;password=1234 从上面的 URL 请求中，很容易就可以辩认出表单提交的内容</li>
</ul>
<h2 id="post">POST</h2>
<ul>
<li>POST 方法与 GET 功能类似，一般用来<strong>传输实体的主体</strong></li>
<li>POST 方法的主要目的不是获取响应主体的内容</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/POST%E8%AF%B7%E6%B1%82.png" alt="图片" loading="lazy"></figure>
<h3 id="说下-get-和-post-的区别">说下 GET 和 POST 的区别？</h3>
<p>GET 和 POST 本质都是 HTTP 请求，只不过对它们的作用做了界定和适配，并且让他们适应各自的场景。</p>
<ul>
<li>本质区别：GET 只是一次 HTTP请求，POST 先发请求头再发请求体，实际上是两次请求。</li>
<li>从功能上讲，GET 一般用来<strong>从服务器上获取资源</strong>，POST 一般用来<strong>更新服务器上的资源</strong>；</li>
<li>从 REST 服务角度上说，<strong>GET 是幂等</strong>的，即读取同一个资源，总是得到相同的数据，而 <strong>POST 不是幂等</strong>的，因为每次请求对资源的改变并不是相同的；进一步地，GET 不会改变服务器上的资源，而 POST 会对服务器资源进行改变；</li>
<li>从请求参数形式上看，<strong>GET 请求的数据会附在 URL 之后</strong>，即将请求数据放置在 HTTP 报文的 请求头 中，以 ? 分割 URL 和传输数据，参数之间以 &amp; 相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用 BASE64 加密，得出如：%E4%BD%A0%E5%A5%BD，其中 ％XX 中的 XX 为该符号以 16 进制表示的 ASCII)；而 **POST 请求会把提交的数据则放置在是 HTTP 请求报文的 **<strong>请求体</strong> 中；</li>
<li>就安全性而言，<strong>POST 的安全性要比 GET 的安全性高</strong>，因为 GET 请求提交的数据将明文出现在 URL 上，而且 POST 请求参数则被包装到请求体中，相对更安全；</li>
<li>从请求的大小看，GET 请求的长度受限于浏览器或服务器对 URL 长度的限制，允许发送的数据量比较小，而 POST 请求则是没有大小限制的。</li>
</ul>
<h2 id="put">PUT</h2>
<ul>
<li>从客户端向服务器传送的数据<strong>取代指定的文档的内容</strong></li>
<li>PUT方法与POST方法最大的不同是：PUT是幂等的，而POST是不幂等的</li>
<li>因此，我们更多时候将PUT方法用作传输资源</li>
</ul>
<blockquote>
<p>创建对象用 POST，更新对象用 PUT。<br>
但是，HTTP1.1 的 PUT 方法不带有验证机制，存在一定的安全问题，所以一般不使用 PUT，更新对象可以使用 POST 请求，然后在后端代码逻辑处理。</p>
</blockquote>
<h2 id="headdelete">HEAD/DELETE</h2>
<ul>
<li>HEAD类似于GET请求，只不过返回的响应中没有具体的内容，用于<strong>获取报头</strong>。</li>
<li>DELETE请求服务器删除指定的资源。</li>
</ul>
<blockquote>
<p>DELETE 方法没有验证机制，所以一般不使用。</p>
</blockquote>
<h2 id="options">OPTIONS</h2>
<p>用来查询针对请求URI指定的资源支持的方法</p>
<blockquote>
<p>不知道对方支持什么方法，询问一下。</p>
</blockquote>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/OPTIONS%E8%AF%B7%E6%B1%82.png" alt="图片" loading="lazy"></figure>
<h2 id="traceconnect">TRACE/CONNECT</h2>
<ul>
<li>TRACE：回显服务器收到的请求，主要用于测试或诊断</li>
</ul>
<blockquote>
<p>容易引发 XSP 攻击，所以一般不使用 TRACE 请求</p>
</blockquote>
<ul>
<li>CONNECT：开启一个客户端与所请求资源之间的双向沟通的通道，它可以用来创建隧道</li>
</ul>
<blockquote>
<p>代理服务器访问互联网时，就是用 CONNECT 方法。<br>
浏览器向代理服务器发送 CONNECT 请求，代理服务器返回状态码 200，浏览器就和服务器三次握手交换数据，代理服务器只负责传输彼此的数据包，并不能读取数据内容。</p>
</blockquote>
<h1 id="状态码">状态码</h1>
<p>是用以表示网页服务器超文本传输协议响应状态的3位数字代码。</p>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/%E7%8A%B6%E6%80%81%E7%A0%81.png" alt="图片" loading="lazy"></figure>
<h2 id="http-状态码详解">HTTP 状态码详解</h2>
<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1XX</td>
<td style="text-align:left">表示消息。这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。</td>
</tr>
<tr>
<td style="text-align:left">2XX</td>
<td style="text-align:left">表示<strong>成功</strong>。这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。</td>
</tr>
<tr>
<td style="text-align:left">3XX</td>
<td style="text-align:left">表示<strong>重定向</strong>。这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。</td>
</tr>
<tr>
<td style="text-align:left">4XX</td>
<td style="text-align:left">表示<strong>请求错误</strong>。这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。</td>
</tr>
<tr>
<td style="text-align:left">5XX</td>
<td style="text-align:left">表示<strong>服务器错误</strong>。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。</td>
</tr>
</tbody>
</table>
<h3 id="常用http状态码">常用HTTP状态码</h3>
<p>2XX 状态码：</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">状态码英文名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">200</td>
<td style="text-align:left">OK</td>
<td style="text-align:left">请求已成功，请求所希望的响应头或数据体将随此响应返回</td>
</tr>
<tr>
<td style="text-align:left">202</td>
<td style="text-align:left">Accepted</td>
<td style="text-align:left">已接受，已经接受请求，但未处理完成</td>
</tr>
<tr>
<td style="text-align:left">206</td>
<td style="text-align:left">Partial Content</td>
<td style="text-align:left">部分内容，服务器成功处理了部分GET请求</td>
</tr>
</tbody>
</table>
<p>3XX 状态码：</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">状态码英文名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">301</td>
<td style="text-align:left">Moved Permanently</td>
<td style="text-align:left"><strong>永久移动</strong>，请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替（<strong>更换域名</strong>）</td>
</tr>
<tr>
<td style="text-align:left">302</td>
<td style="text-align:left">Found</td>
<td style="text-align:left">临时移动，与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
</tbody>
</table>
<p>4XX 状态码：</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">状态码英文名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left">Bad Request</td>
<td style="text-align:left">客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td style="text-align:left">401</td>
<td style="text-align:left">Unauthorized</td>
<td style="text-align:left">请求要求用户的身份认证</td>
</tr>
<tr>
<td style="text-align:left">403</td>
<td style="text-align:left">Forbidden</td>
<td style="text-align:left">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td style="text-align:left">404</td>
<td style="text-align:left">Not Found</td>
<td style="text-align:left">服务器无法根据客户端的请求找到资源（网页）。</td>
</tr>
</tbody>
</table>
<p>5XX 状态码：</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">状态码英文名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left">Internal Server Error</td>
<td style="text-align:left">服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td style="text-align:left">502</td>
<td style="text-align:left">Bad Gateway</td>
<td style="text-align:left">充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</td>
</tr>
</tbody>
</table>
<h1 id="http状态管理cookie与session">HTTP状态管理：Cookie与Session</h1>
<p>HTTP 是无状态协议，每个请求都是独立的，如果后续处理需要前面的信息，必须重传，就会导致连接传送的数据量增大，于是引入 Cookie 和 Session 保存 HTTP 连接状态。</p>
<h2 id="cookie">Cookie</h2>
<ul>
<li>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就向客户端浏览器颁发一个Cookie。</li>
<li><strong>客户端浏览器</strong>会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态<br>
<img src="https://epitomm.github.io/post-images/cookie.png" alt="图片" loading="lazy"></li>
</ul>
<blockquote>
<p>在浏览器地址栏输入 www.baidu.com ，浏览器向百度服务器发送读取网页的请求，并且把结果显示回显示器上。<br>
发送之前，这个网页在本机电脑上寻找百度网站设置的 cookie 文件，如果找到，浏览器会把 cookie 文件中的数据连同 url 一同发送给百度服务器，服务器收到数据，就会在它的数据库中检索 id、搜索记录等信息，并且记录下这次新的内容，增加到数据库和 cookie 文件中。如果没有检测到 cookie，或者 cookie 信息与数据库信息不符合，说明这是第一次浏览这个网站，服务器就会创建一个新的 id，并且保存到数据库，并给浏览器下发一个 cookie，这样下一次访问就会像前面描述的那样查到 cookie 记录了。</p>
</blockquote>
<h2 id="cookie-工作原理">Cookie 工作原理</h2>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/cookie%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="图片" loading="lazy"></figure>
<p>1.浏览器发送请求到服务器</p>
<p>2.如果是第一次访问这个服务器，服务器 set-cookie</p>
<p>3.服务器通过 set-cookie 这样的一个响应头把 cookie 发送给客户端</p>
<p>4.客户端读取到 set-cookie 之后，把 cookie 存储到本地的文本文件中</p>
<p>5.再次发送请求，会把 cookie 一起发送到服务器端</p>
<p>6.服务器接收到这个 cookie，检查 cookie，证明没问题，确实是我已经存在的用户了，返回响应结果。</p>
<h2 id="session">Session</h2>
<ul>
<li>Session是另一种记录客户状态的机制，保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上</li>
<li>客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了</li>
</ul>
<p>##Session 工作原理<br>
<img src="https://epitomm.github.io/post-images/session%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="图片" loading="lazy"></p>
<blockquote>
<p>用户访问一个服务器，如果服务器启用 session，服务器就要为这个用户创建一个 session，在创建这个 session 的时候，服务器首先检查这个用户发来的请求里，是否包含一个 sessionID，如果包含了，就说明这个用户此前已经登陆过，并且已经创建过 session，就按照这个 sessionID 把 session 从服务器的内存中查找出来。如果查找不到或客户端请求就不包含这个 sessionID，就为这个客户端创建一个新的 session，并且生成一个与此 session 相关的 sessionID，这个 sessionID 在服务端是唯一的，这个 sessionID会在这一次响应中返回到客户端进行保存，保存这个 sessionID 的正是 cookie。</p>
</blockquote>
<h2 id="保存session-id的方式">保存Session ID的方式</h2>
<ul>
<li>Cookie</li>
<li>URL重写：
<ul>
<li>https://.../xxx?sessionID=BpRZx3lQx33ccEoU6QZcEb64（参数）</li>
<li>https://.../xxx;SessionID=BpRZx3lQx33ccEoU6QZcEb64（路径附加信息）</li>
</ul>
</li>
<li>隐藏表单</li>
</ul>
<h2 id="session的有效期">Session的有效期</h2>
<ul>
<li>Session超时失效
<ul>
<li>服务器空间有限，设置 session 有效时间，防止更多的用户访问造成服务器内存溢出</li>
</ul>
</li>
<li>程序调用HttpSession.invalidate()
<ul>
<li>点击退出，手动调用 session 失效方法</li>
</ul>
</li>
<li>服务器进程被停止</li>
<li>Cokie 与 Session理存放位置不同
<ul>
<li>Cookie 保存在客户端</li>
<li>Session 保存在服务端</li>
</ul>
</li>
<li>安全性（隐私策略）的不同
<ul>
<li>Cookie 存储在浏览器，对客户端可见，客户端的程序可修改 Cookie 中的内容</li>
<li>Session 存储在服务器端，对客户端来说是透明的，不存在敏感信息泄露的风险</li>
</ul>
</li>
<li>有效期的不同
<ul>
<li>设置 Cookie 的过期时间为很大的数字，Cookie 就可以在浏览器保存很长时间</li>
<li>服务器端会定时清理超时的 sessionID，避免出现过大的压力</li>
<li>session 依赖名为 sessionID 这样类似的 cookie，而 cookie 的 sessionID 过期时间默许是 -1，所以只要关闭了浏览器，也就是<strong>一次会话</strong>结束，这个 session 就失效了。</li>
</ul>
</li>
<li>对服务器压力的不同
<ul>
<li>session 保管在服务器端，每个用户都保存一个 session，耗费大量内存。</li>
<li>cookie 保存在客户端，不太占用服务器的资源。</li>
</ul>
</li>
</ul>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#http-%E7%89%B9%E7%82%B9">HTTP 特点</a>
<ul>
<li><a href="#%E6%94%AF%E6%8C%81-%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8-%E6%A8%A1%E5%BC%8F">支持 客户/服务器 模式</a></li>
<li><a href="#%E7%AE%80%E5%8D%95%E5%BF%AB%E9%80%9F">简单快速</a></li>
<li><a href="#%E7%81%B5%E6%B4%BB">灵活</a></li>
<li><a href="#%E6%97%A0%E8%BF%9E%E6%8E%A5">无连接</a></li>
<li><a href="#%E6%97%A0%E7%8A%B6%E6%80%81">无状态</a></li>
</ul>
</li>
<li><a href="#uri-%E4%B8%8E-url">URI 与 URL</a>
<ul>
<li><a href="#%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%E8%A7%A3%E9%87%8A">维基百科解释</a></li>
<li><a href="#%E5%AE%89%E8%83%BD%E8%BE%A8%E6%88%91%E6%98%AF%E9%9B%8C%E9%9B%84">安能辨我是雌雄</a></li>
</ul>
</li>
<li><a href="#http-%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87">HTTP 报文结构分析 - 请求报文</a>
<ul>
<li><a href="#http-%E6%8A%A5%E6%96%87%E5%A4%B4">HTTP 报文头</a>
<ul>
<li><a href="#%E9%80%9A%E7%94%A8%E6%8A%A5%E6%96%87%E5%A4%B4">通用报文头</a></li>
<li><a href="#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%A4%B4">请求报文头</a></li>
<li><a href="#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E5%A4%B4">响应报文头</a></li>
<li><a href="#%E5%AE%9E%E4%BD%93%E6%8A%A5%E6%96%87%E5%A4%B4">实体报文头</a></li>
</ul>
</li>
<li><a href="#accept">ACCEPT</a></li>
<li><a href="#accept-encoding">Accept-Encoding</a></li>
<li><a href="#host">Host</a></li>
<li><a href="#referer">Referer</a></li>
<li><a href="#user-agent">User-Agent</a></li>
<li><a href="#content-type">Content-Type</a></li>
</ul>
</li>
<li><a href="#http-%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87">HTTP 报文结构分析 - 响应报文</a></li>
<li><a href="#http-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E5%89%96%E6%9E%90">HTTP 请求方法剖析</a>
<ul>
<li><a href="#get-%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90">GET 获取资源</a></li>
<li><a href="#post">POST</a>
<ul>
<li><a href="#%E8%AF%B4%E4%B8%8B-get-%E5%92%8C-post-%E7%9A%84%E5%8C%BA%E5%88%AB">说下 GET 和 POST 的区别？</a></li>
</ul>
</li>
<li><a href="#put">PUT</a></li>
<li><a href="#headdelete">HEAD/DELETE</a></li>
<li><a href="#options">OPTIONS</a></li>
<li><a href="#traceconnect">TRACE/CONNECT</a></li>
</ul>
</li>
<li><a href="#%E7%8A%B6%E6%80%81%E7%A0%81">状态码</a>
<ul>
<li><a href="#http-%E7%8A%B6%E6%80%81%E7%A0%81%E8%AF%A6%E8%A7%A3">HTTP 状态码详解</a>
<ul>
<li><a href="#%E5%B8%B8%E7%94%A8http%E7%8A%B6%E6%80%81%E7%A0%81">常用HTTP状态码</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#http%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86cookie%E4%B8%8Esession">HTTP状态管理：Cookie与Session</a>
<ul>
<li><a href="#cookie">Cookie</a></li>
<li><a href="#cookie-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">Cookie 工作原理</a></li>
<li><a href="#session">Session</a></li>
<li><a href="#%E4%BF%9D%E5%AD%98session-id%E7%9A%84%E6%96%B9%E5%BC%8F">保存Session ID的方式</a></li>
<li><a href="#session%E7%9A%84%E6%9C%89%E6%95%88%E6%9C%9F">Session的有效期</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://epitomm.github.io/post/leetcode876-lian-biao-de-zhong-jian-jie-dian/">
              <h3 class="post-title">
                leetcode876. 链表的中间结点
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '974bd77fbbd52c2a0647',
    clientSecret: '6344370ca1314dbd553f45e75a2121a160ef1c44',
    repo: 'EpitomM.github.io',
    owner: 'EpitomM',
    admin: ['EpitomM'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/EpitomM/EpitomM.github.io" target="_blank">EpitomM</a>
  <a class="rss" href="https://epitomm.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
