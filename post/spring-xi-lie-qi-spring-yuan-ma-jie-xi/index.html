<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Spring系列（七）Spring源码解析 | SSM</title>
<link rel="shortcut icon" href="https://epitomm.github.io/favicon.ico?v=1589125597619">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://epitomm.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Spring系列（七）Spring源码解析 | SSM - Atom Feed" href="https://epitomm.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultLista..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://epitomm.github.io">
  <img class="avatar" src="https://epitomm.github.io/images/avatar.png?v=1589125597619" alt="">
  </a>
  <h1 class="site-title">
    SSM
  </h1>
  <p class="site-description">
    热心善良的老学姐
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Spring系列（七）Spring源码解析
            </h2>
            <div class="post-info">
              <span>
                2020-05-08
              </span>
              <span>
                40 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      // 初始化 Spring 的环境
      context.refresh();
      IndexDao indexDao = context.getBean(IndexDaoImpl.class);
      indexDao.query();
   }
}
</code></pre>
<h1 id="1new-annotationconfigapplicationcontext">1.new AnnotationConfigApplicationContext();</h1>
<p>第 6 行代码，new AnnotationConfigApplicationContext(); 时，由于 AnnotationConfigApplicationContext 有父类</p>
<pre><code class="language-java">public class AnnotationConfigApplicationContext extends GenericApplicationContext implements AnnotationConfigRegistry {
</code></pre>
<h2 id="11-genericapplicationcontext">1.1 GenericApplicationContext()</h2>
<p>所以会先调用父类 GenericApplicationContext  的构造方法（上一篇文章中提到过），今天就从它父类的构造方法说起：实例化了一个 Bean 工厂，</p>
<pre><code class="language-java">/**
 * Create a new GenericApplicationContext.
 * @see #registerBeanDefinition
 * @see #refresh
 */
public GenericApplicationContext() {
   // 实例化一个 Bean 工厂
   this.beanFactory = new DefaultListableBeanFactory();
}
</code></pre>
<h3 id="111-defaultlistablebeanfactory">1.1.1 DefaultListableBeanFactory</h3>
<p>这个 Bean 工厂内到底有些什么属性呢，这里列举出几个常用重要属性：</p>
<pre><code class="language-java">/** 从序列化ID映射到工厂实例 */
private static final Map&lt;String, Reference&lt;DefaultListableBeanFactory&gt;&gt; serializableFactories =
      new ConcurrentHashMap&lt;&gt;(8);
/** 该工厂的可选ID，用于序列化 */
// 可以理解为身份证号
@Nullable
private String serializationId;
// 工厂中能够处理类的实例化顺序
@Nullable
private Comparator&lt;Object&gt; dependencyComparator;
// map&lt;beanName,beanDefinition&gt;
private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);
/** List of bean definition names, in registration order */
private volatile List&lt;String&gt; beanDefinitionNames = new ArrayList&lt;&gt;(256);
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/bean%E5%B7%A5%E5%8E%82.png" alt="图片" loading="lazy"></figure>
<h2 id="12-annotationconfigapplicationcontext">1.2 AnnotationConfigApplicationContext()</h2>
<p>调用完父类构造方法后，调用本类构造方法，即</p>
<pre><code class="language-java">public AnnotationConfigApplicationContext() {
   /**
    * 父类的构造方法 super()
    *创建一个读取注解的 Bean 定义读取器：reader 能读取被加了注解的类
    * 什么是 bean 定义？BeanDefinition
    */
   this.reader = new AnnotatedBeanDefinitionReader(this);
   // 定义扫描器
   this.scanner = new ClassPathBeanDefinitionScanner(this);
}
</code></pre>
<h3 id="121-thisreader-new-annotatedbeandefinitionreaderthis">1.2.1 this.reader = new AnnotatedBeanDefinitionReader(this);</h3>
<p>我们来看上述代码第 7 行的参数为 this（AnnotatedBeanDefinitionReader），点进这个方法看到参数类型为 BeanDefinitionRegistry，也就是意味着 AnnotatedBeanDefinitionReader = BeanDefinitionRegistry</p>
<pre><code class="language-java">public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry) {
   this(registry, getOrCreateEnvironment(registry));
}
</code></pre>
<h4 id="1211-annotatedbeandefinitionreaderbeandefinitionregistry-registry-environment-environment">1.2.1.1 AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment)</h4>
<p>这里调用了一个重载的构造方法</p>
<pre><code class="language-java">public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) {
   Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;);
   Assert.notNull(environment, &quot;Environment must not be null&quot;);
   this.registry = registry;
   this.conditionEvaluator = new ConditionEvaluator(registry, environment, null);
   AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
}
</code></pre>
<p>看第 6 行点进去</p>
<pre><code class="language-java">public static void registerAnnotationConfigProcessors(BeanDefinitionRegistry registry) {
   registerAnnotationConfigProcessors(registry, null);
}
</code></pre>
<p>在点进去第 2 行这个方法：</p>
<pre><code class="language-java">public static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors(
      BeanDefinitionRegistry registry, @Nullable Object source) {
   // 通过 registry 得到 Bean 工厂
   DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);
   if (beanFactory != null) {
      // AnnotationAwareOrderComparator 主要能解析 @Order 注解和 @Priority
      if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {
         // ContextAnnotationAutowireCandidateResolver 提供处理器延迟加载的功能
         beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);
      }
      if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) {
         beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());
      }
   }
   Set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;&gt;(8);
   // BeanDefinition的注册，这里很重要，需要理解注册每个 bean 的类型
   if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {
      // 需要注意的是 ConfigurationClassPostProcessor 的类型是 BeanDefinitionRegistryPostProcessor
      // 而 BeanDefinitionRegistryPostProcessor 最终实现 BeanFactoryPostProcess
      RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);
      def.setSource(source);
      beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
   }
   if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {
      RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);
      def.setSource(source);
      beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
   }
   if (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {
      RootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);
      def.setSource(source);
      beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
   }
   // Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.
   if (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {
      RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);
      def.setSource(source);
      beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));
   }
   // Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.
   if (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {
      RootBeanDefinition def = new RootBeanDefinition();
      try {
         def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,
               AnnotationConfigUtils.class.getClassLoader()));
      }
      catch (ClassNotFoundException ex) {
         throw new IllegalStateException(
               &quot;Cannot load optional framework class: &quot; + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);
      }
      def.setSource(source);
      beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));
   }
   
   if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {
      RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);
      def.setSource(source);
      beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));
   }
   if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {
      RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);
      def.setSource(source);
      beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));
   }
   return beanDefs;
}
</code></pre>
<p>上述代码第 24 行</p>
<pre><code class="language-java">beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
</code></pre>
<pre><code class="language-java">private static BeanDefinitionHolder registerPostProcessor(
      BeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName) {
   definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
   registry.registerBeanDefinition(beanName, definition);
   return new BeanDefinitionHolder(definition, beanName);
}
</code></pre>
<p>上述第 6 行代码：通过 registry 的 registerBeanDefinition 方法将 &lt;beanName,definition&gt; 放到 map 中：</p>
<h3 id="122-thisscanner-new-classpathbeandefinitionscannerthis">1.2.2 this.scanner = new ClassPathBeanDefinitionScanner(this);</h3>
<p>继续看本类构造方法的第 9 行，能够扫描一个类，并且转换成 BeanDefinition</p>
<pre><code class="language-java">public AnnotationConfigApplicationContext() {
   /**
    * 父类的构造方法 super()
    *创建一个读取注解的 Bean 定义读取器：reader 能读取被加了注解的类
    * 什么是 bean 定义？BeanDefinition
    */
   this.reader = new AnnotatedBeanDefinitionReader(this);
   // 定义扫描器
   this.scanner = new ClassPathBeanDefinitionScanner(this);
}
</code></pre>
<h1 id="2contextregisterappconfigclass">2.context.register(AppConfig.class);</h1>
<p>接下来看 Test 测试类的第 10 行：</p>
<pre><code class="language-java">context.register(AppConfig.class);
</code></pre>
<p>点进 register 方法如下：</p>
<pre><code class="language-java">public void register(Class&lt;?&gt;... annotatedClasses) {
   Assert.notEmpty(annotatedClasses, &quot;At least one annotated class must be specified&quot;);
   this.reader.register(annotatedClasses);
}
</code></pre>
<p>第 3 行：调用 reader 的 register() 方法，将  AppConfig.class 这个普通的类交给 reader，由 reader 将它转化成 BeanDefinition。那么这个具体的 register 方法是如何实现的呢？点进去这个 register() 方法</p>
<h2 id="21-doregisterbean">2.1 doRegisterBean</h2>
<p>(中间省略两步代码)最终会到 doRegisterBean 方法：</p>
<pre><code class="language-java">&lt;T&gt; void doRegisterBean(Class&lt;T&gt; annotatedClass, @Nullable Supplier&lt;T&gt; instanceSupplier, @Nullable String name,
      @Nullable Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers) {
   /**
    *
    * AnnotatedGenericBeanDefinition：被注解的 BeanDefinition(描述Bean)
    * 将 bean 放入 map 中，bean 的 name 是 map 的 key，
    * map 中的 value 为 AnnotatedGenericBeanDefinition 对象
    */
   AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass);
   /**
    * 判断这个类是否需要跳过解析
    * 通过代码可以知道 Spring 判断是否跳过解析，主要判断有没有加注解
    */
   // 这个类如果没有加注解，就不需要解析。因为 AnnotatedGenericBeanDefinition 是为了注册被加了注解的；
   // 如果这个类没有被加注解，就跳过不解析
   if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) {
      return;
   }
   abd.setInstanceSupplier(instanceSupplier);
   /**
    * 得到类的作用域
    *     如果是 context.register(SpringConfig.class);则作用域没有什么作用
    *     注册单个类时需要，比如：context.register(IndexService.class);
    */
   ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);
   /**
    * 将类的作用域添加到数据结构中
    */
   abd.setScope(scopeMetadata.getScopeName());
   /**
    * 生成类的名字通过 beanNameGenerator
    */
   String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));
   /**
    * 处理类当中的其他通用注解
    * 分析源码可以知道它主要处理：Lazy、DependsOn、Primary、Role 等注解
    * 处理完成之后 processCommonDefinitionAnnotation 中依然是把它添加到数据结构 AnnotatedGenericBeanDefinition 当中
    */
   AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
   /**
    * 如果在向容器注册注解 @Bean定义时，使用了额外的限定符注解则解析
    * 关于 Qualifier 和 Primary 主要涉及到 Spring 的自动装配
    * 这里需要注意的
    *     beanName 和 qualifier 这个变量时 Annotation 类型的数组，里面不仅仅是 Qualifier 注解
    *     理论上里面存的是一切注解，所以可以看到下面的代码 Spring 去循环了这个数组
    *     然后依次判断注解当中是否包含了 Primary，是否包含了 Lazy
    */
   if (qualifiers != null) {
      for (Class&lt;? extends Annotation&gt; qualifier : qualifiers) {
         if (Primary.class == qualifier) {
            abd.setPrimary(true);
         }
         else if (Lazy.class == qualifier) {
            abd.setLazyInit(true);
         }
         else {
            abd.addQualifier(new AutowireCandidateQualifier(qualifier));
         }
      }
   }
   for (BeanDefinitionCustomizer customizer : definitionCustomizers) {
      customizer.customize(abd);
   }
   /**
    * 这个 BeanDefinitionHolder 也是一个数据结构
    * BeanDefinitionHolder 是一个 map，里面放了一个 (BeanDefinition，beanName)
    */
   BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);
   definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
   /**
    * 把上述的这个数据结构注册给 registry
    * registry 就是 AnnotationConfigApplicationContext
    * AnnotationConfigApplicationContext 在初始化的时候通过调用父类的构造方法实例化了一个 DefaultListableBeanFactory
    * registerBeanDefinition 里面就是把 definitionHolder 这个数据结构包含的信息注册到 DefaultListableBeanFactory 这个工厂
    */
   BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
}
</code></pre>
<p>为什么 deoRegisterBean 方法中要解析作用域、其他通用注解等信息？<br>
因为如果 context.register(IndexServiceImpl.class); 参数是 Bean 时，则需要获取 Bean 具体信息然后封装成 BeanDefinition，注册进 map 中。</p>
<h3 id="211-new-annotatedgenericbeandefinitionannotatedclass">2.1.1 new AnnotatedGenericBeanDefinition(annotatedClass);</h3>
<p>上述第 10 行代码，使用 new AnnotatedGenericBeanDefinition(annotatedClass); 的方式将一个普通的 annotatedClass(AppConfig.class) 转化成 AnnotatedGenericBeanDefinition。</p>
<h3 id="212-registerbeandefinitiondefinitionholder-thisregistry">2.1.2 registerBeanDefinition(definitionHolder, this.registry);</h3>
<p>上述代码第 80 行：</p>
<pre><code class="language-java">BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
</code></pre>
<p>点进 registerBeanDefinition 方法：</p>
<pre><code class="language-java">public static void registerBeanDefinition(
      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
      throws BeanDefinitionStoreException {
   // Register bean definition under primary name.
   String beanName = definitionHolder.getBeanName();
   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
   // Register aliases for bean name, if any.
   String[] aliases = definitionHolder.getAliases();
   if (aliases != null) {
      for (String alias : aliases) {
         registry.registerAlias(beanName, alias);
      }
   }
}
</code></pre>
<p>上述代码第 7 行，使用 registry 的 registerBeanDefinition 方法将 &lt;beanName,BeanDefinition&gt;注册到 map 中。<br>
<img src="https://epitomm.github.io/post-images/registerBeanDefinition.png" alt="图片" loading="lazy"></p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/bean%E5%B7%A5%E5%8E%82_2.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/register_2.png" alt="图片" loading="lazy"></figure>
<h1 id="3contextrefresh">3.context.refresh()</h1>
<pre><code class="language-java">@Override
public void refresh() throws BeansException, IllegalStateException {
   synchronized (this.startupShutdownMonitor) {
      // Prepare this context for refreshing.
      // 准备工作包括设置启动时间、是否激活标识位，初始化属性源（property source）配置
      prepareRefresh();
      // 告诉子类 refresh Bean 工厂
      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
      // 用这个上下文准备 Bean 工厂
      prepareBeanFactory(beanFactory);
      try {
         // Allows post-processing of the bean factory in context subclasses.
         postProcessBeanFactory(beanFactory);
         // Invoke factory processors registered as beans in the context.
         invokeBeanFactoryPostProcessors(beanFactory);
         // Register bean processors that intercept bean creation.
         registerBeanPostProcessors(beanFactory);
         // Initialize message source for this context.
         initMessageSource();
         // Initialize event multicaster for this context.
         initApplicationEventMulticaster();
         // Initialize other special beans in specific context subclasses.
         onRefresh();
         // Check for listener beans and register them.
         registerListeners();
         // Instantiate all remaining (non-lazy-init) singletons.
         finishBeanFactoryInitialization(beanFactory);
         // Last step: publish corresponding event.
         finishRefresh();
      }
      catch (BeansException ex) {
         if (logger.isWarnEnabled()) {
            logger.warn(&quot;Exception encountered during context initialization - &quot; +
                  &quot;cancelling refresh attempt: &quot; + ex);
         }
         // Destroy already created singletons to avoid dangling resources.
         destroyBeans();
         // Reset 'active' flag.
         cancelRefresh(ex);
         // Propagate exception to caller.
         throw ex;
      }
      finally {
         // Reset common introspection caches in Spring's core, since we
         // might not ever need metadata for singleton beans anymore...
         resetCommonCaches();
      }
   }
}
</code></pre>
<h2 id="31-preparerefresh">3.1 prepareRefresh();</h2>
<p>上述第6 行代码：<strong>准备工作包括设置启动时间、是否激活标识位，初始化属性源（property source）配置</strong></p>
<h2 id="32-obtainfreshbeanfactory">3.2 obtainFreshBeanFactory();</h2>
<p>上述第 9 行代码：得到 BeanFactory，因为需要对 BeanFactory 进行设置</p>
<pre><code class="language-java">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
</code></pre>
<h2 id="33-preparebeanfactorybeanfactory">3.3 prepareBeanFactory(beanFactory);</h2>
<p>上述第 12 行代码：准备 Bean 工厂</p>
<pre><code class="language-java">prepareBeanFactory(beanFactory);
</code></pre>
<p>点进这个 prepareBeanFactory 方法：</p>
<pre><code class="language-java">protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
   // Tell the internal bean factory to use the context's class loader etc.
   beanFactory.setBeanClassLoader(getClassLoader());
   // bean 表达式解析器
   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
   // 注册属性编辑器
   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));
   // Configure the bean factory with context callbacks.
   // 添加一个后置管理器：ApplicationContextAwareProcessor 实现了 BeanPostProcessor接口：插手 Bean 的创建过程
   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);
   // BeanFactory interface not registered as resolvable type in a plain factory.
   // MessageSource registered (and found for autowiring) as a bean.
   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
   beanFactory.registerResolvableDependency(ResourceLoader.class, this);
   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
   beanFactory.registerResolvableDependency(ApplicationContext.class, this);
   // Register early post-processor for detecting inner beans as ApplicationListeners.
   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));
   // Detect a LoadTimeWeaver and prepare for weaving, if found.
   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
      // Set a temporary ClassLoader for type matching.
      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
   }
   // Register default environment beans.
   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
   }
   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
   }
   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
   }
}
</code></pre>
<p>上述代码第 3 行，添加一个类加载器：</p>
<pre><code class="language-java">beanFactory.setBeanClassLoader(getClassLoader());
</code></pre>
<p>上述代码第 5 行，添加 bean 表达式解析器，为了能够让 BeanFactory 去解析 bean 表达式</p>
<pre><code class="language-java">//bean 表达式解析器
beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
// 注册属性编辑器
</code></pre>
<p>上述 12-17 行，添加了自动注入被忽略的列表：</p>
<pre><code class="language-java">  beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);   
</code></pre>
<p>上述代码第 27 行，添加了一个 ApplicationListenerDetector 后置处理器</p>
<pre><code class="language-java">beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));
</code></pre>
<h3 id="331-beanfactoryaddbeanpostprocessornew-applicationcontextawareprocessorthis">3.3.1 beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</h3>
<p>上述代码第 11 行，</p>
<pre><code class="language-java">// 添加一个后置管理器：ApplicationContextAwareProcessor 实现了 BeanPostProcessor接口：插手 Bean 的创建过程
beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
</code></pre>
<p>点进去 (new ApplicationContextAwareProcessor(this)：</p>
<pre><code class="language-java">public ApplicationContextAwareProcessor(ConfigurableApplicationContext applicationContext) {
   this.applicationContext = applicationContext;
   this.embeddedValueResolver = new EmbeddedValueResolver(applicationContext.getBeanFactory());
}
</code></pre>
<p>在点进去看 beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</p>
<pre><code class="language-java">@Override
public void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) {
   Assert.notNull(beanPostProcessor, &quot;BeanPostProcessor must not be null&quot;);
   // Remove from old position, if any
   this.beanPostProcessors.remove(beanPostProcessor);
   // Track whether it is instantiation/destruction aware
   if (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) {
      this.hasInstantiationAwareBeanPostProcessors = true;
   }
   if (beanPostProcessor instanceof DestructionAwareBeanPostProcessor) {
      this.hasDestructionAwareBeanPostProcessors = true;
   }
   // Add to end of list
   this.beanPostProcessors.add(beanPostProcessor);
}
</code></pre>
<p>上述 14 行 提到的 beanPostProcessors，是一个 List<BeanPostProcessor></p>
<pre><code class="language-java">/** BeanPostProcessors to apply in createBean */
private final List&lt;BeanPostProcessor&gt; beanPostProcessors = new CopyOnWriteArrayList&lt;&gt;();
</code></pre>
<h2 id="34-postprocessbeanfactorybeanfactory">3.4 postProcessBeanFactory(beanFactory);</h2>
<p>看 refresh() 看 的第 16 行代码：</p>
<pre><code class="language-java">// 这个方法在当前版本的 spring 是没有任何代码的
// 可能 Spring 期待在后面的版本中去扩展吧
postProcessBeanFactory(beanFactory);
</code></pre>
<h2 id="35-invokebeanfactorypostprocessorsbeanfactory">3.5 invokeBeanFactoryPostProcessors(beanFactory);</h2>
<p>看 refresh() 看 的第 19 行代码：</p>
<pre><code class="language-java">invokeBeanFactoryPostProcessors(beanFactory);
</code></pre>
<p>点进去这个代码：</p>
<pre><code class="language-java">protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
   // 这个地方需要注意 getBeanFactoryPostProcessors() 是获取自定义的
   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
   // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
   // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
   if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
   }
}
</code></pre>
<h3 id="351-getbeanfactorypostprocessors">3.5.1 getBeanFactoryPostProcessors()</h3>
<p>看上述第 3 行代码中的 getBeanFactoryPostProcessors()：是获取自定义的（程序员自己写的，并且没有交给 Spring 管理的，就是没有加上 @Component 注解的）</p>
<p>此时的代码 getBeanFactoryPostProcessors() 运行的结果 size=0。</p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/getBeanFactoryPostProcessors.png" alt="图片" loading="lazy"></figure>
<p>接下来我们看看什么叫做自定义的？</p>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      // 初始化 Spring 的环境
      context.refresh();
      IndexDao indexDao = context.getBean(IndexDaoImpl.class);
      indexDao.query();
      System.out.println(indexDao);
      System.out.println(context.getBean(IndexDaoImpl.class));
   }
}
</code></pre>
<p>因为 bean 默认是单例的，所以两次 context.getBean()获取的是同一个对象</p>
<pre><code class="language-java">dao...模拟查询数据库
com.ssm.dao.impl.IndexDaoImpl@47fd17e3
com.ssm.dao.impl.IndexDaoImpl@47fd17e3
</code></pre>
<p>插手 Bean 的初始化过程，将作用域设置为原型的：</p>
<p>但由于代码未添加 @Component 注解，所以这个类不会生效</p>
<pre><code class="language-java">public class MyBeanFactoryProcessor implements BeanFactoryPostProcessor {
   @Override
   public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
      AnnotatedBeanDefinition annotatedBeanDefinition = (AnnotatedBeanDefinition) beanFactory.getBeanDefinition(&quot;indexDao&quot;);
      annotatedBeanDefinition.setScope(&quot;prototype&quot;);
   }
}
</code></pre>
<p>打印效果：</p>
<pre><code class="language-java">dao...模拟查询数据库
com.ssm.dao.impl.IndexDaoImpl@47fd17e3
com.ssm.dao.impl.IndexDaoImpl@47fd17e3
</code></pre>
<p>在 refresh() 前 context.addBeanFactoryPostProcessor( new MyBeanFactoryProcessor());</p>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      context.addBeanFactoryPostProcessor( new MyBeanFactoryProcessor());
      // 初始化 Spring 的环境
      context.refresh();
      IndexDao indexDao = context.getBean(IndexDaoImpl.class);
      indexDao.query();
      System.out.println(indexDao);
      System.out.println(context.getBean(IndexDaoImpl.class));
   }
}
</code></pre>
<p>即使 MyBeanFactoryProcessor 类并没有添加注解，但是通过 addBeanFactoryPostProcessor 结果显示 IndexDao 对象为原型的了：</p>
<pre><code class="language-java">dao...模拟查询数据库
com.ssm.dao.impl.IndexDaoImpl@47fd17e3
com.ssm.dao.impl.IndexDaoImpl@7cdbc5d3
</code></pre>
<p>结论：<strong>context.addBeanFactoryPostProcessor( new MyBeanFactoryProcessor()); 就称之为自定义的</strong>。<br>
此时 getBeanFactoryPostProcessors() 执行后的结果 size 不为 0 了。</p>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/getBeanFactoryPostProcessors_2.png" alt="图片" loading="lazy"></figure>
<h3 id="352-invokebeanfactorypostprocessorsbeanfactory-getbeanfactorypostprocessors">3.5.2 invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</h3>
<pre><code class="language-java">public static void invokeBeanFactoryPostProcessors(
      ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) {
   // Invoke BeanDefinitionRegistryPostProcessors first, if any.
   Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;();
   if (beanFactory instanceof BeanDefinitionRegistry) {
      BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
      // 定义 List&lt;BeanFactoryPostProcessor&gt;
      List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;();
       // 定义 List&lt;BeanDefinitionRegistryPostProcessor&gt;
      List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;();
      // 遍历 beanFactoryPostProcessors
      for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
         // 判断如果 postProcessor 是 BeanDefinitionRegistryPostProcessor 类型，就添加到 registryProcessors 中
         if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
            BeanDefinitionRegistryPostProcessor registryProcessor =
                  (BeanDefinitionRegistryPostProcessor) postProcessor;
            registryProcessor.postProcessBeanDefinitionRegistry(registry);
            registryProcessors.add(registryProcessor);
         }
         // 否则，添加到 regularPostProcessors中
         else {
            regularPostProcessors.add(postProcessor);
         }
      }
      // Do not initialize FactoryBeans here: We need to leave all regular beans
      // uninitialized to let the bean factory post-processors apply to them!
      // Separate between BeanDefinitionRegistryPostProcessors that implement
      // PriorityOrdered, Ordered, and the rest.
      // 这个 currentRegistryProcessors 放的是 Spring 内部自己实现了 BeanDefinitionRegistryPostProcessor 接口的对象
      List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;();
      // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
      String[] postProcessorNames =
            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
            // 这个地方可以得到一个 BeanFactoryPostProcessor，因为是 Spring 默认在最开始自己注册的
            // 为什么要在最开始注册这个呢？
            // 因为 Spring 的工厂需要注解去扫描等等功能
            // 而这些功能都是需要在 Spring 工厂初始化完成之前就执行
            // 要么在工厂最开始的时候，要么在工厂初始化之中，反正不能在之后
            // 因为如果在之后就没有意义，因为那个时候已经需要使用工厂了
            // 所以这里 Spring 在一开始就注册了一个 BeanFactoryPostProcessor，用来插手 springFactory 的实例化过程
            // 在这个地方断点可以知道这个类叫做 ConfigurationClassPostProcessor
            // ConfigurationClassPostProcessor 那么这个类能干嘛呢？可以参考源码
            // 下面对这个“插手 Spirng 工厂实例化过程”的类重点解释
      for (String ppName : postProcessorNames) {
         if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
         }
      }
      // 排序不重要，况且 currentRegistryProcessor 这里也只有一个数据
      sortPostProcessors(currentRegistryProcessors, beanFactory);
      // 合并 List，不重要（为什么要合并，因为有自定义的Spring自己的）
      registryProcessors.addAll(currentRegistryProcessors);
      // 最重要。注意这里是方法调用
      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
      currentRegistryProcessors.clear();
      // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
      for (String ppName : postProcessorNames) {
         if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
         }
      }
      sortPostProcessors(currentRegistryProcessors, beanFactory);
      registryProcessors.addAll(currentRegistryProcessors);
      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
      currentRegistryProcessors.clear();
      // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
      boolean reiterate = true;
      while (reiterate) {
         reiterate = false;
         postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
         for (String ppName : postProcessorNames) {
            if (!processedBeans.contains(ppName)) {
               currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
               processedBeans.add(ppName);
               reiterate = true;
            }
         }
         sortPostProcessors(currentRegistryProcessors, beanFactory);
         registryProcessors.addAll(currentRegistryProcessors);
         invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
         currentRegistryProcessors.clear();
      }
      // Now, invoke the postProcessBeanFactory callback of all processors handled so far.
      invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
      invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
   }
   else {
      // Invoke factory processors registered with the context instance.
      invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
   }
   // Do not initialize FactoryBeans here: We need to leave all regular beans
   // uninitialized to let the bean factory post-processors apply to them!
   String[] postProcessorNames =
         beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);
   // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
   // Ordered, and the rest.
   List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();
   List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();
   List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();
   for (String ppName : postProcessorNames) {
      if (processedBeans.contains(ppName)) {
         // skip - already processed in first phase above
      }
      else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
         priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
      }
      else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
         orderedPostProcessorNames.add(ppName);
      }
      else {
         nonOrderedPostProcessorNames.add(ppName);
      }
   }
   // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
   invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);
   // Next, invoke the BeanFactoryPostProcessors that implement Ordered.
   List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();
   for (String postProcessorName : orderedPostProcessorNames) {
      orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
   }
   sortPostProcessors(orderedPostProcessors, beanFactory);
   invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);
   // Finally, invoke all other BeanFactoryPostProcessors.
   List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();
   for (String postProcessorName : nonOrderedPostProcessorNames) {
      nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
   }
   invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);
   // Clear cached merged bean definitions since the post-processors might have
   // modified the original metadata, e.g. replacing placeholders in values...
   beanFactory.clearMetadataCache();
}
</code></pre>
<h4 id="3521-listbeanfactorypostprocessor-listbeandefinitionregistrypostprocessor">3.5.2.1  List<BeanFactoryPostProcessor>、List<BeanDefinitionRegistryPostProcessor></h4>
<p>看一下上述 10-12 行：</p>
<pre><code class="language-java">// 定义 List&lt;BeanFactoryPostProcessor&gt;
List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;();
// 定义 List&lt;BeanDefinitionRegistryPostProcessor&gt;
List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;();
</code></pre>
<p>为什么定义两个 List？<br>
自己定义的 BeanFactoryProcessor可以有两种方式：</p>
<p>1.实现 BeanFactoryPostProcessor 接口</p>
<p>2.实现BeanDefinitionRegistryPostProcessor接口</p>
<p>因为 BeanDefinitionRegistryPostProcessor 实现了 BeanFactoryPostProcessor 接口</p>
<p>于是可以猜想实现 bdrp 和实现 bfp 是能够完成不同的功能，</p>
<p>因为 bdrp 是子类，子类肯定扩展了父类中的功能。</p>
<p>父类 BeanFactoryPostProcessor  中有一个 postProcessBeanFactory 方法：</p>
<pre><code class="language-java">@FunctionalInterface
public interface BeanFactoryPostProcessor {
   void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;
}
</code></pre>
<p>子类 BeanDefinitionRegistryPostProcessor  扩展了一个 postProcessBeanDefinitionRegistry() 方法：</p>
<pre><code class="language-java">public interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor {
   void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException;
}
</code></pre>
<h4 id="3522-getbeannamesfortype">3.5.2.2 getBeanNamesForType</h4>
<p>上述 invokeBeanFactoryPostProcessors 方法的第 37-54 行：</p>
<pre><code class="language-java">String[] postProcessorNames =
      beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
for (String ppName : postProcessorNames) {
   if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
      currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
      processedBeans.add(ppName);
   }
}
</code></pre>
<p>getBeanNamesForType：这个方法是 beanFactory 中的方法，顾名思义，这个方法能够得到通过类得到 bean名字，这里的 Type 指的是 bd 当中描述当前类的 Class 类型。<br>
beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false)：获取 Type 为 BeanDefinitionRegistryPostProcessor 对应的 bean 名字。</p>
<p>我们先来查看当前工厂的 map 中有哪些&lt;beanName, beanDefinition&gt;，之前说过在执行 register() 时向容器内添加了 7 个对象，我们看到有一个 BeanClass 为 ConfigurationClassPostProcessor 的类</p>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/ConfigurationClassPostProcessor.png" alt="图片" loading="lazy"></figure>
<p>我们发现 ConfigurationClassPostProcessor 类实现了 BeanDefinitionRegistryPostProcessor 接口：</p>
<pre><code class="language-java">public class ConfigurationClassPostProcessor implements BeanDefinitionRegistryPostProcessor,
      PriorityOrdered, ResourceLoaderAware, BeanClassLoaderAware, EnvironmentAware {
</code></pre>
<p>所以 beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); 就把 ConfigurationClassPostProcessor  类（Spring 内部自己定义的）拿出来了。</p>
<h4 id="3523-invokebeandefinitionregistrypostprocessors">3.5.2.3 invokeBeanDefinitionRegistryPostProcessors</h4>
<p>上述 invokeBeanFactoryPostProcessors 方法的第 60 行：</p>
<pre><code class="language-java">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
</code></pre>
<p>我们点进这个 invokeBeanDefinitionRegistryPostProcessors 方法：</p>
<pre><code class="language-java">private static void invokeBeanDefinitionRegistryPostProcessors(
      Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry) {
   // 循环所有的 BeanDefinitionRegistryPostProcessor
   for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
      postProcessor.postProcessBeanDefinitionRegistry(registry);
   }
}
</code></pre>
<p>上述代码第 5 行点进去：调用 BeanDefinitionRegistryPostProcessor<br>
扩展父类的方法 postProcessBeanDefinitionRegistry()：</p>
<pre><code class="language-java">@Override
public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
   int registryId = System.identityHashCode(registry);
   if (this.registriesPostProcessed.contains(registryId)) {
      throw new IllegalStateException(
            &quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot; + registry);
   }
   if (this.factoriesPostProcessed.contains(registryId)) {
      throw new IllegalStateException(
            &quot;postProcessBeanFactory already called on this post-processor against &quot; + registry);
   }
   this.registriesPostProcessed.add(registryId);
   processConfigBeanDefinitions(registry);
}
</code></pre>
<p>上述代码第 14 行点进去：</p>
<pre><code class="language-java">public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
   // app 提供的 bean
   List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;();
   // 获取容器中注册的所有 bean 名字
   String[] candidateNames = registry.getBeanDefinitionNames();
   // 依次取出每个&lt;beanName,beanDefinition&gt;
   for (String beanName : candidateNames) {
      BeanDefinition beanDef = registry.getBeanDefinition(beanName);
      // 判断当前 bean 是否被处理过：使用 isFullConfigurationClass 来标识
      if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
            ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {
         // 如果 BeanDefinition 中的 configurationClass 属性为 full 或者 lite，则意味着已经处理过了，直接跳过
         // 这里需要结合下面的代码才能理解
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Bean definition has already been processed as a configuration class: &quot; + beanDef);
         }
      }
      // 判断这个 BeanDefinition 是否包含了 @Configuration、@Service 注解
      else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
         configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
      }
   }
   // Return immediately if no @Configuration classes were found
   if (configCandidates.isEmpty()) {
      return;
   }
    
   // 排序，根据 order，不重要
   // Sort by previously determined @Order value, if applicable
   configCandidates.sort((bd1, bd2) -&gt; {
      int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
      int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
      return Integer.compare(i1, i2);
   });
   // Detect any custom bean name generation strategy supplied through the enclosing application context
   SingletonBeanRegistry sbr = null;
   // 如果 BeanDefinitionRegistry 是 SingletonBeanRegistry 子类的话
   // 由于会将 registry 强转为 SingletonBeanRegistry
   if (registry instanceof SingletonBeanRegistry) {
      sbr = (SingletonBeanRegistry) registry;
      if (!this.localBeanNameGeneratorSet) {
         BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);
         // SingletonBeanRegistry 中有 id 为 org.springframework.context.annotation.internalConfigurationBeanNameGenerator
         // 如果有则利用它的，否则则使用 Spring 默认的
         if (generator != null) {
            this.componentScanBeanNameGenerator = generator;
            this.importBeanNameGenerator = generator;
         }
      }
   }
   if (this.environment == null) {
      this.environment = new StandardEnvironment();
   }
   // Parse each @Configuration class
   // 实例化 ConfigurationClassParser 为了解析各个配置类
   ConfigurationClassParser parser = new ConfigurationClassParser(
         this.metadataReaderFactory, this.problemReporter, this.environment,
         this.resourceLoader, this.componentScanBeanNameGenerator, registry);
         
   // 实例化 2 个 set，candidates 用于将之前加入的 configCandidates 进行去重
   // 因为可能有多个配置类重复了
   // alreadyParsed 用户判断是否处理过
   Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates);
   Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size());
   do {
      parser.parse(candidates);
      parser.validate();
      Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());
      configClasses.removeAll(alreadyParsed);
      // Read the model and create bean definitions based on its content
      if (this.reader == null) {
         this.reader = new ConfigurationClassBeanDefinitionReader(
               registry, this.sourceExtractor, this.resourceLoader, this.environment,
               this.importBeanNameGenerator, parser.getImportRegistry());
      }
      // 把扫描出来的 bean 对应的 beanDefinitions 添加到 factory 的 map 当中
      this.reader.loadBeanDefinitions(configClasses);
      alreadyParsed.addAll(configClasses);
      candidates.clear();
      if (registry.getBeanDefinitionCount() &gt; candidateNames.length) {
         String[] newCandidateNames = registry.getBeanDefinitionNames();
         Set&lt;String&gt; oldCandidateNames = new HashSet&lt;&gt;(Arrays.asList(candidateNames));
         Set&lt;String&gt; alreadyParsedClasses = new HashSet&lt;&gt;();
         for (ConfigurationClass configurationClass : alreadyParsed) {
            alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
         }
         for (String candidateName : newCandidateNames) {
            if (!oldCandidateNames.contains(candidateName)) {
               BeanDefinition bd = registry.getBeanDefinition(candidateName);
               if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp;
                     !alreadyParsedClasses.contains(bd.getBeanClassName())) {
                  candidates.add(new BeanDefinitionHolder(bd, candidateName));
               }
            }
         }
         candidateNames = newCandidateNames;
      }
   }
   while (!candidates.isEmpty());
   // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes
   if (sbr != null &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {
      sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
   }
   if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {
      // Clear cache in externally provided MetadataReaderFactory; this is a no-op
      // for a shared cache since it'll be cleared by the ApplicationContext.
      ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();
   }
}
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/candidateNames.png" alt="图片" loading="lazy"></figure>
<p>上述 processConfigBeanDefinitions 方法第 18-21 行：</p>
<pre><code class="language-java">      // 判断这个 BeanDefinition 是否包含了 @Configuration、@Service 注解
      else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
         configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
      }      
</code></pre>
<p>checkConfigurationClassCandidate<br>
先来看上述第二行调用 checkConfigurationClassCandidate 方法判断是否加了 @Configuration 注解，checkConfigurationClassCandidate 方法如下：</p>
<pre><code class="language-java">public static boolean checkConfigurationClassCandidate(BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) {
   String className = beanDef.getBeanClassName();
   if (className == null || beanDef.getFactoryMethodName() != null) {
      return false;
   }
   AnnotationMetadata metadata;
   if (beanDef instanceof AnnotatedBeanDefinition &amp;&amp;
         className.equals(((AnnotatedBeanDefinition) beanDef).getMetadata().getClassName())) {
      // Can reuse the pre-parsed metadata from the given BeanDefinition...
      // 如果 BeanDefinition 是 AnnotatedBeanDefinition 的实例，并且 className 和 BeanDefinition 中的元数据的类名相同
      // 则直接从 BeanDefinition 获得元数据Metadata
      metadata = ((AnnotatedBeanDefinition) beanDef).getMetadata();
   }
   else if (beanDef instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) beanDef).hasBeanClass()) {
      // Check already loaded Class if present...
      // since we possibly can't even load the class file for this Class.
      Class&lt;?&gt; beanClass = ((AbstractBeanDefinition) beanDef).getBeanClass();
      metadata = new StandardAnnotationMetadata(beanClass, true);
   }
   else {
      try {
         MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);
         metadata = metadataReader.getAnnotationMetadata();
      }
      catch (IOException ex) {
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Could not find class file for introspecting configuration annotations: &quot; + className, ex);
         }
         return false;
      }
   }
  
   // 判断当前这个 bd 中存在的类是不是加了 @Configuration 注解
   if (isFullConfigurationCandidate(metadata)) {
      // 如果存在 Configuration 注解，则为 BeanDefinition 设置 configurationClass 属性为 FULL，结合 processConfigBeanDefinitions 方法的第 10 行，使用 isFullConfigurationClass 判断是否处理过
      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);
   }
   // 判断是否加了以下注解，摘录 isLiteConfigurationCandidate 的源码
   // candidateIndicators.add(Component.class.getName());
   // candidateIndicators.add(ComponentScan.class.getName());
   // candidateIndicators.add(Import.class.getName());
   // candidateIndicators.add(ImportResource.class.getName());
   else if (isLiteConfigurationCandidate(metadata)) {
      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
   }
   else {
      return false;
   }
   // It's a full or lite configuration candidate... Let's determine the order value, if any.
   // 得到排序：如果有多个加了 @Configuration 的类，根据 @Order进行排序决定解析顺序
   Integer order = getOrder(metadata);
   if (order != null) {
      beanDef.setAttribute(ORDER_ATTRIBUTE, order);
   }
   return true;
}
</code></pre>
<p>上述代码第 35 行，判断当前这个 bd 中存在的类是不是加了 @Configuration 注解：</p>
<pre><code class="language-java">public static boolean isFullConfigurationCandidate(AnnotationMetadata metadata) {
   return metadata.isAnnotated(Configuration.class.getName());
}
</code></pre>
<p>上述 checkConfigurationClassCandidate 方法第 44-46 行，判断是否加了其他注解</p>
<pre><code class="language-java">// 判断是否加了以下注解，摘录 isLiteConfigurationCandidate 的源码
// candidateIndicators.add(Component.class.getName());
// candidateIndicators.add(ComponentScan.class.getName());
// candidateIndicators.add(Import.class.getName());
// candidateIndicators.add(ImportResource.class.getName());
  else if (isLiteConfigurationCandidate(metadata)) {
      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
  }
</code></pre>
<p>点进 isLiteConfigurationCandidate 方法如下：</p>
<pre><code class="language-java">public static boolean isLiteConfigurationCandidate(AnnotationMetadata metadata) {
   // Do not consider an interface or an annotation...
   if (metadata.isInterface()) {
      return false;
   }
   // Any of the typical annotations found?
   for (String indicator : candidateIndicators) {
      if (metadata.isAnnotated(indicator)) {
         return true;
      }
   }
   // Finally, let's look for @Bean methods...
   try {
      return metadata.hasAnnotatedMethods(Bean.class.getName());
   }
   catch (Throwable ex) {
      if (logger.isDebugEnabled()) {
         logger.debug(&quot;Failed to introspect @Bean methods on class [&quot; + metadata.getClassName() + &quot;]: &quot; + ex);
      }
      return false;
   }
}
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/candidateIndicators.png" alt="图片" loading="lazy"></figure>
<p>processConfigBeanDefinitions 方法的第 62 行：</p>
<pre><code class="language-java">parser.parse(candidates);
</code></pre>
<p>点进这个 parse 方法：</p>
<pre><code class="language-java">public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) {
   this.deferredImportSelectors = new LinkedList&lt;&gt;();
   // 根据 BeanDefinition 的类型做不同的处理，一般都会调用 ConfigurationClassParse#parse 进行解析
   for (BeanDefinitionHolder holder : configCandidates) {
      BeanDefinition bd = holder.getBeanDefinition();
      try {
         // 判断这个 bd 是否被加了注解
         if (bd instanceof AnnotatedBeanDefinition) {
            parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
         }
         else if (bd instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) {
            parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
         }
         else {
            parse(bd.getBeanClassName(), holder.getBeanName());
         }
      }
      catch (BeanDefinitionStoreException ex) {
         throw ex;
      }
      catch (Throwable ex) {
         throw new BeanDefinitionStoreException(
               &quot;Failed to parse configuration class [&quot; + bd.getBeanClassName() + &quot;]&quot;, ex);
      }
   }
   processDeferredImportSelectors();
}
</code></pre>
<p>再点进上述代码第 9 行的 parse 方法：</p>
<pre><code class="language-java">protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {
   processConfigurationClass(new ConfigurationClass(metadata, beanName));
}
</code></pre>
<p>上述代码第二行调用了 processConfigurationClass 方法，点进去：</p>
<pre><code class="language-java">protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
   // 判断是否应该跳过解析
   if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
      return;
   }
   // 处理 Imported 的情况
   ConfigurationClass existingClass = this.configurationClasses.get(configClass);
   if (existingClass != null) {
      if (configClass.isImported()) {
         if (existingClass.isImported()) {
            existingClass.mergeImportedBy(configClass);
         }
         // Otherwise ignore new imported config class; existing non-imported class overrides it.
         return;
      }
      else {
         // Explicit bean definition found, probably replacing an import.
         // Let's remove the old one and go with the new one.
         this.configurationClasses.remove(configClass);
         this.knownSuperclasses.values().removeIf(configClass::equals);
      }
   }
   // Recursively process the configuration class and its superclass hierarchy.
   SourceClass sourceClass = asSourceClass(configClass);
   do {
      sourceClass = doProcessConfigurationClass(configClass, sourceClass);
   }
   while (sourceClass != null);
   
   // 一个 map，用来存放扫描出来的 bean（注意这里的 bean 不是对象，仅仅是 bean 的信息，因为还没到实例化）
   this.configurationClasses.put(configClass, configClass);
}
</code></pre>
<p>doProcessConfigurationClass</p>
<p>看上述第 28 行：</p>
<pre><code class="language-java">sourceClass = doProcessConfigurationClass(configClass, sourceClass);
</code></pre>
<p>点进这个 doProcessConfigurationClass 方法：</p>
<pre><code class="language-java">@Nullable
protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)
      throws IOException {
   // Recursively process any member (nested) classes first
   // 处理内部类
   processMemberClasses(configClass, sourceClass);
   // Process any @PropertySource annotations
   for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
         sourceClass.getMetadata(), PropertySources.class,
         org.springframework.context.annotation.PropertySource.class)) {
      if (this.environment instanceof ConfigurableEnvironment) {
         processPropertySource(propertySource);
      }
      else {
         logger.warn(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() +
               &quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;);
      }
   }
   // Process any @ComponentScan annotations
   Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(
         sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
   if (!componentScans.isEmpty() &amp;&amp;
         !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
      for (AnnotationAttributes componentScan : componentScans) {
         // The config class is annotated with @ComponentScan -&gt; perform the scan immediately
         Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =
               this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
         // Check the set of scanned definitions for any further config classes and parse recursively if needed
         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
            BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
            if (bdCand == null) {
               bdCand = holder.getBeanDefinition();
            }
            if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
               parse(bdCand.getBeanClassName(), holder.getBeanName());
            }
         }
      }
   }
   // Process any @Import annotations
   processImports(configClass, sourceClass, getImports(sourceClass), true);
   // Process any @ImportResource annotations
   AnnotationAttributes importResource =
         AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
   if (importResource != null) {
      String[] resources = importResource.getStringArray(&quot;locations&quot;);
      Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;);
      for (String resource : resources) {
         String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
         configClass.addImportedResource(resolvedResource, readerClass);
      }
   }
   // Process individual @Bean methods
   Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
   for (MethodMetadata methodMetadata : beanMethods) {
      configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
   }
   // Process default methods on interfaces
   processInterfaces(configClass, sourceClass);
   // Process superclass, if any
   if (sourceClass.getMetadata().hasSuperClass()) {
      String superclass = sourceClass.getMetadata().getSuperClassName();
      if (superclass != null &amp;&amp; !superclass.startsWith(&quot;java&quot;) &amp;&amp;
            !this.knownSuperclasses.containsKey(superclass)) {
         this.knownSuperclasses.put(superclass, configClass);
         // Superclass found, return its annotation metadata and recurse
         return sourceClass.getSuperClass();
      }
   }
   // No superclass -&gt; processing is complete
   return null;
}
</code></pre>
<p>上述代码第 23-24 行，获得带有 @ComponentScan 注解的类<br>
<img src="https://epitomm.github.io/post-images/ComponentScan.png" alt="图片" loading="lazy"></p>
<p>上述代码第 30 行：</p>
<pre><code class="language-java">this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
</code></pre>
<p>再点进去这个 parse 方法：真正解析扫描包的</p>
<pre><code class="language-java">public Set&lt;BeanDefinitionHolder&gt; parse(AnnotationAttributes componentScan, final String declaringClass) {
   ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,
         componentScan.getBoolean(&quot;useDefaultFilters&quot;), this.environment, this.resourceLoader);
   
   // 看有没有自定义外部 Bean 生命器
   Class&lt;? extends BeanNameGenerator&gt; generatorClass = componentScan.getClass(&quot;nameGenerator&quot;);
   boolean useInheritedGenerator = (BeanNameGenerator.class == generatorClass);
   scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator :
         BeanUtils.instantiateClass(generatorClass));
   // 判断这个类是不是代理的
   ScopedProxyMode scopedProxyMode = componentScan.getEnum(&quot;scopedProxy&quot;);
   if (scopedProxyMode != ScopedProxyMode.DEFAULT) {
      scanner.setScopedProxyMode(scopedProxyMode);
   }
   else {
      Class&lt;? extends ScopeMetadataResolver&gt; resolverClass = componentScan.getClass(&quot;scopeResolver&quot;);
      scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));
   }
   scanner.setResourcePattern(componentScan.getString(&quot;resourcePattern&quot;));
   for (AnnotationAttributes filter : componentScan.getAnnotationArray(&quot;includeFilters&quot;)) {
      for (TypeFilter typeFilter : typeFiltersFor(filter)) {
         scanner.addIncludeFilter(typeFilter);
      }
   }
   for (AnnotationAttributes filter : componentScan.getAnnotationArray(&quot;excludeFilters&quot;)) {
      for (TypeFilter typeFilter : typeFiltersFor(filter)) {
         scanner.addExcludeFilter(typeFilter);
      }
   }
   boolean lazyInit = componentScan.getBoolean(&quot;lazyInit&quot;);
   if (lazyInit) {
      scanner.getBeanDefinitionDefaults().setLazyInit(true);
   }
   Set&lt;String&gt; basePackages = new LinkedHashSet&lt;&gt;();
   String[] basePackagesArray = componentScan.getStringArray(&quot;basePackages&quot;);
   for (String pkg : basePackagesArray) {
      String[] tokenized = StringUtils.tokenizeToStringArray(this.environment.resolvePlaceholders(pkg),
            ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);
      Collections.addAll(basePackages, tokenized);
   }
   for (Class&lt;?&gt; clazz : componentScan.getClassArray(&quot;basePackageClasses&quot;)) {
      basePackages.add(ClassUtils.getPackageName(clazz));
   }
   if (basePackages.isEmpty()) {
      basePackages.add(ClassUtils.getPackageName(declaringClass));
   }
    
   // 得到 excludeFilter 设置的排除扫描的包
   scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {
      @Override
      protected boolean matchClassName(String className) {
         return declaringClass.equals(className);
      }
   });
   return scanner.doScan(StringUtils.toStringArray(basePackages));
}
</code></pre>
<p>上述代码第 60 行的 doScan 方法：</p>
<pre><code class="language-java">protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) {
   Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;);
   Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;&gt;();
   for (String basePackage : basePackages) {
      // 扫表 basePackage 路径下的 java 文件
      // 并把它转成 BeanDefinition 类型
      Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);
      for (BeanDefinition candidate : candidates) {
         // 解析 scope 属性
         ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
         candidate.setScope(scopeMetadata.getScopeName());
         String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
         if (candidate instanceof AbstractBeanDefinition) {
            // 如果这个类是 AbstractBeanDefinition 的子类
            // 则为它设置默认值，比如 alzy，init destroy
            postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
         }
         if (candidate instanceof AnnotatedBeanDefinition) {
            // 检查并且处理常用的注解
            // 这里的处理主要是指把常用注解的值设置到 AnnotatedBeanDefinition 当中
            // 当前前提是这个类必须是 AnnotatedBeanDefinition 类型的，说白了就是加了注解的类
            AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
         }
         if (checkCandidate(beanName, candidate)) {
            BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
            definitionHolder =
                  AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
            beanDefinitions.add(definitionHolder);
            // 就是在这个方法中，将扫描包的 Bean 添加到 map 中
            registerBeanDefinition(definitionHolder, this.registry);
         }
      }
   }
   return beanDefinitions;
}
</code></pre>
<p>上述代码第 7 行：</p>
<pre><code class="language-java">public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) {
   if (this.componentsIndex != null &amp;&amp; indexSupportsIncludeFilters()) {
      return addCandidateComponentsFromIndex(this.componentsIndex, basePackage);
   }
   else {
      return scanCandidateComponents(basePackage);
   }
}
</code></pre>
<p>上述代码第 6 行：</p>
<pre><code class="language-java">private Set&lt;BeanDefinition&gt; scanCandidateComponents(String basePackage) {
   Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;&gt;();
   try {
      String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
            resolveBasePackage(basePackage) + '/' + this.resourcePattern;
      Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);
      boolean traceEnabled = logger.isTraceEnabled();
      boolean debugEnabled = logger.isDebugEnabled();
      for (Resource resource : resources) {
         if (traceEnabled) {
            logger.trace(&quot;Scanning &quot; + resource);
         }
         if (resource.isReadable()) {
            try {
               MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);
               if (isCandidateComponent(metadataReader)) {
                  ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
                  sbd.setSource(resource);
                  if (isCandidateComponent(sbd)) {
                     if (debugEnabled) {
                        logger.debug(&quot;Identified candidate component class: &quot; + resource);
                     }
                     candidates.add(sbd);
                  }
                  else {
                     if (debugEnabled) {
                        logger.debug(&quot;Ignored because not a concrete top-level class: &quot; + resource);
                     }
                  }
               }
               else {
                  if (traceEnabled) {
                     logger.trace(&quot;Ignored because not matching any filter: &quot; + resource);
                  }
               }
            }
            catch (Throwable ex) {
               throw new BeanDefinitionStoreException(
                     &quot;Failed to read candidate component class: &quot; + resource, ex);
            }
         }
         else {
            if (traceEnabled) {
               logger.trace(&quot;Ignored because not readable: &quot; + resource);
            }
         }
      }
   }
   catch (IOException ex) {
      throw new BeanDefinitionStoreException(&quot;I/O failure during classpath scanning&quot;, ex);
   }
   return candidates;
}
</code></pre>
<p><img src="https://epitomm.github.io/post-images/parse%E5%89%8D.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/parse%E5%90%8E.png" alt="图片" loading="lazy"></p>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/bean%E5%B7%A5%E5%8E%82_3.png" alt="图片" loading="lazy"></figure>
<h1 id="spring-bean-的扩展">Spring Bean 的扩展</h1>
<h2 id="beandefinitionregistrypostprocessor">BeanDefinitionRegistryPostProcessor</h2>
<h1 id="总结">总结</h1>
<pre><code class="language-java">//实例化一个工厂DefaultListableBeanFactory

org.springframework.context.support.GenericApplicationContext-&gt;GenericApplicationContext()

  	1、实例化一个AnnotatedBeanDefinitionReader

	2、ClassPathBeanDefinitionScanner，能够扫描我们bd,能够扫描一个类，并且转换成bd
	
	org.springframework.context.annotation.AnnotationConfigApplicationContext#AnnotationConfigApplicationContext()
	
		委托AnnotationConfigUtils
	
		org.springframework.context.annotation.AnnotatedBeanDefinitionReader#AnnotatedBeanDefinitionReader()


​			

			org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors()


​			

				1、添加AnnotationAwareOrderComparator类的对象，主要去排序
	
				2、ContextAnnotationAutowireCandidateResolver
	
				3、往BeanDefinitionMap注册一个ConfigurationClassPostProcessor?  org.springframework.context.annotation.internalConfigurationAnnotationProcessor
	
					why?因为需要在invokeBeanFactoryPostProcessors
	
					invokeBeanFactoryPostProcessors主要是在spring的beanFactory初始化的过程中去做一些事情，怎么来做这些事情呢？
	
					委托了多个实现了BeanDefinitionRegistryPostProcessor或者BeanFactoryProcessor接口的类来做这些事情,有自定义的也有spring内部的
	
					其中ConfigurationClassPostProcessor就是一个spring内部的BeanDefinitionRegistryPostProcessor
	
					因为如果你不添加这里就没有办法委托ConfigurationClassPostProcessor做一些功能
	
					到底哪些功能？参考下面的注释
	
				4、RequiredAnnotationBeanPostProcessor
	
				.......
	
				org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors()
	
					//往BeanDefinitionMap注册
	
					org.springframework.context.annotation.AnnotationConfigUtils#registerPostProcessor
	
						//准备好bean工厂，实例化对象
	
						org.springframework.context.support.AbstractApplicationContext#refresh
	
						//准备工作包括设置启动时间，是否激活标识位， 初始化属性源(property source)配置
	
							org.springframework.context.support.AbstractApplicationContext#prepareRefresh
	
								//得到beanFactory?因为需要对beanFactory进行设置
	
								org.springframework.context.support.AbstractApplicationContext#obtainFreshBeanFactory
	
									//准备bean工厂
	
									1、添加一个类加载器
	
									2、添加bean表达式解释器，为了能够让我们的beanFactory去解析bean表达式
	
									3、添加一个后置处理器ApplicationContextAwareProcessor
	
									4、添加了自动注入别忽略的列表
	
									5、。。。。。。
	
									6、添加了一个ApplicationListenerDetector后置处理器（自行百度）
	
									org.springframework.context.support.AbstractApplicationContext#prepareBeanFactory
	
										目前没有任何实现
	
										org.springframework.context.support.AbstractApplicationContext#postProcessBeanFactory
	
											1、getBeanFactoryPostProcessors()得到自己定义的（就是程序员自己写的，并且没有交给spring管理，就是没有加上@Component）
	
											2、得到spring内部自己维护的BeanDefinitionRegistryPostProcessor
	
											org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors
	
												//调用这个方法
	
												//循环所有的BeanDefinitionRegistryPostProcessor
	
												//该方法内部postProcessor.postProcessBeanDefinitionRegistry
	
												org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanDefinitionRegistryPostProcessors
	
													//调用扩展方法postProcessBeanDefinitionRegistry
	
													org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry
	
														//拿出的所有bd，然后判断bd时候包含了@Configuration、@Import，@Compent。。。注解
	
														org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions
	
															1、的到bd当中描述的类的元数据（类的信息）
	
															2、判断是不是加了@Configuration   metadata.isAnnotated(Configuration.class.getName())
	
															3、如果加了@Configuration，添加到一个set当中,把这个set传给下面的方法去解析
	
															org.springframework.context.annotation.ConfigurationClassUtils#checkConfigurationClassCandidate
	
															//扫描包


​															

															org.springframework.context.annotation.ConfigurationClassParser#parse(java.util.Set&lt;org.springframework.beans.factory.config.BeanDefinitionHolder&gt;)


​																

																org.springframework.context.annotation.ConfigurationClassParser#parse(org.springframework.core.type.AnnotationMetadata, java.lang.String)
	
																	//就行了一个类型封装
	
																	org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass
	
																	1、处理内部类 一般不会写内部类
	
																	org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass
	
																		//解析扫描的一些基本信息，比如是否过滤，比如是否加入新的包。。。。。
	
																		org.springframework.context.annotation.ComponentScanAnnotationParser#parse
	
																			org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan
	
																			org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#findCandidateComponents
	
																				org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#scanCandidateComponents
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#1new-annotationconfigapplicationcontext">1.new AnnotationConfigApplicationContext();</a>
<ul>
<li><a href="#11-genericapplicationcontext">1.1 GenericApplicationContext()</a>
<ul>
<li><a href="#111-defaultlistablebeanfactory">1.1.1 DefaultListableBeanFactory</a></li>
</ul>
</li>
<li><a href="#12-annotationconfigapplicationcontext">1.2 AnnotationConfigApplicationContext()</a>
<ul>
<li><a href="#121-thisreader-new-annotatedbeandefinitionreaderthis">1.2.1 this.reader = new AnnotatedBeanDefinitionReader(this);</a>
<ul>
<li><a href="#1211-annotatedbeandefinitionreaderbeandefinitionregistry-registry-environment-environment">1.2.1.1 AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment)</a></li>
</ul>
</li>
<li><a href="#122-thisscanner-new-classpathbeandefinitionscannerthis">1.2.2 this.scanner = new ClassPathBeanDefinitionScanner(this);</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2contextregisterappconfigclass">2.context.register(AppConfig.class);</a>
<ul>
<li><a href="#21-doregisterbean">2.1 doRegisterBean</a>
<ul>
<li><a href="#211-new-annotatedgenericbeandefinitionannotatedclass">2.1.1 new AnnotatedGenericBeanDefinition(annotatedClass);</a></li>
<li><a href="#212-registerbeandefinitiondefinitionholder-thisregistry">2.1.2 registerBeanDefinition(definitionHolder, this.registry);</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3contextrefresh">3.context.refresh()</a>
<ul>
<li><a href="#31-preparerefresh">3.1 prepareRefresh();</a></li>
<li><a href="#32-obtainfreshbeanfactory">3.2 obtainFreshBeanFactory();</a></li>
<li><a href="#33-preparebeanfactorybeanfactory">3.3 prepareBeanFactory(beanFactory);</a>
<ul>
<li><a href="#331-beanfactoryaddbeanpostprocessornew-applicationcontextawareprocessorthis">3.3.1 beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</a></li>
</ul>
</li>
<li><a href="#34-postprocessbeanfactorybeanfactory">3.4 postProcessBeanFactory(beanFactory);</a></li>
<li><a href="#35-invokebeanfactorypostprocessorsbeanfactory">3.5 invokeBeanFactoryPostProcessors(beanFactory);</a>
<ul>
<li><a href="#351-getbeanfactorypostprocessors">3.5.1 getBeanFactoryPostProcessors()</a></li>
<li><a href="#352-invokebeanfactorypostprocessorsbeanfactory-getbeanfactorypostprocessors">3.5.2 invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</a>
<ul>
<li><a href="#3521-listbeanfactorypostprocessor-listbeandefinitionregistrypostprocessor">3.5.2.1  List<BeanFactoryPostProcessor>、List<BeanDefinitionRegistryPostProcessor></a></li>
<li><a href="#3522-getbeannamesfortype">3.5.2.2 getBeanNamesForType</a></li>
<li><a href="#3523-invokebeandefinitionregistrypostprocessors">3.5.2.3 invokeBeanDefinitionRegistryPostProcessors</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#spring-bean-%E7%9A%84%E6%89%A9%E5%B1%95">Spring Bean 的扩展</a>
<ul>
<li><a href="#beandefinitionregistrypostprocessor">BeanDefinitionRegistryPostProcessor</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://epitomm.github.io/post/spring-xi-lie-liu-spring-yuan-ma-jie-xi/">
              <h3 class="post-title">
                Spring系列（六）Spring源码解析
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '974bd77fbbd52c2a0647',
    clientSecret: '6344370ca1314dbd553f45e75a2121a160ef1c44',
    repo: 'EpitomM.github.io',
    owner: 'EpitomM',
    admin: ['EpitomM'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/EpitomM/EpitomM.github.io" target="_blank">EpitomM</a>
  <a class="rss" href="https://epitomm.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
