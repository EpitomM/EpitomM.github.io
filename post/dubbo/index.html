<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="热心善良的老学姐">
<meta name="theme-color" content="#000">
<title>dubbo | SSM</title>
<link rel="shortcut icon" href="/favicon.ico?v=1597044612239">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/androidstudio.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>





  <meta name="description" content="dubbo" />
  <meta name="keywords" content="dubbo" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>SSM</span>
            </a>  
          
        </div>
        
          <p class="subtitle">一个敲热心的老学姐</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">SSM</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">49</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">20</span>
        <span class="site-item-stat-name language" data-lan="category">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">20</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  


</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li><a href="#%E4%B8%80-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">一、基础知识</a>
<ul>
<li><a href="#1-%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA">1、分布式基础理论</a>
<ul>
<li><a href="#11-%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F">1.1）、什么是分布式系统？</a></li>
<li><a href="#12-%E5%8F%91%E5%B1%95%E6%BC%94%E5%8F%98">1.2）、发展演变</a></li>
<li><a href="#13-rpc">1.3）、RPC</a></li>
</ul>
</li>
<li><a href="#2-dubbo%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5">2、dubbo核心概念</a>
<ul>
<li><a href="#21-%E7%AE%80%E4%BB%8B">2.1）、简介</a></li>
<li><a href="#22-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">2.2）、基本概念</a></li>
</ul>
</li>
<li><a href="#3-dubbo%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">3、dubbo环境搭建</a>
<ul>
<li><a href="#31-windows-%E5%AE%89%E8%A3%85zookeeper">3.1）、【windows】-安装zookeeper</a></li>
<li><a href="#32-windows-%E5%AE%89%E8%A3%85dubbo-admin%E7%AE%A1%E7%90%86%E6%8E%A7%E5%88%B6%E5%8F%B0">3.2）、【windows】-安装dubbo-admin管理控制台</a></li>
<li><a href="#33-linux-%E5%AE%89%E8%A3%85zookeeper">3.3）、【linux】-安装zookeeper</a></li>
<li><a href="#34-linux-%E5%AE%89%E8%A3%85dubbo-admin%E7%AE%A1%E7%90%86%E6%8E%A7%E5%88%B6%E5%8F%B0">3.4）、【linux】-安装dubbo-admin管理控制台</a></li>
</ul>
</li>
<li><a href="#4-dubbo-helloworld">4、dubbo-helloworld</a>
<ul>
<li><a href="#41-%E6%8F%90%E5%87%BA%E9%9C%80%E6%B1%82">4.1）、提出需求</a></li>
<li><a href="#42-%E5%B7%A5%E7%A8%8B%E6%9E%B6%E6%9E%84">4.2）、工程架构</a></li>
<li><a href="#43-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97">4.3）、创建模块</a></li>
<li><a href="#44-%E4%BD%BF%E7%94%A8dubbo%E6%94%B9%E9%80%A0">4.4）、使用dubbo改造</a></li>
</ul>
</li>
<li><a href="#5-%E7%9B%91%E6%8E%A7%E4%B8%AD%E5%BF%83">5、监控中心</a>
<ul>
<li><a href="#51-dubbo-admin">5.1）、dubbo-admin</a></li>
<li><a href="#52-dubbo-monitor-simple">5.2）、dubbo-monitor-simple</a></li>
</ul>
</li>
<li><a href="#6-%E6%95%B4%E5%90%88springboot">6、整合SpringBoot</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-dubbo%E9%85%8D%E7%BD%AE">二、dubbo配置</a>
<ul>
<li><a href="#1-%E9%85%8D%E7%BD%AE%E5%8E%9F%E5%88%99">1、配置原则</a></li>
<li><a href="#2-%E9%87%8D%E8%AF%95%E6%AC%A1%E6%95%B0">2、重试次数</a></li>
<li><a href="#3-%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4">3、超时时间</a>
<ul>
<li><a href="#1-dubbo%E6%B6%88%E8%B4%B9%E7%AB%AF">1、Dubbo消费端</a></li>
<li><a href="#2-dubbo%E6%9C%8D%E5%8A%A1%E7%AB%AF">2、Dubbo服务端</a></li>
<li><a href="#3-%E9%85%8D%E7%BD%AE%E5%8E%9F%E5%88%99">3、配置原则</a></li>
</ul>
</li>
<li><a href="#4-%E7%89%88%E6%9C%AC%E5%8F%B7">4、版本号</a></li>
<li><a href="#5-%E5%90%AF%E5%8A%A8%E6%97%B6%E6%A3%80%E6%9F%A5">5、启动时检查</a>
<ul>
<li><a href="#%E7%A4%BA%E4%BE%8B">示例</a></li>
</ul>
</li>
<li><a href="#6-%E5%A4%9A%E7%89%88%E6%9C%AC">6、多版本</a></li>
<li><a href="#7-%E6%9C%AC%E5%9C%B0%E5%AD%98%E6%A0%B9">7、本地存根</a></li>
<li><a href="#8-springboot-%E4%B8%8E-dubbo-%E6%95%B4%E5%90%88%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F">8、Springboot 与 dubbo 整合的三种方式</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E9%AB%98%E5%8F%AF%E7%94%A8">三、高可用</a>
<ul>
<li><a href="#1-zookeeper%E5%AE%95%E6%9C%BA%E4%B8%8Edubbo%E7%9B%B4%E8%BF%9E">1、zookeeper宕机与dubbo直连</a></li>
<li><a href="#2-%E9%9B%86%E7%BE%A4%E4%B8%8Bdubbo%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE">2、集群下dubbo负载均衡配置</a>
<ul>
<li><a href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5">负载均衡策略</a></li>
<li><a href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE">负载均衡配置</a></li>
</ul>
</li>
<li><a href="#3-%E6%95%B4%E5%90%88hystrix%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%E4%B8%8E%E9%99%8D%E7%BA%A7%E5%A4%84%E7%90%86">3、整合hystrix，服务熔断与降级处理</a>
<ul>
<li><a href="#1-%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7">1、服务降级</a></li>
<li><a href="#2-%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99">2、集群容错</a></li>
<li><a href="#3-%E6%95%B4%E5%90%88hystrix">3、整合hystrix</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%9B%9B-dubbo%E5%8E%9F%E7%90%86">四、dubbo原理</a>
<ul>
<li><a href="#1-rpc%E5%8E%9F%E7%90%86">1、RPC原理</a></li>
<li><a href="#2-netty%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86">2、netty通信原理</a></li>
<li><a href="#3-dubbo%E5%8E%9F%E7%90%86">3、dubbo原理</a>
<ul>
<li><a href="#1-dubbo%E5%8E%9F%E7%90%86-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1">1、dubbo原理	-框架设计</a></li>
<li><a href="#2-dubbo%E5%8E%9F%E7%90%86-%E5%90%AF%E5%8A%A8%E8%A7%A3%E6%9E%90-%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF">2、dubbo原理	-启动解析、加载配置信息</a></li>
<li><a href="#3-dubbo%E5%8E%9F%E7%90%86-%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2">3、dubbo原理	-服务暴露</a></li>
<li><a href="#4-dubbo%E5%8E%9F%E7%90%86-%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8">4、dubbo原理	-服务引用</a></li>
<li><a href="#5-dubbo%E5%8E%9F%E7%90%86-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8">5、dubbo原理	-服务调用</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://epitomm.github.io/post/dubbo/">
      dubbo
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span>2020-04-10</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">分类于</span>
      
      
      <a href="https://epitomm.github.io/tag/AivfZDvn2/">
        <span>dubbo</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>59<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>14312<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
  </div>
</header>
            <div class="post-body next-md-body" id="post_body">
              <h1 id="一-基础知识">一、基础知识</h1>
<h2 id="1-分布式基础理论">1、分布式基础理论</h2>
<h3 id="11-什么是分布式系统">1.1）、什么是分布式系统？</h3>
<p>《分布式系统原理与范型》定义：</p>
<p>“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”</p>
<p>分布式系统（distributed system）是建立在网络之上的软件系统。</p>
<p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需<strong>一个治理系统</strong>确保架构有条不紊的演进。</p>
<h3 id="12-发展演变">1.2）、发展演变</h3>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E6%BC%94%E5%8F%98.png" alt="图片" loading="lazy"></figure>
<p><em>单一应用架构</em></p>
<p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。<br>
<img src="https://epitomm.github.io/post-images/%E5%8D%95%E4%B8%80%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84.png" alt="图片" loading="lazy"></p>
<pre><code>适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。

缺点： 1、性能扩展比较难 （如果修改或添加某个功能，都需要把整个应用重新打包，重新放部署到 服务器）

       2、协同开发问题（所有人都去修改一个应用，容易乱）

       3、不利于升级维护
</code></pre>
<blockquote>
<p>将多个功能放到一个应用内，打包后放到服务器上即可。访问量增大，一个服务器无法承受时，再添加一个服务器同时跑这个应用。</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E5%8D%95%E4%B8%80%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%842.png" alt="图片" loading="lazy"></figure>
<p><em>垂直应用架构</em></p>
<p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E5%9E%82%E7%9B%B4%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84.png" alt="图片" loading="lazy"></figure>
<pre><code>通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。

缺点： 公用模块无法重复利用，开发性的浪费
</code></pre>
<blockquote>
<p>将一个大应用拆分成几个独立的小应用，每一个应用都是从头到尾完成的（从页面到业务逻辑程序到数据库）。</p>
</blockquote>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E5%9E%82%E7%9B%B4%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%842.png" alt="图片" loading="lazy"></figure>
<p>垂直应用架构</p>
<blockquote>
<p>当某一块应用的访问量比较大时，将这个应用多扩展几个服务器。</p>
</blockquote>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/%E5%9E%82%E7%9B%B4%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%843.png" alt="图片" loading="lazy"></figure>
<p>扩展某个小应用即可</p>
<blockquote>
<p>好处：1）分工合作容易，每个人负责开发维护不同的应用，互不干扰。<br>
2）性能扩展容易，比如“用户”应用的访问量增大， 就把它多放几台服务器，扩展的是某个小应用，其他小应用无需变动。<br>
缺点：1）由于每个小应用都是完整的（界面+业务逻辑+数据库），但是界面要求经常变化，每个界面的变化都会导致应用的重新部署。无法做到页面 和 业务逻辑 的分离<br>
2） 随着应用的逐步增多，垂直应用会越来越多，这样的情况下，不可能理想的应用和应用之间互相独立，订单模块需要用户模块和商品模块信息，应用之间交互，不可能完全独立。</p>
</blockquote>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E5%9E%82%E7%9B%B4%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%844.png" alt="图片" loading="lazy"></figure>
<p>界面与业务逻辑无法分离，各个应用间需要交互</p>
<p><em>分布式服务架构</em></p>
<p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的<strong>分布式服务框架(RPC)是关键</strong>。</p>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%841.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>将用户抽取成“用户界面” 和 “用户业务”，订单抽取成 “订单界面” 和 “订单业务” 等。<br>
当业务逻辑不变的情况下，如果只想修改界面，重启界面服务器即可，核心业务逻辑还在其他服务器上，无需变动。<br>
<img src="https://epitomm.github.io/post-images/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%842.png" alt="图片" loading="lazy"></p>
</blockquote>
<blockquote>
<p>用户界面放在 A 服务器上，用户业务放在 B 服务器上，订单业务放在 C 服务器上，如果 A 服务器（用户界面）需要调用 B 服务器（用户业务）的功能。如果写在一个应用内，A 调用 B，直接“方法 A . 方法 B” 即可，直接调用，进程类通讯，都在一个服务器上，都是同一个 tomcat，同一个进程类通讯。但如果是分布式服务架构，A 和 B 在两台服务器上，这样的不同服务器间的互相调用称为 RPC（远程过程调用）。分布式服务架构的难点：如何进行远程过程调用，如果拆分应用，提升业务的复用程度。<br>
随着业务的不断增多，分拆的业务越来越多，成千上万的服务器在跑不同的服务，出现的资源浪费问题愈加严重，比如用户业务访问量较小，但却有 100 台服务器在跑，就造成了浪费；而 商品业务 访问量很大，但却只有 10 台服务器在跑。应该有一个基于访问压力的调度中心能够实时监控数据动态调度，提高资源利用率，让更多的服务器去跑业务量更大的业务。</p>
</blockquote>
<p><em>流动计算架构</em></p>
<p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于<strong>提高机器利用率的资源调度和治理中心(SOA)[ Service Oriented Architecture]是关键</strong>。</p>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/%E6%B5%81%E5%8A%A8%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>采用流动计算架构，引入调度中心，负责维护服务间的复杂关系，实时管理集群，比如 A 服务器访问量大了，给 A 多增加几台服务器，假设 第一台 有 100 个请求，第二台 有 2 个请求，第三台有 10000 个请求，那么下次请求进来，就应该找比较闲的第二台服务器来处理请求，以此提高整个集群利用率。</p>
</blockquote>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/%E6%B5%81%E5%8A%A8%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%842.png" alt="图片" loading="lazy"></figure>
<p>流动计算架构</p>
<h3 id="13-rpc">1.3）、RPC</h3>
<p><em>什么叫RPC</em></p>
<p>RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</p>
<p><em>RPC基本原理</em></p>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/RPC%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>需求：A 服务器客户端（client）有一个小功能，想要调用 B 服务器的一个小功能。<br>
实现：A 服务器客户端（client）先找一个小助手（client stub），这个小助手一看，A 服务器想要调用 B 服务器上的功能，先跟 B 服务器在网络上建立一个 sockets 连接，将要调用 B 的一些信息（比如要调用 B 的某个方法的方法名、参数）传递给 B 模型，B 服务器上的小助手（server stub）收到这些信息，知道了 A 服务器想要调用 我的一个方法，执行这个方法后，将返回值依次传回 A 客户端。</p>
</blockquote>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/RPC%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%862.png" alt="图片" loading="lazy"></figure>
<p>RPC两个核心模块：通讯，序列化。</p>
<p>RPC 框架有很多如：dubbo、gRPC、Thrift、HSF(High Speed Service Framework)</p>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/RPC%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%863.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>A 服务器上有一个 hello()方法，想要调用 B 服务器上的 hi() 方法，同时传入一个 User  对象，B 服务器上的 hi() 方法执行完了以后，返回一个 String 给 A 服务器，A服务器调完 B服务器的方法后，收到 B 服务器的返回值并在控制台打印。<br>
调用过程：A 服务器客户端（Client） 想要 调用 B 服务器的代码，A 服务器上有一个小助手（Client Stub）这个小助手一看 A 服务器 要调用 B 服务器，先与 B 服务器建议连接，建立连接后，由于调用方法要传递参数，这个参数要发给 B 服务器，参数对象要在网络间传递需要先序列化 ，序列化后将要调用的信息传递给 B 服务器的小助手（Server Stub），B 服务器的小助手收到信息，一看有来自外界的 A 服务器想要调用我的 hi() 方法，同时还传递来了一个参数值，由于是序列化传递过来的，如果使用则需反序列化成对象，B服务器上的小助手调用 B 服务器上的方法，拿到反序列化的对象、一些属性值，方法调用完就会有一个返回值，返回值过来要在网络间传递数据，将返回的 String 对象序列化传递给 A 服务器的小助手，Client Stub 收到后再反序列化，输出。<br>
整个过程两个核心：建立连接、传递数据（序列化和反序列化）。所以，影响一个 RPC 框架性能的重要两点：能否快速地在各个服务器间建立连接；序列化/反序列化机制的速度。</p>
</blockquote>
<h2 id="2-dubbo核心概念">2、dubbo核心概念</h2>
<h3 id="21-简介">2.1）、简介</h3>
<p>Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p>
<p>官网：</p>
<p><a href="http://dubbo.apache.org/zh-cn/">http://dubbo.apache.org/zh-cn/</a></p>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/dubbo%E7%89%B9%E6%80%A7.png" alt="图片" loading="lazy"></figure>
<ol>
<li><strong>面向接口代理的高性能 RPC 调用</strong></li>
</ol>
<p>使用 dubbo 时，A 服务器 要调用 B 服务器上的代码，只需将 B 功能方法的接口 InterfaceB拿过来，调用接口所在的方法 InterfaceB.fun()，就会自动去找服务器 B 上的代码代码调用，屏蔽了远程的调用细节。类似在用 Mybatis ，操作数据库时，只需要写一个 mapper 接口，调用接口的方法即可。</p>
<ol start="2">
<li><strong>智能负载均衡</strong></li>
</ol>
<p>比如用户业务访问量很大，就需要多放几台服务器，“用户界面” 想要调用 “用户业务” 的功能，调用 “用户业务” 的哪一台服务器都可以，假设 第一台用户业务服务器当前有 100 个请求， 第二台用户业务服务器当前有 2 个请求， 第三台用户业务服务器当前有 1000 个请求， 第四台用户业务服务器当前有 10 个请求，就应该找一个非常空闲的服务器快速处理这次响应，这个机制就叫做<strong>负载均衡</strong>，让每个服务器都有一个很均衡的负载，不要让某一台服务器做太多的响应，把它压垮，也不要让某一台服务器太闲，资源浪费。</p>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/%E6%99%BA%E8%83%BD%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png" alt="图片" loading="lazy"></figure>
<ol start="3">
<li><strong>服务自动注册与发现</strong></li>
</ol>
<p>想象这样一个场景：业务非常多，每一块的访问量都特别大，比如用户业务在 1、2、3、4 号服务器都有，支付业务在 9、11、13 号服务器都有，那么 订单web 想要调用支付业务，RPC 框架爱如何知道支付业务都在哪些服务器上呢？如果 11 号服务器出问题了，框架如何自动地知道这个事呢？引入<strong>注册中心</strong>机制。</p>
<p>为了能动态感知到每一个服务，可以将所有的服务都注册到注册中心，包括前端程序也可以都注册到注册中心内，注册中心相当于维护了一个 “业务 - 服务器” 清单，比如：用户业务：1、2、3、4 号服务器，如果 2 号服务器出问题了，就把它从清单中删掉。如果 订单web 要调用支付业务，先到注册中心的清单内找支付业务都在哪一台服务器上，然后随机选择或者选择请求量最少的一台服务器进行访问。</p>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.png" alt="图片" loading="lazy"></figure>
<ol start="4">
<li><strong>高度可扩展</strong></li>
</ol>
<p>微内核 + 插件</p>
<ol start="5">
<li><strong>运行期流量调度</strong></li>
</ol>
<p>内置条件、脚本等路由策略，通过配置不同的路由规则，轻松实现<strong>灰度发布</strong>，同机房优先等功能。</p>
<p>灰度发布：一个用户服务在 100 台服务器上跑，用户服务做了开发升级，先选定 20 台服务器，让它们先用新版本的服务，剩下的 80 台使用旧版本的服务，等这 20 台用着都没问题了，再选 20 台，这样逐步过渡，直到 100 台全用到新的用户服务。配置不同的路由规则，请求进来后，让一部分请求用新升级的服务，剩下的来用旧的服务，通过这种方式从旧服务转化成新服务的过程就叫做<strong>灰度发布</strong>。</p>
<ol start="6">
<li><strong>可视化的服务治理和运维</strong></li>
</ol>
<p>通过可视化的 WEB 界面动态查询服务的信息、调整一些参数。</p>
<h3 id="22-基本概念">2.2）、基本概念</h3>
<figure data-type="image" tabindex="16"><img src="https://epitomm.github.io/post-images/dubbo%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.png" alt="图片" loading="lazy"></figure>
<p><strong>服务提供者（Provider）</strong>：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</p>
<p><strong>服务消费者（Consumer）</strong>: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>
<p><strong>注册中心（Registry）</strong>：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</p>
<p><strong>监控中心（Monitor）</strong>：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p>
<p><strong>框架容器（Container</strong>）</p>
<ul>
<li>调用关系说明
<ul>
<li>服务容器负责启动，加载，运行服务提供者。</li>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。<br>
<img src="https://epitomm.github.io/post-images/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.png" alt="图片" loading="lazy"></li>
</ul>
</li>
</ul>
<p>用户业务是实际的业务功能，web 界面要去调用这些业务功能，所以，用户业务是一个服务提供者（Provider），而 web 界面是服务消费者（Consumer）</p>
<blockquote>
<p>运行流程：容器 Container 启动，初始化 init ，服务提供者 Provider 将自己提供的信息注册 register 到注册中心 Registry ，注册中心就知道有哪些服务上线了，当服务消费者 Consumer 启动，从注册中心订阅 subscribe 自己所需要的服务，如果服务提供者发生变更（3 号服务器下线了），注册中心将这次变更推送 notify 给消费者，消费者拿到所有它能调用的服务，调用的时候可以同步调用 invoke 服务提供者提供的服务，如果消费者要调用的服务有多台服务器在提供，消费者根据负载均衡算法选择一个进行调用。每次的调用信息会定时地每隔一分钟将信息发送到监控中心 Monitor，监控中心就能监控到服务的状态。<br>
0、1、2 这三步是在初始化、启动应用时完成的。<br>
3、5 是异步过程，<br>
4 服务消费者调用服务提供者提供的功能是一个同步的调用。<br>
了解了 dubbo 框架，在编写 dubbo 应用时：</p>
<ol>
<li>先写一个服务提供者，将服务提供者提供的服务注册到注册中心；</li>
<li>编写一个服务消费者，消费者从注册中心订阅提供者提供的服务；</li>
<li>测试消费者如何调用提供者提供的功能。</li>
</ol>
</blockquote>
<h2 id="3-dubbo环境搭建">3、dubbo环境搭建</h2>
<h3 id="31-windows-安装zookeeper">3.1）、【windows】-安装zookeeper</h3>
<table>
<thead>
<tr>
<th style="text-align:center">1、下载zookeeper网址 <a href="https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/">https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/</a></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2、解压zookeeper解压运行zkServer.cmd ，初次运行会报错，没有zoo.cfg配置文件</td>
</tr>
<tr>
<td style="text-align:center">3、修改zoo.cfg配置文件将conf下的zoo_sample.cfg复制一份改名为zoo.cfg即可。注意几个重要位置：dataDir=./   临时数据存储的目录（可写相对路径）clientPort=2181   zookeeper的端口号修改完成后再次启动zookeeper</td>
</tr>
<tr>
<td style="text-align:center">4、使用zkCli.cmd测试ls /：列出zookeeper根下保存的所有节点create –e /atguigu 123：创建一个atguigu节点，值为123get /atguigu：获取/atguigu节点的值</td>
</tr>
</tbody>
</table>
<p>注：记录一个小 bug</p>
<p>问题：【zookeeper】报错-Dzookeeper.log.dir=xxx&quot;' 不是内部或外部命令，也不是可运行的程序 或批处理文件的解决</p>
<p>解决：修改zkServer.cmd文件。将 call %JAVA% 改成 java</p>
<pre><code>java &quot;-Dzookeeper.log.dir=%ZOO_LOG_DIR%&quot; &quot;-Dzookeeper.root.logger=%ZOO_LOG4J_PROP%&quot; -cp &quot;%CLASSPATH%&quot; %ZOOMAIN% &quot;%ZOOCFG%&quot; %*
</code></pre>
<p>参考博客：<a href="https://blog.csdn.net/pangdongh/article/details/90208230">https://blog.csdn.net/pangdongh/article/details/90208230</a></p>
<h3 id="32-windows-安装dubbo-admin管理控制台">3.2）、【windows】-安装dubbo-admin管理控制台</h3>
<p>dubbo本身并不是一个服务软件。它其实就是一个jar包能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。所以你不用在Linux上启动什么dubbo服务。</p>
<p>但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序，不过这个监控即使不装也不影响使用。</p>
<p>1、下载dubbo-admin</p>
<p><a href="https://github.com/apache/incubator-dubbo-ops">https://github.com/apache/incubator-dubbo-ops</a></p>
<figure data-type="image" tabindex="17"><img src="https://epitomm.github.io/post-images/dubbo-admin%E4%B8%8B%E8%BD%BD.png" alt="图片" loading="lazy"></figure>
<p>2、进入目录，修改dubbo-admin配置</p>
<p>修改 src\main\resources\application.properties 指定zookeeper地址</p>
<figure data-type="image" tabindex="18"><img src="https://epitomm.github.io/post-images/dubbo-admin%E9%85%8D%E7%BD%AE.png" alt="图片" loading="lazy"></figure>
<p>3、打包dubbo-admin</p>
<pre><code>mvn clean package -Dmaven.test.skip=true 
</code></pre>
<p>4、运行dubbo-admin</p>
<pre><code>java -jar dubbo-admin-0.0.1-SNAPSHOT.jar
</code></pre>
<p><strong>注意：【有可能控制台看着启动了，但是网页打不开，需要在控制台按下ctrl+c即可】</strong></p>
<p>默认使用root/root 登陆</p>
<figure data-type="image" tabindex="19"><img src="https://epitomm.github.io/post-images/%E8%BF%90%E8%A1%8Cdubbo-admin.png" alt="图片" loading="lazy"></figure>
<h3 id="33-linux-安装zookeeper">3.3）、【linux】-安装zookeeper</h3>
<p><em>1、安装jdk</em></p>
<p>1、下载jdk</p>
<p><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p>
<figure data-type="image" tabindex="20"><img src="https://epitomm.github.io/post-images/%E4%B8%8B%E8%BD%BDjdk.png" alt="图片" loading="lazy"></figure>
<p>不要使用wget命令获取jdk链接，这是默认不同意，导致下载来的jdk压缩内容错误</p>
<p>2、上传到服务器并解压</p>
<figure data-type="image" tabindex="21"><img src="https://epitomm.github.io/post-images/jdk%E8%A7%A3%E5%8E%8B.png" alt="图片" loading="lazy"></figure>
<p>3、设置环境变量</p>
<pre><code>/usr/local/java/jdk1.8.0_171
</code></pre>
<figure data-type="image" tabindex="22"><img src="https://epitomm.github.io/post-images/%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" alt="图片" loading="lazy"></figure>
<p>文件末尾加入下面配置</p>
<pre><code>export JAVA_HOME=/usr/local/java/jdk1.8.0_171

export JRE_HOME=${JAVA_HOME}/jre

export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib

export PATH=${JAVA_HOME}/bin:$PATH
</code></pre>
<figure data-type="image" tabindex="23"><img src="https://epitomm.github.io/post-images/jdk%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F2.png" alt="图片" loading="lazy"></figure>
<p>4、使环境变量生效&amp;测试JDK</p>
<figure data-type="image" tabindex="24"><img src="https://epitomm.github.io/post-images/jdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%94%9F%E6%95%88.png" alt="图片" loading="lazy"></figure>
<p><em>2、安装zookeeper</em></p>
<p>1、下载zookeeper</p>
<p>网址 <a href="https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/">https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/</a></p>
<p>wget <a href="https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/zookeeper-3.4.11.tar.gz">https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/zookeeper-3.4.11.tar.gz</a></p>
<p>2、解压</p>
<figure data-type="image" tabindex="25"><img src="https://epitomm.github.io/post-images/%E8%A7%A3%E5%8E%8Bzk.png" alt="图片" loading="lazy"></figure>
<p>3、移动到指定位置并改名为zookeeper</p>
<figure data-type="image" tabindex="26"><img src="https://epitomm.github.io/post-images/zk%E7%A7%BB%E5%8A%A8%E5%91%BD%E5%90%8D.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="27"><img src="https://epitomm.github.io/post-images/zk%E6%9F%A5%E7%9C%8B%E7%9B%AE%E5%BD%95.png" alt="图片" loading="lazy"></figure>
<p><em>3、开机启动zookeeper</em></p>
<p>1）-复制如下脚本</p>
<pre><code>#!/bin/bash

#chkconfig:2345 20 90

#description:zookeeper

#processname:zookeeper

ZK_PATH=/usr/local/zookeeper

export JAVA_HOME=/usr/local/java/jdk1.8.0_171

case $1 in

         start) sh  $ZK_PATH/bin/zkServer.sh start;;

         stop)  sh  $ZK_PATH/bin/zkServer.sh stop;;

         status) sh  $ZK_PATH/bin/zkServer.sh status;;

         restart) sh $ZK_PATH/bin/zkServer.sh restart;;

         *)  echo &quot;require start|stop|status|restart&quot;  ;;

esac
</code></pre>
<figure data-type="image" tabindex="28"><img src="https://epitomm.github.io/post-images/%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8zk.png" alt="图片" loading="lazy"></figure>
<p>2）-把脚本注册为Service</p>
<figure data-type="image" tabindex="29"><img src="https://epitomm.github.io/post-images/%E8%84%9A%E6%9C%AC%E6%B3%A8%E5%86%8C%E4%B8%BAservice.png" alt="图片" loading="lazy"></figure>
<p>3）-增加权限</p>
<figure data-type="image" tabindex="30"><img src="https://epitomm.github.io/post-images/%E5%A2%9E%E5%8A%A0%E6%9D%83%E9%99%90.png" alt="图片" loading="lazy"></figure>
<p><em>4、配置zookeeper</em></p>
<p>1、初始化zookeeper配置文件</p>
<p>拷贝/usr/local/zookeeper/conf/zoo_sample.cfg</p>
<p>到同一个目录下改个名字叫zoo.cfg</p>
<figure data-type="image" tabindex="31"><img src="https://epitomm.github.io/post-images/%E5%88%9D%E5%A7%8B%E5%8C%96zk%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt="图片" loading="lazy"></figure>
<p>2、启动zookeeper</p>
<figure data-type="image" tabindex="32"><img src="https://epitomm.github.io/post-images/%E5%90%AF%E5%8A%A8zk.png" alt="图片" loading="lazy"></figure>
<h3 id="34-linux-安装dubbo-admin管理控制台">3.4）、【linux】-安装dubbo-admin管理控制台</h3>
<p><em>1、安装Tomcat8（旧版dubbo-admin是war，新版是jar不需要安装Tomcat）</em></p>
<p>1、下载Tomcat8并解压</p>
<p><a href="https://tomcat.apache.org/download-80.cgi">https://tomcat.apache.org/download-80.cgi</a></p>
<p>wget <a href="http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v8.5.32/bin/apache-tomcat-8.5.32.tar.gz">http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v8.5.32/bin/apache-tomcat-8.5.32.tar.gz</a></p>
<p>2、解压移动到指定位置</p>
<figure data-type="image" tabindex="33"><img src="https://epitomm.github.io/post-images/%E8%A7%A3%E5%8E%8Btomcat.png" alt="图片" loading="lazy"></figure>
<p>3、开机启动tomcat8</p>
<figure data-type="image" tabindex="34"><img src="https://epitomm.github.io/post-images/%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8tomcat.png" alt="图片" loading="lazy"></figure>
<p>复制如下脚本</p>
<pre><code>#!/bin/bash

#chkconfig:2345 21 90

#description:apache-tomcat-8

#processname:apache-tomcat-8

CATALANA_HOME=/opt/apache-tomcat-8.5.32

export JAVA_HOME=/opt/java/jdk1.8.0_171

case $1 in

start)

    echo &quot;Starting Tomcat...&quot;  

    $CATALANA_HOME/bin/startup.sh

    ;;

stop)

    echo &quot;Stopping Tomcat...&quot;  

    $CATALANA_HOME/bin/shutdown.sh

    ;;

restart)

    echo &quot;Stopping Tomcat...&quot;  

    $CATALANA_HOME/bin/shutdown.sh

    sleep 2

    echo  

    echo &quot;Starting Tomcat...&quot;  

    $CATALANA_HOME/bin/startup.sh

    ;;

*)

    echo &quot;Usage: tomcat {start|stop|restart}&quot;  

    ;; esac
</code></pre>
<p>4、注册服务&amp;添加权限</p>
<figure data-type="image" tabindex="35"><img src="https://uploader.shimo.im/f/sgrlw1jLRksvtDuA.png!thumbnail" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="36"><img src="https://uploader.shimo.im/f/yFBPAQA9wQcuLiLK.png!thumbnail" alt="图片" loading="lazy"></figure>
<p>5、启动服务&amp;访问tomcat测试</p>
<figure data-type="image" tabindex="37"><img src="https://uploader.shimo.im/f/PCItXvgg0c8lpyxk.png!thumbnail" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="38"><img src="https://uploader.shimo.im/f/UkCJSOTip08WixDn.png!thumbnail" alt="图片" loading="lazy"></figure>
<p><em>2、安装dubbo-admin</em></p>
<p>dubbo本身并不是一个服务软件。它其实就是一个jar包能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。所以你不用在Linux上启动什么dubbo服务。</p>
<p>但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序，不过这个监控即使不装也不影响使用。</p>
<p>1、下载dubbo-admin</p>
<p><a href="https://github.com/apache/incubator-dubbo-ops">https://github.com/apache/incubator-dubbo-ops</a></p>
<figure data-type="image" tabindex="39"><img src="https://uploader.shimo.im/f/NB3VdgOwTJUVLKd7.png!thumbnail" alt="图片" loading="lazy"></figure>
<p>2、进入目录，修改dubbo-admin配置</p>
<p>修改 src\main\resources\application.properties 指定zookeeper地址</p>
<figure data-type="image" tabindex="40"><img src="https://uploader.shimo.im/f/Ky405QqumK4BCVLb.png!thumbnail" alt="图片" loading="lazy"></figure>
<p>3、打包dubbo-admin</p>
<pre><code>mvn clean package -Dmaven.test.skip=true 
</code></pre>
<p>4、运行dubbo-admin</p>
<pre><code>java -jar dubbo-admin-0.0.1-SNAPSHOT.jar
</code></pre>
<p>默认使用root/root 登陆</p>
<figure data-type="image" tabindex="41"><img src="https://uploader.shimo.im/f/QwVB9l4fvmYkh6a2.png!thumbnail" alt="图片" loading="lazy"></figure>
<h2 id="4-dubbo-helloworld">4、dubbo-helloworld</h2>
<h3 id="41-提出需求">4.1）、提出需求</h3>
<p>某个电商系统，订单服务需要调用用户服务获取某个用户的所有地址；</p>
<p>我们现在 需要创建两个服务模块进行测试</p>
<table>
<thead>
<tr>
<th style="text-align:center">模块</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">订单服务web模块</td>
<td style="text-align:center">创建订单等</td>
</tr>
<tr>
<td style="text-align:center">用户服务service模块</td>
<td style="text-align:center">查询用户地址等</td>
</tr>
</tbody>
</table>
<p>测试预期结果：</p>
<p>订单服务web模块在A服务器，用户服务模块在B服务器，A可以远程调用B的功能。</p>
<figure data-type="image" tabindex="42"><img src="https://uploader.shimo.im/f/zu5t5nNfM7A5kcbM.png!thumbnail" alt="图片" loading="lazy"></figure>
<h3 id="42-工程架构">4.2）、工程架构</h3>
<p>根据 dubbo《服务化最佳实践》</p>
<p><em>1、分包</em></p>
<p>建议将服务接口，服务模型，服务异常等均放在 API 包中，因为服务模型及异常也是 API 的一部分，同时，这样做也符合分包原则：重用发布等价原则(REP)，共同重用原则(CRP)。</p>
<p>如果需要，也可以考虑在 API 包中放置一份 spring 的引用配置，这样使用方，只需在 spring 加载过程中引用此配置即可，配置建议放在模块的包目录下，以免冲突，如：com/alibaba/china/xxx/dubbo-reference.xml。</p>
<p><em>2、粒度</em></p>
<p>服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将面临分布式事务问题，Dubbo 暂未提供分布式事务支持。</p>
<p>服务接口建议以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。</p>
<p>不建议使用过于抽象的通用接口，如：Map query(Map)，这样的接口没有明确语义，会给后期维护带来不便。</p>
<figure data-type="image" tabindex="43"><img src="https://uploader.shimo.im/f/JGqDnycGLrAYNogH.png!thumbnail" alt="图片" loading="lazy"></figure>
<h3 id="43-创建模块">4.3）、创建模块</h3>
<p><em>1、gmall-interface：公共接口层（model，service，exception…）</em></p>
<p>作用：定义公共接口，也可以导入公共依赖</p>
<p>1、Bean模型</p>
<pre><code>public class UserAddress implements Serializable{
    private Integer id;
    private String userAddress;
    private String userId;
    private String consignee;
    private String phoneNum;
    private String isDefault;
    // getter、setter、Constructure、toString
}
</code></pre>
<p>2、Service接口<br>
UserService</p>
<pre><code>package com.atguigu.gmall.service;

import com.atguigu.gmall.bean.UserAddress;
import java.util.List;
// 用户服务
public interface UserService {
   /**
    * 按照用户id返回所有的收货地址
    * @param userId
    * @return
    */
   public List&lt;UserAddress&gt; getUserAddressList(String userId);
}
</code></pre>
<p>OrderService</p>
<pre><code>// 订单服务
public interface OrderService {
   /**
    * 初始化订单
    * @param userId
    */
   public void initOrder(String userId);
}
</code></pre>
<figure data-type="image" tabindex="44"><img src="https://uploader.shimo.im/f/wyNzvleAZIggOiT2.png!thumbnail" alt="图片" loading="lazy"></figure>
<p><em>2、gmall-user：用户模块（对用户接口的实现）</em></p>
<p>1、pom.xml</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.atguigu.gmall&lt;/groupId&gt;
        &lt;artifactId&gt;gmall-interface&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>2、Service</p>
<pre><code>public class UserServiceImpl implements UserService {
		
	@Override
	public List&lt;UserAddress&gt; getUserAddressList(String userId) {
		// TODO Auto-generated method stub
		return userAddressDao.getUserAddressById(userId);
	}
}
</code></pre>
<p><em>4、gmall-order-web：订单模块（调用用户模块）</em><br>
1、pom.xml</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.atguigu.gmall&lt;/groupId&gt;
        &lt;artifactId&gt;gmall-interface&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>2、测试</p>
<pre><code>public class OrderService {	
	UserService userService;	
	/**
	 * 初始化订单，查询用户的所有地址并返回
	 * @param userId
	 * @return
	 */
	public List&lt;UserAddress&gt; initOrder(String userId){
		return userService.getUserAddressList(userId);
	}
}
</code></pre>
<p>现在这样是无法进行调用的。我们gmall-order-web引入了gmall-interface，但是interface的实现是gmall-user，我们并没有引入，而且实际他可能还在别的服务器中。</p>
<h3 id="44-使用dubbo改造">4.4）、使用dubbo改造</h3>
<p><em>1、改造gmall-user作为服务提供者</em></p>
<p>1）导入 dubbo 依赖（2.6.2）、导入操作 zookeeper 的客户端（curator）</p>
<pre><code>		&lt;!-- 引入dubbo --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;com.alibaba&lt;/groupId&gt;
			&lt;artifactId&gt;dubbo&lt;/artifactId&gt;
			&lt;version&gt;2.6.2&lt;/version&gt;
		&lt;/dependency&gt;
	&lt;!-- 由于我们使用zookeeper作为注册中心，所以需要操作zookeeper
	dubbo 2.6以前的版本引入zkclient操作zookeeper 
	dubbo 2.6及以后的版本引入curator操作zookeeper
	下面两个zk客户端根据dubbo版本2选1即可
		&lt;dependency&gt;
			&lt;groupId&gt;com.101tec&lt;/groupId&gt;
			&lt;artifactId&gt;zkclient&lt;/artifactId&gt;
			&lt;version&gt;0.10&lt;/version&gt;
		&lt;/dependency&gt;
    --&gt;
		&lt;!-- curator-framework --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
			&lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
			&lt;version&gt;2.12.0&lt;/version&gt;
		&lt;/dependency&gt;
</code></pre>
<p>2）配置提供者</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd        http://dubbo.apache.org/schema/dubbo        http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;&gt;

    &lt;!-- 1.指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名） --&gt;
    &lt;dubbo:application name=&quot;user-service-provider&quot;  /&gt;

    &lt;!-- 2.指定注册中心的位置 --&gt;
    &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; /&gt;

    &lt;!-- 3.指定通信规则（通信协议、通信端口） --&gt;
    &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;

    &lt;!-- 4.暴露服务 ref：指向服务的真正实现对象--&gt;
    &lt;dubbo:service interface=&quot;com.atguigu.gmall.service.UserService&quot; ref=&quot;userServiceImpl&quot; /&gt;

    &lt;!-- 服务的实现  --&gt;
    &lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.atguigu.gmall.service.impl.UserServiceImpl&quot; /&gt;
&lt;/beans&gt;
</code></pre>
<p>3）启动服务</p>
<pre><code>package com.atguigu.gmall;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import java.io.IOException;
public class MainApplication {
    public static void main(String[] args) throws IOException {
        ClassPathXmlApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;provider.xml&quot;);
        ioc.start();
        System.in.read();
    }
}
</code></pre>
<figure data-type="image" tabindex="45"><img src="https://uploader.shimo.im/f/STJJRpsgwTkLRkmY.png!thumbnail" alt="图片" loading="lazy"></figure>
<p>4）测试</p>
<figure data-type="image" tabindex="46"><img src="https://uploader.shimo.im/f/reVohj16x2sHjsEN.png!thumbnail" alt="图片" loading="lazy"></figure>
<p><em>2、改造gmall-order-web作为服务消费者</em></p>
<p>1）引入dubbo</p>
<pre><code>		&lt;!-- 引入dubbo --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;com.alibaba&lt;/groupId&gt;
			&lt;artifactId&gt;dubbo&lt;/artifactId&gt;
			&lt;version&gt;2.6.2&lt;/version&gt;
		&lt;/dependency&gt;
	&lt;!-- 由于我们使用zookeeper作为注册中心，所以需要引入zkclient或curator操作zookeeper --&gt;
		&lt;!-- curator-framework --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
			&lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
			&lt;version&gt;2.12.0&lt;/version&gt;
		&lt;/dependency&gt;
</code></pre>
<p>2）配置消费者信息</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-4.3.xsd
       http://dubbo.apache.org/schema/dubbo
       http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!-- 1.指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名 --&gt;
    &lt;dubbo:application name=&quot;order-service-consumer&quot;  /&gt;

    &lt;!-- 2.注册中心地址 --&gt;
    &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; /&gt;

    &lt;!-- 3.声明需要调用的远程服务的接口 --&gt;
    &lt;dubbo:reference interface=&quot;com.atguigu.gmall.service.UserService&quot; id=&quot;userService&quot; /&gt;
    &lt;!-- 包扫描 --&gt;
    &lt;context:component-scan base-package=&quot;com.atguigu.gmall.service.impl&quot;&gt;&lt;/context:component-scan&gt;
&lt;/beans&gt;
</code></pre>
<p>3）Service 注解</p>
<pre><code>package com.atguigu.gmall.service.impl;

import com.atguigu.gmall.bean.UserAddress;
import com.atguigu.gmall.service.OrderService;
import com.atguigu.gmall.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * 1.让服务提供者注册到注册中心（暴露服务）
 *  1）导入 dubbo 依赖（2.6.2）、导入操作 zookeeper 的客户端（curator）
 *  2）配置服务提供者
 * 2.让消费者去注册中心订阅服务提供者的地址
 */
@Service
public class OrderServiceImpl implements OrderService {
    @Autowired
    UserService userService;
    @Override
    public void initOrder(String userId) {
        // 1. 查询用户收货地址
        List&lt;UserAddress&gt; list = userService.getUserAddressList(userId);
        System.out.println(list);
    }
}
</code></pre>
<p>4）main方法测试</p>
<pre><code>package com.atguigu.gmall;

import com.atguigu.gmall.service.OrderService;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import java.io.IOException;

public class MainApplication {
    public static void main(String[] args) throws IOException {
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;consumer.xml&quot;);
        OrderService orderService = applicationContext.getBean(OrderService.class);
        orderService.initOrder(&quot;1&quot;);
        System.out.println(&quot;调用结束...&quot;);

        System.in.read();
    }
}
</code></pre>
<p><em>3、测试调用</em><br>
访问gmall-order-web的initOrder请求，会调用UserService获取用户地址；</p>
<p>调用成功。说明我们order已经可以调用远程的UserService了；</p>
<p>运行结果：</p>
<pre><code>用户 id ：1
北京市昌平区宏福科技园综合楼3层
深圳市宝安区西部硅谷大厦B座3层（深圳分校）
调用结束...
</code></pre>
<figure data-type="image" tabindex="47"><img src="https://uploader.shimo.im/f/60BuhhwD1HUmxziW.png!thumbnail" alt="图片" loading="lazy"></figure>
<p><em>4、注解版</em></p>
<p>1、服务提供方</p>
<pre><code>&lt;dubbo:application name=&quot;gmall-user&quot;&gt;&lt;/dubbo:application&gt;  
&lt;dubbo:registry address=&quot;zookeeper://118.24.44.169:2181&quot; /&gt;  
&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;
&lt;dubbo:annotation package=*&quot;com.atguigu.gmall.user.impl&quot;/&gt;  

import com.alibaba.dubbo.config.annotation.Service;
import com.atguigu.gmall.bean.UserAddress;  
import com.atguigu.gmall.service.UserService;  
import com.atguigu.gmall.user.mapper.UserAddressMapper;

@Service //使用dubbo提供的service注解，注册暴露服务
public class UserServiceImpl implements UserService {	
     @Autowired		
    UserAddressMapper userAddressMapper; 
</code></pre>
<p>2、服务消费方</p>
<pre><code>&lt;dubbo:application name=&quot;gmall-order-web&quot;&gt;&lt;/dubbo:application&gt;  
&lt;dubbo:registry address=&quot;zookeeper://118.24.44.169:2181&quot; /&gt;  
&lt;dubbo:annotation package=&quot;com.atguigu.gmall.order.controller&quot;/&gt;

@Controller  
public class OrderController {  	  	
    @Reference  //使用dubbo提供的reference注解引用远程服务  	
    UserService userService; 
</code></pre>
<h2 id="5-监控中心">5、监控中心</h2>
<h3 id="51-dubbo-admin">5.1）、dubbo-admin</h3>
<p>图形化的服务管理页面；安装时需要指定注册中心地址，即可从注册中心中获取到所有的提供者/消费者进行配置管理</p>
<h3 id="52-dubbo-monitor-simple">5.2）、dubbo-monitor-simple</h3>
<p>简单的监控中心；</p>
<p><em>1、安装</em></p>
<table>
<thead>
<tr>
<th style="text-align:center">1、下载 dubbo-ops  <a href="https://github.com/apache/incubator-dubbo-ops">https://github.com/apache/incubator-dubbo-ops</a></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2、修改配置指定注册中心地址进入 dubbo-monitor-simple\src\main\resources\conf修改 dubbo.properties文件</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="48"><img src="https://uploader.shimo.im/f/hiBXL60A0HIHytCX.png!thumbnail" alt="图片" loading="lazy"></figure>
<table>
<thead>
<tr>
<th style="text-align:left">3、打包dubbo-monitor-simplemvn clean package -Dmaven.test.skip=true</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">4、解压 tar.gz 文件，并运行start.bat</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="49"><img src="https://uploader.shimo.im/f/3VuJjpqB1NQs3dTZ.png!thumbnail" alt="图片" loading="lazy"></figure>
<table>
<thead>
<tr>
<th style="text-align:left">如果缺少servlet-api，自行导入servlet-api再访问监控中心</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">5、启动访问8080</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="50"><img src="https://uploader.shimo.im/f/8yKt4JScy58YqdVP.png!thumbnail" alt="图片" loading="lazy"></figure>
<p><em>2、监控中心配置</em></p>
<table>
<thead>
<tr>
<th>所有服务配置连接监控中心，进行监控统计    <!-- 监控中心协议，如果为protocol="registry"，表示从注册中心发现监控中心地址，否则直连监控中心 -->  	<a href="dubbo:monitor%C2%A0protocol=%22registry%22">dubbo:monitor protocol=&quot;registry&quot;</a>&lt;/dubbo:monitor&gt;</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Simple Monitor 挂掉不会影响到 Consumer 和 Provider 之间的调用，所以用于生产环境不会有风险。</p>
<p>Simple Monitor 采用磁盘存储统计信息，请注意安装机器的磁盘限制，如果要集群，建议用mount共享磁盘。</p>
<h2 id="6-整合springboot">6、整合SpringBoot</h2>
<p>1）引入<strong>spring-boot-starter以及dubbo和curator的依赖</strong></p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt;
    &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;0.2.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>注意starter版本适配：<br>
<img src="https://uploader.shimo.im/f/d2JLjRxIZZsumBaC.png!thumbnail" alt="图片" loading="lazy"></p>
<p>2）配置application.properties</p>
<p><em>提供者配置：</em></p>
<pre><code>dubbo.application.name=gmall-user
dubbo.registry.protocol=zookeeper
dubbo.registry.address=192.168.67.159:2181
dubbo.scan.base-package=com.atguigu.gmall
dubbo.protocol.name=dubbo
dubbo.protocol.port=20880
dubbo.monitor.protocol=registry
## application.name就是服务名，不能跟别的dubbo提供端重复
## registry.protocol  是指定注册中心协议
## registry.address 是注册中心的地址加端口号
## protocol.name 是分布式固定是dubbo,不要改。
## base-package  注解方式要扫描的包
</code></pre>
<p><em>消费者配置：</em></p>
<pre><code>server.port=8081

dubbo.application.name=gmall-order-web
dubbo.registry.protocol=zookeeper
dubbo.registry.address=192.168.67.159:2181
dubbo.scan.base-package=com.atguigu.gmall
dubbo.protocol.name=dubbo
dubbo.monitor.protocol=registry
</code></pre>
<p>3、dubbo注解<br>
@Service、@Reference</p>
<p><strong>【如果没有在配置中写dubbo.scan.base-package,还需要在启动类使用@EnableDubbo注解】</strong></p>
<p>消费者：</p>
<pre><code>@Reference
UserService userService;
</code></pre>
<p>服务提供者：</p>
<pre><code>@com.alibaba.dubbo.config.annotation.Service // 暴露服务
@Service
public class UserServiceImpl implements UserService {
</code></pre>
<h1 id="二-dubbo配置">二、dubbo配置</h1>
<h2 id="1-配置原则">1、配置原则</h2>
<figure data-type="image" tabindex="51"><img src="https://uploader.shimo.im/f/B1hW7n2x1bYU1d7w.png!thumbnail" alt="图片" loading="lazy"></figure>
<p>JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。</p>
<p>XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。</p>
<p>Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。</p>
<h2 id="2-重试次数">2、重试次数</h2>
<p>失败自动切换，当出现失败，重试其它服务器，但重试会带来更长延迟。可通过 retries=&quot;2&quot; 来设置重试次数(不含第一次)。</p>
<p>重试次数配置如下：</p>
<pre><code>&lt;dubbo:service retries=&quot;2&quot; /&gt;
</code></pre>
<p>或</p>
<pre><code>&lt;dubbo:reference retries=&quot;2&quot; /&gt;
</code></pre>
<p>或</p>
<pre><code>&lt;dubbo:reference&gt;
    &lt;dubbo:method name=&quot;findFoo&quot; retries=&quot;2&quot; /&gt;
&lt;/dubbo:reference&gt;
</code></pre>
<blockquote>
<p>幂等操作（执行多次和执行一次效果相同：查询、删除、修改）可设置重试次数，非幂等操作（执行多次和执行一次效果不同：新增）不宜设置重试次数</p>
</blockquote>
<h2 id="3-超时时间">3、超时时间</h2>
<p>由于网络或服务端不可靠，会导致调用出现一种不确定的中间状态（超时）。为了避免超时导致客户端资源（线程）挂起耗尽，必须设置超时时间。</p>
<blockquote>
<p>服务消费方引用服务提供方时，可能有雨网络等原因，服务提供方要执行一个方法可能有很长时间，如果很长时间都没有返回，导致大量线程阻塞，可能会引起性能下降，为了解决这个问题，可以指定超时时间，只要这个方法在指定时间内没有返回，就立即终止，不让大量线程阻塞。设置单位 ms</p>
</blockquote>
<h3 id="1-dubbo消费端">1、Dubbo消费端</h3>
<p>全局超时配置</p>
<pre><code>&lt;dubbo:consumer timeout=&quot;5000&quot; /&gt;
</code></pre>
<p>指定接口以及特定方法超时配置</p>
<pre><code>&lt;dubbo:reference interface=&quot;com.foo.BarService&quot; timeout=&quot;2000&quot;&gt;
    &lt;dubbo:method name=&quot;sayHello&quot; timeout=&quot;3000&quot; /&gt;
&lt;/dubbo:reference&gt;
</code></pre>
<h3 id="2-dubbo服务端">2、Dubbo服务端</h3>
<p>全局超时配置</p>
<pre><code>&lt;dubbo:provider timeout=&quot;5000&quot; /&gt;
</code></pre>
<p>指定接口以及特定方法超时配置</p>
<pre><code>&lt;dubbo:provider interface=&quot;com.foo.BarService&quot; timeout=&quot;2000&quot;&gt;
    &lt;dubbo:method name=&quot;sayHello&quot; timeout=&quot;3000&quot; /&gt;
&lt;/dubbo:provider&gt;
</code></pre>
<h3 id="3-配置原则">3、配置原则</h3>
<p>dubbo推荐在Provider上尽量多配置Consumer端属性：</p>
<p>1、作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等</p>
<p>2、在Provider配置后，Consumer不配置则会使用Provider的配置值，即Provider配置可以作为Consumer的缺省值。否则，Consumer会使用Consumer端的全局设置，这对于Provider不可控的，并且往往是不合理的</p>
<p>配置的覆盖规则：</p>
<ol>
<li>
<p>方法级别配置优于接口级别，即小Scope优先</p>
</li>
<li>
<p>Consumer端配置 优于 Provider配置 优于 全局配置，</p>
</li>
</ol>
<p>3) 最后是Dubbo Hard Code的配置值（见配置文档）</p>
<figure data-type="image" tabindex="52"><img src="https://uploader.shimo.im/f/5xoy9sunaRc44qdE.png!thumbnail" alt="图片" loading="lazy"></figure>
<h2 id="4-版本号">4、版本号</h2>
<p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。</p>
<p>可以按照以下的步骤进行版本迁移：</p>
<p>在低压力时间段，先升级一半提供者为新版本</p>
<p>再将所有消费者升级为新版本</p>
<p>然后将剩下的一半提供者升级为新版本</p>
<p>老版本服务提供者配置：</p>
<pre><code>&lt;dubbo:service interface=&quot;com.foo.BarService&quot; version=&quot;1.0.0&quot; /&gt;
</code></pre>
<p>新版本服务提供者配置：</p>
<pre><code>&lt;dubbo:service interface=&quot;com.foo.BarService&quot; version=&quot;2.0.0&quot; /&gt;
</code></pre>
<p>老版本服务消费者配置：</p>
<pre><code>&lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;1.0.0&quot; /&gt;
</code></pre>
<p>新版本服务消费者配置：</p>
<pre><code>&lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;2.0.0&quot; /&gt;
</code></pre>
<p>如果不需要区分版本，可以按照以下的方式配置：</p>
<pre><code>&lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;*&quot; /&gt;
</code></pre>
<h2 id="5-启动时检查">5、启动时检查</h2>
<p>Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 check=&quot;true&quot;。</p>
<p>可以通过 check=&quot;false&quot; 关闭检查，比如，测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。</p>
<p>另外，如果你的 Spring 容器是懒加载的，或者通过 API 编程延迟引用服务，请关闭 check，否则服务临时不可用时，会抛出异常，拿到 null 引用，如果 check=&quot;false&quot;，总是会返回引用，当服务恢复时，能自动连上。</p>
<h3 id="示例">示例</h3>
<p><strong>通过 spring 配置文件</strong></p>
<p>关闭某个服务的启动时检查 (没有提供者时报错)：如果启动时没有提供者可以成功启动，但调用时因没有提供者调用失败会抛出异常</p>
<pre><code>&lt;dubbo:reference interface=&quot;com.foo.BarService&quot; check=&quot;false&quot; /&gt;
</code></pre>
<p>配置当前消费者的统一规则，所有的服务启动时都不检查：</p>
<pre><code>&lt;dubbo:consumer check=&quot;false&quot; /&gt;
</code></pre>
<p>关闭注册中心启动时检查 (注册订阅失败时报错)：</p>
<pre><code>&lt;dubbo:registry check=&quot;false&quot; /&gt;
</code></pre>
<p><strong>通过 dubbo.properties</strong></p>
<pre><code>dubbo.reference.com.foo.BarService.check=false
dubbo.reference.check=false
dubbo.consumer.check=false
dubbo.registry.check=false
</code></pre>
<h2 id="6-多版本">6、多版本</h2>
<p><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/multi-versions.html">http://dubbo.apache.org/zh-cn/docs/user/demos/multi-versions.html</a></p>
<blockquote>
<p>使用场景：某一个接口功能出现了不兼容的升级，先让一部分人使用新功能，另外一部分人还是先用旧版本，如果新功能版本都稳定了，再把所有老版本替换成新版本。</p>
</blockquote>
<p>服务提供方提供新旧两个版本供消费者使用</p>
<pre><code>&lt;!-- 4.暴露服务 ref：指向服务的真正实现对象--&gt;
&lt;dubbo:service interface=&quot;com.atguigu.gmall.service.UserService&quot; ref=&quot;userServiceImpl01&quot; version=&quot;1.0.0&quot;/&gt;
&lt;!-- 服务的实现  --&gt;
&lt;bean id=&quot;userServiceImpl01&quot; class=&quot;com.atguigu.gmall.service.impl.UserServiceImpl&quot; /&gt;
&lt;!-- 连接监控中心 --&gt;
&lt;dubbo:monitor protocol=&quot;registry&quot;&gt;&lt;/dubbo:monitor&gt;
&lt;!-- 检测多版本 --&gt;
&lt;dubbo:service interface=&quot;com.atguigu.gmall.service.UserService&quot; ref=&quot;userServiceImpl02&quot; version=&quot;2.0.0&quot;/&gt;
&lt;bean id=&quot;userServiceImpl02&quot; class=&quot;com.atguigu.gmall.service.impl.UserServiceImpl2&quot; /&gt;
</code></pre>
<p>服务消费方可选择哪一个版本</p>
<pre><code>&lt;!-- 3.声明需要调用的远程服务的接口 --&gt;
&lt;dubbo:reference interface=&quot;com.atguigu.gmall.service.UserService&quot; id=&quot;userService&quot; check=&quot;false&quot; version=&quot;2.0.0&quot;/&gt;
</code></pre>
<blockquote>
<p>由此实现灰度发布。</p>
</blockquote>
<h2 id="7-本地存根">7、本地存根</h2>
<p><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html">http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html</a></p>
<p>远程服务后，客户端通常只剩下接口，而实现全在服务器端，但提供方有些时候想在客户端也执行部分逻辑，比如：做 ThreadLocal 缓存，提前验证参数，调用失败后伪造容错数据等等，此时就需要在 API 中带上 Stub，客户端生成 Proxy 实例，会把 Proxy 通过构造函数传给 Stub <a href="http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html#fn1">[1]</a>，然后把 Stub 暴露给用户，Stub 可以决定要不要去调 Proxy。</p>
<figure data-type="image" tabindex="53"><img src="https://uploader.shimo.im/f/fCMOKYxIU74ZSiof.png!thumbnail" alt="图片" loading="lazy"></figure>
<p>在 spring 配置文件中按以下方式配置：</p>
<pre><code>&lt;dubbo:service interface=&quot;com.foo.BarService&quot; stub=&quot;true&quot; /&gt;
</code></pre>
<p>或</p>
<pre><code>&lt;dubbo:service interface=&quot;com.foo.BarService&quot; stub=&quot;com.foo.BarServiceStub&quot; /&gt;
</code></pre>
<p>提供 Stub 的实现 <a href="http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html#fn2">[2]</a>：</p>
<pre><code>package com.foo;
public class BarServiceStub implements BarService {
    private final BarService barService;
    
    // 构造函数传入真正的远程代理对象
    public BarServiceStub(BarService barService){
        this.barService = barService;
    }
 
    public String sayHello(String name) {
        // 此代码在客户端执行, 你可以在客户端做ThreadLocal本地缓存，或预先验证参数是否合法，等等
        try {
            return barService.sayHello(name);
        } catch (Exception e) {
            // 你可以容错，可以做任何AOP拦截事项
            return &quot;容错数据&quot;;
        }
    }
}
</code></pre>
<p>Stub 必须有可传入 Proxy 的构造函数。 <a href="http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html#fnref1">↩︎</a></p>
<ol>
<li>在 interface 旁边放一个 Stub 实现，它实现 BarService 接口，并有一个传入远程 BarService 实例的构造函数 <a href="http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html#fnref2">↩︎</a></li>
</ol>
<h2 id="8-springboot-与-dubbo-整合的三种方式">8、Springboot 与 dubbo 整合的三种方式</h2>
<p><strong>（1） application.properties</strong></p>
<p>导入 dubb-starter，在 application.properties 中配置属性，使用 @Service 暴露服务；使用 @Reference 引用服务</p>
<p>（注意 @EnableDubbo 开启基于注解的 dubbo 或在 properties 文件中包扫描）</p>
<p><strong>（2）保留 dubbo xml配置文件</strong></p>
<p>导入 dubb-starter，使用 @ImportResource 导入配置文件即可（不再使用 @EnableDubbo 注解，转而使用 @ImportResource(locations=&quot;classpath:provider.xml&quot;)</p>
<p>暴露 Service 也不再使用 @Service 了，因为 xml 中已经设置了暴露服务）</p>
<p><strong>（3）使用注解 API 方式</strong></p>
<p>将每一个组件手动创建到容器中，让 dubbo 来扫描其他的组件</p>
<pre><code>  @EnableDubbo(scanBasePackages=&quot;com.atguigu.gmall&quot;)
</code></pre>
<pre><code>package com.atguigu.gmall.config;

import com.alibaba.dubbo.config.*;
import com.atguigu.gmall.service.UserService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.ArrayList;
import java.util.List;

@Configuration
public class MyDubboConfig {

//        &lt;dubbo:application name=&quot;boot-user-service-provider&quot;  /&gt;
    @Bean
    public ApplicationConfig applicationConfig(){
        ApplicationConfig config = new ApplicationConfig();
        config.setName(&quot;boot-user-service-provider&quot;);
        return config;
    }

    // &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; /&gt;
    @Bean
    public RegistryConfig registryConfig(){
        System.out.println(&quot;--------&quot;);
        RegistryConfig registryConfig = new RegistryConfig();
        registryConfig.setProtocol(&quot;zookeeper&quot;);
        registryConfig.setAddress(&quot;127.0.0.1:2181&quot;);
        return registryConfig;
    }

    //&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20882&quot; /&gt;
    @Bean
    public ProtocolConfig protocolConfig(){
        ProtocolConfig config = new ProtocolConfig();
        config.setName(&quot;dubbo&quot;);
        config.setPort(20882);
        return config;
    }

    //    &lt;dubbo:service interface=&quot;com.atguigu.gmall.service.UserService&quot; ref=&quot;userServiceImpl01&quot;&gt;
    //        &lt;dubbo:method name=&quot;getUserAddressList&quot; timeout=&quot;1000&quot;&gt;&lt;/dubbo:method&gt;
    //    &lt;/dubbo:service&gt;
    @Bean
    public ServiceConfig&lt;UserService&gt; serviceConfig(UserService userService){
        ServiceConfig&lt;UserService&gt; config = new ServiceConfig&lt;&gt;();
        config.setInterface(UserService.class);
        config.setRef(userService);

        // 配置每一个 method 信息
        MethodConfig methodConfig = new MethodConfig();
        methodConfig.setName(&quot;getUserAddressList&quot;);
        methodConfig.setTimeout(1000);

        // 将 method 的设置关联到 servie 中
        List&lt;MethodConfig&gt; methods = new ArrayList&lt;&gt;();
        methods.add(methodConfig);
        config.setMethods(methods);

        return config;
    }

}
</code></pre>
<h1 id="三-高可用">三、高可用</h1>
<h2 id="1-zookeeper宕机与dubbo直连">1、zookeeper宕机与dubbo直连</h2>
<p>现象：zookeeper注册中心（zkServer.cmd）宕机，还可以消费dubbo暴露的服务。</p>
<p>原因：</p>
<p>健壮性</p>
<ul>
<li>监控中心宕掉不影响使用，只是丢失部分采样数据</li>
<li>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</li>
<li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li>
<li><strong>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</strong></li>
<li>服务提供者无状态，任意一台宕掉后，不影响使用</li>
<li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</li>
</ul>
<p><strong>高可用：通过设计，减少系统不能提供服务的时间；</strong></p>
<p><strong>dubbo 直连（绕过注册中心）</strong></p>
<pre><code>@Reference(url = &quot;127.0.0.1:20882&quot;)
UserService userService;
</code></pre>
<h2 id="2-集群下dubbo负载均衡配置">2、集群下dubbo负载均衡配置</h2>
<p><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/loadbalance.html">http://dubbo.apache.org/zh-cn/docs/user/demos/loadbalance.html</a></p>
<p>在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。</p>
<h3 id="负载均衡策略">负载均衡策略</h3>
<p><strong>Random LoadBalance</strong></p>
<p>随机，按权重设置随机概率。</p>
<p>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</p>
<figure data-type="image" tabindex="54"><img src="https://uploader.shimo.im/f/t9CCH4EHEeoW2iry.png!thumbnail" alt="图片" loading="lazy"></figure>
<blockquote>
<p>基于权重的随机负载均衡机制：orderService 想要调用 userService，userService 分别在 1、2、3 台机器内，分别为每一台机器的服务设置权重为 100、200、50，总权重 350，那么对于 1 号机器来说，它的概率就是 100/350 = 2/7，在负载均衡的情况下，大量请求过来，大约有 2/7 的请求会来到 1 号机器。第一次请求来调用的是 1 号机器，第二次来有可能还调用 1 号机器，但总体上，按照大量请求概率分布来看，1 号机器会占 2/7 的概率。</p>
</blockquote>
<p><strong>RoundRobin LoadBalance</strong></p>
<p>轮循，按公约后的权重设置轮循比率。</p>
<p>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</p>
<figure data-type="image" tabindex="55"><img src="https://uploader.shimo.im/f/fnw0VbVMqhIoKq6S.png!thumbnail" alt="图片" loading="lazy"></figure>
<blockquote>
<p>轮询负载均衡机制：orderService 想要调用 userService，第一个请求过来先用 1 号 userService 服务，第二个请求过来使用 2 号 userService 服务，下一个请求过来使用 3 号userService 服务，再下一次 1 号，再下一次 2 号...... 依次轮询。<br>
基于权重的轮询负载均衡机制：为每个服务设置权重，3 台服务器的权重分别为 2/7、4/7、1/7，按照轮询机制，第一个请求到来使用 1 号服务器，第二个请求使用 2 号服务器，第三个请求使用 3 号服务器，第四个请求使用 1 号服务器，第五个请求使用 2 号服务器，第六个请求本应使用 3 号服务器，<strong>但是</strong>，由于 3 号服务器的权重是 1/7（如果有 7 个请求，则 7 个之中的 1 个使用 3 号服务器），已经有第三个请求使用了 3 号服务器，第一个、第四个请求已经使用了 两次 1 号服务器，所以第六个请求只能使用 2 号服务器，同理，第七个请求也使用 2 号服务器。<br>
<strong>LeastActive LoadBalance</strong></p>
</blockquote>
<p>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</p>
<p>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</p>
<figure data-type="image" tabindex="56"><img src="https://uploader.shimo.im/f/S8G9zCwCrP81SVr3.png!thumbnail" alt="图片" loading="lazy"></figure>
<blockquote>
<p>最少活跃数：orderService 要调用 userService，在确定要使用几号 userService前，根据 “每一个服务器统计的上一次的调用时间”：三台服务器上一次请求的处理时间分别为 100ms、1000ms、300ms，说明 1 号服务器处理最快，于是此次请求会来到 1 号服务器。</p>
</blockquote>
<p><strong>ConsistentHash LoadBalance</strong></p>
<p>一致性 Hash，相同参数的请求总是发到同一提供者。</p>
<p>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：<a href="http://en.wikipedia.org/wiki/Consistent_hashing">http://en.wikipedia.org/wiki/Consistent_hashing</a></p>
<p>缺省只对第一个参数 Hash，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</p>
<p>缺省用 160 份虚拟节点，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</p>
<figure data-type="image" tabindex="57"><img src="https://uploader.shimo.im/f/TKBZTSuulaQxa01m.png!thumbnail" alt="图片" loading="lazy"></figure>
<blockquote>
<p>一致性 hash：orderService 想要调用 userService，都是调用的同一个 getUser 方法，将参数 hash 后的不同值分不到不同的服务器上。</p>
</blockquote>
<h3 id="负载均衡配置">负载均衡配置</h3>
<p>服务端服务级别，暴露服务时</p>
<pre><code>&lt;dubbo:service interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;
</code></pre>
<p>客户端服务级别，消费时</p>
<pre><code>&lt;dubbo:reference interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;
</code></pre>
<p>服务端方法级别</p>
<pre><code>&lt;dubbo:service interface=&quot;...&quot;&gt;
    &lt;dubbo:method name=&quot;...&quot; loadbalance=&quot;roundrobin&quot;/&gt;
&lt;/dubbo:service&gt;
</code></pre>
<p>客户端方法级别</p>
<pre><code>&lt;dubbo:reference interface=&quot;...&quot;&gt;
    &lt;dubbo:method name=&quot;...&quot; loadbalance=&quot;roundrobin&quot;/&gt;
&lt;/dubbo:reference&gt;
</code></pre>
<h2 id="3-整合hystrix服务熔断与降级处理">3、整合hystrix，服务熔断与降级处理</h2>
<h3 id="1-服务降级">1、服务降级</h3>
<p><strong>什么是服务降级？</strong></p>
<p><strong>当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。</strong></p>
<p>可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。</p>
<p>向注册中心写入动态配置覆盖规则：</p>
<pre><code>RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();
Registry registry = registryFactory.getRegistry(URL.valueOf(&quot;zookeeper://10.20.153.10:2181&quot;));
registry.register(URL.valueOf(&quot;override://0.0.0.0/com.foo.BarService?category=configurators&amp;dynamic=false&amp;application=foo&amp;mock=force:return+null&quot;));
</code></pre>
<p>其中：</p>
<ul>
<li>mock=force:return+null 表示消费方对该服务的方法调用都<strong>直接返回 null 值，不发起远程调用</strong>。用来屏蔽不重要服务不可用时对调用方的影响。</li>
<li>还可以改为 mock=fail:return+null 表示消费方对该服务的方法<strong>调用在失败后，再返回 null 值</strong>，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。</li>
</ul>
<h3 id="2-集群容错">2、集群容错</h3>
<p>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p>
<p><strong>集群容错模式</strong></p>
<p><strong>Failover Cluster</strong></p>
<p>失败自动切换，当<strong>出现失败，重试其它服务器</strong>。通常用于读操作，但重试会带来更长延迟。可通过 retries=&quot;2&quot; 来设置重试次数(不含第一次)。</p>
<blockquote>
<p>A 服务调用 B 服务，B 服务超时后，配置一个重试次数，可以重新切换到能提供 B服务的其他机器。</p>
</blockquote>
<p>重试次数配置如下：</p>
<pre><code>&lt;dubbo:service retries=&quot;2&quot; /&gt;
</code></pre>
<p>或</p>
<pre><code>&lt;dubbo:reference retries=&quot;2&quot; /&gt;
</code></pre>
<p>或</p>
<pre><code>&lt;dubbo:reference&gt;
    &lt;dubbo:method name=&quot;findFoo&quot; retries=&quot;2&quot; /&gt;
&lt;/dubbo:reference&gt;
</code></pre>
<p><strong>Failfast Cluster</strong></p>
<p>快速失败，只发起一次调用，<strong>失败立即报错</strong>。通常用于非幂等性的写操作，比如新增记录。</p>
<blockquote>
<p>A 服务调用 B服务，只发起一次调用，失败立即报错。</p>
</blockquote>
<p><strong>Failsafe Cluster</strong></p>
<p>失败安全，出现异常时，直接<strong>忽略</strong>。通常用于写入审计日志等操作。</p>
<p><strong>Failback Cluster</strong></p>
<p><strong>失败自动恢复，后台记录失败请求，定时重发</strong>。通常用于消息通知操作。</p>
<blockquote>
<p>A 服务调用 B 服务，失败后可以后台记录一下，隔一段时间定时再调用一次。适用于：一定要成功的服务调用</p>
</blockquote>
<p><strong>Forking Cluster</strong></p>
<p>并行调用多个服务器，只要一个成功即返回。通常用于<strong>实时性要求较高</strong>的读操作，但需要浪费更多服务资源。可通过 forks=&quot;2&quot; 来设置最大并行数。</p>
<blockquote>
<p>A 服务调用 B服务，有可能会失败，能提供 B 服务的在三台服务器上，同时给这三台服务器都发起请求，只要其中一个服务器响应成功就可以使用。</p>
</blockquote>
<p><strong>Broadcast Cluster</strong></p>
<p>广播调用所有提供者，逐个调用，任意一台报错则报错 [2]。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p>
<blockquote>
<p>A 服务调用 B服务，B 服务的提供者有四台机器，每一台机器都调用一遍，只要有任意一台出现错误，都认为这次调用是失败的。</p>
</blockquote>
<p><strong>集群模式配置</strong></p>
<p>按照以下示例在服务提供方和消费方配置集群模式</p>
<pre><code>&lt;dubbo:service cluster=&quot;failsafe&quot; /&gt;
</code></pre>
<p>或</p>
<pre><code>&lt;dubbo:reference cluster=&quot;failsafe&quot; /&gt;
</code></pre>
<h3 id="3-整合hystrix">3、整合hystrix</h3>
<p>Hystrix 旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能</p>
<p><em>1、配置spring-cloud-starter-netflix-hystrix</em></p>
<p>spring boot官方提供了对hystrix的集成，直接在pom.xml里加入依赖：</p>
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
  &lt;version&gt;1.4.4.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>然后在Application类上增加@EnableHystrix来启用hystrix starter：</p>
<pre><code>@SpringBootApplication
@EnableHystrix
public class ProviderApplication {
</code></pre>
<p><em>2、配置Provider端</em></p>
<p>在Dubbo的Provider上增加@HystrixCommand配置，这样子调用就会经过Hystrix代理。</p>
<pre><code>@Service(version = &quot;1.0.0&quot;)
public class HelloServiceImpl implements HelloService {
    @HystrixCommand(commandProperties = {
     @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;10&quot;),
     @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;2000&quot;) })
    @Override
    public String sayHello(String name) {
        // System.out.println(&quot;async provider received: &quot; + name);
        // return &quot;annotation: hello, &quot; + name;
        throw new RuntimeException(&quot;Exception to show hystrix enabled.&quot;);
    }
}
</code></pre>
<p><em>3、配置Consumer端</em></p>
<p>对于Consumer端，则可以增加一层method调用，并在method上配置@HystrixCommand。当调用出错时，会走到fallbackMethod = &quot;reliable&quot;的调用里。</p>
<pre><code>    @Reference(version = &quot;1.0.0&quot;)
    private HelloService demoService;
    @HystrixCommand(fallbackMethod = &quot;reliable&quot;)
    public String doSayHello(String name) {
        return demoService.sayHello(name);
    }
    public String reliable(String name) {
        return &quot;hystrix fallback value&quot;;
    }
</code></pre>
<h1 id="四-dubbo原理">四、dubbo原理</h1>
<h2 id="1-rpc原理">1、RPC原理</h2>
<figure data-type="image" tabindex="58"><img src="https://uploader.shimo.im/f/VT5w26Fy18AWw61q.png!thumbnail" alt="图片" loading="lazy"></figure>
<p>一次完整的RPC调用流程（同步调用，异步另说）如下：</p>
<p>**1）服务消费方（client）调用以本地调用方式调用服务； **</p>
<p>2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</p>
<p>3）client stub找到服务地址，并将消息发送到服务端；</p>
<p>4）server stub收到消息后进行解码；</p>
<p>5）server stub根据解码结果调用本地的服务；</p>
<p>6）本地服务执行并将结果返回给server stub；</p>
<p>7）server stub将返回结果打包成消息并发送至消费方；</p>
<p>8）client stub接收到消息，并进行解码；</p>
<p><strong>9）服务消费方得到最终结果。</strong></p>
<p>RPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明的，不可见的。</p>
<h2 id="2-netty通信原理">2、netty通信原理</h2>
<p>Netty是一个异步事件驱动的网络应用程序框架， 用于快速开发可维护的高性能协议服务器和客户端。它极大地简化并简化了TCP和UDP套接字服务器等网络编程。</p>
<p>BIO：(Blocking IO)</p>
<figure data-type="image" tabindex="59"><img src="https://uploader.shimo.im/f/2W5W02pWhRc1tfWH.png!thumbnail" alt="图片" loading="lazy"></figure>
<blockquote>
<p>BIO：阻塞式 IO。每一个请求进来，开一个 Socket 开一个线程来处理数据，读取到数据后业务逻辑操作完成后返回。服务器收到很多请求，同时操作，在这个业务逻辑完成前这个线程不能得到释放，服务器就不能同时处理大量请求，因为有大量线程在阻塞，等待业务逻辑的完成。</p>
</blockquote>
<p>NIO (Non-Blocking IO)</p>
<figure data-type="image" tabindex="60"><img src="https://uploader.shimo.im/f/i2Hhf1AEfLE0e9rK.png!thumbnail" alt="图片" loading="lazy"></figure>
<blockquote>
<p>Channel：通道，通道里面有 Buffer 用来进行数据传输。<br>
一个 Selector 注册进了很多通道，每个请求使用通道进行数据传递通信，Selector 通过监听多个通道，当发现某一个通道里的数据准备好了，Selector 执行相应操作。</p>
</blockquote>
<p>Selector 一般称 为<strong>选择器</strong> ，也可以翻译为 <strong>多路复用器，</strong></p>
<p>Connect（连接就绪）、Accept（接受就绪）、Read（读就绪）、Write（写就绪）</p>
<p>Netty基本原理：</p>
<figure data-type="image" tabindex="61"><img src="https://uploader.shimo.im/f/M16PnkZ6fGY7YG8J.png!thumbnail" alt="图片" loading="lazy"></figure>
<blockquote>
<p>Netty 服务器启动（ServerBootstrap.bind），绑定监听某一个端口，比如 dubbo 的20880端口，这样所有给这个端口发的数据 netty 就能收到，启动后初始化服务器的通道（NioServerSockerChannel），注册到 selector，selector 负责监听 accept 事件（当通道接收准备就绪后，处理通道里的信息），netty 与客户端建立连接， 生成 NioSocketChannel，把这个  通道注册到 Selector 里面，这个 selector 监听 read、write 事件（通道中数据读、写准备就绪），读写准备就绪后来处理这个事件，抛给用户队列，netty 把这个任务队列执行完</p>
</blockquote>
<h2 id="3-dubbo原理">3、dubbo原理</h2>
<h3 id="1-dubbo原理-框架设计">1、dubbo原理	-框架设计</h3>
<figure data-type="image" tabindex="62"><img src="https://uploader.shimo.im/f/mktdQ0QVP0s1eieu.png!thumbnail" alt="图片" loading="lazy"></figure>
<blockquote>
<p>dubbo 框架整体分层：</p>
<ol>
<li>Business 业务逻辑层：<br>
1.1 Service服务层：面向接口编程。接口、实现。想要远程调用只需要调用接口的方法，就自动调实现了。 对于用户编程，只需要关心这一层就结束了。<br>
2.RPC层：完成远程过程调用：<br>
2.1 Config 配置层，封装配置文件里解析出来的信息 ReferenceConfig、ServiceConfig；<br>
2.2 Proxy 服务代理层：利用代理的方式，生成客户端代理对象、服务端代理对象，代理对象互相调用方法；<br>
2.2 Registry 注册中心层：完成服务的发现和注册；很多服务要注册到注册中心，消费者要从注册中心订阅所需要的服务来调用；<br>
2.3 Cluster 路由层：负载均衡。invoker 调用者要调用很多的服务，服务在很多机器上跑，需要负载均衡；<br>
2.4 Monitor 监控层：每一次的调用信息都会向监控层发送一些数据；<br>
2.5 Protocol 远程调用层：封装 RPC 调用，RPC 调用核心的三个：Invoker、Protocol、Exporter；</li>
<li>Remoting 层：远程要调用就要跟 A、B两个服务器架起通信管道，通信以及在通信间传递数据<br>
3.1 Exchange 信息交换层：创建一个客户端 ExchangeClient、服务端 ExchangeServer<br>
两端架起网架进行数据的互联互通；<br>
3.2 Transport 传输层：真正传输数据用 Transporter 来封装传输的，Transporter 底层就是 netty 框架，netty 框架就是在这一层封装；<br>
3.3 Serialize 序列化层：序列化</li>
</ol>
</blockquote>
<ul>
<li>config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li>
<li>proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory</li>
<li>registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService</li>
<li>cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance</li>
<li>monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService</li>
<li>protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter</li>
<li>exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer</li>
<li>transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec</li>
<li>serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool</li>
</ul>
<h3 id="2-dubbo原理-启动解析-加载配置信息">2、dubbo原理	-启动解析、加载配置信息</h3>
<figure data-type="image" tabindex="63"><img src="https://uploader.shimo.im/f/iFVXso8DLkEuO0r6.png!thumbnail" alt="图片" loading="lazy"></figure>
<h3 id="3-dubbo原理-服务暴露">3、dubbo原理	-服务暴露</h3>
<figure data-type="image" tabindex="64"><img src="https://uploader.shimo.im/f/2ocFX7K06DopwxGs.png!thumbnail" alt="图片" loading="lazy"></figure>
<h3 id="4-dubbo原理-服务引用">4、dubbo原理	-服务引用</h3>
<figure data-type="image" tabindex="65"><img src="https://uploader.shimo.im/f/DxTlKd889QMR0jp1.png!thumbnail" alt="图片" loading="lazy"></figure>
<h3 id="5-dubbo原理-服务调用">5、dubbo原理	-服务调用</h3>
<figure data-type="image" tabindex="66"><img src="https://uploader.shimo.im/f/rugf4MklrfIiNoOW.png!thumbnail" alt="图片" loading="lazy"></figure>

            </div>
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      SSM
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://epitomm.github.io/post/dubbo/" title="dubbo">https://epitomm.github.io/post/dubbo/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://epitomm.github.io/tag/AivfZDvn2/"># dubbo</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="Redis 哨兵" href="https://epitomm.github.io/post/redis-shao-bing/">Redis 哨兵</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="Redis 哨兵" href="https://epitomm.github.io/post/redis-shao-bing/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="记一个面试题 —— 实现一个读写锁" href="https://epitomm.github.io/post/ji-yi-ge-mian-shi-ti-shi-xian-yi-ge-du-xie-suo/">记一个面试题 —— 实现一个读写锁</a>
        <a class="nav-mobile-next" title="记一个面试题 —— 实现一个读写锁" href="https://epitomm.github.io/post/ji-yi-ge-mian-shi-ti-shi-xian-yi-ge-du-xie-suo/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  
    
      <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>
  var gitalk = new Gitalk({
    clientID: '974bd77fbbd52c2a0647',
    clientSecret: '6344370ca1314dbd553f45e75a2121a160ef1c44',
    repo: 'EpitomM.github.io',
    owner: 'EpitomM',
    admin: ['EpitomM'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })
  gitalk.render('gitalk-container')
</script>
    
    
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      Powered by <a href="https://github.com/EpitomM/EpitomM.github.io" target="_blank">EpitomM</a>
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
    
    <div class="bg-img">
      <img src="\media\images\custom-bgImg.png" />
    </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  
  let hasCacu = false;
  window.onresize = function() {
    if (window.width > 991) {
      calcuHeight();
    } else {
      hasCacu = false;
    }
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, transitionDir,{ });
          }
        })
        window.Velocity(viewport, openProp,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target","_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch.addEventListener('click', function() {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();

</script>
    <div class="light-box" id="light_box"></div>
<script>
  let imgs = document.querySelectorAll('.post-body img');
  let lightBox = document.querySelector('#light_box');
  lightBox.addEventListener('mousedown', (e) => {
    e.preventDefault()
  })
  lightBox.addEventListener('mousewheel', (e) => {
    e.preventDefault()
  })
  let width = window.innerWidth * 0.8;
  lightBox.onclick = () => {
    let img = lightBox.querySelector('img');
    lightBox.style = '';
    img && img.remove();
  }
  imgs.forEach(item => {
    item.onclick = function (e) {
      let lightImg = document.createElement('img');
      lightImg.src = this.src;
      lightBox.style = `height: 100%; opacity: 1; background-color: rgba(0, 0, 0, 0.5);cursor: zoom-out;`;
      lightImg.style = `width: ${width}px; border: 1px solid #fff; border-radius: 2px;`;
      lightImg.onclick = function () {
        lightBox.style = '';
        this.remove();
      }
      lightBox.append(lightImg);
    }
  })
</script>
  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/spring-xi-lie-shi-liu-xun-huan-yi-lai/"" data-c="
          &lt;h1 id=&#34;spring-循环依赖&#34;&gt;Spring 循环依赖&lt;/h1&gt;
&lt;h2 id=&#34;先准备一段循环依赖代码&#34;&gt;先准备一段循环依赖代码&lt;/h2&gt;
&lt;p&gt;1、IndexService 依赖 Luban&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class IndexService {
   @Autowired
   Luban luban;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、Luban 依赖 IndexService&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class Luban {
   @Autowired
   IndexService indexService;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从设置属性 populateBean 开始看起&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/populateBean.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
   if (bw == null) {
      if (mbd.hasPropertyValues()) {
         throw new BeanCreationException(
               mbd.getResourceDescription(), beanName, &amp;quot;Cannot apply property values to null instance&amp;quot;);
      }
      else {
         // Skip property population phase for null instance.
         return;
      }
   }
   // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the
   // state of the bean before properties are set. This can be used, for example,
   // to support styles of field injection.
   if (!mbd.isSynthetic() &amp;amp;&amp;amp; hasInstantiationAwareBeanPostProcessors()) {
      for (BeanPostProcessor bp : getBeanPostProcessors()) {
         // 如果实例化了 InstantiationAwareBeanPostProcessor接口，重写 postProcessAfterInstantiation方法：
         // 表示不需要 Spring 帮助我们设置属性，就在这里直接 return，不进行后续通过 Spring 来设置属性的操作
         if (bp instanceof InstantiationAwareBeanPostProcessor) {
            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
            if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
               return;
            }
         }
      }
   }
   // Spring 内部设置的，Spring 内部可以添加参数值：
   // 1.设置构造方法的值：genericBeanDefinition.getConstructorArgumentValues().addGenericArgumentValue(&amp;quot;com.ssm.app.Luban&amp;quot;);、
   // 2.设置属性值，如果Spring内部没有设置则 pvs=null
   PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);
   // Spring 默认 AUTOWIRE_NO，如果没有自定义设置自动装配类型，则不会进入这个 if 分支
   int resolvedAutowireMode = mbd.getResolvedAutowireMode();
   if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
      MutablePropertyValues newPvs = new MutablePropertyValues(pvs);
      // Add property values based on autowire by name if applicable.
      if (resolvedAutowireMode == AUTOWIRE_BY_NAME) {
         autowireByName(beanName, mbd, bw, newPvs);
      }
      // Add property values based on autowire by type if applicable.
      if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
         autowireByType(beanName, mbd, bw, newPvs);
      }
      pvs = newPvs;
   }
   // 是否要处理，这里返回 true
   boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
   // 是否要深度检查，比如循环引用时就需要，这里返回 true
   boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);
   if (hasInstAwareBpps || needsDepCheck) {
      if (pvs == null) {
         pvs = mbd.getPropertyValues();
      }
      // 拿到所有 Descriptor，带 get、set 方法的都拿到
      PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
      if (hasInstAwareBpps) {
         for (BeanPostProcessor bp : getBeanPostProcessors()) {
            if (bp instanceof InstantiationAwareBeanPostProcessor) {
               InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
               pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
               if (pvs == null) {
                  return;
               }
            }
         }
      }
      if (needsDepCheck) {
         checkDependencies(beanName, mbd, filteredPds, pvs);
      }
   }
   if (pvs != null) {
      applyPropertyValues(beanName, mbd, bw, pvs);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/filteredPds%E6%8B%BF%E5%88%B0getClass.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;共有 7 个后置处理器，其中有 3个 instanceof InstantiationAwareBeanPostProcessor，会成功进入 if 分支：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ImportAwareBeanPostProcessor&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/ImportAwareBeanPostProcessor.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;CommonAnnotationBeanPostProcessor&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/CommonAnnotationBeanPostProcessor.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;前两个后置处理器执行完毕后，luban 变量都没有被赋值，而第三个后置处理器执行完成后，luban 变量被成功赋值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AutowiredAnnotationBeanPostProcessor&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/AutowiredAnnotationBeanPostProcessor.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;当执行完 AutowiredAnnotationBeanPostProcessor 的 postProcessPropertyValues() 方法后，indexService 中的属性 luban 被成功赋值，不再为 null 了。&lt;/p&gt;
&lt;h2 id=&#34;postprocesspropertyvalues&#34;&gt;postProcessPropertyValues&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来看 postProcessPropertyValues 内都做了什么事情：&lt;br&gt;
AutowiredAnnotationBeanPostProcessor#postProcessPropertyValues&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public PropertyValues postProcessPropertyValues(
      PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeanCreationException {
   InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);
   try {
      metadata.inject(bean, beanName, pvs);
   }
   catch (BeanCreationException ex) {
      throw ex;
   }
   catch (Throwable ex) {
      throw new BeanCreationException(beanName, &amp;quot;Injection of autowired dependencies failed&amp;quot;, ex);
   }
   return pvs;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 6 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;metadata.inject(bean, beanName, pvs);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;InjectionMetadata#inject&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void inject(Object target, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {
   Collection&amp;lt;InjectedElement&amp;gt; checkedElements = this.checkedElements;
   Collection&amp;lt;InjectedElement&amp;gt; elementsToIterate =
         (checkedElements != null ? checkedElements : this.injectedElements);
   if (!elementsToIterate.isEmpty()) {
      for (InjectedElement element : elementsToIterate) {
         if (logger.isDebugEnabled()) {
            logger.debug(&amp;quot;Processing injected element of bean &#39;&amp;quot; + beanName + &amp;quot;&#39;: &amp;quot; + element);
         }
         element.inject(target, beanName, pvs);
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/checkedElements.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上述代码第 10 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;element.inject(target, beanName, pvs);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;AutowiredAnnotationBeanPostProcessor#inject&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {
   Field field = (Field) this.member;
   Object value;
   if (this.cached) {
      value = resolvedCachedArgument(beanName, this.cachedFieldValue);
   }
   else {
      DependencyDescriptor desc = new DependencyDescriptor(field, this.required); 
      desc.setContainingClass(bean.getClass());
      Set&amp;lt;String&amp;gt; autowiredBeanNames = new LinkedHashSet&amp;lt;&amp;gt;(1);
      Assert.state(beanFactory != null, &amp;quot;No BeanFactory available&amp;quot;);
      TypeConverter typeConverter = beanFactory.getTypeConverter();
      try {
         value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);
      }
      catch (BeansException ex) {
         throw new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(field), ex);
      }
      synchronized (this) {
         if (!this.cached) {
            if (value != null || this.required) {
               this.cachedFieldValue = desc;
               registerDependentBeans(beanName, autowiredBeanNames);
               if (autowiredBeanNames.size() == 1) {
                  String autowiredBeanName = autowiredBeanNames.iterator().next();
                  if (beanFactory.containsBean(autowiredBeanName) &amp;amp;&amp;amp;
                        beanFactory.isTypeMatch(autowiredBeanName, field.getType())) {
                     this.cachedFieldValue = new ShortcutDependencyDescriptor(
                           desc, autowiredBeanName, field.getType());
                  }
               }
            }
            else {
               this.cachedFieldValue = null;
            }
            this.cached = true;
         }
      }
   }
   if (value != null) {
      ReflectionUtils.makeAccessible(field);
      field.set(bean, value);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/inject%E7%9A%84field.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上述代码第 14 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DefaultListableBeanFactory#resolveDependency&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,
      @Nullable Set&amp;lt;String&amp;gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {
   descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());
   if (Optional.class == descriptor.getDependencyType()) {
      return createOptionalDependency(descriptor, requestingBeanName);
   }
   else if (ObjectFactory.class == descriptor.getDependencyType() ||
         ObjectProvider.class == descriptor.getDependencyType()) {
      return new DependencyObjectProvider(descriptor, requestingBeanName);
   }
   else if (javaxInjectProviderClass == descriptor.getDependencyType()) {
      return new Jsr330ProviderFactory().createDependencyProvider(descriptor, requestingBeanName);
   }
   else {
      Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(
            descriptor, requestingBeanName);
      if (result == null) {
         result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);
      }
      return result;
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 19 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DefaultListableBeanFactory#doResolveDependency&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName,
      @Nullable Set&amp;lt;String&amp;gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {
   InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);
   try {
      Object shortcut = descriptor.resolveShortcut(this);
      if (shortcut != null) {
         return shortcut;
      }
      
      // 根据类型，从Spring容器中把 Luban 对象取出来
      Class&amp;lt;?&amp;gt; type = descriptor.getDependencyType();
      Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);
      if (value != null) {
         if (value instanceof String) {
            String strVal = resolveEmbeddedValue((String) value);
            BeanDefinition bd = (beanName != null &amp;amp;&amp;amp; containsBean(beanName) ? getMergedBeanDefinition(beanName) : null);
            value = evaluateBeanDefinitionString(strVal, bd);
         }
         TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());
         return (descriptor.getField() != null ?
               converter.convertIfNecessary(value, type, descriptor.getField()) :
               converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));
      }
      Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);
      if (multipleBeans != null) {
         return multipleBeans;
      }
      Map&amp;lt;String, Object&amp;gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);
      if (matchingBeans.isEmpty()) {
         if (isRequired(descriptor)) {
            raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);
         }
         return null;
      }
      String autowiredBeanName;
      Object instanceCandidate;
      if (matchingBeans.size() &amp;gt; 1) {
         autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);
         if (autowiredBeanName == null) {
            if (isRequired(descriptor) || !indicatesMultipleBeans(type)) {
               return descriptor.resolveNotUnique(type, matchingBeans);
            }
            else {
               // In case of an optional Collection/Map, silently ignore a non-unique case:
               // possibly it was meant to be an empty collection of multiple regular beans
               // (before 4.3 in particular when we didn&#39;t even look for collection beans).
               return null;
            }
         }
         instanceCandidate = matchingBeans.get(autowiredBeanName);
      }
      else {
         // We have exactly one match.
         Map.Entry&amp;lt;String, Object&amp;gt; entry = matchingBeans.entrySet().iterator().next();
         autowiredBeanName = entry.getKey();
         instanceCandidate = entry.getValue();
      }
      if (autowiredBeanNames != null) {
         autowiredBeanNames.add(autowiredBeanName);
      }
      if (instanceCandidate instanceof Class) {
         instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, this);
      }
      Object result = instanceCandidate;
      if (result instanceof NullBean) {
         if (isRequired(descriptor)) {
            raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);
         }
         result = null;
      }
      if (!ClassUtils.isAssignableValue(type, result)) {
         throw new BeanNotOfRequiredTypeException(autowiredBeanName, type, instanceCandidate.getClass());
      }
      return result;
   }
   finally {
      ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/instanceCandidate.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;resolvecandidate&#34;&gt;resolveCandidate&lt;/h2&gt;
&lt;p&gt;主要代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, this);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过如上代码把 luban 实例化出来。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/singletonObjects.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;当 Spring 实例化 IndexService 时，调用一个后置处理器把 IndexService 实例化出来，然后把它放到 singletonFactories 中，然后处理它的后置处理器，有一个后置处理器 AutowiredAnnotationBeanPostProcessor，发现 IndexService 有一个属性 Luban 需要自动装配，就调用这个属性 inject，首先拿到他的类型，然后从 Spring 容器中找。&lt;/p&gt;
&lt;p&gt;DependencyDescriptor#resolveCandidate&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Object resolveCandidate(String beanName, Class&amp;lt;?&amp;gt; requiredType, BeanFactory beanFactory)
      throws BeansException {
   return beanFactory.getBean(beanName);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/getBean%E7%9A%84beanName%E5%8F%82%E6%95%B0.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;AbstractBeanFactory#getBean&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Object getBean(String name) throws BeansException {
   return doGetBean(name, null, null, false);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;AbstractBeanFactory#doGetBean&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected &amp;lt;T&amp;gt; T doGetBean(final String name, @Nullable final Class&amp;lt;T&amp;gt; requiredType,
      @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {
   /**
    * 通过 name 获取 beanName，这里不使用 name 直接作为 beanName 有两个原因：
    *     1.name 可能会以 &amp;amp; 字符开头，表名调用者想获取 FactoryBean 本身，而非 FactoryBean
    *     实现类锁创建的 bean。在 Spring 工厂中，FactoryBean 的实现类和其他的普通 bean 存储
    *     方式是一致的，即&amp;lt;beanName, bean&amp;gt;，beanName 中是没有 &amp;amp; 这个字符的。所以我们需要
    *     将 name 的首字符 &amp;amp; 移除，这样才能从缓存里取到 FactoryBean 实例。
    * 2.还是别名的问题，转换需要
    */
   final String beanName = transformedBeanName(name);
   Object bean;
   /**
    * 这个方法在初始化的时候会调用，在 getBean 的时候也会调用
    * 为什么需要这么做呢？
    * 也就是说 Spring 在初始化的时候先获取这个对象，判断这个对象是否被实例化好了
    * （一般情况下为空，因为在初始化阶段，还未初始化结束，所以为空 === 有一种情况可能不为空）
    * 从 Spring 的 Bean 容器中获取一个 bean，由于 Spring 中 Bean 容器是一个 map（singletonObjects）
    * 所以可以理解 getSingleton(beanName) 等于 beanMap.get(beanName)
    * 由于方法会在 Spring 环境初始化的时候（就是对象被创建的时候调用一次）调用一次
    * 还会在 getBean 的时候调用一次
    * 所以在调试的时候需要特别注意，不能直接断点在这里，
    * 需要先进入到 annotationConfigApplicationContext.getBean(IndexService.class)
    * 之后再来断点，这样就确保了我们是在获取这个 bean 的时候调用的
    *
    * 需要说明的是在初始化时候调用一般都是返回 null
    */
   // Eagerly check singleton cache for manually registered singletons.
   // 先 getSingleton(beanName)，如果拿不到，再去初始化
   Object sharedInstance = getSingleton(beanName);
   if (sharedInstance != null &amp;amp;&amp;amp; args == null) {
      if (logger.isDebugEnabled()) {
         if (isSingletonCurrentlyInCreation(beanName)) {
            logger.debug(&amp;quot;Returning eagerly cached instance of singleton bean &#39;&amp;quot; + beanName +
                  &amp;quot;&#39; that is not fully initialized yet - a consequence of a circular reference&amp;quot;);
         }
         else {
            logger.debug(&amp;quot;Returning cached instance of singleton bean &#39;&amp;quot; + beanName + &amp;quot;&#39;&amp;quot;);
         }
      }
      bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
   }
   else {
      // Fail if we&#39;re already creating this bean instance:
      // We&#39;re assumably within a circular reference.
      /**
       * 原型
       * 如果是原型不应该在初始化的时候创建
       */
      if (isPrototypeCurrentlyInCreation(beanName)) {
         throw new BeanCurrentlyInCreationException(beanName);
      }
      // Check if bean definition exists in this factory.
      BeanFactory parentBeanFactory = getParentBeanFactory();
      if (parentBeanFactory != null &amp;amp;&amp;amp; !containsBeanDefinition(beanName)) {
         // Not found -&amp;gt; check parent.
         String nameToLookup = originalBeanName(name);
         if (parentBeanFactory instanceof AbstractBeanFactory) {
            return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
                  nameToLookup, requiredType, args, typeCheckOnly);
         }
         else if (args != null) {
            // Delegation to parent with explicit args.
            return (T) parentBeanFactory.getBean(nameToLookup, args);
         }
         else {
            // No args -&amp;gt; delegate to standard getBean method.
            return parentBeanFactory.getBean(nameToLookup, requiredType);
         }
      }
      if (!typeCheckOnly) {
         // 添加到 alreadyCreated set集合中，表示他已经创建过一次
         markBeanAsCreated(beanName);
      }
      try {
         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
         checkMergedBeanDefinition(mbd, beanName, args);
         // Guarantee initialization of beans that the current bean depends on.
         String[] dependsOn = mbd.getDependsOn();
         if (dependsOn != null) {
            for (String dep : dependsOn) {
               if (isDependent(beanName, dep)) {
                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        &amp;quot;Circular depends-on relationship between &#39;&amp;quot; + beanName + &amp;quot;&#39; and &#39;&amp;quot; + dep + &amp;quot;&#39;&amp;quot;);
               }
               registerDependentBean(dep, beanName);
               try {
                  getBean(dep);
               }
               catch (NoSuchBeanDefinitionException ex) {
                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        &amp;quot;&#39;&amp;quot; + beanName + &amp;quot;&#39; depends on missing bean &#39;&amp;quot; + dep + &amp;quot;&#39;&amp;quot;, ex);
               }
            }
         }
         // Create bean instance.
         if (mbd.isSingleton()) {
            sharedInstance = getSingleton(beanName, () -&amp;gt; {
               try {
                  return createBean(beanName, mbd, args);
               }
               catch (BeansException ex) {
                  // Explicitly remove instance from singleton cache: It might have been put there
                  // eagerly by the creation process, to allow for circular reference resolution.
                  // Also remove any beans that received a temporary reference to the bean.
                  destroySingleton(beanName);
                  throw ex;
               }
            });
            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
         }
         else if (mbd.isPrototype()) {
            // It&#39;s a prototype -&amp;gt; create a new instance.
            Object prototypeInstance = null;
            try {
               beforePrototypeCreation(beanName);
               prototypeInstance = createBean(beanName, mbd, args);
            }
            finally {
               afterPrototypeCreation(beanName);
            }
            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
         }
         else {
            String scopeName = mbd.getScope();
            final Scope scope = this.scopes.get(scopeName);
            if (scope == null) {
               throw new IllegalStateException(&amp;quot;No Scope registered for scope name &#39;&amp;quot; + scopeName + &amp;quot;&#39;&amp;quot;);
            }
            try {
               Object scopedInstance = scope.get(beanName, () -&amp;gt; {
                  beforePrototypeCreation(beanName);
                  try {
                     return createBean(beanName, mbd, args);
                  }
                  finally {
                     afterPrototypeCreation(beanName);
                  }
               });
               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
            }
            catch (IllegalStateException ex) {
               throw new BeanCreationException(beanName,
                     &amp;quot;Scope &#39;&amp;quot; + scopeName + &amp;quot;&#39; is not active for the current thread; consider &amp;quot; +
                     &amp;quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&amp;quot;,
                     ex);
            }
         }
      }
      catch (BeansException ex) {
         cleanupAfterBeanCreationFailure(beanName);
         throw ex;
      }
   }
   // Check if required type matches the type of the actual bean instance.
   if (requiredType != null &amp;amp;&amp;amp; !requiredType.isInstance(bean)) {
      try {
         T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
         if (convertedBean == null) {
            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
         }
         return convertedBean;
      }
      catch (TypeMismatchException ex) {
         if (logger.isDebugEnabled()) {
            logger.debug(&amp;quot;Failed to convert bean &#39;&amp;quot; + name + &amp;quot;&#39; to required type &#39;&amp;quot; +
                  ClassUtils.getQualifiedName(requiredType) + &amp;quot;&#39;&amp;quot;, ex);
         }
         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
      }
   }
   return (T) bean;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一开始实例化时，调用 getSingleton() 返回为 null；当要完成属性填充时，还需调用 getSingleton()。此时&lt;br&gt;
DefaultSingletonBeanRegistry#getSingleton&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Object getSingleton(String beanName) {
   return getSingleton(beanName, true);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DefaultSingletonBeanRegistry#getSingleton&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// allowEarlyReference=true：允许缓存它、允许暴露出来
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
   // 从 map 中获取 bean 如果不为空直接返回，不再进行初始化工作
   Object singletonObject = this.singletonObjects.get(beanName);
   // 此时 Luban 和 IndexService 还没有被放到容器中，所以从容器中get去获取为空，即 singletonObject == null
   // isSingletonCurrentlyInCreation(beanName)==true：表示一个类正在被创建，在第一次初始化调用 doCreateBean 时把对象放到 singletonCurrentlyCreation 中，此时对象已经被 new 出来了，只是没有填充属性
   if (singletonObject == null &amp;amp;&amp;amp; isSingletonCurrentlyInCreation(beanName)) {
      synchronized (this.singletonObjects) {
         // 此时还没有把对象放到 earlySingletonObjects 中，所以 singletonObject=null
         singletonObject = this.earlySingletonObjects.get(beanName);
         // 此 if 判断成立
         if (singletonObject == null &amp;amp;&amp;amp; allowEarlyReference) {
            // 从缓存中取出还没有被填充属性的 Bean
            ObjectFactory&amp;lt;?&amp;gt; singletonFactory = this.singletonFactories.get(beanName);
            if (singletonFactory != null) {
               singletonObject = singletonFactory.getObject();
               // 放到 earlySingletonObjects 中 
               this.earlySingletonObjects.put(beanName, singletonObject);
               this.singletonFactories.remove(beanName);
            }
         }
      }
   }
   return singletonObject;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当一个对象执行 doCreateBean 时：通过构造方法 new Bean，把 Bean 放到 singletonFactories 中，当填充属性时又调用 getBean()，从 singletonFactories 缓存中拿出 Bean，但此时的 Bean 还没有属性，把它放到 earlySingletonObjects 中，然后从 singletonFactories 中移除。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;上述代码第 10 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;singletonObject = this.earlySingletonObjects.get(beanName);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/singletonObject.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上述代码第 14 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ObjectFactory&amp;lt;?&amp;gt; singletonFactory = this.singletonFactories.get(beanName);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/singletonFactory.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上述代码第 18-19 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;this.earlySingletonObjects.put(beanName, singletonObject);
this.singletonFactories.remove(beanName);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将 luban 放到 earlySingletonObjects 中，将 luban 从 singletonFactories 中移除。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/earlySingletonObjects.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;IndexService 类注入 luban 属性的值：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/InsexService%E6%B3%A8%E5%85%A5%E5%B1%9E%E6%80%A7%E5%80%BC.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;spring-循环依赖方法调用过程图&#34;&gt;Spring 循环依赖方法调用过程图&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%9B%BE.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">Spring系列（十六）Spring循环依赖</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/spring-xi-lie-shi-wu-spring-yuan-ma-jie-xi-te-shu-gou-zao-fang-fa/"" data-c="
          &lt;p&gt;·# context.getBean()&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;IndexDao dao = (IndexDao) context.getBean(&amp;quot;indexDao&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;AbstractApplicationContext#getBean&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public Object getBean(String name) throws BeansException {
   assertBeanFactoryActive();
   return getBeanFactory().getBean(name);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DefaultListableBeanFactory#getBean&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public &amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt; requiredType) throws BeansException {
   return getBean(requiredType, (Object[]) null);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DefaultListableBeanFactory#getBean&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public &amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt; requiredType, @Nullable Object... args) throws BeansException {
   NamedBeanHolder&amp;lt;T&amp;gt; namedBean = resolveNamedBean(requiredType, args);
   if (namedBean != null) {
      return namedBean.getBeanInstance();
   }
   BeanFactory parent = getParentBeanFactory();
   if (parent != null) {
      return (args != null ? parent.getBean(requiredType, args) : parent.getBean(requiredType));
   }
   throw new NoSuchBeanDefinitionException(requiredType);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 2 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;NamedBeanHolder&amp;lt;T&amp;gt; namedBean = resolveNamedBean(requiredType, args);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DefaultListableBeanFactory#resolveNamedBean&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private &amp;lt;T&amp;gt; NamedBeanHolder&amp;lt;T&amp;gt; resolveNamedBean(Class&amp;lt;T&amp;gt; requiredType, @Nullable Object... args) throws BeansException {
   Assert.notNull(requiredType, &amp;quot;Required type must not be null&amp;quot;);
   String[] candidateNames = getBeanNamesForType(requiredType);
   if (candidateNames.length &amp;gt; 1) {
      List&amp;lt;String&amp;gt; autowireCandidates = new ArrayList&amp;lt;&amp;gt;(candidateNames.length);
      for (String beanName : candidateNames) {
         if (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) {
            autowireCandidates.add(beanName);
         }
      }
      if (!autowireCandidates.isEmpty()) {
         candidateNames = StringUtils.toStringArray(autowireCandidates);
      }
   }
   if (candidateNames.length == 1) {
      String beanName = candidateNames[0];
      return new NamedBeanHolder&amp;lt;&amp;gt;(beanName, getBean(beanName, requiredType, args));
   }
   else if (candidateNames.length &amp;gt; 1) {
      Map&amp;lt;String, Object&amp;gt; candidates = new LinkedHashMap&amp;lt;&amp;gt;(candidateNames.length);
      for (String beanName : candidateNames) {
         if (containsSingleton(beanName) &amp;amp;&amp;amp; args == null) {
            Object beanInstance = getBean(beanName);
            candidates.put(beanName, (beanInstance instanceof NullBean ? null : beanInstance));
         }
         else {
            candidates.put(beanName, getType(beanName));
         }
      }
      String candidateName = determinePrimaryCandidate(candidates, requiredType);
      if (candidateName == null) {
         candidateName = determineHighestPriorityCandidate(candidates, requiredType);
      }
      if (candidateName != null) {
         Object beanInstance = candidates.get(candidateName);
         if (beanInstance == null || beanInstance instanceof Class) {
            beanInstance = getBean(candidateName, requiredType, args);
         }
         return new NamedBeanHolder&amp;lt;&amp;gt;(candidateName, (T) beanInstance);
      }
      throw new NoUniqueBeanDefinitionException(requiredType, candidates.keySet());
   }
   return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 19 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;return new NamedBeanHolder&amp;lt;&amp;gt;(beanName, getBean(beanName, requiredType, args));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;AbstractBeanFactory#getBean&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public &amp;lt;T&amp;gt; T getBean(String name, @Nullable Class&amp;lt;T&amp;gt; requiredType, @Nullable Object... args)
      throws BeansException {
   return doGetBean(name, requiredType, args, false);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;AbstractBeanFactory#doGetBean&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected &amp;lt;T&amp;gt; T doGetBean(final String name, @Nullable final Class&amp;lt;T&amp;gt; requiredType,
      @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {
   final String beanName = transformedBeanName(name);
   Object bean;
   // Eagerly check singleton cache for manually registered singletons.
   Object sharedInstance = getSingleton(beanName);
   if (sharedInstance != null &amp;amp;&amp;amp; args == null) {
      if (logger.isDebugEnabled()) {
         if (isSingletonCurrentlyInCreation(beanName)) {
            logger.debug(&amp;quot;Returning eagerly cached instance of singleton bean &#39;&amp;quot; + beanName +
                  &amp;quot;&#39; that is not fully initialized yet - a consequence of a circular reference&amp;quot;);
         }
         else {
            logger.debug(&amp;quot;Returning cached instance of singleton bean &#39;&amp;quot; + beanName + &amp;quot;&#39;&amp;quot;);
         }
      }
      bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
   }
   else {
      // Fail if we&#39;re already creating this bean instance:
      // We&#39;re assumably within a circular reference.
      if (isPrototypeCurrentlyInCreation(beanName)) {
         throw new BeanCurrentlyInCreationException(beanName);
      }
      // Check if bean definition exists in this factory.
      BeanFactory parentBeanFactory = getParentBeanFactory();
      if (parentBeanFactory != null &amp;amp;&amp;amp; !containsBeanDefinition(beanName)) {
         // Not found -&amp;gt; check parent.
         String nameToLookup = originalBeanName(name);
         if (parentBeanFactory instanceof AbstractBeanFactory) {
            return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
                  nameToLookup, requiredType, args, typeCheckOnly);
         }
         else if (args != null) {
            // Delegation to parent with explicit args.
            return (T) parentBeanFactory.getBean(nameToLookup, args);
         }
         else {
            // No args -&amp;gt; delegate to standard getBean method.
            return parentBeanFactory.getBean(nameToLookup, requiredType);
         }
      }
      if (!typeCheckOnly) {
         markBeanAsCreated(beanName);
      }
      try {
         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
         checkMergedBeanDefinition(mbd, beanName, args);
         // Guarantee initialization of beans that the current bean depends on.
         String[] dependsOn = mbd.getDependsOn();
         if (dependsOn != null) {
            for (String dep : dependsOn) {
               if (isDependent(beanName, dep)) {
                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        &amp;quot;Circular depends-on relationship between &#39;&amp;quot; + beanName + &amp;quot;&#39; and &#39;&amp;quot; + dep + &amp;quot;&#39;&amp;quot;);
               }
               registerDependentBean(dep, beanName);
               try {
                  getBean(dep);
               }
               catch (NoSuchBeanDefinitionException ex) {
                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        &amp;quot;&#39;&amp;quot; + beanName + &amp;quot;&#39; depends on missing bean &#39;&amp;quot; + dep + &amp;quot;&#39;&amp;quot;, ex);
               }
            }
         }
         // Create bean instance.
         if (mbd.isSingleton()) {
            sharedInstance = getSingleton(beanName, () -&amp;gt; {
               try {
                  return createBean(beanName, mbd, args);
               }
               catch (BeansException ex) {
                  // Explicitly remove instance from singleton cache: It might have been put there
                  // eagerly by the creation process, to allow for circular reference resolution.
                  // Also remove any beans that received a temporary reference to the bean.
                  destroySingleton(beanName);
                  throw ex;
               }
            });
            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
         }
         else if (mbd.isPrototype()) {
            // It&#39;s a prototype -&amp;gt; create a new instance.
            Object prototypeInstance = null;
            try {
               beforePrototypeCreation(beanName);
               prototypeInstance = createBean(beanName, mbd, args);
            }
            finally {
               afterPrototypeCreation(beanName);
            }
            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
         }
         else {
            String scopeName = mbd.getScope();
            final Scope scope = this.scopes.get(scopeName);
            if (scope == null) {
               throw new IllegalStateException(&amp;quot;No Scope registered for scope name &#39;&amp;quot; + scopeName + &amp;quot;&#39;&amp;quot;);
            }
            try {
               Object scopedInstance = scope.get(beanName, () -&amp;gt; {
                  beforePrototypeCreation(beanName);
                  try {
                     return createBean(beanName, mbd, args);
                  }
                  finally {
                     afterPrototypeCreation(beanName);
                  }
               });
               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
            }
            catch (IllegalStateException ex) {
               throw new BeanCreationException(beanName,
                     &amp;quot;Scope &#39;&amp;quot; + scopeName + &amp;quot;&#39; is not active for the current thread; consider &amp;quot; +
                     &amp;quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&amp;quot;,
                     ex);
            }
         }
      }
      catch (BeansException ex) {
         cleanupAfterBeanCreationFailure(beanName);
         throw ex;
      }
   }
   // Check if required type matches the type of the actual bean instance.
   if (requiredType != null &amp;amp;&amp;amp; !requiredType.isInstance(bean)) {
      try {
         T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
         if (convertedBean == null) {
            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
         }
         return convertedBean;
      }
      catch (TypeMismatchException ex) {
         if (logger.isDebugEnabled()) {
            logger.debug(&amp;quot;Failed to convert bean &#39;&amp;quot; + name + &amp;quot;&#39; to required type &#39;&amp;quot; +
                  ClassUtils.getQualifiedName(requiredType) + &amp;quot;&#39;&amp;quot;, ex);
         }
         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
      }
   }
   return (T) bean;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;使用特殊构造方法实例化对象&#34;&gt;使用特殊构造方法实例化对象&lt;/h1&gt;
&lt;h2 id=&#34;提前准备-demo-代码&#34;&gt;提前准备 demo 代码&lt;/h2&gt;
&lt;p&gt;1、准备一个特殊构造方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class IndexService {
   public IndexService(Luban luban){
      System.out.println(&amp;quot;IndexService...constructor&amp;quot;);
   }
   public void query(){
      System.out.println(&amp;quot;query...&amp;quot;);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、构造方法参数类型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class Luban {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、测试类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
   public static void main(String[] args) {
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext(AppConfig.class);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/bean%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;AnnotationConfigApplicationContext#AnnotationConfigApplicationContext ---&amp;gt; AbstractApplicationContext#refresh(); --&amp;gt; finishBeanFactoryInitialization --&amp;gt; DefaultListableBeanFactory#preInstantiateSingletons() --&amp;gt; AbstractBeanFactory#getBean --&amp;gt; AbstractBeanFactory#doGetBean --&amp;gt; AbstractAutowireCapableBeanFactory#createBeanInstance --&amp;gt; AbstractAutowireCapableBeanFactory#createBeanInstance --&amp;gt; AbstractAutowireCapableBeanFactory#autowireConstructor&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {
   // Make sure bean class is actually resolved at this point.
   Class&amp;lt;?&amp;gt; beanClass = resolveBeanClass(mbd, beanName);
   /**
    * 检测一个类的访问权限 Spring 默认情况下对于非 public 的类是允许访问的。
    */
   if (beanClass != null &amp;amp;&amp;amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;amp;&amp;amp; !mbd.isNonPublicAccessAllowed()) {
      throw new BeanCreationException(mbd.getResourceDescription(), beanName,
            &amp;quot;Bean class isn&#39;t public, and non-public access not allowed: &amp;quot; + beanClass.getName());
   }
   Supplier&amp;lt;?&amp;gt; instanceSupplier = mbd.getInstanceSupplier();
   if (instanceSupplier != null) {
      return obtainFromSupplier(instanceSupplier, beanName);
   }
   /**
    * 如果工厂方法不为空，则通过工厂方法创建 bean 对象
    * 这种构建 bean 的方式可以自己写个 demo 去试试
    */
   if (mbd.getFactoryMethodName() != null) {
      return instantiateUsingFactoryMethod(beanName, mbd, args);
   }
   // Shortcut when re-creating the same bean...
   /**
    * 从 Spring 的原始注释可以知道这是一个 Shortcut，什么意思呢？
    * 当多次构建同一个 bean 时，可以使用这个 Shortcut，
    * 也就是说不在需要此腿短应该使用哪种方式构造 bean
    * 比如在多次构建同一个 prototype 类型的 bean 时，就可以走此处的 Shortcut
    * 这里的 resolved  和 mbd.constructorArgumentsResolved 将会在 bean 第一次实例化的过程中被设置，后面来证明
    */
   boolean resolved = false;
   // 必须自动装配
   boolean autowireNecessary = false;
   if (args == null) {
      synchronized (mbd.constructorArgumentLock) {
         // 如果是一个 FactoryMethod 创建的，就会把 resolved 设置为 true
         if (mbd.resolvedConstructorOrFactoryMethod != null) {
            resolved = true;
            // 如果已经解析了构造方法的参数，则必须要通过一个带参构造方法来实例
            autowireNecessary = mbd.constructorArgumentsResolved;
         }
      }
   }
   if (resolved) {
      if (autowireNecessary) {
         // 通过构造方法自动装配的方式构造 bean 对象
         return autowireConstructor(beanName, mbd, null, null);
      }
      else {
         // 通过默认的无参构造方法进行
         return instantiateBean(beanName, mbd);
      }
   }
   // Candidate constructors for autowiring?
   // 由后置处理器决定返回哪些构造方法
      Constructor&amp;lt;?&amp;gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
   if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
      return autowireConstructor(beanName, mbd, ctors, args);
   }
   // No special handling: simply use no-arg constructor.
   // 使用默认的无参构造方法进行初始化
   return instantiateBean(beanName, mbd);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;断点在如下位置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Constructor&amp;lt;?&amp;gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时有一个构造方法：&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%89%AB%E6%8F%8F%E5%88%B0%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;继续向下看代码，constrs != null 满足，于是进入此 if 分支：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
      return autowireConstructor(beanName, mbd, ctors, args);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;AbstractAutowireCapableBeanFactory#autowireConstructor&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected BeanWrapper autowireConstructor(
      String beanName, RootBeanDefinition mbd, @Nullable Constructor&amp;lt;?&amp;gt;[] ctors, @Nullable Object[] explicitArgs) {
   return new ConstructorResolver(this).autowireConstructor(beanName, mbd, ctors, explicitArgs);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;autowireconstructor&#34;&gt;autowireConstructor&lt;/h2&gt;
&lt;p&gt;ConstructorResolver#autowireConstructor&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd,
      @Nullable Constructor&amp;lt;?&amp;gt;[] chosenCtors, @Nullable Object[] explicitArgs) {
   // 实例一个 BeanWrapperImpl 对象
   // 前面外部返回的 BeanWrapper 其实就是这个 BeanWrapperImpl
   // 因为 BeanWrapper 是个接口
   BeanWrapperImpl bw = new BeanWrapperImpl();
   this.beanFactory.initBeanWrapper(bw);
   /**
    * 通过构造方法创建一个对象，需要三个条件：
    * 1.构造方法
    * 2.构造方法的参数类型
    * 3.构造方法的参数值
    * 上述三个条件组成了：public IndexService(String str){}
    */
   // Spring 决定采用哪个构造方法来实例化 bean
   // 代码执行到这里 Spring 已经决定要采用一个特殊构造方法来实例 bean
   // 但是到底用哪个？可能类提供了很多构造方法
   // 采用哪个，Spring 有自己的一套规则
   // 当它找到一个之后他就会把这个构造方法赋值给 constructorToUser
   Constructor&amp;lt;?&amp;gt; constructorToUse = null;
   // 构造方法的值，注意不是参数
   // 比如 public IndexService(String str){},str 的值，只有在真正调用这个构造方法传参时才能被确定
   // 构造方法通过反射来实例化一个对象
   // 在调用反射来实例对象的时候，需要把具体的值
   // 这个变量就是用来记录这些值的，后面有证明
   // 但是这里需要注意的是 argsHolderToUse 是一个数据结构
   // argsToUse[] 才是真正的值
   ArgumentsHolder argsHolderToUse = null;
   Object[] argsToUse = null;
   // 确定参数值列表
   /**
    * explicitArgs 是从 createBeanInstance 方法传过来的，构造方法的值
    * org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBeanInstance
    * 可以看到如果从 createBeanInstance 调用那么永远为空
    */
   if (explicitArgs != null) {
      argsToUse = explicitArgs;
   }
   else {
      // argsToResolve：参数解析器
      Object[] argsToResolve = null;
      synchronized (mbd.constructorArgumentLock) {
         // mbd.resolvedConstructorOrFactoryMethod：获得BeanDefinition中已解析完的构造方法
         // 当 Spring 确定了要使用那个构造方法后，会把要使用的这个构造方法赋值给  mbd.resolvedConstructorOrFactoryMethod，下一次就不需要再解析了
         constructorToUse = (Constructor&amp;lt;?&amp;gt;) mbd.resolvedConstructorOrFactoryMethod;
         if (constructorToUse != null &amp;amp;&amp;amp; mbd.constructorArgumentsResolved) {
            // Found a cached constructor...
            argsToUse = mbd.resolvedConstructorArguments;
            if (argsToUse == null) {
               argsToResolve = mbd.preparedConstructorArguments;
            }
         }
      }
      // 如果有已解析的构造方法
      if (argsToResolve != null) {
         argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve);
      }
   }
   if (constructorToUse == null) {
      // Need to resolve the constructor.
      // 如果没有已经解析的构造方法，则需要去解析构造方法，使用哪个构造方法来实例化对象
      // 两个判断条件：判断1.chosenCtors != null
      // chosenCtors != null：判断传参进来的构造方法是否为空，如果不为空，则需要解析构造方法：
      // chosenCtors参数是由 { AbstractAutowireCapableBeanFactory#createBeanInstance：
      // Constructor&amp;lt;?&amp;gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);后置处理器决定要用ctors来实例化对象 } 传递过来的
      // 判断2.mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR：根据构造方法自动注入，也需要解析构造方法
      // 由于上面传递了 ctors,所以 chosenCtors != null
      boolean autowiring = (chosenCtors != null ||
            mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);
      // 构造方法参数的值
      ConstructorArgumentValues resolvedValues = null;
      // 定义了最小参数个数
      // 如果构造方法的参数列表给定了具体的值
      // 那么这里指的就是构造方法参数的个数
      int minNrOfArgs;
      // explicitArgs：如果传参为 Object[]{&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;}，即构造方法的参数值为 &amp;quot;hello&amp;quot;、&amp;quot;world&amp;quot;，
      // 则最小参数个数 minNrOfArgs=2
      if (explicitArgs != null) {
         minNrOfArgs = explicitArgs.length;
      }
      else {
         // cargs 获取构造方法的值，注意是值，不是类型和列表
         // 实例化一个对象，用来存放构造方法的参数值，当中主要存放了参数值和参数所对应的下标
         ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();
         // 如 MyBtis 通过 mbd.getConstructorArgumentValues().addGenericArgumentValue(&amp;quot;com.index.dao&amp;quot;); 设置构造参数的值
         // 则下面获取的 minNrOfArgs：构造方法最小参数个数就是 1 了，因为有上一行代码给了一个参数&amp;quot;com.index.dao&amp;quot;
         resolvedValues = new ConstructorArgumentValues();
         /**
          * 把 cargs 的内容给 resolvedValues 比那里并且确定构造方法参数数量，假设有如下配置：
          *     &amp;lt;bean id=&amp;quot;luban&amp;quot; class=&amp;quot;com.luban.Luban&amp;quot;&amp;gt;
          *        &amp;lt;constructor-arg index=&amp;quot;0&amp;quot; value=&amp;quot;str1&amp;quot;/&amp;gt;
          *        &amp;lt;constructor-arg index=&amp;quot;1&amp;quot; value=&amp;quot;1&amp;quot;/&amp;gt;
          *        &amp;lt;constructor-arg index=&amp;quot;2&amp;quot; value=&amp;quot;str2&amp;quot;/&amp;gt;
          *      &amp;lt;/bean&amp;gt;
          *
          * 那么 minNrOfArgs=3
          * 或者你通过 Spring 的各种扩展点给了 Spring 一些构造方法的值，那么也能确定
          * 为什么要确定？
          * 因为我们的构造方法有多个，
          * 那么类型和个数是 Spring 用来确定使用哪个构造方法的重要信息
          */
         minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);
      }
      // Take specified constructors, if any.
      Constructor&amp;lt;?&amp;gt;[] candidates = chosenCtors;
      if (candidates == null) {
         Class&amp;lt;?&amp;gt; beanClass = mbd.getBeanClass();
         try {
            candidates = (mbd.isNonPublicAccessAllowed() ?
                  beanClass.getDeclaredConstructors() : beanClass.getConstructors());
         }
         catch (Throwable ex) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                  &amp;quot;Resolution of declared constructors on bean Class [&amp;quot; + beanClass.getName() +
                  &amp;quot;] from ClassLoader [&amp;quot; + beanClass.getClassLoader() + &amp;quot;] failed&amp;quot;, ex);
         }
      }
      /**
       * 排序：优先访问权限，继而参数个数
       * 1.public Luban(Object o1, Object o2, Object o3)
       * 2.public Luban(Object o1, Object o2)
       * 3.public Luban(Object o1)
       * 4.protected Luban(Integer i, Object o1, Object o2,Object o3)
       * 5.protected Luban(Integer i, Object o1, Object o2)
       * 6.protected Luban(Integer i, Object o1)
       */
      AutowireUtils.sortConstructors(candidates);
      // 定义了一个差异变量，初始化为 Integer 最大值
      int minTypeDiffWeight = Integer.MAX_VALUE;
      // 有歧义的构造方法，比如 public IndexService(Class clazz){} 和 public IndexService(Object obj){}
      Set&amp;lt;Constructor&amp;lt;?&amp;gt;&amp;gt; ambiguousConstructors = null;
      LinkedList&amp;lt;UnsatisfiedDependencyException&amp;gt; causes = null;
      
      // 循环所有的构造方法
      for (Constructor&amp;lt;?&amp;gt; candidate : candidates) {
         Class&amp;lt;?&amp;gt;[] paramTypes = candidate.getParameterTypes();
         /**
          * constructorToUse != null 这个很好理解，
          * 前面已经说过首先 constructorToUse 主要是用来装已经解析过了并且在使用的构造方法
          * 只有在它等于空的情况下，才有继续的意义，因为下面如果解析到了一个符合的构造方法，就会赋值给这个变量。故而如果这个变量不等于 null 就不需要再进行解析了，
          * 说明 Spring 已经找到了一个合适的构造方法，直接使用便可以
          *
          * argsToUse.length &amp;gt; paramTypes.length
          * 首先假设 argsToUse=[1,&amp;quot;hello&amp;quot;,obj]
          * 那么会去匹配到上面的构造方法的 1 和 5
          * 因为排序，大到小，如果第一个都比 argsToUse 小，那么后面的就不需要去判断了
          */
          // 如果已经确定了要使用哪个构造方法，即constructorToUse != null直接break 即可。
         if (constructorToUse != null &amp;amp;&amp;amp; argsToUse.length &amp;gt; paramTypes.length) {
            // Already found greedy constructor that can be satisfied -&amp;gt;
            // do not look any further, there are only less greedy constructors left.
            break;
         }
         // 当构造方法的参数列表长度 &amp;lt; 最小参数个数，终止当前循环，继续下一次循环
         if (paramTypes.length &amp;lt; minNrOfArgs) {
            continue;
         }
         ArgumentsHolder argsHolder;
         if (resolvedValues != null) {
            try {
               // 判断是否加了 ConstructorProperties 注解，如果加了则把值取出来
               // @ConstructorProperties(value={&amp;quot;xxx&amp;quot;, &amp;quot;111 &amp;quot;})
               String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, paramTypes.length);
               if (paramNames == null) {
                  ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();
                  if (pnd != null) {
                     // 获取构造方法参数名称列表
                     // 假如有一个 (String str, Object obj)，则 paramNames=[str,obj]
                     paramNames = pnd.getParameterNames(candidate);
                  }
               }
               // 获取构造方法参数值列表
               /**
                * Spring 只能提供字符串的参数值
                * 如 &amp;lt;constructor-arg index=&amp;quot;0&amp;quot; value=&amp;quot;com.ssm.dao.IndexDao&amp;quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt; 就需要将 &amp;quot;com.ssm.dao.IndexDao&amp;quot; 转换成 IndexDao 对象
                * 故而需要进行转换，argsHolder 所包含的值就是转换之后的
                */
               argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,
                     getUserDeclaredConstructor(candidate), autowiring);
            }
            catch (UnsatisfiedDependencyException ex) {
               if (logger.isTraceEnabled()) {
                  logger.trace(&amp;quot;Ignoring constructor [&amp;quot; + candidate + &amp;quot;] of bean &#39;&amp;quot; + beanName + &amp;quot;&#39;: &amp;quot; + ex);
               }
               // Swallow and try next constructor.
               if (causes == null) {
                  causes = new LinkedList&amp;lt;&amp;gt;();
               }
               causes.add(ex);
               continue;
            }
         }
         else {
            // Explicit arguments given -&amp;gt; arguments length must match exactly.
            if (paramTypes.length != explicitArgs.length) {
               continue;
            }
            argsHolder = new ArgumentsHolder(explicitArgs);
         }
         /**
          * typeDiffWeight差异量，何谓差异量呢？
          * argsHolder.arguments 和 parameTypes 之间的差异
          * 每个参数值的类型与构造方法参数列表的类型之间的差异量
          * 通过这个差异量来衡量或者确定一个合适的构造方法
          *
          * 值得注意的是 constructoToUse=candidate
          *
          * 第一次循环一定会 typeDiffWeight &amp;lt; minTypeDiffWeight，因为 minTypeDiffWeight 的值非常大
          * 然后每次循环会把 typeDiffWeight 赋值给 minTypeDiffWeight（minTypeDiffWeight=typeDiffWeight）
          * else if(constructorToUse != null &amp;amp;&amp;amp; typeDiffWeight == minTypeDiffWeight)
          * 第一次循环肯定不会进入这个，第二次如果进入了这个分支代表什么？
          * 代表有两个构造方法都符合我们要求？那么 Spring 不知道该怎么做了
          * ambiguousConstructors.add(candidate);
          * ambiguousConstructors=null，但是非常重要，因为需要清空
          * 这也解释了为什么它找到两个符合要求的方法不直接抛异常的原因
          * 如果这个 ambiguousConstructors 一直存在，Spring 会在循环外面去 exception
          *
          */
         int typeDiffWeight = (mbd.isLenientConstructorResolution() ?
               argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));
         // Choose this constructor if it represents the closest match.
         if (typeDiffWeight &amp;lt; minTypeDiffWeight) {
            constructorToUse = candidate;
            argsHolderToUse = argsHolder;
            argsToUse = argsHolder.arguments;
            // 比如当第一次循环时候，将差异量赋值给最小差异量；第二次循环时候进行对比，如果第二次循环得到的差异量&amp;lt;当前最小差异量，则更新最小差异值；否则不更新
            minTypeDiffWeight = typeDiffWeight;
            // 如果找到比歧义变量更符合的，把歧义变量清空
            ambiguousConstructors = null;
         }
         // 如果找到两个差异值一样的，就会把它们放到歧义变量 ambiguousConstructors 里面
         else if (constructorToUse != null &amp;amp;&amp;amp; typeDiffWeight == minTypeDiffWeight) {
            if (ambiguousConstructors == null) {
               ambiguousConstructors = new LinkedHashSet&amp;lt;&amp;gt;();
               ambiguousConstructors.add(constructorToUse);
            }
            ambiguousConstructors.add(candidate);
         }
      }
      // 没有找到合适的构造方法
      if (constructorToUse == null) {
         if (causes != null) {
            UnsatisfiedDependencyException ex = causes.removeLast();
            for (Exception cause : causes) {
               this.beanFactory.onSuppressedException(cause);
            }
            throw ex;
         }
         throw new BeanCreationException(mbd.getResourceDescription(), beanName,
               &amp;quot;Could not resolve matching constructor &amp;quot; +
               &amp;quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)&amp;quot;);
      }
      // 如果 ambiguousConstructors 还存在异常？为什么会在上面方法中直接 exception?
      // 上面注释当中有说明
      else if (ambiguousConstructors != null &amp;amp;&amp;amp; !mbd.isLenientConstructorResolution()) {
         throw new BeanCreationException(mbd.getResourceDescription(), beanName,
               &amp;quot;Ambiguous constructor matches found in bean &#39;&amp;quot; + beanName + &amp;quot;&#39; &amp;quot; +
               &amp;quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): &amp;quot; +
               ambiguousConstructors);
      }
      if (explicitArgs == null) {
         /**
          * 缓存相关信息，比如：
          *     1.已解析出的构造方法对象 resolvedConstructorOfFactoryMethod
          *     2.构造方法参数列表是否已解析标志 constructorArgumentsResolved
          *     这些信息可用在其他地方，用于进行快捷判断
          */
         argsHolderToUse.storeCache(mbd, constructorToUse);
      }
   }
   try {
      /**
       * 使用反射创建实例 lookup-method 通过 CGLIB 增强 bean 实例
       */
      final InstantiationStrategy strategy = beanFactory.getInstantiationStrategy();
      Object beanInstance;
      if (System.getSecurityManager() != null) {
         final Constructor&amp;lt;?&amp;gt; ctorToUse = constructorToUse;
         final Object[] argumentsToUse = argsToUse;
         beanInstance = AccessController.doPrivileged((PrivilegedAction&amp;lt;Object&amp;gt;) () -&amp;gt;
               strategy.instantiate(mbd, beanName, beanFactory, ctorToUse, argumentsToUse),
               beanFactory.getAccessControlContext());
      }
      else {
         beanInstance = strategy.instantiate(mbd, beanName, this.beanFactory, constructorToUse, argsToUse);
      }
      bw.setBeanInstance(beanInstance);
      return bw;
   }
   catch (Throwable ex) {
      throw new BeanCreationException(mbd.getResourceDescription(), beanName,
            &amp;quot;Bean instantiation via constructor failed&amp;quot;, ex);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 89 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// cargs 获取构造方法的值，注意是值，不是类型和列表
// 实例化一个对象，用来存放构造方法的参数值，当中主要存放了参数值和参数所所对应的下标
ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ConstructorArgumentValues 用来存构造方法的值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无序时，使用 List 存储；&lt;/li&gt;
&lt;li&gt;有序时，使用 Map 存储，如：&amp;lt;1, &amp;quot;hello&amp;quot;&amp;gt;；&amp;lt;2, &amp;quot;world&amp;quot;&amp;gt;。
&lt;ul&gt;
&lt;li&gt;
&lt;constructor-arg index=&#34;1&#34; value=&#34;hello&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ConstructorArgumentValues {
   private final Map&amp;lt;Integer, ValueHolder&amp;gt; indexedArgumentValues = new LinkedHashMap&amp;lt;&amp;gt;();
   private final List&amp;lt;ValueHolder&amp;gt; genericArgumentValues = new ArrayList&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 107 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/minNrOfArgs%E4%B8%BA0.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上述代码第 178 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 获取构造方法参数名称列表
// 假如有一个 (String str, Object obj)，则 paramNames=[str,obj]
paramNames = pnd.getParameterNames(candidate);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%8E%B7%E5%BE%97%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E5%90%8D%E7%A7%B0%E5%88%97%E8%A1%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 获取构造方法参数值列表
/**
 * Spring 只能提供字符串的参数值
 * 故而需要进行转换
 * argsHolder 所包含的值就是转换之后的
 */
argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,
      getUserDeclaredConstructor(candidate), autowiring);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上述代码第 299 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;beanInstance = strategy.instantiate(mbd, beanName, this.beanFactory, constructorToUse, argsToUse);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SimpleInstantiationStrategy#instantiate&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,
      final Constructor&amp;lt;?&amp;gt; ctor, @Nullable Object... args) {
   if (!bd.hasMethodOverrides()) {
      if (System.getSecurityManager() != null) {
         // use own privileged to change accessibility (when security is on)
         AccessController.doPrivileged((PrivilegedAction&amp;lt;Object&amp;gt;) () -&amp;gt; {
            ReflectionUtils.makeAccessible(ctor);
            return null;
         });
      }
      return (args != null ? BeanUtils.instantiateClass(ctor, args) : BeanUtils.instantiateClass(ctor));
   }
   else {
      return instantiateWithMethodInjection(bd, beanName, owner, ctor, args);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 15 行：&lt;br&gt;
BeanUtils#instantiateClass&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static &amp;lt;T&amp;gt; T instantiateClass(Constructor&amp;lt;T&amp;gt; ctor, Object... args) throws BeanInstantiationException {
   Assert.notNull(ctor, &amp;quot;Constructor must not be null&amp;quot;);
   try {
      // 设置构造方法可访问
      ReflectionUtils.makeAccessible(ctor);
      // 反射创建对象
      return (KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ?
            KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args));
   }
   catch (InstantiationException ex) {
      throw new BeanInstantiationException(ctor, &amp;quot;Is it an abstract class?&amp;quot;, ex);
   }
   catch (IllegalAccessException ex) {
      throw new BeanInstantiationException(ctor, &amp;quot;Is the constructor accessible?&amp;quot;, ex);
   }
   catch (IllegalArgumentException ex) {
      throw new BeanInstantiationException(ctor, &amp;quot;Illegal arguments for constructor&amp;quot;, ex);
   }
   catch (InvocationTargetException ex) {
      throw new BeanInstantiationException(ctor, &amp;quot;Constructor threw exception&amp;quot;, ex.getTargetException());
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;构造方法注入-class&#34;&gt;构造方法注入 Class&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class IndexService {
   Class clazz;
   // 如果类型为 Class，直接忽略，不会自动装配，那么如何将 Class 注入给构造方法呢？拿出 BeanDefinition,给他一个 Class 值即可。
   public IndexService(Class clazz){
      this.clazz = clazz;
      System.out.println(&amp;quot;IndexService...constructor&amp;quot;);
   }
   public void query(){
     System.out.println(&amp;quot;clazz = &amp;quot; + this.clazz);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MyBatis 中的 MapperFactoryBean 就是类似场景：注入 Class&lt;br&gt;
MapperFactoryBean{&lt;/p&gt;
&lt;p&gt;getObject(){&lt;/p&gt;
&lt;p&gt;// 根据 clazz 返回真实代理对象&lt;/p&gt;
&lt;p&gt;return proxyObject.proxy(clazz);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h2 id=&#34;beanfactory&#34;&gt;BeanFactory&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class IndexFactory implements BeanFactoryPostProcessor {
   @Override
   public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
      // 得到 BeanDefintion
      GenericBeanDefinition indexService = (GenericBeanDefinition) beanFactory.getBeanDefinition(&amp;quot;indexService&amp;quot;);
      // 为 BeanDefinition 设置一个 Class 属性，传值 &amp;quot;com.ssm.app.Luban&amp;quot;，Spring 将字符串转化成类对象
      indexService.getConstructorArgumentValues().addGenericArgumentValue(&amp;quot;com.ssm.app.Luban&amp;quot;);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;IndexService...constructor
clazz = class com.ssm.app.Luban
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;AbstractAutowireCapableBeanFactory#createBeanInstance&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%89%AB%E6%8F%8F%E5%88%B0%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;ConstructorResolver#autowireConstructor&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E5%80%BC.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/minNrOfArgs%E4%B8%BA1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/argsHolder.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;addsingletonfactory&#34;&gt;addSingletonFactory&lt;/h1&gt;
&lt;p&gt;当把对象实例化完成之后，就会执行 addSingletonFactory 方法。&lt;/p&gt;
&lt;p&gt;AbstractApplicationContext#refresh --&amp;gt; AbstractApplicationContext#invokeBeanFactoryPostProcessors --&amp;gt; PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors --&amp;gt; AbstractBeanFactory#getBean --&amp;gt; AbstractBeanFactory#doGetBean --&amp;gt; DefaultSingletonBeanRegistry#getSingleton --&amp;gt;  AbstractBeanFactory #lambda$doGetBean --&amp;gt;AbstractAutowireCapableBeanFactory#createBean --&amp;gt; AbstractAutowireCapableBeanFactory#doCreateBean&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
      throws BeanCreationException {
   // Instantiate the bean.
   BeanWrapper instanceWrapper = null;
   if (mbd.isSingleton()) {
      instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
   }
   if (instanceWrapper == null) {
      /**
       * 创建 bean 实例，并将实例包裹在 BeanWrapper 实现类对象中返回。
       * createBeanInstance中包含三种创建 bean 实例的方式：
       *     1.通过工厂方法创建 bean 实例
       *     2.通过构造方法自动注入（autowire by constructor）的方式创建 bean 实例
       *     3.通过无参构造方法创建 bean 实例
       *
       *     若 bean 的配置信息中配置了 lookup-method 和 replace-method，则会
       *     增强 bean 实例。
       */
      instanceWrapper = createBeanInstance(beanName, mbd, args);
   }
   final Object bean = instanceWrapper.getWrappedInstance();
   Class&amp;lt;?&amp;gt; beanType = instanceWrapper.getWrappedClass();
   if (beanType != NullBean.class) {
      mbd.resolvedTargetType = beanType;
   }
   // Allow post-processors to modify the merged bean definition.
   synchronized (mbd.postProcessingLock) {
      if (!mbd.postProcessed) {
         try {
            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
         }
         catch (Throwable ex) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                  &amp;quot;Post-processing of merged bean definition failed&amp;quot;, ex);
         }
         mbd.postProcessed = true;
      }
   }
   // Eagerly cache singletons to be able to resolve circular references
   // even when triggered by lifecycle interfaces like BeanFactoryAware.
   boolean earlySingletonExposure = (mbd.isSingleton() &amp;amp;&amp;amp; this.allowCircularReferences &amp;amp;&amp;amp;
         isSingletonCurrentlyInCreation(beanName));
   if (earlySingletonExposure) {
      if (logger.isDebugEnabled()) {
         logger.debug(&amp;quot;Eagerly caching bean &#39;&amp;quot; + beanName +
               &amp;quot;&#39; to allow for resolving potential circular references&amp;quot;);
      }
      addSingletonFactory(beanName, () -&amp;gt; getEarlyBeanReference(beanName, mbd, bean));
   }
   // Initialize the bean instance.
   Object exposedObject = bean;
   try {
      // 设置属性，非常重要
      populateBean(beanName, mbd, instanceWrapper);
      // 执行后置处理器，AOP就是在这里完成的处理
      exposedObject = initializeBean(beanName, exposedObject, mbd);
   }
   catch (Throwable ex) {
      if (ex instanceof BeanCreationException &amp;amp;&amp;amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {
         throw (BeanCreationException) ex;
      }
      else {
         throw new BeanCreationException(
               mbd.getResourceDescription(), beanName, &amp;quot;Initialization of bean failed&amp;quot;, ex);
      }
   }
   if (earlySingletonExposure) {
      Object earlySingletonReference = getSingleton(beanName, false);
      if (earlySingletonReference != null) {
         if (exposedObject == bean) {
            exposedObject = earlySingletonReference;
         }
         else if (!this.allowRawInjectionDespiteWrapping &amp;amp;&amp;amp; hasDependentBean(beanName)) {
            String[] dependentBeans = getDependentBeans(beanName);
            Set&amp;lt;String&amp;gt; actualDependentBeans = new LinkedHashSet&amp;lt;&amp;gt;(dependentBeans.length);
            for (String dependentBean : dependentBeans) {
               if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                  actualDependentBeans.add(dependentBean);
               }
            }
            if (!actualDependentBeans.isEmpty()) {
               throw new BeanCurrentlyInCreationException(beanName,
                     &amp;quot;Bean with name &#39;&amp;quot; + beanName + &amp;quot;&#39; has been injected into other beans [&amp;quot; +
                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
                     &amp;quot;] in its raw version as part of a circular reference, but has eventually been &amp;quot; +
                     &amp;quot;wrapped. This means that said other beans do not use the final version of the &amp;quot; +
                     &amp;quot;bean. This is often the result of over-eager type matching - consider using &amp;quot; +
                     &amp;quot;&#39;getBeanNamesOfType&#39; with the &#39;allowEagerInit&#39; flag turned off, for example.&amp;quot;);
            }
         }
      }
   }
   // Register bean as disposable.
   try {
      registerDisposableBeanIfNecessary(beanName, bean, mbd);
   }
   catch (BeanDefinitionValidationException ex) {
      throw new BeanCreationException(
            mbd.getResourceDescription(), beanName, &amp;quot;Invalid destruction signature&amp;quot;, ex);
   }
   return exposedObject;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 51 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;addSingletonFactory(beanName, () -&amp;gt; getEarlyBeanReference(beanName, mbd, bean));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DefaultSingletonBeanRegistry#addSingletonFactory&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void addSingletonFactory(String beanName, ObjectFactory&amp;lt;?&amp;gt; singletonFactory) {
   Assert.notNull(singletonFactory, &amp;quot;Singleton factory must not be null&amp;quot;);
   synchronized (this.singletonObjects) {
      // 判断有没有实例化完成：singletonObjects 放的是原来已经实例化好的对象
      if (!this.singletonObjects.containsKey(beanName)) {
         this.singletonFactories.put(beanName, singletonFactory);
         this.earlySingletonObjects.remove(beanName);
         this.registeredSingletons.add(beanName);
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;spring-的对象有四种状态&#34;&gt;Spring 的对象有四种状态：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Bean 原生对象：把 Bean 创建出来，不存在于任何集合中&lt;/li&gt;
&lt;li&gt;放到 singletonFactories 中的对象：&lt;/li&gt;
&lt;li&gt;放到 earlySingletonObjects 中的对象：过渡对象：已经被 new 出来的，但是属性没有填充&lt;/li&gt;
&lt;li&gt;放到 singletonObjects 中的对象：已经实例化好的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;populatebean&#34;&gt;populateBean&lt;/h2&gt;
&lt;p&gt;上述代码第 58 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 设置属性，非常重要：通过后置处理器填充属性
populateBean(beanName, mbd, instanceWrapper);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主要使用两个后置处理器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CommonAnnotationBeanPostProcessor：主要处理 @Resource、@PostConstruct 和 @PreDestory 注解&lt;/li&gt;
&lt;li&gt;AutowiredAnnotationBeanPostProcessor：处理 @Autowired 注解&lt;/li&gt;
&lt;/ul&gt;
">Spring系列（十五）Spring源码解析——特殊构造方法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/spring-xi-lie-shi-si-spring-yuan-ma-jie-xi/"" data-c="
          &lt;h1 id=&#34;preinstantiatesingletons&#34;&gt;preInstantiateSingletons&lt;/h1&gt;
&lt;p&gt;AnnotationConfigApplicationContext#refresh() --&amp;gt; AbstractApplicationContext#finishBeanFactoryInitialization --&amp;gt; DefaultListableBeanFactory#preInstantiateSingletons：准备实例化单例对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void preInstantiateSingletons() throws BeansException {
   if (logger.isDebugEnabled()) {
      logger.debug(&amp;quot;Pre-instantiating singletons in &amp;quot; + this);
   }
   // Iterate over a copy to allow for init methods which in turn register new bean definitions.
   // While this may not be part of the regular factory bootstrap, it does otherwise work fine.
   // beanNames：BeanDefinitionMap中所有类的名字
   List&amp;lt;String&amp;gt; beanNames = new ArrayList&amp;lt;&amp;gt;(this.beanDefinitionNames);
   // Trigger initialization of all non-lazy singleton beans...
   // 触发所有非 Lazy 单例 beans 的初始化，主要步骤为调用 getBean
   for (String beanName : beanNames) {
      // 通过 beanName 得到 BeanDefinition，合并父类 BeanDefinition
      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
      // 如果这个 bd 是非抽象的、单例、非懒加载的：懒加载一开始不会实例化
      if (!bd.isAbstract() &amp;amp;&amp;amp; bd.isSingleton() &amp;amp;&amp;amp; !bd.isLazyInit()) {
         if (isFactoryBean(beanName)) {
            // 如果是 FactoryBean 则加上 &amp;amp;
            Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
            // 判断这个 bean 是不是 FactoryBean
            if (bean instanceof FactoryBean) {
               final FactoryBean&amp;lt;?&amp;gt; factory = (FactoryBean&amp;lt;?&amp;gt;) bean;
               boolean isEagerInit;
               if (System.getSecurityManager() != null &amp;amp;&amp;amp; factory instanceof SmartFactoryBean) {
                  isEagerInit = AccessController.doPrivileged((PrivilegedAction&amp;lt;Boolean&amp;gt;)
                              ((SmartFactoryBean&amp;lt;?&amp;gt;) factory)::isEagerInit,
                        getAccessControlContext());
               }
               else {
                  isEagerInit = (factory instanceof SmartFactoryBean &amp;amp;&amp;amp;
                        ((SmartFactoryBean&amp;lt;?&amp;gt;) factory).isEagerInit());
               }
               if (isEagerInit) {
                  getBean(beanName);
               }
            }
         }
         else {
            getBean(beanName);
         }
      }
   }
   // Trigger post-initialization callback for all applicable beans...
   for (String beanName : beanNames) {
      Object singletonInstance = getSingleton(beanName);
      if (singletonInstance instanceof SmartInitializingSingleton) {
         final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
         if (System.getSecurityManager() != null) {
            AccessController.doPrivileged((PrivilegedAction&amp;lt;Object&amp;gt;) () -&amp;gt; {
               smartSingleton.afterSingletonsInstantiated();
               return null;
            }, getAccessControlContext());
         }
         else {
            smartSingleton.afterSingletonsInstantiated();
         }
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 15行合并父类，案例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&amp;quot;&amp;gt;
   &amp;lt;bean id=&amp;quot;parent&amp;quot; class=&amp;quot;com.ssm.service.IndexService&amp;quot;&amp;gt;
      &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;parent&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
   &amp;lt;/bean&amp;gt;
   &amp;lt;bean id=&amp;quot;child&amp;quot; parent=&amp;quot;parent&amp;quot;&amp;gt;
      &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;children&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
   &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
@ImportResource(&amp;quot;classpath:spring.xml&amp;quot;)
public class AppConfig {
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class IndexService {
   private String name;
   public String getName(){
      return name;
   }
   public void setName(String name){
      this.name = name;
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
   public static void main(String[] args) {
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext(AppConfig.class);
      IndexService indexService = (IndexService) context.getBean(&amp;quot;parent&amp;quot;);
      System.out.println(indexService.getName());
      IndexService child = (IndexService) context.getBean(&amp;quot;child&amp;quot;);
      System.out.println(child.getName());
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;``&lt;br&gt;
parent&lt;br&gt;
children&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
当 Spring 实例化时，首先把所有类都扫描出来，放到 BeanDefinitionMap 中，从 map 中把所有名字都拿出来。
Spring 工厂的 IOC 容器两方面体现：

* 宏观方面：Spring环境，包括Bean工厂，包括Spring内部处理器，包括读取器、注册器...
* 微观方面：private final Map&amp;lt;String, Object&amp;gt; singletonObjects = new ConcurrentHashMap&amp;lt;&amp;gt;(256);

## getBean(beanName);

上述代码第 40 行：

```java
getBean(beanName);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;AbstractBeanFactory#getBean&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Object getBean(String name) throws BeansException {
   return doGetBean(name, null, null, false);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;dogetbean&#34;&gt;doGetBean&lt;/h3&gt;
&lt;p&gt;AbstractBeanFactory#doGetBean&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected &amp;lt;T&amp;gt; T doGetBean(final String name, @Nullable final Class&amp;lt;T&amp;gt; requiredType,
      @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {
   /**
    * 通过 name 获取 beanName，这里不使用 name 直接作为 beanName 有两个原因：
    *     1.name 可能会以 &amp;amp; 字符开头，表名调用者想获取 FactoryBean 本身，而非 FactoryBean
    *     实现类锁创建的 bean。在 Spring 工厂中，FactoryBean 的实现类和其他的普通 bean 存储
    *     方式是一致的，即&amp;lt;beanName, bean&amp;gt;，beanName 中是没有 &amp;amp; 这个字符的。所以我们需要
    *     将 name 的首字符 &amp;amp; 移除，这样才能从缓存里取到 FactoryBean 实例。
    * 2.还是别名的问题，转换需要
    */
   final String beanName = transformedBeanName(name);
   Object bean;
   /**
    * 这个方法在初始化的时候会调用，在 getBean 的时候也会调用
    * 为什么需要这么做呢？
    * 也就是说 Spring 在初始化的时候先获取这个对象，判断这个对象是否被实例化好了
    * （一般情况下为空，因为在初始化阶段，还未初始化结束，所以为空 === 有一种情况可能不为空）
    * 从 Spring 的 Bean 容器中获取一个 bean，由于 Spring 中 Bean 容器是一个 map（singletonObjects）
    * 所以可以理解 getSingleton(beanName) 等于 beanMap.get(beanName)
    * 由于方法会在 Spring 环境初始化的时候（就是对象被创建的时候调用一次）调用一次
    * 还会在 getBean 的时候调用一次
    * 所以在调试的时候需要特别注意，不能直接断点在这里，
    * 需要先进入到 annotationConfigApplicationContext.getBean(IndexService.class)
    * 之后再来断点，这样就确保了我们是在获取这个 bean 的时候调用的
    *
    * 需要说明的是在初始化时候调用一般都是返回 null
    */
   // Eagerly check singleton cache for manually registered singletons.
   // 先 getSingleton(beanName)，如果拿不到，再去初始化
   Object sharedInstance = getSingleton(beanName);
   if (sharedInstance != null &amp;amp;&amp;amp; args == null) {
      if (logger.isDebugEnabled()) {
         if (isSingletonCurrentlyInCreation(beanName)) {
            logger.debug(&amp;quot;Returning eagerly cached instance of singleton bean &#39;&amp;quot; + beanName +
                  &amp;quot;&#39; that is not fully initialized yet - a consequence of a circular reference&amp;quot;);
         }
         else {
            logger.debug(&amp;quot;Returning cached instance of singleton bean &#39;&amp;quot; + beanName + &amp;quot;&#39;&amp;quot;);
         }
      }
      bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
   }
   else {
      // Fail if we&#39;re already creating this bean instance:
      // We&#39;re assumably within a circular reference.
      /**
       * 原型
       * 如果是原型不应该在初始化的时候创建
       */
      if (isPrototypeCurrentlyInCreation(beanName)) {
         throw new BeanCurrentlyInCreationException(beanName);
      }
      // Check if bean definition exists in this factory.
      BeanFactory parentBeanFactory = getParentBeanFactory();
      if (parentBeanFactory != null &amp;amp;&amp;amp; !containsBeanDefinition(beanName)) {
         // Not found -&amp;gt; check parent.
         String nameToLookup = originalBeanName(name);
         if (parentBeanFactory instanceof AbstractBeanFactory) {
            return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
                  nameToLookup, requiredType, args, typeCheckOnly);
         }
         else if (args != null) {
            // Delegation to parent with explicit args.
            return (T) parentBeanFactory.getBean(nameToLookup, args);
         }
         else {
            // No args -&amp;gt; delegate to standard getBean method.
            return parentBeanFactory.getBean(nameToLookup, requiredType);
         }
      }
      if (!typeCheckOnly) {
         // 添加到 alreadyCreated set集合中，表示他已经创建过一次
         markBeanAsCreated(beanName);
      }
      try {
         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
         checkMergedBeanDefinition(mbd, beanName, args);
         // Guarantee initialization of beans that the current bean depends on.
         String[] dependsOn = mbd.getDependsOn();
         if (dependsOn != null) {
            for (String dep : dependsOn) {
               if (isDependent(beanName, dep)) {
                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        &amp;quot;Circular depends-on relationship between &#39;&amp;quot; + beanName + &amp;quot;&#39; and &#39;&amp;quot; + dep + &amp;quot;&#39;&amp;quot;);
               }
               registerDependentBean(dep, beanName);
               try {
                  getBean(dep);
               }
               catch (NoSuchBeanDefinitionException ex) {
                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        &amp;quot;&#39;&amp;quot; + beanName + &amp;quot;&#39; depends on missing bean &#39;&amp;quot; + dep + &amp;quot;&#39;&amp;quot;, ex);
               }
            }
         }
         // Create bean instance.
         if (mbd.isSingleton()) {
            sharedInstance = getSingleton(beanName, () -&amp;gt; {
               try {
                  return createBean(beanName, mbd, args);
               }
               catch (BeansException ex) {
                  // Explicitly remove instance from singleton cache: It might have been put there
                  // eagerly by the creation process, to allow for circular reference resolution.
                  // Also remove any beans that received a temporary reference to the bean.
                  destroySingleton(beanName);
                  throw ex;
               }
            });
            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
         }
         else if (mbd.isPrototype()) {
            // It&#39;s a prototype -&amp;gt; create a new instance.
            Object prototypeInstance = null;
            try {
               beforePrototypeCreation(beanName);
               prototypeInstance = createBean(beanName, mbd, args);
            }
            finally {
               afterPrototypeCreation(beanName);
            }
            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
         }
         else {
            String scopeName = mbd.getScope();
            final Scope scope = this.scopes.get(scopeName);
            if (scope == null) {
               throw new IllegalStateException(&amp;quot;No Scope registered for scope name &#39;&amp;quot; + scopeName + &amp;quot;&#39;&amp;quot;);
            }
            try {
               Object scopedInstance = scope.get(beanName, () -&amp;gt; {
                  beforePrototypeCreation(beanName);
                  try {
                     return createBean(beanName, mbd, args);
                  }
                  finally {
                     afterPrototypeCreation(beanName);
                  }
               });
               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
            }
            catch (IllegalStateException ex) {
               throw new BeanCreationException(beanName,
                     &amp;quot;Scope &#39;&amp;quot; + scopeName + &amp;quot;&#39; is not active for the current thread; consider &amp;quot; +
                     &amp;quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&amp;quot;,
                     ex);
            }
         }
      }
      catch (BeansException ex) {
         cleanupAfterBeanCreationFailure(beanName);
         throw ex;
      }
   }
   // Check if required type matches the type of the actual bean instance.
   if (requiredType != null &amp;amp;&amp;amp; !requiredType.isInstance(bean)) {
      try {
         T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
         if (convertedBean == null) {
            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
         }
         return convertedBean;
      }
      catch (TypeMismatchException ex) {
         if (logger.isDebugEnabled()) {
            logger.debug(&amp;quot;Failed to convert bean &#39;&amp;quot; + name + &amp;quot;&#39; to required type &#39;&amp;quot; +
                  ClassUtils.getQualifiedName(requiredType) + &amp;quot;&#39;&amp;quot;, ex);
         }
         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
      }
   }
   return (T) bean;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 32 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Object sharedInstance = getSingleton(beanName);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DefaultSingletonBeanRegistry#getSingleton&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Object getSingleton(String beanName) {
   return getSingleton(beanName, true);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DefaultSingletonBeanRegistry#getSingleton&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected Object getSingleton(String beanName, boolean allowEarlyReference) {
   // 从 map 中获取 bean 如果不为空直接返回，不再进行初始化工作
   Object singletonObject = this.singletonObjects.get(beanName);
   // 第一次 getSingleton() 返回空原因：
   // singletonObject=null
   // isSingletonCurrentlyInCreation:Spring认为还没有到需要创建对象的时候
   if (singletonObject == null &amp;amp;&amp;amp; isSingletonCurrentlyInCreation(beanName)) {
      synchronized (this.singletonObjects) {
         singletonObject = this.earlySingletonObjects.get(beanName);
         if (singletonObject == null &amp;amp;&amp;amp; allowEarlyReference) {
            ObjectFactory&amp;lt;?&amp;gt; singletonFactory = this.singletonFactories.get(beanName);
            if (singletonFactory != null) {
               singletonObject = singletonFactory.getObject();
               this.earlySingletonObjects.put(beanName, singletonObject);
               this.singletonFactories.remove(beanName);
            }
         }
      }
   }
   return singletonObject;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 7 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**  正在创建的 bean 名字 */
private final Set&amp;lt;String&amp;gt; singletonsCurrentlyInCreation =
      Collections.newSetFromMap(new ConcurrentHashMap&amp;lt;&amp;gt;(16));
      
public boolean isSingletonCurrentlyInCreation(String beanName) {
   return this.singletonsCurrentlyInCreation.contains(beanName);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;doGetBean 的第 32 行：第一次调用 getSingleton() 返回空，因为上述 getSingleton 的第 7 行判断：singletonObject=null 且 isSingletonCurrentlyInCreation 为 false :Spring认为还没有到需要创建对象的时候。使用：context.getBean() --&amp;gt; getBeanFactory().getBean(name); --&amp;gt; doGetBean(name, null, null, false);&lt;br&gt;
doGetBean 的第 106 行：第二次调用 getSingleton() 不为空，因为 Spring 已经做了该做的验证（比如 checkMergedBeanDefinition 验证 BeanDefinitionMap 有没有错误，有没有DependsOn），如果都成立则把类放到 alreadyCreated set 集合中，然后调用 getSingleton，如果为空则创建对象。使用：初始化时 new&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;sharedInstance = getSingleton(beanName, () -&amp;gt; {
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Object getSingleton(String beanName, ObjectFactory&amp;lt;?&amp;gt; singletonFactory) {
      Assert.notNull(beanName, &amp;quot;Bean name must not be null&amp;quot;);
   synchronized (this.singletonObjects) {
      Object singletonObject = this.singletonObjects.get(beanName);
      if (singletonObject == null) {
         if (this.singletonsCurrentlyInDestruction) {
            throw new BeanCreationNotAllowedException(beanName,
                  &amp;quot;Singleton bean creation not allowed while singletons of this factory are in destruction &amp;quot; +
                  &amp;quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&amp;quot;);
         }
         if (logger.isDebugEnabled()) {
            logger.debug(&amp;quot;Creating shared instance of singleton bean &#39;&amp;quot; + beanName + &amp;quot;&#39;&amp;quot;);
         }
         /**
          * 将 beanName 添加到 singletonCurrentlyInCreation 这样一个 set 集合中
          * 表示 beanName 对应的 bean 正在创建中
          */
         beforeSingletonCreation(beanName);
         boolean newSingleton = false;
         boolean recordSuppressedExceptions = (this.suppressedExceptions == null);
         if (recordSuppressedExceptions) {
            this.suppressedExceptions = new LinkedHashSet&amp;lt;&amp;gt;();
         }
         try {
            singletonObject = singletonFactory.getObject();
            newSingleton = true;
         }
         catch (IllegalStateException ex) {
            // Has the singleton object implicitly appeared in the meantime -&amp;gt;
            // if yes, proceed with it since the exception indicates that state.
            singletonObject = this.singletonObjects.get(beanName);
            if (singletonObject == null) {
               throw ex;
            }
         }
         catch (BeanCreationException ex) {
            if (recordSuppressedExceptions) {
               for (Exception suppressedException : this.suppressedExceptions) {
                  ex.addRelatedCause(suppressedException);
               }
            }
            throw ex;
         }
         finally {
            if (recordSuppressedExceptions) {
               this.suppressedExceptions = null;
            }
            afterSingletonCreation(beanName);
         }
         if (newSingleton) {
            addSingleton(beanName, singletonObject);
         }
      }
      return singletonObject;
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 18 行：将 beanName 添加到 singletonCurrentlyInCreation 这样一个 set 集合中，表示 beanName 对应的 bean 正在创建中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void beforeSingletonCreation(String beanName) {
   if (!this.inCreationCheckExclusions.contains(beanName) &amp;amp;&amp;amp; !this.singletonsCurrentlyInCreation.add(beanName)) {
      throw new BeanCurrentlyInCreationException(beanName);
   }
} 
private final Set&amp;lt;String&amp;gt; singletonsCurrentlyInCreation =
      Collections.newSetFromMap(new ConcurrentHashMap&amp;lt;&amp;gt;(16));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;断点在上述代码第 25 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;singletonObject = singletonFactory.getObject();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后会执行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;return createBean(beanName, mbd, args);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来点进 createBean 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
      throws BeanCreationException {
   if (logger.isDebugEnabled()) {
      logger.debug(&amp;quot;Creating instance of bean &#39;&amp;quot; + beanName + &amp;quot;&#39;&amp;quot;);
   }
   RootBeanDefinition mbdToUse = mbd;
   // Make sure bean class is actually resolved at this point, and
   // clone the bean definition in case of a dynamically resolved Class
   // which cannot be stored in the shared merged bean definition.
   Class&amp;lt;?&amp;gt; resolvedClass = resolveBeanClass(mbd, beanName);
   if (resolvedClass != null &amp;amp;&amp;amp; !mbd.hasBeanClass() &amp;amp;&amp;amp; mbd.getBeanClassName() != null) {
      mbdToUse = new RootBeanDefinition(mbd);
      mbdToUse.setBeanClass(resolvedClass);
   }
   // Prepare method overrides.
   // 处理 lookup-method 和 replace-method 配置，Spring 将这两个配置统称为 MethodOverrides
   try {
      mbdToUse.prepareMethodOverrides();
   }
   catch (BeanDefinitionValidationException ex) {
      throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),
            beanName, &amp;quot;Validation of method overrides failed&amp;quot;, ex);
   }
   try {
      // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
      // 在 bean 实例化前应用后置处理，如果后置处理返回的 bean 不为空，则直接返回，我们这里并没有实现 InstantiationAwareBeanPostProcessor 后置处理器，所以返回的 bean=null
      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
      if (bean != null) {
         return bean;
      }
   }
   catch (Throwable ex) {
      throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,
            &amp;quot;BeanPostProcessor before instantiation of bean failed&amp;quot;, ex);
   }
   try {
      Object beanInstance = doCreateBean(beanName, mbdToUse, args);
      if (logger.isDebugEnabled()) {
         logger.debug(&amp;quot;Finished creating instance of bean &#39;&amp;quot; + beanName + &amp;quot;&#39;&amp;quot;);
      }
      return beanInstance;
   }
   catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {
      // A previously detected exception with proper bean creation context already,
      // or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.
      throw ex;
   }
   catch (Throwable ex) {
      throw new BeanCreationException(
            mbdToUse.getResourceDescription(), beanName, &amp;quot;Unexpected exception during bean creation&amp;quot;, ex);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 31 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {
   Object bean = null;
   if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {
      // Make sure bean class is actually resolved at this point.
      if (!mbd.isSynthetic() &amp;amp;&amp;amp; hasInstantiationAwareBeanPostProcessors()) {
         Class&amp;lt;?&amp;gt; targetType = determineTargetType(beanName, mbd);
         if (targetType != null) {
            // 执行后置处理器，如果有一个类中有一些属性不需要交给 Spring 处理，就实现InstantiationAwareBeanPostProcessor后置处理器，通过这个后置处理器返回一个 Bean
            bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);
            if (bean != null) {
               bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);
            }
         }
      }
      mbd.beforeInstantiationResolved = (bean != null);
   }
   return bean;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行了一个后置处理器，后置处理器是对 Bean 的生产进行插手的，但是现在这个 Bean 并没有产生出来，后置处理器是做什么的呢？&lt;br&gt;
如果有一个类中有一些属性不需要交给 Spring 处理，就实现 InstantiationAwareBeanPostProcessor 后置处理器，通过这个后置处理器返回一个 Bean，如果这个 Bean 不为空，就直接返回这个 Bean。&lt;/p&gt;
&lt;p&gt;上述代码第 9 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected Object applyBeanPostProcessorsBeforeInstantiation(Class&amp;lt;?&amp;gt; beanClass, String beanName) {
   for (BeanPostProcessor bp : getBeanPostProcessors()) {
      // 如果一个类实现了 InstantiationAwareBeanPostProcessor 后置处理器
      if (bp instanceof InstantiationAwareBeanPostProcessor) {
         InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
         // 实现了 InstantiationAwareBeanPostProcessor 后置处理器的类，就可以通过重写 postProcessBeforeInstantiation 方法返回一个真实的 Bean 对象
         Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);
         if (result != null) {
            return result;
         }
      }
   }
   return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现了 InstantiationAwareBeanPostProcessor 后置处理器的类，可以通过重写 postProcessBeforeInstantiation 方法返回一个真实的 Bean 对象：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;default Object postProcessBeforeInstantiation(Class&amp;lt;?&amp;gt; beanClass, String beanName) throws BeansException {
   return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码 createBean 方法第 42 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Object beanInstance = doCreateBean(beanName, mbdToUse, args);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
      throws BeanCreationException {
   // Instantiate the bean.
   BeanWrapper instanceWrapper = null;
   if (mbd.isSingleton()) {
      instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
   }
   if (instanceWrapper == null) {
      /**
       * 创建 bean 实例，并将实例包裹在 BeanWrapper 实现类对象中返回。
       * createBeanInstance中包含三种创建 bean 实例的方式：
       *     1.通过工厂方法创建 bean 实例
       *     2.通过构造方法自动注入（autowire by constructor）的方式创建 bean 实例
       *     3.通过无参构造方法创建 bean 实例
       *
       *     若 bean 的配置信息中配置了 lookup-method 和 replace-method，则会
       *     增强 bean 实例。
       */
      instanceWrapper = createBeanInstance(beanName, mbd, args);
   }
   final Object bean = instanceWrapper.getWrappedInstance();
   Class&amp;lt;?&amp;gt; beanType = instanceWrapper.getWrappedClass();
   if (beanType != NullBean.class) {
      mbd.resolvedTargetType = beanType;
   }
   // Allow post-processors to modify the merged bean definition.
   synchronized (mbd.postProcessingLock) {
      if (!mbd.postProcessed) {
         try {
            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
         }
         catch (Throwable ex) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                  &amp;quot;Post-processing of merged bean definition failed&amp;quot;, ex);
         }
         mbd.postProcessed = true;
      }
   }
   // Eagerly cache singletons to be able to resolve circular references
   // even when triggered by lifecycle interfaces like BeanFactoryAware.
   boolean earlySingletonExposure = (mbd.isSingleton() &amp;amp;&amp;amp; this.allowCircularReferences &amp;amp;&amp;amp;
         isSingletonCurrentlyInCreation(beanName));
   if (earlySingletonExposure) {
      if (logger.isDebugEnabled()) {
         logger.debug(&amp;quot;Eagerly caching bean &#39;&amp;quot; + beanName +
               &amp;quot;&#39; to allow for resolving potential circular references&amp;quot;);
      }
      addSingletonFactory(beanName, () -&amp;gt; getEarlyBeanReference(beanName, mbd, bean));
   }
   // Initialize the bean instance.
   Object exposedObject = bean;
   try {
      // 设置属性，非常重要
      populateBean(beanName, mbd, instanceWrapper);
      // 执行后置处理器，AOP就是在这里完成的处理
      exposedObject = initializeBean(beanName, exposedObject, mbd);
   }
   catch (Throwable ex) {
      if (ex instanceof BeanCreationException &amp;amp;&amp;amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {
         throw (BeanCreationException) ex;
      }
      else {
         throw new BeanCreationException(
               mbd.getResourceDescription(), beanName, &amp;quot;Initialization of bean failed&amp;quot;, ex);
      }
   }
   if (earlySingletonExposure) {
      Object earlySingletonReference = getSingleton(beanName, false);
      if (earlySingletonReference != null) {
         if (exposedObject == bean) {
            exposedObject = earlySingletonReference;
         }
         else if (!this.allowRawInjectionDespiteWrapping &amp;amp;&amp;amp; hasDependentBean(beanName)) {
            String[] dependentBeans = getDependentBeans(beanName);
            Set&amp;lt;String&amp;gt; actualDependentBeans = new LinkedHashSet&amp;lt;&amp;gt;(dependentBeans.length);
            for (String dependentBean : dependentBeans) {
               if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                  actualDependentBeans.add(dependentBean);
               }
            }
            if (!actualDependentBeans.isEmpty()) {
               throw new BeanCurrentlyInCreationException(beanName,
                     &amp;quot;Bean with name &#39;&amp;quot; + beanName + &amp;quot;&#39; has been injected into other beans [&amp;quot; +
                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
                     &amp;quot;] in its raw version as part of a circular reference, but has eventually been &amp;quot; +
                     &amp;quot;wrapped. This means that said other beans do not use the final version of the &amp;quot; +
                     &amp;quot;bean. This is often the result of over-eager type matching - consider using &amp;quot; +
                     &amp;quot;&#39;getBeanNamesOfType&#39; with the &#39;allowEagerInit&#39; flag turned off, for example.&amp;quot;);
            }
         }
      }
   }
   // Register bean as disposable.
   try {
      registerDisposableBeanIfNecessary(beanName, bean, mbd);
   }
   catch (BeanDefinitionValidationException ex) {
      throw new BeanCreationException(
            mbd.getResourceDescription(), beanName, &amp;quot;Invalid destruction signature&amp;quot;, ex);
   }
   return exposedObject;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;createbeaninstance&#34;&gt;createBeanInstance&lt;/h4&gt;
&lt;p&gt;上述代码第 20 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {
   // Make sure bean class is actually resolved at this point.
   Class&amp;lt;?&amp;gt; beanClass = resolveBeanClass(mbd, beanName);
   /**
    * 检测一个类的访问权限 Spring 默认情况下对于非 public 的类是允许访问的。
    */
   if (beanClass != null &amp;amp;&amp;amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;amp;&amp;amp; !mbd.isNonPublicAccessAllowed()) {
      throw new BeanCreationException(mbd.getResourceDescription(), beanName,
            &amp;quot;Bean class isn&#39;t public, and non-public access not allowed: &amp;quot; + beanClass.getName());
   }
   Supplier&amp;lt;?&amp;gt; instanceSupplier = mbd.getInstanceSupplier();
   if (instanceSupplier != null) {
      return obtainFromSupplier(instanceSupplier, beanName);
   }
   /**
    * 如果工厂方法不为空，则通过工厂方法创建 bean 对象，在这里直接 return，就不会再去执行下面的 Shortcut 等语句了。
    * 这种构建 bean 的方式可以参考以下 demo
    */
   if (mbd.getFactoryMethodName() != null) {
      return instantiateUsingFactoryMethod(beanName, mbd, args);
   }
   // Shortcut when re-creating the same bean...
   /**
    * 从 Spring 的原始注释可以知道这是一个 Shortcut，什么意思呢？
    * 当多次构建同一个 bean 时，可以使用这个 Shortcut，
    * 也就是说不在需要此腿短应该使用哪种方式构造 bean
    * 比如在多次构建同一个 prototype 类型的 bean 时，就可以走此处的 Shortcut
    * 这里的 resolved  和 mbd.constructorArgumentsResolved 将会在 bean 第一次实例化的过程中被设置，后面来证明
    */
   boolean resolved = false;
   boolean autowireNecessary = false;
   if (args == null) {
      synchronized (mbd.constructorArgumentLock) {
         if (mbd.resolvedConstructorOrFactoryMethod != null) {
            resolved = true;
            // 如果已经解析了构造方法的参数，则必须要通过一个带参构造方法来实例
            autowireNecessary = mbd.constructorArgumentsResolved;
         }
      }
   }
   if (resolved) {
      if (autowireNecessary) {
         // 通过构造方法自动装配的方式构造 bean 对象
         return autowireConstructor(beanName, mbd, null, null);
      }
      else {
         // 通过默认的无参构造方法进行
         return instantiateBean(beanName, mbd);
      }
   }
   // Candidate constructors for autowiring?
   // 由后置处理器决定返回哪些构造方法
   Constructor&amp;lt;?&amp;gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
   if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
      return autowireConstructor(beanName, mbd, ctors, args);
   }
   // No special handling: simply use no-arg constructor.
   // 使用默认的无参构造方法进行初始化
   return instantiateBean(beanName, mbd);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;演示-factorymethod-的-demo1&#34;&gt;演示 FactoryMethod 的 demo1&lt;/h4&gt;
&lt;p&gt;上述代码第 22 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//  按照以下demo，当执行到这行代码，发现有一个 FactoryMethod， 就调用 instantiateUsingFactoryMethod 方法去创建
if (mbd.getFactoryMethodName() != null) {
  return instantiateUsingFactoryMethod(beanName, mbd, args);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Spring 要实例化一个 Bean，会经过一个 getSingleton() 方法，经过一系列判断后，会进入 createBeanInstance() 方法：先判断这个 BeanDefinition 中有没有 FactoryMethod 属性，如果有，则调用 FactoryMethod 去创建对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&amp;quot;&amp;gt;
   &amp;lt;bean id=&amp;quot;order&amp;quot; class=&amp;quot;com.ssm.service.OrderService&amp;quot; factory-method=&amp;quot;query&amp;quot;&amp;gt;
   &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
@ImportResource(&amp;quot;classpath:spring.xml&amp;quot;)
public class AppConfig {
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Luban {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class OrderService {
   public static Object query(){
      return new Luban();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为在 xml 中使用了 factory-method 进行配置，所以会将 Luban 对象放到 Spring 容器中去，因此通过 beanName=&amp;quot;order&amp;quot; 拿出的对象也是 Luban。&lt;br&gt;
测试类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
   public static void main(String[] args) {
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext(AppConfig.class);
      System.out.println(context.getBean(&amp;quot;order&amp;quot;));
      System.out.println(context.getBean(OrderService.class));
      System.out.println(context.getBean(Luban.class));
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;com.ssm.app.Luban@7c30a502
com.ssm.service.OrderService@49e4cb85
com.ssm.app.Luban@7c30a502
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;演示-factorymethod-的-demo2&#34;&gt;演示 FactoryMethod 的 demo2&lt;/h4&gt;
&lt;p&gt;另一个演示 FactoryMethod 的 demo，被 @Bean 修饰的 static 相当于给这个 bean 添加了一个 factory-method：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
public class AppConfig {
   @Bean
   public static IndexService indexService(){
      return new IndexService();
   }
   @Bean
   public OrderService orderService(){
      indexService();
      return new OrderService();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按照上述代码，IndexService 会调用两次初始化。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class IndexService {
   public IndexService(){
      System.out.println(&amp;quot;IndexService...constructor&amp;quot;);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IndexService...constructor
IndexService...constructor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是如果去掉 static，IndexService 只会调用一次初始化。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
public class AppConfig {
   @Bean
   public IndexService indexService(){
      return new IndexService();
   }
   @Bean
   public OrderService orderService(){
      indexService();
      return new OrderService();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;IndexService...constructor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ConfigurationClassPostProcessor#processConfigBeanDefinitions：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// configClasses 拿到了 @Import、@Service、@Bean
this.reader.loadBeanDefinitions(configClasses);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ConfigurationClassBeanDefinitionReader#loadBeanDefinitions --&amp;gt; ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForConfigurationClass：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 如果一个类是 @Bean，会循环拿出所有加了 @Bean 的方法
for (BeanMethod beanMethod : configClass.getBeanMethods()) {
   loadBeanDefinitionsForBeanMethod(beanMethod);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForBeanMethod：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 如果这个方法是 static 的，相当于为这个 Bean 配置了一个 factory-method=&amp;quot;index&amp;quot;， 即&amp;lt;bean id=&amp;quot;indexService&amp;quot; class=&amp;quot;com.ssm.service.IndexService&amp;quot; factory-method=&amp;quot;indexService&amp;quot;&amp;gt;
if (metadata.isStatic()) {
   // static @Bean method
   beanDef.setBeanClassName(configClass.getMetadata().getClassName());
   // 设置 FactoryMethod
   beanDef.setFactoryMethodName(methodName);
}
// 如果这个方法不是 static 的
else {
   // instance @Bean method
   beanDef.setFactoryBeanName(configClass.getBeanName());
   // 设置  UniqueFactoryMethod
   beanDef.setUniqueFactoryMethodName(methodName);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;shortcut-快捷方式&#34;&gt;Shortcut 快捷方式&lt;/h1&gt;
&lt;h2 id=&#34;无参构造方法&#34;&gt;无参构造方法&lt;/h2&gt;
&lt;p&gt;首先声明 IndexService 中有一个无参构造方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class IndexService {
   public IndexService(){
      System.out.println(&amp;quot;IndexService...constructor&amp;quot;);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;当重新创建同一个 Bean 的时候使用 Shortcut 快捷方式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;createBeanInstance 的第 27-67 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 当重新创建同一个 Bean 的时候使用 Shortcut 快捷方式
/**
 * 从 Spring 的原始注释可以知道这是一个 Shortcut，什么意思呢？
 * 当多次构建同一个 bean 时，可以使用这个 Shortcut，
 * 也就是说不在需要此腿短应该使用哪种方式构造 bean
 * 比如在多次构建同一个 prototype 类型的 bean 时，就可以走此处的 Shortcut
 * 这里的 resolved  和 mbd.constructorArgumentsResolved 将会在 bean 第一次实例化的过程中被设置，后面来证明
 */
boolean resolved = false;
// 必须自动装配
boolean autowireNecessary = false;
if (args == null) {
   synchronized (mbd.constructorArgumentLock) {
      // 如果是一个 FactoryMethod 创建的，就会把 resolved 设置为 true
      if (mbd.resolvedConstructorOrFactoryMethod != null) {
         resolved = true;
         // 如果已经解析了构造方法的参数，则必须要通过一个带参构造方法来实例
         autowireNecessary = mbd.constructorArgumentsResolved;
      }
   }
}
if (resolved) {
   if (autowireNecessary) {
      // 通过构造方法自动装配的方式构造 bean 对象
      return autowireConstructor(beanName, mbd, null, null);
   }
   else {
      // 通过默认的无参构造方法进行
      return instantiateBean(beanName, mbd);
   }
}
// Candidate constructors for autowiring?
// 由后置处理器决定返回哪些构造方法
   Constructor&amp;lt;?&amp;gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
      mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
   return autowireConstructor(beanName, mbd, ctors, args);
}
// No special handling: simply use no-arg constructor.
// 使用默认的无参构造方法进行初始化
return instantiateBean(beanName, mbd);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Spring 在构建对象的时候，要知道这个对象如何构建，利用构造方法还是默认的构造方法，通过 autowireNecessary 值来记录，当第二次被实例化时，直接判断 autowireNecessary 的值即可。&lt;br&gt;
上述代码第 35 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//  拿出构造方法，然后决定用哪个构造方法进行实例化
Constructor&amp;lt;?&amp;gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/FZ9Tj8MwpTCVHFpr.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Spring 得到构造方法，然后通过构造方法去 new 对象。&lt;/p&gt;
&lt;p&gt;IndexService 中有一个无参构造方法，Spring 会认为它没有构造方法，如上图 determineConstructorsFromBeanPostProcessors 方法返回 null，然后执行 instantiateBean 方法去创建对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected Constructor&amp;lt;?&amp;gt;[] determineConstructorsFromBeanPostProcessors(@Nullable Class&amp;lt;?&amp;gt; beanClass, String beanName)
      throws BeansException {
   // 是否有 InstantiationAwareBeanPostProcessors 后置处理器
   if (beanClass != null &amp;amp;&amp;amp; hasInstantiationAwareBeanPostProcessors()) {
      for (BeanPostProcessor bp : getBeanPostProcessors()) {
         // 如果有 SmartInstantiationAwareBeanPostProcessor 后置处理器
         if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
            SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;
            Constructor&amp;lt;?&amp;gt;[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);
            if (ctors != null) {
               return ctors;
            }
         }
      }
   }
   return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 9 行，首先这个 SmartInstantiationAwareBeanPostProcessor 后置处理器什么都没做，直接 return null;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Constructor&amp;lt;?&amp;gt;[] determineCandidateConstructors(Class&amp;lt;?&amp;gt; beanClass, String beanName) throws BeansException {
   return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再进行下一轮循环，这个后置处理器的操作非常复杂了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Constructor&amp;lt;?&amp;gt;[] determineCandidateConstructors(Class&amp;lt;?&amp;gt; beanClass, final String beanName)
      throws BeanCreationException {
   // Let&#39;s check for lookup methods here...
   if (!this.lookupMethodsChecked.contains(beanName)) {
      try {
         ReflectionUtils.doWithMethods(beanClass, method -&amp;gt; {
            Lookup lookup = method.getAnnotation(Lookup.class);
            if (lookup != null) {
               Assert.state(this.beanFactory != null, &amp;quot;No BeanFactory available&amp;quot;);
               LookupOverride override = new LookupOverride(method, lookup.value());
               try {
                  RootBeanDefinition mbd = (RootBeanDefinition)
                        this.beanFactory.getMergedBeanDefinition(beanName);
                  mbd.getMethodOverrides().addOverride(override);
               }
               catch (NoSuchBeanDefinitionException ex) {
                  throw new BeanCreationException(beanName,
                        &amp;quot;Cannot apply @Lookup to beans without corresponding bean definition&amp;quot;);
               }
            }
         });
      }
      catch (IllegalStateException ex) {
         throw new BeanCreationException(beanName, &amp;quot;Lookup method resolution failed&amp;quot;, ex);
      }
      this.lookupMethodsChecked.add(beanName);
   }
   // Quick check on the concurrent map first, with minimal locking.
   // 从构造方法的缓存中拿一个构造方法
   Constructor&amp;lt;?&amp;gt;[] candidateConstructors = this.candidateConstructorsCache.get(beanClass);
   if (candidateConstructors == null) {
      // Fully synchronized resolution now...
      synchronized (this.candidateConstructorsCache) {
         candidateConstructors = this.candidateConstructorsCache.get(beanClass);
         if (candidateConstructors == null) {
            Constructor&amp;lt;?&amp;gt;[] rawCandidates;
            try {
               // 通过反射得到 IndexService 的构造方法
               rawCandidates = beanClass.getDeclaredConstructors();
            }
            catch (Throwable ex) {
               throw new BeanCreationException(beanName,
                     &amp;quot;Resolution of declared constructors on bean Class [&amp;quot; + beanClass.getName() +
                     &amp;quot;] from ClassLoader [&amp;quot; + beanClass.getClassLoader() + &amp;quot;] failed&amp;quot;, ex);
            }
            List&amp;lt;Constructor&amp;lt;?&amp;gt;&amp;gt; candidates = new ArrayList&amp;lt;&amp;gt;(rawCandidates.length);
            Constructor&amp;lt;?&amp;gt; requiredConstructor = null;
            Constructor&amp;lt;?&amp;gt; defaultConstructor = null;
            Constructor&amp;lt;?&amp;gt; primaryConstructor = BeanUtils.findPrimaryConstructor(beanClass);
            int nonSyntheticConstructors = 0;
            for (Constructor&amp;lt;?&amp;gt; candidate : rawCandidates) {
               if (!candidate.isSynthetic()) {
                  nonSyntheticConstructors++;
               }
               else if (primaryConstructor != null) {
                  continue;
               }
               AnnotationAttributes ann = findAutowiredAnnotation(candidate);
               if (ann == null) {
                  Class&amp;lt;?&amp;gt; userClass = ClassUtils.getUserClass(beanClass);
                  if (userClass != beanClass) {
                     try {
                        Constructor&amp;lt;?&amp;gt; superCtor =
                              userClass.getDeclaredConstructor(candidate.getParameterTypes());
                        ann = findAutowiredAnnotation(superCtor);
                     }
                     catch (NoSuchMethodException ex) {
                        // Simply proceed, no equivalent superclass constructor found...
                     }
                  }
               }
               if (ann != null) {
                  if (requiredConstructor != null) {
                     throw new BeanCreationException(beanName,
                           &amp;quot;Invalid autowire-marked constructor: &amp;quot; + candidate +
                           &amp;quot;. Found constructor with &#39;required&#39; Autowired annotation already: &amp;quot; +
                           requiredConstructor);
                  }
                  boolean required = determineRequiredStatus(ann);
                  if (required) {
                     if (!candidates.isEmpty()) {
                        throw new BeanCreationException(beanName,
                              &amp;quot;Invalid autowire-marked constructors: &amp;quot; + candidates +
                              &amp;quot;. Found constructor with &#39;required&#39; Autowired annotation: &amp;quot; +
                              candidate);
                     }
                     requiredConstructor = candidate;
                  }
                  candidates.add(candidate);
               }
               // 如果构造方法的参数=0，即无参构造方法
               else if (candidate.getParameterCount() == 0) {
                  defaultConstructor = candidate;
               }
            }
            if (!candidates.isEmpty()) {
               // Add default constructor to list of optional constructors, as fallback.
               if (requiredConstructor == null) {
                  if (defaultConstructor != null) {
                     candidates.add(defaultConstructor);
                  }
                  else if (candidates.size() == 1 &amp;amp;&amp;amp; logger.isWarnEnabled()) {
                     logger.warn(&amp;quot;Inconsistent constructor declaration on bean with name &#39;&amp;quot; + beanName +
                           &amp;quot;&#39;: single autowire-marked constructor flagged as optional - &amp;quot; +
                           &amp;quot;this constructor is effectively required since there is no &amp;quot; +
                           &amp;quot;default constructor to fall back to: &amp;quot; + candidates.get(0));
                  }
               }
               candidateConstructors = candidates.toArray(new Constructor&amp;lt;?&amp;gt;[0]);
            }
            // 如果有 1个 构造方法，且构造方法有参数
            else if (rawCandidates.length == 1 &amp;amp;&amp;amp; rawCandidates[0].getParameterCount() &amp;gt; 0) {
               candidateConstructors = new Constructor&amp;lt;?&amp;gt;[] {rawCandidates[0]};
            }
            // 如果有 2个 构造方法，且主要的构造方法不为空且...
            else if (nonSyntheticConstructors == 2 &amp;amp;&amp;amp; primaryConstructor != null &amp;amp;&amp;amp;
                  defaultConstructor != null &amp;amp;&amp;amp; !primaryConstructor.equals(defaultConstructor)) {
               candidateConstructors = new Constructor&amp;lt;?&amp;gt;[] {primaryConstructor, defaultConstructor};
            }
            // 如果有 1个 构造方法，且构造方法参数不为空
            else if (nonSyntheticConstructors == 1 &amp;amp;&amp;amp; primaryConstructor != null) {
               candidateConstructors = new Constructor&amp;lt;?&amp;gt;[] {primaryConstructor};
            }
            else {
               // 因为  IndexService 内有一个无参构造方法，所以上述三个 else if 判断都不成立，所以会进入 else 分支
               candidateConstructors = new Constructor&amp;lt;?&amp;gt;[0];
            }
            this.candidateConstructorsCache.put(beanClass, candidateConstructors);
         }
      }
   }
   return (candidateConstructors.length &amp;gt; 0 ? candidateConstructors : null);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 41 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;rawCandidates = beanClass.getDeclaredConstructors();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/mWIAbxNGJdjVMIGW.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/6pMDddCa1pKMHuyv.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;有参构造方法&#34;&gt;有参构造方法&lt;/h2&gt;
&lt;p&gt;如果为 IndexService 添加了一个 有参构造方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class IndexService {
   public IndexService(String str){
      System.out.println(&amp;quot;IndexService...constructor&amp;quot;);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/PMA5pOIPRlLi8GVH.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Constructor&amp;lt;?&amp;gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
      mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
   return autowireConstructor(beanName, mbd, ctors, args);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有参构造方法就会调用 autowireConstructor 方法创建对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected BeanWrapper autowireConstructor(
      String beanName, RootBeanDefinition mbd, @Nullable Constructor&amp;lt;?&amp;gt;[] ctors, @Nullable Object[] explicitArgs) {
   return new ConstructorResolver(this).autowireConstructor(beanName, mbd, ctors, explicitArgs);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public ConstructorResolver(AbstractAutowireCapableBeanFactory beanFactory) {
   this.beanFactory = beanFactory;
   this.logger = beanFactory.getLogger();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd,
      @Nullable Constructor&amp;lt;?&amp;gt;[] chosenCtors, @Nullable Object[] explicitArgs) {
   // 实例一个 BeanWrapperImpl 对象
   // 前面外部返回的 BeanWrapper 其实就是这个 BeanWrapperImpl
   // 因为 BeanWrapper 是个接口
   BeanWrapperImpl bw = new BeanWrapperImpl();
   this.beanFactory.initBeanWrapper(bw);
   // Spring 决定采用哪个构造方法来实例化 bean，把这个构造方法使用 constructorToUse 变量暂存起来
   // 代码执行到这里 Spring 已经决定要采用一个特殊构造方法来实例 bean
   Constructor&amp;lt;?&amp;gt; constructorToUse = null;
   // 构造方法的值，构造方法通过反射来实例化一个对象
   // 但是这里需要注意的是 argsHolderToUse 是一个数据结构
   // argsToUse[] 才是真正的值
   ArgumentsHolder argsHolderToUse = null;
   Object[] argsToUse = null;
   // 确定参数值列表
   /**
    * explicitArgs 是从 createBeanInstance 方法传过来的，构造方法的值
    * org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBeanInstance
    * 可以看到如果从 createBeanInstance 调用那么永远为空
    */
   if (explicitArgs != null) {
      argsToUse = explicitArgs;
   }
   else {
      Object[] argsToResolve = null;
      synchronized (mbd.constructorArgumentLock) {
         constructorToUse = (Constructor&amp;lt;?&amp;gt;) mbd.resolvedConstructorOrFactoryMethod;
         if (constructorToUse != null &amp;amp;&amp;amp; mbd.constructorArgumentsResolved) {
            // Found a cached constructor...
            argsToUse = mbd.resolvedConstructorArguments;
            if (argsToUse == null) {
               argsToResolve = mbd.preparedConstructorArguments;
            }
         }
      }
      if (argsToResolve != null) {
         argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve);
      }
   }
   if (constructorToUse == null) {
      // Need to resolve the constructor.
      // 如果没有已经解析的构造方法
      // 则需要去解析构造方法
      // 判断构造方法是否为空，判断是否根据构造方法自动注入，此时 IndexService 有一个有参构造方法，所以 autowiring =true
      boolean autowiring = (chosenCtors != null ||
            mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);
      ConstructorArgumentValues resolvedValues = null;
      // 定义了最小参数个数
      // 如果构造方法的参数列表给定了具体的值
      // 那么这里指的就是构造方法参数的个数
      int minNrOfArgs;
      if (explicitArgs != null) {
         minNrOfArgs = explicitArgs.length;
      }
      else {
         /**
          * cargs 获取构造方法的值，注意是值，不是类型和列表
          */
         ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();
         resolvedValues = new ConstructorArgumentValues();
         /**
          * 把 cargs 的内容给 resolvedValues 比那里并且确定构造方法参数数量，假设有如下配置：
          *     &amp;lt;bean id=&amp;quot;luban&amp;quot; class=&amp;quot;com.luban.Luban&amp;quot;&amp;gt;
          *        &amp;lt;constructor-arg index=&amp;quot;0&amp;quot; value=&amp;quot;str1&amp;quot;/&amp;gt;
          *        &amp;lt;constructor-arg index=&amp;quot;1&amp;quot; value=&amp;quot;1&amp;quot;/&amp;gt;
          *        &amp;lt;constructor-arg index=&amp;quot;2&amp;quot; value=&amp;quot;str2&amp;quot;/&amp;gt;
          *      &amp;lt;/bean&amp;gt;
          *
          * 那么 minNrOfArgs=3
          * 或者你通过 Spring 的各种扩展点给了 Spring 一些构造方法的值，那么也能确定
          * 为什么要确定？
          * 因为我们的构造方法有多个，
          * 那么类型和个数是 Spring 用来确定使用哪个构造方法的重要信息
          */
         minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);
      }
      // Take specified constructors, if any.
      Constructor&amp;lt;?&amp;gt;[] candidates = chosenCtors;
      if (candidates == null) {
         Class&amp;lt;?&amp;gt; beanClass = mbd.getBeanClass();
         try {
            // 得到所有的构造方法
            candidates = (mbd.isNonPublicAccessAllowed() ?
                  beanClass.getDeclaredConstructors() : beanClass.getConstructors());
         }
         catch (Throwable ex) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                  &amp;quot;Resolution of declared constructors on bean Class [&amp;quot; + beanClass.getName() +
                  &amp;quot;] from ClassLoader [&amp;quot; + beanClass.getClassLoader() + &amp;quot;] failed&amp;quot;, ex);
         }
      }
      // 构造方法进行排序 
      AutowireUtils.sortConstructors(candidates);
      // 定义了一个差异变量，默认为 Integer 最大值
      int minTypeDiffWeight = Integer.MAX_VALUE;
      // 有歧义的构造方法 public IndexService(Class clazz){} 和 public IndexService(Object obj){}
      Set&amp;lt;Constructor&amp;lt;?&amp;gt;&amp;gt; ambiguousConstructors = null;
      // 循环所有的构造方法
      LinkedList&amp;lt;UnsatisfiedDependencyException&amp;gt; causes = null;
      for (Constructor&amp;lt;?&amp;gt; candidate : candidates) {
         Class&amp;lt;?&amp;gt;[] paramTypes = candidate.getParameterTypes();
         // 需要循环寻找构造方法，
         // 因为：比如传参为 (&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;, 120)
         // 比如有这样这样一个这样的构造方法：public void IndexService(Object o1, Object o2, Object o3) ，Spring 会认为它符合；但是还有一个 public void IndexService(String str, String str2, Integer i2):这个构造方法更符合传参的类型，所以会循环不断寻找构造方法，为了找到更匹配的。
         // 如果构造方法参数个数(3) &amp;gt; 当前这个构造方法参数个数(2)，则不再继续向下找。因为当前构造方法是按照参数个数进行排好序的，当前构造方法个数为2了，表明后面不会有更匹配的了，于是终止。 
         if (constructorToUse != null &amp;amp;&amp;amp; argsToUse.length &amp;gt; paramTypes.length) {
            // Already found greedy constructor that can be satisfied -&amp;gt;
            // do not look any further, there are only less greedy constructors left.
            break;
         }
         if (paramTypes.length &amp;lt; minNrOfArgs) {
            continue;
         }
         ArgumentsHolder argsHolder;
         if (resolvedValues != null) {
            try {
               String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, paramTypes.length);
               if (paramNames == null) {
                  ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();
                  if (pnd != null) {
                     paramNames = pnd.getParameterNames(candidate);
                  }
               }
               argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,
                     getUserDeclaredConstructor(candidate), autowiring);
            }
            catch (UnsatisfiedDependencyException ex) {
               if (logger.isTraceEnabled()) {
                  logger.trace(&amp;quot;Ignoring constructor [&amp;quot; + candidate + &amp;quot;] of bean &#39;&amp;quot; + beanName + &amp;quot;&#39;: &amp;quot; + ex);
               }
               // Swallow and try next constructor.
               if (causes == null) {
                  causes = new LinkedList&amp;lt;&amp;gt;();
               }
               causes.add(ex);
               continue;
            }
         }
         else {
            // Explicit arguments given -&amp;gt; arguments length must match exactly.
            if (paramTypes.length != explicitArgs.length) {
               continue;
            }
            argsHolder = new ArgumentsHolder(explicitArgs);
         }
         int typeDiffWeight = (mbd.isLenientConstructorResolution() ?
               argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));
         // Choose this constructor if it represents the closest match.
         if (typeDiffWeight &amp;lt; minTypeDiffWeight) {
            constructorToUse = candidate;
            argsHolderToUse = argsHolder;
            argsToUse = argsHolder.arguments;
            minTypeDiffWeight = typeDiffWeight;
            ambiguousConstructors = null;
         }
         else if (constructorToUse != null &amp;amp;&amp;amp; typeDiffWeight == minTypeDiffWeight) {
            if (ambiguousConstructors == null) {
               ambiguousConstructors = new LinkedHashSet&amp;lt;&amp;gt;();
               ambiguousConstructors.add(constructorToUse);
            }
            ambiguousConstructors.add(candidate);
         }
      }
      if (constructorToUse == null) {
         if (causes != null) {
            UnsatisfiedDependencyException ex = causes.removeLast();
            for (Exception cause : causes) {
               this.beanFactory.onSuppressedException(cause);
            }
            throw ex;
         }
         throw new BeanCreationException(mbd.getResourceDescription(), beanName,
               &amp;quot;Could not resolve matching constructor &amp;quot; +
               &amp;quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)&amp;quot;);
      }
      else if (ambiguousConstructors != null &amp;amp;&amp;amp; !mbd.isLenientConstructorResolution()) {
         throw new BeanCreationException(mbd.getResourceDescription(), beanName,
               &amp;quot;Ambiguous constructor matches found in bean &#39;&amp;quot; + beanName + &amp;quot;&#39; &amp;quot; +
               &amp;quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): &amp;quot; +
               ambiguousConstructors);
      }
      if (explicitArgs == null) {
         argsHolderToUse.storeCache(mbd, constructorToUse);
      }
   }
   try {
      final InstantiationStrategy strategy = beanFactory.getInstantiationStrategy();
      Object beanInstance;
      if (System.getSecurityManager() != null) {
         final Constructor&amp;lt;?&amp;gt; ctorToUse = constructorToUse;
         final Object[] argumentsToUse = argsToUse;
         beanInstance = AccessController.doPrivileged((PrivilegedAction&amp;lt;Object&amp;gt;) () -&amp;gt;
               strategy.instantiate(mbd, beanName, beanFactory, ctorToUse, argumentsToUse),
               beanFactory.getAccessControlContext());
      }
      else {
         beanInstance = strategy.instantiate(mbd, beanName, this.beanFactory, constructorToUse, argsToUse);
      }
      bw.setBeanInstance(beanInstance);
      return bw;
   }
   catch (Throwable ex) {
      throw new BeanCreationException(mbd.getResourceDescription(), beanName,
            &amp;quot;Bean instantiation via constructor failed&amp;quot;, ex);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述第 116 行代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if (constructorToUse != null &amp;amp;&amp;amp; argsToUse.length &amp;gt; paramTypes.length){
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;constructorToUse != null：因为 Spring 会有多次循环，当循环第一次如果找到了匹配的构造方法，会把构造方法赋值给 constructorToUse；第二次循环时 constructorToUse != null，然后判断 argsToUse.length 参数长度&lt;br&gt;
需要循环寻找构造方法，因为：比如传参为 (&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;, 120)&lt;/p&gt;
&lt;p&gt;比如有这样这样一个这样的构造方法：public void IndexService(Object o1, Object o2, Object o3) ，Spring 会认为它符合；&lt;/p&gt;
&lt;p&gt;但是还有一个 public void IndexService(String str, String str2, Integer i2):这个构造方法更符合传参的类型，所以会循环不断寻找构造方法，为了找到更匹配的。&lt;/p&gt;
&lt;p&gt;如果构造方法参数个数(3) &amp;gt; 当前这个构造方法参数个数(2)，则不再继续向下找。因为当前构造方法是按照参数个数进行排好序的，当前构造方法个数为2了，表明后面不会有更匹配的了，于是终止。&lt;/p&gt;
&lt;h2 id=&#34;一个有参-一个无参构造方法&#34;&gt;一个有参、一个无参构造方法&lt;/h2&gt;
&lt;p&gt;当 IndexService 有一个无参、一个有参构造方法时：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class IndexService {
   public IndexService(String str){
      System.out.println(&amp;quot;IndexService...constructor&amp;quot;);
   }
   public IndexService(){
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/S7iCrnxWKpwY5lkQ.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Spring 不知道你到底要调用哪个构造方法，于是干脆返回 null，调用无参构造方法。&lt;/p&gt;
&lt;p&gt;createBeanInstance 中使用默认构造方法进行实例化：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 使用默认的无参构造方法进行初始化
return instantiateBean(beanName, mbd);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {
   try {
      Object beanInstance;
      final BeanFactory parent = this;
      if (System.getSecurityManager() != null) {
         beanInstance = AccessController.doPrivileged((PrivilegedAction&amp;lt;Object&amp;gt;) () -&amp;gt;
               getInstantiationStrategy().instantiate(mbd, beanName, parent),
               getAccessControlContext());
      }
      else {
         // getInstantiationStrategy() 得到类的实例化策略
         // 默认情况下是得到一个反射的实例化策略
         beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);
      }
      BeanWrapper bw = new BeanWrapperImpl(beanInstance);
      initBeanWrapper(bw);
      return bw;
   }
   catch (Throwable ex) {
      throw new BeanCreationException(
            mbd.getResourceDescription(), beanName, &amp;quot;Instantiation of bean failed&amp;quot;, ex);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 13 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/cVEHVfWfsTFkJTj5__thumbnail.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {
   // Don&#39;t override the class with CGLIB if no overrides.
   // 检查 bean 配置中是否配置了 lookup-method 或 replace-method
   // 如果配置了就需要使用 CGLIB 构建 bean 对象
   if (!bd.hasMethodOverrides()) {
      Constructor&amp;lt;?&amp;gt; constructorToUse;
      synchronized (bd.constructorArgumentLock) {
         // constructorToUse： 使用哪个构造方法
         constructorToUse = (Constructor&amp;lt;?&amp;gt;) bd.resolvedConstructorOrFactoryMethod;
         if (constructorToUse == null) {
            final Class&amp;lt;?&amp;gt; clazz = bd.getBeanClass();
            // 如果 clazz 是接口，抛出异常
            if (clazz.isInterface()) {
               throw new BeanInstantiationException(clazz, &amp;quot;Specified class is an interface&amp;quot;);
            }
            try {
               if (System.getSecurityManager() != null) {
                  constructorToUse = AccessController.doPrivileged(
                        (PrivilegedExceptionAction&amp;lt;Constructor&amp;lt;?&amp;gt;&amp;gt;) clazz::getDeclaredConstructor);
               }
               else {
                  // getDeclaredConstructor：得到默认构造方法，constructorToUse：表示 Spring 使用哪个构造方法实例对象
                  constructorToUse = clazz.getDeclaredConstructor();
               }
               bd.resolvedConstructorOrFactoryMethod = constructorToUse;
            }
            catch (Throwable ex) {
               throw new BeanInstantiationException(clazz, &amp;quot;No default constructor found&amp;quot;, ex);
            }
         }
      }
      return BeanUtils.instantiateClass(constructorToUse);
   }
   else {
      // Must generate CGLIB subclass.
      return instantiateWithMethodInjection(bd, beanName, owner);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 23 行：&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/AxQHvIdwrp1K1Dd2__thumbnail.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;上述代码第 32 行，反射完成 Bean 的实例化：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static &amp;lt;T&amp;gt; T instantiateClass(Constructor&amp;lt;T&amp;gt; ctor, Object... args) throws BeanInstantiationException {
   Assert.notNull(ctor, &amp;quot;Constructor must not be null&amp;quot;);
   try {
      // 设置构造方法可访问
      ReflectionUtils.makeAccessible(ctor);
      // 反射创建对象
      return (KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ?
            KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args));
   }
   catch (InstantiationException ex) {
      throw new BeanInstantiationException(ctor, &amp;quot;Is it an abstract class?&amp;quot;, ex);
   }
   catch (IllegalAccessException ex) {
      throw new BeanInstantiationException(ctor, &amp;quot;Is the constructor accessible?&amp;quot;, ex);
   }
   catch (IllegalArgumentException ex) {
      throw new BeanInstantiationException(ctor, &amp;quot;Illegal arguments for constructor&amp;quot;, ex);
   }
   catch (InvocationTargetException ex) {
      throw new BeanInstantiationException(ctor, &amp;quot;Constructor threw exception&amp;quot;, ex.getTargetException());
   }
}
&lt;/code&gt;&lt;/pre&gt;
">Spring系列（十四）Spring源码解析——类的实例化过程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/spring-xi-lie-shi-san-spring-aop-yuan-ma-fen-xi/"" data-c="
          &lt;h1 id=&#34;先从一个-aop-例子开始&#34;&gt;先从一个 AOP 例子开始&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;
  &amp;lt;!-- spring --&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;5.0.9.RELEASE&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;
  &amp;lt;!-- aspectj --&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;aspectjweaver&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.9.0&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ComponentScan(&amp;quot;com.ssm&amp;quot;)
@Configuration
@EnableAspectJAutoProxy
public class AppConfig {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
@Aspect
public class AspectSSM {
    @Pointcut(&amp;quot;execution(* com.ssm.dao.*.*(..))&amp;quot;)
    public void pointCut(){
    }
    @Before(&amp;quot;pointCut()&amp;quot;)
    public void before(){
        System.out.println(&amp;quot;proxy before&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface OrderDao {
    public void query();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class OrderDaoImpl implements OrderDao {
    @Override
    public void query() {
        System.out.println(&amp;quot;query...&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext configApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
        configApplicationContext.getBean(OrderDao.class).query();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;proxy before
query...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;一个需求根据参数在-service-内调用不同-dao&#34;&gt;一个需求：根据参数在 service 内调用不同 dao&lt;/h2&gt;
&lt;p&gt;一个需求：如果登录的是 A类用户，就调用 OrderADaoImpl；如果登录的是 B 类用户，就调用 OrderDaoBImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class OrderService {
    @Autowired
    OrderDao orderDao;
    public void query(String str){
        // 如果 str=&#39;A&#39;,orderDao=OrderDaoAImpl;
        // 如果 str&#39;B&#39;,OrderDao=OrderDaoBImpl
        orderDao.query(str);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/5KUUxsI8sbRrU7m3.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;第一阶段 Spring 初始化：初始化后已经有了 OrderService 类，OrderService 类依赖 OrderDao&lt;/p&gt;
&lt;p&gt;第二阶段用户阶段： 用户登录，调用 orderService 的方法，因为 OrderService 已经被实例化了，里面的属性 OrderDao 也被确定了。&lt;/p&gt;
&lt;p&gt;Spring 扩展点是在 Spring 生命周期之间插手去做一些事情，一旦 Spring 生命周期结束，对 Spring 工厂做其他事情已经没有意义了。&lt;/p&gt;
&lt;h3 id=&#34;解决方案一再创建一个工厂&#34;&gt;解决方案一：再创建一个工厂&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class OrderService implements ApplicationContextAware {
    ApplicationContext applicationContext;
    
    public void query(String str){
        OrderDao orderDao = null;
        if(&amp;quot;A&amp;quot;.equals(str)){
            orderDao = (OrderDao) applicationContext.getBean(&amp;quot;orderDaoAImpl&amp;quot;);
        }else if(&amp;quot;B&amp;quot;.equals(str)){
            orderDao = (OrderDao) applicationContext.getBean(&amp;quot;orderDaoBImpl&amp;quot;);
        }
        orderDao.query(str);
    }
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext configApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
        OrderService orderService = configApplicationContext.getBean(OrderService.class);
        orderService.query(&amp;quot;A&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当传参数为 A 时，调用 OrderDaoAImpl 的方法；当传参数为 B 时，调用 OrderDaoBImpl 的方法。&lt;/p&gt;
&lt;h3 id=&#34;方法二map&#34;&gt;方法二：Map&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class OrderService{
    @Autowired
    Map&amp;lt;String,OrderDao&amp;gt; orderDaoMap;
    public void query(String str){
        OrderDao orderDao =  orderDaoMap.get(&amp;quot;orderDao&amp;quot;+str+&amp;quot;Impl&amp;quot;);
        orderDao.query(str);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/6FvFs1Etv3oBBqLg.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当测试类传参数为 A 时，调用 OrderDaoAImpl 的方法；当传参数为 B 时，调用 OrderDaoBImpl 的方法。&lt;/p&gt;
&lt;h1 id=&#34;spring-中的后置处理器&#34;&gt;Spring 中的后置处理器&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Spring%E4%B8%AD%E7%9A%84%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;BeanPostProcessor：Spring 后置处理器。为什么需要注册 BeanPostProcessor？&lt;/p&gt;
&lt;p&gt;实例化要经过 BeanPostProcessor 处理器，这个处理器是一个 List，这个 List 被维护在 Spring 内部，所以要把 BeanPostProcessor 注册给它，BeanPostProcessor 是一个 List，有自定义，也有 Spring 内部的，Spring 内部有非常多后置处理器，这里就是把 Spring 内部要执行的后置处理器注册到这个 List 中。&lt;/p&gt;
&lt;p&gt;AbstractApplicationContext#refresh(); ---&amp;gt; AbstractApplicationContext#registerBeanPostProcessors ---&amp;gt;PostProcessorRegistrationDelegate#registerBeanPostProcessors&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/3%E4%B8%AA%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如上图所示，现在 Spring 容器中有三个后置处理器。&lt;/p&gt;
&lt;h2 id=&#34;applicationcontextawareprocessor&#34;&gt;ApplicationContextAwareProcessor&lt;/h2&gt;
&lt;h2 id=&#34;applicationlistenerdetector&#34;&gt;ApplicationListenerDetector&lt;/h2&gt;
&lt;p&gt;先来分析第一个后置处理器 ApplicationContextAwareProcessor 和第二个后置处理器 ApplicationListenerDetector。&lt;/p&gt;
&lt;p&gt;按调用链：AnnotationConfigApplicationContext#AnnotationConfigApplicationContext(Class&amp;lt;?&amp;gt;... annotatedClasses) ---&amp;gt; AbstractApplicationContext#refresh() ---&amp;gt; AbstractApplicationContext#prepareBeanFactory(beanFactory); 添加了两个后置处理器到 Spring 容器内：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 添加后置处理器
beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;importawarebeanpostprocessor&#34;&gt;ImportAwareBeanPostProcessor&lt;/h2&gt;
&lt;p&gt;接下来看第三个后置处理器 ImportAwareBeanPostProcessor，这个类是在哪里注入进来的呢？&lt;/p&gt;
&lt;p&gt;refresh() 方法内的 invokeBeanFactoryPostProcessors(beanFactory); 在 CGLIB 增强时，注入了 ImportAwareBeanPostProcessor。&lt;/p&gt;
&lt;p&gt;调用链如下：AbstractApplicationContext #refresh ---&amp;gt; AbstractApplicationContext#invokeBeanFactoryPostProcessors ---&amp;gt; PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors ---&amp;gt; PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors ---&amp;gt; ConfigurationClassPostProcessor#postProcessBeanFactory&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ImportAwareBeanPostProcessor 间接继承了 BeanPostProcessor&lt;br&gt;
当一个类实例化之后会调用 BeanPostProcessor，&lt;/p&gt;
&lt;p&gt;ImportAwareBeanPostProcessor#postProcessBeforeInitialization&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public Object postProcessBeforeInitialization(Object bean, String beanName) {
   // 判断这个 bean 是否是 ImportAware
   if (bean instanceof ImportAware) {
      ImportRegistry ir = this.beanFactory.getBean(IMPORT_REGISTRY_BEAN_NAME, ImportRegistry.class);
      AnnotationMetadata importingClass = ir.getImportingClassFor(bean.getClass().getSuperclass().getName());
      if (importingClass != null) {
         ((ImportAware) bean).setImportMetadata(importingClass);
      }
   }
   return bean;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;importaware扩展-spring-常用&#34;&gt;ImportAware：扩展 Spring 常用&lt;/h3&gt;
&lt;p&gt;比如有一个连接数据库工具 DBConfig：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class DBConfig{
   String name;
   String password;
   //...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 AppConfig 中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
@SSMDBUtils 
public class AppConfig {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如何将数据库的用户名、密码等信息设置给 SSMDBUtils 的 name、password 属性呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;xml、properties 配置文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ImportAware 的 setImportMetadata() 方法：得到 Spring 注解上的值，设置给特定属性：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class DBConfig implements ImportAware {
   String name;
   String password;
   @Override
   public void setImportMetadata(AnnotationMetadata importMetadata) {
      // 拿到 AppConfig 类上的所有注解，得到 @EnableSSMUtil注解 上的 name、password 值赋值给当前对象
      Set&amp;lt;String&amp;gt; appConfig = importMetadata.getMetaAnnotationTypes(&amp;quot;appConfig&amp;quot;);
      System.out.println(appConfig);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
@EnableSSMUtil
public class AppConfig {
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Retention(RetentionPolicy.RUNTIME)
public @interface EnableSSMUtil {
   String name() default &amp;quot;root&amp;quot;;
   String password() default &amp;quot;root&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;beanpostprocessorchecker&#34;&gt;BeanPostProcessorChecker&lt;/h2&gt;
&lt;p&gt;AbstractApplicationContext#refresh ---&amp;gt; AbstractApplicationContext#registerBeanPostProcessors ---&amp;gt; PostProcessorRegistrationDelegate#registerBeanPostProcessors&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void registerBeanPostProcessors(
      ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {
   // 从 beanDefinitionMap 中得到所有的 BeanPostProcessor
      String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);
   // Register BeanPostProcessorChecker that logs an info message when
   // a bean is created during BeanPostProcessor instantiation, i.e. when
   // a bean is not eligible for getting processed by all BeanPostProcessors.
   int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;
   beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));
   // Separate between BeanPostProcessors that implement PriorityOrdered,
   // Ordered, and the rest.
   List&amp;lt;BeanPostProcessor&amp;gt; priorityOrderedPostProcessors = new ArrayList&amp;lt;&amp;gt;();
   List&amp;lt;BeanPostProcessor&amp;gt; internalPostProcessors = new ArrayList&amp;lt;&amp;gt;();
   List&amp;lt;String&amp;gt; orderedPostProcessorNames = new ArrayList&amp;lt;&amp;gt;();
   List&amp;lt;String&amp;gt; nonOrderedPostProcessorNames = new ArrayList&amp;lt;&amp;gt;();
   for (String ppName : postProcessorNames) {
      if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
         BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
         priorityOrderedPostProcessors.add(pp);
         if (pp instanceof MergedBeanDefinitionPostProcessor) {
            internalPostProcessors.add(pp);
         }
      }
      else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
         orderedPostProcessorNames.add(ppName);
      }
      else {
         nonOrderedPostProcessorNames.add(ppName);
      }
   }
   // First, register the BeanPostProcessors that implement PriorityOrdered.
   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
   registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);
   // Next, register the BeanPostProcessors that implement Ordered.
   List&amp;lt;BeanPostProcessor&amp;gt; orderedPostProcessors = new ArrayList&amp;lt;&amp;gt;();
   for (String ppName : orderedPostProcessorNames) {
      BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
      orderedPostProcessors.add(pp);
      if (pp instanceof MergedBeanDefinitionPostProcessor) {
         internalPostProcessors.add(pp);
      }
   }
   sortPostProcessors(orderedPostProcessors, beanFactory);
   registerBeanPostProcessors(beanFactory, orderedPostProcessors);
   // Now, register all regular BeanPostProcessors.
   List&amp;lt;BeanPostProcessor&amp;gt; nonOrderedPostProcessors = new ArrayList&amp;lt;&amp;gt;();
   for (String ppName : nonOrderedPostProcessorNames) {
      BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
      nonOrderedPostProcessors.add(pp);
      if (pp instanceof MergedBeanDefinitionPostProcessor) {
         internalPostProcessors.add(pp);
      }
   }
   registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);
   // Finally, re-register all internal BeanPostProcessors.
   sortPostProcessors(internalPostProcessors, beanFactory);
   registerBeanPostProcessors(beanFactory, internalPostProcessors);
   // Re-register post-processor for detecting inner beans as ApplicationListeners,
   // moving it to the end of the processor chain (for picking up proxies etc).
   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 11 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** 当 Spring 的配置中的后置处理器还没有被注册就已经开始了 bean 的初始化
  * 便会打印出 BeanPostProcessorChecker 中设定的信息
  */
public BeanPostProcessorChecker(ConfigurableListableBeanFactory beanFactory, int beanPostProcessorTargetCount) {
   this.beanFactory = beanFactory;
   this.beanPostProcessorTargetCount = beanPostProcessorTargetCount;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/YVAE0NRT6PKD1ndX__thumbnail.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;当 Spring 的配置中的后置处理器还没有被注册就已经开始了 bean 的初始化，便会打印出 BeanPostProcessorChecker 中设定的信息。&lt;/p&gt;
&lt;h2 id=&#34;commonannotationbeanpostprocessor&#34;&gt;CommonAnnotationBeanPostProcessor&lt;/h2&gt;
&lt;p&gt;处理公共注解，比如 @POSTConstructor&lt;/p&gt;
&lt;h2 id=&#34;autowiredannotationbeanpostprocessor&#34;&gt;AutowiredAnnotationBeanPostProcessor&lt;/h2&gt;
&lt;p&gt;有没有加 @Autowired，如果加了 @Autowired 注解，就进行处理&lt;/p&gt;
&lt;h2 id=&#34;requiredannotationbeanpostprocessor&#34;&gt;RequiredAnnotationBeanPostProcessor&lt;/h2&gt;
&lt;p&gt;如果加了 @Required 注解，就进行处理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class IndexService {
   private String name;
   public String getName(){
      return name;
   }
   // 必须注入 name，不注入会报异常
   @Required
   public void setName(String name){
      this.name = name;
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行 Test，报错信息如下：&lt;br&gt;
Initialization of bean failed; nested exception is org.springframework.beans.factory.BeanInitializationException: Property &#39;name&#39; is required for bean &#39;indexService&#39;&lt;/p&gt;
&lt;p&gt;因为@Required 表示 name 是必须的，没有给 IndexService 设置 name，使用后置处理器 RequiredAnnotationBeanPostProcessor 进行处理后结果： IndexService 无法实例化。&lt;/p&gt;
&lt;h2 id=&#34;annotationawareaspectjautoproxycreator&#34;&gt;AnnotationAwareAspectJAutoProxyCreator&lt;/h2&gt;
&lt;p&gt;当加入 @EnableAspectJAutoProxy 后，Spring 加入了一个后置处理器 AnnotationAwareAspectJAutoProxyCreator：处理 aop，把一个对象变成代理对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ComponentScan(&amp;quot;com.ssm&amp;quot;)
@Configuration
@EnableAspectJAutoProxy
public class AppConfig {
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(AspectJAutoProxyRegistrar.class)
public @interface EnableAspectJAutoProxy {
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar {
   @Override
   public void registerBeanDefinitions(
         AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
      AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码动态加载了一个处理 aop 的后置处理器 AnnotationAwareAspectJAutoProxyCreator 到 BeanDefinitionMap 中。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/AnnotationAwareAspectJAutoProxyCreator.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;AnnotationAwareAspectJAutoProxyCreator 间接继承了 BeanPostProcessor，所以它也是一个后置处理器。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/8%E4%B8%AA%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;原来有 7 个后置处理器，注册了一个 AnnotationAwareAspectJAutoProxyCreator 后置处理器后，现在有 8 个后置处理器。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;通过 add 添加了 3 个：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ApplicationContextAwareProcessor&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ApplicationListenerDetector&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ImportAwareBeanPostProcessor&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/add%E6%B7%BB%E5%8A%A0%E4%BA%863%E4%B8%AA%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;从 BeanDefinitionMap 中拿出 3个 对象，放到 List 中：String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;AutowiredAnnotationBeanPostProcessor&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RequiredAnnotationBeanPostProcessor&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CommonAnnotationBeanPostProcessor&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%BB%8Emap%E6%8B%BF%E5%87%BA%E4%BA%863%E4%B8%AA%E5%AF%B9%E8%B1%A1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;通过 add 添加了 1个 真实对象：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;BeanPostProcessorChecker&lt;/strong&gt;：beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/add%E6%B7%BB%E5%8A%A01%E4%B8%AA%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;通过 beanFactory 拿出了一个对象：beanFactory.getBean(ppName, BeanPostProcessor.class);
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;AnnotationAwareAspectJAutoProxyCreator&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%BB%8EbeanFactory%E6%8B%BF%E5%87%BA1%E4%B8%AA%E5%AF%B9%E8%B1%A1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;finishbeanfactoryinitialization&#34;&gt;finishBeanFactoryInitialization&lt;/h1&gt;
&lt;p&gt;AbstractApplicationContext#refresh() ---&amp;gt; AbstractApplicationContext#finishBeanFactoryInitialization&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
   // Initialize conversion service for this context.
   // CONVERSION_SERVICE_BEAN_NAME：用来转换类型的
   if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;amp;&amp;amp;
         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {
      beanFactory.setConversionService(
            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
   }
   // Register a default embedded value resolver if no bean post-processor
   // (such as a PropertyPlaceholderConfigurer bean) registered any before:
   // at this point, primarily for resolution in annotation attribute values.
   // 是否有内置value转换器
   if (!beanFactory.hasEmbeddedValueResolver()) {
      beanFactory.addEmbeddedValueResolver(strVal -&amp;gt; getEnvironment().resolvePlaceholders(strVal));
   }
   // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.
   // LoadTimeWeaverAware ：AspectJ 静态织入的过程
   // AspectJ：编译过程就织入，扩展了JDK编译器
   // Spring：无论用JDK还是CGLIB，都是动态织入，在项目运行过程中织入。
   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
   for (String weaverAwareName : weaverAwareNames) {
      getBean(weaverAwareName);
   }
   // Stop using the temporary ClassLoader for type matching.
   beanFactory.setTempClassLoader(null);
   // Allow for caching all bean definition metadata, not expecting further changes.
   beanFactory.freezeConfiguration();
   // Instantiate all remaining (non-lazy-init) singletons.
   // 到此为止，bean还没有实例化出来，这个方法是实例化单例对象之前要做的事情
   beanFactory.preInstantiateSingletons();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 35 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public void preInstantiateSingletons() throws BeansException {
   if (logger.isDebugEnabled()) {
      logger.debug(&amp;quot;Pre-instantiating singletons in &amp;quot; + this);
   }
   // Iterate over a copy to allow for init methods which in turn register new bean definitions.
   // While this may not be part of the regular factory bootstrap, it does otherwise work fine.
   List&amp;lt;String&amp;gt; beanNames = new ArrayList&amp;lt;&amp;gt;(this.beanDefinitionNames);
   // Trigger initialization of all non-lazy singleton beans...
   // beanNames：BeanDefinitionMap中所有类的名字
   for (String beanName : beanNames) {
      // 通过 beanName 得到 BeanDefinition，合并父类 BeanDefinition
      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
      // 如果这个 bd 是非抽象、单例、非懒加载的
      if (!bd.isAbstract() &amp;amp;&amp;amp; bd.isSingleton() &amp;amp;&amp;amp; !bd.isLazyInit()) {
         if (isFactoryBean(beanName)) {
            Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
            // 判断这个 bean 是不是 FactoryBean
            if (bean instanceof FactoryBean) {
               final FactoryBean&amp;lt;?&amp;gt; factory = (FactoryBean&amp;lt;?&amp;gt;) bean;
               boolean isEagerInit;
               if (System.getSecurityManager() != null &amp;amp;&amp;amp; factory instanceof SmartFactoryBean) {
                  isEagerInit = AccessController.doPrivileged((PrivilegedAction&amp;lt;Boolean&amp;gt;)
                              ((SmartFactoryBean&amp;lt;?&amp;gt;) factory)::isEagerInit,
                        getAccessControlContext());
               }
               else {
                  isEagerInit = (factory instanceof SmartFactoryBean &amp;amp;&amp;amp;
                        ((SmartFactoryBean&amp;lt;?&amp;gt;) factory).isEagerInit());
               }
               if (isEagerInit) {
                  getBean(beanName);
               }
            }
         }
         else {
            getBean(beanName);
         }
      }
   }
   // Trigger post-initialization callback for all applicable beans...
   for (String beanName : beanNames) {
      Object singletonInstance = getSingleton(beanName);
      if (singletonInstance instanceof SmartInitializingSingleton) {
         final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
         if (System.getSecurityManager() != null) {
            AccessController.doPrivileged((PrivilegedAction&amp;lt;Object&amp;gt;) () -&amp;gt; {
               smartSingleton.afterSingletonsInstantiated();
               return null;
            }, getAccessControlContext());
         }
         else {
            smartSingleton.afterSingletonsInstantiated();
         }
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 39 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public Object getBean(String name) throws BeansException {
   return doGetBean(name, null, null, false);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected &amp;lt;T&amp;gt; T doGetBean(final String name, @Nullable final Class&amp;lt;T&amp;gt; requiredType,
      @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {
   final String beanName = transformedBeanName(name);
   Object bean;
   // Eagerly check singleton cache for manually registered singletons.
   // 先 getSingleton(beanName)，如果拿不到，再去初始化
   Object sharedInstance = getSingleton(beanName);
   if (sharedInstance != null &amp;amp;&amp;amp; args == null) {
      if (logger.isDebugEnabled()) {
         if (isSingletonCurrentlyInCreation(beanName)) {
            logger.debug(&amp;quot;Returning eagerly cached instance of singleton bean &#39;&amp;quot; + beanName +
                  &amp;quot;&#39; that is not fully initialized yet - a consequence of a circular reference&amp;quot;);
         }
         else {
            logger.debug(&amp;quot;Returning cached instance of singleton bean &#39;&amp;quot; + beanName + &amp;quot;&#39;&amp;quot;);
         }
      }
      bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
   }
   else {
      // Fail if we&#39;re already creating this bean instance:
      // We&#39;re assumably within a circular reference.
      if (isPrototypeCurrentlyInCreation(beanName)) {
         throw new BeanCurrentlyInCreationException(beanName);
      }
      // Check if bean definition exists in this factory.
      // 有没有对 Spring 进行改造
      BeanFactory parentBeanFactory = getParentBeanFactory();
      if (parentBeanFactory != null &amp;amp;&amp;amp; !containsBeanDefinition(beanName)) {
         // Not found -&amp;gt; check parent.
         String nameToLookup = originalBeanName(name);
         if (parentBeanFactory instanceof AbstractBeanFactory) {
            return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
                  nameToLookup, requiredType, args, typeCheckOnly);
         }
         else if (args != null) {
            // Delegation to parent with explicit args.
            return (T) parentBeanFactory.getBean(nameToLookup, args);
         }
         else {
            // No args -&amp;gt; delegate to standard getBean method.
            return parentBeanFactory.getBean(nameToLookup, requiredType);
         }
      }
      // 检查
      if (!typeCheckOnly) {
         markBeanAsCreated(beanName);
      }
      try {
         // 拿出 RootBeanDefinition 
         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
         checkMergedBeanDefinition(mbd, beanName, args);
         // Guarantee initialization of beans that the current bean depends on.
         // 判断有没有 DependsOn
         String[] dependsOn = mbd.getDependsOn();
         if (dependsOn != null) {
            for (String dep : dependsOn) {
               if (isDependent(beanName, dep)) {
                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        &amp;quot;Circular depends-on relationship between &#39;&amp;quot; + beanName + &amp;quot;&#39; and &#39;&amp;quot; + dep + &amp;quot;&#39;&amp;quot;);
               }
               registerDependentBean(dep, beanName);
               try {
                  getBean(dep);
               }
               catch (NoSuchBeanDefinitionException ex) {
                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        &amp;quot;&#39;&amp;quot; + beanName + &amp;quot;&#39; depends on missing bean &#39;&amp;quot; + dep + &amp;quot;&#39;&amp;quot;, ex);
               }
            }
         }
         // Create bean instance.
         //
         if (mbd.isSingleton()) {
            sharedInstance = getSingleton(beanName, () -&amp;gt; {
               try {
                  return createBean(beanName, mbd, args);
               }
               catch (BeansException ex) {
                  // Explicitly remove instance from singleton cache: It might have been put there
                  // eagerly by the creation process, to allow for circular reference resolution.
                  // Also remove any beans that received a temporary reference to the bean.
                  destroySingleton(beanName);
                  throw ex;
               }
            });
            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
         }
         else if (mbd.isPrototype()) {
            // It&#39;s a prototype -&amp;gt; create a new instance.
            Object prototypeInstance = null;
            try {
               beforePrototypeCreation(beanName);
               prototypeInstance = createBean(beanName, mbd, args);
            }
            finally {
               afterPrototypeCreation(beanName);
            }
            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
         }
         else {
            String scopeName = mbd.getScope();
            final Scope scope = this.scopes.get(scopeName);
            if (scope == null) {
               throw new IllegalStateException(&amp;quot;No Scope registered for scope name &#39;&amp;quot; + scopeName + &amp;quot;&#39;&amp;quot;);
            }
            try {
               Object scopedInstance = scope.get(beanName, () -&amp;gt; {
                  beforePrototypeCreation(beanName);
                  try {
                     return createBean(beanName, mbd, args);
                  }
                  finally {
                     afterPrototypeCreation(beanName);
                  }
               });
               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
            }
            catch (IllegalStateException ex) {
               throw new BeanCreationException(beanName,
                     &amp;quot;Scope &#39;&amp;quot; + scopeName + &amp;quot;&#39; is not active for the current thread; consider &amp;quot; +
                     &amp;quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&amp;quot;,
                     ex);
            }
         }
      }
      catch (BeansException ex) {
         cleanupAfterBeanCreationFailure(beanName);
         throw ex;
      }
   }
   // Check if required type matches the type of the actual bean instance.
   if (requiredType != null &amp;amp;&amp;amp; !requiredType.isInstance(bean)) {
      try {
         T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
         if (convertedBean == null) {
            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
         }
         return convertedBean;
      }
      catch (TypeMismatchException ex) {
         if (logger.isDebugEnabled()) {
            logger.debug(&amp;quot;Failed to convert bean &#39;&amp;quot; + name + &amp;quot;&#39; to required type &#39;&amp;quot; +
                  ClassUtils.getQualifiedName(requiredType) + &amp;quot;&#39;&amp;quot;, ex);
         }
         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
      }
   }
   return (T) bean;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 84 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Object getSingleton(String beanName, ObjectFactory&amp;lt;?&amp;gt; singletonFactory) {
   Assert.notNull(beanName, &amp;quot;Bean name must not be null&amp;quot;);
   synchronized (this.singletonObjects) {
      // 从SpringIOC容器中拿出 key=orderDaoAImpl，因为还未被实例化，所以 singletonObject=null
      Object singletonObject = this.singletonObjects.get(beanName);
      if (singletonObject == null) {
         if (this.singletonsCurrentlyInDestruction) {
            throw new BeanCreationNotAllowedException(beanName,
                  &amp;quot;Singleton bean creation not allowed while singletons of this factory are in destruction &amp;quot; +
                  &amp;quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&amp;quot;);
         }
         if (logger.isDebugEnabled()) {
            logger.debug(&amp;quot;Creating shared instance of singleton bean &#39;&amp;quot; + beanName + &amp;quot;&#39;&amp;quot;);
         }
         beforeSingletonCreation(beanName);
         boolean newSingleton = false;
         boolean recordSuppressedExceptions = (this.suppressedExceptions == null);
         if (recordSuppressedExceptions) {
            this.suppressedExceptions = new LinkedHashSet&amp;lt;&amp;gt;();
         }
         try {
            // 执行完这行代码，OrderDaoAImpl对象被创建出来了
            singletonObject = singletonFactory.getObject();
            newSingleton = true;
         }
         catch (IllegalStateException ex) {
            // Has the singleton object implicitly appeared in the meantime -&amp;gt;
            // if yes, proceed with it since the exception indicates that state.
            singletonObject = this.singletonObjects.get(beanName);
            if (singletonObject == null) {
               throw ex;
            }
         }
         catch (BeanCreationException ex) {
            if (recordSuppressedExceptions) {
               for (Exception suppressedException : this.suppressedExceptions) {
                  ex.addRelatedCause(suppressedException);
               }
            }
            throw ex;
         }
         finally {
            if (recordSuppressedExceptions) {
               this.suppressedExceptions = null;
            }
            afterSingletonCreation(beanName);
         }
         if (newSingleton) {
            addSingleton(beanName, singletonObject);
         }
      }
      return singletonObject;
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 4 行：SpringIOC容器 singletonObjects&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private final Map&amp;lt;String, Object&amp;gt; singletonObjects = new ConcurrentHashMap&amp;lt;&amp;gt;(256);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 23 行：&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/zjTYCzGjuFjMmnDr.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;OrderDaoAImpl 对象被创建出来后，已经是一个代理对象了，应该是一个原生对象 -&amp;gt; 后置处理器 -&amp;gt; 代理对象，所以后置处理器在 singletonFactory.getObject(); 已经被执行了，所以才能产生一个代理对象。看是怎样执行后置处理器的？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;singletonObject = singletonFactory.getObject();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;singletonFactory 是作为参数传递过来的：&lt;br&gt;
DefaultSingletonBeanRegistry#getSingleton&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Object getSingleton(String beanName, ObjectFactory&amp;lt;?&amp;gt; singletonFactory) {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;于是查看调用链，传过来的参数是一个匿名内部类，如下所示：&lt;br&gt;
AbstractBeanFactory#doGetBean&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;sharedInstance = getSingleton(beanName, () -&amp;gt; {
   try {
      return createBean(beanName, mbd, args);
   }
   catch (BeansException ex) {
      // Explicitly remove instance from singleton cache: It might have been put there
      // eagerly by the creation process, to allow for circular reference resolution.
      // Also remove any beans that received a temporary reference to the bean.
      destroySingleton(beanName);
      throw ex;
   }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 3 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
      throws BeanCreationException {
   if (logger.isDebugEnabled()) {
      logger.debug(&amp;quot;Creating instance of bean &#39;&amp;quot; + beanName + &amp;quot;&#39;&amp;quot;);
   }
   RootBeanDefinition mbdToUse = mbd;
   // Make sure bean class is actually resolved at this point, and
   // clone the bean definition in case of a dynamically resolved Class
   // which cannot be stored in the shared merged bean definition.
   // 属性值的赋值：拿到一些属性值，通过 Spring 给它的值：bd.setPropertyValues(&amp;quot;xxx&amp;quot;)，这里就能拿到 xxx 
   // 如何给属性赋值：外部写代码赋值；通过 Spring 的 BeanDefinition 给它赋值。
   Class&amp;lt;?&amp;gt; resolvedClass = resolveBeanClass(mbd, beanName);
   if (resolvedClass != null &amp;amp;&amp;amp; !mbd.hasBeanClass() &amp;amp;&amp;amp; mbd.getBeanClassName() != null) {
      mbdToUse = new RootBeanDefinition(mbd);
      mbdToUse.setBeanClass(resolvedClass);
   }
   // Prepare method overrides.
   try {
      mbdToUse.prepareMethodOverrides();
   }
   catch (BeanDefinitionValidationException ex) {
      throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),
            beanName, &amp;quot;Validation of method overrides failed&amp;quot;, ex);
   }
   try {
      // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
      if (bean != null) {
         return bean;
      }
   }
   catch (Throwable ex) {
      throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,
            &amp;quot;BeanPostProcessor before instantiation of bean failed&amp;quot;, ex);
   }
   try {
      Object beanInstance = doCreateBean(beanName, mbdToUse, args);
      if (logger.isDebugEnabled()) {
         logger.debug(&amp;quot;Finished creating instance of bean &#39;&amp;quot; + beanName + &amp;quot;&#39;&amp;quot;);
      }
      return beanInstance;
   }
   catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {
      // A previously detected exception with proper bean creation context already,
      // or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.
      throw ex;
   }
   catch (Throwable ex) {
      throw new BeanCreationException(
            mbdToUse.getResourceDescription(), beanName, &amp;quot;Unexpected exception during bean creation&amp;quot;, ex);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 42 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Object beanInstance = doCreateBean(beanName, mbdToUse, args);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/kacCBa8WLRfTCTOO.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
      throws BeanCreationException {
   // Instantiate the bean.
   // BeanWrapper：Bean的包装
   BeanWrapper instanceWrapper = null;
   if (mbd.isSingleton()) {
      instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
   }
   if (instanceWrapper == null) {
      instanceWrapper = createBeanInstance(beanName, mbd, args);
   }
   // 拿到原生对象 OrderDaoAImpl，而不是代理
   final Object bean = instanceWrapper.getWrappedInstance();
   Class&amp;lt;?&amp;gt; beanType = instanceWrapper.getWrappedClass();
   if (beanType != NullBean.class) {
      mbd.resolvedTargetType = beanType;
   }
   // Allow post-processors to modify the merged bean definition.
   synchronized (mbd.postProcessingLock) {
      if (!mbd.postProcessed) {
         try {
            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
         }
         catch (Throwable ex) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                  &amp;quot;Post-processing of merged bean definition failed&amp;quot;, ex);
         }
         mbd.postProcessed = true;
      }
   }
   // Eagerly cache singletons to be able to resolve circular references
   // even when triggered by lifecycle interfaces like BeanFactoryAware.
   boolean earlySingletonExposure = (mbd.isSingleton() &amp;amp;&amp;amp; this.allowCircularReferences &amp;amp;&amp;amp;
         isSingletonCurrentlyInCreation(beanName));
   if (earlySingletonExposure) {
      if (logger.isDebugEnabled()) {
         logger.debug(&amp;quot;Eagerly caching bean &#39;&amp;quot; + beanName +
               &amp;quot;&#39; to allow for resolving potential circular references&amp;quot;);
      }
      addSingletonFactory(beanName, () -&amp;gt; getEarlyBeanReference(beanName, mbd, bean));
   }
   // Initialize the bean instance.
   Object exposedObject = bean;
   try {
      // 这个方法是用来赋值属性的
      populateBean(beanName, mbd, instanceWrapper);
      exposedObject = initializeBean(beanName, exposedObject, mbd);
   }
   catch (Throwable ex) {
      if (ex instanceof BeanCreationException &amp;amp;&amp;amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {
         throw (BeanCreationException) ex;
      }
      else {
         throw new BeanCreationException(
               mbd.getResourceDescription(), beanName, &amp;quot;Initialization of bean failed&amp;quot;, ex);
      }
   }
   if (earlySingletonExposure) {
      Object earlySingletonReference = getSingleton(beanName, false);
      if (earlySingletonReference != null) {
         if (exposedObject == bean) {
            exposedObject = earlySingletonReference;
         }
         else if (!this.allowRawInjectionDespiteWrapping &amp;amp;&amp;amp; hasDependentBean(beanName)) {
            String[] dependentBeans = getDependentBeans(beanName);
            Set&amp;lt;String&amp;gt; actualDependentBeans = new LinkedHashSet&amp;lt;&amp;gt;(dependentBeans.length);
            for (String dependentBean : dependentBeans) {
               if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                  actualDependentBeans.add(dependentBean);
               }
            }
            if (!actualDependentBeans.isEmpty()) {
               throw new BeanCurrentlyInCreationException(beanName,
                     &amp;quot;Bean with name &#39;&amp;quot; + beanName + &amp;quot;&#39; has been injected into other beans [&amp;quot; +
                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
                     &amp;quot;] in its raw version as part of a circular reference, but has eventually been &amp;quot; +
                     &amp;quot;wrapped. This means that said other beans do not use the final version of the &amp;quot; +
                     &amp;quot;bean. This is often the result of over-eager type matching - consider using &amp;quot; +
                     &amp;quot;&#39;getBeanNamesOfType&#39; with the &#39;allowEagerInit&#39; flag turned off, for example.&amp;quot;);
            }
         }
      }
   }
   // Register bean as disposable.
   try {
      registerDisposableBeanIfNecessary(beanName, bean, mbd);
   }
   catch (BeanDefinitionValidationException ex) {
      throw new BeanCreationException(
            mbd.getResourceDescription(), beanName, &amp;quot;Invalid destruction signature&amp;quot;, ex);
   }
   return exposedObject;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 6 行的 BeanWrapper：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface BeanWrapper extends ConfigurablePropertyAccessor {
   /**
    * Return the bean instance wrapped by this object.
    */ 
   // 真实对象被 BeanWrapper 包装了，此方法可返回真实对象
   Object getWrappedInstance();
   /**
    * Obtain the PropertyDescriptors for the wrapped object
    * (as determined by standard JavaBeans introspection).
    * @return the PropertyDescriptors for the wrapped object
    */
    // 拿到当前类所有set方法以及属性
    PropertyDescriptor[] getPropertyDescriptors();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MyBatis 中通过 PropertyDescriptiors 拿到 DaoSupport 中所有的 set 方法，如果用 Bena 去拿就拿不到，因为 Bean 没有这个 getPropertyDescriptors() 方法.&lt;br&gt;
上述代码第 14 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final Object bean = instanceWrapper.getWrappedInstance();
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/pP3vXT3NuPdFl10t.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上述代码第 51 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;exposedObject = initializeBean(beanName, exposedObject, mbd);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Usp0Jdaj4VUS2rCE.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/f84P5zIwXEOHdDAR__thumbnail.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;当执行完 initializeBean 方法后，原生对象变成了代理对象，因此产生代理对象的逻辑（后置处理器的执行）是在 initializeBean 方法内。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {
   if (System.getSecurityManager() != null) {
      AccessController.doPrivileged((PrivilegedAction&amp;lt;Object&amp;gt;) () -&amp;gt; {
         invokeAwareMethods(beanName, bean);
         return null;
      }, getAccessControlContext());
   }
   else {
      invokeAwareMethods(beanName, bean);
   }
   Object wrappedBean = bean;
   if (mbd == null || !mbd.isSynthetic()) {
      // 执行所有的 BeanPostProcessor 的 postProcessBeforeInitialization 方法
      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
   }
   try {
      invokeInitMethods(beanName, wrappedBean, mbd);
   }
   catch (Throwable ex) {
      throw new BeanCreationException(
            (mbd != null ? mbd.getResourceDescription() : null),
            beanName, &amp;quot;Invocation of init method failed&amp;quot;, ex);
   }
   if (mbd == null || !mbd.isSynthetic()) {
      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
   }
   return wrappedBean;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 1 行参数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/ccXowFCJVQJC5Or9__thumbnail.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上述代码第 30 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/7a47oIqK7YxjiLdA.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;传进来的参数是原生对象，最终返回的是代理对象，于是得出结果：把原生对象变为代理对象的逻辑就在这个方法内。&lt;/p&gt;
&lt;p&gt;上述代码第 15 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/31119MWEqBNxDpOJ__thumbnail.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上述代码第 27 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/DJ2g1jLeAfvnxmEu.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)
      throws BeansException {
   Object result = existingBean;
   for (BeanPostProcessor processor : getBeanPostProcessors()) {
      Object current = processor.postProcessAfterInitialization(result, beanName);
      if (current == null) {
         return result;
      }
      result = current;
   }
   return result;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/41Nr3cCPIIdWbJkZ.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/LNrUMvC84nYPM5g2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;所以是在 processor.postProcessAfterInitialization(result, beanName); 方法内将原生对象变成了代理对象：AbstractAutoProxyCreator#postProcessAfterInitialization&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) throws BeansException {
   if (bean != null) {
      Object cacheKey = getCacheKey(bean.getClass(), beanName);
      if (!this.earlyProxyReferences.contains(cacheKey)) {
         return wrapIfNecessary(bean, beanName, cacheKey);
      }
   }
   return bean;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 5 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {
   if (StringUtils.hasLength(beanName) &amp;amp;&amp;amp; this.targetSourcedBeans.contains(beanName)) {
      return bean;
   }
   if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {
      return bean;
   }
   if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {
      this.advisedBeans.put(cacheKey, Boolean.FALSE);
      return bean;
   }
   // Create proxy if we have advice.
   // 解析所有配置的切面，看这个类是否符合切点描述的，如果符合就加上拦截器
   Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);
   if (specificInterceptors != DO_NOT_PROXY) {
      this.advisedBeans.put(cacheKey, Boolean.TRUE);
      Object proxy = createProxy(
            bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
      this.proxyTypes.put(cacheKey, proxy.getClass());
      return proxy;
   }
   this.advisedBeans.put(cacheKey, Boolean.FALSE);
   return bean;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 18 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected Object createProxy(Class&amp;lt;?&amp;gt; beanClass, @Nullable String beanName,
      @Nullable Object[] specificInterceptors, TargetSource targetSource) {
   if (this.beanFactory instanceof ConfigurableListableBeanFactory) {
      AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);
   }
   ProxyFactory proxyFactory = new ProxyFactory();
   proxyFactory.copyFrom(this);
   if (!proxyFactory.isProxyTargetClass()) {
      if (shouldProxyTargetClass(beanClass, beanName)) {
         proxyFactory.setProxyTargetClass(true);
      }
      else {
         evaluateProxyInterfaces(beanClass, proxyFactory);
      }
   }
   Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);
   proxyFactory.addAdvisors(advisors);
   proxyFactory.setTargetSource(targetSource);
   customizeProxyFactory(proxyFactory);
   proxyFactory.setFrozen(this.freezeProxy);
   if (advisorsPreFiltered()) {
      proxyFactory.setPreFiltered(true);
   }
   return proxyFactory.getProxy(getProxyClassLoader());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 30 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Object getProxy(@Nullable ClassLoader classLoader) {
   return createAopProxy().getProxy(classLoader);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected final synchronized AopProxy createAopProxy() {
   if (!this.active) {
      activate();
   }
   return getAopProxyFactory().createAopProxy(this);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Object getProxy(@Nullable ClassLoader classLoader) {
   return createAopProxy().getProxy(classLoader);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException { 
   if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {
      Class&amp;lt;?&amp;gt; targetClass = config.getTargetClass();
      if (targetClass == null) {
         throw new AopConfigException(&amp;quot;TargetSource cannot determine target class: &amp;quot; +
               &amp;quot;Either an interface or a target is required for proxy creation.&amp;quot;);
      }
      if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
         return new JdkDynamicAopProxy(config);
      }
      return new ObjenesisCglibAopProxy(config);
   }
   else {
      // 创建一个 JDK 动态代理返回
      return new JdkDynamicAopProxy(config);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先看第 2 行代码的判断：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一个条件：config.isOptimize()：可以在 xml 中配置 optimize，如果不配置默认 optimize=false;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/xPRuOoTpWagSzEsK.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ProxyConfig implements Serializable {
   private boolean proxyTargetClass = false;
   private boolean optimize = false;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二个条件：config.isProxyTargetClass(); proxyTargetClass 默认值也为 false。&lt;br&gt;
创建一个 JDK 动态代理后返回，沿着调用链 到 ProxyFactory#getProxy&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Object getProxy(@Nullable ClassLoader classLoader) {
   return createAopProxy().getProxy(classLoader);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来进入 getProxy 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Object getProxy(@Nullable ClassLoader classLoader) {
   if (logger.isDebugEnabled()) {
      logger.debug(&amp;quot;Creating JDK dynamic proxy: target source is &amp;quot; + this.advised.getTargetSource());
   }
   Class&amp;lt;?&amp;gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);
   findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);
   // 动态代理创建代理对象 
   return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总结：&lt;br&gt;
bean new出来 --&amp;gt; BeanPostProcessor --&amp;gt; doCreateBean() --&amp;gt; BeanWrapper --&amp;gt; beanWrapper.getBean() --&amp;gt; for(8个后置处理器)&lt;/p&gt;
&lt;h1 id=&#34;spring-如何处理-aop&#34;&gt;Spring 如何处理 AOP？&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;在后置处理器 AnnotationAwareAspectJAutoProxyCreator 内处理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AbstractApplicationContext#refresh() --&amp;gt; AbstractApplicationContext#registerBeanPostProcessors(beanFactory); --&amp;gt; 如果添加了 @EnableAspectJAutoProxy注解，就会利用 ImportBeanDefinitionRegistrar 动态注册一个后置处理器 AnnotationAwareAspectJAutoProxyCreator，完成代理。&lt;/p&gt;
&lt;h2 id=&#34;后置处理器在哪里处理&#34;&gt;后置处理器在哪里处理&lt;/h2&gt;
&lt;p&gt;AbstractApplicationContext#refresh() --&amp;gt; AbstractApplicationContext#finishBeanFactoryInitialization(beanFactory); --&amp;gt; DefaultListableBeanFactory#preInstantiateSingletons --&amp;gt; AbstractBeanFactory#getBean --&amp;gt; AbstractBeanFactory#doGetBean --&amp;gt; AbstractAutowireCapableBeanFactory#createBean --&amp;gt; AbstractAutowireCapableBeanFactory#doCreateBean：实例化BeanWrapper，然后通过 BeanWrapper 拿到原始对象 --&amp;gt; AbstractAutowireCapableBeanFactory#initializeBean：执行后置处理器，将原始对象变为代理对象，aop就是在这里完成的代理 --&amp;gt; applyBeanPostProcessorsAfterInitialization：执行后置处理器的 after 方法&lt;/p&gt;
">Spring系列（十三）Spring AOP源码分析</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/mybatis-xi-lie-san-mybatis-huan-cun/"" data-c="
          &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface IndexMapper {
    public void query();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;执行代理对象的-invoke-方法&#34;&gt;执行代理对象的 invoke 方法&lt;/h1&gt;
&lt;p&gt;动态代理为接口生成代理对象时，为什么会执行 invoke() 方法？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; public class Test {
    public static void main(String[] args) throws IOException {
        AnnotationConfigApplicationContext configApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
        byte[] bytes = ProxyGenerator.generateProxyClass(&amp;quot;mapper&amp;quot;, new Class[]{IndexMapper.class});
        FileOutputStream fw = new FileOutputStream(&amp;quot;C:\\Users\\Only\\IdeaProjects\\luban\\mapper.class&amp;quot;);
        fw.write(bytes);
        fw.flush();
        fw.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成的代理类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class mapper extends Proxy implements IndexMapper {
    private static Method m1;
    private static Method m3;
    private static Method m2;
    private static Method m0;
    public mapper(InvocationHandler var1) throws  {
        super(var1);
    }
    public final boolean equals(Object var1) throws  {
        try {
            return (Boolean)super.h.invoke(this, m1, new Object[]{var1});
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }
    public final void query() throws  {
        try {
            super.h.invoke(this, m3, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }
    public final String toString() throws  {
        try {
            return (String)super.h.invoke(this, m2, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }
    public final int hashCode() throws  {
        try {
            return (Integer)super.h.invoke(this, m0, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }
    static {
        try {
            m1 = Class.forName(&amp;quot;java.lang.Object&amp;quot;).getMethod(&amp;quot;equals&amp;quot;, Class.forName(&amp;quot;java.lang.Object&amp;quot;));
            m3 = Class.forName(&amp;quot;com.ssm.service.IndexMapper&amp;quot;).getMethod(&amp;quot;query&amp;quot;);
            m2 = Class.forName(&amp;quot;java.lang.Object&amp;quot;).getMethod(&amp;quot;toString&amp;quot;);
            m0 = Class.forName(&amp;quot;java.lang.Object&amp;quot;).getMethod(&amp;quot;hashCode&amp;quot;);
        } catch (NoSuchMethodException var2) {
            throw new NoSuchMethodError(var2.getMessage());
        } catch (ClassNotFoundException var3) {
            throw new NoClassDefFoundError(var3.getMessage());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当调用接口的 query() 时，实际执行的是代理对象的 query() 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;super.h.invoke(this, m3, (Object[])null);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在代理对象的 query() 方法中调用了 “实现了 InvocationHandler 接口的类” 的 invoke() 方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) throws IOException {
        AnnotationConfigApplicationContext configApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
        configApplicationContext.getBean(IndexService.class).list();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当调用 Service 中的 list() 方法时，会调用 mapper 的 list() 方法，实际调用的是 mapper 的代理对象的 list() 方法，即 实现了 InvocationHandler 接口的类的 invoke() 方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class IndexService implements InitializingBean {
    @Autowired
    UserMapper userMapper;
    public List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt; list(){
        return userMapper.list();
    }
    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println(&amp;quot;app...&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserMapper {
    @Select(&amp;quot;select * from t1&amp;quot;)
    List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt; list();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用 Mapper 代理对象：MapperProxy 的 invoke() 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MapperProxy&amp;lt;T&amp;gt; implements InvocationHandler, Serializable {
  //...
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    try {
      if (Object.class.equals(method.getDeclaringClass())) {
        return method.invoke(this, args);
      } else if (isDefaultMethod(method)) {
        return invokeDefaultMethod(proxy, method, args);
      }
    } catch (Throwable t) {
      throw ExceptionUtil.unwrapThrowable(t);
    }
    // MapperMethod 包含了当前方法，比如 list() 的所有信息：注解
    final MapperMethod mapperMethod = cachedMapperMethod(method);
    // 在 spring 中，当产生代理对象时，sqlSession 已经被替换成了 SqlSessionTemplate 
    return mapperMethod.execute(sqlSession, args);
  }
  //...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;execute() 方法判断当前注解是什么类型操作：增、删、改、查&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Object execute(SqlSession sqlSession, Object[] args) {
  Object result;
  switch (command.getType()) {
    case INSERT: {
    Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.insert(command.getName(), param));
      break;
    }
    case UPDATE: {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.update(command.getName(), param));
      break;
    }
    case DELETE: {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.delete(command.getName(), param));
      break;
    }
    case SELECT:
      if (method.returnsVoid() &amp;amp;&amp;amp; method.hasResultHandler()) {
        executeWithResultHandler(sqlSession, args);
        result = null;
      } else if (method.returnsMany()) {
        // SELECT 返回结果有多条，执行此方法
        result = executeForMany(sqlSession, args);
      } else if (method.returnsMap()) {
        result = executeForMap(sqlSession, args);
      } else if (method.returnsCursor()) {
        result = executeForCursor(sqlSession, args);
      } else {
        Object param = method.convertArgsToSqlCommandParam(args);
        result = sqlSession.selectOne(command.getName(), param);
      }
      break;
    case FLUSH:
      result = sqlSession.flushStatements();
      break;
    default:
      throw new BindingException(&amp;quot;Unknown execution method for: &amp;quot; + command.getName());
  }
  if (result == null &amp;amp;&amp;amp; method.getReturnType().isPrimitive() &amp;amp;&amp;amp; !method.returnsVoid()) {
    throw new BindingException(&amp;quot;Mapper method &#39;&amp;quot; + command.getName() 
        + &amp;quot; attempted to return null from a method with a primitive return type (&amp;quot; + method.getReturnType() + &amp;quot;).&amp;quot;);
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private &amp;lt;E&amp;gt; Object executeForMany(SqlSession sqlSession, Object[] args) {
  List&amp;lt;E&amp;gt; result;
  Object param = method.convertArgsToSqlCommandParam(args);
  if (method.hasRowBounds()) {
    RowBounds rowBounds = method.extractRowBounds(args);
    result = sqlSession.&amp;lt;E&amp;gt;selectList(command.getName(), param, rowBounds);
  } else {
    // 调用 sqlSession 的 selectList 方法
    result = sqlSession.&amp;lt;E&amp;gt;selectList(command.getName(), param);
  }
  // issue #510 Collections &amp;amp; arrays support
  if (!method.getReturnType().isAssignableFrom(result.getClass())) {
    if (method.getReturnType().isArray()) {
      return convertToArray(result);
    } else {
      return convertToDeclaredCollection(sqlSession.getConfiguration(), result);
    }
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果使用 Spring，sqlSession 就是 SqlSessionTemplate 类型；如果不使用 Spring，单独使用 MyBatis，sqlSession 就是 DefaultSqlSession 类型。&lt;/p&gt;
&lt;h1 id=&#34;defaultsqlsession&#34;&gt;DefaultSqlSession&lt;/h1&gt;
&lt;p&gt;DefaultSqlSession#selectList&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; selectList(String statement, Object parameter, RowBounds rowBounds) {
  try {
    MappedStatement ms = configuration.getMappedStatement(statement);
    // 直接用 executor 执行 query 方法
    return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
  } catch (Exception e) {
    throw ExceptionFactory.wrapException(&amp;quot;Error querying database.  Cause: &amp;quot; + e, e);
  } finally {
    ErrorContext.instance().reset();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;sqlsessiontemplate&#34;&gt;SqlSessionTemplate&lt;/h1&gt;
&lt;p&gt;SqlSessionTemplate#selectList&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; selectList(String statement, Object parameter) {
  // 调用代理对象的 selectList
  return this.sqlSessionProxy.&amp;lt;E&amp;gt; selectList(statement, parameter);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MapperProxy 的 invoke() 方法中的 sqlSession 已经被替换成了 SqlSessionTemplate，但它具体是在什么时候被替换的现在还不知道。&lt;br&gt;
SqlSessionTemplate 肯定会被赋值给 sqlSession，但是具体什么时候赋值的不知道，于是看它什么时候被实例化，于是断点在 SqlSessionTemplate 实例化的地方进行调试。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public SqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
  this(sqlSessionFactory, sqlSessionFactory.getConfiguration().getDefaultExecutorType());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) {
  if (!this.externalSqlSession) {
    this.sqlSession = new SqlSessionTemplate(sqlSessionFactory);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;沿着 setSqlSessionFactory 的调用链向下找发现了：AbstractAutowireCapableBeanFactory#doCreateBean&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;populateBean(beanName, mbd, instanceWrapper);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在创建 UserMapper 时实例化了 sqlSessionFactory&lt;/p&gt;
&lt;h1 id=&#34;哪些属性需要自动装配&#34;&gt;哪些属性需要自动装配？&lt;/h1&gt;
&lt;p&gt;Spring 当中有自动装配，当创建 MapperFactoryBean 时，要看这个类里面的属性是否需要自动装配：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MapperFactoryBean&amp;lt;T&amp;gt; extends SqlSessionDaoSupport implements FactoryBean&amp;lt;T&amp;gt; {
  // mapperInterface 不需要自动装配 ，因为自动装配忽略 Class 类型
  private Class&amp;lt;T&amp;gt; mapperInterface;
  // addToConfig 需要自动装配
  private boolean addToConfig = true;
  
  public void setAddToConfig(boolean addToConfig) {
    this.addToConfig = addToConfig;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它的父类 SqlSessionDaoSupport 中的属性是否需要自动装配：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class SqlSessionDaoSupport extends DaoSupport {
  // 不需要自动装配，因为没有对应的 set 方法
  private SqlSession sqlSession;
  // 不需要自动装配，因为没有对应的 set 方法
  private boolean externalSqlSession;
  // sqlSessionFactory 需要自动装配，因为有 set 方法
  public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) {
    if (!this.externalSqlSession) {
      this.sqlSession = new SqlSessionTemplate(sqlSessionFactory);
    }
  }
  // sqlSessionTemplate 需要自动装配，因为有 set 方法
  public void setSqlSessionTemplate(SqlSessionTemplate sqlSessionTemplate) {
    this.sqlSession = sqlSessionTemplate;
    this.externalSqlSession = true;
  }
  //......
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sqlSessionFactory 和 sqlSessionTemplate 由于有 set 方法，所以需要自动装配。&lt;br&gt;
Spring 在创建 IndexService 时，发现它依赖了 UserMapper：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class IndexService implements InitializingBean {
    @Autowired
    UserMapper userMapper;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;于是就去创建 UserMapper，发现 MapperFactoryBean 中有很多依赖，然后决定是否注入这些依赖。&lt;br&gt;
断点在：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) {
  if (!this.externalSqlSession) {
    this.sqlSession = new SqlSessionTemplate(sqlSessionFactory);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用链如下：&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/setSqlSessionFactory%E8%B0%83%E7%94%A8%E9%93%BE.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AF%BB%E5%8F%96indexService.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;populateBean 用来设置类的属性的，发现 IndexService 类中有一个属性 UserMapper，于是就去创建 UserMapper&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/indexService%E6%9C%89%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7UserMapper.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;当自动装配时，如果属性的类型是 Class 的直接忽略&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%8B%BF%E5%88%B0%E4%B9%8B%E5%89%8D%E6%B7%BB%E5%8A%A0%E7%9A%84addToConfig.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;类中的属性如何拿到？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) {
   PropertyValues pvs = mbd.getPropertyValues();
   if (bw == null) {
      if (!pvs.isEmpty()) {
         throw new BeanCreationException(
               mbd.getResourceDescription(), beanName, &amp;quot;Cannot apply property values to null instance&amp;quot;);
      }
      else {
         // Skip property population phase for null instance.
         return;
      }
   }
   // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the
   // state of the bean before properties are set. This can be used, for example,
   // to support styles of field injection.
   boolean continueWithPropertyPopulation = true;
   if (!mbd.isSynthetic() &amp;amp;&amp;amp; hasInstantiationAwareBeanPostProcessors()) {
      for (BeanPostProcessor bp : getBeanPostProcessors()) {
         if (bp instanceof InstantiationAwareBeanPostProcessor) {
            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
            if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
               continueWithPropertyPopulation = false;
               break;
            }
         }
      }
   }
   if (!continueWithPropertyPopulation) {
      return;
   }
    
   // 拿出当前对象自动注入的模型，如果是 BY_NAME 或 BY_TYPE，才会进入这个 if 分支
   if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||
         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
      //  用原来的 pvs 定义一个新的 newPvs
      MutablePropertyValues newPvs = new MutablePropertyValues(pvs);
      // Add property values based on autowire by name if applicable.
      if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {
         autowireByName(beanName, mbd, bw, newPvs);
      }
      // Add property values based on autowire by type if applicable.
      if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
         autowireByType(beanName, mbd, bw, newPvs);
      }
      pvs = newPvs;
   }
   boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
   boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);
   if (hasInstAwareBpps || needsDepCheck) {
      PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
      if (hasInstAwareBpps) {
         for (BeanPostProcessor bp : getBeanPostProcessors()) {
            if (bp instanceof InstantiationAwareBeanPostProcessor) {
               InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
               pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
               if (pvs == null) {
                  return;
               }
            }
         }
      }
      if (needsDepCheck) {
         checkDependencies(beanName, mbd, filteredPds, pvs);
      }
   }
   applyPropertyValues(beanName, mbd, bw, pvs);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/newPvs.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;所以分析是上面的 autowireByType 注入了 sqlSessionFactory 属性&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void autowireByType(
      String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {
   TypeConverter converter = getCustomTypeConverter();
   if (converter == null) {
      converter = bw;
   }
   Set&amp;lt;String&amp;gt; autowiredBeanNames = new LinkedHashSet&amp;lt;String&amp;gt;(4);
   String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);
   for (String propertyName : propertyNames) {
      try {
         PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);
         // Don&#39;t try autowiring by type for type Object: never makes sense,
         // even if it technically is a unsatisfied, non-simple property.
         if (Object.class != pd.getPropertyType()) {
            MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);
            // Do not allow eager init for type matching in case of a prioritized post-processor.
            boolean eager = !PriorityOrdered.class.isAssignableFrom(bw.getWrappedClass());
            DependencyDescriptor desc = new AutowireByTypeDependencyDescriptor(methodParam, eager);
            Object autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);
            if (autowiredArgument != null) {
               pvs.add(propertyName, autowiredArgument);
            }
            for (String autowiredBeanName : autowiredBeanNames) {
               registerDependentBean(autowiredBeanName, beanName);
               if (logger.isDebugEnabled()) {
                  logger.debug(&amp;quot;Autowiring by type from bean name &#39;&amp;quot; + beanName + &amp;quot;&#39; via property &#39;&amp;quot; +
                        propertyName + &amp;quot;&#39; to bean named &#39;&amp;quot; + autowiredBeanName + &amp;quot;&#39;&amp;quot;);
               }
            }
            autowiredBeanNames.clear();
         }
      }
      catch (BeansException ex) {
         throw new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/propertyNames.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;字符串中有两个值，addToConfig 已经被包含了，mapperInterface 是 Class 不注入，所以共有 sqlSessionFactory 和 sqlSessionTemplate 两个属性。&lt;/p&gt;
&lt;p&gt;接下来看 unsatisfiedNonSimpleProperties 方法是如何得到这两个值的？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected String[] unsatisfiedNonSimpleProperties(AbstractBeanDefinition mbd, BeanWrapper bw) {
   Set&amp;lt;String&amp;gt; result = new TreeSet&amp;lt;String&amp;gt;();
   PropertyValues pvs = mbd.getPropertyValues();
   // PropertyDescriptor 属性描述器：拿出所有的属性
   PropertyDescriptor[] pds = bw.getPropertyDescriptors();
   for (PropertyDescriptor pd : pds) {
      if (pd.getWriteMethod() != null &amp;amp;&amp;amp; !isExcludedFromDependencyCheck(pd) &amp;amp;&amp;amp; !pvs.contains(pd.getName()) &amp;amp;&amp;amp;
            !BeanUtils.isSimpleProperty(pd.getPropertyType())) {
         result.add(pd.getName());
      }
   }
   return StringUtils.toStringArray(result);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/pds%E6%8B%BF%E5%87%BA%E6%89%80%E6%9C%89%E7%9A%84%E5%B1%9E%E6%80%A7.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;spring-如何判断一个类是一个属性&#34;&gt;Spring 如何判断一个类是一个属性&lt;/h2&gt;
&lt;p&gt;readMethod：有 get 方法就认为这是一个属性；writeMethod：有 set 方法就认为这是一个属性&lt;/p&gt;
&lt;h3 id=&#34;addtoconfig&#34;&gt;addToConfig&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;因为 MapperFactoryBean 类中有这个属性&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/pds_addToConfig.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;class&#34;&gt;class&lt;/h3&gt;
&lt;p&gt;为什么会有一个 class 属性？任意一个对象都可以 xxx.getClass()，所以认为 class 是一个属性&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/pds_class.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;mapperinterface&#34;&gt;mapperInterface&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;因为 MapperFactoryBean 类中有这个属性&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/pds_mapperInterface.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;object&#34;&gt;object&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MapperFactoryBean  是一个 FactoryBean，Bean 当中都有一个 getObject() 方法，因为有 getObject() 方法，所以认为 object 是一个属性&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/pds_object.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;objecttype&#34;&gt;objectType&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;因为有 getObjectType() 方法，所以任务 objectType 是一个属性&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/pds_objectType.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;single&#34;&gt;single&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;boolean flag; 默认将 getFlag() 改成 isFlag()，因为有 isFlag() 属性，所以认为 singleton 是一个属性。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/pds_singleton.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;sqlsession&#34;&gt;sqlSession&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;因为 SqlSessionDaoSupport 中有 getSqlSession(); 所以认为 sqlSession 是一个属性。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/pds_sqlSession.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;sqlsessionfactory&#34;&gt;sqlSessionFactory&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/pds_sqlSessionFactory.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;sqlsessiontemplate-2&#34;&gt;sqlSessionTemplate&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/pds_sqlSessionTmplate.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;判断哪些类需要自动装配&#34;&gt;判断哪些类需要自动装配&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected String[] unsatisfiedNonSimpleProperties(AbstractBeanDefinition mbd, BeanWrapper bw) {
   Set&amp;lt;String&amp;gt; result = new TreeSet&amp;lt;String&amp;gt;();
   PropertyValues pvs = mbd.getPropertyValues();
   PropertyDescriptor[] pds = bw.getPropertyDescriptors();
   for (PropertyDescriptor pd : pds) {
      if (pd.getWriteMethod() != null &amp;amp;&amp;amp; !isExcludedFromDependencyCheck(pd) &amp;amp;&amp;amp; !pvs.contains(pd.getName()) &amp;amp;&amp;amp;
            !BeanUtils.isSimpleProperty(pd.getPropertyType())) {
         result.add(pd.getName());
      }
   }
   return StringUtils.toStringArray(result);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;判断哪些类需要自动装配的核心代码第 6-7 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if (pd.getWriteMethod() != null &amp;amp;&amp;amp; !isExcludedFromDependencyCheck(pd) &amp;amp;&amp;amp; !pvs.contains(pd.getName()) &amp;amp;&amp;amp;
            !BeanUtils.isSimpleProperty(pd.getPropertyType()))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先看第一个条件：pd.getWriteMethod() != null：将 name=class、name=object、name=objectType、name=singleton、name=sqlSession 这5 个属性忽略掉，即它们不需要自动装配，因为它们的 writeMethod=null。&lt;br&gt;
这也就解释了 AUTOWIRED_BY_TYPE 只关心 set 方法，因为如果没有 set 方法，writeMethod=null，不满足 pd.getWriteMethod() != null 条件，就会被过滤掉，不会自动装配。&lt;/p&gt;
&lt;p&gt;经过第一个条件判断后还剩下 4 个属性：addToConfig、mapperInterface、SqlSessionFactory、SqlSessionTemplate&lt;/p&gt;
&lt;p&gt;接下来看第二个条件：!isExcludedFromDependencyCheck(pd)：自定义设置过滤接口，由于没有自行设置过滤，所以可暂时忽略这个条件判断。&lt;/p&gt;
&lt;p&gt;下面看第三个条件：!pvs.contains(pd.getName())：pvs 不包含 pd.getName()，如果一个类在 pd 中，就会被过滤掉，不自动装配，比如 addToConfig 就会被过滤掉。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/pvs%E5%8C%85%E5%90%ABpd.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;pvs 是 Spring 自动设置给它的，&lt;/p&gt;
&lt;p&gt;@Mapper --- &amp;gt; @Import(MapperScannerRegistrar.class) ---&amp;gt; MapperScannerRegistrar#registerBeanDefinitions ---&amp;gt; ClassPathMapperScanner#doScan ---&amp;gt; org.mybatis.spring.mapper.ClassPathMapperScanner#processBeanDefinitions&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;definition.getPropertyValues().add(&amp;quot;addToConfig&amp;quot;, this.addToConfig);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自己设置一个值，不需要自动装配，放到 pd 中。&lt;br&gt;
经过上述三个判断条件后还剩下 3 个属性：mapperInterface、SqlSessionFactory、SqlSessionTemplate&lt;/p&gt;
&lt;p&gt;接下来来第四个条件：!BeanUtils.isSimpleProperty(pd.getPropertyType()：不是简单类型，来看一下什么是简单类型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static boolean isSimpleProperty(Class&amp;lt;?&amp;gt; clazz) {
   Assert.notNull(clazz, &amp;quot;Class must not be null&amp;quot;);
   return isSimpleValueType(clazz) || (clazz.isArray() &amp;amp;&amp;amp; isSimpleValueType(clazz.getComponentType()));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static boolean isSimpleValueType(Class&amp;lt;?&amp;gt; clazz) {
   return (ClassUtils.isPrimitiveOrWrapper(clazz) ||
         Enum.class.isAssignableFrom(clazz) ||
         CharSequence.class.isAssignableFrom(clazz) ||
         Number.class.isAssignableFrom(clazz) ||
         Date.class.isAssignableFrom(clazz) ||
         URI.class == clazz || URL.class == clazz ||
         Locale.class == clazz || Class.class == clazz);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由上述代码可知，简单类型为：Enum、CharSequence、Number、Date、URI、URI、Locale、Class&lt;br&gt;
所以第四个判断条件会过滤掉 mapperInterface，name = mapperInterface 的属性 getPropertyType() 方法返回 java.lang.Class&lt;/p&gt;
&lt;p&gt;最终，经过四个判断后，还剩下 SqlSessionFactory、SqlSessionTemplate 这两个属性。&lt;/p&gt;
&lt;h1 id=&#34;如何判断一个类中的某个属性是否需要自动装配&#34;&gt;如何判断一个类中的某个属性是否需要自动装配？&lt;/h1&gt;
&lt;h3 id=&#34;默认-autowire_no&#34;&gt;默认 AUTOWIRE_NO&lt;/h3&gt;
&lt;p&gt;有一个 OrderClazz 类交给 Spring 管理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class OrderClazz {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;UserClazz 类交给 Spring 管理，UserClazz 类依赖 OrderClazz：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class UserClazz {
    // orderClazz 是否会自动装配？会
    private OrderClazz orderClazz;
    public OrderClazz getOrderClazz() {
        return orderClazz;
    }
    public void setOrderClazz(OrderClazz orderClazz) {
        this.orderClazz = orderClazz;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个测试类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) throws IOException {
        AnnotationConfigApplicationContext configApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
        OrderClazz orderClazz = configApplicationContext.getBean(UserClazz.class).getOrderClazz();
        System.out.println(orderClazz);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打印结果：null，而不是报错没有这个 bean。&lt;br&gt;
自动装配有三种类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Constant that indicates no autowiring at all.
 * @see #setAutowireMode
 */
public static final int AUTOWIRE_NO = AutowireCapableBeanFactory.AUTOWIRE_NO;
/**
 * Constant that indicates autowiring bean properties by name.
 * @see #setAutowireMode
 */
public static final int AUTOWIRE_BY_NAME = AutowireCapableBeanFactory.AUTOWIRE_BY_NAME;
/**
 * Constant that indicates autowiring bean properties by type.
 * @see #setAutowireMode
 */
public static final int AUTOWIRE_BY_TYPE = AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Spring 默认自动装配规则 AUTOWIRE_NO：不自动装配，但是加了 @Autowired 或 @Resource 的会自动装配：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class UserClazz{
  @Autowired
  private OrderClazz orderClazz;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果使用自动装配规则 AUTOWIRE_BY_TYPE，会根据属性的 set 方法进行装配，无需 @Autowired 注解：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class UserClazz{
  private OrderClazz orderClazz;
  public OrderClazz getOrderClazz() {
    return orderClazz;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;设置自动装配类型为-autowire_by_type&#34;&gt;设置自动装配类型为 AUTOWIRE_BY_TYPE&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SSMScanRegistrar implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        GenericBeanDefinition userClazz = (GenericBeanDefinition) registry.getBeanDefinition(&amp;quot;userClazz&amp;quot;);
        // 设置自动装配类型为 AUTOWIRE_BY_TYPE
userClazz.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);
        registry.registerBeanDefinition(&amp;quot;userClazz&amp;quot;,userClazz);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动类扫描 SSMScanRegistrar&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
@MapperScan(&amp;quot;com.ssm.dao&amp;quot;)
@Import(SSMScanRegistrar.class)
public class AppConfig{
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试类打印：com.ssm.manager.OrderClazz@4c12331b&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class UserClazz {
//    private OrderClazz orderClazz;
    public OrderClazz getOrderClazz() {
        return null;
    }
    public void setOrderClazz(OrderClazz orderClazz) {
//        this.orderClazz = orderClazz;
        System.out.println(&amp;quot;---------&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试类打印：---------&lt;br&gt;
AUTOWIRE_BY_TYPE 读取 set 方法，当有 set 方法，就认为 set 方法的参数对应的类 OrderClazz  需要自动装配。&lt;/p&gt;
&lt;p&gt;如果去掉 set 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class UserClazz {
    private OrderClazz orderClazz;
    public OrderClazz getOrderClazz() {
        return orderClazz;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试类打印：null&lt;br&gt;
AUTOWIRE_BY_TYPE 根据 set 方法进行自动装配，与属性的声明无关。上述虽然声明了属性，但没有 set 方法，所以 orderClazz 并没有被赋值。&lt;/p&gt;
&lt;p&gt;当实例化 MapperFactoryBean 时：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Import(MapperScannerRegistrar.class)
public @interface MapperScan {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MapperScannerRegistrar#registerBeanDefinitions ---&amp;gt; ClassPathMapperScanner#doScan ---&amp;gt; ClassPathMapperScanner#processBeanDefinitions&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void processBeanDefinitions(Set&amp;lt;BeanDefinitionHolder&amp;gt; beanDefinitions) {
  GenericBeanDefinition definition;
  for (BeanDefinitionHolder holder : beanDefinitions) {
    definition = (GenericBeanDefinition) holder.getBeanDefinition();
    if (logger.isDebugEnabled()) {
      logger.debug(&amp;quot;Creating MapperFactoryBean with name &#39;&amp;quot; + holder.getBeanName() 
        + &amp;quot;&#39; and &#39;&amp;quot; + definition.getBeanClassName() + &amp;quot;&#39; mapperInterface&amp;quot;);
    }
    // the mapper interface is the original class of the bean
    // but, the actual class of the bean is MapperFactoryBean
    definition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName()); // issue #59
    // 
    definition.setBeanClass(this.mapperFactoryBean.getClass());
    definition.getPropertyValues().add(&amp;quot;addToConfig&amp;quot;, this.addToConfig);
    boolean explicitFactoryUsed = false;
    if (StringUtils.hasText(this.sqlSessionFactoryBeanName)) {
      definition.getPropertyValues().add(&amp;quot;sqlSessionFactory&amp;quot;, new RuntimeBeanReference(this.sqlSessionFactoryBeanName));
      explicitFactoryUsed = true;
    } else if (this.sqlSessionFactory != null) {
      definition.getPropertyValues().add(&amp;quot;sqlSessionFactory&amp;quot;, this.sqlSessionFactory);
      explicitFactoryUsed = true;
    }
    if (StringUtils.hasText(this.sqlSessionTemplateBeanName)) {
      if (explicitFactoryUsed) {
        logger.warn(&amp;quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&amp;quot;);
      }
      definition.getPropertyValues().add(&amp;quot;sqlSessionTemplate&amp;quot;, new RuntimeBeanReference(this.sqlSessionTemplateBeanName));
      explicitFactoryUsed = true;
    } else if (this.sqlSessionTemplate != null) {
      if (explicitFactoryUsed) {
        logger.warn(&amp;quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&amp;quot;);
      }
      definition.getPropertyValues().add(&amp;quot;sqlSessionTemplate&amp;quot;, this.sqlSessionTemplate);
      explicitFactoryUsed = true;
    }
    if (!explicitFactoryUsed) {
      if (logger.isDebugEnabled()) {
        logger.debug(&amp;quot;Enabling autowire by type for MapperFactoryBean with name &#39;&amp;quot; + holder.getBeanName() + &amp;quot;&#39;.&amp;quot;);
      }
      // mapper 自动注入类型修改为 AUTOWIRE_BY_TYPE
            definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当实例化 MapperFactoryBean 时，由于 addToConfig 有 set 方法，所以会自动装配 addToConfig：&lt;br&gt;
MapperFactoryBean#setAddToConfig&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void setAddToConfig(boolean addToConfig) {
  this.addToConfig = addToConfig;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于 MapperFactoryBean 继承了 SqlSessionDaoSupport：&lt;br&gt;
SqlSessionDaoSupport # 所有set方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class SqlSessionDaoSupport extends DaoSupport {
  private SqlSession sqlSession;
  private boolean externalSqlSession;
  public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) {
    if (!this.externalSqlSession) {
      this.sqlSession = new SqlSessionTemplate(sqlSessionFactory);
    }
  }
  public void setSqlSessionTemplate(SqlSessionTemplate sqlSessionTemplate) {
    this.sqlSession = sqlSessionTemplate;
    this.externalSqlSession = true;
  }
  //......
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为有 setSqlSessionFactory 和  setSqlSessionTemplate 方法，所以会自动装配 sqlSessionTemplate 和 sqlSessionFactory，所以 sqlSessionTemplate 是在实例化 MapperFactoryBean 时被赋值的。&lt;br&gt;
为什么不直接使用 @Autowired SqlSession sqlSesssion; 自动注入？解耦。&lt;/p&gt;
&lt;p&gt;如果写了 @Autowired，永远依赖 Spring 去编译。&lt;/p&gt;
&lt;h1 id=&#34;mybatis-整合-spring-流程&#34;&gt;MyBatis 整合 Spring 流程&lt;/h1&gt;
&lt;p&gt;扫描，实例化各种 mapper，通过 @MapperScan 把 mapper 变成 MapperFactoryBean，&lt;/p&gt;
&lt;p&gt;在实例化过程中，MyBatis 会产生两个代理对象，mapper 代理对象；往 mapper 的代理对象中注入一个 SqlSessionTemplate，执行 SqlSessionTemplate 的代理方法，代理方法中关闭 sqlSession，一级缓存 map 失效，&lt;/p&gt;
&lt;p&gt;当执行 userMapper.list() 时，实际上执行的是代理对象 MappperProxy 的 invoke()&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
  try {
    if (Object.class.equals(method.getDeclaringClass())) {
      return method.invoke(this, args);
    } else if (isDefaultMethod(method)) {
      return invokeDefaultMethod(proxy, method, args);
    }
  } catch (Throwable t) {
    throw ExceptionUtil.unwrapThrowable(t);
  }
  final MapperMethod mapperMethod = cachedMapperMethod(method);
  return mapperMethod.execute(sqlSession, args);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 11 行：MapperProxy#cachedMapperMethod&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private MapperMethod cachedMapperMethod(Method method) {
  MapperMethod mapperMethod = methodCache.get(method);
  if (mapperMethod == null) {
    mapperMethod = new MapperMethod(mapperInterface, method, sqlSession.getConfiguration());
    methodCache.put(method, mapperMethod);
  }
  return mapperMethod;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 4 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public MapperMethod(Class&amp;lt;?&amp;gt; mapperInterface, Method method, Configuration config) {
  this.command = new SqlCommand(config, mapperInterface, method);
  this.method = new MethodSignature(config, mapperInterface, method);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 2 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public SqlCommand(Configuration configuration, Class&amp;lt;?&amp;gt; mapperInterface, Method method) {
  final String methodName = method.getName();
  final Class&amp;lt;?&amp;gt; declaringClass = method.getDeclaringClass();
  MappedStatement ms = resolveMappedStatement(mapperInterface, methodName, declaringClass,
      configuration);
  if (ms == null) {
    if (method.getAnnotation(Flush.class) != null) {
      name = null;
      type = SqlCommandType.FLUSH;
    } else {
      throw new BindingException(&amp;quot;Invalid bound statement (not found): &amp;quot;
          + mapperInterface.getName() + &amp;quot;.&amp;quot; + methodName);
    }
  } else {
    name = ms.getId();
    type = ms.getSqlCommandType();
    if (type == SqlCommandType.UNKNOWN) {
      throw new BindingException(&amp;quot;Unknown execution method for: &amp;quot; + name);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 4 行：&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/mapperStatement.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;执行完 org.apache.ibatis.binding.MapperMethod.SqlCommand#resolveMappedStatement 方法，能够得到 SQL 语句。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private MappedStatement resolveMappedStatement(Class&amp;lt;?&amp;gt; mapperInterface, String methodName,
    Class&amp;lt;?&amp;gt; declaringClass, Configuration configuration) {
    // 方法名：List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt; list(); 为什么要和 mapper 的 id：&amp;lt;select id=&amp;quot;list&amp;quot; &amp;gt; 相同：通过命名空间+方法名得到 statementId：com.ssm.mapper.UserMapper.list
  String statementId = mapperInterface.getName() + &amp;quot;.&amp;quot; + methodName;
  // 判断 configuration 是否包含 statementId
  if (configuration.hasStatement(statementId)) {
    // 通过 configuration 得到 statementId 对应的 MappedStatement 
    return configuration.getMappedStatement(statementId);
  } else if (mapperInterface.equals(declaringClass)) {
    return null;
  }
  for (Class&amp;lt;?&amp;gt; superInterface : mapperInterface.getInterfaces()) {
    if (declaringClass.isAssignableFrom(superInterface)) {
      MappedStatement ms = resolveMappedStatement(superInterface, methodName,
          declaringClass, configuration);
      if (ms != null) {
        return ms;
      }
    }
  }
  return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 8 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public MappedStatement getMappedStatement(String id) {
  return this.getMappedStatement(id, true);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public MappedStatement getMappedStatement(String id, boolean validateIncompleteStatements) {
  if (validateIncompleteStatements) {
    buildAllStatements();
  }
  return mappedStatements.get(id);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected final Map&amp;lt;String, MappedStatement&amp;gt; mappedStatements = new StrictMap&amp;lt;MappedStatement&amp;gt;(&amp;quot;Mapped Statements collection&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先把 SQL 语句 放到 mappedStatements 中，然后通过 mappedStatements.get(id) 拿出 SQL 语句，在 execute(sql) 执行 SQL 语句&lt;br&gt;
上述 invoke 方法的第 12 行：&lt;/p&gt;
&lt;p&gt;MapperMethod#execute&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Object execute(SqlSession sqlSession, Object[] args) {
  Object result;
  switch (command.getType()) {
    case INSERT: {
    Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.insert(command.getName(), param));
      break;
    }
    case UPDATE: {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.update(command.getName(), param));
      break;
    }
    case DELETE: {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.delete(command.getName(), param));
      break;
    }
    case SELECT:
      if (method.returnsVoid() &amp;amp;&amp;amp; method.hasResultHandler()) {
        executeWithResultHandler(sqlSession, args);
        result = null;
      } else if (method.returnsMany()) {
        result = executeForMany(sqlSession, args);
      } else if (method.returnsMap()) {
        result = executeForMap(sqlSession, args);
      } else if (method.returnsCursor()) {
        result = executeForCursor(sqlSession, args);
      } else {
        Object param = method.convertArgsToSqlCommandParam(args);
        result = sqlSession.selectOne(command.getName(), param);
      }
      break;
    case FLUSH:
      result = sqlSession.flushStatements();
      break;
    default:
      throw new BindingException(&amp;quot;Unknown execution method for: &amp;quot; + command.getName());
  }
  if (result == null &amp;amp;&amp;amp; method.getReturnType().isPrimitive() &amp;amp;&amp;amp; !method.returnsVoid()) {
    throw new BindingException(&amp;quot;Mapper method &#39;&amp;quot; + command.getName() 
        + &amp;quot; attempted to return null from a method with a primitive return type (&amp;quot; + method.getReturnType() + &amp;quot;).&amp;quot;);
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 24 行：MapperMethod#executeForMany&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private &amp;lt;E&amp;gt; Object executeForMany(SqlSession sqlSession, Object[] args) {
  List&amp;lt;E&amp;gt; result;
  Object param = method.convertArgsToSqlCommandParam(args);
  if (method.hasRowBounds()) {
    RowBounds rowBounds = method.extractRowBounds(args);
    result = sqlSession.&amp;lt;E&amp;gt;selectList(command.getName(), param, rowBounds);
  } else {
    result = sqlSession.&amp;lt;E&amp;gt;selectList(command.getName(), param);
  }
  // issue #510 Collections &amp;amp; arrays support
  if (!method.getReturnType().isAssignableFrom(result.getClass())) {
    if (method.getReturnType().isArray()) {
      return convertToArray(result);
    } else {
      return convertToDeclaredCollection(sqlSession.getConfiguration(), result);
    }
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DefaultSqlSession#selectList&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; selectList(String statement, Object parameter) {
  return this.selectList(statement, parameter, RowBounds.DEFAULT);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/statement.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; selectList(String statement, Object parameter, RowBounds rowBounds) {
  try {
    MappedStatement ms = configuration.getMappedStatement(statement);
    return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
  } catch (Exception e) {
    throw ExceptionFactory.wrapException(&amp;quot;Error querying database.  Cause: &amp;quot; + e, e);
  } finally {
    ErrorContext.instance().reset();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/ms.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {
  BoundSql boundSql = ms.getBoundSql(parameterObject);
  CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);
  return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/BoundSql.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;MyBatis 中的所有信息，包括 SQL 语句、返回类型信息都存在了 mappedStatements 中。&lt;/p&gt;
&lt;p&gt;什么时候把 mapper 信息放到 mappedStatements 中的？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void addMappedStatement(MappedStatement ms) {
  mappedStatements.put(ms.getId(), ms);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用链如下：&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/ms%E8%B0%83%E7%94%A8%E9%93%BE.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;Spring 容器初始化 UserMapper 时，就拿到 mapper 里的所有信息，放到 mapperStatements 中，&lt;/p&gt;
&lt;p&gt;一个对象被实例化后，由于实例化的是 MapperFactoryBean，MapperFactoryBean 继承了 SqlSessionDaoSupport 接口，SqlSessionDaoSupport 继承了 DaoSupport，所以会执行 DaoSupport#afterPropertiesSet() ---&amp;gt; DaoSupport#checkDaoConfig(); ---&amp;gt; Configuration#addMapper ---&amp;gt; MapperRegistry#addMapper --&amp;gt; MapperAnnotationBuilder#parse()&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void parse() {
  String resource = type.toString();
  if (!configuration.isResourceLoaded(resource)) {
    loadXmlResource();
    configuration.addLoadedResource(resource);
    assistant.setCurrentNamespace(type.getName());
    parseCache();
    parseCacheRef();
    Method[] methods = type.getMethods();
    for (Method method : methods) {
      try {
        // issue #237
        if (!method.isBridge()) {
          parseStatement(method);
        }
      } catch (IncompleteElementException e) {
        configuration.addIncompleteMethod(new MethodResolver(this, method));
      }
    }
  }
  parsePendingMethods();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 14 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void parseStatement(Method method) {
  Class&amp;lt;?&amp;gt; parameterTypeClass = getParameterType(method);
  LanguageDriver languageDriver = getLanguageDriver(method);
  
  SqlSource sqlSource = getSqlSourceFromAnnotations(method, parameterTypeClass, languageDriver);
  // ......
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 5 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private SqlSource getSqlSourceFromAnnotations(Method method, Class&amp;lt;?&amp;gt; parameterType, LanguageDriver languageDriver) {
  try {
    // 判断 sqlAnnotationType  是不是 SELECT、INSERT 等
    Class&amp;lt;? extends Annotation&amp;gt; sqlAnnotationType = getSqlAnnotationType(method);
    // 判断注解是否是 @SelectProvider
    Class&amp;lt;? extends Annotation&amp;gt; sqlProviderAnnotationType = getSqlProviderAnnotationType(method);
    if (sqlAnnotationType != null) {
      if (sqlProviderAnnotationType != null) {
        // @SelectProvider 与 @Select 注解不能同时存在
        throw new BindingException(&amp;quot;You cannot supply both a static SQL and SqlProvider to method named &amp;quot; + method.getName());
      }
      Annotation sqlAnnotation = method.getAnnotation(sqlAnnotationType);
      // 获取 SQL 语句，可以是个数组：@Select({&amp;quot;select * from city&amp;quot;},{&amp;quot;xxx&amp;quot;})
      final String[] strings = (String[]) sqlAnnotation.getClass().getMethod(&amp;quot;value&amp;quot;).invoke(sqlAnnotation);
      return buildSqlSourceFromStrings(strings, parameterType, languageDriver);
    } else if (sqlProviderAnnotationType != null) {
      Annotation sqlProviderAnnotation = method.getAnnotation(sqlProviderAnnotationType);
      return new ProviderSqlSource(assistant.getConfiguration(), sqlProviderAnnotation, type, method);
    }
    return null;
  } catch (Exception e) {
    throw new BuilderException(&amp;quot;Could not find value method on SQL annotation.  Cause: &amp;quot; + e, e);
  }
}
&lt;/code&gt;&lt;/pre&gt;
">MyBatis系列（三）MyBatis源码</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/mybatis-xi-lie-er-mybatis-huan-cun/"" data-c="
          &lt;h1 id=&#34;spring-中的-mybatis-缓存&#34;&gt;Spring 中的 MyBatis 缓存&lt;/h1&gt;
&lt;h2 id=&#34;一级缓存&#34;&gt;一级缓存&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/MyBatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果不使用 Spring，执行三行相同的查询，只会打印一条 SQL 语句，证明一级缓存有效。&lt;/p&gt;
&lt;p&gt;但是使用 Spring 后，执行三行相同的查询，会打印三条 SQL 语句，证明&lt;strong&gt;一级缓存失效&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一级缓存基于 SqlSession，当执行 list() 方法时，在代理类中，会得到一个 SqlSession 对象，并且把它设置到当前线程中去，&lt;strong&gt;当完成一个查询后，会关闭 SqlSession&lt;/strong&gt;，这是 Spring 做的，所以一级缓存失效了。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E6%97%A0%E6%B3%95%E5%85%B1%E4%BA%ABMyBatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;spring当中为什么失效&#34;&gt;spring当中为什么失效&lt;/h2&gt;
&lt;p&gt;因为 mybatis 和 spring 的集成包当中扩展了一个类 SqlSessionTemplate，这个类在 spring 容器启动的时候被注入给了 mapper 这个类替代了原来的 DefulatSqlSession，SqlSessionTemplate当中的所有查询方法不是直接查询，而是经过一个代理对象，代理对象增强了查询方法，主要是关闭了session。&lt;/p&gt;
&lt;h3 id=&#34;先来看一个-mybatis-spring-的-demo&#34;&gt;先来看一个 mybatis-spring 的 demo&lt;/h3&gt;
&lt;p&gt;准备一个 Mapper 接口：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserMapper {
    @Select(&amp;quot;select * from t1&amp;quot;)
    List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt; list();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试类调用 mapper 接口中的 list() 方法两次，查询两次数据库，MyBatis 一级缓存失效：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) throws IOException {
        AnnotationConfigApplicationContext configApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
        UserMapper mapper = configApplicationContext.getBean(UserMapper.class);
        System.out.println(mapper.list());
        System.out.println(mapper.list());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/spring-mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;执行 list() 方法是通过 ImportBeanDefinitionRegistrar&lt;/p&gt;
&lt;p&gt;MyBatis 底层 生成的是 MapperFactoryBean 对象，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Import(MapperScannerRegistrar.class)
public @interface MapperScan {
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MapperScannerRegistrar implements ImportBeanDefinitionRegistrar, ResourceLoaderAware {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在 Spring 容器中，有多少个 mapper，就有多少个 MapperFactoryBean&lt;/strong&gt;，&lt;br&gt;
当调用 getSqlSession() 时，使用了代理，因为 mapper 是接口，肯定会为它产生一个代理类，就是通过 getSqlSession() 产生一个代理对象出来，&lt;/p&gt;
&lt;p&gt;MapperFactoryBean#getObject&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public T getObject() throws Exception {
  return getSqlSession().getMapper(this.mapperInterface);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SqlSessionTemplate#getMapper&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public &amp;lt;T&amp;gt; T getMapper(Class&amp;lt;T&amp;gt; type) {
  return getConfiguration().getMapper(type, this);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Configuration#getMapper&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public &amp;lt;T&amp;gt; T getMapper(Class&amp;lt;T&amp;gt; type, SqlSession sqlSession) {
  return mapperRegistry.getMapper(type, sqlSession);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MapperRegistry#getMapper&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public &amp;lt;T&amp;gt; T getMapper(Class&amp;lt;T&amp;gt; type, SqlSession sqlSession) {
  final MapperProxyFactory&amp;lt;T&amp;gt; mapperProxyFactory = (MapperProxyFactory&amp;lt;T&amp;gt;) knownMappers.get(type);
  if (mapperProxyFactory == null) {
    throw new BindingException(&amp;quot;Type &amp;quot; + type + &amp;quot; is not known to the MapperRegistry.&amp;quot;);
  }
  try {
    return mapperProxyFactory.newInstance(sqlSession);
  } catch (Exception e) {
    throw new BindingException(&amp;quot;Error getting mapper instance. Cause: &amp;quot; + e, e);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MapperProxyFactory#newInstance&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public T newInstance(SqlSession sqlSession) {
  final MapperProxy&amp;lt;T&amp;gt; mapperProxy = new MapperProxy&amp;lt;T&amp;gt;(sqlSession, mapperInterface, methodCache);
  return newInstance(mapperProxy);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MapperProxyFactory#newInstance&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected T newInstance(MapperProxy&amp;lt;T&amp;gt; mapperProxy) {
  // mapperInterface 就是接口 UserMapper，为 UserMapper 产生一个代理对象，产生代理对象需要传递一个 InvocationHandler 参数：mapperProxy
  return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%B0%83%E7%94%A8mapper%E7%9A%84list%E6%96%B9%E6%B3%95.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;当调用 userMapper.list() 时，实际执行的逻辑是实现 InvocationHandler 接口的类中的 invoke() 方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;mapperProxy 是一个 InvocationHandler：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MapperProxy&amp;lt;T&amp;gt; implements InvocationHandler, Serializable {
    // ...
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
      try {
        if (Object.class.equals(method.getDeclaringClass())) {
          return method.invoke(this, args);
        } else if (isDefaultMethod(method)) {
          return invokeDefaultMethod(proxy, method, args);
        }
      } catch (Throwable t) {
        throw ExceptionUtil.unwrapThrowable(t);
      }
      // MapperMethod 相当于 Spring 当中的 BeanDefinition，包含了：返回类型、缓存级别
      final MapperMethod mapperMethod = cachedMapperMethod(method);
      return mapperMethod.execute(sqlSession, args);
    }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/sqlSessionTemplate.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这里的 sqlSession 是一个 SqlSessionTemplate 对象，&lt;/p&gt;
&lt;p&gt;UserMapper 代理对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 代理类
class UserMapperProxy{
  private InvocationHandler h;
  // 构造方法
  public UserMapperProxy(InvocationHandler h){
     this.h = h;
  }
  list(){
    // 执行 InvocationHandler 的 invoke() 方法
    return h.invoke();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当 configApplicationContext.getBean(UserMapper.class); 时就拿出了 UserMapper 的代理对象。&lt;br&gt;
MapperMethod#execute&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Object execute(SqlSession sqlSession, Object[] args) {
  Object result;
  switch (command.getType()) {
    case INSERT: {
    Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.insert(command.getName(), param));
      break;
    }
    case UPDATE: {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.update(command.getName(), param));
      break;
    }
    case DELETE: {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.delete(command.getName(), param));
      break;
    }
    case SELECT:
      if (method.returnsVoid() &amp;amp;&amp;amp; method.hasResultHandler()) {
        executeWithResultHandler(sqlSession, args);
        result = null;
      } else if (method.returnsMany()) {
        // 返回值是 Map，查询多条，所以走这个分支
        result = executeForMany(sqlSession, args);
      } else if (method.returnsMap()) {
        result = executeForMap(sqlSession, args);
      } else if (method.returnsCursor()) {
        result = executeForCursor(sqlSession, args);
      } else {
        Object param = method.convertArgsToSqlCommandParam(args);
        result = sqlSession.selectOne(command.getName(), param);
      }
      break;
    case FLUSH:
      result = sqlSession.flushStatements();
      break;
    default:
      throw new BindingException(&amp;quot;Unknown execution method for: &amp;quot; + command.getName());
  }
  if (result == null &amp;amp;&amp;amp; method.getReturnType().isPrimitive() &amp;amp;&amp;amp; !method.returnsVoid()) {
    throw new BindingException(&amp;quot;Mapper method &#39;&amp;quot; + command.getName() 
        + &amp;quot; attempted to return null from a method with a primitive return type (&amp;quot; + method.getReturnType() + &amp;quot;).&amp;quot;);
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/command.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/DefaultSqlSession.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;MapperMethod#executeForMany&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private &amp;lt;E&amp;gt; Object executeForMany(SqlSession sqlSession, Object[] args) {
  List&amp;lt;E&amp;gt; result;
  Object param = method.convertArgsToSqlCommandParam(args);
  if (method.hasRowBounds()) {
    RowBounds rowBounds = method.extractRowBounds(args);
    result = sqlSession.&amp;lt;E&amp;gt;selectList(command.getName(), param, rowBounds);
  } else {
    // 因为 select *，所以走这个分支
    result = sqlSession.&amp;lt;E&amp;gt;selectList(command.getName(), param);
  }
  // issue #510 Collections &amp;amp; arrays support
  if (!method.getReturnType().isAssignableFrom(result.getClass())) {
    if (method.getReturnType().isArray()) {
      return convertToArray(result);
    } else {
      return convertToDeclaredCollection(sqlSession.getConfiguration(), result);
    }
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 9 行：SqlSessionTemplate#selectList&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; selectList(String statement, Object parameter) {
  return this.sqlSessionProxy.&amp;lt;E&amp;gt; selectList(statement, parameter);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SqlSessionInterceptor#invoke&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
  SqlSession sqlSession = getSqlSession(
      SqlSessionTemplate.this.sqlSessionFactory,
      SqlSessionTemplate.this.executorType,
      SqlSessionTemplate.this.exceptionTranslator);
  try {
    Object result = method.invoke(sqlSession, args);
    if (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.this.sqlSessionFactory)) {
      // force commit even on non-dirty sessions because some databases require
      // a commit/rollback before calling close()
      sqlSession.commit(true);
    }
    return result;
  } catch (Throwable t) {
    Throwable unwrapped = unwrapThrowable(t);
    if (SqlSessionTemplate.this.exceptionTranslator != null &amp;amp;&amp;amp; unwrapped instanceof PersistenceException) {
      // release the connection to avoid a deadlock if the translator is no loaded. See issue #22
      closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory);
      sqlSession = null;
      Throwable translated = SqlSessionTemplate.this.exceptionTranslator.translateExceptionIfPossible((PersistenceException) unwrapped);
      if (translated != null) {
        unwrapped = translated;
      }
    }
    throw unwrapped;
  } finally {
    if (sqlSession != null) {
      // 当执行完查询，关闭 sqlSession，所以 Spring+MyBatis一级缓存失效。
      closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/DefaultSqlSession_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果使用普通 MyBatis，执行的不是 SqlSessionTemplate 的代理方法，执行的是 DefaultSqlSession；在 Spring 过程中，执行代理对象的方法：sqlSessionProxy.&lt;E&gt; selectList(statement, parameter);&lt;/p&gt;
&lt;p&gt;由于 sqlSessionProxy 是代理对象，所以看不到代理对象的方法，点进去只能看到 它实现的 InvocationHandler（SqlSessionInterceptor） 的 invoke 方法；与 userMapper.list(); 一样，当调用 list() 方法时，debug 下一步进入的是它实现的 InvocationHandler：MapperProxy 的 invoke() 方法。&lt;/p&gt;
&lt;h3 id=&#34;再来看一个-mybatis-原生的-demo&#34;&gt;再来看一个 mybatis 原生的 demo&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) throws IOException {
        String resource = &amp;quot;mybatis-config.xml&amp;quot;;
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        SqlSession sqlSession = sqlSessionFactory.openSession();
        sqlSession.getConfiguration().addMapper(UserMapper.class);
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        System.out.println(mapper.list());
        System.out.println(mapper.list());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;当调用 mapper 的 list() 方法时，执行 InvocationHandler 的实现类：MapperProxy 的 invoke() 方法，因为 mapper 是一个代理对象。&lt;/p&gt;
&lt;p&gt;MapperProxy#invoke&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
  try {
    if (Object.class.equals(method.getDeclaringClass())) {
      return method.invoke(this, args);
    } else if (isDefaultMethod(method)) {
      return invokeDefaultMethod(proxy, method, args);
    }
  } catch (Throwable t) {
    throw ExceptionUtil.unwrapThrowable(t);
  }
  final MapperMethod mapperMethod = cachedMapperMethod(method);
  return mapperMethod.execute(sqlSession, args);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/mappedStatements.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上述代码第 12 行：MapperMethod#execute&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Object execute(SqlSession sqlSession, Object[] args) {
  Object result;
  switch (command.getType()) {
    case INSERT: {
    Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.insert(command.getName(), param));
      break;
    }
    case UPDATE: {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.update(command.getName(), param));
      break;
    }
    case DELETE: {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.delete(command.getName(), param));
      break;
    }
    case SELECT:
      if (method.returnsVoid() &amp;amp;&amp;amp; method.hasResultHandler()) {
        executeWithResultHandler(sqlSession, args);
        result = null;
      } else if (method.returnsMany()) {
        result = executeForMany(sqlSession, args);
      } else if (method.returnsMap()) {
        result = executeForMap(sqlSession, args);
      } else if (method.returnsCursor()) {
        result = executeForCursor(sqlSession, args);
      } else {
        Object param = method.convertArgsToSqlCommandParam(args);
        result = sqlSession.selectOne(command.getName(), param);
      }
      break;
    case FLUSH:
      result = sqlSession.flushStatements();
      break;
    default:
      throw new BindingException(&amp;quot;Unknown execution method for: &amp;quot; + command.getName());
  }
  if (result == null &amp;amp;&amp;amp; method.getReturnType().isPrimitive() &amp;amp;&amp;amp; !method.returnsVoid()) {
    throw new BindingException(&amp;quot;Mapper method &#39;&amp;quot; + command.getName() 
        + &amp;quot; attempted to return null from a method with a primitive return type (&amp;quot; + method.getReturnType() + &amp;quot;).&amp;quot;);
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 24 行：MapperMethod#executeForMany&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private &amp;lt;E&amp;gt; Object executeForMany(SqlSession sqlSession, Object[] args) {
  List&amp;lt;E&amp;gt; result;
  Object param = method.convertArgsToSqlCommandParam(args);
  if (method.hasRowBounds()) {
    RowBounds rowBounds = method.extractRowBounds(args);
    result = sqlSession.&amp;lt;E&amp;gt;selectList(command.getName(), param, rowBounds);
  } else {
    result = sqlSession.&amp;lt;E&amp;gt;selectList(command.getName(), param);
  }
  // issue #510 Collections &amp;amp; arrays support
  if (!method.getReturnType().isAssignableFrom(result.getClass())) {
    if (method.getReturnType().isArray()) {
      return convertToArray(result);
    } else {
      return convertToDeclaredCollection(sqlSession.getConfiguration(), result);
    }
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 8 行：DefaultSqlSession#selectList&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; selectList(String statement, Object parameter) {
  return this.selectList(statement, parameter, RowBounds.DEFAULT);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MyBatis 直接调用 DefaultSqlSession 的 selectList 方法；而 Spring 调用的是 DefaultSqlSession 的代理类的方法，Spring 把 sqlSession 替换成了代理对象：在完成查询后关闭 sqlSession。&lt;br&gt;
DefaultSqlSession#selectList&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; selectList(String statement, Object parameter, RowBounds rowBounds) {
  try {
    MappedStatement ms = configuration.getMappedStatement(statement);
    return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
  } catch (Exception e) {
    throw ExceptionFactory.wrapException(&amp;quot;Error querying database.  Cause: &amp;quot; + e, e);
  } finally {
    ErrorContext.instance().reset();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;MyBatis --&amp;gt; SqlSession --&amp;gt; DefaultSqlSession --&amp;gt; DefaultSqlSession.select(); --&amp;gt; SQL&lt;/p&gt;
&lt;p&gt;spring-mybatis --&amp;gt; SqlSession --&amp;gt; SqlSessionTemplate --&amp;gt;  SqlSessionTemplate.selectList(); --&amp;gt;  sqlSessionProxy.selectList();&lt;/p&gt;
&lt;h3 id=&#34;为什么-spring-当中-mybatis-一级缓存失效&#34;&gt;为什么 Spring 当中 MyBatis 一级缓存失效&lt;/h3&gt;
&lt;p&gt;MyBatis 整合 Spring 时，MyBatis 为 Spring 提供了一个插件包：mybatis-spring，在 mybatis-spring 中提供了一个类：SqlSessionTemplate 替代了 MyBatis 中默认的 DefaultSqlSession，对&lt;/p&gt;
&lt;p&gt;DefaultSqlSession 的增强，在代理的代码中把 SqlSession 关闭了。&lt;/p&gt;
&lt;h4 id=&#34;spring-为什么要关闭-sqlsession&#34;&gt;Spring 为什么要关闭 sqlSession？&lt;/h4&gt;
&lt;p&gt;MyBatis 把 SqlSession 暴露出来，想什么时候关闭，就什么时候关闭。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SqlSession sqlSession = sqlSessionFactory.openSession();
sqlSession.close();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而在 Spring 没有把 SqlSession 暴露出来，所以只有在源码中，使用完一次后就关闭，否则没有其他地方可以关闭。&lt;/p&gt;
&lt;h2 id=&#34;二级缓存&#34;&gt;二级缓存&lt;/h2&gt;
&lt;p&gt;多个线程共享二级缓存&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@CacheNamespace
public interface IndexDao {
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/MyBatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@CacheNamespace
public interface IndexDao2 {
    @Update(&amp;quot;update t1 set b=1 where a=1&amp;quot;)
    public int update();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class IndexService {
    @Autowired
    IndexDao indexDao;
    @Autowired
    IndexDao2 indexDao2;
    public List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt; list(){
        indexDao.list();
        indexDao.list();
        return indexDao.list();
    }
    public void update(){
       indexDao2.update();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext configApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
        List&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; list = configApplicationContext.getBean(IndexService.class).list();
        System.out.println(list);
        configApplicationContext.getBean(IndexService.class).update();
        System.out.println(configApplicationContext.getBean(IndexService.class).list());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们发现，使用了二级缓存后，第一次查询，将查询结果缓存起来，接下来更新操作，第二次再次查询直接使用缓存结果，无法查到更新后的值。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/MyBatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E8%AF%BB%E8%84%8F%E6%95%B0%E6%8D%AE.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;分析：MyBatis 缓存是基于&lt;strong&gt;命名空间&lt;/strong&gt;的，当调用 indexDao.list() 查询出结果后，由于 IndexDao 添加了缓存 @CacheNamespace，把 list() 查询结果放到缓存中，存放形式：&amp;lt;&amp;quot;com.ssm.dao.IndexDao&amp;quot;, &amp;quot;list&amp;quot;&amp;gt;，当调用 update() 方法时，更新当前这个 update() 方法所在的命名空间，即 com.ssm.dao.IndexDao2，于是放入缓存 &amp;lt;&amp;quot;com.ssm.dao.IndexDao2&amp;quot;, &amp;quot;更新后的list&amp;quot;&amp;gt;，而第二次调用 list() 查询时，查找 list() 方法对应的命名空间的缓存：&amp;lt;&amp;quot;com.ssm.dao.IndexDao&amp;quot;, &amp;quot;list&amp;quot;&amp;gt;。&lt;/p&gt;
&lt;p&gt;如果将 update、select 写在一个 dao 内，就不会出现上述问题了，代码修改如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@CacheNamespace
public interface IndexDao {
    @Select(&amp;quot;select * from t1&amp;quot;)
    List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt; list();
    @Update(&amp;quot;update t1 set b=111 where a=1&amp;quot;)
    public int update();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class IndexService {
    @Autowired
    IndexDao indexDao;
    public List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt; list(){
        indexDao.list();
        indexDao.list();
        return indexDao.list();
    }
    public void update(){
       indexDao.update();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/MyBatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9B%B8%E5%90%8C%E8%AF%BB%E6%95%B0%E6%8D%AE%E6%AD%A3%E7%A1%AE.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;分析：MyBatis 缓存是基于&lt;strong&gt;命名空间&lt;/strong&gt;的，当调用 indexDao.list() 查询出结果后，由于 IndexDao 添加了缓存 @CacheNamespace，把 list() 查询结果放到缓存中，存放形式：&amp;lt;&amp;quot;com.ssm.dao.IndexDao&amp;quot;, &amp;quot;list&amp;quot;&amp;gt;，当调用 update() 方法时，更新当前这个 update() 方法所在的命名空间，即 &amp;lt;&amp;quot;com.ssm.dao.IndexDao&amp;quot;, &amp;quot;更新后的list&amp;quot;&amp;gt;。&lt;/p&gt;
&lt;h1 id=&#34;当调用-list-时已经拿到了-sql-语句&#34;&gt;当调用 list() 时，已经拿到了 sql 语句&lt;/h1&gt;
&lt;p&gt;当实例化一个 MapperFactoryBean 时，MyBatis 初始化：解析注解：把接口 mapper 中的 method 中的注解拿出来，把&amp;lt;id,object&amp;gt;放到 map 中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected final Map&amp;lt;String, MappedStatement&amp;gt; mappedStatements = new StrictMap&amp;lt;MappedStatement&amp;gt;(&amp;quot;Mapped Statements collection&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在调用方法前，就实例化 mappedStatements 了。当创建 Service 时，由于 Service 会调用 putVal，putVal 就会创建 mapper，当创建 mapper 时，就 put 了一个&amp;lt;id,object&amp;gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/DefaultSqlSession_3.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;Mapper 被实例化之后，就立刻把 sql 语句放到 map 中了。&lt;/p&gt;
&lt;h2 id=&#34;当一个类被实例化时就去执行一些东西把-sql-放到-map-中怎么做&#34;&gt;当一个类被实例化时，就去执行一些东西（把 sql 放到 map 中）怎么做？&lt;/h2&gt;
&lt;p&gt;实现 InitializingBean 接口，重写接口中的 afterPropertiesSet() 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class IndexService implements InitializingBean {
    @Autowired
    UserMapper userMapper;
    public List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt; list(){
        userMapper.list();
        userMapper.list();
        return userMapper.list();
    }
    public void update(){
       userMapper.update();
    }
    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println(&amp;quot;app...&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;DEBUG [main] - Finished creating instance of bean &#39;userMapper&#39;
DEBUG [main] - Autowiring by type from bean name &#39;indexService&#39; to bean named &#39;userMapper&#39;
DEBUG [main] - Invoking afterPropertiesSet() on bean with name &#39;indexService&#39;
app...
DEBUG [main] - Finished creating instance of bean &#39;indexService&#39;
DEBUG [main] - Returning cached instance of singleton bean &#39;dataSource&#39;
DEBUG [main] - Returning cached instance of singleton bean &#39;sqlSessionFactoryBean&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Spring 与 MyBatis 整合的流程：&lt;br&gt;
MyBatis 中所有的 mapper 都是 MapperFactoryBean，MapperFactoryBean 实现了 SqlSessionDaoSupport：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MapperFactoryBean&amp;lt;T&amp;gt; extends SqlSessionDaoSupport implements FactoryBean&amp;lt;T&amp;gt; {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SqlSessionDaoSupport  是 MyBatis 开发的，SqlSessionDaoSupport 继承了 DaoSupport：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package org.mybatis.spring.support;
public abstract class SqlSessionDaoSupport extends DaoSupport {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DaoSupport 是 Spring 开发的，DaoSupport 实现了 InitializingBean：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package org.springframework.dao.support;
public abstract class DaoSupport implements InitializingBean {
    // ...
    public final void afterPropertiesSet() throws IllegalArgumentException, BeanInitializationException {
       // Let abstract subclasses check their configuration.
       // 抽象方法，所以会调用子类的实现
       checkDaoConfig();
    
       // Let concrete implementations initialize themselves.
       try {
          initDao();
       }
       catch (Exception ex) {
          throw new BeanInitializationException(&amp;quot;Initialization of DAO failed&amp;quot;, ex);
       }
    }
    //...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果用 MapperFactoryBean 直接实现 InitializingBean，重写 afterPropertiesSet()，当 MapperFactoryBean 被实例化后，就会调用 DaoSupport 的 afterPropertiesSet()，而  DaoSupport 的 afterPropertiesSet() 内部会调用 checkDaoConfig()，由于 checkDaoConfig() 是抽象方法，所以会去调用子类 MapperFactoryBean 的实现：&lt;br&gt;
MapperFactoryBean#checkDaoConfig&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void checkDaoConfig() {
  super.checkDaoConfig();
  notNull(this.mapperInterface, &amp;quot;Property &#39;mapperInterface&#39; is required&amp;quot;);
  // 得到 Configuration
  Configuration configuration = getSqlSession().getConfiguration();
  if (this.addToConfig &amp;amp;&amp;amp; !configuration.hasMapper(this.mapperInterface)) {
    try {
      // 初始化 mapper 这些类
      configuration.addMapper(this.mapperInterface);
    } catch (Exception e) {
      logger.error(&amp;quot;Error while adding the mapper &#39;&amp;quot; + this.mapperInterface + &amp;quot;&#39; to configuration.&amp;quot;, e);
      throw new IllegalArgumentException(e);
    } finally {
      ErrorContext.instance().reset();
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Configuration#addMapper&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public &amp;lt;T&amp;gt; void addMapper(Class&amp;lt;T&amp;gt; type) {
  mapperRegistry.addMapper(type);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MapperRegistry#addMapper&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public &amp;lt;T&amp;gt; void addMapper(Class&amp;lt;T&amp;gt; type) {
  if (type.isInterface()) {
    if (hasMapper(type)) {
      throw new BindingException(&amp;quot;Type &amp;quot; + type + &amp;quot; is already known to the MapperRegistry.&amp;quot;);
    }
    boolean loadCompleted = false;
    try {
      // 放到 map 中
      knownMappers.put(type, new MapperProxyFactory&amp;lt;T&amp;gt;(type));
      // It&#39;s important that the type is added before the parser is run
      // otherwise the binding may automatically be attempted by the
      // mapper parser. If the type is already known, it won&#39;t try.
      MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);
      // 解析
      parser.parse();
      loadCompleted = true;
    } finally {
      if (!loadCompleted) {
        knownMappers.remove(type);
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;spring-和-mybatis-结合如何初始化&#34;&gt;Spring 和 MyBatis 结合如何初始化？&lt;/h1&gt;
&lt;h2 id=&#34;springbean-实例化之前的工作&#34;&gt;SpringBean 实例化之前的工作：&lt;/h2&gt;
&lt;p&gt;通过分析源码可以得出 @MapperScan 主要做了3个事情：&lt;/p&gt;
&lt;p&gt;1.扫描出来所有的 mapper 所对应的 BeanDefinition&lt;/p&gt;
&lt;p&gt;2.把 mapper 变成 FactoryBean，MapperFactoryBean  和 BeanDefinition&lt;/p&gt;
&lt;p&gt;3.为BeanDefinition 添加一个构造方法的值，因为 MyBatis 的 MapperFactoryBean 有一个有参构造方法，Spring 在实例化这个对象的时候需要一个构造方法的值，这个值是一个 class，后面 Spring 在实例化过程中根据这个 class 返回我们的代理对象&lt;/p&gt;
&lt;h2 id=&#34;springbean-实例化之中和之后的工作&#34;&gt;SpringBean 实例化之中和之后的工作：&lt;/h2&gt;
&lt;p&gt;mybatis 主要利用 spring 的初始方法扩展点来完成对 mapper 信息的初始化，比如 sql 语句的初始化。这里的 spring 扩展点主要就是 afterPropertiesSet，说白了就是利用 MapperFactoryBean 去实现 InitializingBean 接口，由于 MapperFactoryBean 是一个 FactoryBean，我们理解为就是一个 mapper，把 &amp;lt;id,object&amp;gt; 缓存到 map 中。&lt;/p&gt;
">MyBatis系列（二）MyBatis缓存</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/spring-xi-lie-shi-san-mybatis-ri-zhi/"" data-c="
          &lt;h1 id=&#34;mybatis-入门&#34;&gt;MyBatis 入门&lt;/h1&gt;
&lt;p&gt;MyBatis 官网：&lt;a href=&#34;https://mybatis.org/mybatis-3/zh/index.html&#34;&gt;https://mybatis.org/mybatis-3/zh/index.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;先从一个测试类开始&#34;&gt;先从一个测试类开始&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface IndexDao {
    @Select(&amp;quot;select * from t1&amp;quot;)
    List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt; list();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class IndexService {
    @Autowired
    IndexDao indexDao;
    public List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt; list(){
        return indexDao.list();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
@MapperScan(&amp;quot;com.ssm.dao&amp;quot;)
public class AppConfig{
    @Bean
    public DataSource dataSource(){
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;);
        dataSource.setUsername(&amp;quot;root&amp;quot;);
        dataSource.setPassword(&amp;quot;123456&amp;quot;);
        dataSource.setUrl(&amp;quot;jdbc:mysql://localhost:3306/t1&amp;quot;);
        return dataSource;
    }
    @Bean
    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){
        SqlSessionFactoryBean sqlSessionFactoryBean =  new SqlSessionFactoryBean();
         // 配置日志打印 SQL
        org.apache.ibatis.session.Configuration configuration = new org.apache.ibatis.session.Configuration();
        configuration.setLogImpl(Log4jImpl.class);
        sqlSessionFactoryBean.setConfiguration(configuration);
        // -- 日志打印 SQL 结束
        sqlSessionFactoryBean.setDataSource(dataSource);
        return sqlSessionFactoryBean;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext configApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
        List&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; list = configApplicationContext.getBean(IndexService.class).list();
        System.out.println(list);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# 全局日志配置
log4j.rootLogger=DEBUG, stdout
# MyBatis 日志配置
log4j.logger.com.ssm.IndexDao=TRACE
# 控制台输出
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;日志打印结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;五月 18, 2020 8:47:01 下午 org.springframework.context.support.AbstractApplicationContext prepareRefresh
信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@433c675d: startup date [Mon May 18 20:47:01 CST 2020]; root of context hierarchy
五月 18, 2020 8:47:01 下午 org.springframework.jdbc.datasource.DriverManagerDataSource setDriverClassName
信息: Loaded JDBC driver: com.mysql.jdbc.Driver
DEBUG [main] - Logging initialized using &#39;class org.apache.ibatis.logging.log4j.Log4jImpl&#39; adapter.
DEBUG [main] - Creating a new SqlSession
DEBUG [main] - SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@445b295b] was not registered for synchronization because synchronization is not active
DEBUG [main] - JDBC Connection [com.mysql.jdbc.JDBC4Connection@a2431d0] will not be managed by Spring
DEBUG [main] - ==&amp;gt;  Preparing: select * from t1 
DEBUG [main] - ==&amp;gt; Parameters: 
DEBUG [main] - &amp;lt;==      Total: 9
DEBUG [main] - Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@445b295b]
[{a=1, b=11, c=4, d=1, e=a}, {a=2, b=2, c=2, d=2, e=b}, {a=3, b=3, c=2, d=2, e=c}, {a=4, b=3, c=1, d=1, e=d}, {a=5, b=2, c=3, d=5, e=e}, {a=6, b=6, c=4, d=4, e=6}, {a=7, b=4, c=5, d=5, e=g}, {a=8, b=8, c=8, d=8, e=h}, {a=9, b=9, c=9, d=9, e=i}]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;mybatis的日志技术实现&#34;&gt;mybatis的日志技术实现&lt;/h1&gt;
&lt;h2 id=&#34;初始化&#34;&gt;初始化&lt;/h2&gt;
&lt;h3 id=&#34;orgapacheibatislogginglogfactory&#34;&gt;org.apache.ibatis.logging.LogFactory&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/logFactory_static.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/tryImplementation.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;tryImplementation(new Runnable() {
  @Override
  public void run() {
    useSlf4jLogging();
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法中的 runnable 参数是 new Runnable() 对象，run() 方法里面调用了 useSlf4jLogging() 方法，使用 SLF4J 日志。关键代码  **   if (logConstructor == null)****,**没有找到实现则继续找&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static void tryImplementation(Runnable runnable) {
  if (logConstructor == null) {
    try {
      runnable.run();
    } catch (Throwable t) {
      // ignore
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用 setImplementation 方法，传参 Slf4jImpl ：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static synchronized void useSlf4jLogging() {
  setImplementation(org.apache.ibatis.logging.slf4j.Slf4jImpl.class);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;LogFactory#setImplementation&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static void setImplementation(Class&amp;lt;? extends Log&amp;gt; implClass) {
  try {
    //  通过参数 implClass 得到构造方法
    Constructor&amp;lt;? extends Log&amp;gt; candidate = implClass.getConstructor(String.class);
    //  通过构造方法 new 出来对象
    Log log = candidate.newInstance(LogFactory.class.getName());
    if (log.isDebugEnabled()) {
      log.debug(&amp;quot;Logging initialized using &#39;&amp;quot; + implClass + &amp;quot;&#39; adapter.&amp;quot;);
    }
    // 将构造方法赋值给全局变量：private static Constructor&amp;lt;? extends Log&amp;gt; logConstructor;
    logConstructor = candidate;
  } catch (Throwable t) {
    throw new LogException(&amp;quot;Error setting Log implementation.  Cause: &amp;quot; + t, t);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 6 行，调用 Slf4jImpl 的构造方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Slf4jImpl(String clazz) {
  Logger logger = LoggerFactory.getLogger(clazz);
  if (logger instanceof LocationAwareLogger) {
    try {
      // check for slf4j &amp;gt;= 1.6 method signature
      logger.getClass().getMethod(&amp;quot;log&amp;quot;, Marker.class, String.class, int.class, String.class, Object[].class, Throwable.class);
      log = new Slf4jLocationAwareLoggerImpl((LocationAwareLogger) logger);
      return;
    } catch (SecurityException e) {
      // fail-back to Slf4jLoggerImpl
    } catch (NoSuchMethodException e) {
      // fail-back to Slf4jLoggerImpl
    }
  }
  // Logger is not LocationAwareLogger or slf4j version &amp;lt; 1.6
  log = new Slf4jLoggerImpl(logger);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在执行过程中发现，上述代码执行到第 2 行就返回了，因为项目中并未添加 SLF4J 依赖。于是抛出异常，执行 static 块的 useCommonsLogging。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;MyBatis 日志使用顺序： SLF4J、JCL、Log4J2、JUL、NO&lt;/p&gt;
&lt;p&gt;如果没有引入 SLF4J，就会使用 JCL，因为 spring-context 默认内置 JCL。&lt;/p&gt;
&lt;h2 id=&#34;日志打印-sql&#34;&gt;日志打印 SQL&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class IndexService {
    @Autowired
    IndexDao indexDao;
    public List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt; list(){
        // 将代码添加在这里无法打印 SQL
        org.apache.ibatis.logging.LogFactory.useLog4JLogging();
        return indexDao.list();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0SQL.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;打印 SQL 语句是一个 proxy 代理对象&lt;/strong&gt;，这个代理对象在 Spring 初始化时利用 Registrar 创建的，但是在创建这个 proxy 之前是没有任何日志的，而 useLog4J() 这个方法是在后面使用的，于是在 proxy 里面无法得到 log4j 对象，为什么创建时可以使用？因为 Spring 实例化过程 比 MyBatis 实例化的过程早，Spring 实例化 Service 时已经告诉 MyBatis 要使用 log4j 了，当创建 MyBatis 工厂时，可以直接打印日志，但是&lt;strong&gt;代理对象在 useLog4JLogging() 方法之前&lt;/strong&gt;，所以不知道到底要使用哪个日志。实例化 indexDao 这个代理对象，包含一个日志对象 Log logger，但是在创建 BeanDefinition 之前，不知道要使用哪个 Log，所以 logger=null。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0SQL_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;需要将 org.apache.ibatis.logging.LogFactory.useLog4JLogging(); 写在 Spring 初始化之前，告诉 MyBatis 要使用 log4J，当产生代理对象时，就知道要使用 log4j 日志了，代理对象中就有了 Log logger = new Log4JLogger();对象。&lt;/p&gt;
&lt;p&gt;一个对象要记录日志：logger.info()，证明代理对象 proxy 要包含一个 Log logger， proxy 被 new 出来的过程中，MyBatis 不知道它要使用什么日志，所以就不记录日志，即 logger=null。&lt;/p&gt;
&lt;p&gt;如果在 proxy 之前让 proxy 使用 Log4J，在产生这个代理对象之前，Log logger = new Log4JLogger();&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
         // 在 Spring 初始化前设置使用的日志
        org.apache.ibatis.logging.LogFactory.useLog4JLogging();
        AnnotationConfigApplicationContext configApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
        List&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; list = configApplicationContext.getBean(IndexService.class).list();
        System.out.println(list);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;LogFactory#useLog4JLogging -&amp;gt; LogFactory#setImplementation：给构造方法赋值logConstructor = candidate;&lt;/p&gt;
&lt;h3 id=&#34;在使用日志时如何得到-logger&#34;&gt;在使用日志时如何得到 logger？&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static final Log LOGGER = LogFactory.getLog(SqlSessionFactoryBean.class);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static Log getLog(Class&amp;lt;?&amp;gt; aClass) {
  return getLog(aClass.getName());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用 logConstructor.newInstance(logger); logConstructor 即之前赋的值 candidate：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static Log getLog(String logger) {
  try {
    return logConstructor.newInstance(logger);
  } catch (Throwable t) {
    throw new LogException(&amp;quot;Error creating logger for logger &amp;quot; + logger + &amp;quot;.  Cause: &amp;quot; + t, t);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;日志打印：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DEBUG [main] - Property &#39;configuration&#39; or &#39;configLocation&#39; not specified, using default MyBatis Configuration
DEBUG [main] - Property &#39;mapperLocations&#39; was not specified or no matching resources found
DEBUG [main] - Creating a new SqlSession
DEBUG [main] - SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@445b295b] was not registered for synchronization because synchronization is not active
DEBUG [main] - JDBC Connection [com.mysql.jdbc.JDBC4Connection@a2431d0] will not be managed by Spring
DEBUG [main] - ==&amp;gt;  Preparing: select * from t1 
DEBUG [main] - ==&amp;gt; Parameters: 
DEBUG [main] - &amp;lt;==      Total: 9
DEBUG [main] - Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@445b295b]
[{a=1, b=11, c=4, d=1, e=a}, {a=2, b=2, c=2, d=2, e=b}, {a=3, b=3, c=2, d=2, e=c}, {a=4, b=3, c=1, d=1, e=d}, {a=5, b=2, c=3, d=5, e=e}, {a=6, b=6, c=4, d=4, e=6}, {a=7, b=4, c=5, d=5, e=g}, {a=8, b=8, c=8, d=8, e=h}, {a=9, b=9, c=9, d=9, e=i}]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mybatisspring5log4j-没有日志打印&#34;&gt;MyBatis+Spring5+Log4J 没有日志打印&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;
  &amp;lt;!-- spring-core --&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;5.0.9.RELEASE&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;
  &amp;lt;!-- spring 连接池 --&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;5.0.9.RELEASE&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;
  &amp;lt;!-- mybatis --&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.4.6&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;
  &amp;lt;!-- mybatis-spring --&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis-spring&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;
  &amp;lt;!-- mysql-connector-java --&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;5.1.46&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;
  &amp;lt;!-- log4j --&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.2.17&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
@MapperScan(&amp;quot;com.ssm.dao&amp;quot;)
public class AppConfig{
    @Bean
    public DataSource dataSource(){
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;);
        dataSource.setUsername(&amp;quot;root&amp;quot;);
        dataSource.setPassword(&amp;quot;123456&amp;quot;);
        dataSource.setUrl(&amp;quot;jdbc:mysql://localhost:3306/t1&amp;quot;);
        return dataSource;
    }
    @Bean
    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){
        SqlSessionFactoryBean sqlSessionFactoryBean =  new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource);
        return sqlSessionFactoryBean;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%B2%A1%E6%9C%89%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/Spring5_static.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果想在 Spring5+MyBatis+log4j 打印 log4j 日志，方法一：改变 JUL 的默认级别，但是 JUL 的默认级别不能改变；方法二：扩展 MyBatis。&lt;/p&gt;
&lt;h3 id=&#34;方法一改变-jul-默认级别&#34;&gt;方法一：改变 JUL 默认级别&lt;/h3&gt;
&lt;p&gt;由于 Spring5 内置 spring-jcl，spring-jcl+log4j 打印 JUL 日志。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static void setImplementation(Class&amp;lt;? extends Log&amp;gt; implClass) {
  try {
    Constructor&amp;lt;? extends Log&amp;gt; candidate = implClass.getConstructor(String.class);
    Log log = candidate.newInstance(LogFactory.class.getName());
    // 判断能不能打印日志,MyBatis在记录日志时，要判断级别是不是DEBUG级别，如果是DEBUG级别才会记录；否则不会记录。
    if (log.isDebugEnabled()) {
      // 因为这是 debug 信息
      log.debug(&amp;quot;Logging initialized using &#39;&amp;quot; + implClass + &amp;quot;&#39; adapter.&amp;quot;);
    }
    logConstructor = candidate;
  } catch (Throwable t) {
    throw new LogException(&amp;quot;Error setting Log implementation.  Cause: &amp;quot; + t, t);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Spring5_JUL.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;由于 JCL 是一个接口，真实调用了 JUL 或 log4j 的日志打印，所以会判断 JUL 或 lo4j 的级别是否是 DEBUG 级别。&lt;/p&gt;
&lt;p&gt;JakartaCommonsLoggingImpl#isDebugEnabled&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public boolean isDebugEnabled() {
  return log.isDebugEnabled();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%88%A4%E6%96%ADJUL%E7%BA%A7%E5%88%AB.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;判断 JUL 是否是 DEBUG 级别，会返回 false，因为 JUL 日志级别是写死的，不是 DEBUG；&lt;/p&gt;
&lt;p&gt;但如果是 log4j，由于 lo4j 是自己在 .properties 文件内配置的，可配置级别为 DEBUG。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;log4j.rootLogger=DEBUG, stdout
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JavaUtilLog#isDebugEnabled&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean isDebugEnabled() {
   return this.logger.isLoggable(java.util.logging.Level.FINE);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以将源码中的 java.util.logging.Level.FINE 更改，来改变 JUL 的日志级别。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private transient java.util.logging.Logger logger;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MyBatis - JCL - JavaUtilLog - JUL(java.util.logging.Logger)&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/JUL%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB%E4%BC%98%E5%85%88%E7%BA%A7.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;方法二扩展-mybatis&#34;&gt;方法二：扩展 MyBatis&lt;/h3&gt;
&lt;p&gt;可以传值一个优先级比 500 高的日志级别。&lt;/p&gt;
&lt;p&gt;官方文档：&lt;a href=&#34;https://mybatis.org/mybatis-3/zh/logging.html&#34;&gt;https://mybatis.org/mybatis-3/zh/logging.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;mybatisspring4log4j-有日志打印&#34;&gt;MyBatis+Spring4+Log4J 有日志打印&lt;/h2&gt;
&lt;p&gt;如果将上述 Spring5 改为 Spring4，可以打印日志。因为在Spring4中：Spring+MyBatis+log4j&lt;/p&gt;
&lt;p&gt;Spring4 内置 JCL，Spring4+log4j = log4j，所以变成了 MyBatis+log4j，所以打印 log4j 日志。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%9C%89%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;mybatis-如何解析-mapper&#34;&gt;MyBatis 如何解析 mapper&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;resource：&lt;mapper resource=&#34;&#34;&gt;&lt;/li&gt;
&lt;li&gt;url：&lt;mapper url=&#34;&#34;&gt;&lt;/li&gt;
&lt;li&gt;class：&lt;mapper class=&#34;&#34;&gt;&lt;/li&gt;
&lt;li&gt;package：&lt;package name=&#34;&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mybatis-log4j-打印-log4j-日志&#34;&gt;MyBatis + Log4J 打印 Log4J 日志&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;
  &amp;lt;!-- spring-core --&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;5.0.9.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;!-- 剔除 spring-jcl 依赖 --&amp;gt;
    &amp;lt;exclusions&amp;gt;
      &amp;lt;exclusion&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-jcl&amp;lt;/artifactId&amp;gt;
      &amp;lt;/exclusion&amp;gt;
    &amp;lt;/exclusions&amp;gt;
  &amp;lt;/dependency&amp;gt;
  &amp;lt;!-- spring 连接池 --&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;5.0.9.RELEASE&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;
  &amp;lt;!-- mybatis --&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.4.6&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;
  &amp;lt;!-- mybatis-spring --&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis-spring&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;
  &amp;lt;!-- mysql-connector-java --&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;5.1.46&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;
  &amp;lt;!-- log4j --&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.2.17&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE configuration
        PUBLIC &amp;quot;-//mybatis.org//DTD Config 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-config.dtd&amp;quot;&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;environments default=&amp;quot;development&amp;quot;&amp;gt;
        &amp;lt;environment id=&amp;quot;development&amp;quot;&amp;gt;
            &amp;lt;transactionManager type=&amp;quot;JDBC&amp;quot;/&amp;gt;
            &amp;lt;dataSource type=&amp;quot;POOLED&amp;quot;&amp;gt;
                &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;com.mysql.jdbc.Driver&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;jdbc:mysql://localhost:3306/t1&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;root&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;123456&amp;quot;/&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
    &amp;lt;/environments&amp;gt;
    &amp;lt;mappers&amp;gt;
&amp;lt;!--        &amp;lt;mapper resource=&amp;quot;org/mybatis/example/BlogMapper.xml&amp;quot;/&amp;gt;--&amp;gt;
    &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) throws IOException {
        String resource = &amp;quot;mybatis-config.xml&amp;quot;;
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        SqlSession sqlSession = sqlSessionFactory.openSession();
        sqlSession.getConfiguration().addMapper(IndexDao.class);
        IndexDao mapper = sqlSession.getMapper(IndexDao.class);
        System.out.println(mapper.list());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%9C%89%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/log4j%E4%BE%9D%E8%B5%96.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;具体实现类&#34;&gt;具体实现类&lt;/h2&gt;
&lt;p&gt;mybatis提供很多日志的实现类,用来记录日志,取决于初始化的时候load到的class&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/MyBatis%E6%97%A5%E5%BF%97%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%B1%BB.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;上图红色箭头可以看到 JakartaCommonsLoggingImpl 中引用了 jcl 的类,如果在初始化的时候load到类为JakartaCommonsLoggingImpl，
那么则使用 jcl 去实现日志记录,但是也是顺序的,顺序参考源码
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;自己模拟实现mybaits的日志实现&#34;&gt;自己模拟实现mybaits的日志实现&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;mybatis的官网关于日志的介绍
定义org.apache.ibatis.session.Configuration
参考org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl
分析为什么jcl不记录日志,修改代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;架构系统如何考虑日志&#34;&gt;架构系统如何考虑日志&lt;/h1&gt;
&lt;p&gt;old:jcl+log4j&lt;/p&gt;
&lt;p&gt;new:slf4j+jul&lt;/p&gt;
">MyBatis系列（一）MyBatis日志</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/spring-xi-lie-shi-er-spring-ri-zhi/"" data-c="
          &lt;ul&gt;
&lt;li&gt;各种日志技术的关系和作用&lt;/li&gt;
&lt;li&gt;通过源码来分析spring的日志技术&lt;/li&gt;
&lt;li&gt;commons-logging源码分析&lt;/li&gt;
&lt;li&gt;通过源码分析mybaits的日志技术&lt;/li&gt;
&lt;li&gt;架构系统时候如何选择、优化日志技术&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;先从一个-spring-日志开始&#34;&gt;先从一个 Spring 日志开始&lt;/h1&gt;
&lt;p&gt;1、配置文件引入 spring-context&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;5.0.9.RELEASE&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、一个 配置类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@Component(&amp;quot;com.ssm&amp;quot;)
public class AppConfig {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、一个 Service&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class IndexService {
    public void query(){
        System.out.println(&amp;quot;query...&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、测试类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext configApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
        configApplicationContext.start();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5、日志打印如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;五月 17, 2020 12:02:07 下午 org.springframework.context.support.AbstractApplicationContext prepareRefresh
信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@7e6cbb7a: startup date [Sun May 17 12:02:07 CST 2020]; root of context hierarchy
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;spring4-spring5-日志打印&#34;&gt;Spring4、Spring5 日志打印&lt;/h2&gt;
&lt;p&gt;接下来开始分析这个日志如何打印出来的&lt;/p&gt;
&lt;p&gt;先从日志打印 AbstractApplicationContext 类开始：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void prepareRefresh() {
   this.startupDate = System.currentTimeMillis();
   this.closed.set(false);
   this.active.set(true);
   if (logger.isInfoEnabled()) {
      logger.info(&amp;quot;Refreshing &amp;quot; + this);
   }
   // Initialize any placeholder property sources in the context environment
   initPropertySources();
   // Validate that all properties marked as required are resolvable
   // see ConfigurablePropertyResolver#setRequiredProperties
   getEnvironment().validateRequiredProperties();
   // Allow for the collection of early ApplicationEvents,
   // to be published once the multicaster is available...
   this.earlyApplicationEvents = new LinkedHashSet&amp;lt;&amp;gt;();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第6 行打印 Refreshing：即我们上面看到的日志打印结果，这里调用了 logger.info()，那么我们来看看这个 logger 到底是什么？先来剧透一下：其实它是一个 JUL。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected final Log logger = LogFactory.getLog(getClass());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于 JUL 是 JDK 的，很难去修改它的打印格式，于是我们想把日志打印换成 log4j，于是我们在 xml 中加上 log4j 依赖，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.2.17&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;log4j 配置文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-prolog&#34;&gt;log4j.rootLogger=ERROR,stdout
# 输出到控制台
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.target=System.out
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss,SSS} %p [%t] %C.%M(%L) | %m%n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果却发现，即使加上了 log4j 依赖，日志却仍然使用 JUL 打印&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;五月 17, 2020 12:13:10 下午 org.springframework.context.support.AbstractApplicationContext prepareRefresh
信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@7106e68e: startup date [Sun May 17 12:13:09 CST 2020]; root of context hierarchy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当将 Spring 版本更改为 4.x.x 后，上述代码成功打印了 log4j 日志：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;4.3.16.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于 log4j 内配置只打印 ERROR 级别的日志，由于没有 ERROR，所以日志打印为空。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/log4j%E6%97%A5%E5%BF%97.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;主流的log技术名词&#34;&gt;主流的log技术名词&lt;/h1&gt;
&lt;h2 id=&#34;1log4j&#34;&gt;1.log4j&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可以不需要依赖第三方的技术&lt;/li&gt;
&lt;li&gt;直接记录日志&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（1）引入依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.2.17&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（2）配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;log4j.rootLogger=INFO,stdout
# 输出到控制台
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.target=System.out
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss,SSS} %p [%t] %C.%M(%L) | %m%n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（3）测试类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.apache.log4j.Logger;
public class Log4j {
    public static void main(String[] args) {
        Logger logger = Logger.getLogger(&amp;quot;log4j&amp;quot;);
        logger.info(&amp;quot;log4j&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（4）日志打印：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2020-05-17 12:44:41,453 INFO [main] com.ssm.utils.Log4j.main(9) | log4j
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2jul&#34;&gt;2.jul&lt;/h2&gt;
&lt;p&gt;java自带的一个日志记录的技术,直接使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.logging.Logger;
public class JUL {
    public static void main(String[] args) {
        Logger logger = Logger.getLogger(&amp;quot;jul&amp;quot;);
        logger.info(&amp;quot;jul&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;五月 17, 2020 12:45:59 下午 com.ssm.utils.JUL main
信息: jul
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3jcl&#34;&gt;3.jcl&lt;/h2&gt;
&lt;p&gt;jakartaCommonsLoggingImpl&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;commons-logging&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;commons-logging&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.1.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;jcl他不直接记录日志,他是通过第三方记录日志(jul、log4j)&lt;/li&gt;
&lt;li&gt;如果使用jcl来记录日志,在没有log4j的依赖情况下,使用jul&lt;/li&gt;
&lt;li&gt;如果有了log4j则使用log4j&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/JCL%E6%97%A5%E5%BF%97.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;log4j&#34;&gt;log4j&lt;/h3&gt;
&lt;p&gt;当有 log4j 依赖时，JCL 日志使用 log4j 打印：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class JCL {
    public static void main(String[] args) {
        Log log = LogFactory.getLog(&amp;quot;jcl&amp;quot;);
        log.info(&amp;quot;jcl&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/JCL_log4j.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;日志打印：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2020-05-17 12:50:04,813 INFO [main] com.ssm.utils.JCL.main(9) | jcl
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;分析&#34;&gt;分析&lt;/h4&gt;
&lt;p&gt;LogFactory#getLog&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static Log getLog(String name) throws LogConfigurationException {
    return getFactory().getInstance(name);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;LogFactoryImpl#getInstance&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Log getInstance(String name) throws LogConfigurationException {
    Log instance = (Log) instances.get(name);
    if (instance == null) {
        instance = newInstance(name);
        instances.put(name, instance);
    }
    return instance;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 4 行：&lt;br&gt;
LogFactoryImpl#newInstance&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected Log newInstance(String name) throws LogConfigurationException {
    Log instance;
    try {
        if (logConstructor == null) {
            instance = discoverLogImplementation(name);
        }
        else {
            Object params[] = { name };
            instance = (Log) logConstructor.newInstance(params);
        }
        if (logMethod != null) {
            Object params[] = { this };
            logMethod.invoke(instance, params);
        }
        return instance;
    } catch (LogConfigurationException lce) {
        // this type of exception means there was a problem in discovery
        // and we&#39;ve already output diagnostics about the issue, etc.;
        // just pass it on
        throw lce;
    } catch (InvocationTargetException e) {
        // A problem occurred invoking the Constructor or Method
        // previously discovered
        Throwable c = e.getTargetException();
        throw new LogConfigurationException(c == null ? e : c);
    } catch (Throwable t) {
        handleThrowable(t); // may re-throw t
        // A problem occurred invoking the Constructor or Method
        // previously discovered
        throw new LogConfigurationException(t);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;LogFactoryImpl#discoverLogImplementation&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Log discoverLogImplementation(String logCategory)
    throws LogConfigurationException {
    if (isDiagnosticsEnabled()) {
        logDiagnostic(&amp;quot;Discovering a Log implementation...&amp;quot;);
    }
    initConfiguration();
    Log result = null;
    // See if the user specified the Log implementation to use
    String specifiedLogClassName = findUserSpecifiedLogClassName();
    if (specifiedLogClassName != null) {
        if (isDiagnosticsEnabled()) {
            logDiagnostic(&amp;quot;Attempting to load user-specified log class &#39;&amp;quot; +
                specifiedLogClassName + &amp;quot;&#39;...&amp;quot;);
        }
        result = createLogFromClass(specifiedLogClassName,
                                    logCategory,
                                    true);
        if (result == null) {
            StringBuffer messageBuffer =  new StringBuffer(&amp;quot;User-specified log class &#39;&amp;quot;);
            messageBuffer.append(specifiedLogClassName);
            messageBuffer.append(&amp;quot;&#39; cannot be found or is not useable.&amp;quot;);
            // Mistyping or misspelling names is a common fault.
            // Construct a good error message, if we can
            informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_LOG4J_LOGGER);
            informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_JDK14_LOGGER);
            informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_LUMBERJACK_LOGGER);
            informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_SIMPLE_LOGGER);
            throw new LogConfigurationException(messageBuffer.toString());
        }
        return result;
    }
    // No user specified log; try to discover what&#39;s on the classpath
    //
    // Note that we deliberately loop here over classesToDiscover and
    // expect method createLogFromClass to loop over the possible source
    // classloaders. The effect is:
    //   for each discoverable log adapter
    //      for each possible classloader
    //          see if it works
    //
    // It appears reasonable at first glance to do the opposite:
    //   for each possible classloader
    //     for each discoverable log adapter
    //        see if it works
    //
    // The latter certainly has advantages for user-installable logging
    // libraries such as log4j; in a webapp for example this code should
    // first check whether the user has provided any of the possible
    // logging libraries before looking in the parent classloader.
    // Unfortunately, however, Jdk14Logger will always work in jvm&amp;gt;=1.4,
    // and SimpleLog will always work in any JVM. So the loop would never
    // ever look for logging libraries in the parent classpath. Yet many
    // users would expect that putting log4j there would cause it to be
    // detected (and this is the historical JCL behaviour). So we go with
    // the first approach. A user that has bundled a specific logging lib
    // in a webapp should use a commons-logging.properties file or a
    // service file in META-INF to force use of that logging lib anyway,
    // rather than relying on discovery.
    if (isDiagnosticsEnabled()) {
        logDiagnostic(
            &amp;quot;No user-specified Log implementation; performing discovery&amp;quot; +
            &amp;quot; using the standard supported logging implementations...&amp;quot;);
    }
    for(int i=0; i&amp;lt;classesToDiscover.length &amp;amp;&amp;amp; result == null; ++i) {
        result = createLogFromClass(classesToDiscover[i], logCategory, true);
    }
    if (result == null) {
        throw new LogConfigurationException
                    (&amp;quot;No suitable Log implementation&amp;quot;);
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 74 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;result = createLogFromClass(classesToDiscover[i], logCategory, true);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static final String[] classesToDiscover = {
        LOGGING_IMPL_LOG4J_LOGGER,
        &amp;quot;org.apache.commons.logging.impl.Jdk14Logger&amp;quot;,
        &amp;quot;org.apache.commons.logging.impl.Jdk13LumberjackLogger&amp;quot;,
        &amp;quot;org.apache.commons.logging.impl.SimpleLog&amp;quot;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static final String LOGGING_IMPL_LOG4J_LOGGER = &amp;quot;org.apache.commons.logging.impl.Log4JLogger&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当执行到 73 行，进行第 0 次 for 循环时，将 org.apache.commons.logging.impl.Log4JLogger 作为第一个参数传递给 createLogFromClass 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Log createLogFromClass(String logAdapterClassName,
                               String logCategory,
                               boolean affectState)
    throws LogConfigurationException {
    if (isDiagnosticsEnabled()) {
        logDiagnostic(&amp;quot;Attempting to instantiate &#39;&amp;quot; + logAdapterClassName + &amp;quot;&#39;&amp;quot;);
    }
    Object[] params = { logCategory };
    Log logAdapter = null;
    Constructor constructor = null;
    Class logAdapterClass = null;
    ClassLoader currentCL = getBaseClassLoader();
    for(;;) {
        // Loop through the classloader hierarchy trying to find
        // a viable classloader.
        logDiagnostic(&amp;quot;Trying to load &#39;&amp;quot; + logAdapterClassName + &amp;quot;&#39; from classloader &amp;quot; + objectId(currentCL));
        try {
            if (isDiagnosticsEnabled()) {
                // Show the location of the first occurrence of the .class file
                // in the classpath. This is the location that ClassLoader.loadClass
                // will load the class from -- unless the classloader is doing
                // something weird.
                URL url;
                String resourceName = logAdapterClassName.replace(&#39;.&#39;, &#39;/&#39;) + &amp;quot;.class&amp;quot;;
                if (currentCL != null) {
                    url = currentCL.getResource(resourceName );
                } else {
                    url = ClassLoader.getSystemResource(resourceName + &amp;quot;.class&amp;quot;);
                }
                if (url == null) {
                    logDiagnostic(&amp;quot;Class &#39;&amp;quot; + logAdapterClassName + &amp;quot;&#39; [&amp;quot; + resourceName + &amp;quot;] cannot be found.&amp;quot;);
                } else {
                    logDiagnostic(&amp;quot;Class &#39;&amp;quot; + logAdapterClassName + &amp;quot;&#39; was found at &#39;&amp;quot; + url + &amp;quot;&#39;&amp;quot;);
                }
            }
            Class c;
            try {
                c = Class.forName(logAdapterClassName, true, currentCL);
            } catch (ClassNotFoundException originalClassNotFoundException) {
                // The current classloader was unable to find the log adapter
                // in this or any ancestor classloader. There&#39;s no point in
                // trying higher up in the hierarchy in this case..
                String msg = originalClassNotFoundException.getMessage();
                logDiagnostic(&amp;quot;The log adapter &#39;&amp;quot; + logAdapterClassName + &amp;quot;&#39; is not available via classloader &amp;quot; +
                              objectId(currentCL) + &amp;quot;: &amp;quot; + msg.trim());
                try {
                    // Try the class classloader.
                    // This may work in cases where the TCCL
                    // does not contain the code executed or JCL.
                    // This behaviour indicates that the application
                    // classloading strategy is not consistent with the
                    // Java 1.2 classloading guidelines but JCL can
                    // and so should handle this case.
                    c = Class.forName(logAdapterClassName);
                } catch (ClassNotFoundException secondaryClassNotFoundException) {
                    // no point continuing: this adapter isn&#39;t available
                    msg = secondaryClassNotFoundException.getMessage();
                    logDiagnostic(&amp;quot;The log adapter &#39;&amp;quot; + logAdapterClassName +
                                  &amp;quot;&#39; is not available via the LogFactoryImpl class classloader: &amp;quot; + msg.trim());
                    break;
                }
            }
            constructor = c.getConstructor(logConstructorSignature);
            Object o = constructor.newInstance(params);
            // Note that we do this test after trying to create an instance
            // [rather than testing Log.class.isAssignableFrom(c)] so that
            // we don&#39;t complain about Log hierarchy problems when the
            // adapter couldn&#39;t be instantiated anyway.
            if (o instanceof Log) {
                logAdapterClass = c;
                logAdapter = (Log) o;
                break;
            }
            // Oops, we have a potential problem here. An adapter class
            // has been found and its underlying lib is present too, but
            // there are multiple Log interface classes available making it
            // impossible to cast to the type the caller wanted. We
            // certainly can&#39;t use this logger, but we need to know whether
            // to keep on discovering or terminate now.
            //
            // The handleFlawedHierarchy method will throw
            // LogConfigurationException if it regards this problem as
            // fatal, and just return if not.
            handleFlawedHierarchy(currentCL, c);
        } catch (NoClassDefFoundError e) {
            // We were able to load the adapter but it had references to
            // other classes that could not be found. This simply means that
            // the underlying logger library is not present in this or any
            // ancestor classloader. There&#39;s no point in trying higher up
            // in the hierarchy in this case..
            String msg = e.getMessage();
            logDiagnostic(&amp;quot;The log adapter &#39;&amp;quot; + logAdapterClassName +
                          &amp;quot;&#39; is missing dependencies when loaded via classloader &amp;quot; + objectId(currentCL) +
                          &amp;quot;: &amp;quot; + msg.trim());
            break;
        } catch (ExceptionInInitializerError e) {
            // A static initializer block or the initializer code associated
            // with a static variable on the log adapter class has thrown
            // an exception.
            //
            // We treat this as meaning the adapter&#39;s underlying logging
            // library could not be found.
            String msg = e.getMessage();
            logDiagnostic(&amp;quot;The log adapter &#39;&amp;quot; + logAdapterClassName +
                          &amp;quot;&#39; is unable to initialize itself when loaded via classloader &amp;quot; + objectId(currentCL) +
                          &amp;quot;: &amp;quot; + msg.trim());
            break;
        } catch (LogConfigurationException e) {
            // call to handleFlawedHierarchy above must have thrown
            // a LogConfigurationException, so just throw it on
            throw e;
        } catch (Throwable t) {
            handleThrowable(t); // may re-throw t
            // handleFlawedDiscovery will determine whether this is a fatal
            // problem or not. If it is fatal, then a LogConfigurationException
            // will be thrown.
            handleFlawedDiscovery(logAdapterClassName, currentCL, t);
        }
        if (currentCL == null) {
            break;
        }
        // try the parent classloader
        // currentCL = currentCL.getParent();
        currentCL = getParentClassLoader(currentCL);
    }
    if (logAdapterClass != null &amp;amp;&amp;amp; affectState) {
        // We&#39;ve succeeded, so set instance fields
        this.logClassName   = logAdapterClassName;
        this.logConstructor = constructor;
        // Identify the &amp;lt;code&amp;gt;setLogFactory&amp;lt;/code&amp;gt; method (if there is one)
        try {
            this.logMethod = logAdapterClass.getMethod(&amp;quot;setLogFactory&amp;quot;, logMethodSignature);
            logDiagnostic(&amp;quot;Found method setLogFactory(LogFactory) in &#39;&amp;quot; + logAdapterClassName + &amp;quot;&#39;&amp;quot;);
        } catch (Throwable t) {
            handleThrowable(t); // may re-throw t
            this.logMethod = null;
            logDiagnostic(&amp;quot;[INFO] &#39;&amp;quot; + logAdapterClassName + &amp;quot;&#39; from classloader &amp;quot; + objectId(currentCL) +
                          &amp;quot; does not declare optional method &amp;quot; + &amp;quot;setLogFactory(LogFactory)&amp;quot;);
        }
        logDiagnostic(&amp;quot;Log adapter &#39;&amp;quot; + logAdapterClassName + &amp;quot;&#39; from classloader &amp;quot; +
                      objectId(logAdapterClass.getClassLoader()) + &amp;quot; has been selected for use.&amp;quot;);
    }
    return logAdapter;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 44 行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;c = Class.forName(logAdapterClassName, true, currentCL);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;logAdapterClassName 是 createLogFromClass 方法的第一个参数  org.apache.commons.logging.impl.Log4JLogger&lt;br&gt;
Class c = Class.forName(&amp;quot;org.apache.commons.logging.impl.Log4JLogger&amp;quot;, true, currentCL);&lt;/p&gt;
&lt;p&gt;如果能够得到这个 Class，c 就有值，因为当前有 log4j 依赖，所以能够得到 Log4JLogger 类。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/c.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上述代码第 70 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//  得到这个类的构造方法
constructor = c.getConstructor(logConstructorSignature);
// 创建一个实例对象
Object o = constructor.newInstance(params);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/o.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上述代码第 77 行：把创建出来的实例对象 o 赋值给 logAdapter&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if (o instanceof Log) {
    logAdapterClass = c;
    logAdapter = (Log) o;
    break;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第 158 行：返回实例化对象 logAdapter：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;return logAdapter;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;于是第一次 for 循环结束，result != null ，于是终止 for 循环&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;for(int i=0; i&amp;lt;classesToDiscover.length &amp;amp;&amp;amp; result == null; ++i) {
    result = createLogFromClass(classesToDiscover[i], logCategory, true);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;jul&#34;&gt;JUL&lt;/h3&gt;
&lt;p&gt;当 pom.xml 内没有 log4j 依赖时，JCL 日志使用 JUL 打印：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/JUL.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;五月 17, 2020 12:59:17 下午 jcl main
信息: jcl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Class c = Class.forName(&amp;quot;org.apache.commons.logging.impl.Log4JLogger&amp;quot;, true, currentCL);&lt;br&gt;
因为当前没有 log4j 依赖，所以不能得到 Log4JLogger 类，所以进入 catch (NoClassDefFoundError e){，logAdapter 没有被复制，最终返回 null。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/logAdapter.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;于是进入第 1 次循环：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;for(int i=0; i&amp;lt;classesToDiscover.length &amp;amp;&amp;amp; result == null; ++i) {
    result = createLogFromClass(classesToDiscover[i], logCategory, true);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classesToDiscover[1] = org.apache.commons.logging.impl.Jdk14Logger&lt;br&gt;
因为 Jdk14Logger 是JDK 内部自带的，所以执行第 1 次循环，返回的 result 一定有值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/c_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/logAdapter_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;jcl=Jakarta commons-logging ,是apache公司开发的一个抽象日志通用框架,本身不实现日志记录,
但是提供了记录日志的抽象方法即接口(info,debug,error.......),底层通过一个数组存放具体的日志
框架的类名,然后循环数组依次去匹配这些类名是否在app中被依赖了,如果找到被依赖的则直接使用,所以他
有先后顺序。
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/jcl1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;上图为jcl中存放日志技术类名的数组，默认有四个，后面两个可以忽略。
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/jcl0.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;上图81行就是通过一个类名去load一个class，如果load成功则直接new出来并且返回使用。
如果没有load到class这循环第二个，直到找到为止。
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/jcl2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;可以看到这里的循环条件必须满足result不为空，
也就是如果没有找到具体的日志依赖则继续循环，如果找到则条件不成立，不进行循环了。
总结：顺序log4j&amp;gt;jul
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;为什么要引入-jcl&#34;&gt;为什么要引入 JCL&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/JCL.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果要合并两个 app1 和 app2，其中 app1 使用 JUL 日志，app2 使用 lot4j 记录日志，就会出现：日志打印格式混乱问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%B8%A4%E7%A7%8D%E6%97%A5%E5%BF%97.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/JCL%E7%9A%84%E4%BD%BF%E7%94%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果使用 JCL，如果想使用 log4j 打印日志，只需引入 log4j 依赖；如果想使用 JUL 打印日志，只需删除 log4j 依赖即可。&lt;/p&gt;
&lt;h2 id=&#34;4log4j2&#34;&gt;4.log4j2&lt;/h2&gt;
&lt;h2 id=&#34;5slf4j&#34;&gt;5.slf4j&lt;/h2&gt;
&lt;p&gt;slf4j官网：&lt;a href=&#34;http://www.slf4j.org/&#34;&gt;http://www.slf4j.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;slf4j他也不记录日志,通过绑定器绑定一个具体的日志记录来完成日志记录&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log4j---&amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/slf4j.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;加入-slf4j-依赖&#34;&gt;加入 slf4j 依赖&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- slf4j --&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.7.25&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!-- 绑定器：注绑定器版本号和 slf4j 版本号要一致 --&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;slf4j-jdk14&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.7.25&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/slf4j%E6%94%AF%E6%8C%81%E7%9A%84%E6%97%A5%E5%BF%97%E7%BB%91%E5%AE%9A.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;模拟日志打印&#34;&gt;模拟日志打印&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class SLF4J {
    public static void main(String[] args) {
        Logger logger = LoggerFactory.getLogger(&amp;quot;slf4j&amp;quot;);
        logger.info(&amp;quot;slf4j&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;日志打印 JUL：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;五月 17, 2020 5:25:58 下午 com.ssm.utils.SLF4J main
信息: slf4j
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当绑定 slf4j 时，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- slf4j --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.7.25&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!-- 绑定器：log4j --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.7.25&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;日志打印是 log4j 形式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2020-05-17 17:30:47,801 INFO [main] com.ssm.utils.SLF4J.main(9) | slf4j
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%B8%8D%E5%90%8C%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果想统一日志格式为 log4j，只需修改 app1 的绑定器，使它绑定 log4j 即可，如下图所示：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E7%BB%9F%E4%B8%80%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E4%B8%BAlog4j.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果想统一日志格式为 JUL ：① 可删除 Spring 内的 log4j 依赖，JCL 就自动使用 JCL 了。&lt;/p&gt;
&lt;p&gt;② 为 Spring 添加桥接器，通过桥接器把它桥接到 slf4j，然后再绑定 JUL，就能打印 JUL 了，如下图所示：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E7%BB%9F%E4%B8%80%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E4%B8%BAJUL.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;模拟&#34;&gt;模拟&lt;/h3&gt;
&lt;h4 id=&#34;两种日志打印&#34;&gt;两种日志打印&lt;/h4&gt;
&lt;p&gt;Sring 使用 JCL，且有 log4j，即 Spring 使用 log4j 日志打印。&lt;/p&gt;
&lt;p&gt;App1 使用 slf4j ，绑定器绑定 JUL 日志打印。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;4.3.16.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- 绑定器：JUL --&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;slf4j-jdk14&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.7.25&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- log4j --&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.2.17&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- JCL --&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;commons-logging&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;commons-logging&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.2&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
  &amp;lt;/dependencies&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自己的 app 使用 slf4j 日志打印：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class SLF4J {
    public static void main(String[] args) {
        Logger logger = LoggerFactory.getLogger(&amp;quot;slf4j&amp;quot;);
        logger.info(&amp;quot;slf4j&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/slf4j%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Spring 使用 log4j 日志打印：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
public class TestSpringLog {
    public static void main(String[] args) {
        Log log = LogFactory.getLog(&amp;quot;spring&amp;quot;);
        log.info(&amp;quot;spring...JCL&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/log4j%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;统一日志打印&#34;&gt;统一日志打印&lt;/h4&gt;
&lt;p&gt;添加桥接器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- 桥接器 --&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;jcl-over-slf4j&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.7.25&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
public class TestSpringLog {
    public static void main(String[] args) {
        Log log = LogFactory.getLog(&amp;quot;spring&amp;quot;);
        log.info(&amp;quot;spring...JCL&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%BE%9D%E8%B5%96%E6%B7%B7%E4%B9%B1%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Spring 日志打印也变成 JUL 了。&lt;/p&gt;
&lt;h3 id=&#34;依赖混乱导致内存溢出&#34;&gt;依赖混乱导致内存溢出&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;4.3.16.RELEASE&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;
  &amp;lt;!-- slf4j --&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.7.25&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;
  &amp;lt;!-- 绑定器：JCL. slf4j 绑定到 JCL --&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;slf4j-jcl&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.7.25&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;
  &amp;lt;!-- 桥接器：JCL. JCL 桥接到 slf4j --&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jcl-over-slf4j&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.7.25&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.ssm.app.AppConfig;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext configApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
        configApplicationContext.start();
        LoggerFactory.getLogger(&amp;quot;ttt&amp;quot;).info(&amp;quot;test&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;6logback&#34;&gt;6.logback&lt;/h2&gt;
&lt;h2 id=&#34;7simple-log&#34;&gt;7.simple-log&lt;/h2&gt;
&lt;h1 id=&#34;各种日志技术的关系和作用&#34;&gt;各种日志技术的关系和作用&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%90%84%E7%A7%8D%E6%97%A5%E5%BF%97.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;spring日志技术分析&#34;&gt;spring日志技术分析&lt;/h1&gt;
&lt;p&gt;再来看一下开始的那个问题：Spring4 加上 log4j 就打印 log4j 日志；但是 Spring5 加上 log4j 仍打印 JUL 日志。&lt;/p&gt;
&lt;h2 id=&#34;spring4日志技术实现&#34;&gt;spring4.*日志技术实现&lt;/h2&gt;
&lt;p&gt;spring4当中依赖的是原生的jcl：commons-logging.jar&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Spring4%E6%97%A5%E5%BF%97.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/Spring4%E5%BC%95%E5%85%A5log4j.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;上面的日志打印说是在org.springframework.context.support.AbstractApplicationContext.prepareRefresh(583) 内进行的日志打印：logger.info(&amp;quot;Refreshing &amp;quot; + this);&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Spring%E7%89%88%E6%9C%AC%E5%8F%B7.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这里我们要查看的是 Spring4 的 AbstractApplicationContext，我们来看一下 AbstractApplicationContext#prepareRefresh&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void prepareRefresh() {
   this.startupDate = System.currentTimeMillis();
   this.closed.set(false);
   this.active.set(true);
   if (logger.isInfoEnabled()) {
      logger.info(&amp;quot;Refreshing &amp;quot; + this);
   }
   // Initialize any placeholder property sources in the context environment
   initPropertySources();
   // Validate that all properties marked as required are resolvable
   // see ConfigurablePropertyResolver#setRequiredProperties
   getEnvironment().validateRequiredProperties();
   // Allow for the collection of early ApplicationEvents,
   // to be published once the multicaster is available...
   this.earlyApplicationEvents = new LinkedHashSet&amp;lt;ApplicationEvent&amp;gt;();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Log4JLogger.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;org.springframework.context.support.AbstractApplicationContext.prepareRefresh(583) 的 logger 对象是 Log4JLogger，所以打印 log4j 日志。&lt;/p&gt;
&lt;p&gt;来看一个 logger 变量的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected final Log logger = LogFactory.getLog(getClass());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们再来看一下这个 Log 对象，它是 JCL （org.apache.commons.logging）包下的，我们的 pom.xml 中并未引入 JCL 依赖，只引入了 spring-context 和 log4j 依赖，于是猜想 spring-context 中有 JCL 依赖。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package org.apache.commons.logging;
public interface Log {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看一下 maven 依赖图：&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/spring4maven%E4%BE%9D%E8%B5%96.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring4 当中依赖了 JCL，Spring4 中采用的日志技术是 JCL：commons-logging.jar&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;LogFactory#getLog&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static Log getLog(Class clazz) throws LogConfigurationException {
    return getFactory().getInstance(clazz);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;LogFactory#getFactory&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static LogFactory getFactory() throws LogConfigurationException {
    // Identify the class loader we will be using
    ClassLoader contextClassLoader = getContextClassLoaderInternal();
    if (contextClassLoader == null) {
        // This is an odd enough situation to report about. This
        // output will be a nuisance on JDK1.1, as the system
        // classloader is null in that environment.
        if (isDiagnosticsEnabled()) {
            logDiagnostic(&amp;quot;Context classloader is null.&amp;quot;);
        }
    }
    // Return any previously registered factory for this class loader
    LogFactory factory = getCachedFactory(contextClassLoader);
    if (factory != null) {
        return factory;
    }
    if (isDiagnosticsEnabled()) {
        logDiagnostic(
                &amp;quot;[LOOKUP] LogFactory implementation requested for the first time for context classloader &amp;quot; +
                objectId(contextClassLoader));
        logHierarchy(&amp;quot;[LOOKUP] &amp;quot;, contextClassLoader);
    }
    // Load properties file.
    //
    // If the properties file exists, then its contents are used as
    // &amp;quot;attributes&amp;quot; on the LogFactory implementation class. One particular
    // property may also control which LogFactory concrete subclass is
    // used, but only if other discovery mechanisms fail..
    //
    // As the properties file (if it exists) will be used one way or
    // another in the end we may as well look for it first.
    Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES);
    // Determine whether we will be using the thread context class loader to
    // load logging classes or not by checking the loaded properties file (if any).
    ClassLoader baseClassLoader = contextClassLoader;
    if (props != null) {
        String useTCCLStr = props.getProperty(TCCL_KEY);
        if (useTCCLStr != null) {
            // The Boolean.valueOf(useTCCLStr).booleanValue() formulation
            // is required for Java 1.2 compatibility.
            if (Boolean.valueOf(useTCCLStr).booleanValue() == false) {
                // Don&#39;t use current context classloader when locating any
                // LogFactory or Log classes, just use the class that loaded
                // this abstract class. When this class is deployed in a shared
                // classpath of a container, it means webapps cannot deploy their
                // own logging implementations. It also means that it is up to the
                // implementation whether to load library-specific config files
                // from the TCCL or not.
                baseClassLoader = thisClassLoader;
            }
        }
    }
    // Determine which concrete LogFactory subclass to use.
    // First, try a global system property
    if (isDiagnosticsEnabled()) {
        logDiagnostic(&amp;quot;[LOOKUP] Looking for system property [&amp;quot; + FACTORY_PROPERTY +
                      &amp;quot;] to define the LogFactory subclass to use...&amp;quot;);
    }
    try {
        String factoryClass = getSystemProperty(FACTORY_PROPERTY, null);
        if (factoryClass != null) {
            if (isDiagnosticsEnabled()) {
                logDiagnostic(&amp;quot;[LOOKUP] Creating an instance of LogFactory class &#39;&amp;quot; + factoryClass +
                              &amp;quot;&#39; as specified by system property &amp;quot; + FACTORY_PROPERTY);
            }
            factory = newFactory(factoryClass, baseClassLoader, contextClassLoader);
        } else {
            if (isDiagnosticsEnabled()) {
                logDiagnostic(&amp;quot;[LOOKUP] No system property [&amp;quot; + FACTORY_PROPERTY + &amp;quot;] defined.&amp;quot;);
            }
        }
    } catch (SecurityException e) {
        if (isDiagnosticsEnabled()) {
            logDiagnostic(&amp;quot;[LOOKUP] A security exception occurred while trying to create an&amp;quot; +
                          &amp;quot; instance of the custom factory class&amp;quot; + &amp;quot;: [&amp;quot; + trim(e.getMessage()) +
                          &amp;quot;]. Trying alternative implementations...&amp;quot;);
        }
        // ignore
    } catch (RuntimeException e) {
        // This is not consistent with the behaviour when a bad LogFactory class is
        // specified in a services file.
        //
        // One possible exception that can occur here is a ClassCastException when
        // the specified class wasn&#39;t castable to this LogFactory type.
        if (isDiagnosticsEnabled()) {
            logDiagnostic(&amp;quot;[LOOKUP] An exception occurred while trying to create an&amp;quot; +
                          &amp;quot; instance of the custom factory class&amp;quot; + &amp;quot;: [&amp;quot; +
                          trim(e.getMessage()) +
                          &amp;quot;] as specified by a system property.&amp;quot;);
        }
        throw e;
    }
    // Second, try to find a service by using the JDK1.3 class
    // discovery mechanism, which involves putting a file with the name
    // of an interface class in the META-INF/services directory, where the
    // contents of the file is a single line specifying a concrete class
    // that implements the desired interface.
    if (factory == null) {
        if (isDiagnosticsEnabled()) {
            logDiagnostic(&amp;quot;[LOOKUP] Looking for a resource file of name [&amp;quot; + SERVICE_ID +
                          &amp;quot;] to define the LogFactory subclass to use...&amp;quot;);
        }
        try {
            final InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID);
            if( is != null ) {
                // This code is needed by EBCDIC and other strange systems.
                // It&#39;s a fix for bugs reported in xerces
                BufferedReader rd;
                try {
                    rd = new BufferedReader(new InputStreamReader(is, &amp;quot;UTF-8&amp;quot;));
                } catch (java.io.UnsupportedEncodingException e) {
                    rd = new BufferedReader(new InputStreamReader(is));
                }
                String factoryClassName = rd.readLine();
                rd.close();
                if (factoryClassName != null &amp;amp;&amp;amp; ! &amp;quot;&amp;quot;.equals(factoryClassName)) {
                    if (isDiagnosticsEnabled()) {
                        logDiagnostic(&amp;quot;[LOOKUP]  Creating an instance of LogFactory class &amp;quot; +
                                      factoryClassName +
                                      &amp;quot; as specified by file &#39;&amp;quot; + SERVICE_ID +
                                      &amp;quot;&#39; which was present in the path of the context classloader.&amp;quot;);
                    }
                    factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader );
                }
            } else {
                // is == null
                if (isDiagnosticsEnabled()) {
                    logDiagnostic(&amp;quot;[LOOKUP] No resource file with name &#39;&amp;quot; + SERVICE_ID + &amp;quot;&#39; found.&amp;quot;);
                }
            }
        } catch (Exception ex) {
            // note: if the specified LogFactory class wasn&#39;t compatible with LogFactory
            // for some reason, a ClassCastException will be caught here, and attempts will
            // continue to find a compatible class.
            if (isDiagnosticsEnabled()) {
                logDiagnostic(
                    &amp;quot;[LOOKUP] A security exception occurred while trying to create an&amp;quot; +
                    &amp;quot; instance of the custom factory class&amp;quot; +
                    &amp;quot;: [&amp;quot; + trim(ex.getMessage()) +
                    &amp;quot;]. Trying alternative implementations...&amp;quot;);
            }
            // ignore
        }
    }
    // Third try looking into the properties file read earlier (if found)
    if (factory == null) {
        if (props != null) {
            if (isDiagnosticsEnabled()) {
                logDiagnostic(
                    &amp;quot;[LOOKUP] Looking in properties file for entry with key &#39;&amp;quot; + FACTORY_PROPERTY +
                    &amp;quot;&#39; to define the LogFactory subclass to use...&amp;quot;);
            }
            String factoryClass = props.getProperty(FACTORY_PROPERTY);
            if (factoryClass != null) {
                if (isDiagnosticsEnabled()) {
                    logDiagnostic(
                        &amp;quot;[LOOKUP] Properties file specifies LogFactory subclass &#39;&amp;quot; + factoryClass + &amp;quot;&#39;&amp;quot;);
                }
                factory = newFactory(factoryClass, baseClassLoader, contextClassLoader);
                // TODO: think about whether we need to handle exceptions from newFactory
            } else {
                if (isDiagnosticsEnabled()) {
                    logDiagnostic(&amp;quot;[LOOKUP] Properties file has no entry specifying LogFactory subclass.&amp;quot;);
                }
            }
        } else {
            if (isDiagnosticsEnabled()) {
                logDiagnostic(&amp;quot;[LOOKUP] No properties file available to determine&amp;quot; + &amp;quot; LogFactory subclass from..&amp;quot;);
            }
        }
    }
    // Fourth, try the fallback implementation class
    if (factory == null) {
        if (isDiagnosticsEnabled()) {
            logDiagnostic(
                &amp;quot;[LOOKUP] Loading the default LogFactory implementation &#39;&amp;quot; + FACTORY_DEFAULT +
                &amp;quot;&#39; via the same classloader that loaded this LogFactory&amp;quot; +
                &amp;quot; class (ie not looking in the context classloader).&amp;quot;);
        }
        // Note: unlike the above code which can try to load custom LogFactory
        // implementations via the TCCL, we don&#39;t try to load the default LogFactory
        // implementation via the context classloader because:
        // * that can cause problems (see comments in newFactory method)
        // * no-one should be customising the code of the default class
        // Yes, we do give up the ability for the child to ship a newer
        // version of the LogFactoryImpl class and have it used dynamically
        // by an old LogFactory class in the parent, but that isn&#39;t
        // necessarily a good idea anyway.
        factory = newFactory(FACTORY_DEFAULT, thisClassLoader, contextClassLoader);
    }
    if (factory != null) {
        /**
         * Always cache using context class loader.
         */
        cacheFactory(contextClassLoader, factory);
        if (props != null) {
            Enumeration names = props.propertyNames();
            while (names.hasMoreElements()) {
                String name = (String) names.nextElement();
                String value = props.getProperty(name);
                factory.setAttribute(name, value);
            }
        }
    }
    return factory;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;spring5日志技术实现&#34;&gt;spring5.*日志技术实现&lt;/h2&gt;
&lt;p&gt;spring5使用的spring的jcl(spring改了jcl的代码)来记录日志的,但是jcl不能直接记录日志,采用循环优先的原则&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Spring5%E6%97%A5%E5%BF%97.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/Spring5maven%E4%BE%9D%E8%B5%96.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring5 当中依赖了 JCL，Spring5 中采用的日志技术是 JCL：spring-jcl&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Spring5%E5%BC%95%E5%85%A5log4j.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上面的日志打印说是在org.springframework.context.support.AbstractApplicationContext prepareRefresh 内进行的日志打印：logger.info(&amp;quot;Refreshing &amp;quot; + this);&lt;/p&gt;
&lt;p&gt;这里我们要查看的是 Spring5 的 AbstractApplicationContext#prepareRefresh，我们来看一下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void prepareRefresh() {
   this.startupDate = System.currentTimeMillis();
   this.closed.set(false);
   this.active.set(true);
   if (logger.isInfoEnabled()) {
      logger.info(&amp;quot;Refreshing &amp;quot; + this);
   }
   // Initialize any placeholder property sources in the context environment
   initPropertySources();
   // Validate that all properties marked as required are resolvable
   // see ConfigurablePropertyResolver#setRequiredProperties
   getEnvironment().validateRequiredProperties();
   // Allow for the collection of early ApplicationEvents,
   // to be published once the multicaster is available...
   this.earlyApplicationEvents = new LinkedHashSet&amp;lt;&amp;gt;();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;25&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Spring5JUL.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;org.springframework.context.support.AbstractApplicationContext prepareRefresh 的 logger 对象是 JavaUtilLog，所以打印 JUL 日志。&lt;/p&gt;
&lt;p&gt;来看一个 logger 变量的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected final Log logger = LogFactory.getLog(getClass());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们再来看一下这个 Log 对象，它是 JCL （org.apache.commons.logging）包下的，虽然我们的 pom.xml 中并未引入 JCL 依赖，但是 spring-context 中有 JCL 依赖。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package org.apache.commons.logging;
public interface Log {
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;26&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Spring5JUL_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;一般情况下，JCL 在有 log4j 时，使用 log4j 打印日志；在没有 log4j 时，使用 JUL 打印日志。但是 Spring5 在有 log4j 时，仍然打印 JUL 日志，因为Spring 把 JCL 的源码改了。&lt;/p&gt;
&lt;p&gt;LogFactory#getLog&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static Log getLog(Class&amp;lt;?&amp;gt; clazz) {
   return getLog(clazz.getName());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;LogFactory#getLog&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static Log getLog(String name) {
   switch (logApi) {
      case LOG4J:
         return Log4jDelegate.createLog(name);
      case SLF4J_LAL:
         return Slf4jDelegate.createLocationAwareLog(name);
      case SLF4J:
         return Slf4jDelegate.createLog(name);
      default:
         // Defensively use lazy-initializing delegate class here as well since the
         // java.logging module is not present by default on JDK 9. We are requiring
         // its presence if neither Log4j nor SLF4J is available; however, in the
         // case of Log4j or SLF4J, we are trying to prevent early initialization
         // of the JavaUtilLog adapter - e.g. by a JVM in debug mode - when eagerly
         // trying to parse the bytecode for all the cases of this switch clause.
         return JavaUtilDelegate.createLog(name);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;27&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/logApi.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;来看一下 logApi 这个变量：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static LogApi logApi = LogApi.JUL;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JavaUtilDelegate#createLog&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static class JavaUtilDelegate {
   public static Log createLog(String name) {
      return new JavaUtilLog(name);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终会返回 JavaUtilLog。Spiring5 默认采用 JCL 绑定 JUL 打印日志。&lt;br&gt;
我们看一下 case LOG4J 分支：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;case LOG4J:
   return Log4jDelegate.createLog(name);   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果走 case LOG4J 分支，创建的是 Log4j2 日志：org.apache.logging.log4j.Level，而不是 log4j 日志：org.apache.log4j.Logger;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.apache.logging.log4j.Level;
private static class Log4jDelegate {
   public static Log createLog(String name) {
      return new Log4jLog(name);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以在 Spring5 中不能仅仅通过在 pom.xml 中引入 log4j 来使用 log4j。&lt;/p&gt;
&lt;h3 id=&#34;spring5-使用桥接器-slf4j-绑定-log4j-打印日志&#34;&gt;Spring5 使用桥接器 SLF4J 绑定 log4j 打印日志&lt;/h3&gt;
&lt;p&gt;如果想要使用 log4j 打印日志，就需要修改 logApi 的值，先来看一下 logApi 是在哪里赋值的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static {
   ClassLoader cl = LogFactory.class.getClassLoader();
   try {
      // 如果有 log4j2，就使用 log4j2 打印日志
      // Try Log4j 2.x API
      cl.loadClass(&amp;quot;org.apache.logging.log4j.spi.ExtendedLogger&amp;quot;);
      logApi = LogApi.LOG4J;
   }
   // 如果没有 log4j2
   catch (ClassNotFoundException ex1) {
      try {
         // 如果有 SLF4J，就桥接 SLF4J 日志打印
         // Try SLF4J 1.7 SPI
         cl.loadClass(&amp;quot;org.slf4j.spi.LocationAwareLogger&amp;quot;);
         logApi = LogApi.SLF4J_LAL;
      }
      catch (ClassNotFoundException ex2) {
         try {
            // Try SLF4J 1.7 API
            cl.loadClass(&amp;quot;org.slf4j.Logger&amp;quot;);
            logApi = LogApi.SLF4J;
         }
         catch (ClassNotFoundException ex3) {
            // Keep java.util.logging as default
         }
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;28&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/logApi%E8%B5%8B%E5%80%BC%E8%BF%87%E7%A8%8B.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;5.0.9.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- slf4j --&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.7.25&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- 绑定器：Log4J. slf4j 绑定到 Log4J --&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.7.25&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
  &amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;29&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Spring5%E6%89%93%E5%8D%B0log4j.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;总结-2&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;Spring4 默认使用 JCL 日志打印，通过 for 循环一个数组[&amp;quot;org.apache.commons.logging.impl.Log4JLogger&amp;quot;,&lt;/p&gt;
&lt;p&gt;&amp;quot;org.apache.commons.logging.impl.Jdk14Logger&amp;quot;,&lt;/p&gt;
&lt;p&gt;&amp;quot;org.apache.commons.logging.impl.Jdk13LumberjackLogger&amp;quot;,&lt;/p&gt;
&lt;p&gt;&amp;quot;org.apache.commons.logging.impl.SimpleLog&amp;quot;&lt;/p&gt;
&lt;p&gt;]，给 result 赋值。&lt;/p&gt;
&lt;p&gt;Spring5 默认采用 JCL 日志，但是 Spring 把 JCL 改了，底层用了一个 switch-case 去选择一个不同的日志实现，默认采用 JUL，当项目中如果有 SLF4J 或 Log4J2 时，Spring5 就会选用 SLF4J 或  Log4J2 ，采用一个 class.forName() 机制，如果找到了就修改 logApi 值，调用 getLog 方法时得到具体的日志实现。&lt;/p&gt;
">Spring系列（十二）Spring5新特性——日志</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/spring-xi-lie-shi-yi-spring-yuan-ma-jie-xi/"" data-c="
          &lt;h1 id=&#34;如何处理bean&#34;&gt;如何处理@Bean&lt;/h1&gt;
&lt;p&gt;给配置类产生 CGLIB 代理：需要维护配置类中 Bean 的作用域。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E9%85%8D%E7%BD%AE%E7%B1%BB%E4%BA%A7%E7%94%9FCGLIB%E4%BB%A3%E7%90%86.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;enhance&#34;&gt;enhance&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Class&amp;lt;?&amp;gt; enhance(Class&amp;lt;?&amp;gt; configClass, @Nullable ClassLoader classLoader) {
   // 判断是否被代理过
   // 如何判断是否被代理？这个 AppConfig 一旦被代理了，就会产生一个EnhancedConfiguration接口。
   // 如果实现了这个接口，就代表已经被代理过了，直接 return
   if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {
      if (logger.isDebugEnabled()) {
         logger.debug(String.format(&amp;quot;Ignoring request to enhance %s as it has &amp;quot; +
               &amp;quot;already been enhanced. This usually indicates that more than one &amp;quot; +
               &amp;quot;ConfigurationClassPostProcessor has been registered (e.g. via &amp;quot; +
               &amp;quot;&amp;lt;context:annotation-config&amp;gt;). This is harmless, but you may &amp;quot; +
               &amp;quot;want check your configuration and remove one CCPP if possible&amp;quot;,
               configClass.getName()));
      }
      return configClass;
   }
   // 如果没有被代理，就cglib 代理
   Class&amp;lt;?&amp;gt; enhancedClass = createClass(newEnhancer(configClass, classLoader));
   if (logger.isDebugEnabled()) {
      logger.debug(String.format(&amp;quot;Successfully enhanced %s; enhanced class name is: %s&amp;quot;,
            configClass.getName(), enhancedClass.getName()));
   }
   return enhancedClass;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;newenhancer&#34;&gt;newEnhancer&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Enhancer newEnhancer(Class&amp;lt;?&amp;gt; configSuperClass, @Nullable ClassLoader classLoader) {
   Enhancer enhancer = new Enhancer();
   // 增强父类，cglib 是基于继承来的
   // 把当前类 configSuperClass 作为 enhancer 的父类
   enhancer.setSuperclass(configSuperClass);
   // 增强接口，为什么要增强接口？
   // 便于判断，表示一个类已经被增强了
   enhancer.setInterfaces(new Class&amp;lt;?&amp;gt;[] {EnhancedConfiguration.class});
   enhancer.setUseFactory(false);
   enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
   // BeanFactoryAwareGeneratorStrategy 是一个生成策略
   // 主要为生成的 CGLIB 类中添加成员变量 $$beanFactory
   // 同时基于接口 EnhancedConfiguration 的父接口 BeanFactoryAware 中的 setBeanFactory 方法，
   // 设置此变量的值为当前 Context 中的 beanFactory，这样一来我们这个 cglib 代理的对象就有了 beanFactory
   // 有了 factory 就能获得对象，而不用去通过方法获得对象了，因为通过方法获得对象不能控制其过程
   // BeanFactory 的作用是在 this 调用时拦截该调用，并直接在 beanFactory 中获得目标 bean
   enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader));
   // 过滤方法，不能每次都去 new
   enhancer.setCallbackFilter(CALLBACK_FILTER);
   enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());
   return enhancer;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static final ConditionalCallbackFilter CALLBACK_FILTER = new ConditionalCallbackFilter(CALLBACKS);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static final Callback[] CALLBACKS = new Callback[] {
      // 增强方法，主要控制 bean 的作用域，就是不让它每调用方法都去 new
      new BeanMethodInterceptor(),
      // 设置一个 BeanFactory
      new BeanFactoryAwareMethodInterceptor(),
      NoOp.INSTANCE
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;怎样拿到-cglib-代理产生的类&#34;&gt;怎样拿到 CGLIB 代理产生的类？&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      // 初始化 Spring 的环境
      context. refresh();
      /**
       * 对目标对象的所有方法进行拦截
       */
      Enhancer enhancer = new Enhancer();
      enhancer.setSuperclass(IndexDaoImpl.class);
      // 增强接口
      enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
      // 添加方法过滤器
      enhancer.setCallback(new TestMethodCallabck());
      IndexDaoImpl indexDao = (IndexDaoImpl) enhancer.create();
      indexDao.query();
      try {
         System.in.read();
      } catch (IOException e) {
         e.printStackTrace();
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestMethodCallabck implements MethodInterceptor {
   /**
    *
    * @param o 代理对象
    * @param method 当前方法，目标对象的方法
    * @param objects 参数
    * @param methodProxy 代理对象的方法
    * @return
    * @throws Throwable
    */
   @Override
   public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
      System.out.println(&amp;quot;method...&amp;quot;);
      return methodProxy.invokeSuper(o,objects);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;原始类未经过代理的&#34;&gt;原始类（未经过代理的）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
public class AppConfig {
   @Bean
   public IndexDao indexDao2(){
      indexDao();
      return new IndexDaoImpl2();
   }
   @Bean
   public IndexDao indexDao(){
      return new IndexDaoImpl();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;经过-cglib-代理后得到的代理类&#34;&gt;经过 CGLIB 代理后得到的代理类&lt;/h2&gt;
&lt;h3 id=&#34;我们的猜测&#34;&gt;我们的猜测&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
public class xxxx extends AppConfig implements EnhancedConfiguration{
   private BeanFactory $$beanFactory;
   @Bean
   public IndexDao indexDao2(){
      if(第一次调用){
        // 调用父类方法，让父类去 new
        proxy.invokeSuper();
      }else{
        // 如果不是第一次调用，直接从 bean 工厂中取出对象并返回
        return $$beanFactory.getBean();
      }
   }
   @Bean
   public IndexDao indexDao(){
      return new IndexDaoImpl();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;代理类 extends AppConfig implements EnhancedConfiguration&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;enhancer.setInterfaces(new Class&amp;lt;?&amp;gt;[] {EnhancedConfiguration.class});
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;添加了一个属性：private BeanFactory $$beanFactory;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为代理类添加了一个方法过滤器后，代理类与原始类代码有什么区别？&lt;/p&gt;
&lt;p&gt;在外部调用时， AppConfig appConfig = getBean(); 拿到的对象是代理类 xxxx&lt;/p&gt;
&lt;p&gt;当调用 appConfig.indexDao() 时，具体方法里面是什么样还不知道。&lt;/p&gt;
&lt;p&gt;其实 indexDao() 方法并没有改变，只不过在这个方法前面还执行了一段代码进行拦截，可以调用父类方法，也可以直接调用子类方法。&lt;/p&gt;
&lt;h3 id=&#34;查看-cglib-生成的-class-文件&#34;&gt;查看 CGLIB 生成的 class 文件&lt;/h3&gt;
&lt;p&gt;java -classpath &amp;quot;C:\Program Files\Java\jdk1.8.0_172\lib\sa-jdi.jar&amp;quot; sun.jvm.hotspot.HSDB&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Only@DESKTOP-MHJI7PB MINGW64 ~/Downloads/spring-framework-5.0.x
$ jps
11408 RemoteMavenServer36
22980 Test
23636 Launcher
24132 KotlinCompileDaemon
24708
22172 Jps
Only@DESKTOP-MHJI7PB MINGW64 ~/Downloads/spring-framework-5.0.x
$ java -classpath &amp;quot;C:\Program Files\Java\jdk1.8.0_172\lib\sa-jdi.jar&amp;quot; sun.jvm.hotspot.HSDB
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%BE%97%E5%88%B0CGLIB%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90%E7%9A%84class%E6%96%87%E4%BB%B6_1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%BE%97%E5%88%B0CGLIB%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90%E7%9A%84class%E6%96%87%E4%BB%B6_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%BE%97%E5%88%B0CGLIB%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90%E7%9A%84class%E6%96%87%E4%BB%B6_3.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;创建完成后，在当前运行目录  ~/Downloads/spring-framework-5.0.x 下&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%BE%97%E5%88%B0CGLIB%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90%E7%9A%84class%E6%96%87%E4%BB%B6_4.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%BE%97%E5%88%B0CGLIB%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90%E7%9A%84class%E6%96%87%E4%BB%B6_5.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final void query() {
    // CGLIB$CALLBACK_0 对应 TestMethodInterceptor 类
    MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
    if (var10000 == null) {
        CGLIB$BIND_CALLBACKS(this);
        var10000 = this.CGLIB$CALLBACK_0;
    }
    if (var10000 != null) {
        // 调用 TestMethodInterceptor 的 intercept 方法
        var10000.intercept(this, CGLIB$query$0$Method, CGLIB$emptyArgs, CGLIB$query$0$Proxy);
    } else {
        super.query();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JDK 动态代理是实现一个接口，CGLIB 动态代理是继承父类。&lt;/p&gt;
&lt;h1 id=&#34;如何判断是不是第一次调用&#34;&gt;如何判断是不是第一次调用&lt;/h1&gt;
&lt;p&gt;第一次调用 indexDao() 方法时 new IndexDaoImpl ，之后再次调用 indexDao() ，则直接从容器中拿出来，factory.getBean() ，如此保持了 IndexDaoImpl 对象的单例。&lt;/p&gt;
&lt;p&gt;当 Spring 容器解析到 @Bean 时，就会调用 indexDao()，产生一个 Bean，把它放到 Spring 的 singleObjects 中，得到对象。&lt;/p&gt;
&lt;h2 id=&#34;intercept&#34;&gt;intercept&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,
         MethodProxy cglibMethodProxy) throws Throwable {
   // enhancedConfigInstance 代理对象
   // 通过 enhancedConfigInstance 中 cglib 生成的成员变量 $$beanFactory 获得 beanFactory
   ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance);
   String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod);
   // Determine whether this bean is a scoped-proxy
   Scope scope = AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class);
   if (scope != null &amp;amp;&amp;amp; scope.proxyMode() != ScopedProxyMode.NO) {
      String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName);
      if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {
         beanName = scopedBeanName;
      }
   }
   // To handle the case of an inter-bean method reference, we must explicitly check the
   // container for already cached instances.
   // First, check to see if the requested bean is a FactoryBean. If so, create a subclass
   // proxy that intercepts calls to getObject() and returns any cached bean instance.
   // This ensures that the semantics of calling a FactoryBean from within @Bean methods
   // is the same as that of referring to a FactoryBean within XML. See SPR-6602.
   if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &amp;amp;&amp;amp;
         factoryContainsBean(beanFactory, beanName)) {
      // 如何判断这个 Bean 是不是 FactoryBean？
      // 从 BeanFactory 中拿 &amp;quot;&amp;amp;beanName&amp;quot;，如果能够拿到，证明这就是一个 FactoryBean
      Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName);
      if (factoryBean instanceof ScopedProxyFactoryBean) {
         // Scoped proxy factory beans are a special case and should not be further proxied
      }
      else {
         // It is a candidate FactoryBean - go ahead with enhancement
         return enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName);
      }
   }
   // 判断是不是第一次调用，如果是第一次就 new；否则 factory,getBean()
   // 判断执行的方法和调用方法是不是同一个方法
   if (isCurrentlyInvokedFactoryMethod(beanMethod)) {
      // The factory is calling the bean method in order to instantiate and register the bean
      // (i.e. via a getBean() call) -&amp;gt; invoke the super implementation of the method to actually
      // create the bean instance.
      if (logger.isWarnEnabled() &amp;amp;&amp;amp;
            BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {
         logger.warn(String.format(&amp;quot;@Bean method %s.%s is non-static and returns an object &amp;quot; +
                     &amp;quot;assignable to Spring&#39;s BeanFactoryPostProcessor interface. This will &amp;quot; +
                     &amp;quot;result in a failure to process annotations such as @Autowired, &amp;quot; +
                     &amp;quot;@Resource and @PostConstruct within the method&#39;s declaring &amp;quot; +
                     &amp;quot;@Configuration class. Add the &#39;static&#39; modifier to this method to avoid &amp;quot; +
                     &amp;quot;these container lifecycle issues; see @Bean javadoc for complete details.&amp;quot;,
               beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()));
      }
      return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);
   }
   return resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;beanMethod 是当前调用的方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void query(){
  //...具体操作
}
// query2()是调用方法，query()是执行方法
public void query2(){
  // 判断当前调用方法 query2 与执行方法 query 是否相同，如果相同，证明是第一次调用，就执行 new；如果不同，证明不是第一次调用，就执行 factory.getBean()。
  query();
  //...具体操作
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestMethodCallabck implements MethodInterceptor {
   /**
    *
    * @param o 代理对象
    * @param method 当前方法，目标对象的方法
    * @param objects 参数
    * @param methodProxy 代理对象的方法
    * @return
    * @throws Throwable
    */
    // 当一个方法调用时，method 与 methodProxy 相同。当在 query2()内调用 query() 时，method=query() 与 methodProxy=query2() 不同。
   @Override
   public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
      System.out.println(&amp;quot;method...&amp;quot;);
      return methodProxy.invokeSuper(o,objects);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private boolean isCurrentlyInvokedFactoryMethod(Method method) {
   //  得到代理方法（调用方法），如果调用方法名与执行方法名相同，即method.getName().equals(currentlyInvoked.getName())，就认为是第一次调用
   Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod();
   return (currentlyInvoked != null &amp;amp;&amp;amp; method.getName().equals(currentlyInvoked.getName()) &amp;amp;&amp;amp;
         Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;第一次调用时，需要 new，直接调用父类方法，父类方法内含有 new，让父类去 new，上述 intercept 方法第 55 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8indexDao2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;首先扫描 @Bean，调用 indexDao2() 方法，&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8indexDao.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;调用 indexDao2() 方法内部的 indexDao() 方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%B0%83%E7%94%A8indexDao.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
扫描下一个 @Bean，调用 indexDao() 方法&lt;/p&gt;
&lt;p&gt;intercept 方法的第 58 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Object resolveBeanReference(Method beanMethod, Object[] beanMethodArgs,
      ConfigurableBeanFactory beanFactory, String beanName) {
   // The user (i.e. not the factory) is requesting this bean through a call to
   // the bean method, direct or indirect. The bean may have already been marked
   // as &#39;in creation&#39; in certain autowiring scenarios; if so, temporarily set
   // the in-creation status to false in order to avoid an exception.
   // 判断它是否正在创建
   boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName);
   try {
      if (alreadyInCreation) {
         beanFactory.setCurrentlyInCreation(beanName, false);
      }
      boolean useArgs = !ObjectUtils.isEmpty(beanMethodArgs);
      if (useArgs &amp;amp;&amp;amp; beanFactory.isSingleton(beanName)) {
         // Stubbed null arguments just for reference purposes,
         // expecting them to be autowired for regular singleton references?
         // A safe assumption since @Bean singleton arguments cannot be optional...
         for (Object arg : beanMethodArgs) {
            if (arg == null) {
               useArgs = false;
               break;
            }
         }
      }
      Object beanInstance = (useArgs ? beanFactory.getBean(beanName, beanMethodArgs) :
            beanFactory.getBean(beanName));
      if (!ClassUtils.isAssignableValue(beanMethod.getReturnType(), beanInstance)) {
         // Detect package-protected NullBean instance through equals(null) check
         if (beanInstance.equals(null)) {
            if (logger.isDebugEnabled()) {
               logger.debug(String.format(&amp;quot;@Bean method %s.%s called as bean reference &amp;quot; +
                     &amp;quot;for type [%s] returned null bean; resolving to null value.&amp;quot;,
                     beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(),
                     beanMethod.getReturnType().getName()));
            }
            beanInstance = null;
         }
         else {
            String msg = String.format(&amp;quot;@Bean method %s.%s called as bean reference &amp;quot; +
                  &amp;quot;for type [%s] but overridden by non-compatible bean instance of type [%s].&amp;quot;,
                  beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(),
                  beanMethod.getReturnType().getName(), beanInstance.getClass().getName());
            try {
               BeanDefinition beanDefinition = beanFactory.getMergedBeanDefinition(beanName);
               msg += &amp;quot; Overriding bean of same name declared in: &amp;quot; + beanDefinition.getResourceDescription();
            }
            catch (NoSuchBeanDefinitionException ex) {
               // Ignore - simply no detailed message then.
            }
            throw new IllegalStateException(msg);
         }
      }
      Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod();
      if (currentlyInvoked != null) {
         String outerBeanName = BeanAnnotationHelper.determineBeanNameFor(currentlyInvoked);
         beanFactory.registerDependentBean(beanName, outerBeanName);
      }
      return beanInstance;
   }
   finally {
      if (alreadyInCreation) {
         beanFactory.setCurrentlyInCreation(beanName, true);
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个对象有三种状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;no 没有创建
&lt;ul&gt;
&lt;li&gt;去创建它&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ing 在创建中
&lt;ul&gt;
&lt;li&gt;标识正在创建&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ed 创建成功
&lt;ul&gt;
&lt;li&gt;直接拿出来&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Spring 的 getBean() 方法做了封装：没有就创建，有就直接拿。&lt;/p&gt;
&lt;h1 id=&#34;spring-当中-bean-的后置处理器&#34;&gt;Spring 当中 Bean 的后置处理器&lt;/h1&gt;
&lt;p&gt;Spring 当中的后置处理器是 Spring 提供的一个扩展点，程序员只要去实现 BeanPostProcessor 接口，就能插手 Bean 的实例化过程，怎么插手呢？在 Bean 被放到 Spring 这个 Bean 容器之前去插手，能够对 Bean 做一些改变。经典场景：① Bean 的生命周期回调：CommonAnnotationBeanPostProcessor、② AOP：@AspectJ&lt;/p&gt;
&lt;h1 id=&#34;beanfactorypostprocessor-的作用&#34;&gt;BeanFactoryPostProcessor 的作用&lt;/h1&gt;
&lt;p&gt;BeanFactoryPostProcessor 主要能够在 Spring 的 bean容器当中的任意一个类被实例化之前来回调里面的方法。经典应用场景：ConfigurationClassPostProcessor#postProcessBeanFactory，针对 @Configuration 配置类加上 CGLIB 代理&lt;/p&gt;
&lt;h1 id=&#34;beandefinitionregistrypostprocessor&#34;&gt;BeanDefinitionRegistryPostProcessor&lt;/h1&gt;
&lt;p&gt;是 BeanFactoryPostProcessor 的子类，在 BeanFactoryPostProcessor 之前执行。&lt;/p&gt;
&lt;p&gt;Spinrg 底层源码决定的，先遍历 BeanDefinitionRegistryPostProcessor：Spring 提供的 + 自定义的：context.addBeanFactoryPostProcessor()，先执行自定义的，后执行 Spring 提供的【参照源码：refresh(); ---&amp;gt; invokeBeanFactoryPostProcessors(beanFactory); ---&amp;gt; invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); ---&amp;gt; invokeBeanFactoryPostProcessors】，后遍历 BeanFactoryPostProcessor。&lt;/p&gt;
&lt;p&gt;应用场景：ConfigurationClassPostProcessor 扫描、解析。ConfigurationClassPostProcessor 实现了 BeanDefinitionRegistryPostProcessor 接口，这个类当中有一个回调方法，完成了 Spring 的核心功能：扫描类，包括3种import的扫描、@Bean的扫描、判断配置类是否是一个完整的配置类，解析、解析配置类、解析 XML。&lt;/p&gt;
&lt;h1 id=&#34;importselector&#34;&gt;ImportSelector&lt;/h1&gt;
&lt;p&gt;通过 selectImports 方法返回一个类名（全限定类名），把它变成 bd，动态添加 bd（这个 bd 是死的）。如果用 ImportSelector，实现了 selectImports 方法，返回全限定类名，Spring 会得到这些类名，然后通过这些类名得到一个 Class，然后把它变成一个 BeanDefinition，但是把 Class 变成 BeanDefinition 的过程是由 Spring 完成的，所以这个 BeanDefinition 是死的，这个 Class 是怎样的，这个 BeanDefinition 就是怎样的。&lt;/p&gt;
&lt;p&gt;ImportSelector 还可以动态扫描&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String[] selectImports(AnnotationMetadata importingClassMetadata){
  class A extends Spring扫描器{
    A 完成扫描，返回字符串xxxx，把字符串返回给 String[],也能注入成功
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;扫描谁都可以做，关键是扫描出来后，程序员不能把它变成 BeanDefinition，因为扫描出来的仅仅是一个 Class 或者是 Resource，怎样把它变成 BeanDefinition 呢？要么交给 Spring，让 Spring 把它变成 BeanDefinition；要么手动 new reader，然后通过一个 BeanDefinition &lt;br&gt;
的实现类的构造方法去 new。而 selectImports 方法只需要把它变成 Class，后续 Spring 会把它变成一个 BeanDefinition。一些应用直接扩展 ImportSlector，在里面扩展 Spring 扫描器，完成自己的扫描，经典场景 MyBatis：MyBatis 扩展 Spring 扫描器，扫描 Dao，但是扫描出来由Spring 把它变成 BeanDefinition。但是 MyBatis 用的不是 ImportSelector，因为 MyBatis 底层要做一些 BeanDefinition 的改变，ImportSelector 无法实现。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Import(MapperScannerRegistrar.class)
public @interface MapperScan {
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MapperScannerRegistrar implements ImportBeanDefinitionRegistrar, ResourceLoaderAware {
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// BeanDefinitionRegistry 注册器：在注册前可以改变 BeanDefinition，然后再注册到 Spring 容器中
public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
  AnnotationAttributes annoAttrs = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));
  ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);
  // this check is needed in Spring 3.1
  if (resourceLoader != null) {
    scanner.setResourceLoader(resourceLoader);
  }
  Class&amp;lt;? extends Annotation&amp;gt; annotationClass = annoAttrs.getClass(&amp;quot;annotationClass&amp;quot;);
  if (!Annotation.class.equals(annotationClass)) {
    scanner.setAnnotationClass(annotationClass);
  }
  Class&amp;lt;?&amp;gt; markerInterface = annoAttrs.getClass(&amp;quot;markerInterface&amp;quot;);
  if (!Class.class.equals(markerInterface)) {
    scanner.setMarkerInterface(markerInterface);
  }
  Class&amp;lt;? extends BeanNameGenerator&amp;gt; generatorClass = annoAttrs.getClass(&amp;quot;nameGenerator&amp;quot;);
  if (!BeanNameGenerator.class.equals(generatorClass)) {
    scanner.setBeanNameGenerator(BeanUtils.instantiateClass(generatorClass));
  }
  Class&amp;lt;? extends MapperFactoryBean&amp;gt; mapperFactoryBeanClass = annoAttrs.getClass(&amp;quot;factoryBean&amp;quot;);
  if (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) {
    scanner.setMapperFactoryBean(BeanUtils.instantiateClass(mapperFactoryBeanClass));
  }
  scanner.setSqlSessionTemplateBeanName(annoAttrs.getString(&amp;quot;sqlSessionTemplateRef&amp;quot;));
  scanner.setSqlSessionFactoryBeanName(annoAttrs.getString(&amp;quot;sqlSessionFactoryRef&amp;quot;));
  List&amp;lt;String&amp;gt; basePackages = new ArrayList&amp;lt;String&amp;gt;();
  for (String pkg : annoAttrs.getStringArray(&amp;quot;value&amp;quot;)) {
    if (StringUtils.hasText(pkg)) {
      basePackages.add(pkg);
    }
  }
  for (String pkg : annoAttrs.getStringArray(&amp;quot;basePackages&amp;quot;)) {
    if (StringUtils.hasText(pkg)) {
      basePackages.add(pkg);
    }
  }
  for (Class&amp;lt;?&amp;gt; clazz : annoAttrs.getClassArray(&amp;quot;basePackageClasses&amp;quot;)) {
    basePackages.add(ClassUtils.getPackageName(clazz));
  }
  scanner.registerFilters();
  scanner.doScan(StringUtils.toStringArray(basePackages));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ClassPathMapperScanner extends ClassPathBeanDefinitionScanner {
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;importselector-与-importbeandefinitionregistrar-的区别&#34;&gt;ImportSelector 与  ImportBeanDefinitionRegistrar 的区别&lt;/h1&gt;
&lt;p&gt;ImportSelector 与 ImportBeanDefinitionRegistrar 的区别，实现的 ImportSelector，永远停留在 BeanDefinition 级别，Bean 的级别要到 BeanPostProcessor 那里去。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么时候用 ImportSelector，什么时候用 ImportBeanDefinitionRegistrar&lt;/strong&gt; ？&lt;/p&gt;
&lt;p&gt;看要不要动态改变这个 BeanDefinition，如果这个 BeanDefinition 不要动态改变，就用 ImportSelector；如果需要动态改变，就用 Registrar。&lt;/p&gt;
&lt;p&gt;ImportSelector 能拿到 AnnotationMetadata 注解，但是 Registrar 不一定能拿到。&lt;/p&gt;
&lt;p&gt;ImportSelector 能做的事情，Registrar 都能做，但是 Registrar 能动态改变 BeanDefinition，ImportSelector 做不了。&lt;/p&gt;
&lt;p&gt;ImportSelector 的 String[] selectImports(AnnotationMetadata importingClassMetadata); 返回字符串，Spring 帮忙注册。&lt;/p&gt;
&lt;p&gt;ImportBeanDefinitionRegistrar 的 registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry); 提供环境 registry，让程序员自己注册。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%80%BB%E7%BB%93.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">Spring系列（十一）Spring源码解析</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/spring-xi-lie-shi-spring-yuan-ma/"" data-c="
          &lt;h1 id=&#34;processconfigurationclass&#34;&gt;processConfigurationClass&lt;/h1&gt;
&lt;p&gt;context.&lt;em&gt;refresh&lt;/em&gt;(); ---&amp;gt; &lt;em&gt;invokeBeanFactoryPostProcessors&lt;/em&gt;(beanFactory); ---&amp;gt; PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); ---&amp;gt;invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); ---&amp;gt; postProcessor.&lt;em&gt;postProcessBeanDefinitionRegistry&lt;/em&gt;(registry); ---&amp;gt; &lt;em&gt;processConfigBeanDefinitions&lt;/em&gt;(registry);处理@Configuration ---&amp;gt; parser.parse(candidates); 解析注解对象---&amp;gt; parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName()); ---&amp;gt; processConfigurationClass(new ConfigurationClass(metadata, beanName)); 处理Import---&amp;gt; sourceClass = doProcessConfigurationClass(configClass, sourceClass); ---&amp;gt; this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()); ---&amp;gt; scanner.doScan(StringUtils.toStringArray(basePackages));扫描包&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
   // 判断是否应该跳过解析
   if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
      return;
   }
   // 处理 Imported 的情况
   // 就是当前这个类有没有被别的类 @Import
   ConfigurationClass existingClass = this.configurationClasses.get(configClass);
   if (existingClass != null) {
      if (configClass.isImported()) {
         if (existingClass.isImported()) {
            existingClass.mergeImportedBy(configClass);
         }
         // Otherwise ignore new imported config class; existing non-imported class overrides it.
         return;
      }
      else {
         // Explicit bean definition found, probably replacing an import.
         // Let&#39;s remove the old one and go with the new one.
         this.configurationClasses.remove(configClass);
         this.knownSuperclasses.values().removeIf(configClass::equals);
      }
   }
   // Recursively process the configuration class and its superclass hierarchy.
   SourceClass sourceClass = asSourceClass(configClass);
   do {
      sourceClass = doProcessConfigurationClass(configClass, sourceClass);
   }
   while (sourceClass != null);
   // 一个 map，用来存放扫描出来的 bean（注意这里的 bean 不是对象，仅仅是 bean 的信息，因为还没到实例化）
   this.configurationClasses.put(configClass, configClass);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;扫描普通类component并放到-map-中&#34;&gt;扫描普通类@Component，并放到 map 中&lt;/h2&gt;
&lt;h3 id=&#34;doprocessconfigurationclass&#34;&gt;doProcessConfigurationClass&lt;/h3&gt;
&lt;p&gt;上述代码第 29 行：解析注解类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)
      throws IOException {
   // Recursively process any member (nested) classes first
   // 处理内部类
   processMemberClasses(configClass, sourceClass);
   // Process any @PropertySource annotations
   for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
         sourceClass.getMetadata(), PropertySources.class,
         org.springframework.context.annotation.PropertySource.class)) {
      if (this.environment instanceof ConfigurableEnvironment) {
         processPropertySource(propertySource);
      }
      else {
         logger.warn(&amp;quot;Ignoring @PropertySource annotation on [&amp;quot; + sourceClass.getMetadata().getClassName() +
               &amp;quot;]. Reason: Environment must implement ConfigurableEnvironment&amp;quot;);
      }
   }
   // Process any @ComponentScan annotations
   Set&amp;lt;AnnotationAttributes&amp;gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(
         sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
   if (!componentScans.isEmpty() &amp;amp;&amp;amp;
         !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
      for (AnnotationAttributes componentScan : componentScans) {
         // The config class is annotated with @ComponentScan -&amp;gt; perform the scan immediately
         // 扫描普通类=componentScan=com.ssm
         // 这里扫描出来所有 @Component
         Set&amp;lt;BeanDefinitionHolder&amp;gt; scannedBeanDefinitions =
               this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
         // Check the set of scanned definitions for any further config classes and parse recursively if needed
         // 检查扫描出来的类当中是否还有 Configuration
         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
            BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
            if (bdCand == null) {
               bdCand = holder.getBeanDefinition();
            }
            if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
               parse(bdCand.getBeanClassName(), holder.getBeanName());
            }
         }
      }
   }
   /**
    * 上面的代码就是扫描普通类——@Component
    * 并且放到了map当中
    */
   // Process any @Import annotations
   // 处理 @Import：三种情况
   // ImportSelector、ImportBeanDefinitionRegistrar、普通类
   /**
    * 这里处理的 import 是需要判断我们的类当中是否有@Import注解： getImports(sourceClass)
    * 如果有 @Import 注解，就把这个值拿出来，是一个类
    * 比如 @Import(xxxx.class)，那么这里便把 xxxx 传进去进行解析
    * 在解析的过程中如果发觉是一个 importSelector 那么就回调 selector 的方法
    * 返回一个字符串（类名），通过这个字符串得到一个类
    * 继而在递归调用本方法来处理这个类
    *
    * 判断一组类是不是 imports(3种import)
    */
   processImports(configClass, sourceClass, getImports(sourceClass), true);
   // Process any @ImportResource annotations
   AnnotationAttributes importResource =
         AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
   if (importResource != null) {
      String[] resources = importResource.getStringArray(&amp;quot;locations&amp;quot;);
      Class&amp;lt;? extends BeanDefinitionReader&amp;gt; readerClass = importResource.getClass(&amp;quot;reader&amp;quot;);
      for (String resource : resources) {
         String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
         configClass.addImportedResource(resolvedResource, readerClass);
      }
   }
   // Process individual @Bean methods
   Set&amp;lt;MethodMetadata&amp;gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
   for (MethodMetadata methodMetadata : beanMethods) {
      configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
   }
   // Process default methods on interfaces
   processInterfaces(configClass, sourceClass);
   // Process superclass, if any
   if (sourceClass.getMetadata().hasSuperClass()) {
      String superclass = sourceClass.getMetadata().getSuperClassName();
      if (superclass != null &amp;amp;&amp;amp; !superclass.startsWith(&amp;quot;java&amp;quot;) &amp;amp;&amp;amp;
            !this.knownSuperclasses.containsKey(superclass)) {
         this.knownSuperclasses.put(superclass, configClass);
         // Superclass found, return its annotation metadata and recurse
         return sourceClass.getSuperClass();
      }
   }
   // No superclass -&amp;gt; processing is complete
   return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;普通类扫描后就完成了注册：上述代码第 26 行：&lt;br&gt;
上述代码第 31 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Set&amp;lt;BeanDefinitionHolder&amp;gt; parse(AnnotationAttributes componentScan, final String declaringClass) {
   ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,
         componentScan.getBoolean(&amp;quot;useDefaultFilters&amp;quot;), this.environment, this.resourceLoader);
   // BeanNameGenerator：Bean名字生成器
   Class&amp;lt;? extends BeanNameGenerator&amp;gt; generatorClass = componentScan.getClass(&amp;quot;nameGenerator&amp;quot;);
   boolean useInheritedGenerator = (BeanNameGenerator.class == generatorClass);
   scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator :
         BeanUtils.instantiateClass(generatorClass));
   ScopedProxyMode scopedProxyMode = componentScan.getEnum(&amp;quot;scopedProxy&amp;quot;);
   if (scopedProxyMode != ScopedProxyMode.DEFAULT) {
      scanner.setScopedProxyMode(scopedProxyMode);
   }
   else {
      Class&amp;lt;? extends ScopeMetadataResolver&amp;gt; resolverClass = componentScan.getClass(&amp;quot;scopeResolver&amp;quot;);
      scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));
   }
   scanner.setResourcePattern(componentScan.getString(&amp;quot;resourcePattern&amp;quot;));
   // 遍历当中的过滤
   for (AnnotationAttributes filter : componentScan.getAnnotationArray(&amp;quot;includeFilters&amp;quot;)) {
      for (TypeFilter typeFilter : typeFiltersFor(filter)) {
         scanner.addIncludeFilter(typeFilter);
      }
   }
   for (AnnotationAttributes filter : componentScan.getAnnotationArray(&amp;quot;excludeFilters&amp;quot;)) {
      for (TypeFilter typeFilter : typeFiltersFor(filter)) {
         scanner.addExcludeFilter(typeFilter);
      }
   }
   // 扫描出来的这个类是否需要懒加载：默认 false
   // xml 配置懒加载：&amp;lt;beans lazy=&amp;quot;true&amp;quot;&amp;gt;&amp;lt;bean&amp;gt;&amp;lt;/bean&amp;gt;&amp;lt;/beans&amp;gt;
   // JavaConfig配置懒加载：@Lazy   public class AppConfig{
   boolean lazyInit = componentScan.getBoolean(&amp;quot;lazyInit&amp;quot;);
   if (lazyInit) {
      scanner.getBeanDefinitionDefaults().setLazyInit(true);
   }
   Set&amp;lt;String&amp;gt; basePackages = new LinkedHashSet&amp;lt;&amp;gt;();
   String[] basePackagesArray = componentScan.getStringArray(&amp;quot;basePackages&amp;quot;);
   for (String pkg : basePackagesArray) {
      String[] tokenized = StringUtils.tokenizeToStringArray(this.environment.resolvePlaceholders(pkg),
            ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);
      Collections.addAll(basePackages, tokenized);
   }
   for (Class&amp;lt;?&amp;gt; clazz : componentScan.getClassArray(&amp;quot;basePackageClasses&amp;quot;)) {
      basePackages.add(ClassUtils.getPackageName(clazz));
   }
   if (basePackages.isEmpty()) {
      basePackages.add(ClassUtils.getPackageName(declaringClass));
   }
   scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {
      @Override
      protected boolean matchClassName(String className) {
         return declaringClass.equals(className);
      }
   });
   return scanner.doScan(StringUtils.toStringArray(basePackages));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 62 行，调用 doScan 方法完成扫描&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected Set&amp;lt;BeanDefinitionHolder&amp;gt; doScan(String... basePackages) {
   Assert.notEmpty(basePackages, &amp;quot;At least one base package must be specified&amp;quot;);
   Set&amp;lt;BeanDefinitionHolder&amp;gt; beanDefinitions = new LinkedHashSet&amp;lt;&amp;gt;();
   // 循环所有 basePackages，因为@ComponentScan({&amp;quot;com.ssm.dao&amp;quot;},{&amp;quot;com.ssm.service&amp;quot;})可以写多个
   for (String basePackage : basePackages) {
      // 扫表 basePackage 路径下的 java 文件
      // 并把它转成 BeanDefinition 类型
      Set&amp;lt;BeanDefinition&amp;gt; candidates = findCandidateComponents(basePackage);
      for (BeanDefinition candidate : candidates) {
         // 解析 scope 属性
         ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
         candidate.setScope(scopeMetadata.getScopeName());
         String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
         if (candidate instanceof AbstractBeanDefinition) {
            // 如果这个类是 AbstractBeanDefinition 的子类
            // 则为它设置默认值，比如 lazy，init destroy
            postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
         }
         if (candidate instanceof AnnotatedBeanDefinition) {
            // 检查并且处理常用的注解
            // 这里的处理主要是指把常用注解的值设置到 AnnotatedBeanDefinition 当中
            // 当前前提是这个类必须是 AnnotatedBeanDefinition 类型的，说白了就是加了注解的类
            AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
         }
         if (checkCandidate(beanName, candidate)) {
            BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
            definitionHolder =
                  AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
            beanDefinitions.add(definitionHolder);
            // 加入到 map 中
            registerBeanDefinition(definitionHolder, this.registry);
         }
      }
   }
   return beanDefinitions;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 8 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Set&amp;lt;BeanDefinition&amp;gt; candidates = findCandidateComponents(basePackage);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用 findCandidateComponents 方法完成扫描，并把扫描出来的类都转化成 BeanDefinition，&lt;br&gt;
第 31 行：把所有的 BeanDefinition 注册到 map 中。&lt;/p&gt;
&lt;p&gt;即：普通类扫描后就完成了注册。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Import(MyImportSelector.class)
@ComponentScan
public class AppConfig{
  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码完成了：扫描所有的 @ComponentScan，并把 BeanDefinition 放到 map 中。&lt;br&gt;
还没有开始处理 @Import。&lt;/p&gt;
&lt;h2 id=&#34;处理-import&#34;&gt;处理 @Import&lt;/h2&gt;
&lt;p&gt;什么时候处理 @Import呢？上述 processConfigurationClass 方法的第 64 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 这里处理的 import 是需要判断我们的类当中是否有@Import注解： getImports(sourceClass)
 * 如果有 @Import 注解，就把这个值拿出来，是一个类
 * 比如 @Import(xxxx.class)，那么这里便把 xxxx 传进去进行解析
 * 在解析的过程中如果发觉是一个 importSelector 那么就回调 selector 的方法
 * 返回一个字符串（类名），通过这个字符串得到一个类
 * 继而在递归调用本方法来处理这个类
 *
 * 判断一组类是不是 imports(3中import)
 */
processImports(configClass, sourceClass, getImports(sourceClass), true);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;示例代码&#34;&gt;示例代码&lt;/h3&gt;
&lt;p&gt;1、有一个配置类：&lt;/p&gt;
&lt;p&gt;① 扫描包 com.ssm；&lt;/p&gt;
&lt;p&gt;② @Import(MyImportSelector.class)；&lt;/p&gt;
&lt;p&gt;③ 通过 @Bean 注入 IndexDaoImpl2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@ComponentScan(&amp;quot;com.ssm&amp;quot;)
@Import(MyImportSelector.class)
public class AppConfig {
   @Bean
   public IndexDaoImpl2 indexDaoImpl2(){
      return new IndexDaoImpl2();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、有一个 IndexDaoImpl 通过 @Repository(&amp;quot;indexDao&amp;quot;) 注入到 Spring 容器中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Repository(&amp;quot;indexDao&amp;quot;)
public class IndexDaoImpl implements IndexDao{
   @Override
   public void query() {
      System.out.println(&amp;quot;dao...模拟查询数据库&amp;quot;);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、有一个 IndexDaoImpl2 在此类中并未添加 @Component，但是在 AppConfig 通过 @Bean 的方式 new IndexDaoImpl2 添加到 Spring 容器中了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class IndexDaoImpl2 implements IndexDao{
   @Override
   public void query() {
      System.out.println(&amp;quot;dao2...模拟查询数据库&amp;quot;);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、MyImportSelector implements ImportSelector，返回 “类的字符串”，即 IndexDaoImpl3.class.getName()&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyImportSelector implements ImportSelector {
   @Override
   public String[] selectImports(AnnotationMetadata importingClassMetadata) {
      return new String[]{IndexDaoImpl3.class.getName()};
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5、IndexDaoImpl3 implements BeanPostProcessor&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class IndexDaoImpl3 implements IndexDao, BeanPostProcessor {
   @Override
   public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
      if(beanName.equals(&amp;quot;indexDao&amp;quot;)){
         bean = Proxy.newProxyInstance(this.getClass().getClassLoader(), new Class[]{IndexDao.class},new MyInvocationHandler(bean));
      }
      return bean;
   }
   @Override
   public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
      return null;
   }
   @Override
   public void query() {
      System.out.println(&amp;quot;dao3...模拟查询数据库&amp;quot;);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6、MyInvocationHandler implements InvocationHandler&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyInvocationHandler implements InvocationHandler {
   Object target;
   public MyInvocationHandler(Object target){
      this.target = target;
   }
   @Override
   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
      System.out.println(&amp;quot;代理方法...&amp;quot;);
      return method.invoke(target,args);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7、测试类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      // 初始化 Spring 的环境
      context. refresh();
      IndexDao dao = (IndexDao) context.getBean(&amp;quot;indexDao&amp;quot;);
      dao.query();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;8、运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;代理方法...
dao...模拟查询数据库
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;processimports&#34;&gt;processImports&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,
      Collection&amp;lt;SourceClass&amp;gt; importCandidates, boolean checkForCircularImports) {
   // 如果没有加@Import，直接返回
   if (importCandidates.isEmpty()) {
      return;
   }
   if (checkForCircularImports &amp;amp;&amp;amp; isChainedImportOnStack(configClass)) {
      this.problemReporter.error(new CircularImportProblem(configClass, this.importStack));
   }
   else {
      this.importStack.push(configClass);
      try {
         for (SourceClass candidate : importCandidates) {
            // @Import(IndexDao.class)、@Import(ImportSelector)、@Import(ImportBeanDefinitionRegistrar)
            // 判断是不是 ImportSelector
            if (candidate.isAssignable(ImportSelector.class)) {
               // Candidate class is an ImportSelector -&amp;gt; delegate to it to determine imports
               Class&amp;lt;?&amp;gt; candidateClass = candidate.loadClass();
               // 反射实现一个对象
               ImportSelector selector = BeanUtils.instantiateClass(candidateClass, ImportSelector.class);
               ParserStrategyUtils.invokeAwareMethods(
                     selector, this.environment, this.resourceLoader, this.registry);
               if (this.deferredImportSelectors != null &amp;amp;&amp;amp; selector instanceof DeferredImportSelector) {
                  this.deferredImportSelectors.add(
                        new DeferredImportSelectorHolder(configClass, (DeferredImportSelector) selector));
               }
               else {
                  // 回调
                  String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
                  Collection&amp;lt;SourceClass&amp;gt; importSourceClasses = asSourceClasses(importClassNames);
                  // 递归，这里第二次调用 processImports
                  // 如果是一个普通类，会进 else
                  processImports(configClass, currentSourceClass, importSourceClasses, false);
               }
            }
            // 判断是不是 ImportBeanDefinitionRegistrar
            else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
               // Candidate class is an ImportBeanDefinitionRegistrar -&amp;gt;
               // delegate to it to register additional bean definitions
               Class&amp;lt;?&amp;gt; candidateClass = candidate.loadClass();
               ImportBeanDefinitionRegistrar registrar =
                     BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);
               ParserStrategyUtils.invokeAwareMethods(
                     registrar, this.environment, this.resourceLoader, this.registry);
               // 添加到一个 list 当中和 importSelector 不同
               configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
            }
            // 普通类：@Import(IndexDao.class)
            else {
               // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&amp;gt;
               // process it as an @Configuration class
               // 否则，加入到 importStack 后调用 processConfigurationClass 进行处理
               // processConfigurationClass 里面主要就是把类放到 configurationClasses
               // configurationClasses 是一个集合，会在后面拿出来解析成 bd 继而注册
               // 可以看到普通类在扫描出来的时候就被注册了
               // 如果是 importSelector，会先放到 configurationClasses 后面进行出来注册
               this.importStack.registerImport(
                     currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
               processConfigurationClass(candidate.asConfigClass(configClass));
            }
         }
      }
      catch (BeanDefinitionStoreException ex) {
         throw ex;
      }
      catch (Throwable ex) {
         throw new BeanDefinitionStoreException(
               &amp;quot;Failed to process import candidates for configuration class [&amp;quot; +
               configClass.getMetadata().getClassName() + &amp;quot;]&amp;quot;, ex);
      }
      finally {
         this.importStack.pop();
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/candidate.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上述代码第 15-20 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;for (SourceClass candidate : importCandidates) {
    // @Import(IndexDao.class)、@Import(ImportSelector)、@Import(ImportBeanDefinitionRegistrar)
    // 判断是不是 ImportSelector
    if (candidate.isAssignable(ImportSelector.class)) {
    // Candidate class is an ImportSelector -&amp;gt; delegate to it to determine imports
        Class&amp;lt;?&amp;gt; candidateClass = candidate.loadClass(
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解析到了 @Import(MyImportSelector.class)，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyImportSelector implements ImportSelector {
   @Override
   public String[] selectImports(AnnotationMetadata importingClassMetadata) {
      return new String[]{IndexDaoImpl3.class.getName()};
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解析到 @MyImportSelector 后，会返回一个 “类的字符串”，如上述代码第 4 行所示。&lt;br&gt;
这个 “类的字符串” 肯定会放到 map 中，但此时还没有放进去。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/candidateClass.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;普通类通过 doScan 方法被扫描出来，转化成 BeanDefinition，并被加入到 map 中：所以被 @Reposity 修饰的 IndexDaoImpl 此时已经在容器中了。&lt;/p&gt;
&lt;h3 id=&#34;何时将-importselector-返回的字符串放到-map-中&#34;&gt;何时将 @ImportSelector 返回的字符串放到 map 中&lt;/h3&gt;
&lt;p&gt;反射实现一个对象：Spring 要知道这个 ImportSelector  到底返回了哪些字符串（return new String[]{IndexDaoImpl3.class.getName()};），然后通过这个字符串反射得到类名。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyImportSelector implements ImportSelector {
   @Override
   public String[] selectImports(AnnotationMetadata importingClassMetadata) {
      return new String[]{IndexDaoImpl3.class.getName()};
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到 selectImports 方法返回的字符串数组：String[] strs = selectImports();&lt;br&gt;
for(String str: strs){&lt;/p&gt;
&lt;p&gt;// 通过反射得到类名&lt;/p&gt;
&lt;p&gt;class = Class.forName(str);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/importSourceClasses.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;递归调用-processimports&#34;&gt;递归调用 processImports&lt;/h2&gt;
&lt;p&gt;得到类名 IndexDaoImpl3，正常情况可能会想：将 IndexDaoImpl3 转化成 BeanDefinition，然后放到 map 中，但是，Spring 并不是这样做的，因为有可能这个 IndexDaoImpl3 里面也有一个 @Import，所以 Spring 进行递归处理。&lt;/p&gt;
&lt;p&gt;上述 processImports 方法的第 30-35 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 得到类名
String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
Collection&amp;lt;SourceClass&amp;gt; importSourceClasses = asSourceClasses(importClassNames);
// 递归，这里第二次调用 processImports
// 如果是一个普通类，会进 else
processImports(configClass, currentSourceClass, importSourceClasses, false);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;于是再次调用 processImports 方法：&lt;br&gt;
上述 processImports  方法第 18 行判断：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if (candidate.isAssignable(ImportSelector.class)) {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;IndexDaoImpl3 不是一个 ImportSelector&lt;br&gt;
上述 processImports  方法第 39 行判断：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;IndexDaoImpl3 不是一个 ImportBeanDefinitionRegistrar&lt;br&gt;
所以进入 processImports  方法的第 51 行 else 分支&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;else{
  this.importStack.registerImport(
      currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
processConfigurationClass(candidate.asConfigClass(configClass));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;外部调用&#34;&gt;外部调用&lt;/h3&gt;
&lt;p&gt;从外部调用时，doProcessConfigurationClass 方法的第 64 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;processImports(configClass, sourceClass, getImports(sourceClass), true);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/getImports.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;传递的第三个参数是获得 @Import(MyImportSelector.class) 的值：MyImportSelector。判断 AppConfig 中 @Import 的值到底是哪一种 Import，然后再来进行处理。&lt;/p&gt;
&lt;p&gt;再来看 processImports 方法的参数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,
      Collection&amp;lt;SourceClass&amp;gt; importCandidates, boolean checkForCircularImports) {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第三个参数 importCandidates 即 MyImportSelector&lt;/p&gt;
&lt;h3 id=&#34;内部调用&#34;&gt;内部调用&lt;/h3&gt;
&lt;p&gt;内部递归调用时，传递的第三个参数是当前类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;processImports(configClass, currentSourceClass, importSourceClasses, false);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内部调用判断当前类 IndexDaoImpl3 到底是哪一种 @Import。&lt;br&gt;
&lt;strong&gt;getImports(sourceClass) 是获取 @Import 注解内的值，而 processImports 仅仅判断传进来的类（第三个参数）是 三种Import 中的哪一种&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;processconfigurationclass-2&#34;&gt;processConfigurationClass&lt;/h2&gt;
&lt;p&gt;前面提到递归调用会进入 else 分支，调用 processConfigurationClass 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
   // 判断是否应该跳过解析
   if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
      return;
   }
   // 处理 Imported 的情况
   // 就是当前这个类有没有被别的类 @Import
   ConfigurationClass existingClass = this.configurationClasses.get(configClass);
   if (existingClass != null) {
      if (configClass.isImported()) {
         if (existingClass.isImported()) {
            existingClass.mergeImportedBy(configClass);
         }
         // Otherwise ignore new imported config class; existing non-imported class overrides it.
         return;
      }
      else {
         // Explicit bean definition found, probably replacing an import.
         // Let&#39;s remove the old one and go with the new one.
         this.configurationClasses.remove(configClass);
         this.knownSuperclasses.values().removeIf(configClass::equals);
      }
   }
   // Recursively process the configuration class and its superclass hierarchy.
   SourceClass sourceClass = asSourceClass(configClass);
   do {
      sourceClass = doProcessConfigurationClass(configClass, sourceClass);
   }
   while (sourceClass != null);
   // 一个 map，用来存放扫描出来的 bean（注意这里的 bean 不是对象，仅仅是 bean 的信息，因为还没到实例化）
   this.configurationClasses.put(configClass, configClass);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 34 行：将类放到 configurationClasses 变量中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private final Map&amp;lt;ConfigurationClass, ConfigurationClass&amp;gt; configurationClasses = new LinkedHashMap&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;spring-处理四种类&#34;&gt;Spring 处理四种类&lt;/h1&gt;
&lt;h2 id=&#34;普通类-component&#34;&gt;普通类 @Component&lt;/h2&gt;
&lt;p&gt;扫描完成后注册&lt;/p&gt;
&lt;h2 id=&#34;importselector&#34;&gt;importSelector&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;先放到 Map&amp;lt;ConfigurationClass, ConfigurationClass&amp;gt; configurationClasses = new LinkedHashMap&amp;lt;&amp;gt;(); 中，然后再注册&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;context.&lt;em&gt;refresh&lt;/em&gt;(); ---&amp;gt; &lt;em&gt;invokeBeanFactoryPostProcessors&lt;/em&gt;(beanFactory); ---&amp;gt; PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); ---&amp;gt;invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); ---&amp;gt; postProcessor.&lt;em&gt;postProcessBeanDefinitionRegistry&lt;/em&gt;(registry); ---&amp;gt; &lt;em&gt;processConfigBeanDefinitions&lt;/em&gt;(registry);处理@Configuration ---&amp;gt; parser.parse(candidates); 解析注解对象---&amp;gt; parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName()); ---&amp;gt; processConfigurationClass(new ConfigurationClass(metadata, beanName)); 处理Import&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
   // 判断是否应该跳过解析
   if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
      return;
   }
   // 处理 Imported 的情况
   // 就是当前这个类有没有被别的类 @Import
   ConfigurationClass existingClass = this.configurationClasses.get(configClass);
   if (existingClass != null) {
      if (configClass.isImported()) {
         if (existingClass.isImported()) {
            existingClass.mergeImportedBy(configClass);
         }
         // Otherwise ignore new imported config class; existing non-imported class overrides it.
         return;
      }
      else {
         // Explicit bean definition found, probably replacing an import.
         // Let&#39;s remove the old one and go with the new one.
         this.configurationClasses.remove(configClass);
         this.knownSuperclasses.values().removeIf(configClass::equals);
      }
   }
   // Recursively process the configuration class and its superclass hierarchy.
   SourceClass sourceClass = asSourceClass(configClass);
   do {
      sourceClass = doProcessConfigurationClass(configClass, sourceClass);
   }
   while (sourceClass != null);
   // 一个 map，用来存放扫描出来的 bean（注意这里的 bean 不是对象，仅仅是 bean 的信息，因为还没到实例化）
   this.configurationClasses.put(configClass, configClass);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/map%E4%B8%AD%E6%9C%898%E4%B8%AA.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;context. refresh(); ---&amp;gt; invokeBeanFactoryPostProcessors(beanFactory); ---&amp;gt; PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); ---&amp;gt; invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); ---&amp;gt; postProcessor.postProcessBeanDefinitionRegistry(registry); ---&amp;gt; processConfigBeanDefinitions(registry); ---&amp;gt; this.reader.loadBeanDefinitions(configClasses);&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
   //定义一个 list 存放 app 提供的 bd：项目当中提供了 @Component
   List&amp;lt;BeanDefinitionHolder&amp;gt; configCandidates = new ArrayList&amp;lt;&amp;gt;();
   // 获取容器中注册的所有 bd 名字
   // 7 个
   String[] candidateNames = registry.getBeanDefinitionNames();
   // 依次取出每个&amp;lt;beanName,beanDefinition&amp;gt;
   /**
    * full
    * lite
    */
   for (String beanName : candidateNames) {
      BeanDefinition beanDef = registry.getBeanDefinition(beanName);
      // 判断当前 bean 是否被处理过：使用 isFullConfigurationClass 来标识
      if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
            ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {
         // 如果 BeanDefinition 中的 configurationClass 属性为 full 或者 lite，则意味着已经处理过了，直接跳过
         // 这里需要结合下面的代码才能理解
         if (logger.isDebugEnabled()) {
            logger.debug(&amp;quot;Bean definition has already been processed as a configuration class: &amp;quot; + beanDef);
         }
      }
      // 判断这个 BeanDefinition 是否是 Configuration类，如果加了 Configuration 下面的这几个注解就不再判断了
      // 还有  add(Component.class.getName())
      //         candidateIndicators.add(ComponentScan.class.getName())
      //         candidateIndicators.add(Import.class.getName())
      //         candidateIndicators.add(ImportResource.class.getName())
      else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
         configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
      }
   }
   // Return immediately if no @Configuration classes were found
   if (configCandidates.isEmpty()) {
      return;
   }
   // 排序，根据 order，不重要
   // Sort by previously determined @Order value, if applicable
   configCandidates.sort((bd1, bd2) -&amp;gt; {
      int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
      int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
      return Integer.compare(i1, i2);
   });
   // Detect any custom bean name generation strategy supplied through the enclosing application context
   SingletonBeanRegistry sbr = null;
   // 如果 BeanDefinitionRegistry 是 SingletonBeanRegistry 子类的话
   // 由于会将 registry 强转为 SingletonBeanRegistry
   if (registry instanceof SingletonBeanRegistry) {
      sbr = (SingletonBeanRegistry) registry;
      if (!this.localBeanNameGeneratorSet) {//是否有自定义的
         BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);
         // SingletonBeanRegistry 中有 id 为 org.springframework.context.annotation.internalConfigurationBeanNameGenerator
         // 如果有则利用它的，否则则使用 Spring 默认的
         if (generator != null) {
            this.componentScanBeanNameGenerator = generator;
            this.importBeanNameGenerator = generator;
         }
      }
   }
   if (this.environment == null) {
      this.environment = new StandardEnvironment();
   }
   // Parse each @Configuration class
   // 实例化 ConfigurationClassParser 为了解析各个配置类
   ConfigurationClassParser parser = new ConfigurationClassParser(
         this.metadataReaderFactory, this.problemReporter, this.environment,
         this.resourceLoader, this.componentScanBeanNameGenerator, registry);
   // 实例化 2 个 set，candidates 用于将之前加入的 configCandidates 进行去重
   // 因为可能有多个配置类重复了
   // alreadyParsed 用户判断是否处理过
   Set&amp;lt;BeanDefinitionHolder&amp;gt; candidates = new LinkedHashSet&amp;lt;&amp;gt;(configCandidates);
   Set&amp;lt;ConfigurationClass&amp;gt; alreadyParsed = new HashSet&amp;lt;&amp;gt;(configCandidates.size());
   do {
      parser.parse(candidates);
      parser.validate();
      Set&amp;lt;ConfigurationClass&amp;gt; configClasses = new LinkedHashSet&amp;lt;&amp;gt;(parser.getConfigurationClasses());
      configClasses.removeAll(alreadyParsed);
      // Read the model and create bean definitions based on its content
      if (this.reader == null) {
         this.reader = new ConfigurationClassBeanDefinitionReader(
               registry, this.sourceExtractor, this.resourceLoader, this.environment,
               this.importBeanNameGenerator, parser.getImportRegistry());
      }
      // 把扫描出来的 bean 对应的 beanDefinitions 添加到 factory 的 map 当中
      this.reader.loadBeanDefinitions(configClasses);
      alreadyParsed.addAll(configClasses);
      candidates.clear();
      if (registry.getBeanDefinitionCount() &amp;gt; candidateNames.length) {
         String[] newCandidateNames = registry.getBeanDefinitionNames();
         Set&amp;lt;String&amp;gt; oldCandidateNames = new HashSet&amp;lt;&amp;gt;(Arrays.asList(candidateNames));
         Set&amp;lt;String&amp;gt; alreadyParsedClasses = new HashSet&amp;lt;&amp;gt;();
         for (ConfigurationClass configurationClass : alreadyParsed) {
            alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
         }
         for (String candidateName : newCandidateNames) {
            if (!oldCandidateNames.contains(candidateName)) {
               BeanDefinition bd = registry.getBeanDefinition(candidateName);
               if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;amp;&amp;amp;
                     !alreadyParsedClasses.contains(bd.getBeanClassName())) {
                  candidates.add(new BeanDefinitionHolder(bd, candidateName));
               }
            }
         }
         candidateNames = newCandidateNames;
      }
   }
   while (!candidates.isEmpty());
   // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes
   if (sbr != null &amp;amp;&amp;amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {
      sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
   }
   if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {
      // Clear cache in externally provided MetadataReaderFactory; this is a no-op
      // for a shared cache since it&#39;ll be cleared by the ApplicationContext.
      ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 82 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Set&amp;lt;ConfigurationClass&amp;gt; configClasses = new LinkedHashSet&amp;lt;&amp;gt;(parser.getConfigurationClasses());
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public Set&amp;lt;ConfigurationClass&amp;gt; getConfigurationClasses() {
   return this.configurationClasses.keySet();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private final Map&amp;lt;ConfigurationClass, ConfigurationClass&amp;gt; configurationClasses = new LinkedHashMap&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/getConfigurationClasses.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;通过 parser.getConfigurationClasses() 方法，得到：普通类 @Component、 @Import 类、本身类 appConfig ，其中 普通类、本身类已经注册了，@Import 类还没有注册。&lt;/p&gt;
&lt;p&gt;如何知道哪些类还没有注册呢？&lt;/p&gt;
&lt;p&gt;上述代码第 92 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;this.reader.loadBeanDefinitions(configClasses);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%89%A7%E8%A1%8CloadBeanDefinitions%E5%89%8D.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void loadBeanDefinitions(Set&amp;lt;ConfigurationClass&amp;gt; configurationModel) {
   TrackedConditionEvaluator trackedConditionEvaluator = new TrackedConditionEvaluator();
   for (ConfigurationClass configClass : configurationModel) {
      loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void loadBeanDefinitionsForConfigurationClass(
      ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) {
   if (trackedConditionEvaluator.shouldSkip(configClass)) {
      String beanName = configClass.getBeanName();
      if (StringUtils.hasLength(beanName) &amp;amp;&amp;amp; this.registry.containsBeanDefinition(beanName)) {
         this.registry.removeBeanDefinition(beanName);
      }
      this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());
      return;
   }
   if (configClass.isImported()) {
      registerBeanDefinitionForImportedConfigurationClass(configClass);
   }
   for (BeanMethod beanMethod : configClass.getBeanMethods()) {
      loadBeanDefinitionsForBeanMethod(beanMethod);
   }
   loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());
   // 注册 Registrar
loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 22 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void loadBeanDefinitionsFromRegistrars(Map&amp;lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&amp;gt; registrars) {
   registrars.forEach((registrar, metadata) -&amp;gt;
         registrar.registerBeanDefinitions(metadata, this.registry));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果一个类是 Registrar，将它放到 importBeanDefinitionRegistrars 中，循环遍历 importBeanDefinitionRegistrars  注册。&lt;br&gt;
当执行完 this.reader.loadBeanDefinitions(configClasses);&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%89%A7%E8%A1%8CloadBeanDefinitions%E5%90%8E.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;IndexDaoImpl2 是通过 @Bean 注入到容器中的，IndexDaoImpl3 是通过 “将 @ImportSelector 返回的字符串放到 map 中” 注入到容器中的。&lt;/p&gt;
&lt;h2 id=&#34;registrar&#34;&gt;Registrar&lt;/h2&gt;
&lt;p&gt;先放到 importBeanDefinitionRegistrars 中，然后再 通过 loadBeanDefinitionsFromRegistrars 方法注册。&lt;/p&gt;
&lt;p&gt;processImports 方法的第 39-49 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
    // Candidate class is an ImportBeanDefinitionRegistrar -&amp;gt;
    // delegate to it to register additional bean definitions
    Class&amp;lt;?&amp;gt; candidateClass = candidate.loadClass();
    ImportBeanDefinitionRegistrar registrar = BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);
    ParserStrategyUtils.invokeAwareMethods(registrar, this.environment, this.resourceLoader, this.registry);
    // 添加到一个 list 当中和 importSelector 不同
    configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果有一个类是 ImportBeanDefinitionRegistrar，把这个类拿出来，把它实例化，放到 configClass 中。&lt;br&gt;
上述代码第 8 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void addImportBeanDefinitionRegistrar(ImportBeanDefinitionRegistrar registrar, AnnotationMetadata importingClassMetadata) {
   this.importBeanDefinitionRegistrars.put(registrar, importingClassMetadata);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private final Map&amp;lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&amp;gt; importBeanDefinitionRegistrars = new LinkedHashMap&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;import-普通类&#34;&gt;import 普通类&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;先放到 configurationClasses，注册时判断里面有没有，如果有就不注册了，因为扫描出来的已经有了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;processImports 方法第 51-62 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;else {
    // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&amp;gt;
    // process it as an @Configuration class
    // 否则，加入到 importStack 后调用 processConfigurationClass 进行处理
    // processConfigurationClass 里面主要就是把类放到 configurationClasses
    // configurationClasses 是一个集合，会在后面拿出来解析成 bd 继而注册
    // 可以看到普通类在扫描出来的时候就被注册了
    // 如果是 importSelector，会先放到 configurationClasses 后面进行出来注册
    this.importStack.registerImport(currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
               processConfigurationClass(candidate.asConfigClass(configClass));
}     
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 10 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
   // 判断是否应该跳过解析
   if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
      return;
   }
   // 处理 Imported 的情况
   // 就是当前这个类有没有被别的类 @Import
   ConfigurationClass existingClass = this.configurationClasses.get(configClass);
   if (existingClass != null) {
      if (configClass.isImported()) {
         if (existingClass.isImported()) {
            existingClass.mergeImportedBy(configClass);
         }
         // Otherwise ignore new imported config class; existing non-imported class overrides it.
         return;
      }
      else {
         // Explicit bean definition found, probably replacing an import.
         // Let&#39;s remove the old one and go with the new one.
         this.configurationClasses.remove(configClass);
         this.knownSuperclasses.values().removeIf(configClass::equals);
      }
   }
   // Recursively process the configuration class and its superclass hierarchy.
   SourceClass sourceClass = asSourceClass(configClass);
   do {
      sourceClass = doProcessConfigurationClass(configClass, sourceClass);
   }
   while (sourceClass != null);
   // 一个 map，用来存放扫描出来的 bean（注意这里的 bean 不是对象，仅仅是 bean 的信息，因为还没到实例化）
   this.configurationClasses.put(configClass, configClass);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此为止，执行完了 自定义的 BeanDefinitionRegistryPostProcessor + Spring 内部的 BeanDefinitionRegistryPostProcessor 所有的 postProcessBeanDefinitionRegistry 方法。&lt;br&gt;
context. refresh(); ---&amp;gt; invokeBeanFactoryPostProcessors(beanFactory); ---&amp;gt; PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); 获取&lt;strong&gt;自定义的 beanFactoryPostProcessors+ Spring 内部自己实现了 BeanDefinitionRegistryPostProcessor 接口的对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;---&amp;gt; invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); &lt;strong&gt;执行所有 BeanDefinitionRegistryPostProcessor&lt;/strong&gt;---&amp;gt; postProcessor.postProcessBeanDefinitionRegistry(registry); ---&amp;gt; processConfigBeanDefinitions(registry); ---&amp;gt; parser.parse(candidates); 解析：把普通类放到 map 中；this.reader.loadBeanDefinitions(configClasses); 特殊类：处理所有的 @Import；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void invokeBeanFactoryPostProcessors(
      ConfigurableListableBeanFactory beanFactory, List&amp;lt;BeanFactoryPostProcessor&amp;gt; beanFactoryPostProcessors) {
   // Invoke BeanDefinitionRegistryPostProcessors first, if any.
   Set&amp;lt;String&amp;gt; processedBeans = new HashSet&amp;lt;&amp;gt;();
   if (beanFactory instanceof BeanDefinitionRegistry) {
      BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
      // 定义两个 list， BeanDefinitionRegistryPostProcessor 实现了 BeanFactoryPostProcessor 接口
      // 因为 bdrp 是子类，子类肯定扩展了父类中的功能。
      List&amp;lt;BeanFactoryPostProcessor&amp;gt; regularPostProcessors = new ArrayList&amp;lt;&amp;gt;();
      List&amp;lt;BeanDefinitionRegistryPostProcessor&amp;gt; registryProcessors = new ArrayList&amp;lt;&amp;gt;();
      // 自定义的 beanFactoryPostProcessors
      for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
         if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
            BeanDefinitionRegistryPostProcessor registryProcessor =
                  (BeanDefinitionRegistryPostProcessor) postProcessor;
            registryProcessor.postProcessBeanDefinitionRegistry(registry);
            registryProcessors.add(registryProcessor);
         }
         else {
            regularPostProcessors.add(postProcessor);
         }
      }
      // Do not initialize FactoryBeans here: We need to leave all regular beans
      // uninitialized to let the bean factory post-processors apply to them!
      // Separate between BeanDefinitionRegistryPostProcessors that implement
      // PriorityOrdered, Ordered, and the rest.
      // 这个 currentRegistryProcessors 放的是 Spring 内部自己实现了 BeanDefinitionRegistryPostProcessor 接口的对象
      List&amp;lt;BeanDefinitionRegistryPostProcessor&amp;gt; currentRegistryProcessors = new ArrayList&amp;lt;&amp;gt;();
      // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
      // BeanDefinitionRegistryPostProcessor 等于 BeanFactoryPostProcessor
      // getBeanNamesForType：根据 bean 的 Type 类型获取 bean 的名字
      String[] postProcessorNames =
            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
      // 这个地方可以得到一个 BeanFactoryPostProcessor，因为是 Spring 默认在最开始自己注册的
      // 为什么要在最开始注册这个呢？
      // 因为 Spring 的工厂需要注解去扫描等等功能
      // 而这些功能都是需要在 Spring 工厂初始化完成之前就执行
      // 要么在工厂最开始的时候，要么在工厂初始化之中，反正不能在之后
      // 因为如果在之后就没有意义，因为那个时候已经需要使用工厂了
      // 所以这里 Spring 在一开始就注册了一个 BeanFactoryPostProcessor，用来插手 springFactory 的实例化过程
      // 在这个地方断点可以知道这个类叫做 ConfigurationClassPostProcessor
      // ConfigurationClassPostProcessor 那么这个类能干嘛呢？可以参考源码
      // 下面对这个“插手 Spring 工厂实例化过程”的类重点解释
      for (String ppName : postProcessorNames) {
         if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
         }
      }
      // 排序不重要，况且 currentRegistryProcessor 这里也只有一个数据
      sortPostProcessors(currentRegistryProcessors, beanFactory);
      // 合并 List，不重要（为什么要合并，因为有自定义的Spring自己的）
      registryProcessors.addAll(currentRegistryProcessors);
      // 最重要。注意这里是方法调用
      // 执行所有 BeanDefinitionRegistryPostProcessor
      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
      // 执行完了所有的 BeanDefinitionRegistryPostProcessor
      // 这个 list 只是一个临时变量，故而要清除
      currentRegistryProcessors.clear();
      // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
      for (String ppName : postProcessorNames) {
         if (!processedBeans.contains(ppName) &amp;amp;&amp;amp; beanFactory.isTypeMatch(ppName, Ordered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
         }
      }
      sortPostProcessors(currentRegistryProcessors, beanFactory);
      registryProcessors.addAll(currentRegistryProcessors);
      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
      currentRegistryProcessors.clear();
      // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
      boolean reiterate = true;
      while (reiterate) {
         reiterate = false;
         postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
         for (String ppName : postProcessorNames) {
            if (!processedBeans.contains(ppName)) {
               currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
               processedBeans.add(ppName);
               reiterate = true;
            }
         }
         sortPostProcessors(currentRegistryProcessors, beanFactory);
         registryProcessors.addAll(currentRegistryProcessors);
         invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
         currentRegistryProcessors.clear();
      }
      // Now, invoke the postProcessBeanFactory callback of all processors handled so far.
      // 执行 BeanFactoryPostProcessor 的回调，前面不是吗？
      // 前面执行的 BeanFactoryPostProcessor 的子类 BeanDefinitionRegistryPostProcessor 的回调
      // 这里执行的是 BeanFactoryPostProcessor 的回调
      invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
      //
      invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
   }
   else {
      // Invoke factory processors registered with the context instance.
      invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
   }
   // Do not initialize FactoryBeans here: We need to leave all regular beans
   // uninitialized to let the bean factory post-processors apply to them!
   String[] postProcessorNames =
         beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);
   // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
   // Ordered, and the rest.
   List&amp;lt;BeanFactoryPostProcessor&amp;gt; priorityOrderedPostProcessors = new ArrayList&amp;lt;&amp;gt;();
   List&amp;lt;String&amp;gt; orderedPostProcessorNames = new ArrayList&amp;lt;&amp;gt;();
   List&amp;lt;String&amp;gt; nonOrderedPostProcessorNames = new ArrayList&amp;lt;&amp;gt;();
   for (String ppName : postProcessorNames) {
      if (processedBeans.contains(ppName)) {
         // skip - already processed in first phase above
      }
      else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
         priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
      }
      else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
         orderedPostProcessorNames.add(ppName);
      }
      else {
         nonOrderedPostProcessorNames.add(ppName);
      }
   }
   // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
   invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);
   // Next, invoke the BeanFactoryPostProcessors that implement Ordered.
   List&amp;lt;BeanFactoryPostProcessor&amp;gt; orderedPostProcessors = new ArrayList&amp;lt;&amp;gt;();
   for (String postProcessorName : orderedPostProcessorNames) {
      orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
   }
   sortPostProcessors(orderedPostProcessors, beanFactory);
   invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);
   // Finally, invoke all other BeanFactoryPostProcessors.
   List&amp;lt;BeanFactoryPostProcessor&amp;gt; nonOrderedPostProcessors = new ArrayList&amp;lt;&amp;gt;();
   for (String postProcessorName : nonOrderedPostProcessorNames) {
      nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
   }
   invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);
   // Clear cached merged bean definitions since the post-processors might have
   // modified the original metadata, e.g. replacing placeholders in values...
   beanFactory.clearMetadataCache();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述第 98-102 行代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Now, invoke the postProcessBeanFactory callback of all processors handled so far.
// 执行 BeanFactoryPostProcessor 的回调，前面不是吗？
// 前面执行的 BeanFactoryPostProcessor 的子类 BeanDefinitionRegistryPostProcessor 的回调
// 这里执行的是 BeanFactoryPostProcessor 的回调
invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行 BeanFactoryPostProcessor 的回调，前面不是吗？&lt;br&gt;
前面执行的 BeanFactoryPostProcessor 的子类 BeanDefinitionRegistryPostProcessor 的回调。这里执行的是 BeanFactoryPostProcessor 的回调。&lt;/p&gt;
&lt;p&gt;于是我们来看一下前面的代码验证一下，上述方法第 16 行，判断是不是 BeanDefinitionRegistryPostProcessor，如果是，就把它放到 registryProcessors 中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
   if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
      BeanDefinitionRegistryPostProcessor registryProcessor =
            (BeanDefinitionRegistryPostProcessor) postProcessor;
      registryProcessor.postProcessBeanDefinitionRegistry(registry);
      registryProcessors.add(registryProcessor);
   }
   else {
      regularPostProcessors.add(postProcessor);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来看 invokeBeanFactoryPostProcessors 方法：完成 BeanFactoryPostProcessor 的回调&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static void invokeBeanFactoryPostProcessors(
      Collection&amp;lt;? extends BeanFactoryPostProcessor&amp;gt; postProcessors, ConfigurableListableBeanFactory beanFactory) {
   for (BeanFactoryPostProcessor postProcessor : postProcessors) {
      postProcessor.postProcessBeanFactory(beanFactory);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;点进来这个方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
   int factoryId = System.identityHashCode(beanFactory);
   if (this.factoriesPostProcessed.contains(factoryId)) {
      throw new IllegalStateException(
            &amp;quot;postProcessBeanFactory already called on this post-processor against &amp;quot; + beanFactory);
   }
   this.factoriesPostProcessed.add(factoryId);
   if (!this.registriesPostProcessed.contains(factoryId)) {
      // BeanDefinitionRegistryPostProcessor hook apparently not supported...
      // Simply call processConfigurationClasses lazily at this point then.
      processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);
   }
   // 产生 cglib 代理
   // 为什么需要产生 cglib 代理
   enhanceConfigurationClasses(beanFactory);
   beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;full-与-lite&#34;&gt;FULL 与 LITE&lt;/h1&gt;
&lt;p&gt;上述代码第 16 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) {
   Map&amp;lt;String, AbstractBeanDefinition&amp;gt; configBeanDefs = new LinkedHashMap&amp;lt;&amp;gt;();
   for (String beanName : beanFactory.getBeanDefinitionNames()) {
      BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);
      // 判断是否是一个全注解类
      // 什么是全注解类？FULL 和 LITE
      if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) {
         if (!(beanDef instanceof AbstractBeanDefinition)) {
            throw new BeanDefinitionStoreException(&amp;quot;Cannot enhance @Configuration bean definition &#39;&amp;quot; +
                  beanName + &amp;quot;&#39; since it is not stored in an AbstractBeanDefinition subclass&amp;quot;);
         }
         else if (logger.isWarnEnabled() &amp;amp;&amp;amp; beanFactory.containsSingleton(beanName)) {
            logger.warn(&amp;quot;Cannot enhance @Configuration bean definition &#39;&amp;quot; + beanName +
                  &amp;quot;&#39; since its singleton instance has been created too early. The typical cause &amp;quot; +
                  &amp;quot;is a non-static @Bean method with a BeanDefinitionRegistryPostProcessor &amp;quot; +
                  &amp;quot;return type: Consider declaring such methods as &#39;static&#39;.&amp;quot;);
         }
         configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);
      }
   }
   if (configBeanDefs.isEmpty()) {
      // nothing to enhance -&amp;gt; return immediately
      return;
   }
   ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer();
   for (Map.Entry&amp;lt;String, AbstractBeanDefinition&amp;gt; entry : configBeanDefs.entrySet()) {
      AbstractBeanDefinition beanDef = entry.getValue();
      // If a @Configuration class gets proxied, always proxy the target class
      beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);
      try {
         // Set enhanced subclass of the user-specified bean class
         Class&amp;lt;?&amp;gt; configClass = beanDef.resolveBeanClass(this.beanClassLoader);
         if (configClass != null) {
            Class&amp;lt;?&amp;gt; enhancedClass = enhancer.enhance(configClass, this.beanClassLoader);
            if (configClass != enhancedClass) {
               if (logger.isDebugEnabled()) {
                  logger.debug(String.format(&amp;quot;Replacing bean definition &#39;%s&#39; existing class &#39;%s&#39; with &amp;quot; +
                        &amp;quot;enhanced class &#39;%s&#39;&amp;quot;, entry.getKey(), configClass.getName(), enhancedClass.getName()));
               }
               beanDef.setBeanClass(enhancedClass);
            }
         }
      }
      catch (Throwable ex) {
         throw new IllegalStateException(&amp;quot;Cannot load configuration class: &amp;quot; + beanDef.getBeanClassName(), ex);
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果没有添加 @Configuration 会直接在上述代码第 23 行 return;&lt;br&gt;
如果添加了 @Configuration 后，就不会在第 23 行 return;而是会继续向下走到第 26 行。&lt;/p&gt;
&lt;p&gt;加了 @Configuration 会进行 cglib 代理，如果不加 @Configuration  就不会进行 cglib 动态代理。&lt;/p&gt;
&lt;p&gt;为什么加了 @Configuration 能够向下走到第 26 行呢？&lt;/p&gt;
&lt;p&gt;上述代码第 5-8 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 判断是否是一个全注解类
// 什么是全注解类？FULL 和 LITE
if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) {
  if (!(beanDef instanceof AbstractBeanDefinition)) {  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在解析 AppConfig 时，如果 AppConfig 有 @Configuration 注解，就会给它设置一个属性 FULL；如果没有，就设置属性 LITE。&lt;br&gt;
&lt;strong&gt;FULL 与 LITE 只是 Spring 当中的一个标识，Spring 标识为 FULL，表示它是一个全配置类，Spring 在为它生成 Bean 时，会加上 cglib 代理。标志为 LITE，表示它是一个部分配置类&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%B7%BB%E5%8A%A0@Configuration%E6%B3%A8%E8%A7%A3.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%B8%8D%E6%B7%BB%E5%8A%A0@Configuration%E6%B3%A8%E8%A7%A3.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;为什么要给这个类加上-cglib-动态代理&#34;&gt;为什么要给这个类加上 cglib 动态代理&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class IndexDaoImpl2 implements IndexDao{
   @Override
   public void query() {
      System.out.println(&amp;quot;dao2...模拟查询数据库&amp;quot;);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class IndexDaoImpl implements IndexDao{
   public IndexDaoImpl(){
      System.out.println(&amp;quot;indexDao...constructor&amp;quot;);
   }
   @Override
   public void query() {
      System.out.println(&amp;quot;dao...模拟查询数据库&amp;quot;);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ComponentScan(&amp;quot;com.ssm&amp;quot;)
public class AppConfig {
   @Bean
   public IndexDao indexDao2(){
      return new IndexDaoImpl2();
   }
   @Bean
   public IndexDao indexDao(){
      return new IndexDaoImpl();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      // 初始化 Spring 的环境
      context. refresh();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;indexDao...constructor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析：当执行 indexDao() 时，new IndexDaoImpl()，调用 IndexDaoImpl 的构造方法，所以IndexDaoImpl 的构造方法执行一次。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ComponentScan(&amp;quot;com.ssm&amp;quot;)
public class AppConfig {
   @Bean
   public IndexDao indexDao2(){
      indexDao();
      return new IndexDaoImpl2();
   }
   @Bean
   public IndexDao indexDao(){
      return new IndexDaoImpl();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;indexDao...constructor
indexDao...constructor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析：当执行 indexDao() 时，new IndexDaoImpl()，调用 IndexDaoImpl 的构造方法。&lt;br&gt;
当执行 indexDao2 方法时，再次调用 indexDao(); 方法，所以IndexDaoImpl 的构造方法共执行了两次。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
public class AppConfig {
   @Bean
   public IndexDao indexDao2(){
      indexDao();
      return new IndexDaoImpl2();
   }
   @Bean
   public IndexDao indexDao(){
      return new IndexDaoImpl();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;indexDao...constructor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析：&lt;strong&gt;添加了 @Configuration 后，仅调用一次 IndexDao 的构造方法&lt;/strong&gt;。&lt;br&gt;
indexDao() 方法被改变了，即使在 indexDao2() 内再次调用 indexDao()，也不会执行方法内的代码 new IndexDaoImpl(); 了。&lt;/p&gt;
&lt;p&gt;如何改变一个方法 indexD()？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代理 AppConfig&lt;/strong&gt;，当调用 AppConfig 的 indexDao() 时，调用的是代理类 AppConfig 内部的 indexDao()，而不是普通类 AppConfig 内部的 indexDao()。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) {
   Map&amp;lt;String, AbstractBeanDefinition&amp;gt; configBeanDefs = new LinkedHashMap&amp;lt;&amp;gt;();
   for (String beanName : beanFactory.getBeanDefinitionNames()) {
      BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);
      // 判断是否是一个全注解类
      // 什么是全注解类？FULL 和 LITE
      if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) {
         if (!(beanDef instanceof AbstractBeanDefinition)) {
            throw new BeanDefinitionStoreException(&amp;quot;Cannot enhance @Configuration bean definition &#39;&amp;quot; +
                  beanName + &amp;quot;&#39; since it is not stored in an AbstractBeanDefinition subclass&amp;quot;);
         }
         else if (logger.isWarnEnabled() &amp;amp;&amp;amp; beanFactory.containsSingleton(beanName)) {
            logger.warn(&amp;quot;Cannot enhance @Configuration bean definition &#39;&amp;quot; + beanName +
                  &amp;quot;&#39; since its singleton instance has been created too early. The typical cause &amp;quot; +
                  &amp;quot;is a non-static @Bean method with a BeanDefinitionRegistryPostProcessor &amp;quot; +
                  &amp;quot;return type: Consider declaring such methods as &#39;static&#39;.&amp;quot;);
         }
         //  如果是一个全注解，添加到 configBeanDefs 中；如果不是全注解，则不会put，即 configBeanDefs 为空
         configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);
      }
   }
   // 如果不是全注解，configBeanDefs 为空，直接 return;
   if (configBeanDefs.isEmpty()) {
      // nothing to enhance -&amp;gt; return immediately
      return;
   }
   ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer();
   for (Map.Entry&amp;lt;String, AbstractBeanDefinition&amp;gt; entry : configBeanDefs.entrySet()) {
      AbstractBeanDefinition beanDef = entry.getValue();
      // If a @Configuration class gets proxied, always proxy the target class
      beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);
      try {
         // Set enhanced subclass of the user-specified bean class
         Class&amp;lt;?&amp;gt; configClass = beanDef.resolveBeanClass(this.beanClassLoader);
         if (configClass != null) {
            // 完成对全注解类的 cglib 代理
            Class&amp;lt;?&amp;gt; enhancedClass = enhancer.enhance(configClass, this.beanClassLoader);
            if (configClass != enhancedClass) {
               if (logger.isDebugEnabled()) {
                  logger.debug(String.format(&amp;quot;Replacing bean definition &#39;%s&#39; existing class &#39;%s&#39; with &amp;quot; +
                        &amp;quot;enhanced class &#39;%s&#39;&amp;quot;, entry.getKey(), configClass.getName(), enhancedClass.getName()));
               }
               beanDef.setBeanClass(enhancedClass);
            }
         }
      }
      catch (Throwable ex) {
         throw new IllegalStateException(&amp;quot;Cannot load configuration class: &amp;quot; + beanDef.getBeanClassName(), ex);
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 38 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Class&amp;lt;?&amp;gt; enhance(Class&amp;lt;?&amp;gt; configClass, @Nullable ClassLoader classLoader) {
   if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {
      if (logger.isDebugEnabled()) {
         logger.debug(String.format(&amp;quot;Ignoring request to enhance %s as it has &amp;quot; +
               &amp;quot;already been enhanced. This usually indicates that more than one &amp;quot; +
               &amp;quot;ConfigurationClassPostProcessor has been registered (e.g. via &amp;quot; +
               &amp;quot;&amp;lt;context:annotation-config&amp;gt;). This is harmless, but you may &amp;quot; +
               &amp;quot;want check your configuration and remove one CCPP if possible&amp;quot;,
               configClass.getName()));
      }
      return configClass;
   }
   // cglib 代理
   Class&amp;lt;?&amp;gt; enhancedClass = createClass(newEnhancer(configClass, classLoader));
   if (logger.isDebugEnabled()) {
      logger.debug(String.format(&amp;quot;Successfully enhanced %s; enhanced class name is: %s&amp;quot;,
            configClass.getName(), enhancedClass.getName()));
   }
   return enhancedClass;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建一个类，把这个类 enhancedClass  返回，因为此时还没有实例化对象，&lt;br&gt;
AppConfig - cglib的class - BeanDefinition - cglib的Bean&lt;/p&gt;
&lt;p&gt;如何返回一个 cglib 的 class？&lt;/p&gt;
&lt;p&gt;上述代码第 14 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Enhancer newEnhancer(Class&amp;lt;?&amp;gt; configSuperClass, @Nullable ClassLoader classLoader) {
   Enhancer enhancer = new Enhancer();
   // 增强父类，cglib 是基于继承来的
   // 把当前类 configSuperClass 作为 enhancer 的父类
   enhancer.setSuperclass(configSuperClass);
   // 增强接口，为什么要增强接口？
   // 便于判断，表示一个类已经被增强了
   enhancer.setInterfaces(new Class&amp;lt;?&amp;gt;[] {EnhancedConfiguration.class});
   enhancer.setUseFactory(false);
   enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
   // BeanFactoryAwareGeneratorStrategy 是一个生成策略
   // 主要为生成的 CGLIB 类中添加成员变量 $$beanFactory
   // 同时基于接口 EnhancedConfiguration 的父接口 BeanFactoryAware 中的 setBeanFactory 方法，
   // 设置此变量的值为当前 Context 中的 beanFactory，这样一来我们这个 cglib 代理的对象就有了 beanFactory
   // 有了 factory 就能获得对象，而不用去通过方法获得对象了，因为通过方法获得对象不能控制其过程
   // BeanFactory 的作用是在 this 调用时拦截该调用，并直接在 beanFactory 中获得目标 bean
   enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader));
   // 当调用 indexDao() 时进行拦截
   enhancer.setCallbackFilter(CALLBACK_FILTER);
   enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());
   return enhancer;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;EnhancedConfiguration 继承了 BeanFactoryAware&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface EnhancedConfiguration extends BeanFactoryAware {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;BeanFactoryAware 实现了 Aware，Aware 里面有一个 setBeanFactory 方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface BeanFactoryAware extends Aware {
   /**
    * Callback that supplies the owning factory to a bean instance.
    * &amp;lt;p&amp;gt;Invoked after the population of normal bean properties
    * but before an initialization callback such as
    * {@link InitializingBean#afterPropertiesSet()} or a custom init-method.
    * @param beanFactory owning BeanFactory (never {@code null}).
    * The bean can immediately call methods on the factory.
    * @throws BeansException in case of initialization errors
    * @see BeanInitializationException
    */
   void setBeanFactory(BeanFactory beanFactory) throws BeansException;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;让 CGLIB 产生的代理对象能够获得 BeanFactory。&lt;/p&gt;
&lt;h3 id=&#34;cglib-的代理对象为什么要得到-beanfactory&#34;&gt;CGLIB 的代理对象为什么要得到 BeanFactory？&lt;/h3&gt;
&lt;p&gt;AppConfig 在执行代理前直接使用它得到原始类，就会执行原始类中的原始方法，每调用一次 indexDao() 方法，就会 new IndexDaoImpl(); 违背了 Spring 中的单例原则，所以不能使用原始对象，就需要使用代理对象，当再次调用 indexDao() 方法时，执行代理对象内的 indexDao() 方法，不再 new  IndexDaoImpl()，而是直接返回已经存在的 IndexDaoImpl。&lt;/p&gt;
&lt;p&gt;![图片](https://epitomm.github.io/post-images/CGLIB的代理对象为什么要得到 BeanFactory.png)&lt;/p&gt;
&lt;p&gt;当第一次调用 indexDao() 时，new IndexDaoImpl()，放到容器中，当第二次调用时，不再 new，而是直接从容器中拿出来 &lt;strong&gt;factory.getBean()&lt;/strong&gt;，就需要在代理对象中有一个 BeanFactory，不然没办法 factory.getBean()。&lt;/p&gt;
&lt;h3 id=&#34;如何得到一个-beanfactory&#34;&gt;如何得到一个 BeanFactory？&lt;/h3&gt;
&lt;p&gt;实现 BeanFactoryAware 接口，后置处理器在实例化对象前，把它放进来。&lt;/p&gt;
&lt;p&gt;BeanFactoryAwareGeneratorStrategy：CGLIB 生成类的策略。&lt;/p&gt;
&lt;p&gt;默认策略：DefaultGeneratorStrategy，生成基本的。如果需要扩展，使用一个类 BeanFactoryAwareGeneratorStrategy：CGLIB  继承 DefaultGeneratorStrategy，在生成这个类的过程中，调用 declare_field 方法：声明一个属性 $$beanFactory。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected ClassGenerator transform(ClassGenerator cg) throws Exception {
   ClassEmitterTransformer transformer = new ClassEmitterTransformer() {
      @Override
      public void end_class() {
         declare_field(Constants.ACC_PUBLIC, BEAN_FACTORY_FIELD, Type.getType(BeanFactory.class), null);
         super.end_class();
      }
   };
   return new TransformingClassGenerator(cg, transformer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static final String BEAN_FACTORY_FIELD = &amp;quot;$$beanFactory&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      // 初始化 Spring 的环境
      context. refresh();
      /**
        * 对目标对象的所有方法进行拦截
        */
      Enhancer enhancer = new Enhancer();
      enhancer.setSuperclass(IndexDaoImpl.class);
      // 增强接口
      enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
      // 添加方法过滤器
      enhancer.setCallback(new TestMethodCallabck());
      IndexDaoImpl indexDao = (IndexDaoImpl) enhancer.create();
      indexDao.query();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestMethodCallabck implements MethodInterceptor {
   /**
    *
    * @param o 代理对象
    * @param method 当前方法，目标对象的方法
    * @param objects 参数
    * @param methodProxy 代理对象的方法
    * @return
    * @throws Throwable
    */
   @Override
   public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
      System.out.println(&amp;quot;method...&amp;quot;);
      return methodProxy.invokeSuper(o,objects);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;indexDao...constructor
indexDao...constructor
method...
dao...模拟查询数据库
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;newEnhancer 方法的第 19 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static final ConditionalCallbackFilter CALLBACK_FILTER = new ConditionalCallbackFilter(CALLBACKS);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static final Callback[] CALLBACKS = new Callback[] {
      new BeanMethodInterceptor(),
      new BeanFactoryAwareMethodInterceptor(),
      NoOp.INSTANCE
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;configuration&#34;&gt;@Configuration&lt;/h1&gt;
&lt;p&gt;让 AppConfig 产生一个 CGLIB 动态代理类，这个 CGLIB 代理类会去实现一个 BeanFactoryAware 接口，自动注入一个 BeanFactory，于是当再次调用 indexDao() 时，首先会判断是不是第一次，如果是，则 new IndexDaoImpl；如果不是，从 BeanFactory 中得到这个 Bean 并返回。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
public class AppConfig {
   @Bean
   public IndexDao indexDao2(){
      indexDao();
      return new IndexDaoImpl2();
   }
   @Bean
   public static IndexDao indexDao(){
      return new IndexDaoImpl();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即使添加了 @Configuration，如果 使用 static 修饰 indexDao()，也会创建两遍&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;indexDao...constructor
indexDao...constructor
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void loadBeanDefinitionsForConfigurationClass(
      ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) {
   if (trackedConditionEvaluator.shouldSkip(configClass)) {
      String beanName = configClass.getBeanName();
      if (StringUtils.hasLength(beanName) &amp;amp;&amp;amp; this.registry.containsBeanDefinition(beanName)) {
         this.registry.removeBeanDefinition(beanName);
      }
      this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());
      return;
   }
   // 如果一个类是被 import 的，会被 Spring 标注
   // 在这里完成注册
   if (configClass.isImported()) {
      registerBeanDefinitionForImportedConfigurationClass(configClass);
   }
   // BeanMethod：得到 AppConfig 中的所有包，
   for (BeanMethod beanMethod : configClass.getBeanMethods()) {
      loadBeanDefinitionsForBeanMethod(beanMethod);
   }
   // xml
   loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());
   // 注册 Registrar
   loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {
   ConfigurationClass configClass = beanMethod.getConfigurationClass();
   MethodMetadata metadata = beanMethod.getMetadata();
   String methodName = metadata.getMethodName();
   // Do we need to mark the bean as skipped by its condition?
   if (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {
      configClass.skippedBeanMethods.add(methodName);
      return;
   }
   if (configClass.skippedBeanMethods.contains(methodName)) {
      return;
   }
   AnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);
   Assert.state(bean != null, &amp;quot;No @Bean annotation attributes&amp;quot;);
   // Consider name and any aliases
   List&amp;lt;String&amp;gt; names = new ArrayList&amp;lt;&amp;gt;(Arrays.asList(bean.getStringArray(&amp;quot;name&amp;quot;)));
   String beanName = (!names.isEmpty() ? names.remove(0) : methodName);
   // Register aliases even when overridden
   for (String alias : names) {
      this.registry.registerAlias(beanName, alias);
   }
   // Has this effectively been overridden before (e.g. via XML)?
   if (isOverriddenByExistingDefinition(beanMethod, beanName)) {
      if (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) {
         throw new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(),
               beanName, &amp;quot;Bean name derived from @Bean method &#39;&amp;quot; + beanMethod.getMetadata().getMethodName() +
               &amp;quot;&#39; clashes with bean name for containing configuration class; please make those names unique!&amp;quot;);
      }
      return;
   }
   ConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass, metadata);
   beanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));
   if (metadata.isStatic()) {
      // static @Bean method
      beanDef.setBeanClassName(configClass.getMetadata().getClassName());
      beanDef.setFactoryMethodName(methodName);
   }
   else {
      // instance @Bean method
      beanDef.setFactoryBeanName(configClass.getBeanName());
      beanDef.setUniqueFactoryMethodName(methodName);
   }
   beanDef.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);
   beanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);
   AnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);
   Autowire autowire = bean.getEnum(&amp;quot;autowire&amp;quot;);
   if (autowire.isAutowire()) {
      beanDef.setAutowireMode(autowire.value());
   }
   String initMethodName = bean.getString(&amp;quot;initMethod&amp;quot;);
   if (StringUtils.hasText(initMethodName)) {
      beanDef.setInitMethodName(initMethodName);
   }
   String destroyMethodName = bean.getString(&amp;quot;destroyMethod&amp;quot;);
   beanDef.setDestroyMethodName(destroyMethodName);
   // Consider scoping
   ScopedProxyMode proxyMode = ScopedProxyMode.NO;
   AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(metadata, Scope.class);
   if (attributes != null) {
      beanDef.setScope(attributes.getString(&amp;quot;value&amp;quot;));
      proxyMode = attributes.getEnum(&amp;quot;proxyMode&amp;quot;);
      if (proxyMode == ScopedProxyMode.DEFAULT) {
         proxyMode = ScopedProxyMode.NO;
      }
   }
   // Replace the original bean definition with the target one, if necessary
   BeanDefinition beanDefToRegister = beanDef;
   if (proxyMode != ScopedProxyMode.NO) {
      BeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(
            new BeanDefinitionHolder(beanDef, beanName), this.registry,
            proxyMode == ScopedProxyMode.TARGET_CLASS);
      beanDefToRegister = new ConfigurationClassBeanDefinition(
            (RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);
   }
   if (logger.isDebugEnabled()) {
      logger.debug(String.format(&amp;quot;Registering bean definition for @Bean method %s.%s()&amp;quot;,
            configClass.getMetadata().getClassName(), beanName));
   }
   this.registry.registerBeanDefinition(beanName, beanDefToRegister);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 40 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if (metadata.isStatic()) {
   // static @Bean method
   // 如果是静态的，BeanDefinition 中放的是 Bean   beanDef.setBeanClassName(configClass.getMetadata().getClassName());
   beanDef.setFactoryMethodName(methodName);
}
else {
   // instance @Bean method
   // 如果不是静态的，BeanDefinition 中放的是 FactoryBean
   // FactoryBean 是怎样被创建出来的？
   // FactoryBean 有两个意义：本身是一个 Bean，
   // 如何 new 出来一个 FactoryBean 给它呢？
   // 通过 setUniqueFactoryMethodName
   beanDef.setFactoryBeanName(configClass.getBeanName());
   beanDef.setUniqueFactoryMethodName(methodName);
}
&lt;/code&gt;&lt;/pre&gt;
">Spring系列（十）Spring源码解析</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/spring-xi-lie-jiu-yuan-ma-jie-xi/"" data-c="
          &lt;h1 id=&#34;spring-bean-的生命周期&#34;&gt;Spring Bean 的生命周期&lt;/h1&gt;
&lt;h2 id=&#34;1得到用户自定义的-beandefinitionregistrypostprocessor&#34;&gt;1.得到用户自定义的 BeanDefinitionRegistryPostProcessor&lt;/h2&gt;
&lt;p&gt;具体流程：&lt;/p&gt;
&lt;p&gt;context.&lt;em&gt;refresh&lt;/em&gt;(); ---&amp;gt; invokeBeanFactoryPostProcessors(beanFactory); ---&amp;gt; 		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); ---&amp;gt; 其中 getBeanFactoryPostProcessors() 方法返回值是BeanFactoryPostProcessor ---&amp;gt; ConfigurationClassPostProcessor 实现了 BeanDefinitionRegistryPostProcessor，而 BeanDefinitionRegistryPostProcessor 继承了 BeanFactoryPostProcessor。&lt;/p&gt;
&lt;h2 id=&#34;2得到-spring-内置的-beandefinitionregistrypostprocessor&#34;&gt;2.得到 Spring 内置的 BeanDefinitionRegistryPostProcessor&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;目前 Spring 只内置了一个 &lt;em&gt;BeanDefinitionRegistryPostProcessor，也就是&lt;/em&gt;ConfigurationClassPostProcessor&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;具体流程：&lt;/p&gt;
&lt;p&gt;context.&lt;em&gt;refresh&lt;/em&gt;(); ---&amp;gt; &lt;em&gt;invokeBeanFactoryPostProcessors&lt;/em&gt;(beanFactory); ---&amp;gt; PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); ---&amp;gt; List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&amp;lt;&amp;gt;(); 这个 currentRegistryProcessors 中放的就是 Spring 内部自己实现了 BeanDefinitionRegistryPostProcessor 接口的对象&lt;/p&gt;
&lt;h2 id=&#34;3处理-beandefinitionregistrypostprocessor&#34;&gt;3.处理 BeanDefinitionRegistryPostProcessor&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static void invokeBeanDefinitionRegistryPostProcessors(
      Collection&amp;lt;? extends BeanDefinitionRegistryPostProcessor&amp;gt; postProcessors, BeanDefinitionRegistry registry) {
   // 遍历所有 &amp;quot;用户自定义+Spirng内置&amp;quot; 的 BeanDefinitionRegistryPostProcessor 
   for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
      // 调用 postProcessBeanDefinitionRegistry 方法处理每一个 postProcessor
      postProcessor.postProcessBeanDefinitionRegistry(registry);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体流程：&lt;br&gt;
context.&lt;em&gt;refresh&lt;/em&gt;(); ---&amp;gt; &lt;em&gt;invokeBeanFactoryPostProcessors&lt;/em&gt;(beanFactory); ---&amp;gt; PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); ---&amp;gt;invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); ---&amp;gt; postProcessor.&lt;em&gt;postProcessBeanDefinitionRegistry&lt;/em&gt;(registry); ---&amp;gt; &lt;em&gt;processConfigBeanDefinitions&lt;/em&gt;(registry);处理@Configuration ---&amp;gt; parser.parse(candidates); 解析注解对象---&amp;gt; parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName()); ---&amp;gt; processConfigurationClass(new ConfigurationClass(metadata, beanName)); 处理Import---&amp;gt; sourceClass = doProcessConfigurationClass(configClass, sourceClass); ---&amp;gt; this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()); ---&amp;gt; scanner.doScan(StringUtils.toStringArray(basePackages));扫描包&lt;/p&gt;
&lt;h1 id=&#34;spring-源码解析&#34;&gt;Spring 源码解析&lt;/h1&gt;
&lt;h2 id=&#34;配置类只扫描包没有添加-configuration注解&#34;&gt;配置类只扫描包，没有添加 @Configuration注解&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ComponentScan(&amp;quot;com.ssm&amp;quot;)
public class AppConfig {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Repository(&amp;quot;indexDao&amp;quot;)
public class IndexDaoImpl implements IndexDao{
   @Override
   public void query() {
      System.out.println(&amp;quot;dao...模拟查询数据库&amp;quot;);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
//    context.addBeanFactoryPostProcessor(new MyBeanFactoryProcessor());
      // 初始化 Spring 的环境
      context.refresh();
      IndexDao indexDao = context.getBean(IndexDaoImpl.class);
      indexDao.query();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dao...模拟查询数据库
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总结：即使没有添加 @Configuration 注解，也能正确完成对 AppConfig 类的扫描：扫描包 com.ssm。那么 @Configuration 到底有什么用呢？&lt;/p&gt;
&lt;h1 id=&#34;1processconfigbeandefinitions&#34;&gt;1.processConfigBeanDefinitions&lt;/h1&gt;
&lt;p&gt;context.&lt;em&gt;refresh&lt;/em&gt;(); ---&amp;gt; invokeBeanFactoryPostProcessors(beanFactory); ---&amp;gt; 		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); ---&amp;gt; invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); ---&amp;gt; postProcessor.postProcessBeanDefinitionRegistry(registry); ---&amp;gt; processConfigBeanDefinitions(registry);&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
   //定义一个 list 存放 app 提供的 bd：项目当中提供了 @Component
   List&amp;lt;BeanDefinitionHolder&amp;gt; configCandidates = new ArrayList&amp;lt;&amp;gt;();
   // 获取容器中注册的所有 bd 名字
   // 7 个
   String[] candidateNames = registry.getBeanDefinitionNames();
   // 依次取出每个&amp;lt;beanName,beanDefinition&amp;gt;
   /**
    * full
    * lite
    */
   for (String beanName : candidateNames) {
      BeanDefinition beanDef = registry.getBeanDefinition(beanName);
      // 判断当前 bean 是否被处理过：使用 isFullConfigurationClass 来标识
      if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
            ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {
         // 如果 BeanDefinition 中的 configurationClass 属性为 full 或者 lite，则意味着已经处理过了，直接跳过
         // 这里需要结合下面的代码才能理解
         if (logger.isDebugEnabled()) {
            logger.debug(&amp;quot;Bean definition has already been processed as a configuration class: &amp;quot; + beanDef);
         }
      }
      // 判断这个 BeanDefinition 是否是 Configuration类，如果加了 Configuration 下面的这几个注解就不再判断了
      // 还有  add(Component.class.getName())
      //         candidateIndicators.add(ComponentScan.class.getName())
      //         candidateIndicators.add(Import.class.getName())
      //         candidateIndicators.add(ImportResource.class.getName())
      else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
         configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
      }
   }
   // Return immediately if no @Configuration classes were found
   if (configCandidates.isEmpty()) {
      return;
   }
   // 排序，根据 order，不重要
   // Sort by previously determined @Order value, if applicable
   configCandidates.sort((bd1, bd2) -&amp;gt; {
      int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
      int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
      return Integer.compare(i1, i2);
   });
   // Detect any custom bean name generation strategy supplied through the enclosing application context
   SingletonBeanRegistry sbr = null;
   // 如果 BeanDefinitionRegistry 是 SingletonBeanRegistry 子类的话
   // 由于会将 registry 强转为 SingletonBeanRegistry
   if (registry instanceof SingletonBeanRegistry) {
      sbr = (SingletonBeanRegistry) registry;
      if (!this.localBeanNameGeneratorSet) {//是否有自定义的
         BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);
         // SingletonBeanRegistry 中有 id 为 org.springframework.context.annotation.internalConfigurationBeanNameGenerator
         // 如果有则利用它的，否则则使用 Spring 默认的
         if (generator != null) {
            this.componentScanBeanNameGenerator = generator;
            this.importBeanNameGenerator = generator;
         }
      }
   }
   if (this.environment == null) {
      this.environment = new StandardEnvironment();
   }
   // Parse each @Configuration class
   // 实例化 ConfigurationClassParser 为了解析各个配置类
   ConfigurationClassParser parser = new ConfigurationClassParser(
         this.metadataReaderFactory, this.problemReporter, this.environment,
         this.resourceLoader, this.componentScanBeanNameGenerator, registry);
   // 实例化 2 个 set，candidates 用于将之前加入的 configCandidates 进行去重
   // 因为可能有多个配置类重复了
   // alreadyParsed 用户判断是否处理过
   Set&amp;lt;BeanDefinitionHolder&amp;gt; candidates = new LinkedHashSet&amp;lt;&amp;gt;(configCandidates);
   Set&amp;lt;ConfigurationClass&amp;gt; alreadyParsed = new HashSet&amp;lt;&amp;gt;(configCandidates.size());
   do {
      parser.parse(candidates);
      parser.validate();
      Set&amp;lt;ConfigurationClass&amp;gt; configClasses = new LinkedHashSet&amp;lt;&amp;gt;(parser.getConfigurationClasses());
      configClasses.removeAll(alreadyParsed);
      // Read the model and create bean definitions based on its content
      if (this.reader == null) {
         this.reader = new ConfigurationClassBeanDefinitionReader(
               registry, this.sourceExtractor, this.resourceLoader, this.environment,
               this.importBeanNameGenerator, parser.getImportRegistry());
      }
      // 把扫描出来的 bean 对应的 beanDefinitions 添加到 factory 的 map 当中
      this.reader.loadBeanDefinitions(configClasses);
      alreadyParsed.addAll(configClasses);
      candidates.clear();
      if (registry.getBeanDefinitionCount() &amp;gt; candidateNames.length) {
         String[] newCandidateNames = registry.getBeanDefinitionNames();
         Set&amp;lt;String&amp;gt; oldCandidateNames = new HashSet&amp;lt;&amp;gt;(Arrays.asList(candidateNames));
         Set&amp;lt;String&amp;gt; alreadyParsedClasses = new HashSet&amp;lt;&amp;gt;();
         for (ConfigurationClass configurationClass : alreadyParsed) {
            alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
         }
         for (String candidateName : newCandidateNames) {
            if (!oldCandidateNames.contains(candidateName)) {
               BeanDefinition bd = registry.getBeanDefinition(candidateName);
               if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;amp;&amp;amp;
                     !alreadyParsedClasses.contains(bd.getBeanClassName())) {
                  candidates.add(new BeanDefinitionHolder(bd, candidateName));
               }
            }
         }
         candidateNames = newCandidateNames;
      }
   }
   while (!candidates.isEmpty());
   // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes
   if (sbr != null &amp;amp;&amp;amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {
      sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
   }
   if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {
      // Clear cache in externally provided MetadataReaderFactory; this is a no-op
      // for a shared cache since it&#39;ll be cleared by the ApplicationContext.
      ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 28 行判断这个 bd 是否加了 @Configuration 注解&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 判断这个 BeanDefinition 是否是 Configuration类，如果加了 Configuration 下面的这几个注解就不再判断了
// 还有  add(Component.class.getName())
//         candidateIndicators.add(ComponentScan.class.getName())
//         candidateIndicators.add(Import.class.getName())
//         candidateIndicators.add(ImportResource.class.getName())
else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
   configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们点进 ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) 这个方法&lt;/p&gt;
&lt;h2 id=&#34;11-checkconfigurationclasscandidate&#34;&gt;1.1 checkConfigurationClassCandidate&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public static boolean checkConfigurationClassCandidate(BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) {
      String className = beanDef.getBeanClassName();
      if (className == null || beanDef.getFactoryMethodName() != null) {
         return false;
      }
      AnnotationMetadata metadata;
      if (beanDef instanceof AnnotatedBeanDefinition &amp;amp;&amp;amp;
            className.equals(((AnnotatedBeanDefinition) beanDef).getMetadata().getClassName())) {
         // Can reuse the pre-parsed metadata from the given BeanDefinition...
         // 如果 BeanDefinition 是 AnnotatedBeanDefinition 的实例，并且 className 和 BeanDefinition 中的元数据的类名相同
         // 则直接从 BeanDefinition 获得元数据Metadata
         metadata = ((AnnotatedBeanDefinition) beanDef).getMetadata();
      }
      else if (beanDef instanceof AbstractBeanDefinition &amp;amp;&amp;amp; ((AbstractBeanDefinition) beanDef).hasBeanClass()) {
         // Check already loaded Class if present...
         // since we possibly can&#39;t even load the class file for this Class.
         // 如果 BeanDefinition 是 AbstractBeanDefinition 的实例，并且 beanDef 有 beanClass 属性存在
         // 则实例化 StandardAnnotationMetadata
         Class&amp;lt;?&amp;gt; beanClass = ((AbstractBeanDefinition) beanDef).getBeanClass();
         metadata = new StandardAnnotationMetadata(beanClass, true);
      }
      else {
         try {
            MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);
            metadata = metadataReader.getAnnotationMetadata();
         }
         catch (IOException ex) {
            if (logger.isDebugEnabled()) {
               logger.debug(&amp;quot;Could not find class file for introspecting configuration annotations: &amp;quot; + className, ex);
            }
            return false;
         }
      }
      // 判断当前这个 bd 中存在的类是不是加了 @Configuration 注解，但是如果加了 @Configuration，下面的这几个注解就不再判断，因为这是一个 if-else if 分支
      // 只有满足了 &amp;quot;没有加 @Configuration注解&amp;quot;，才会走 else 分支去判断是否添加了其他注解
      // 如果存在则 Spring 认为它是一个全注解 FULL 的类
      if (isFullConfigurationCandidate(metadata)) {
         // 如果存在 Configuration 注解，则为 BeanDefinition 设置 configurationClass 属性为 FULL
         beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);
      }
      // 判断是否加了以下注解，摘录 isLiteConfigurationCandidate 的源码
//    candidateIndicators.add(Component.class.getName());
//    candidateIndicators.add(ComponentScan.class.getName());
//    candidateIndicators.add(Import.class.getName());
//    candidateIndicators.add(ImportResource.class.getName());
//    如果不存在 @Configuration 注解，Spring 则认为是一个部分注解 LITE 类
      else if (isLiteConfigurationCandidate(metadata)) {
         beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
      }
      else {
         return false;
      }
      // It&#39;s a full or lite configuration candidate... Let&#39;s determine the order value, if any.
      Integer order = getOrder(metadata);
      if ( order != null) {
         beanDef.setAttribute(ORDER_ATTRIBUTE, order);
      }
      return true;
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;111-isfullconfigurationcandidate&#34;&gt;1.1.1 isFullConfigurationCandidate&lt;/h3&gt;
&lt;p&gt;上述代码第 39 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static boolean isFullConfigurationCandidate(AnnotationMetadata metadata) {
   return metadata.isAnnotated(Configuration.class.getName());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;112-isliteconfigurationcandidate&#34;&gt;1.1.2 isLiteConfigurationCandidate&lt;/h3&gt;
&lt;p&gt;上述代码第 49 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static boolean isLiteConfigurationCandidate(AnnotationMetadata metadata) {
   // Do not consider an interface or an annotation...
   if (metadata.isInterface()) {
      return false;
   }
   // Any of the typical annotations found?
   for (String indicator : candidateIndicators) {
      if (metadata.isAnnotated(indicator)) {
         return true;
      }
   }
   // Finally, let&#39;s look for @Bean methods...
   try {
      return metadata.hasAnnotatedMethods(Bean.class.getName());
   }
   catch (Throwable ex) {
      if (logger.isDebugEnabled()) {
         logger.debug(&amp;quot;Failed to introspect @Bean methods on class [&amp;quot; + metadata.getClassName() + &amp;quot;]: &amp;quot; + ex);
      }
      return false;
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述第 8 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static final Set&amp;lt;String&amp;gt; candidateIndicators = new HashSet&amp;lt;&amp;gt;(8);
static {
   candidateIndicators.add(Component.class.getName());
   candidateIndicators.add(ComponentScan.class.getName());
   candidateIndicators.add(Import.class.getName());
   candidateIndicators.add(ImportResource.class.getName());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述 checkConfigurationClassCandidate 方法的第 39-51 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;      // 判断当前这个 bd 中存在的类是不是加了 @Configuration 注解，但是如果加了 @Configuration，下面的这几个注解就不再判断，因为这是一个 if-else if 分支
      // 只有满足了 &amp;quot;没有加 @Configuration注解&amp;quot;，才会走 else 分支去判断是否添加了其他注解
      if (isFullConfigurationCandidate(metadata)) {
         // 如果存在 Configuration 注解，则为 BeanDefinition 设置 configurationClass 属性为 FULL
         beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);
      }
      // 判断是否加了以下注解，摘录 isLiteConfigurationCandidate 的源码
/nss/    candidateIndicators.add(Component.class.getName());
//    candidateIndicators.add(ComponentScan.class.getName());
//    candidateIndicators.add(Import.class.getName());
//    candidateIndicators.add(ImportResource.class.getName());
      else if (isLiteConfigurationCandidate(metadata)) {
         beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果一个类加了 @Configuration 注解，BeanDefinition 中的 attribute =  CONFIGURATION_CLASS_FULL；否则，BeanDefinition 中的 attribute =   CONFIGURATION_CLASS_LITE&lt;/p&gt;
&lt;h3 id=&#34;113-parse&#34;&gt;1.1.3 parse&lt;/h3&gt;
&lt;p&gt;上述 checkConfigurationClassCandidate 方法的第 79 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; parser.parse(candidates);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/parse%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AAappConfig%E9%9C%80%E8%A6%81%E6%9B%B4%E6%96%B0.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void parse(Set&amp;lt;BeanDefinitionHolder&amp;gt; configCandidates) {
   // deferred：延迟的
   this.deferredImportSelectors = new LinkedList&amp;lt;&amp;gt;();
   // 根据 BeanDefinition 的类型做不同的处理，一般都会调用 ConfigurationClassParse#parse 进行解析
   for (BeanDefinitionHolder holder : configCandidates) {
      BeanDefinition bd = holder.getBeanDefinition();
      try {
         // 判断这个 bd 是否被加了注解
         if (bd instanceof AnnotatedBeanDefinition) {
            // 解析注解对象，并且把解析出来的 bd 放到 map，但是这里的 bd 指的是普通的
            // 何为不普通的呢？比如 @Bean 和 beanFactoryPostProcessor 得到的 bean 不在
            // 但是是这里解析，只是不 put 而已
            parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
         }
         else if (bd instanceof AbstractBeanDefinition &amp;amp;&amp;amp; ((AbstractBeanDefinition) bd).hasBeanClass()) {
            parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
         }
         else {
            parse(bd.getBeanClassName(), holder.getBeanName());
         }
      }
      catch (BeanDefinitionStoreException ex) {
         throw ex;
      }
      catch (Throwable ex) {
         throw new BeanDefinitionStoreException(
               &amp;quot;Failed to parse configuration class [&amp;quot; + bd.getBeanClassName() + &amp;quot;]&amp;quot;, ex);
      }
   }
   processDeferredImportSelectors();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 13 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {
   processConfigurationClass(new ConfigurationClass(metadata, beanName));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 2 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
   // 判断是否应该跳过解析
   if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
      return;
   }
   // 处理 Imported 的情况
   // 就是当前这个类有没有被别的类 @Import
   ConfigurationClass existingClass = this.configurationClasses.get(configClass);
   if (existingClass != null) {
      if (configClass.isImported()) {
         if (existingClass.isImported()) {
            existingClass.mergeImportedBy(configClass);
         }
         // Otherwise ignore new imported config class; existing non-imported class overrides it.
         return;
      }
      else {
         // Explicit bean definition found, probably replacing an import.
         // Let&#39;s remove the old one and go with the new one.
         this.configurationClasses.remove(configClass);
         this.knownSuperclasses.values().removeIf(configClass::equals);
      }
   }
   // Recursively process the configuration class and its superclass hierarchy.
   // 将 AppConfig 这个类转化成 SourceClass 
   SourceClass sourceClass = asSourceClass(configClass);
   do {
      sourceClass = doProcessConfigurationClass(configClass, sourceClass);
   }
   while (sourceClass != null);
   // 一个 map，用来存放扫描出来的 bean（注意这里的 bean 不是对象，仅仅是 bean 的信息，因为还没到实例化）
   this.configurationClasses.put(configClass, configClass);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;1131-doprocessconfigurationclass&#34;&gt;1.1.3.1  doProcessConfigurationClass&lt;/h4&gt;
&lt;p&gt;上述代码第 30 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)
      throws IOException {
   // Recursively process any member (nested) classes first
   // 处理内部类
   processMemberClasses(configClass, sourceClass);
   // 处理 @PropertySource 注解
   for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
         sourceClass.getMetadata(), PropertySources.class,
         org.springframework.context.annotation.PropertySource.class)) {
      if (this.environment instanceof ConfigurableEnvironment) {
         processPropertySource(propertySource);
      }
      else {
         logger.warn(&amp;quot;Ignoring @PropertySource annotation on [&amp;quot; + sourceClass.getMetadata().getClassName() +
               &amp;quot;]. Reason: Environment must implement ConfigurableEnvironment&amp;quot;);
      }
   }
   // 处理 @ComponentScan 注解
   Set&amp;lt;AnnotationAttributes&amp;gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(
         sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
   if (!componentScans.isEmpty() &amp;amp;&amp;amp;
         !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
      for (AnnotationAttributes componentScan : componentScans) {
         // The config class is annotated with @ComponentScan -&amp;gt; perform the scan immediately
         // 扫描普通类 componentScan=com.ssm 
         // 这里扫描出来所有 @Component
         Set&amp;lt;BeanDefinitionHolder&amp;gt; scannedBeanDefinitions =
               this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
         // Check the set of scanned definitions for any further config classes and parse recursively if needed
         // 检查扫描出来的类当中是否还有 Configuration
         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
            BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
            if (bdCand == null) {
               bdCand = holder.getBeanDefinition();
            }
            if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
               parse(bdCand.getBeanClassName(), holder.getBeanName());
            }
         }
      }
   }
   // Process any @Import annotations
   // 处理 @Import
   processImports(configClass, sourceClass, getImports(sourceClass), true);
   // Process any @ImportResource annotations
   AnnotationAttributes importResource =
         AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
   if (importResource != null) {
      String[] resources = importResource.getStringArray(&amp;quot;locations&amp;quot;);
      Class&amp;lt;? extends BeanDefinitionReader&amp;gt; readerClass = importResource.getClass(&amp;quot;reader&amp;quot;);
      for (String resource : resources) {
         String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
         configClass.addImportedResource(resolvedResource, readerClass);
      }
   }
   // Process individual @Bean methods
   Set&amp;lt;MethodMetadata&amp;gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
   for (MethodMetadata methodMetadata : beanMethods) {
      configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
   }
   // Process default methods on interfaces
   processInterfaces(configClass, sourceClass);
   // Process superclass, if any
   if (sourceClass.getMetadata().hasSuperClass()) {
      String superclass = sourceClass.getMetadata().getSuperClassName();
      if (superclass != null &amp;amp;&amp;amp; !superclass.startsWith(&amp;quot;java&amp;quot;) &amp;amp;&amp;amp;
            !this.knownSuperclasses.containsKey(superclass)) {
         this.knownSuperclasses.put(superclass, configClass);
         // Superclass found, return its annotation metadata and recurse
         return sourceClass.getSuperClass();
      }
   }
   // No superclass -&amp;gt; processing is complete
   return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 30 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Set&amp;lt;BeanDefinitionHolder&amp;gt; parse(AnnotationAttributes componentScan, final String declaringClass) {
   ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,
         componentScan.getBoolean(&amp;quot;useDefaultFilters&amp;quot;), this.environment, this.resourceLoader);
   
   // BeanNameGenerator：Bean名字生成器
   Class&amp;lt;? extends BeanNameGenerator&amp;gt; generatorClass = componentScan.getClass(&amp;quot;nameGenerator&amp;quot;);
   boolean useInheritedGenerator = (BeanNameGenerator.class == generatorClass);
   scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator :
         BeanUtils.instantiateClass(generatorClass));
   ScopedProxyMode scopedProxyMode = componentScan.getEnum(&amp;quot;scopedProxy&amp;quot;);
   if (scopedProxyMode != ScopedProxyMode.DEFAULT) {
      scanner.setScopedProxyMode(scopedProxyMode);
   }
   else {
      Class&amp;lt;? extends ScopeMetadataResolver&amp;gt; resolverClass = componentScan.getClass(&amp;quot;scopeResolver&amp;quot;);
      scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));
   }
   scanner.setResourcePattern(componentScan.getString(&amp;quot;resourcePattern&amp;quot;));
   for (AnnotationAttributes filter : componentScan.getAnnotationArray(&amp;quot;includeFilters&amp;quot;)) {
      for (TypeFilter typeFilter : typeFiltersFor(filter)) {
         scanner.addIncludeFilter(typeFilter);
      }
   }
   for (AnnotationAttributes filter : componentScan.getAnnotationArray(&amp;quot;excludeFilters&amp;quot;)) {
      for (TypeFilter typeFilter : typeFiltersFor(filter)) {
         scanner.addExcludeFilter(typeFilter);
      }
   }
  
    // 扫描出来的这个类是否需要懒加载：默认 false
   // xml 配置懒加载：&amp;lt;beans lazy=&amp;quot;true&amp;quot;&amp;gt;&amp;lt;bean&amp;gt;&amp;lt;/bean&amp;gt;&amp;lt;/beans&amp;gt;
   // JavaConfig配置懒加载：@Lazy   public class AppConfig{
   boolean lazyInit = componentScan.getBoolean(&amp;quot;lazyInit&amp;quot;);
   if (lazyInit) {
      scanner.getBeanDefinitionDefaults().setLazyInit(true);
   }
   Set&amp;lt;String&amp;gt; basePackages = new LinkedHashSet&amp;lt;&amp;gt;();
   String[] basePackagesArray = componentScan.getStringArray(&amp;quot;basePackages&amp;quot;);
   for (String pkg : basePackagesArray) {
      String[] tokenized = StringUtils.tokenizeToStringArray(this.environment.resolvePlaceholders(pkg),
            ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);
      Collections.addAll(basePackages, tokenized);
   }
   for (Class&amp;lt;?&amp;gt; clazz : componentScan.getClassArray(&amp;quot;basePackageClasses&amp;quot;)) {
      basePackages.add(ClassUtils.getPackageName(clazz));
   }
   if (basePackages.isEmpty()) {
      basePackages.add(ClassUtils.getPackageName(declaringClass));
   }
   scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {
      @Override
      protected boolean matchClassName(String className) {
         return declaringClass.equals(className);
      }
   });
   return scanner.doScan(StringUtils.toStringArray(basePackages));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第  12 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,
         componentScan.getBoolean(&amp;quot;useDefaultFilters&amp;quot;), this.environment, this.resourceLoader);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里 new 了一个 ClassPathBeanDefinitionScanner 真正去扫描包的类。&lt;br&gt;
我们再来看一下构造方法中的 scanner：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public AnnotationConfigApplicationContext() {
   /**
    * 父类的构造方法 super()
    *创建一个读取注解的 Bean 定义读取器：reader 能读取被加了注解的类
    * 什么是 bean 定义？BeanDefinition
    */
   this.reader = new AnnotatedBeanDefinitionReader(this);
   // 定义扫描器
   // 可以用来扫描包，继而转换成 bd
   // 但是实际上我们扫描包工作不是 scanner 这个对象
   // 是 Spring 自己 new 的一个 ClasspathBeanDefinitionScanner
   // 这里的 scanner 仅仅是为了程序员能够在外部调用 AnnotationConfigApplicationContext 对象的 scan 方法用的。
   this.scanner = new ClassPathBeanDefinitionScanner(this);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的 scanner 仅仅是为了程序员能够在外部调用 AnnotationConfigApplicationContext 对象的 scan 方法用的，而不是真正的扫描包。&lt;br&gt;
上述 parse 方法的第 36-39 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 扫描出来的这个类是否需要懒加载：默认 false
// xml 配置懒加载：&amp;lt;beans lazy=&amp;quot;true&amp;quot;&amp;gt;&amp;lt;bean&amp;gt;&amp;lt;/bean&amp;gt;&amp;lt;/beans&amp;gt;
// JavaConfig配置懒加载：@Lazy   public class AppConfig{
boolean lazyInit = componentScan.getBoolean(&amp;quot;lazyInit&amp;quot;);   
if (lazyInit) {
  scanner.getBeanDefinitionDefaults().setLazyInit(true);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里设置懒加载时，将 isLazyInit 设置为 true，而不是将 BeanDefinition 内的 lazy 设置为 true，因为这个时候还没有 BeanDefinition。&lt;br&gt;
上述 parse 方法第 61 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;return scanner.doScan(StringUtils.toStringArray(basePackages));
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;doscan&#34;&gt;doScan&lt;/h4&gt;
&lt;p&gt;点进去 doScan 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected Set&amp;lt;BeanDefinitionHolder&amp;gt; doScan(String... basePackages) {
   Assert.notEmpty(basePackages, &amp;quot;At least one base package must be specified&amp;quot;);
   Set&amp;lt;BeanDefinitionHolder&amp;gt; beanDefinitions = new LinkedHashSet&amp;lt;&amp;gt;();
   // 循环所有 basePackages，因为@ComponentScan({&amp;quot;com.ssm.dao&amp;quot;},{&amp;quot;com.ssm.service&amp;quot;})可以写多个
   for (String basePackage : basePackages) {
      // 扫表 basePackage 路径下的 java 文件
      // 并把它转成 BeanDefinition 类型
      Set&amp;lt;BeanDefinition&amp;gt; candidates = findCandidateComponents(basePackage);
      for (BeanDefinition candidate : candidates) {
         // 解析 scope 属性
         ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
         candidate.setScope(scopeMetadata.getScopeName());
         String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
         if (candidate instanceof AbstractBeanDefinition) {
            // 如果这个类是 AbstractBeanDefinition 的子类
            // 则为它设置默认值，比如 lazy，init destroy
            postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
         }
         if (candidate instanceof AnnotatedBeanDefinition) {
            // 检查并且处理常用的注解
            // 这里的处理主要是指把常用注解的值设置到 AnnotatedBeanDefinition 当中
            // 当前前提是这个类必须是 AnnotatedBeanDefinition 类型的，说白了就是加了注解的类
            AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
         }
         if (checkCandidate(beanName, candidate)) {
            BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
            definitionHolder =
                  AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
            beanDefinitions.add(definitionHolder);
            registerBeanDefinition(definitionHolder, this.registry);
         }
      }
   }
   return beanDefinitions;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述第 8 行代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Set&amp;lt;BeanDefinition&amp;gt; findCandidateComponents(String basePackage) {
   if (this.componentsIndex != null &amp;amp;&amp;amp; indexSupportsIncludeFilters()) {
      return addCandidateComponentsFromIndex(this.componentsIndex, basePackage);
   }
   else {
      return scanCandidateComponents(basePackage);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述第 6 行，asm 读取 class 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Set&amp;lt;BeanDefinition&amp;gt; scanCandidateComponents(String basePackage) {
   Set&amp;lt;BeanDefinition&amp;gt; candidates = new LinkedHashSet&amp;lt;&amp;gt;();
   try {
      String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
            resolveBasePackage(basePackage) + &#39;/&#39; + this.resourcePattern;
      // asm 读取 class 文件
      Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);
      boolean traceEnabled = logger.isTraceEnabled();
      boolean debugEnabled = logger.isDebugEnabled();
      for (Resource resource : resources) {
         if (traceEnabled) {
            logger.trace(&amp;quot;Scanning &amp;quot; + resource);
         }
         if (resource.isReadable()) {
            try {
               MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);
               if (isCandidateComponent(metadataReader)) {
                  // 通过 Spring 扫描出来的 BeanDefinition 叫 ScannedGenericBeanDefinition 
                  ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
                  sbd.setSource(resource);
                  if (isCandidateComponent(sbd)) {
                     if (debugEnabled) {
                        logger.debug(&amp;quot;Identified candidate component class: &amp;quot; + resource);
                     }
                     candidates.add(sbd);
                  }
                  else {
                     if (debugEnabled) {
                        logger.debug(&amp;quot;Ignored because not a concrete top-level class: &amp;quot; + resource);
                     }
                  }
               }
               else {
                  if (traceEnabled) {
                     logger.trace(&amp;quot;Ignored because not matching any filter: &amp;quot; + resource);
                  }
               }
            }
            catch (Throwable ex) {
               throw new BeanDefinitionStoreException(
                     &amp;quot;Failed to read candidate component class: &amp;quot; + resource, ex);
            }
         }
         else {
            if (traceEnabled) {
               logger.trace(&amp;quot;Ignored because not readable: &amp;quot; + resource);
            }
         }
      }
   }
   catch (IOException ex) {
      throw new BeanDefinitionStoreException(&amp;quot;I/O failure during classpath scanning&amp;quot;, ex);
   }
   return candidates;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/asm%E6%89%AB%E6%8F%8F%E6%96%87%E4%BB%B6.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上述代码第 17 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException {
   // 当前这个类是否在 excludeFilters 当中
   for (TypeFilter tf : this.excludeFilters) {
      if (tf.match(metadataReader, getMetadataReaderFactory())) {
         // 如果当前类在排除条件中，返回 false
         return false;
      }
   }
   // 当前这个类是否在 includeFilters当中
   for (TypeFilter tf : this.includeFilters) {
      if (tf.match(metadataReader, getMetadataReaderFactory())) {
         return isConditionMatch(metadataReader);
      }
   }
   return false;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 19 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 通过 Spring 扫描出来的 BeanDefinition 叫 ScannedGenericBeanDefinition 
ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;来看一下这个类 ScannedGenericBeanDefinition：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ScannedGenericBeanDefinition extends GenericBeanDefinition implements AnnotatedBeanDefinition {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而 GenericBeanDefinition 类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class GenericBeanDefinition extends AbstractBeanDefinition {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以：所有扫描出来的类都 instanceof AbstractBeanDefinition &lt;br&gt;
上述代码第 21 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) {
   AnnotationMetadata metadata = beanDefinition.getMetadata();
   return (metadata.isIndependent() &amp;amp;&amp;amp; (metadata.isConcrete() ||
         (metadata.isAbstract() &amp;amp;&amp;amp; metadata.hasAnnotatedMethods(Lookup.class.getName()))));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/candidates.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;doScan 方法第 14-24 行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 所有扫描出来的类都 instanceof AbstractBeanDefinition 
if (candidate instanceof AbstractBeanDefinition) {
    // 如果这个类是 AbstractBeanDefinition 的子类
    // 则为它设置默认值，比如 lazy，init destroy
    postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
}
// 如果这个类是被加了注解的
if (candidate instanceof AnnotatedBeanDefinition) {
    // 检查并且处理常用的注解
    // 这里的处理主要是指把常用注解的值设置到 AnnotatedBeanDefinition 当中
    // 当前前提是这个类必须是 AnnotatedBeanDefinition 类型的，说白了就是加了注解的类
          AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于上面的分析，上述判断的第 1 行的 if 分支成立&lt;br&gt;
把一个类扫描出来后，需要填充 BeanDefinition，postProcessBeanDefinition 就是填充这个 BeanDefinition，为它设置默认值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void postProcessBeanDefinition(AbstractBeanDefinition beanDefinition, String beanName) {
   beanDefinition.applyDefaults(this.beanDefinitionDefaults);
   if (this.autowireCandidatePatterns != null) {
      beanDefinition.setAutowireCandidate(PatternMatchUtils.simpleMatch(this.autowireCandidatePatterns, beanName));
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 2 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 为 BeanDefinition 设置默认值
public void applyDefaults(BeanDefinitionDefaults defaults) {
   // 默认设置懒加载
   setLazyInit(defaults.isLazyInit());
   setAutowireMode(defaults.getAutowireMode());
   setDependencyCheck(defaults.getDependencyCheck());
   setInitMethodName(defaults.getInitMethodName());
   setEnforceInitMethod(false);
   setDestroyMethodName(defaults.getDestroyMethodName());
   setEnforceDestroyMethod(false);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述判断懒加载时，将 isLazyInit 设置为 true，而不是将 BeanDefinition 内的 lazy 设置为 true，因为那时候还没有 BeanDefinition。&lt;br&gt;
看一下第 12 行的判断：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;点进去这个 processCommonDefinitionAnnotations 方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd) {
   processCommonDefinitionAnnotations(abd, abd.getMetadata());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;点进去这个 processCommonDefinitionAnnotations 方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata) {
   AnnotationAttributes lazy = attributesFor(metadata, Lazy.class);
   if (lazy != null) {
      abd.setLazyInit(lazy.getBoolean(&amp;quot;value&amp;quot;));
   }
   else if (abd.getMetadata() != metadata) {
      lazy = attributesFor(abd.getMetadata(), Lazy.class);
      if (lazy != null) {
         abd.setLazyInit(lazy.getBoolean(&amp;quot;value&amp;quot;));
      }
   }
   if (metadata.isAnnotated(Primary.class.getName())) {
      abd.setPrimary(true);
   }
   AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);
   if (dependsOn != null) {
      abd.setDependsOn(dependsOn.getStringArray(&amp;quot;value&amp;quot;));
   }
   if (abd instanceof AbstractBeanDefinition) {
      AbstractBeanDefinition absBd = (AbstractBeanDefinition) abd;
      AnnotationAttributes role = attributesFor(metadata, Role.class);
      if (role != null) {
         absBd.setRole(role.getNumber(&amp;quot;value&amp;quot;).intValue());
      }
      AnnotationAttributes description = attributesFor(metadata, Description.class);
      if (description != null) {
         absBd.setDescription(description.getString(&amp;quot;value&amp;quot;));
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;doScan 方法的第 30 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 加入到 map 中
registerBeanDefinition(definitionHolder, this.registry);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;点进去 registerBeanDefinition：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) {
   BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在点进去 registerBeanDefinition：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void registerBeanDefinition(
      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
      throws BeanDefinitionStoreException {
   // Register bean definition under primary name.
   String beanName = definitionHolder.getBeanName();
   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
   // Register aliases for bean name, if any.
   String[] aliases = definitionHolder.getAliases();
   if (aliases != null) {
      for (String alias : aliases) {
         registry.registerAlias(beanName, alias);
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;doProcessConfigurationClass 代码的第 48 行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 处理 @Import
processImports(configClass, sourceClass,getImports(sourceClass), true);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;点进去这个 processImports 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,
      Collection&amp;lt;SourceClass&amp;gt; importCandidates, boolean checkForCircularImports) {
   // 如果没有加@Import，直接返回
   if (importCandidates.isEmpty()) {
      return;
   }
   if (checkForCircularImports &amp;amp;&amp;amp; isChainedImportOnStack(configClass)) {
      this.problemReporter.error(new CircularImportProblem(configClass, this.importStack));
   }
   else {
      this.importStack.push(configClass);
      try {
         for (SourceClass candidate : importCandidates) {
            // @Import(IndexDao.class)、@Import(ImportSelector)、@Import(ImportBeanDefinitionRegistrar)
            // 判断是不是 ImportSelector
            if (candidate.isAssignable(ImportSelector.class)) {
               // Candidate class is an ImportSelector -&amp;gt; delegate to it to determine imports
               Class&amp;lt;?&amp;gt; candidateClass = candidate.loadClass();
               // 通过反射实现一个对象 
               ImportSelector selector = BeanUtils.instantiateClass(candidateClass, ImportSelector.class);
               ParserStrategyUtils.invokeAwareMethods(
                     selector, this.environment, this.resourceLoader, this.registry);
               if (this.deferredImportSelectors != null &amp;amp;&amp;amp; selector instanceof DeferredImportSelector) {
                  this.deferredImportSelectors.add(
                        new DeferredImportSelectorHolder(configClass, (DeferredImportSelector) selector));
               }
               else {
                  String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
                  Collection&amp;lt;SourceClass&amp;gt; importSourceClasses = asSourceClasses(importClassNames);
                  processImports(configClass, currentSourceClass, importSourceClasses, false);
               }
            }
            // 判断是不是 ImportBeanDefinitionRegistrar
            else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
               // Candidate class is an ImportBeanDefinitionRegistrar -&amp;gt;
               // delegate to it to register additional bean definitions
               Class&amp;lt;?&amp;gt; candidateClass = candidate.loadClass();
               ImportBeanDefinitionRegistrar registrar =
                     BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);
               ParserStrategyUtils.invokeAwareMethods(
                     registrar, this.environment, this.resourceLoader, this.registry);
               configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
            }
            // 普通类：@Import(IndexDao.class)
            else {
               // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&amp;gt;
               // process it as an @Configuration class
               this.importStack.registerImport(
                     currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
               processConfigurationClass(candidate.asConfigClass(configClass));
            }
         }
      }
      catch (BeanDefinitionStoreException ex) {
         throw ex;
      }
      catch (Throwable ex) {
         throw new BeanDefinitionStoreException(
               &amp;quot;Failed to process import candidates for configuration class [&amp;quot; +
               configClass.getMetadata().getClassName() + &amp;quot;]&amp;quot;, ex);
      }
      finally {
         this.importStack.pop();
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;import&#34;&gt;Import&lt;/h1&gt;
&lt;h2 id=&#34;importselector&#34;&gt;ImportSelector&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyImportSelector implements ImportSelector {
   @Override
   public String[] selectImports(AnnotationMetadata importingClassMetadata) {
      return new String[]{IndexDaoImpl3.class.getName()};
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ComponentScan(&amp;quot;com.ssm&amp;quot;)
@Import(MyImportSelector.class)
public class AppConfig {
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class IndexDaoImpl3 implements IndexDao{
   @Override
   public void query() {
      System.out.println(&amp;quot;dao3...模拟查询数据库&amp;quot;);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      // 初始化 Spring 的环境
      context. refresh();
      IndexDao dao = context.getBean(IndexDaoImpl3.class);
      dao.query();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dao3...模拟查询数据库
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接在 IndexDaoImpl3 添加 @Component 注解也能实现将 对象注入到 Spring 容器中，为什么要使用一个 MyImportSelector implements ImportSelector 类呢？&lt;br&gt;
因为有的功能需要 Spring 动态帮我们加载，比如 IndexDaoImpl3 是我开发的程序，我开发的程序并不一定在我的项目中，可以在 AppConfig 中修改扫描包，但是如果只有一个类需要引用，修改扫描包 @ComponentScan 不是好的办法。可以开关闭某些功能。&lt;/p&gt;
&lt;p&gt;动态代理：&lt;/p&gt;
&lt;p&gt;Spring 底层的 AOP 提供一个开关来开启是否要对 AOP 的支持&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class IndexDaoImpl3 implements IndexDao, BeanPostProcessor {
   @Override
   public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
      if(beanName.equals(&amp;quot;indexDao&amp;quot;)){
         bean = Proxy.newProxyInstance(this.getClass().getClassLoader(), new Class[]{IndexDao.class},new MyInvocationHandler(bean));
      }
      return bean;
   }
   @Override
   public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
      return null;
   }
   @Override
   public void query() {
      System.out.println(&amp;quot;dao3...模拟查询数据库&amp;quot;);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;怎样实现 Spring 动态加载？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyImportSelector implements ImportSelector {
   @Override
   public String[] selectImports(AnnotationMetadata importingClassMetadata) {
      // 得到 @EnableLuban 注解的值
      // int value = importingClassMetadata.getAnnotationTypes().value
      // if(value)   return new String[]{IndexDaoImpl3.class.getName()};
      return new String[]{IndexDaoImpl3.class.getName()};
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Retention(RetentionPolicy.RUNTIME)
@Import(MyImportSelector.class)
public @interface EnableLuban {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ComponentScan(&amp;quot;com.ssm&amp;quot;)
@EnableLuban
public class AppConfig {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果配置类有 @EnableLuban 注解，运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dao3...模拟查询数据库
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果配置类没有 @EnableLuban 注解，运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Exception in thread &amp;quot;main&amp;quot; org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &#39;com.ssm.dao.impl.IndexDaoImpl3&#39; available
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyInvocationHandler implements InvocationHandler {
   Object target;
   public MyInvocationHandler(Object target){
      this.target = target;
   }
   @Override
   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
      System.out.println(&amp;quot;代理方法...&amp;quot;);
      return method.invoke(target,args);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      // 初始化 Spring 的环境
      context. refresh();
      IndexDao dao = (IndexDao) context.getBean(&amp;quot;indexDao&amp;quot;);
      dao.query();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;代理方法...
dao...模拟查询数据库
&lt;/code&gt;&lt;/pre&gt;
">Spring系列（九）Spring源码解析</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/spring-xi-lie-ba-spring-yuan-ma-jie-xi/"" data-c="
          &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
   public static void main(String[] args) {
      // 初始化 Spring 环境
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // 注册 AppConfig.class
      context.register(AppConfig.class);
      // 解析 AppConfig.class
      context.refresh();
      IndexDao indexDao = context.getBean(IndexDaoImpl.class);
      indexDao.query();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1new-annotationconfigapplicationcontext&#34;&gt;1.new AnnotationConfigApplicationContext();&lt;/h1&gt;
&lt;p&gt;第 6-7 行代码：由于 AnnotationConfigApplicationContext 有父类，所以会先调用父类构造方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class AnnotationConfigApplicationContext extends GenericApplicationContext implements AnnotationConfigRegistry {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;父类构造方法 GenericApplicationContext() 中创建一个 DefaultListableBeanFactory 工厂：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public GenericApplicationContext() {
   this.beanFactory = new DefaultListableBeanFactory();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;父类构造方法调用完成后，调用本类构造方法，初始化读取器 AnnotatedBeanDefinitionReader 和扫描器 ClassPathBeanDefinitionScanner：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public AnnotationConfigApplicationContext() {
   /**
    * 父类的构造方法 super()
    *创建一个读取注解的 Bean 定义读取器：reader 能读取被加了注解的类
    * 什么是 bean 定义？BeanDefinition
    */
   this.reader = new AnnotatedBeanDefinitionReader(this);
   // 定义扫描器
   // 可以用来扫描包，继而转换成 bd
   // 但是实际上我们扫描包工作不是 scanner 这个对象
   // 是 Spring 自己 new 的一个 ClasspathBeanDefinitionScanner
   // 这里的 scanner 仅仅是为了程序员能够在外部调用 AnnotationConfigApplicationContext 对象的 scan 方法用的。
   this.scanner = new ClassPathBeanDefinitionScanner(this);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;11-new-annotatedbeandefinitionreaderthis&#34;&gt;1.1 new AnnotatedBeanDefinitionReader(this)&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/7%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;2contextrefresh&#34;&gt;2.context.refresh();&lt;/h1&gt;
&lt;p&gt;Test 类第 12 行代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;context.refresh();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;点进去如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void refresh() throws BeansException, IllegalStateException {
   synchronized (this.startupShutdownMonitor) {
      // Prepare this context for refreshing.
      // 准备工作包括设置启动时间、是否激活标识位，初始化属性源（property source）配置
      prepareRefresh();
      // Tell the subclass to refresh the internal bean factory.
      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
      // Prepare the bean factory for use in this context.
      // 准备 Bean 工厂
      prepareBeanFactory(beanFactory);
      try {
         // Allows post-processing of the bean factory in context subclasses.
         // 这个方法在当前版本的 spring 是没有任何代码的
         // 可能 Spring 期待在后面的版本中去扩展吧
         postProcessBeanFactory(beanFactory);
         // Invoke factory processors registered as beans in the context.
         // 在 Spring 的环境中执行已经被注册的 factory processors
         // 设置执行自定义的 ProcessBeanFactory 和 Spring 内部自己定义的，比如 ConfigurationClassPostProcessor
         invokeBeanFactoryPostProcessors(beanFactory);
         // Register bean processors that intercept bean creation.
         registerBeanPostProcessors(beanFactory);
         // Initialize message source for this context.
         initMessageSource();
         // Initialize event multicaster for this context.
         initApplicationEventMulticaster();
         // Initialize other special beans in specific context subclasses.
         onRefresh();
         // Check for listener beans and register them.
         registerListeners();
         // Instantiate all remaining (non-lazy-init) singletons.
         finishBeanFactoryInitialization(beanFactory);
         // Last step: publish corresponding event.
         finishRefresh();
      }
      catch (BeansException ex) {
         if (logger.isWarnEnabled()) {
            logger.warn(&amp;quot;Exception encountered during context initialization - &amp;quot; +
                  &amp;quot;cancelling refresh attempt: &amp;quot; + ex);
         }
         // Destroy already created singletons to avoid dangling resources.
         destroyBeans();
         // Reset &#39;active&#39; flag.
         cancelRefresh(ex);
         // Propagate exception to caller.
         throw ex;
      }
      finally {
         // Reset common introspection caches in Spring&#39;s core, since we
         // might not ever need metadata for singleton beans anymore...
         resetCommonCaches();
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;21-preparebeanfactory&#34;&gt;2.1 prepareBeanFactory&lt;/h2&gt;
&lt;p&gt;上述代码第 12 行准备 Bean 工厂：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 配置工厂标准的特征，比如上下文的加载器 ClassLoader 和 post-processors 回调
 * Configure the factory&#39;s standard context characteristics,
 * such as the context&#39;s ClassLoader and post-processors.
 * @param beanFactory the BeanFactory to configure
 */
protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
   // Tell the internal bean factory to use the context&#39;s class loader etc.
   beanFactory.setBeanClassLoader(getClassLoader());
   // bean 表达式解析器，能够在前台页面获取 bean 当中的属性
   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
   // 对象与 string 类型的转换 &amp;lt;property ref=&amp;quot;dao&amp;quot;&amp;gt; 将dao转为对象
   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));
   // Configure the bean factory with context callbacks.
   // 添加一个后置管理器：ApplicationContextAwareProcessor 实现了 BeanPostProcessor接口：插手 Bean 的创建过程
   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
   // 忽略接口
   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);
   // BeanFactory interface not registered as resolvable type in a plain factory.
   // MessageSource registered (and found for autowiring) as a bean.
   // 依赖替换：如果注入的是 BeanFactory，就用 beanFactory 替代
   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
   beanFactory.registerResolvableDependency(ResourceLoader.class, this);
   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
   beanFactory.registerResolvableDependency(ApplicationContext.class, this);
   // Register early post-processor for detecting inner beans as ApplicationListeners.
   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));
   // Detect a LoadTimeWeaver and prepare for weaving, if found.
   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
      // Set a temporary ClassLoader for type matching.
      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
   }
   // 意思是如果自定义的 Bean 中没有名为 &amp;quot;systemProperties&amp;quot; 和 &amp;quot;systemEnvironment&amp;quot; 的 Bean
   // 则注册两个 Bean，key 为 &amp;quot;systemProperties&amp;quot; 和 &amp;quot;systemEnvironment&amp;quot;, value 为 map
   // 这两个 Bean 就是一些系统配置和系统环境信息
   // Register default environment beans.
   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
   }
   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
   }
   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;22-invokebeanfactorypostprocessors&#34;&gt;2.2 invokeBeanFactoryPostProcessors&lt;/h2&gt;
&lt;p&gt;看 refresh 方法的第 23 行 ：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;invokeBeanFactoryPostProcessors(beanFactory);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;点进去这个方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
   // 这个地方需要注意 getBeanFactoryPostProcessors() 是获取手动给 Spring 的 BeanFactoryPostProcessor
   // 自定义的并不仅仅是程序员自己写的
   // 自己写的可以加 @Component,也可以不加，
   // 如果加了@Component这个getBeanFactoryPostProcessors()方法得不到，应该是 Spring 自己扫描的
   // 为什么得不到？因为 getBeanFactoryPostProcessors() 这个方法是直接获取一个 list，
   // 这个 list 是在 AnnotationConfigApplicationContext被定义
   // 所谓的自定义的就是你手动调用 AnnotationConfigApplicationContext.addBeanFactoryPostProcessor(new XxxBeanFactoryPostProcessor());
   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
   // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
   // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
   if (beanFactory.getTempClassLoader() == null &amp;amp;&amp;amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;221-getbeanfactorypostprocessors&#34;&gt;2.2.1 getBeanFactoryPostProcessors&lt;/h3&gt;
&lt;p&gt;上述代码第 9 行中的 getBeanFactoryPostProcessors()：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public List&amp;lt;BeanFactoryPostProcessor&amp;gt; getBeanFactoryPostProcessors() {
   return this.beanFactoryPostProcessors;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;beanFactoryPostProcessors 变量的定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private final List&amp;lt;BeanFactoryPostProcessor&amp;gt; beanFactoryPostProcessors = new ArrayList&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%87%AA%E5%AE%9A%E4%B9%89beanFactoryPostProcessor.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;222-invokebeanfactorypostprocessors&#34;&gt;2.2.2 invokeBeanFactoryPostProcessors&lt;/h3&gt;
&lt;p&gt;同样的 invokeBeanFactoryPostProcessors 方法的第 9 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void invokeBeanFactoryPostProcessors(
      ConfigurableListableBeanFactory beanFactory, List&amp;lt;BeanFactoryPostProcessor&amp;gt; beanFactoryPostProcessors) {
   // Invoke BeanDefinitionRegistryPostProcessors first, if any.
   Set&amp;lt;String&amp;gt; processedBeans = new HashSet&amp;lt;&amp;gt;();
   if (beanFactory instanceof BeanDefinitionRegistry) {
      BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
      // 定义两个 list， BeanDefinitionRegistryPostProcessor 实现了 BeanFactoryPostProcessor 接口
      // 因为 bdrp 是子类，子类扩展了父类中的功能。
      List&amp;lt;BeanFactoryPostProcessor&amp;gt; regularPostProcessors = new ArrayList&amp;lt;&amp;gt;();
      List&amp;lt;BeanDefinitionRegistryPostProcessor&amp;gt; registryProcessors = new ArrayList&amp;lt;&amp;gt;(); 
      // 自定义的 beanFactoryPostProcessors
      // 因为传参，所以 beanFactoryPostProcessors 是 BeanFactoryPostProcessor 类型
      // 这里因为 beanFactoryPostProcessors长度为0，所以不会进入 for 循环 
      for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
         // 判断 postProcessor 是否是 BeanFactoryPostProcessor 的子类 BeanDefinitionRegistryPostProcessor
         if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
            BeanDefinitionRegistryPostProcessor registryProcessor =
                  (BeanDefinitionRegistryPostProcessor) postProcessor;
            registryProcessor.postProcessBeanDefinitionRegistry(registry);
            registryProcessors.add(registryProcessor);
         }
         else {
         // 如果 postProcessor 不是 BeanFactoryPostProcessor 的子类 BeanDefinitionRegistryPostProcessor，那 postProcessor 就一定是 BeanFactoryPostProcessor 类型，添加到 List&amp;lt;BeanFactoryPostProcessor&amp;gt; regularPostProcessors 中
            regularPostProcessors.add(postProcessor);
         }
      }
      
      // 这个 currentRegistryProcessors 放的是 Spring 内部自己实现了 BeanDefinitionRegistryPostProcessor 接口的对象
      List&amp;lt;BeanDefinitionRegistryPostProcessor&amp;gt; currentRegistryProcessors = new ArrayList&amp;lt;&amp;gt;();
      // BeanDefinitionRegistryPostProcessor 等于 BeanFactoryPostProcessor
      String[] postProcessorNames =
            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
      // 这个地方可以得到一个 BeanFactoryPostProcessor，因为是 Spring 默认在最开始自己注册的
      // 为什么要在最开始注册这个呢？
      // 因为 Spring 的工厂需要注解去扫描等等功能
      // 而这些功能都是需要在 Spring 工厂初始化完成之前就执行
      // 要么在工厂最开始的时候，要么在工厂初始化之中，反正不能在之后
      // 因为如果在之后就没有意义，因为那个时候已经需要使用工厂了
      // 所以这里 Spring 在一开始就注册了一个 BeanFactoryPostProcessor，用来插手 springFactory 的实例化过程
      // 在这个地方断点可以知道这个类叫做 ConfigurationClassPostProcessor
      // ConfigurationClassPostProcessor 那么这个类能干嘛呢？可以参考源码
      // 下面对这个“插手 Spring 工厂实例化过程”的类重点解释
      for (String ppName : postProcessorNames) {
         if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
         }
      }
      // 排序不重要，况且 currentRegistryProcessor 这里也只有一个数据
      sortPostProcessors(currentRegistryProcessors, beanFactory);
      // 合并 List，不重要（为什么要合并，因为有自定义的Spring自己的）
      registryProcessors.addAll(currentRegistryProcessors);
      // 最重要。注意这里是方法调用
      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
      currentRegistryProcessors.clear();
      // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
      for (String ppName : postProcessorNames) {
         if (!processedBeans.contains(ppName) &amp;amp;&amp;amp; beanFactory.isTypeMatch(ppName, Ordered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
         }
      }
      sortPostProcessors(currentRegistryProcessors, beanFactory);
      registryProcessors.addAll(currentRegistryProcessors);
      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
      currentRegistryProcessors.clear();
      // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
      boolean reiterate = true;
      while (reiterate) {
         reiterate = false;
         postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
         for (String ppName : postProcessorNames) {
            if (!processedBeans.contains(ppName)) {
               currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
               processedBeans.add(ppName);
               reiterate = true;
            }
         }
         sortPostProcessors(currentRegistryProcessors, beanFactory);
         registryProcessors.addAll(currentRegistryProcessors);
         invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
         currentRegistryProcessors.clear();
      }
      // Now, invoke the postProcessBeanFactory callback of all processors handled so far.
      invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
      invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
   }
   else {
      // Invoke factory processors registered with the context instance.
      invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
   }
   // Do not initialize FactoryBeans here: We need to leave all regular beans
   // uninitialized to let the bean factory post-processors apply to them!
   String[] postProcessorNames =
         beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);
   // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
   // Ordered, and the rest.
   List&amp;lt;BeanFactoryPostProcessor&amp;gt; priorityOrderedPostProcessors = new ArrayList&amp;lt;&amp;gt;();
   List&amp;lt;String&amp;gt; orderedPostProcessorNames = new ArrayList&amp;lt;&amp;gt;();
   List&amp;lt;String&amp;gt; nonOrderedPostProcessorNames = new ArrayList&amp;lt;&amp;gt;();
   for (String ppName : postProcessorNames) {
      if (processedBeans.contains(ppName)) {
         // skip - already processed in first phase above
      }
      else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
         priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
      }
      else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
         orderedPostProcessorNames.add(ppName);
      }
      else {
         nonOrderedPostProcessorNames.add(ppName);
      }
   }
   // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
   invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);
   // Next, invoke the BeanFactoryPostProcessors that implement Ordered.
   List&amp;lt;BeanFactoryPostProcessor&amp;gt; orderedPostProcessors = new ArrayList&amp;lt;&amp;gt;();
   for (String postProcessorName : orderedPostProcessorNames) {
      orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
   }
   sortPostProcessors(orderedPostProcessors, beanFactory);
   invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);
   // Finally, invoke all other BeanFactoryPostProcessors.
   List&amp;lt;BeanFactoryPostProcessor&amp;gt; nonOrderedPostProcessors = new ArrayList&amp;lt;&amp;gt;();
   for (String postProcessorName : nonOrderedPostProcessorNames) {
      nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
   }
   invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);
   // Clear cached merged bean definitions since the post-processors might have
   // modified the original metadata, e.g. replacing placeholders in values...
   beanFactory.clearMetadataCache();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述第 11、12、31 行分别定义了一个 List：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors：放程序员手动添加的 BeanFactoryPostProcessor&lt;/li&gt;
&lt;li&gt;List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors：放程序员手动添加的 BeanDefinitionRegistryPostProcessor&lt;/li&gt;
&lt;li&gt;List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors：放 Spring 内部自己的 BeanDefinitionRegistryPostProcessor&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述第 35-36 行代码：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/currentRegistryProcessors.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上述第 47-51 行代码：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/postProcessorNames.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上述代码第 58 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static void invokeBeanDefinitionRegistryPostProcessors(
      Collection&amp;lt;? extends BeanDefinitionRegistryPostProcessor&amp;gt; postProcessors, BeanDefinitionRegistry registry) {
   for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
      postProcessor.postProcessBeanDefinitionRegistry(registry);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/postProcessors.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;点进去上述第  5 行代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
   int registryId = System.identityHashCode(registry);
   if (this.registriesPostProcessed.contains(registryId)) {
      throw new IllegalStateException(
            &amp;quot;postProcessBeanDefinitionRegistry already called on this post-processor against &amp;quot; + registry);
   }
   if (this.factoriesPostProcessed.contains(registryId)) {
      throw new IllegalStateException(
            &amp;quot;postProcessBeanFactory already called on this post-processor against &amp;quot; + registry);
   }
   this.registriesPostProcessed.add(registryId);
   processConfigBeanDefinitions(registry);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2221-processconfigbeandefinitions&#34;&gt;2.2.2.1 processConfigBeanDefinitions&lt;/h4&gt;
&lt;p&gt;点进上述第 14 行代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
   // app 提供的 bean：每扫描到添加了 @Configuraion 注解的类就添加到这个 set 集合中
   List&amp;lt;BeanDefinitionHolder&amp;gt; configCandidates = new ArrayList&amp;lt;&amp;gt;();
   // 获取容器中注册的所有 bean 名字
   String[] candidateNames = registry.getBeanDefinitionNames();
   // 依次取出每个&amp;lt;beanName,beanDefinition&amp;gt;
   for (String beanName : candidateNames) {
      BeanDefinition beanDef = registry.getBeanDefinition(beanName);
      // 判断当前 bean 是否被处理过：使用 isFullConfigurationClass 来标识
      if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
            ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {
         // 如果 BeanDefinition 中的 configurationClass 属性为 full 或者 lite，则意味着已经处理过了，直接跳过
         // 这里需要结合下面的代码才能理解
         if (logger.isDebugEnabled()) {
            logger.debug(&amp;quot;Bean definition has already been processed as a configuration class: &amp;quot; + beanDef);
         }
      }
      // 判断这个 BeanDefinition 是否是 Configuration类，这其实主要是看是否有
      else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
         configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
      }
   }
   // Return immediately if no @Configuration classes were found
   if (configCandidates.isEmpty()) {
      return;
   }
   // 排序，根据 order，不重要
   // Sort by previously determined @Order value, if applicable
   configCandidates.sort((bd1, bd2) -&amp;gt; {
      int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
      int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
      return Integer.compare(i1, i2);
   });
   // Detect any custom bean name generation strategy supplied through the enclosing application context
   SingletonBeanRegistry sbr = null;
   // 如果 BeanDefinitionRegistry 是 SingletonBeanRegistry 子类的话
   // 由于会将 registry 强转为 SingletonBeanRegistry
   if (registry instanceof SingletonBeanRegistry) {
      sbr = (SingletonBeanRegistry) registry;
      if (!this.localBeanNameGeneratorSet) {//是否有自定义的
         BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);
         // SingletonBeanRegistry 中有 id 为 org.springframework.context.annotation.internalConfigurationBeanNameGenerator
         // 如果有则利用它的，否则则使用 Spring 默认的
         if (generator != null) {
            this.componentScanBeanNameGenerator = generator;
            this.importBeanNameGenerator = generator;
         }
      }
   }
   if (this.environment == null) {
      this.environment = new StandardEnvironment();
   }
   // Parse each @Configuration class
   // 实例化 ConfigurationClassParser 为了解析各个配置类
   ConfigurationClassParser parser = new ConfigurationClassParser(
         this.metadataReaderFactory, this.problemReporter, this.environment,
         this.resourceLoader, this.componentScanBeanNameGenerator, registry);
   // 实例化 2 个 set，candidates 用于将之前加入的 configCandidates 进行去重
   // 因为可能有多个配置类重复了
   // alreadyParsed 用户判断是否处理过
   Set&amp;lt;BeanDefinitionHolder&amp;gt; candidates = new LinkedHashSet&amp;lt;&amp;gt;(configCandidates);
   Set&amp;lt;ConfigurationClass&amp;gt; alreadyParsed = new HashSet&amp;lt;&amp;gt;(configCandidates.size());
   do {
      parser.parse(candidates);
      parser.validate();
      Set&amp;lt;ConfigurationClass&amp;gt; configClasses = new LinkedHashSet&amp;lt;&amp;gt;(parser.getConfigurationClasses());
      configClasses.removeAll(alreadyParsed);
      // Read the model and create bean definitions based on its content
      if (this.reader == null) {
         this.reader = new ConfigurationClassBeanDefinitionReader(
               registry, this.sourceExtractor, this.resourceLoader, this.environment,
               this.importBeanNameGenerator, parser.getImportRegistry());
      }
      // 把扫描出来的 bean 对应的 beanDefinitions 添加到 factory 的 map 当中
      this.reader.loadBeanDefinitions(configClasses);
      alreadyParsed.addAll(configClasses);
      candidates.clear();
      if (registry.getBeanDefinitionCount() &amp;gt; candidateNames.length) {
         String[] newCandidateNames = registry.getBeanDefinitionNames();
         Set&amp;lt;String&amp;gt; oldCandidateNames = new HashSet&amp;lt;&amp;gt;(Arrays.asList(candidateNames));
         Set&amp;lt;String&amp;gt; alreadyParsedClasses = new HashSet&amp;lt;&amp;gt;();
         for (ConfigurationClass configurationClass : alreadyParsed) {
            alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
         }
         for (String candidateName : newCandidateNames) {
            if (!oldCandidateNames.contains(candidateName)) {
               BeanDefinition bd = registry.getBeanDefinition(candidateName);
               if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;amp;&amp;amp;
                     !alreadyParsedClasses.contains(bd.getBeanClassName())) {
                  candidates.add(new BeanDefinitionHolder(bd, candidateName));
               }
            }
         }
         candidateNames = newCandidateNames;
      }
   }
   while (!candidates.isEmpty());
   // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes
   if (sbr != null &amp;amp;&amp;amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {
      sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
   }
   if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {
      // Clear cache in externally provided MetadataReaderFactory; this is a no-op
      // for a shared cache since it&#39;ll be cleared by the ApplicationContext.
      ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/getBeanDefinitionNames.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;22211-checkconfigurationclasscandidate&#34;&gt;2.2.2.1.1 checkConfigurationClassCandidate&lt;/h5&gt;
&lt;p&gt;上述代码第 19 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;refresh() 的主要功能是要解析类：Spring 认为添加了@Configuration、@Component、@Import...注解的类都是需要解析的类。&lt;br&gt;
如何将一个 User 类变成 BeanDefinition：XxxBeanDefinition bd = new XxxBeanDefinition(user);&lt;/p&gt;
&lt;p&gt;Spring 如何判断一个类是否是应该解析的类？&lt;/p&gt;
&lt;p&gt;①判断一个 bd 是否被加了注解（AnnotatedBeanDefinition abd = new AnnotatedBeanDefinition(AppConfig.class); register.regisyBD(abd); ）；②把信息（元数据）拿出来；③根据信息判断加了什么注解&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static boolean checkConfigurationClassCandidate(BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) {
   String className = beanDef.getBeanClassName();
   if (className == null || beanDef.getFactoryMethodName() != null) {
      return false;
   }
   AnnotationMetadata metadata;
   // 判断这个 bd 是否被加了注解
   if (beanDef instanceof AnnotatedBeanDefinition &amp;amp;&amp;amp;
         className.equals(((AnnotatedBeanDefinition) beanDef).getMetadata().getClassName())) {
      // Can reuse the pre-parsed metadata from the given BeanDefinition...
      // 如果 BeanDefinition 是 AnnotatedBeanDefinition 的实例，并且 className 和 BeanDefinition 中的元数据的类名相同
      // 则直接从 BeanDefinition 获得元数据Metadata
      metadata = ((AnnotatedBeanDefinition) beanDef).getMetadata();
   }
   else if (beanDef instanceof AbstractBeanDefinition &amp;amp;&amp;amp; ((AbstractBeanDefinition) beanDef).hasBeanClass()) {
      // Check already loaded Class if present...
      // since we possibly can&#39;t even load the class file for this Class.
      // 如果 BeanDefinition 是 AbstractBeanDefinition 的实例，并且 beanDef 有 beanClass 属性存在
      // 则实例化 StandardAnnotationMetadata
      Class&amp;lt;?&amp;gt; beanClass = ((AbstractBeanDefinition) beanDef).getBeanClass();
      metadata = new StandardAnnotationMetadata(beanClass, true);
   }
   else {
      try {
         MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);
         metadata = metadataReader.getAnnotationMetadata();
      }
      catch (IOException ex) {
         if (logger.isDebugEnabled()) {
            logger.debug(&amp;quot;Could not find class file for introspecting configuration annotations: &amp;quot; + className, ex);
         }
         return false;
      }
   }
   // 判断当前这个 bd 中存在的类是不是加了 @Configuration 注解，但是如果加了 @Configuration，下面的这几个注解就不再判断，因为这是一个 if-else if 分支
   // 只有满足了 &amp;quot;没有加 @Configuration注解&amp;quot;，才会走 else 分支去判断是否添加了其他注解
   if (isFullConfigurationCandidate(metadata)) {
      // 如果存在 Configuration 注解，则为 BeanDefinition 设置 configurationClass 属性为 FULL
      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);
   }
   // 判断是否加了以下注解，摘录 isLiteConfigurationCandidate 的源码
   // candidateIndicators.add(Component.class.getName());
   // candidateIndicators.add(ComponentScan.class.getName());
   // candidateIndicators.add(Import.class.getName());
   // candidateIndicators.add(ImportResource.class.getName());
   else if (isLiteConfigurationCandidate(metadata)) {
      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
   }
   else {
      return false;
   }
   // It&#39;s a full or lite configuration candidate... Let&#39;s determine the order value, if any.
   Integer order = getOrder(metadata);
   if (order != null) {
      beanDef.setAttribute(ORDER_ATTRIBUTE, order);
   }
   return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 39 行，判断是否加了 @Configuration 注解&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static boolean isFullConfigurationCandidate(AnnotationMetadata metadata) {
   return metadata.isAnnotated(Configuration.class.getName());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 48 行，判断是否加了其他注解：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static boolean isLiteConfigurationCandidate(AnnotationMetadata metadata) {
   // Do not consider an interface or an annotation...
   if (metadata.isInterface()) {
      return false;
   }
   // Any of the typical annotations found?
   for (String indicator : candidateIndicators) {
      if (metadata.isAnnotated(indicator)) {
         return true;
      }
   }
   // Finally, let&#39;s look for @Bean methods...
   try {
      return metadata.hasAnnotatedMethods(Bean.class.getName());
   }
   catch (Throwable ex) {
      if (logger.isDebugEnabled()) {
         logger.debug(&amp;quot;Failed to introspect @Bean methods on class [&amp;quot; + metadata.getClassName() + &amp;quot;]: &amp;quot; + ex);
      }
      return false;
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 8 行中提到的 candidateIndicators&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static final Set&amp;lt;String&amp;gt; candidateIndicators = new HashSet&amp;lt;&amp;gt;(8);
static {
   candidateIndicators.add(Component.class.getName());
   candidateIndicators.add(ComponentScan.class.getName());
   candidateIndicators.add(Import.class.getName());
   candidateIndicators.add(ImportResource.class.getName());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于 39-48 行的 if-else if 判断是否添加注解，其中 &amp;quot;eles if&amp;quot; 分支的作用，补充说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果一个类添加了 @Configuration，Spring 把它扫描出来，知道它是一个配置类，然后再去解析这个类，就可以依次扫描到其他注解：@ComponentScan、@Import&lt;/li&gt;
&lt;li&gt;但是如果一个类没有添加 @Configuration 注解，只加入了 @ImportResource(&amp;quot;spring.xml&amp;quot;) 注解，这时候就需要使用到上述的 eles if 分支单独进行处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述 processConfigBeanDefinitions 方法的第 79 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;parser.parse(candidates);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;点进这个方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void parse(Set&amp;lt;BeanDefinitionHolder&amp;gt; configCandidates) {
   this.deferredImportSelectors = new LinkedList&amp;lt;&amp;gt;();
   // 根据 BeanDefinition 的类型做不同的处理，一般都会调用 ConfigurationClassParse#parse 进行解析
   for (BeanDefinitionHolder holder : configCandidates) {
      BeanDefinition bd = holder.getBeanDefinition();
      try {
         // 判断这个 bd 是否被加了注解
         if (bd instanceof AnnotatedBeanDefinition) {
            parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
         }
         else if (bd instanceof AbstractBeanDefinition &amp;amp;&amp;amp; ((AbstractBeanDefinition) bd).hasBeanClass()) {
            parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
         }
         else {
            parse(bd.getBeanClassName(), holder.getBeanName());
         }
      }
      catch (BeanDefinitionStoreException ex) {
         throw ex;
      }
      catch (Throwable ex) {
         throw new BeanDefinitionStoreException(
               &amp;quot;Failed to parse configuration class [&amp;quot; + bd.getBeanClassName() + &amp;quot;]&amp;quot;, ex);
      }
   }
   processDeferredImportSelectors();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 9 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;点进这个方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {
   processConfigurationClass(new ConfigurationClass(metadata, beanName));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;点进第 2 行这个方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
   // 判断是否应该跳过解析
   if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
      return;
   }
   // 处理 Imported 的情况
   ConfigurationClass existingClass = this.configurationClasses.get(configClass);
   if (existingClass != null) {
      if (configClass.isImported()) {
         if (existingClass.isImported()) {
            existingClass.mergeImportedBy(configClass);
         }
         // Otherwise ignore new imported config class; existing non-imported class overrides it.
         return;
      }
      else {
         // Explicit bean definition found, probably replacing an import.
         // Let&#39;s remove the old one and go with the new one.
         this.configurationClasses.remove(configClass);
         this.knownSuperclasses.values().removeIf(configClass::equals);
      }
   }
   // Recursively process the configuration class and its superclass hierarchy.
   SourceClass sourceClass = asSourceClass(configClass);
   do {
      sourceClass = doProcessConfigurationClass(configClass, sourceClass);
   }
   while (sourceClass != null);
   // 一个 map，用来存放扫描出来的 bean（注意这里的 bean 不是对象，仅仅是 bean 的信息，因为还没到实例化）
   this.configurationClasses.put(configClass, configClass);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 28 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Nullable
protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)
      throws IOException {
   // Recursively process any member (nested) classes first
   // 处理内部类
   processMemberClasses(configClass, sourceClass);
   // Process any @PropertySource annotations
   for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
         sourceClass.getMetadata(), PropertySources.class,
         org.springframework.context.annotation.PropertySource.class)) {
      if (this.environment instanceof ConfigurableEnvironment) {
         processPropertySource(propertySource);
      }
      else {
         logger.warn(&amp;quot;Ignoring @PropertySource annotation on [&amp;quot; + sourceClass.getMetadata().getClassName() +
               &amp;quot;]. Reason: Environment must implement ConfigurableEnvironment&amp;quot;);
      }
   }
   // Process any @ComponentScan annotations
   Set&amp;lt;AnnotationAttributes&amp;gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(
         sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
   if (!componentScans.isEmpty() &amp;amp;&amp;amp;
         !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
      for (AnnotationAttributes componentScan : componentScans) {
         // The config class is annotated with @ComponentScan -&amp;gt; perform the scan immediately
         Set&amp;lt;BeanDefinitionHolder&amp;gt; scannedBeanDefinitions =
               this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
         // Check the set of scanned definitions for any further config classes and parse recursively if needed
         // 检查扫描出来的类当中是否还有 Configuration
         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
            BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
            if (bdCand == null) {
               bdCand = holder.getBeanDefinition();
            }
            if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
               parse(bdCand.getBeanClassName(), holder.getBeanName());
            }
         }
      }
   }
   // Process any @Import annotations
   // 处理 @Import
   processImports(configClass, sourceClass, getImports(sourceClass), true);
   // Process any @ImportResource annotations
   AnnotationAttributes importResource =
         AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
   if (importResource != null) {
      String[] resources = importResource.getStringArray(&amp;quot;locations&amp;quot;);
      Class&amp;lt;? extends BeanDefinitionReader&amp;gt; readerClass = importResource.getClass(&amp;quot;reader&amp;quot;);
      for (String resource : resources) {
         String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
         configClass.addImportedResource(resolvedResource, readerClass);
      }
   }
   // Process individual @Bean methods
   Set&amp;lt;MethodMetadata&amp;gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
   for (MethodMetadata methodMetadata : beanMethods) {
      configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
   }
   // Process default methods on interfaces
   processInterfaces(configClass, sourceClass);
   // Process superclass, if any
   if (sourceClass.getMetadata().hasSuperClass()) {
      String superclass = sourceClass.getMetadata().getSuperClassName();
      if (superclass != null &amp;amp;&amp;amp; !superclass.startsWith(&amp;quot;java&amp;quot;) &amp;amp;&amp;amp;
            !this.knownSuperclasses.containsKey(superclass)) {
         this.knownSuperclasses.put(superclass, configClass);
         // Superclass found, return its annotation metadata and recurse
         return sourceClass.getSuperClass();
      }
   }
   // No superclass -&amp;gt; processing is complete
   return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 47 行，判断有没有加 Import 标签&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Set&amp;lt;SourceClass&amp;gt; getImports(SourceClass sourceClass) throws IOException {
   Set&amp;lt;SourceClass&amp;gt; imports = new LinkedHashSet&amp;lt;&amp;gt;();
   Set&amp;lt;SourceClass&amp;gt; visited = new LinkedHashSet&amp;lt;&amp;gt;();
   collectImports(sourceClass, imports, visited);
   return imports;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;@Import 注解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@Import(IndexDao.class)、&lt;/li&gt;
&lt;li&gt;@Import(ImportSelector)、&lt;/li&gt;
&lt;li&gt;@Import(ImportBeanDefinitionRegistrar)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同样的上述代码第 47 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,
      Collection&amp;lt;SourceClass&amp;gt; importCandidates, boolean checkForCircularImports) {
   // 如果没有加@Import，直接返回
   if (importCandidates.isEmpty()) {
      return;
   }
   if (checkForCircularImports &amp;amp;&amp;amp; isChainedImportOnStack(configClass)) {
      this.problemReporter.error(new CircularImportProblem(configClass, this.importStack));
   }
   else {
      this.importStack.push(configClass);
      try {
         for (SourceClass candidate : importCandidates) {
            // @Import(IndexDao.class)、@Import(ImportSelector)、@Import(ImportBeanDefinitionRegistrar)
            // 判断是不是 ImportSelector
            if (candidate.isAssignable(ImportSelector.class)) {
               // Candidate class is an ImportSelector -&amp;gt; delegate to it to determine imports
               Class&amp;lt;?&amp;gt; candidateClass = candidate.loadClass();
               ImportSelector selector = BeanUtils.instantiateClass(candidateClass, ImportSelector.class);
               ParserStrategyUtils.invokeAwareMethods(
                     selector, this.environment, this.resourceLoader, this.registry);
               if (this.deferredImportSelectors != null &amp;amp;&amp;amp; selector instanceof DeferredImportSelector) {
                  this.deferredImportSelectors.add(
                        new DeferredImportSelectorHolder(configClass, (DeferredImportSelector) selector));
               }
               else {
                  String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
                  Collection&amp;lt;SourceClass&amp;gt; importSourceClasses = asSourceClasses(importClassNames);
                  processImports(configClass, currentSourceClass, importSourceClasses, false);
               }
            }
            // 判断是不是 ImportBeanDefinitionRegistrar
            else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
               // Candidate class is an ImportBeanDefinitionRegistrar -&amp;gt;
               // delegate to it to register additional bean definitions
               Class&amp;lt;?&amp;gt; candidateClass = candidate.loadClass();
               ImportBeanDefinitionRegistrar registrar =
                     BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);
               ParserStrategyUtils.invokeAwareMethods(
                     registrar, this.environment, this.resourceLoader, this.registry);
               configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
            }
            // 普通类：@Import(IndexDao.class)
            else {
               // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&amp;gt;
               // process it as an @Configuration class
               this.importStack.registerImport(
                     currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
               processConfigurationClass(candidate.asConfigClass(configClass));
            }
         }
      }
      catch (BeanDefinitionStoreException ex) {
         throw ex;
      }
      catch (Throwable ex) {
         throw new BeanDefinitionStoreException(
               &amp;quot;Failed to process import candidates for configuration class [&amp;quot; +
               configClass.getMetadata().getClassName() + &amp;quot;]&amp;quot;, ex);
      }
      finally {
         this.importStack.pop();
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;插手 Spring 中 Bean 工厂的建设：&lt;br&gt;
BeanFactoryPostProcessor：把它设置为一个 Bean 的属性。&lt;/p&gt;
&lt;p&gt;ImportBeanDefinitionRegistrar：把 map 暴露出来，用户就可以向 map 中动态添加 bean 了。&lt;/p&gt;
&lt;h1 id=&#34;注册-bean-的方法&#34;&gt;注册 Bean 的方法&lt;/h1&gt;
&lt;h2 id=&#34;registerindexdaoimplclass&#34;&gt;register(IndexDaoImpl.class);&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;bdmap.put()&lt;/li&gt;
&lt;li&gt;需要的是一个类，一个类变成 BeanDefinition 的过程是没办法参与的&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;scancomssm&#34;&gt;scan(&amp;quot;com.ssm&amp;quot;)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;需要的是一个类，一个类变成 BeanDefinition 的过程是没办法参与的&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;importbeandefinitionregistrar&#34;&gt;ImportBeanDefinitionRegistrar&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;向 map 中添加一个 bd&lt;/li&gt;
&lt;li&gt;好处：可以参与一个类变成 BeanDefinition 的过程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;@MapperScan() 的作用：扫描 mapper&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
@MapperScan(&amp;quot;com.ssm.dao&amp;quot;)
public class AppConfig{
    @Bean
    public DataSource dataSource(){
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;);
        dataSource.setUsername(&amp;quot;root&amp;quot;);
        dataSource.setPassword(&amp;quot;123456&amp;quot;);
        dataSource.setUrl(&amp;quot;jdbc:mysql://localhost:3306/card&amp;quot;);
        return dataSource;
    }
    @Bean
    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){
        SqlSessionFactoryBean sqlSessionFactoryBean =  new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource);
        return sqlSessionFactoryBean;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class CardService{
  @Autowired
  CardDao cardDao;
  public void list(){
    System.out.println(cardDao.list(&amp;quot;xxx&amp;quot;));
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface CardDao{
  @Select(&amp;quot;select * from card where card_number like &#39;%s{number}%&#39;&amp;quot;)
  public List&amp;lt;Map&amp;lt;Integer,String&amp;gt;&amp;gt; list(@Param(&amp;quot;number&amp;quot;) String number);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CardDao 是一个接口，一个接口如何变成一个对象？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        context.getBean(CardService.class).list();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;@MapperScan() ：将一个接口变成一个对象，且把变成的这个对象放到 Spring 容器中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Import(MapperScannerRegistrar.class)
public @interface MapperScan {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Spring 在解析到 @MapperScan 后，又会去解析 @Import，然后再解析 MapperScannerRegistrar&lt;br&gt;
MapperScannerRegistrar 类中有一个 registerBeanDefinitions 方法，此方法有一个参数是 BeanDefinitionRegistry，即把注册器暴露出来，就可以向容器中添加 Bean 了，这个方法是在所有 Bean 执行之前执行的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MapperScannerRegistrar implements ImportBeanDefinitionRegistrar, ResourceLoaderAware {
  private ResourceLoader resourceLoader;
  /**
   * {@inheritDoc}
   */
  @Override
  public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;@Autowired&lt;br&gt;
CardDao cardDao;&lt;/p&gt;
&lt;p&gt;如果有一个类 A extends CardService，不会将类 A 自动注入给 CardDao。如果有一个类 A implements CardDao，会将类 A 注入给 CardDao。&lt;/p&gt;
&lt;p&gt;模拟 Mybatis：在现在的基础上完成：① 创建一个对象；② 对象实现 CardDao 接口； ③这个对象在 Spring 容器中。&lt;/p&gt;
&lt;h3 id=&#34;让一个接口变成对象代理&#34;&gt;让一个接口变成对象：代理&lt;/h3&gt;
&lt;p&gt;1.测试类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        CardDao cardDao = (CardDao) Proxy.newProxyInstance(Test.class.getClassLoader(), new Class[]{CardDao.class}, new MyInvocationHandler());
        cardDao.list(&amp;quot;1&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.MyInvocationHandler&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyInvocationHandler implements InvocationHandler {
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&amp;quot;handler...&amp;quot;);
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.输出结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;handler...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.分析：&lt;br&gt;
通过 JDK 动态代理生成一个对象，执行代理方法时打印了 handler...&lt;/p&gt;
&lt;p&gt;上述步骤 1、2、3、4 已经实现了① 创建一个对象；② 对象实现 CardDao 接口，接下来实现步骤 ③将这个对象放到 Spring 容器中&lt;/p&gt;
&lt;h3 id=&#34;将对象放到-spring-容器中&#34;&gt;将对象放到 Spring 容器中&lt;/h3&gt;
&lt;h4 id=&#34;方法一实现-beanfactorypostprocessor-接口&#34;&gt;方法一：实现 BeanFactoryPostProcessor 接口&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 对 Bean 工厂进行插手，只能对 Bean 工厂进行初始化，不能将对象放入到 map 中，没有对应API
public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;方法二实现-importselector-接口&#34;&gt;方法二：实现 ImportSelector  接口&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
@MapperScan(&amp;quot;com.ssm&amp;quot;)
// Spring 把 MyImportSelect 类中 invoke 方法返回的字符串数组类名 new 出对象放到 Spring 工厂中
@Import(MyImportSelect.class) 
public class AppConfig{
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyImportSelect implements ImportSelector {
    @Override
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        // 因为是要将代理对象放到Spring工厂中，但是这里得不到代理对象的类名
        return new String[]{CardDaoProxy.class.getSimpleName()};
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;必须先产生代理对象出来，然后再来执行：Spring 扫描 @Import 注解，将 MyImportSelect 类中 invoke 方法返回的字符串数组类名 new 出对象放到 Spring 工厂中。&lt;/p&gt;
&lt;h4 id=&#34;方法三实现-importbeandefinitionregistrar-接口&#34;&gt;方法三：实现 ImportBeanDefinitionRegistrar  接口&lt;/h4&gt;
&lt;p&gt;1、实现 ImportBeanDefinitionRegistrar  接口：创建代理对象，并添加到 Spring 容器中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        // 1.得到 BeanDefinition
            // 扫描所有接口：扫描 com.ssm.dao 下所有接口。这里为了方便写死，不模拟动态了
        // carDao：代理对象
        CardDao cardDao = (CardDao) Proxy.newProxyInstance(Test.class.getClassLoader(), new Class[]{CardDao.class}, new MyInvocationHandler());
        cardDao.list(&amp;quot;2&amp;quot;);
        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(cardDao.getClass());
        GenericBeanDefinition beanDefinition = (GenericBeanDefinition) builder.getBeanDefinition();
        registry.registerBeanDefinition(&amp;quot;cardDao&amp;quot;,beanDefinition);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、配置类扫描 MyImportBeanDefinitionRegistrar&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
@MapperScan(&amp;quot;com.ssm&amp;quot;)
@Import(MyImportBeanDefinitionRegistrar.class)
public class AppConfig{
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、测试类：初始化 Spring 容器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5、测试结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;handler...
Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;cardDao&#39;: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &#39;java.lang.reflect.InvocationHandler&#39; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6、分析&lt;br&gt;
代理对象的代理方法执行了（证明 cardDao.list(&amp;quot;2&amp;quot;) 执行到了），但是代理对象注入不进来，因为 Spring 没有办法这样处理一个类，这个 dao 中的某些属性 Spring 没有注入进来。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyInvocationHandler implements InvocationHandler {
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&amp;quot;proxy...&amp;quot;);
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7、接口不能实例化&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        // 得到 BeanDefinition(扫描所有接口：扫描 com.ssm.dao 下所有接口。这里为了方便写死，不模拟动态了)
        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(CardDao.class);
        // 得到 BeanDefinition，BeanDefinition 有一个属性 beanClass 表示类型 CardDao.class
        GenericBeanDefinition beanDefinition = (GenericBeanDefinition) builder.getBeanDefinition();
        registry.registerBeanDefinition(&amp;quot;cardDao&amp;quot;,beanDefinition);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.ssm.dao.CardDao]: Specified class is an interface
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据 beanName=&amp;quot;cardDao&amp;quot; 取出 BeanDefinition，当执行完上述第 5 行代码后，取出的 BeanDefinition 类型为 CardDao 接口，接口不能实例化。&lt;br&gt;
所以需要将一个代理对象放入 map 中，{ beanName=&amp;quot;dao&amp;quot;, BeanDefinition={beanClass=$Proxy01.class; ...} }&lt;/p&gt;
&lt;p&gt;8、引入 FactoryBean&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        // 得到 BeanDefinition(扫描所有接口：扫描 com.ssm.dao 下所有接口。这里为了方便写死，不模拟动态了)
        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(CardDao.class);
        // 得到 BeanDefinition，BeanDefinition 有一个属性 beanClass 表示类型 CardDao
        GenericBeanDefinition beanDefinition = (GenericBeanDefinition) builder.getBeanDefinition();
        // 给 BeanDefinition 添加构造方法，因为 public MyFactoryBean(Class clazz) { 构造方法有参数
        beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(&amp;quot;com.ssm.dao.CardDao&amp;quot;);
        // 设置 BeanDefinition 的 beanClass 为代理对象
        beanDefinition.setBeanClass(MyFactoryBean.class);
        registry.registerBeanDefinition(&amp;quot;cardDao&amp;quot;,beanDefinition);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果类实现了 FactoryBean，那么 Spring 容器当中存在两个对象，一个是 getObject() 方法返回的代理对象（name=&amp;quot;myFactoryBean &amp;quot;）；还有一个是当前对象 MyFactoryBean（name=&amp;amp;myFactoryBean ） 。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyFactoryBean implements FactoryBean, InvocationHandler {
    Class clazz;
    public MyFactoryBean(Class clazz) {
        this.clazz = clazz;
    }
    @Override
    public Object getObject() throws Exception {
        Class[] clazzs = new Class[]{clazz};
        Object proxy = Proxy.newProxyInstance(this.getClass().getClassLoader(),clazzs,this);
        return proxy;
    }
    @Override
    public Class&amp;lt;?&amp;gt; getObjectType() {
        return clazz;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 得到代理对象的接口，通过名字去拿方法
        Method method1 = proxy.getClass().getInterfaces()[0].getMethod(method.getName(), String.class);
        // 拿到这个方法的注解
        Select select = method1.getDeclaredAnnotation(Select.class);
        System.out.println(String.valueOf(select.value()[0]));
        System.out.println(&amp;quot;proxy&amp;quot;);
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自定义注解：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Retention(RetentionPolicy.RUNTIME)
@Import(MyImportBeanDefinitionRegistrar.class)
public @interface LuBanScan {
    String value();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
@LuBanScan(&amp;quot;com.ssm&amp;quot;)
@Import(MyImportBeanDefinitionRegistrar.class)
public class AppConfig{
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        CardDao cardDao = (CardDao) context.getBean(&amp;quot;cardDao&amp;quot;);
        cardDao.list(&amp;quot;2&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from t1 where a=#{number}
proxy
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;mybatis&#34;&gt;MyBatis&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;userMapper&amp;quot; class=&amp;quot;org.mybatis.spring.mapper.MapperFactoryBean&amp;quot;&amp;gt;
  &amp;lt;property name=&amp;quot;mapperInterface&amp;quot; value=&amp;quot;org.mybatis.spring.sample.mapper.UserMapper&amp;quot; /&amp;gt;
  &amp;lt;property name=&amp;quot;sqlSessionFactory&amp;quot; ref=&amp;quot;sqlSessionFactory&amp;quot; /&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果不想使用 @MapperScan，采用上述代码同样可以完成扫描 mapper 的功能。上述代码不是将 UserMapper 注册给 MapperFactoryBean。&lt;br&gt;
正确含义：MapperFactoryBean 就是前面手动模拟的 MyFactoryBean：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyFactoryBean implements FactoryBean, InvocationHandler {
    Class clazz;
    public MyFactoryBean(Class clazz) {
        this.clazz = clazz;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述的 xml 代码含义：将 UserMapper 作为 Class 参数传递给 MapperFactoryBean，MapperFactoryBean 得到接口后，内部动态生成代理对象。&lt;br&gt;
Mybatis 源码：MapperFactoryBean 内部同样有一个 Class，构造方法 MapperFactoryBean(Class&lt;T&gt; mapperInterface)，是不是与我们模拟的 MyFactoryBean 几乎一样呢？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MapperFactoryBean&amp;lt;T&amp;gt; extends SqlSessionDaoSupport implements FactoryBean&amp;lt;T&amp;gt; {
  private Class&amp;lt;T&amp;gt; mapperInterface;
  private boolean addToConfig = true;
  public MapperFactoryBean() {
    //intentionally empty 
  }
  
  public MapperFactoryBean(Class&amp;lt;T&amp;gt; mapperInterface) {
    this.mapperInterface = mapperInterface;
  }
&lt;/code&gt;&lt;/pre&gt;
">Spring系列（八）Spring源码解析</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/spring-xi-lie-qi-spring-yuan-ma-jie-xi/"" data-c="
          &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      // 初始化 Spring 的环境
      context.refresh();
      IndexDao indexDao = context.getBean(IndexDaoImpl.class);
      indexDao.query();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1new-annotationconfigapplicationcontext&#34;&gt;1.new AnnotationConfigApplicationContext();&lt;/h1&gt;
&lt;p&gt;第 6 行代码，new AnnotationConfigApplicationContext(); 时，由于 AnnotationConfigApplicationContext 有父类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class AnnotationConfigApplicationContext extends GenericApplicationContext implements AnnotationConfigRegistry {
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;11-genericapplicationcontext&#34;&gt;1.1 GenericApplicationContext()&lt;/h2&gt;
&lt;p&gt;所以会先调用父类 GenericApplicationContext  的构造方法（上一篇文章中提到过），今天就从它父类的构造方法说起：实例化了一个 Bean 工厂，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Create a new GenericApplicationContext.
 * @see #registerBeanDefinition
 * @see #refresh
 */
public GenericApplicationContext() {
   // 实例化一个 Bean 工厂
   this.beanFactory = new DefaultListableBeanFactory();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;111-defaultlistablebeanfactory&#34;&gt;1.1.1 DefaultListableBeanFactory&lt;/h3&gt;
&lt;p&gt;这个 Bean 工厂内到底有些什么属性呢，这里列举出几个常用重要属性：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** 从序列化ID映射到工厂实例 */
private static final Map&amp;lt;String, Reference&amp;lt;DefaultListableBeanFactory&amp;gt;&amp;gt; serializableFactories =
      new ConcurrentHashMap&amp;lt;&amp;gt;(8);
/** 该工厂的可选ID，用于序列化 */
// 可以理解为身份证号
@Nullable
private String serializationId;
// 工厂中能够处理类的实例化顺序
@Nullable
private Comparator&amp;lt;Object&amp;gt; dependencyComparator;
// map&amp;lt;beanName,beanDefinition&amp;gt;
private final Map&amp;lt;String, BeanDefinition&amp;gt; beanDefinitionMap = new ConcurrentHashMap&amp;lt;&amp;gt;(256);
/** List of bean definition names, in registration order */
private volatile List&amp;lt;String&amp;gt; beanDefinitionNames = new ArrayList&amp;lt;&amp;gt;(256);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/bean%E5%B7%A5%E5%8E%82.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;12-annotationconfigapplicationcontext&#34;&gt;1.2 AnnotationConfigApplicationContext()&lt;/h2&gt;
&lt;p&gt;调用完父类构造方法后，调用本类构造方法，即&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public AnnotationConfigApplicationContext() {
   /**
    * 父类的构造方法 super()
    *创建一个读取注解的 Bean 定义读取器：reader 能读取被加了注解的类
    * 什么是 bean 定义？BeanDefinition
    */
   this.reader = new AnnotatedBeanDefinitionReader(this);
   // 定义扫描器
   this.scanner = new ClassPathBeanDefinitionScanner(this);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;121-thisreader-new-annotatedbeandefinitionreaderthis&#34;&gt;1.2.1 this.reader = new AnnotatedBeanDefinitionReader(this);&lt;/h3&gt;
&lt;p&gt;我们来看上述代码第 7 行的参数为 this（AnnotatedBeanDefinitionReader），点进这个方法看到参数类型为 BeanDefinitionRegistry，也就是意味着 AnnotatedBeanDefinitionReader = BeanDefinitionRegistry&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry) {
   this(registry, getOrCreateEnvironment(registry));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;1211-annotatedbeandefinitionreaderbeandefinitionregistry-registry-environment-environment&#34;&gt;1.2.1.1 AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment)&lt;/h4&gt;
&lt;p&gt;这里调用了一个重载的构造方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) {
   Assert.notNull(registry, &amp;quot;BeanDefinitionRegistry must not be null&amp;quot;);
   Assert.notNull(environment, &amp;quot;Environment must not be null&amp;quot;);
   this.registry = registry;
   this.conditionEvaluator = new ConditionEvaluator(registry, environment, null);
   AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看第 6 行点进去&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void registerAnnotationConfigProcessors(BeanDefinitionRegistry registry) {
   registerAnnotationConfigProcessors(registry, null);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在点进去第 2 行这个方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static Set&amp;lt;BeanDefinitionHolder&amp;gt; registerAnnotationConfigProcessors(
      BeanDefinitionRegistry registry, @Nullable Object source) {
   // 通过 registry 得到 Bean 工厂
   DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);
   if (beanFactory != null) {
      // AnnotationAwareOrderComparator 主要能解析 @Order 注解和 @Priority
      if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {
         // ContextAnnotationAutowireCandidateResolver 提供处理器延迟加载的功能
         beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);
      }
      if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) {
         beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());
      }
   }
   Set&amp;lt;BeanDefinitionHolder&amp;gt; beanDefs = new LinkedHashSet&amp;lt;&amp;gt;(8);
   // BeanDefinition的注册，这里很重要，需要理解注册每个 bean 的类型
   if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {
      // 需要注意的是 ConfigurationClassPostProcessor 的类型是 BeanDefinitionRegistryPostProcessor
      // 而 BeanDefinitionRegistryPostProcessor 最终实现 BeanFactoryPostProcess
      RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);
      def.setSource(source);
      beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
   }
   if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {
      RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);
      def.setSource(source);
      beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
   }
   if (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {
      RootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);
      def.setSource(source);
      beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
   }
   // Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.
   if (jsr250Present &amp;amp;&amp;amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {
      RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);
      def.setSource(source);
      beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));
   }
   // Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.
   if (jpaPresent &amp;amp;&amp;amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {
      RootBeanDefinition def = new RootBeanDefinition();
      try {
         def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,
               AnnotationConfigUtils.class.getClassLoader()));
      }
      catch (ClassNotFoundException ex) {
         throw new IllegalStateException(
               &amp;quot;Cannot load optional framework class: &amp;quot; + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);
      }
      def.setSource(source);
      beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));
   }
   
   if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {
      RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);
      def.setSource(source);
      beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));
   }
   if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {
      RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);
      def.setSource(source);
      beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));
   }
   return beanDefs;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 24 行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static BeanDefinitionHolder registerPostProcessor(
      BeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName) {
   definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
   registry.registerBeanDefinition(beanName, definition);
   return new BeanDefinitionHolder(definition, beanName);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述第 6 行代码：通过 registry 的 registerBeanDefinition 方法将 &amp;lt;beanName,definition&amp;gt; 放到 map 中：&lt;/p&gt;
&lt;h3 id=&#34;122-thisscanner-new-classpathbeandefinitionscannerthis&#34;&gt;1.2.2 this.scanner = new ClassPathBeanDefinitionScanner(this);&lt;/h3&gt;
&lt;p&gt;继续看本类构造方法的第 9 行，能够扫描一个类，并且转换成 BeanDefinition&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public AnnotationConfigApplicationContext() {
   /**
    * 父类的构造方法 super()
    *创建一个读取注解的 Bean 定义读取器：reader 能读取被加了注解的类
    * 什么是 bean 定义？BeanDefinition
    */
   this.reader = new AnnotatedBeanDefinitionReader(this);
   // 定义扫描器
   this.scanner = new ClassPathBeanDefinitionScanner(this);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2contextregisterappconfigclass&#34;&gt;2.context.register(AppConfig.class);&lt;/h1&gt;
&lt;p&gt;接下来看 Test 测试类的第 10 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;context.register(AppConfig.class);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;点进 register 方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void register(Class&amp;lt;?&amp;gt;... annotatedClasses) {
   Assert.notEmpty(annotatedClasses, &amp;quot;At least one annotated class must be specified&amp;quot;);
   this.reader.register(annotatedClasses);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第 3 行：调用 reader 的 register() 方法，将  AppConfig.class 这个普通的类交给 reader，由 reader 将它转化成 BeanDefinition。那么这个具体的 register 方法是如何实现的呢？点进去这个 register() 方法&lt;/p&gt;
&lt;h2 id=&#34;21-doregisterbean&#34;&gt;2.1 doRegisterBean&lt;/h2&gt;
&lt;p&gt;(中间省略两步代码)最终会到 doRegisterBean 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;T&amp;gt; void doRegisterBean(Class&amp;lt;T&amp;gt; annotatedClass, @Nullable Supplier&amp;lt;T&amp;gt; instanceSupplier, @Nullable String name,
      @Nullable Class&amp;lt;? extends Annotation&amp;gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers) {
   /**
    *
    * AnnotatedGenericBeanDefinition：被注解的 BeanDefinition(描述Bean)
    * 将 bean 放入 map 中，bean 的 name 是 map 的 key，
    * map 中的 value 为 AnnotatedGenericBeanDefinition 对象
    */
   AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass);
   /**
    * 判断这个类是否需要跳过解析
    * 通过代码可以知道 Spring 判断是否跳过解析，主要判断有没有加注解
    */
   // 这个类如果没有加注解，就不需要解析。因为 AnnotatedGenericBeanDefinition 是为了注册被加了注解的；
   // 如果这个类没有被加注解，就跳过不解析
   if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) {
      return;
   }
   abd.setInstanceSupplier(instanceSupplier);
   /**
    * 得到类的作用域
    *     如果是 context.register(SpringConfig.class);则作用域没有什么作用
    *     注册单个类时需要，比如：context.register(IndexService.class);
    */
   ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);
   /**
    * 将类的作用域添加到数据结构中
    */
   abd.setScope(scopeMetadata.getScopeName());
   /**
    * 生成类的名字通过 beanNameGenerator
    */
   String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));
   /**
    * 处理类当中的其他通用注解
    * 分析源码可以知道它主要处理：Lazy、DependsOn、Primary、Role 等注解
    * 处理完成之后 processCommonDefinitionAnnotation 中依然是把它添加到数据结构 AnnotatedGenericBeanDefinition 当中
    */
   AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
   /**
    * 如果在向容器注册注解 @Bean定义时，使用了额外的限定符注解则解析
    * 关于 Qualifier 和 Primary 主要涉及到 Spring 的自动装配
    * 这里需要注意的
    *     beanName 和 qualifier 这个变量时 Annotation 类型的数组，里面不仅仅是 Qualifier 注解
    *     理论上里面存的是一切注解，所以可以看到下面的代码 Spring 去循环了这个数组
    *     然后依次判断注解当中是否包含了 Primary，是否包含了 Lazy
    */
   if (qualifiers != null) {
      for (Class&amp;lt;? extends Annotation&amp;gt; qualifier : qualifiers) {
         if (Primary.class == qualifier) {
            abd.setPrimary(true);
         }
         else if (Lazy.class == qualifier) {
            abd.setLazyInit(true);
         }
         else {
            abd.addQualifier(new AutowireCandidateQualifier(qualifier));
         }
      }
   }
   for (BeanDefinitionCustomizer customizer : definitionCustomizers) {
      customizer.customize(abd);
   }
   /**
    * 这个 BeanDefinitionHolder 也是一个数据结构
    * BeanDefinitionHolder 是一个 map，里面放了一个 (BeanDefinition，beanName)
    */
   BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);
   definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
   /**
    * 把上述的这个数据结构注册给 registry
    * registry 就是 AnnotationConfigApplicationContext
    * AnnotationConfigApplicationContext 在初始化的时候通过调用父类的构造方法实例化了一个 DefaultListableBeanFactory
    * registerBeanDefinition 里面就是把 definitionHolder 这个数据结构包含的信息注册到 DefaultListableBeanFactory 这个工厂
    */
   BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为什么 deoRegisterBean 方法中要解析作用域、其他通用注解等信息？&lt;br&gt;
因为如果 context.register(IndexServiceImpl.class); 参数是 Bean 时，则需要获取 Bean 具体信息然后封装成 BeanDefinition，注册进 map 中。&lt;/p&gt;
&lt;h3 id=&#34;211-new-annotatedgenericbeandefinitionannotatedclass&#34;&gt;2.1.1 new AnnotatedGenericBeanDefinition(annotatedClass);&lt;/h3&gt;
&lt;p&gt;上述第 10 行代码，使用 new AnnotatedGenericBeanDefinition(annotatedClass); 的方式将一个普通的 annotatedClass(AppConfig.class) 转化成 AnnotatedGenericBeanDefinition。&lt;/p&gt;
&lt;h3 id=&#34;212-registerbeandefinitiondefinitionholder-thisregistry&#34;&gt;2.1.2 registerBeanDefinition(definitionHolder, this.registry);&lt;/h3&gt;
&lt;p&gt;上述代码第 80 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;点进 registerBeanDefinition 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void registerBeanDefinition(
      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
      throws BeanDefinitionStoreException {
   // Register bean definition under primary name.
   String beanName = definitionHolder.getBeanName();
   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
   // Register aliases for bean name, if any.
   String[] aliases = definitionHolder.getAliases();
   if (aliases != null) {
      for (String alias : aliases) {
         registry.registerAlias(beanName, alias);
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 7 行，使用 registry 的 registerBeanDefinition 方法将 &amp;lt;beanName,BeanDefinition&amp;gt;注册到 map 中。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/registerBeanDefinition.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/bean%E5%B7%A5%E5%8E%82_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/register_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;3contextrefresh&#34;&gt;3.context.refresh()&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public void refresh() throws BeansException, IllegalStateException {
   synchronized (this.startupShutdownMonitor) {
      // Prepare this context for refreshing.
      // 准备工作包括设置启动时间、是否激活标识位，初始化属性源（property source）配置
      prepareRefresh();
      // 告诉子类 refresh Bean 工厂
      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
      // 用这个上下文准备 Bean 工厂
      prepareBeanFactory(beanFactory);
      try {
         // Allows post-processing of the bean factory in context subclasses.
         postProcessBeanFactory(beanFactory);
         // Invoke factory processors registered as beans in the context.
         invokeBeanFactoryPostProcessors(beanFactory);
         // Register bean processors that intercept bean creation.
         registerBeanPostProcessors(beanFactory);
         // Initialize message source for this context.
         initMessageSource();
         // Initialize event multicaster for this context.
         initApplicationEventMulticaster();
         // Initialize other special beans in specific context subclasses.
         onRefresh();
         // Check for listener beans and register them.
         registerListeners();
         // Instantiate all remaining (non-lazy-init) singletons.
         finishBeanFactoryInitialization(beanFactory);
         // Last step: publish corresponding event.
         finishRefresh();
      }
      catch (BeansException ex) {
         if (logger.isWarnEnabled()) {
            logger.warn(&amp;quot;Exception encountered during context initialization - &amp;quot; +
                  &amp;quot;cancelling refresh attempt: &amp;quot; + ex);
         }
         // Destroy already created singletons to avoid dangling resources.
         destroyBeans();
         // Reset &#39;active&#39; flag.
         cancelRefresh(ex);
         // Propagate exception to caller.
         throw ex;
      }
      finally {
         // Reset common introspection caches in Spring&#39;s core, since we
         // might not ever need metadata for singleton beans anymore...
         resetCommonCaches();
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;31-preparerefresh&#34;&gt;3.1 prepareRefresh();&lt;/h2&gt;
&lt;p&gt;上述第6 行代码：&lt;strong&gt;准备工作包括设置启动时间、是否激活标识位，初始化属性源（property source）配置&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-obtainfreshbeanfactory&#34;&gt;3.2 obtainFreshBeanFactory();&lt;/h2&gt;
&lt;p&gt;上述第 9 行代码：得到 BeanFactory，因为需要对 BeanFactory 进行设置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;33-preparebeanfactorybeanfactory&#34;&gt;3.3 prepareBeanFactory(beanFactory);&lt;/h2&gt;
&lt;p&gt;上述第 12 行代码：准备 Bean 工厂&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;prepareBeanFactory(beanFactory);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;点进这个 prepareBeanFactory 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
   // Tell the internal bean factory to use the context&#39;s class loader etc.
   beanFactory.setBeanClassLoader(getClassLoader());
   // bean 表达式解析器
   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
   // 注册属性编辑器
   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));
   // Configure the bean factory with context callbacks.
   // 添加一个后置管理器：ApplicationContextAwareProcessor 实现了 BeanPostProcessor接口：插手 Bean 的创建过程
   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);
   // BeanFactory interface not registered as resolvable type in a plain factory.
   // MessageSource registered (and found for autowiring) as a bean.
   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
   beanFactory.registerResolvableDependency(ResourceLoader.class, this);
   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
   beanFactory.registerResolvableDependency(ApplicationContext.class, this);
   // Register early post-processor for detecting inner beans as ApplicationListeners.
   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));
   // Detect a LoadTimeWeaver and prepare for weaving, if found.
   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
      // Set a temporary ClassLoader for type matching.
      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
   }
   // Register default environment beans.
   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
   }
   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
   }
   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 3 行，添加一个类加载器：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;beanFactory.setBeanClassLoader(getClassLoader());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 5 行，添加 bean 表达式解析器，为了能够让 BeanFactory 去解析 bean 表达式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//bean 表达式解析器
beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
// 注册属性编辑器
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述 12-17 行，添加了自动注入被忽略的列表：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 27 行，添加了一个 ApplicationListenerDetector 后置处理器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;331-beanfactoryaddbeanpostprocessornew-applicationcontextawareprocessorthis&#34;&gt;3.3.1 beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));&lt;/h3&gt;
&lt;p&gt;上述代码第 11 行，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 添加一个后置管理器：ApplicationContextAwareProcessor 实现了 BeanPostProcessor接口：插手 Bean 的创建过程
beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;点进去 (new ApplicationContextAwareProcessor(this)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public ApplicationContextAwareProcessor(ConfigurableApplicationContext applicationContext) {
   this.applicationContext = applicationContext;
   this.embeddedValueResolver = new EmbeddedValueResolver(applicationContext.getBeanFactory());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在点进去看 beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) {
   Assert.notNull(beanPostProcessor, &amp;quot;BeanPostProcessor must not be null&amp;quot;);
   // Remove from old position, if any
   this.beanPostProcessors.remove(beanPostProcessor);
   // Track whether it is instantiation/destruction aware
   if (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) {
      this.hasInstantiationAwareBeanPostProcessors = true;
   }
   if (beanPostProcessor instanceof DestructionAwareBeanPostProcessor) {
      this.hasDestructionAwareBeanPostProcessors = true;
   }
   // Add to end of list
   this.beanPostProcessors.add(beanPostProcessor);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述 14 行 提到的 beanPostProcessors，是一个 List&lt;BeanPostProcessor&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** BeanPostProcessors to apply in createBean */
private final List&amp;lt;BeanPostProcessor&amp;gt; beanPostProcessors = new CopyOnWriteArrayList&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;34-postprocessbeanfactorybeanfactory&#34;&gt;3.4 postProcessBeanFactory(beanFactory);&lt;/h2&gt;
&lt;p&gt;看 refresh() 看 的第 16 行代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 这个方法在当前版本的 spring 是没有任何代码的
// 可能 Spring 期待在后面的版本中去扩展吧
postProcessBeanFactory(beanFactory);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;35-invokebeanfactorypostprocessorsbeanfactory&#34;&gt;3.5 invokeBeanFactoryPostProcessors(beanFactory);&lt;/h2&gt;
&lt;p&gt;看 refresh() 看 的第 19 行代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;invokeBeanFactoryPostProcessors(beanFactory);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;点进去这个代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
   // 这个地方需要注意 getBeanFactoryPostProcessors() 是获取自定义的
   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
   // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
   // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
   if (beanFactory.getTempClassLoader() == null &amp;amp;&amp;amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;351-getbeanfactorypostprocessors&#34;&gt;3.5.1 getBeanFactoryPostProcessors()&lt;/h3&gt;
&lt;p&gt;看上述第 3 行代码中的 getBeanFactoryPostProcessors()：是获取自定义的（程序员自己写的，并且没有交给 Spring 管理的，就是没有加上 @Component 注解的）&lt;/p&gt;
&lt;p&gt;此时的代码 getBeanFactoryPostProcessors() 运行的结果 size=0。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/getBeanFactoryPostProcessors.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;接下来我们看看什么叫做自定义的？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      // 初始化 Spring 的环境
      context.refresh();
      IndexDao indexDao = context.getBean(IndexDaoImpl.class);
      indexDao.query();
      System.out.println(indexDao);
      System.out.println(context.getBean(IndexDaoImpl.class));
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为 bean 默认是单例的，所以两次 context.getBean()获取的是同一个对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;dao...模拟查询数据库
com.ssm.dao.impl.IndexDaoImpl@47fd17e3
com.ssm.dao.impl.IndexDaoImpl@47fd17e3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;插手 Bean 的初始化过程，将作用域设置为原型的：&lt;/p&gt;
&lt;p&gt;但由于代码未添加 @Component 注解，所以这个类不会生效&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyBeanFactoryProcessor implements BeanFactoryPostProcessor {
   @Override
   public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
      AnnotatedBeanDefinition annotatedBeanDefinition = (AnnotatedBeanDefinition) beanFactory.getBeanDefinition(&amp;quot;indexDao&amp;quot;);
      annotatedBeanDefinition.setScope(&amp;quot;prototype&amp;quot;);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打印效果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;dao...模拟查询数据库
com.ssm.dao.impl.IndexDaoImpl@47fd17e3
com.ssm.dao.impl.IndexDaoImpl@47fd17e3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 refresh() 前 context.addBeanFactoryPostProcessor( new MyBeanFactoryProcessor());&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      context.addBeanFactoryPostProcessor( new MyBeanFactoryProcessor());
      // 初始化 Spring 的环境
      context.refresh();
      IndexDao indexDao = context.getBean(IndexDaoImpl.class);
      indexDao.query();
      System.out.println(indexDao);
      System.out.println(context.getBean(IndexDaoImpl.class));
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即使 MyBeanFactoryProcessor 类并没有添加注解，但是通过 addBeanFactoryPostProcessor 结果显示 IndexDao 对象为原型的了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;dao...模拟查询数据库
com.ssm.dao.impl.IndexDaoImpl@47fd17e3
com.ssm.dao.impl.IndexDaoImpl@7cdbc5d3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结论：&lt;strong&gt;context.addBeanFactoryPostProcessor( new MyBeanFactoryProcessor()); 就称之为自定义的&lt;/strong&gt;。&lt;br&gt;
此时 getBeanFactoryPostProcessors() 执行后的结果 size 不为 0 了。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/getBeanFactoryPostProcessors_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;352-invokebeanfactorypostprocessorsbeanfactory-getbeanfactorypostprocessors&#34;&gt;3.5.2 invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void invokeBeanFactoryPostProcessors(
      ConfigurableListableBeanFactory beanFactory, List&amp;lt;BeanFactoryPostProcessor&amp;gt; beanFactoryPostProcessors) {
   // Invoke BeanDefinitionRegistryPostProcessors first, if any.
   Set&amp;lt;String&amp;gt; processedBeans = new HashSet&amp;lt;&amp;gt;();
   if (beanFactory instanceof BeanDefinitionRegistry) {
      BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
      // 定义 List&amp;lt;BeanFactoryPostProcessor&amp;gt;
      List&amp;lt;BeanFactoryPostProcessor&amp;gt; regularPostProcessors = new ArrayList&amp;lt;&amp;gt;();
       // 定义 List&amp;lt;BeanDefinitionRegistryPostProcessor&amp;gt;
      List&amp;lt;BeanDefinitionRegistryPostProcessor&amp;gt; registryProcessors = new ArrayList&amp;lt;&amp;gt;();
      // 遍历 beanFactoryPostProcessors
      for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
         // 判断如果 postProcessor 是 BeanDefinitionRegistryPostProcessor 类型，就添加到 registryProcessors 中
         if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
            BeanDefinitionRegistryPostProcessor registryProcessor =
                  (BeanDefinitionRegistryPostProcessor) postProcessor;
            registryProcessor.postProcessBeanDefinitionRegistry(registry);
            registryProcessors.add(registryProcessor);
         }
         // 否则，添加到 regularPostProcessors中
         else {
            regularPostProcessors.add(postProcessor);
         }
      }
      // Do not initialize FactoryBeans here: We need to leave all regular beans
      // uninitialized to let the bean factory post-processors apply to them!
      // Separate between BeanDefinitionRegistryPostProcessors that implement
      // PriorityOrdered, Ordered, and the rest.
      // 这个 currentRegistryProcessors 放的是 Spring 内部自己实现了 BeanDefinitionRegistryPostProcessor 接口的对象
      List&amp;lt;BeanDefinitionRegistryPostProcessor&amp;gt; currentRegistryProcessors = new ArrayList&amp;lt;&amp;gt;();
      // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
      String[] postProcessorNames =
            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
            // 这个地方可以得到一个 BeanFactoryPostProcessor，因为是 Spring 默认在最开始自己注册的
            // 为什么要在最开始注册这个呢？
            // 因为 Spring 的工厂需要注解去扫描等等功能
            // 而这些功能都是需要在 Spring 工厂初始化完成之前就执行
            // 要么在工厂最开始的时候，要么在工厂初始化之中，反正不能在之后
            // 因为如果在之后就没有意义，因为那个时候已经需要使用工厂了
            // 所以这里 Spring 在一开始就注册了一个 BeanFactoryPostProcessor，用来插手 springFactory 的实例化过程
            // 在这个地方断点可以知道这个类叫做 ConfigurationClassPostProcessor
            // ConfigurationClassPostProcessor 那么这个类能干嘛呢？可以参考源码
            // 下面对这个“插手 Spirng 工厂实例化过程”的类重点解释
      for (String ppName : postProcessorNames) {
         if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
         }
      }
      // 排序不重要，况且 currentRegistryProcessor 这里也只有一个数据
      sortPostProcessors(currentRegistryProcessors, beanFactory);
      // 合并 List，不重要（为什么要合并，因为有自定义的Spring自己的）
      registryProcessors.addAll(currentRegistryProcessors);
      // 最重要。注意这里是方法调用
      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
      currentRegistryProcessors.clear();
      // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
      for (String ppName : postProcessorNames) {
         if (!processedBeans.contains(ppName) &amp;amp;&amp;amp; beanFactory.isTypeMatch(ppName, Ordered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
         }
      }
      sortPostProcessors(currentRegistryProcessors, beanFactory);
      registryProcessors.addAll(currentRegistryProcessors);
      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
      currentRegistryProcessors.clear();
      // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
      boolean reiterate = true;
      while (reiterate) {
         reiterate = false;
         postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
         for (String ppName : postProcessorNames) {
            if (!processedBeans.contains(ppName)) {
               currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
               processedBeans.add(ppName);
               reiterate = true;
            }
         }
         sortPostProcessors(currentRegistryProcessors, beanFactory);
         registryProcessors.addAll(currentRegistryProcessors);
         invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
         currentRegistryProcessors.clear();
      }
      // Now, invoke the postProcessBeanFactory callback of all processors handled so far.
      invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
      invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
   }
   else {
      // Invoke factory processors registered with the context instance.
      invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
   }
   // Do not initialize FactoryBeans here: We need to leave all regular beans
   // uninitialized to let the bean factory post-processors apply to them!
   String[] postProcessorNames =
         beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);
   // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
   // Ordered, and the rest.
   List&amp;lt;BeanFactoryPostProcessor&amp;gt; priorityOrderedPostProcessors = new ArrayList&amp;lt;&amp;gt;();
   List&amp;lt;String&amp;gt; orderedPostProcessorNames = new ArrayList&amp;lt;&amp;gt;();
   List&amp;lt;String&amp;gt; nonOrderedPostProcessorNames = new ArrayList&amp;lt;&amp;gt;();
   for (String ppName : postProcessorNames) {
      if (processedBeans.contains(ppName)) {
         // skip - already processed in first phase above
      }
      else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
         priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
      }
      else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
         orderedPostProcessorNames.add(ppName);
      }
      else {
         nonOrderedPostProcessorNames.add(ppName);
      }
   }
   // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
   invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);
   // Next, invoke the BeanFactoryPostProcessors that implement Ordered.
   List&amp;lt;BeanFactoryPostProcessor&amp;gt; orderedPostProcessors = new ArrayList&amp;lt;&amp;gt;();
   for (String postProcessorName : orderedPostProcessorNames) {
      orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
   }
   sortPostProcessors(orderedPostProcessors, beanFactory);
   invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);
   // Finally, invoke all other BeanFactoryPostProcessors.
   List&amp;lt;BeanFactoryPostProcessor&amp;gt; nonOrderedPostProcessors = new ArrayList&amp;lt;&amp;gt;();
   for (String postProcessorName : nonOrderedPostProcessorNames) {
      nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
   }
   invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);
   // Clear cached merged bean definitions since the post-processors might have
   // modified the original metadata, e.g. replacing placeholders in values...
   beanFactory.clearMetadataCache();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3521-listbeanfactorypostprocessor-listbeandefinitionregistrypostprocessor&#34;&gt;3.5.2.1  List&lt;BeanFactoryPostProcessor&gt;、List&lt;BeanDefinitionRegistryPostProcessor&gt;&lt;/h4&gt;
&lt;p&gt;看一下上述 10-12 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 定义 List&amp;lt;BeanFactoryPostProcessor&amp;gt;
List&amp;lt;BeanFactoryPostProcessor&amp;gt; regularPostProcessors = new ArrayList&amp;lt;&amp;gt;();
// 定义 List&amp;lt;BeanDefinitionRegistryPostProcessor&amp;gt;
List&amp;lt;BeanDefinitionRegistryPostProcessor&amp;gt; registryProcessors = new ArrayList&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为什么定义两个 List？&lt;br&gt;
自己定义的 BeanFactoryProcessor可以有两种方式：&lt;/p&gt;
&lt;p&gt;1.实现 BeanFactoryPostProcessor 接口&lt;/p&gt;
&lt;p&gt;2.实现BeanDefinitionRegistryPostProcessor接口&lt;/p&gt;
&lt;p&gt;因为 BeanDefinitionRegistryPostProcessor 实现了 BeanFactoryPostProcessor 接口&lt;/p&gt;
&lt;p&gt;于是可以猜想实现 bdrp 和实现 bfp 是能够完成不同的功能，&lt;/p&gt;
&lt;p&gt;因为 bdrp 是子类，子类肯定扩展了父类中的功能。&lt;/p&gt;
&lt;p&gt;父类 BeanFactoryPostProcessor  中有一个 postProcessBeanFactory 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@FunctionalInterface
public interface BeanFactoryPostProcessor {
   void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;子类 BeanDefinitionRegistryPostProcessor  扩展了一个 postProcessBeanDefinitionRegistry() 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor {
   void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3522-getbeannamesfortype&#34;&gt;3.5.2.2 getBeanNamesForType&lt;/h4&gt;
&lt;p&gt;上述 invokeBeanFactoryPostProcessors 方法的第 37-54 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String[] postProcessorNames =
      beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
for (String ppName : postProcessorNames) {
   if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
      currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
      processedBeans.add(ppName);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;getBeanNamesForType：这个方法是 beanFactory 中的方法，顾名思义，这个方法能够得到通过类得到 bean名字，这里的 Type 指的是 bd 当中描述当前类的 Class 类型。&lt;br&gt;
beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false)：获取 Type 为 BeanDefinitionRegistryPostProcessor 对应的 bean 名字。&lt;/p&gt;
&lt;p&gt;我们先来查看当前工厂的 map 中有哪些&amp;lt;beanName, beanDefinition&amp;gt;，之前说过在执行 register() 时向容器内添加了 7 个对象，我们看到有一个 BeanClass 为 ConfigurationClassPostProcessor 的类&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/ConfigurationClassPostProcessor.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;我们发现 ConfigurationClassPostProcessor 类实现了 BeanDefinitionRegistryPostProcessor 接口：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ConfigurationClassPostProcessor implements BeanDefinitionRegistryPostProcessor,
      PriorityOrdered, ResourceLoaderAware, BeanClassLoaderAware, EnvironmentAware {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以 beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); 就把 ConfigurationClassPostProcessor  类（Spring 内部自己定义的）拿出来了。&lt;/p&gt;
&lt;h4 id=&#34;3523-invokebeandefinitionregistrypostprocessors&#34;&gt;3.5.2.3 invokeBeanDefinitionRegistryPostProcessors&lt;/h4&gt;
&lt;p&gt;上述 invokeBeanFactoryPostProcessors 方法的第 60 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们点进这个 invokeBeanDefinitionRegistryPostProcessors 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static void invokeBeanDefinitionRegistryPostProcessors(
      Collection&amp;lt;? extends BeanDefinitionRegistryPostProcessor&amp;gt; postProcessors, BeanDefinitionRegistry registry) {
   // 循环所有的 BeanDefinitionRegistryPostProcessor
   for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
      postProcessor.postProcessBeanDefinitionRegistry(registry);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 5 行点进去：调用 BeanDefinitionRegistryPostProcessor&lt;br&gt;
扩展父类的方法 postProcessBeanDefinitionRegistry()：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
   int registryId = System.identityHashCode(registry);
   if (this.registriesPostProcessed.contains(registryId)) {
      throw new IllegalStateException(
            &amp;quot;postProcessBeanDefinitionRegistry already called on this post-processor against &amp;quot; + registry);
   }
   if (this.factoriesPostProcessed.contains(registryId)) {
      throw new IllegalStateException(
            &amp;quot;postProcessBeanFactory already called on this post-processor against &amp;quot; + registry);
   }
   this.registriesPostProcessed.add(registryId);
   processConfigBeanDefinitions(registry);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 14 行点进去：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
   // app 提供的 bean
   List&amp;lt;BeanDefinitionHolder&amp;gt; configCandidates = new ArrayList&amp;lt;&amp;gt;();
   // 获取容器中注册的所有 bean 名字
   String[] candidateNames = registry.getBeanDefinitionNames();
   // 依次取出每个&amp;lt;beanName,beanDefinition&amp;gt;
   for (String beanName : candidateNames) {
      BeanDefinition beanDef = registry.getBeanDefinition(beanName);
      // 判断当前 bean 是否被处理过：使用 isFullConfigurationClass 来标识
      if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
            ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {
         // 如果 BeanDefinition 中的 configurationClass 属性为 full 或者 lite，则意味着已经处理过了，直接跳过
         // 这里需要结合下面的代码才能理解
         if (logger.isDebugEnabled()) {
            logger.debug(&amp;quot;Bean definition has already been processed as a configuration class: &amp;quot; + beanDef);
         }
      }
      // 判断这个 BeanDefinition 是否包含了 @Configuration、@Service 注解
      else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
         configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
      }
   }
   // Return immediately if no @Configuration classes were found
   if (configCandidates.isEmpty()) {
      return;
   }
    
   // 排序，根据 order，不重要
   // Sort by previously determined @Order value, if applicable
   configCandidates.sort((bd1, bd2) -&amp;gt; {
      int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
      int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
      return Integer.compare(i1, i2);
   });
   // Detect any custom bean name generation strategy supplied through the enclosing application context
   SingletonBeanRegistry sbr = null;
   // 如果 BeanDefinitionRegistry 是 SingletonBeanRegistry 子类的话
   // 由于会将 registry 强转为 SingletonBeanRegistry
   if (registry instanceof SingletonBeanRegistry) {
      sbr = (SingletonBeanRegistry) registry;
      if (!this.localBeanNameGeneratorSet) {
         BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);
         // SingletonBeanRegistry 中有 id 为 org.springframework.context.annotation.internalConfigurationBeanNameGenerator
         // 如果有则利用它的，否则则使用 Spring 默认的
         if (generator != null) {
            this.componentScanBeanNameGenerator = generator;
            this.importBeanNameGenerator = generator;
         }
      }
   }
   if (this.environment == null) {
      this.environment = new StandardEnvironment();
   }
   // Parse each @Configuration class
   // 实例化 ConfigurationClassParser 为了解析各个配置类
   ConfigurationClassParser parser = new ConfigurationClassParser(
         this.metadataReaderFactory, this.problemReporter, this.environment,
         this.resourceLoader, this.componentScanBeanNameGenerator, registry);
         
   // 实例化 2 个 set，candidates 用于将之前加入的 configCandidates 进行去重
   // 因为可能有多个配置类重复了
   // alreadyParsed 用户判断是否处理过
   Set&amp;lt;BeanDefinitionHolder&amp;gt; candidates = new LinkedHashSet&amp;lt;&amp;gt;(configCandidates);
   Set&amp;lt;ConfigurationClass&amp;gt; alreadyParsed = new HashSet&amp;lt;&amp;gt;(configCandidates.size());
   do {
      parser.parse(candidates);
      parser.validate();
      Set&amp;lt;ConfigurationClass&amp;gt; configClasses = new LinkedHashSet&amp;lt;&amp;gt;(parser.getConfigurationClasses());
      configClasses.removeAll(alreadyParsed);
      // Read the model and create bean definitions based on its content
      if (this.reader == null) {
         this.reader = new ConfigurationClassBeanDefinitionReader(
               registry, this.sourceExtractor, this.resourceLoader, this.environment,
               this.importBeanNameGenerator, parser.getImportRegistry());
      }
      // 把扫描出来的 bean 对应的 beanDefinitions 添加到 factory 的 map 当中
      this.reader.loadBeanDefinitions(configClasses);
      alreadyParsed.addAll(configClasses);
      candidates.clear();
      if (registry.getBeanDefinitionCount() &amp;gt; candidateNames.length) {
         String[] newCandidateNames = registry.getBeanDefinitionNames();
         Set&amp;lt;String&amp;gt; oldCandidateNames = new HashSet&amp;lt;&amp;gt;(Arrays.asList(candidateNames));
         Set&amp;lt;String&amp;gt; alreadyParsedClasses = new HashSet&amp;lt;&amp;gt;();
         for (ConfigurationClass configurationClass : alreadyParsed) {
            alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
         }
         for (String candidateName : newCandidateNames) {
            if (!oldCandidateNames.contains(candidateName)) {
               BeanDefinition bd = registry.getBeanDefinition(candidateName);
               if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;amp;&amp;amp;
                     !alreadyParsedClasses.contains(bd.getBeanClassName())) {
                  candidates.add(new BeanDefinitionHolder(bd, candidateName));
               }
            }
         }
         candidateNames = newCandidateNames;
      }
   }
   while (!candidates.isEmpty());
   // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes
   if (sbr != null &amp;amp;&amp;amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {
      sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
   }
   if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {
      // Clear cache in externally provided MetadataReaderFactory; this is a no-op
      // for a shared cache since it&#39;ll be cleared by the ApplicationContext.
      ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/candidateNames.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上述 processConfigBeanDefinitions 方法第 18-21 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;      // 判断这个 BeanDefinition 是否包含了 @Configuration、@Service 注解
      else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
         configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
      }      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;checkConfigurationClassCandidate&lt;br&gt;
先来看上述第二行调用 checkConfigurationClassCandidate 方法判断是否加了 @Configuration 注解，checkConfigurationClassCandidate 方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static boolean checkConfigurationClassCandidate(BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) {
   String className = beanDef.getBeanClassName();
   if (className == null || beanDef.getFactoryMethodName() != null) {
      return false;
   }
   AnnotationMetadata metadata;
   if (beanDef instanceof AnnotatedBeanDefinition &amp;amp;&amp;amp;
         className.equals(((AnnotatedBeanDefinition) beanDef).getMetadata().getClassName())) {
      // Can reuse the pre-parsed metadata from the given BeanDefinition...
      // 如果 BeanDefinition 是 AnnotatedBeanDefinition 的实例，并且 className 和 BeanDefinition 中的元数据的类名相同
      // 则直接从 BeanDefinition 获得元数据Metadata
      metadata = ((AnnotatedBeanDefinition) beanDef).getMetadata();
   }
   else if (beanDef instanceof AbstractBeanDefinition &amp;amp;&amp;amp; ((AbstractBeanDefinition) beanDef).hasBeanClass()) {
      // Check already loaded Class if present...
      // since we possibly can&#39;t even load the class file for this Class.
      Class&amp;lt;?&amp;gt; beanClass = ((AbstractBeanDefinition) beanDef).getBeanClass();
      metadata = new StandardAnnotationMetadata(beanClass, true);
   }
   else {
      try {
         MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);
         metadata = metadataReader.getAnnotationMetadata();
      }
      catch (IOException ex) {
         if (logger.isDebugEnabled()) {
            logger.debug(&amp;quot;Could not find class file for introspecting configuration annotations: &amp;quot; + className, ex);
         }
         return false;
      }
   }
  
   // 判断当前这个 bd 中存在的类是不是加了 @Configuration 注解
   if (isFullConfigurationCandidate(metadata)) {
      // 如果存在 Configuration 注解，则为 BeanDefinition 设置 configurationClass 属性为 FULL，结合 processConfigBeanDefinitions 方法的第 10 行，使用 isFullConfigurationClass 判断是否处理过
      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);
   }
   // 判断是否加了以下注解，摘录 isLiteConfigurationCandidate 的源码
   // candidateIndicators.add(Component.class.getName());
   // candidateIndicators.add(ComponentScan.class.getName());
   // candidateIndicators.add(Import.class.getName());
   // candidateIndicators.add(ImportResource.class.getName());
   else if (isLiteConfigurationCandidate(metadata)) {
      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
   }
   else {
      return false;
   }
   // It&#39;s a full or lite configuration candidate... Let&#39;s determine the order value, if any.
   // 得到排序：如果有多个加了 @Configuration 的类，根据 @Order进行排序决定解析顺序
   Integer order = getOrder(metadata);
   if (order != null) {
      beanDef.setAttribute(ORDER_ATTRIBUTE, order);
   }
   return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 35 行，判断当前这个 bd 中存在的类是不是加了 @Configuration 注解：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static boolean isFullConfigurationCandidate(AnnotationMetadata metadata) {
   return metadata.isAnnotated(Configuration.class.getName());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述 checkConfigurationClassCandidate 方法第 44-46 行，判断是否加了其他注解&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 判断是否加了以下注解，摘录 isLiteConfigurationCandidate 的源码
// candidateIndicators.add(Component.class.getName());
// candidateIndicators.add(ComponentScan.class.getName());
// candidateIndicators.add(Import.class.getName());
// candidateIndicators.add(ImportResource.class.getName());
  else if (isLiteConfigurationCandidate(metadata)) {
      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;点进 isLiteConfigurationCandidate 方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static boolean isLiteConfigurationCandidate(AnnotationMetadata metadata) {
   // Do not consider an interface or an annotation...
   if (metadata.isInterface()) {
      return false;
   }
   // Any of the typical annotations found?
   for (String indicator : candidateIndicators) {
      if (metadata.isAnnotated(indicator)) {
         return true;
      }
   }
   // Finally, let&#39;s look for @Bean methods...
   try {
      return metadata.hasAnnotatedMethods(Bean.class.getName());
   }
   catch (Throwable ex) {
      if (logger.isDebugEnabled()) {
         logger.debug(&amp;quot;Failed to introspect @Bean methods on class [&amp;quot; + metadata.getClassName() + &amp;quot;]: &amp;quot; + ex);
      }
      return false;
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/candidateIndicators.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;processConfigBeanDefinitions 方法的第 62 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;parser.parse(candidates);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;点进这个 parse 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void parse(Set&amp;lt;BeanDefinitionHolder&amp;gt; configCandidates) {
   this.deferredImportSelectors = new LinkedList&amp;lt;&amp;gt;();
   // 根据 BeanDefinition 的类型做不同的处理，一般都会调用 ConfigurationClassParse#parse 进行解析
   for (BeanDefinitionHolder holder : configCandidates) {
      BeanDefinition bd = holder.getBeanDefinition();
      try {
         // 判断这个 bd 是否被加了注解
         if (bd instanceof AnnotatedBeanDefinition) {
            parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
         }
         else if (bd instanceof AbstractBeanDefinition &amp;amp;&amp;amp; ((AbstractBeanDefinition) bd).hasBeanClass()) {
            parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
         }
         else {
            parse(bd.getBeanClassName(), holder.getBeanName());
         }
      }
      catch (BeanDefinitionStoreException ex) {
         throw ex;
      }
      catch (Throwable ex) {
         throw new BeanDefinitionStoreException(
               &amp;quot;Failed to parse configuration class [&amp;quot; + bd.getBeanClassName() + &amp;quot;]&amp;quot;, ex);
      }
   }
   processDeferredImportSelectors();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再点进上述代码第 9 行的 parse 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {
   processConfigurationClass(new ConfigurationClass(metadata, beanName));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第二行调用了 processConfigurationClass 方法，点进去：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
   // 判断是否应该跳过解析
   if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
      return;
   }
   // 处理 Imported 的情况
   ConfigurationClass existingClass = this.configurationClasses.get(configClass);
   if (existingClass != null) {
      if (configClass.isImported()) {
         if (existingClass.isImported()) {
            existingClass.mergeImportedBy(configClass);
         }
         // Otherwise ignore new imported config class; existing non-imported class overrides it.
         return;
      }
      else {
         // Explicit bean definition found, probably replacing an import.
         // Let&#39;s remove the old one and go with the new one.
         this.configurationClasses.remove(configClass);
         this.knownSuperclasses.values().removeIf(configClass::equals);
      }
   }
   // Recursively process the configuration class and its superclass hierarchy.
   SourceClass sourceClass = asSourceClass(configClass);
   do {
      sourceClass = doProcessConfigurationClass(configClass, sourceClass);
   }
   while (sourceClass != null);
   
   // 一个 map，用来存放扫描出来的 bean（注意这里的 bean 不是对象，仅仅是 bean 的信息，因为还没到实例化）
   this.configurationClasses.put(configClass, configClass);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;doProcessConfigurationClass&lt;/p&gt;
&lt;p&gt;看上述第 28 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;sourceClass = doProcessConfigurationClass(configClass, sourceClass);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;点进这个 doProcessConfigurationClass 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Nullable
protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)
      throws IOException {
   // Recursively process any member (nested) classes first
   // 处理内部类
   processMemberClasses(configClass, sourceClass);
   // Process any @PropertySource annotations
   for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
         sourceClass.getMetadata(), PropertySources.class,
         org.springframework.context.annotation.PropertySource.class)) {
      if (this.environment instanceof ConfigurableEnvironment) {
         processPropertySource(propertySource);
      }
      else {
         logger.warn(&amp;quot;Ignoring @PropertySource annotation on [&amp;quot; + sourceClass.getMetadata().getClassName() +
               &amp;quot;]. Reason: Environment must implement ConfigurableEnvironment&amp;quot;);
      }
   }
   // Process any @ComponentScan annotations
   Set&amp;lt;AnnotationAttributes&amp;gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(
         sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
   if (!componentScans.isEmpty() &amp;amp;&amp;amp;
         !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
      for (AnnotationAttributes componentScan : componentScans) {
         // The config class is annotated with @ComponentScan -&amp;gt; perform the scan immediately
         Set&amp;lt;BeanDefinitionHolder&amp;gt; scannedBeanDefinitions =
               this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
         // Check the set of scanned definitions for any further config classes and parse recursively if needed
         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
            BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
            if (bdCand == null) {
               bdCand = holder.getBeanDefinition();
            }
            if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
               parse(bdCand.getBeanClassName(), holder.getBeanName());
            }
         }
      }
   }
   // Process any @Import annotations
   processImports(configClass, sourceClass, getImports(sourceClass), true);
   // Process any @ImportResource annotations
   AnnotationAttributes importResource =
         AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
   if (importResource != null) {
      String[] resources = importResource.getStringArray(&amp;quot;locations&amp;quot;);
      Class&amp;lt;? extends BeanDefinitionReader&amp;gt; readerClass = importResource.getClass(&amp;quot;reader&amp;quot;);
      for (String resource : resources) {
         String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
         configClass.addImportedResource(resolvedResource, readerClass);
      }
   }
   // Process individual @Bean methods
   Set&amp;lt;MethodMetadata&amp;gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
   for (MethodMetadata methodMetadata : beanMethods) {
      configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
   }
   // Process default methods on interfaces
   processInterfaces(configClass, sourceClass);
   // Process superclass, if any
   if (sourceClass.getMetadata().hasSuperClass()) {
      String superclass = sourceClass.getMetadata().getSuperClassName();
      if (superclass != null &amp;amp;&amp;amp; !superclass.startsWith(&amp;quot;java&amp;quot;) &amp;amp;&amp;amp;
            !this.knownSuperclasses.containsKey(superclass)) {
         this.knownSuperclasses.put(superclass, configClass);
         // Superclass found, return its annotation metadata and recurse
         return sourceClass.getSuperClass();
      }
   }
   // No superclass -&amp;gt; processing is complete
   return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 23-24 行，获得带有 @ComponentScan 注解的类&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/ComponentScan.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;上述代码第 30 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再点进去这个 parse 方法：真正解析扫描包的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Set&amp;lt;BeanDefinitionHolder&amp;gt; parse(AnnotationAttributes componentScan, final String declaringClass) {
   ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,
         componentScan.getBoolean(&amp;quot;useDefaultFilters&amp;quot;), this.environment, this.resourceLoader);
   
   // 看有没有自定义外部 Bean 生命器
   Class&amp;lt;? extends BeanNameGenerator&amp;gt; generatorClass = componentScan.getClass(&amp;quot;nameGenerator&amp;quot;);
   boolean useInheritedGenerator = (BeanNameGenerator.class == generatorClass);
   scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator :
         BeanUtils.instantiateClass(generatorClass));
   // 判断这个类是不是代理的
   ScopedProxyMode scopedProxyMode = componentScan.getEnum(&amp;quot;scopedProxy&amp;quot;);
   if (scopedProxyMode != ScopedProxyMode.DEFAULT) {
      scanner.setScopedProxyMode(scopedProxyMode);
   }
   else {
      Class&amp;lt;? extends ScopeMetadataResolver&amp;gt; resolverClass = componentScan.getClass(&amp;quot;scopeResolver&amp;quot;);
      scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));
   }
   scanner.setResourcePattern(componentScan.getString(&amp;quot;resourcePattern&amp;quot;));
   for (AnnotationAttributes filter : componentScan.getAnnotationArray(&amp;quot;includeFilters&amp;quot;)) {
      for (TypeFilter typeFilter : typeFiltersFor(filter)) {
         scanner.addIncludeFilter(typeFilter);
      }
   }
   for (AnnotationAttributes filter : componentScan.getAnnotationArray(&amp;quot;excludeFilters&amp;quot;)) {
      for (TypeFilter typeFilter : typeFiltersFor(filter)) {
         scanner.addExcludeFilter(typeFilter);
      }
   }
   boolean lazyInit = componentScan.getBoolean(&amp;quot;lazyInit&amp;quot;);
   if (lazyInit) {
      scanner.getBeanDefinitionDefaults().setLazyInit(true);
   }
   Set&amp;lt;String&amp;gt; basePackages = new LinkedHashSet&amp;lt;&amp;gt;();
   String[] basePackagesArray = componentScan.getStringArray(&amp;quot;basePackages&amp;quot;);
   for (String pkg : basePackagesArray) {
      String[] tokenized = StringUtils.tokenizeToStringArray(this.environment.resolvePlaceholders(pkg),
            ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);
      Collections.addAll(basePackages, tokenized);
   }
   for (Class&amp;lt;?&amp;gt; clazz : componentScan.getClassArray(&amp;quot;basePackageClasses&amp;quot;)) {
      basePackages.add(ClassUtils.getPackageName(clazz));
   }
   if (basePackages.isEmpty()) {
      basePackages.add(ClassUtils.getPackageName(declaringClass));
   }
    
   // 得到 excludeFilter 设置的排除扫描的包
   scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {
      @Override
      protected boolean matchClassName(String className) {
         return declaringClass.equals(className);
      }
   });
   return scanner.doScan(StringUtils.toStringArray(basePackages));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 60 行的 doScan 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected Set&amp;lt;BeanDefinitionHolder&amp;gt; doScan(String... basePackages) {
   Assert.notEmpty(basePackages, &amp;quot;At least one base package must be specified&amp;quot;);
   Set&amp;lt;BeanDefinitionHolder&amp;gt; beanDefinitions = new LinkedHashSet&amp;lt;&amp;gt;();
   for (String basePackage : basePackages) {
      // 扫表 basePackage 路径下的 java 文件
      // 并把它转成 BeanDefinition 类型
      Set&amp;lt;BeanDefinition&amp;gt; candidates = findCandidateComponents(basePackage);
      for (BeanDefinition candidate : candidates) {
         // 解析 scope 属性
         ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
         candidate.setScope(scopeMetadata.getScopeName());
         String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
         if (candidate instanceof AbstractBeanDefinition) {
            // 如果这个类是 AbstractBeanDefinition 的子类
            // 则为它设置默认值，比如 alzy，init destroy
            postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
         }
         if (candidate instanceof AnnotatedBeanDefinition) {
            // 检查并且处理常用的注解
            // 这里的处理主要是指把常用注解的值设置到 AnnotatedBeanDefinition 当中
            // 当前前提是这个类必须是 AnnotatedBeanDefinition 类型的，说白了就是加了注解的类
            AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
         }
         if (checkCandidate(beanName, candidate)) {
            BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
            definitionHolder =
                  AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
            beanDefinitions.add(definitionHolder);
            // 就是在这个方法中，将扫描包的 Bean 添加到 map 中
            registerBeanDefinition(definitionHolder, this.registry);
         }
      }
   }
   return beanDefinitions;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 7 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Set&amp;lt;BeanDefinition&amp;gt; findCandidateComponents(String basePackage) {
   if (this.componentsIndex != null &amp;amp;&amp;amp; indexSupportsIncludeFilters()) {
      return addCandidateComponentsFromIndex(this.componentsIndex, basePackage);
   }
   else {
      return scanCandidateComponents(basePackage);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码第 6 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Set&amp;lt;BeanDefinition&amp;gt; scanCandidateComponents(String basePackage) {
   Set&amp;lt;BeanDefinition&amp;gt; candidates = new LinkedHashSet&amp;lt;&amp;gt;();
   try {
      String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
            resolveBasePackage(basePackage) + &#39;/&#39; + this.resourcePattern;
      Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);
      boolean traceEnabled = logger.isTraceEnabled();
      boolean debugEnabled = logger.isDebugEnabled();
      for (Resource resource : resources) {
         if (traceEnabled) {
            logger.trace(&amp;quot;Scanning &amp;quot; + resource);
         }
         if (resource.isReadable()) {
            try {
               MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);
               if (isCandidateComponent(metadataReader)) {
                  ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
                  sbd.setSource(resource);
                  if (isCandidateComponent(sbd)) {
                     if (debugEnabled) {
                        logger.debug(&amp;quot;Identified candidate component class: &amp;quot; + resource);
                     }
                     candidates.add(sbd);
                  }
                  else {
                     if (debugEnabled) {
                        logger.debug(&amp;quot;Ignored because not a concrete top-level class: &amp;quot; + resource);
                     }
                  }
               }
               else {
                  if (traceEnabled) {
                     logger.trace(&amp;quot;Ignored because not matching any filter: &amp;quot; + resource);
                  }
               }
            }
            catch (Throwable ex) {
               throw new BeanDefinitionStoreException(
                     &amp;quot;Failed to read candidate component class: &amp;quot; + resource, ex);
            }
         }
         else {
            if (traceEnabled) {
               logger.trace(&amp;quot;Ignored because not readable: &amp;quot; + resource);
            }
         }
      }
   }
   catch (IOException ex) {
      throw new BeanDefinitionStoreException(&amp;quot;I/O failure during classpath scanning&amp;quot;, ex);
   }
   return candidates;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/parse%E5%89%8D.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/parse%E5%90%8E.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/bean%E5%B7%A5%E5%8E%82_3.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;spring-bean-的扩展&#34;&gt;Spring Bean 的扩展&lt;/h1&gt;
&lt;h2 id=&#34;beandefinitionregistrypostprocessor&#34;&gt;BeanDefinitionRegistryPostProcessor&lt;/h2&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//实例化一个工厂DefaultListableBeanFactory

org.springframework.context.support.GenericApplicationContext-&amp;gt;GenericApplicationContext()

  	1、实例化一个AnnotatedBeanDefinitionReader

	2、ClassPathBeanDefinitionScanner，能够扫描我们bd,能够扫描一个类，并且转换成bd
	
	org.springframework.context.annotation.AnnotationConfigApplicationContext#AnnotationConfigApplicationContext()
	
		委托AnnotationConfigUtils
	
		org.springframework.context.annotation.AnnotatedBeanDefinitionReader#AnnotatedBeanDefinitionReader()


​			

			org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors()


​			

				1、添加AnnotationAwareOrderComparator类的对象，主要去排序
	
				2、ContextAnnotationAutowireCandidateResolver
	
				3、往BeanDefinitionMap注册一个ConfigurationClassPostProcessor?  org.springframework.context.annotation.internalConfigurationAnnotationProcessor
	
					why?因为需要在invokeBeanFactoryPostProcessors
	
					invokeBeanFactoryPostProcessors主要是在spring的beanFactory初始化的过程中去做一些事情，怎么来做这些事情呢？
	
					委托了多个实现了BeanDefinitionRegistryPostProcessor或者BeanFactoryProcessor接口的类来做这些事情,有自定义的也有spring内部的
	
					其中ConfigurationClassPostProcessor就是一个spring内部的BeanDefinitionRegistryPostProcessor
	
					因为如果你不添加这里就没有办法委托ConfigurationClassPostProcessor做一些功能
	
					到底哪些功能？参考下面的注释
	
				4、RequiredAnnotationBeanPostProcessor
	
				.......
	
				org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors()
	
					//往BeanDefinitionMap注册
	
					org.springframework.context.annotation.AnnotationConfigUtils#registerPostProcessor
	
						//准备好bean工厂，实例化对象
	
						org.springframework.context.support.AbstractApplicationContext#refresh
	
						//准备工作包括设置启动时间，是否激活标识位， 初始化属性源(property source)配置
	
							org.springframework.context.support.AbstractApplicationContext#prepareRefresh
	
								//得到beanFactory?因为需要对beanFactory进行设置
	
								org.springframework.context.support.AbstractApplicationContext#obtainFreshBeanFactory
	
									//准备bean工厂
	
									1、添加一个类加载器
	
									2、添加bean表达式解释器，为了能够让我们的beanFactory去解析bean表达式
	
									3、添加一个后置处理器ApplicationContextAwareProcessor
	
									4、添加了自动注入别忽略的列表
	
									5、。。。。。。
	
									6、添加了一个ApplicationListenerDetector后置处理器（自行百度）
	
									org.springframework.context.support.AbstractApplicationContext#prepareBeanFactory
	
										目前没有任何实现
	
										org.springframework.context.support.AbstractApplicationContext#postProcessBeanFactory
	
											1、getBeanFactoryPostProcessors()得到自己定义的（就是程序员自己写的，并且没有交给spring管理，就是没有加上@Component）
	
											2、得到spring内部自己维护的BeanDefinitionRegistryPostProcessor
	
											org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors
	
												//调用这个方法
	
												//循环所有的BeanDefinitionRegistryPostProcessor
	
												//该方法内部postProcessor.postProcessBeanDefinitionRegistry
	
												org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanDefinitionRegistryPostProcessors
	
													//调用扩展方法postProcessBeanDefinitionRegistry
	
													org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry
	
														//拿出的所有bd，然后判断bd时候包含了@Configuration、@Import，@Compent。。。注解
	
														org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions
	
															1、的到bd当中描述的类的元数据（类的信息）
	
															2、判断是不是加了@Configuration   metadata.isAnnotated(Configuration.class.getName())
	
															3、如果加了@Configuration，添加到一个set当中,把这个set传给下面的方法去解析
	
															org.springframework.context.annotation.ConfigurationClassUtils#checkConfigurationClassCandidate
	
															//扫描包


​															

															org.springframework.context.annotation.ConfigurationClassParser#parse(java.util.Set&amp;lt;org.springframework.beans.factory.config.BeanDefinitionHolder&amp;gt;)


​																

																org.springframework.context.annotation.ConfigurationClassParser#parse(org.springframework.core.type.AnnotationMetadata, java.lang.String)
	
																	//就行了一个类型封装
	
																	org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass
	
																	1、处理内部类 一般不会写内部类
	
																	org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass
	
																		//解析扫描的一些基本信息，比如是否过滤，比如是否加入新的包。。。。。
	
																		org.springframework.context.annotation.ComponentScanAnnotationParser#parse
	
																			org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan
	
																			org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#findCandidateComponents
	
																				org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#scanCandidateComponents
&lt;/code&gt;&lt;/pre&gt;
">Spring系列（七）Spring源码解析</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/spring-xi-lie-liu-spring-yuan-ma-jie-xi/"" data-c="
          &lt;h1 id=&#34;先来写一个简单的-spring-案例&#34;&gt;先来写一个简单的 spring 案例：&lt;/h1&gt;
&lt;p&gt;1.准备一个接口和实现类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface IndexDao {
   void query();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接口实现类添加 @Reposity 表示把这个对象交给 Spring 管理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Repository(&amp;quot;indexDao&amp;quot;)
public class IndexDaoImpl implements IndexDao {

   @Override
   public void query() {
      System.out.println(&amp;quot;dao...模拟查询数据库&amp;quot;);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.准备一个配置文件类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 表名这是一个配置类
@Configuration
// 扫描包
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
public class AppConfig {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.准备一个简单的测试类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读取配置文件&lt;/li&gt;
&lt;li&gt;通过 getBean(&amp;quot;xxx&amp;quot;) 获得 Bean 对象&lt;/li&gt;
&lt;li&gt;调用 Bean 对象的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.读取配置文件
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext(AppConfig.class);
      // 2.获得 Bean 对象 
      IndexDao indexDao = context.getBean(IndexDao.class);
      // 3.调用方法
      indexDao.query();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.测试结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dao...模拟查询数据库
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;new-annotationconfigapplicationcontextappconfigclass&#34;&gt;new AnnotationConfigApplicationContext(AppConfig.class);&lt;/h1&gt;
&lt;p&gt;从测试类 Test 开始看，测试类的第 5 行读取配置文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;于是点进 AnnotationConfigApplicationContext(AppConfig.class); 构造方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public AnnotationConfigApplicationContext(Class&amp;lt;?&amp;gt;... annotatedClasses) {
   // 这里由于它有父类，故而会先调用父类的构造方法，然后才会调用自己的构造方法
   // 在自己的构造方法中初始一个读取器和扫描器
   this();
   register(annotatedClasses);
   refresh();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;AnnotationConfigApplicationContext 有父类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class AnnotationConfigApplicationContext extends GenericApplicationContext implements AnnotationConfigRegistry {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析 AnnotationConfigApplicationContext 的有参 Class&amp;lt;?&amp;gt;... 构造方法，一行行看，先看第 4 行代码：this()：调用本类的构造方法，但是由于 AnnotationConfigApplicationContext  有父类，于是&lt;strong&gt;先调用父类的构造方法&lt;/strong&gt;，我们这里先看本类的构造方法。&lt;/p&gt;
&lt;h2 id=&#34;annotationconfigapplicationcontext&#34;&gt;AnnotationConfigApplicationContext()&lt;/h2&gt;
&lt;p&gt;第 7 行，创建了一个 AnnotatedBeanDefinitionReader 并赋值给 reader，那这个 reader 是什么呢？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public AnnotationConfigApplicationContext() {
   /**
    * 父类的构造方法 super()
    * 创建一个读取注解的 Bean 定义读取器：reader 能读取被加了注解的类
    * 什么是 bean 定义？BeanDefinition
    */
   this.reader = new AnnotatedBeanDefinitionReader(this);
   // 定义扫描器
   this.scanner = new ClassPathBeanDefinitionScanner(this);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;annotatedbeandefinitionreader&#34;&gt;AnnotatedBeanDefinitionReader&lt;/h3&gt;
&lt;p&gt;reader 是一个 AnnotatedBeanDefinitionReader 类型的变量，顾名思义，reader 是一个读取器，并且 AnnotatedBeanDefinitionReader 是一个用来读取 “被加了注解的 BeanDefinition” 的读取器。那么 BeanDefinition 又是什么呢？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 这个类顾名思义是一个 reader  读取器
 * 读取什么呢？顾名思义读取 AnnotatedBeanDefinition，意思是读取一个被加了注解的 bean
 * 这个类是构造方法中被实例化的
 */
private final AnnotatedBeanDefinitionReader reader;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从代码中也能看出：AnnotatedBeanDefinition（被注解的 BeanDefinition）继承了 BeanDefinition：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface AnnotatedBeanDefinition extends BeanDefinition {
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;beandefinition&#34;&gt;BeanDefinition&lt;/h4&gt;
&lt;p&gt;BeanDefinition描述了一个bean实例，它具有属性值，构造函数参数值以及具体实现所提供的更多信息。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Spring 当中用来描述 Bean 的一个接口
public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以想象这样一个需求：有一个 Java 类 User&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;User{
  private String name;
  public void study(){
    
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Java 中一切皆对象，一个 User 类也是一个对象，定义一个什么类来描述 User 类对象呢？&lt;/p&gt;
&lt;p&gt;答案就是 Class 类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Class{
  name;        // 全限定类名
  SimpleName;  // User类名
  Methods[];   // 类中的所有方法
  Fields[];    // 类中的所有属性
  
  // 方法...
  public Method[] getMethods(){
    
  }
  public String getName(){
    
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Java 中的类使用 Class 来描述；&lt;strong&gt;Spring 中的 Bean 使用 BeanDefinition 来描述&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;bean-的四种体现方法&#34;&gt;Bean 的四种体现方法：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;@Annotation
&lt;ul&gt;
&lt;li&gt;给一个类添加 @Component、@Service、@Repository 注解，就代表把该类交给 Spring 管理，Spring 就会创建一个 Bean。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Repository
public class IndexDaoImpl implements IndexDao{
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;xml
&lt;ul&gt;
&lt;li&gt;使用 &lt;bean&gt; 标签同样声明一个 Bean&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;dao&amp;quot; class=&amp;quot;com.ssm.dao.impl.IndexDaoImpl&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;@Bean
&lt;ul&gt;
&lt;li&gt;使用@Bean 注解也能声明一个 Bean&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Bean
public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){
    SqlSessionFactoryBean sqlSessionFactoryBean =  new SqlSessionFactoryBean();
    sqlSessionFactoryBean.setDataSource(dataSource);
    return sqlSessionFactoryBean;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Spring 内部提供的 bean，因为自定义的 bean 是 Spring 扫描，然后把它放到容器中的，Spring 也会开发自己的 bean，不扫描也把它放到容器当中去。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;继续来看 AnnotationConfigApplicationContext 的这个带参 Class&amp;lt;?&amp;gt;... 构造方法，下面来看第 6 行，调用了 register 方法，并传参 annotatedClasses，在这个 Test 测试类中，这个 annotatedClasses 就是 AppConfig.class&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// annotatedClasses 在这里代表 AppConfig.class：存放了配置信息
register(annotatedClasses);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;registerclass-annotatedclasses&#34;&gt;register(Class&amp;lt;?&amp;gt;... annotatedClasses)&lt;/h2&gt;
&lt;p&gt;接下来点进这个 register(annotatedClasses); 方法，这里的主要代码就是第 20 行：this.reader.register(annotatedClasses); 调用 reader（前面通过 new AnnotatedBeanDefinitionReader(this); 初始化过了） 的 register方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 注册一个或多个要处理的带注解的类。
 *     比如有新加的类可以用这个方法，但是注册之后需要手动调用 refresh() 方法去触发容器解析注解。
 *
 *   有两个意思：
 *     它可以注册一个配置类：AnnotationConfigApplicationContext context =
 *     new AnnotationConfigApplicationContext(AppConfig.class);
 *     它还可以单独注册一个 bean：context.register(IndexService.class);
 *
 * &amp;lt;p&amp;gt;请注意，必须调用{@link #refresh（）}才能使上下文完全处理新类
 * to fully process the new classes.
 * @param annotatedClasses 一个或多个带注解的类,
 * e.g. {@link Configuration @Configuration} classes
 * @see #scan(String...)
 * @see #refresh()
 */
public void register(Class&amp;lt;?&amp;gt;... annotatedClasses) {
   Assert.notEmpty(annotatedClasses, &amp;quot;At least one annotated class must be specified&amp;quot;);
   // 在this()构造方法中初始化了 reader，就是为了在这里调用
   this.reader.register(annotatedClasses);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;register(Class&amp;lt;?&amp;gt;... annotatedClasses)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;于是我们点进去 reader.register(annotatedClasses); 发现这个 register 就是一个空壳方法，它有调用了 registerBean(annotatedClass); 这个方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 这是一个空壳方法
 *
 * Register one or more annotated classes to be processed.
 * &amp;lt;p&amp;gt;Calls to {@code register} are idempotent; adding the same
 * annotated class more than once has no additional effect.
 * @param annotatedClasses one or more annotated classes,
 * e.g. {@link Configuration @Configuration} classes
 */
public void register(Class&amp;lt;?&amp;gt;... annotatedClasses) {
   for (Class&amp;lt;?&amp;gt; annotatedClass : annotatedClasses) {
      registerBean(annotatedClass);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;registerBean&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;继续点进去 registerBean(annotatedClass);我们发现这个方法又调用了 doRegisterBean(annotatedClass, null, name, qualifiers); 这个方法，继续点进去&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Register a bean from the given bean class, deriving its metadata from
 * class-declared annotations.
 * @param annotatedClass the class of the bean
 * @param name an explicit name for the bean
 * @param qualifiers specific qualifier annotations to consider,
 * in addition to qualifiers at the bean class level
 */
@SuppressWarnings(&amp;quot;unchecked&amp;quot;)
public void registerBean(Class&amp;lt;?&amp;gt; annotatedClass, String name, Class&amp;lt;? extends Annotation&amp;gt;... qualifiers) {
   doRegisterBean(annotatedClass, null, name, qualifiers);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;doregisterbean&#34;&gt;doRegisterBean&lt;/h3&gt;
&lt;p&gt;当传参一个单独的 Bean 时： AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(IndexDao.class);&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;T&amp;gt; void doRegisterBean(Class&amp;lt;T&amp;gt; annotatedClass, @Nullable Supplier&amp;lt;T&amp;gt; instanceSupplier, @Nullable String name,
      @Nullable Class&amp;lt;? extends Annotation&amp;gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers) {

   /**
    *
    * AnnotatedGenericBeanDefinition：被注解的 BeanDefinition(描述Bean)
    * 将 bean 放入 map 中，bean 的 name 是 map 的 key，
    * map 中的 value 为 AnnotatedGenericBeanDefinition 对象
    */
    // 因为 register 中传递过来的参数是带注解的 Bean，即此类的参数 annotatedClass，所以此处使用 AnnotatedGenericBeanDefinition（被注解的BeanDefinition）
   AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass);
   /**
     * 判断这个类是否需要跳过解析
     * 通过代码可以知道 Spring 判断是否跳过解析，主要判断有没有加注解
     */
    // 这个类如果没有加注解，就不需要解析。因为 AnnotatedGenericBeanDefinition 是为了注册被加了注解的；
    // 如果这个类没有被加注解，就跳过不解析
   if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) {
      return;
   }

   abd.setInstanceSupplier(instanceSupplier);
   /**
    * 得到类的作用域
    *     如果是 context.register(SpringConfig.class);则作用域没有什么作用
    *     注册单个类时需要，比如：context.register(IndexService.class);
    */
   ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);
   /**
    * 将类的作用域添加到数据结构中
    * 如果参数为一个Bean，而不是 AppConfig.class 如 new AnnotationConfigApplicationContext(IndexDao.class); 将Bean 内容解析出来放到 AnnotatedGenericBeanDefinition 中
    */
   abd.setScope(scopeMetadata.getScopeName());
   /**
    * 生成类的名字通过 beanNameGenerator
    */
   String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));

   /**
    * 处理类当中的其他通用注解
    * 分析源码可以知道它主要处理：Lazy、DependsOn、Primary、Role 等注解
    * 处理完成之后 processCommonDefinitionAnnotation 中依然是把它添加到数据结构 AnnotatedGenericBeanDefinition 当中
    */
   AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
   /**
     * 如果在向容器注册注解 @Bean定义时，使用了额外的限定符注解则解析
     * 关于 Qualifier 和 Primary 主要涉及到 Spring 的自动装配
     * 这里需要注意的
     *     beanName 和 qualifier 这个变量时 Annotation 类型的数组，里面不仅仅是 Qualifier 注解
     *     理论上里面存的是一切注解，所以可以看到下面的代码 Spring 去循环了这个数组
     *     然后依次判断注解当中是否包含了 Primary，是否包含了 Lazy
     */
   if (qualifiers != null) {
      for (Class&amp;lt;? extends Annotation&amp;gt; qualifier : qualifiers) {
         if (Primary.class == qualifier) {
            abd.setPrimary(true);
         }
         else if (Lazy.class == qualifier) {
            abd.setLazyInit(true);
         }
         else {
            abd.addQualifier(new AutowireCandidateQualifier(qualifier));
         }
      }
   }
   for (BeanDefinitionCustomizer customizer : definitionCustomizers) {
      customizer.customize(abd);
   }
    /**
     * 这个 BeanDefinitionHolder 也是一个数据结构
     * BeanDefinitionHolder 是一个 map，里面放了一个 (BeanDefinition，beanName)
     */
   BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);
   definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
   /**
     * 把上述的这个数据结构注册给 registry
     * registry 就是 AnnotationConfigApplicationContext
     * AnnotationConfigApplicationContext 在初始化的时候通过调用父类的构造方法实例化了一个 DefaultListableBeanFactory
     * registerBeanDefinition 里面就是把 definitionHolder 这个数据结构包含的信息注册到 DefaultListableBeanFactory 这个工厂
     */
   BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述 deRegisterBean 方法的第 28-33 行，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 得到类的作用域
 *     如果是 context.register(SpringConfig.class);则作用域没有什么作用
 *     注册单个类时需要，比如：context.register(IndexService.class);
 */
ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);
/**
 * 将类的作用域添加到数据结构中
 */
abd.setScope(scopeMetadata.getScopeName());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取 Bean 的作用域并添加到 adb 中：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%8E%B7%E5%8F%96bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%B9%B6%E6%B7%BB%E5%8A%A0%E5%88%B0adb%E4%B8%AD.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;processcommondefinitionannotations&#34;&gt;processCommonDefinitionAnnotations&lt;/h4&gt;
&lt;p&gt;上述 deRegisterBean 方法的第 44 行，调用了 processCommonDefinitionAnnotations 方法，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 处理类当中的其他通用注解
 * 分析源码可以知道它主要处理：Lazy、DependsOn、Primary、Role 等注解
 * 处理完成之后 processCommonDefinitionAnnotation 中依然是把它添加到数据结构 AnnotatedGenericBeanDefinition 当中
 */
AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;点进去，又调用了 processCommonDefinitionAnnotations 的重载方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd) {
   // 通过 abd.getMetadata() 获取元数据：@Scope、@DependsOn、@Qualifier、@Primary
   processCommonDefinitionAnnotations(abd, abd.getMetadata());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过 processCommonDefinitionAnnotations 方法解析元数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata) {
   AnnotationAttributes lazy = attributesFor(metadata, Lazy.class);
   // 如果 lazy 不为空
   if (lazy != null) {
      // 把 lazy 的值拿出来，放到 abd(描述 Bean 对象的) 里面去
      abd.setLazyInit(lazy.getBoolean(&amp;quot;value&amp;quot;));
   }
   else if (abd.getMetadata() != metadata) {
      lazy = attributesFor(abd.getMetadata(), Lazy.class);
      if (lazy != null) {
         abd.setLazyInit(lazy.getBoolean(&amp;quot;value&amp;quot;));
      }
   }
   
   // 判断是否有@Primary注解，如果有，放到 abd(描述 Bean 对象的) 里面去
   if (metadata.isAnnotated(Primary.class.getName())) {
      abd.setPrimary(true);
   }
   // 判断是否有@DependsOn注解，如果有，放到 abd(描述 Bean 对象的) 里面去
   AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);
   if (dependsOn != null) {
      abd.setDependsOn(dependsOn.getStringArray(&amp;quot;value&amp;quot;));
   }

   if (abd instanceof AbstractBeanDefinition) {
      AbstractBeanDefinition absBd = (AbstractBeanDefinition) abd;
      // 判断是否有@Role注解，如果有，放到 abd(描述 Bean 对象的) 里面去
      AnnotationAttributes role = attributesFor(metadata, Role.class);
      if (role != null) {
         absBd.setRole(role.getNumber(&amp;quot;value&amp;quot;).intValue());
      }
      // 判断是否有@Description注解，如果有，放到 abd(描述 Bean 对象的) 里面去
      AnnotationAttributes description = attributesFor(metadata, Description.class);
      if (description != null) {
         absBd.setDescription(description.getString(&amp;quot;value&amp;quot;));
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;beandefinitionholder&#34;&gt;BeanDefinitionHolder&lt;/h4&gt;
&lt;p&gt;上述 doRegisterBean 方法的73-74 行，定义了一个 BeanDefinitionHolder，BeanDefinitionHolder 类似一个 map，里面放了一个 (BeanDefinition，beanName)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 这个 BeanDefinitionHolder 也是一个数据结构
 * BeanDefinitionHolder 类似一个 map，里面放了一个 (BeanDefinition，beanName)
 */
BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);
definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;顾名思义，BeanDefinitionRegistry 是用来注册 BeanDefinition（Bean的定义）的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//用来注册Bean的定义 BeanDefinition
private final BeanDefinitionRegistry registry;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/BeanDefinitionRegistry.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;BeanDefinitionRegistry：将 BeanDifinition 放到 Spring 容器中&lt;/p&gt;
&lt;p&gt;点进去 registerBeanDefinition 这个方法，发现就是拿出 BeanDefinitionHolder 中的 BeanName 和 BeanDefinition，并把它注册到 registry 中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void registerBeanDefinition(
      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
      throws BeanDefinitionStoreException {

   // 拿出 BeanDefinitionHolder 中的 BeanName 和 BeanDefinition 
   String beanName = definitionHolder.getBeanName();
   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

   // 注册bean名称的别名（如果有）。
   String[] aliases = definitionHolder.getAliases();
   if (aliases != null) {
      for (String alias : aliases) {
         registry.registerAlias(beanName, alias);
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们看第 7 行，真正的将 BeanName 和 BeanDefinition 注册到 registry 中，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;点进去 registerBeanDefinition 方法：&lt;/p&gt;
&lt;h4 id=&#34;registerbeandefinition&#34;&gt;registerBeanDefinition&lt;/h4&gt;
&lt;p&gt;上述 deRegisterBean 方法的第 81 行，把 &lt;strong&gt;BeanDefinitionHolder&lt;/strong&gt;注册给 registry：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 把上述的这个数据结构注册给 registry
 * registry 就是 AnnotationConfigApplicationContext
 * AnnotationConfigApplicationContext 在初始化的时候通过调用父类的构造方法实例化了一个 DefaultListableBeanFactory
 * registerBeanDefinition 里面就是把 definitionHolder 这个数据结构包含的信息注册到 DefaultListableBeanFactory 这个工厂
 */
BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;点进 registerBeanDefinition 方法代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
      throws BeanDefinitionStoreException {

   this.beanFactory.registerBeanDefinition(beanName, beanDefinition);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/beanDefinitionMap_put.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;this.beanDefinitionMap.put(beanName, beanDefinition);&lt;/p&gt;
&lt;p&gt;点进 registerBeanDefinition 方法如下，主要操作是：将 (beanName,beanDefiniton)放到map中，将 beanName 加入到 list 中：&lt;br&gt;
DefaultListableBeanFactory#registerBeanDefinition：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
      throws BeanDefinitionStoreException {

   Assert.hasText(beanName, &amp;quot;Bean name must not be empty&amp;quot;);
   Assert.notNull(beanDefinition, &amp;quot;BeanDefinition must not be null&amp;quot;);

   if (beanDefinition instanceof AbstractBeanDefinition) {
      try {
         ((AbstractBeanDefinition) beanDefinition).validate();
      }
      catch (BeanDefinitionValidationException ex) {
         throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
               &amp;quot;Validation of bean definition failed&amp;quot;, ex);
      }
   }

   BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
   if (existingDefinition != null) {
      if (!isAllowBeanDefinitionOverriding()) {
         throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
               &amp;quot;Cannot register bean definition [&amp;quot; + beanDefinition + &amp;quot;] for bean &#39;&amp;quot; + beanName +
               &amp;quot;&#39;: There is already [&amp;quot; + existingDefinition + &amp;quot;] bound.&amp;quot;);
      }
      else if (existingDefinition.getRole() &amp;lt; beanDefinition.getRole()) {
         // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
         if (logger.isWarnEnabled()) {
            logger.warn(&amp;quot;Overriding user-defined bean definition for bean &#39;&amp;quot; + beanName +
                  &amp;quot;&#39; with a framework-generated bean definition: replacing [&amp;quot; +
                  existingDefinition + &amp;quot;] with [&amp;quot; + beanDefinition + &amp;quot;]&amp;quot;);
         }
      }
      else if (!beanDefinition.equals(existingDefinition)) {
         if (logger.isInfoEnabled()) {
            logger.info(&amp;quot;Overriding bean definition for bean &#39;&amp;quot; + beanName +
                  &amp;quot;&#39; with a different definition: replacing [&amp;quot; + existingDefinition +
                  &amp;quot;] with [&amp;quot; + beanDefinition + &amp;quot;]&amp;quot;);
         }
      }
      else {
         if (logger.isDebugEnabled()) {
            logger.debug(&amp;quot;Overriding bean definition for bean &#39;&amp;quot; + beanName +
                  &amp;quot;&#39; with an equivalent definition: replacing [&amp;quot; + existingDefinition +
                  &amp;quot;] with [&amp;quot; + beanDefinition + &amp;quot;]&amp;quot;);
         }
      }
      this.beanDefinitionMap.put(beanName, beanDefinition);
   }
   else {
      if (hasBeanCreationStarted()) {
         // Cannot modify startup-time collection elements anymore (for stable iteration)
         synchronized (this.beanDefinitionMap) {
            // DefaultListableBeanFactory.beanDefinitionMap.put(beanName, beanDefinition)
            this.beanDefinitionMap.put(beanName, beanDefinition);
            List&amp;lt;String&amp;gt; updatedDefinitions = new ArrayList&amp;lt;&amp;gt;(this.beanDefinitionNames.size() + 1);
            updatedDefinitions.addAll(this.beanDefinitionNames);
            updatedDefinitions.add(beanName);
            this.beanDefinitionNames = updatedDefinitions;
            if (this.manualSingletonNames.contains(beanName)) {
               Set&amp;lt;String&amp;gt; updatedSingletons = new LinkedHashSet&amp;lt;&amp;gt;(this.manualSingletonNames);
               updatedSingletons.remove(beanName);
               this.manualSingletonNames = updatedSingletons;
            }
         }
      }
      else {
         // 将 (beanName,beanDefiniton)放到map中
         this.beanDefinitionMap.put(beanName, beanDefinition);
         // 将 beanName 加入到 list 中
         this.beanDefinitionNames.add(beanName);
         this.manualSingletonNames.remove(beanName);
      }
      this.frozenBeanDefinitionNames = null;
   }

   if (existingDefinition != null || containsSingleton(beanName)) {
      resetBeanDefinition(beanName);
   }
   else if (isConfigurationFrozen()) {
      clearByTypeCache();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;beanDefinitionNames 是一个 List 集合，将 Bean 定义的名字添加到这个 List 集合中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** List of bean definition names, in registration order */
private volatile List&amp;lt;String&amp;gt; beanDefinitionNames = new ArrayList&amp;lt;&amp;gt;(256);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述第 67 行代码执行完毕&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;this.beanDefinitionMap.put(beanName, beanDefinition);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;map 中添加了 7 个对象，一个是自定义的 indexDao，其余 6 个是 Spring 在启动过程中自动添加的&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/map%E6%B7%BB%E5%8A%A07%E4%B8%AA%E5%AF%B9%E8%B1%A1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;refresh&#34;&gt;refresh()&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;初始化 Spring 的环境&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void refresh() throws BeansException, IllegalStateException {
   synchronized (this.startupShutdownMonitor) {
      // Prepare this context for refreshing.
      // 准备工作包括设置启动时间、是否激活标识位，初始化属性源（property source）配置（这里不属于 Bean 的生命周期内）
      prepareRefresh();

      // Tell the subclass to refresh the internal bean factory.
      // 获取 DefaultListableBeanFactory
      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

      // Prepare the bean factory for use in this context.
      prepareBeanFactory(beanFactory);

      try {
         // Allows post-processing of the bean factory in context subclasses.
         postProcessBeanFactory(beanFactory);

         // Invoke factory processors registered as beans in the context.
         invokeBeanFactoryPostProcessors(beanFactory);

         // Register bean processors that intercept bean creation.
         registerBeanPostProcessors(beanFactory);

         // Initialize message source for this context.
         initMessageSource();

         // Initialize event multicaster for this context.
         initApplicationEventMulticaster();

         // Initialize other special beans in specific context subclasses.
         onRefresh();

         // Check for listener beans and register them.
         registerListeners();

         // Instantiate all remaining (non-lazy-init) singletons.
         finishBeanFactoryInitialization(beanFactory);

         // Last step: publish corresponding event.
         finishRefresh();
      }

      catch (BeansException ex) {
         if (logger.isWarnEnabled()) {
            logger.warn(&amp;quot;Exception encountered during context initialization - &amp;quot; +
                  &amp;quot;cancelling refresh attempt: &amp;quot; + ex);
         }

         // Destroy already created singletons to avoid dangling resources.
         destroyBeans();

         // Reset &#39;active&#39; flag.
         cancelRefresh(ex);

         // Propagate exception to caller.
         throw ex;
      }

      finally {
         // Reset common introspection caches in Spring&#39;s core, since we
         // might not ever need metadata for singleton beans anymore...
         resetCommonCaches();
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先看上述 refresh() 的第 5 行，调用了 prepareRefresh() 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 准备工作包括设置启动时间、是否激活标识位，初始化属性源（property source）配置（这里不属于 Bean 的生命周期内）
prepareRefresh();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;preparerefresh&#34;&gt;prepareRefresh()&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void prepareRefresh() {
   // Switch to active.
   this.startupDate = System.currentTimeMillis();
   this.closed.set(false);
   this.active.set(true);

   if (logger.isInfoEnabled()) {
      logger.info(&amp;quot;Refreshing &amp;quot; + this);
   }

   // Initialize any placeholder property sources in the context environment.
   // 这个方法目前没有子类去实现
   // 估计 Spring 是期待后面的版本有子类去实现吧
   initPropertySources();

   // Validate that all properties marked as required are resolvable:
   // see ConfigurablePropertyResolver#setRequiredProperties
   // 获取 .properties 文件或者 @Profile 环境
   getEnvironment().validateRequiredProperties();

   // Store pre-refresh ApplicationListeners...
   if (this.earlyApplicationListeners == null) {
      this.earlyApplicationListeners = new LinkedHashSet&amp;lt;&amp;gt;(this.applicationListeners);
   }
   else {
      // Reset local application listeners to pre-refresh state.
      this.applicationListeners.clear();
      this.applicationListeners.addAll(this.earlyApplicationListeners);
   }

   // Allow for the collection of early ApplicationEvents,
   // to be published once the multicaster is available...
   this.earlyApplicationEvents = new LinkedHashSet&amp;lt;&amp;gt;();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看 prepareRefresh() 方法的第 14 行，调用了 initPropertySources()，这个方法目前没有子类去实现估计 Spring 是期待后面的版本有子类去实现吧：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void initPropertySources() {
   // For subclasses: do nothing by default.
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再来看 refresh() 的第 9 行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 告诉子类 refresh 内部 Bean工厂
ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;obtainfreshbeanfactory&#34;&gt;obtainFreshBeanFactory()&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
   refreshBeanFactory();
   ConfigurableListableBeanFactory beanFactory = getBeanFactory();
   if (logger.isDebugEnabled()) {
      logger.debug(&amp;quot;Bean factory for &amp;quot; + getDisplayName() + &amp;quot;: &amp;quot; + beanFactory);
   }
   return beanFactory;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看 obtainFreshBeanFactory() 方法的第 3 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ConfigurableListableBeanFactory beanFactory = getBeanFactory();
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;getbeanfactory&#34;&gt;getBeanFactory()&lt;/h4&gt;
&lt;p&gt;GenericApplicationContext#getBeanFactory：&lt;br&gt;
返回 DefaultListableBeanFactory&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final ConfigurableListableBeanFactory getBeanFactory() {
   return this.beanFactory;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;beanFactory 是 DefaultListableBeanFactory  类型变量：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** Bean factory for this context */
private final DefaultListableBeanFactory beanFactory;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再看 refresh() 的第 19 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Invoke factory processors registered as beans in the context.
// 调用在上下文中注册为bean的工厂处理器。
invokeBeanFactoryPostProcessors(beanFactory);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们点进这个 invokeBeanFactoryPostProcessors(beanFactory); 方法看：&lt;/p&gt;
&lt;h3 id=&#34;invokebeanfactorypostprocessors&#34;&gt;invokeBeanFactoryPostProcessors&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
  * 实例化并调用所有已注册的BeanFactoryPostProcessor Bean，
  * 遵循显式顺序（如果给定的话）。 
  * 必须在单例实例化之前调用。
  */
protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());

   // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
   // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
   if (beanFactory.getTempClassLoader() == null &amp;amp;&amp;amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们看上述 invokeBeanFactoryPostProcessors 方法中的第 7 行代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个 invokeBeanFactoryPostProcessors 方法是非常重要的，也就是上面说的产生 7 个对象的过程，就是此段代码内实现的&lt;/p&gt;
&lt;h1 id=&#34;spring-bean-的扩展有哪些&#34;&gt;Spring Bean 的扩展有哪些&lt;/h1&gt;
&lt;h2 id=&#34;aop&#34;&gt;AOP&lt;/h2&gt;
&lt;p&gt;IndexDao 配置了 AOP，AOP 与 IndexDao 没有任何耦合&lt;/p&gt;
&lt;p&gt;AOP 通过 @AspectJ 配置通知、切点，与 IndexDao 没有任何耦合，那 AOP 是如何将 IndexDao 变成代理的呢？ ——Spring  Bean 的扩展（想让它成为 IndexDao，就成为 IndexDao；想让它成为代理类，就成为代理类）&lt;/p&gt;
&lt;h2 id=&#34;beanpostprocessor&#34;&gt;BeanPostProcessor&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Bean 后置处理器&lt;/li&gt;
&lt;li&gt;BeanPostProcessor 接口，能够扩展 Spring&lt;/li&gt;
&lt;li&gt;所有 BeanPostProcessor 接口的实现类，本质上都是通过 BeanPostProcessor 进行扩展，属于Spring 扩展的一种方式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Repository(&amp;quot;indexDao&amp;quot;)
public class IndexDaoImpl implements IndexDao {

   public IndexDaoImpl(){
      System.out.println(&amp;quot;indexDao...constructor&amp;quot;);
   }

   @PostConstruct
   public void init(){
      System.out.println(&amp;quot;indexDao...init&amp;quot;);
   }

   @Override
   public void query() {
      System.out.println(&amp;quot;dao...模拟查询数据库&amp;quot;);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;插手 Bean 的构建过程，将 Bean 变为代理对象并返回：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class TestBeanPostProcessor implements BeanPostProcessor {
   @Override
   public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
      if(beanName.equals(&amp;quot;indexDao&amp;quot;)){
         System.out.println(&amp;quot;BeforeInitialization...&amp;quot;);
      }
      // 返回一个代理对象出去
//    Proxy.newProxyInstance()
      return bean;
   }

   @Override
   public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
      if(beanName.equals(&amp;quot;indexDao&amp;quot;)){
         System.out.println(&amp;quot;AfterInitialization...&amp;quot;);
      }
      return bean;
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;indexDao...constructor
BeforeInitialization...
indexDao...init
AfterInitialization...
dao...模拟查询数据库
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;如何控制多个后置处理器的顺序&#34;&gt;如何控制多个后置处理器的顺序：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;后置处理器实现 PriorityOrdered 接口，重写 getOrder() 方法，值越小就越先执行&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class TestBeanPostProcessor implements BeanPostProcessor, PriorityOrdered {
   @Override
   public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
      if(beanName.equals(&amp;quot;indexDao&amp;quot;)){
         System.out.println(&amp;quot;BeforeInitialization...&amp;quot;);
      }
      // 返回一个代理对象出去
//    Proxy.newProxyInstance()
      return bean;
   }

   @Override
   public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
      if(beanName.equals(&amp;quot;indexDao&amp;quot;)){
         System.out.println(&amp;quot;AfterInitialization...&amp;quot;);
      }
      return bean;
   }

   @Override
   public int getOrder() {
      return 102;
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二个后置处理器的定义，同样实现 PriorityOrdered 接口，重写 getOrder() 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class TestBeanPostProcessor2 implements BeanPostProcessor, PriorityOrdered {
   @Override
   public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
      if(beanName.equals(&amp;quot;indexDao&amp;quot;)){
         System.out.println(&amp;quot;BeforeInitialization2...&amp;quot;);
      }
      // 返回一个代理对象出去
//    Proxy.newProxyInstance()
      return bean;
   }

   @Override
   public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
      if(beanName.equals(&amp;quot;indexDao&amp;quot;)){
         System.out.println(&amp;quot;AfterInitialization2...&amp;quot;);
      }
      return bean;
   }

   @Override
   public int getOrder() {
      return 100;
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;indexDao...constructor
BeforeInitialization2...
BeforeInitialization...
indexDao...init
AfterInitialization2...
AfterInitialization...
dao...模拟查询数据库
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;beanfactorypostprocessor&#34;&gt;BeanFactoryPostProcessor&lt;/h2&gt;
&lt;p&gt;Spring 工厂后置处理器&lt;/p&gt;
&lt;h2 id=&#34;beandefinitionregistrypostprocessor&#34;&gt;BeanDefinitionRegistryPostProcessor&lt;/h2&gt;
&lt;h3 id=&#34;preparebeanfactorybeanfactory&#34;&gt;prepareBeanFactory(beanFactory)&lt;/h3&gt;
&lt;p&gt;再来看 refresh() 的第 12 行： prepareBeanFactory(beanFactory);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Prepare the bean factory for use in this context.
prepareBeanFactory(beanFactory);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;点进去 prepareBeanFactory(beanFactory) 代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
   // Tell the internal bean factory to use the context&#39;s class loader etc.
   beanFactory.setBeanClassLoader(getClassLoader());
   // bean 表达式解析器
   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
   // 注册属性编辑器
   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));

   // Configure the bean factory with context callbacks.
   // 使用上下文回调配置Bean工厂。
   // 向 List 里面添加一个数据：添加一个后置管理器：ApplicationContextAwareProcessor 实现了 BeanPostProcessor接口：插手 Bean 的创建过程
   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);

   // BeanFactory interface not registered as resolvable type in a plain factory.
   // MessageSource registered (and found for autowiring) as a bean.
   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
   beanFactory.registerResolvableDependency(ResourceLoader.class, this);
   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
   beanFactory.registerResolvableDependency(ApplicationContext.class, this);

   // Register early post-processor for detecting inner beans as ApplicationListeners.
   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));

   // Detect a LoadTimeWeaver and prepare for weaving, if found.
   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
      // Set a temporary ClassLoader for type matching.
      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
   }

   // Register default environment beans.
   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
   }
   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
   }
   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看 prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) 的第 12 行内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Configure the bean factory with context callbacks.
// 使用上下文回调配置Bean工厂。
// 向 List 里面添加一个数据：添加一个后置管理器：ApplicationContextAwareProcessor 实现了 BeanPostProcessor接口：插手 Bean 的创建过程
beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;向 List 里面添加一个数据：添加一个后置管理器：ApplicationContextAwareProcessor 实现了 BeanPostProcessor接口：插手 Bean 的创建过程：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class ApplicationContextAwareProcessor implements BeanPostProcessor {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果想了解 ApplicationContextAwareProcessor 类，就先来看一下它实现的父接口 BeanPostProcessor 类。&lt;/p&gt;
&lt;h4 id=&#34;beanpostprocessor-2&#34;&gt;BeanPostProcessor&lt;/h4&gt;
&lt;p&gt;先来看一下 BeanPostProcessor 接口的结构，一共有两个方法：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/BeanPostProcessor.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * BeanPostProcessor 是 Spring 框架提供的一个扩展类点（Spring 扩展不止一个后置处理器，
 * Spring 能够扩展一个类，它提供了很多后置处理器，但这个后置处理器都属于一种，还有其他办法）
 * 通过实现 BeanPostProcessor 接口，程序员就可查收 bean 实例化的过程，从而减轻了 beanFactory 的负担
 * 值得说明的是这个接口可以设置多个，会形成一个列表， 然后依次执行
 * （自己写的后置处理器只需添加 @Component 即可，Spring就会自动扫描把它new出来然后添加到容器中。
 * 但是 Spring 默认的怎么办？Spring 手动 set 添加到容器中） 
 * 比如 AOP 就是在 bean 实例化后期间将切面逻辑织入 bean 实例中的
 * AOP 也正是通过 BeanPostProcessor 和 IOC 容器建立起了联系
 * （由 Spring 提供的默认的 PostProcessor，Spring 提供了很多默认的 PostProcessor，下面一一介绍这些实现类的功能）
 * 可以演示一下 BeanPostProcessor 的使用方式（把动态代理和 IOC、AOP 结合起来使用）
 *
 * 在演示之前先来熟悉一下这个接口，是这个接口本身特别简单，但是它的实现类特别复杂。
 * 可以看看 Spring 提供哪些默认的实现
 * 查看类的关系图就可以知道 Spring 提供了以下的默认实现，由于实现类是在太多，所以只是解释几个常用的
 * 1.ApplicationContextAwareProcessor（sacap）
 *        acap 后置处理器的作用是：当应用程序定义的 Bean 实现 ApplicationContextAware 接口时注入 ApplicationContext 对象
 *        当然这是他的第一个作用，它还有其他作用，这里就不一一举例了，可以参考源码
 *        我们可以针对 ApplicationContextAwareProcessor 写一个例子
 * 2.InitDestroyAnnotationBeanPostProcessor
 *     用来处理自定义的初始化方法和销毁方法
 *     Spring 中提供了三种自定义初始化和销毁方法分别是
 *     ① 通过 @Bean 指定 intit method 和 destory-method 属性
 *     ② Ban 实现 InitializingBean 接口并重写afterPropertiesSet()、实现 DisposableBean 接口并重写 destroy()
 *     ③ @PostConstruct：@PreDestroy
 *     为什么 Spring 通过这三种方式都能完成对 bean 生命周期的回调呢？
 *     可以通过 InitDestroyAnnotationBeanPostProcessor 的源码来解释
 * 3.InstantiationAwareBeanPostProcessor
 * 4.CommonAnnotationBeanPostProcessor
 * 5.AutowiredAnnotationBeanPostProcessor
 * 6.RequiredAnnotationBeanPostProcessor
 * 7.BeanValidationPostProcessor
 * 8.AbstractAutoProxyCreator：抽象自动代理创建器：AOP 创建一个代理
 * ......
 *
 *
 * Factory hook that allows for custom modification of new bean instances,
 * e.g. checking for marker interfaces or wrapping them with proxies.
 *
 * &amp;lt;p&amp;gt;ApplicationContexts can autodetect BeanPostProcessor beans in their
 * bean definitions and apply them to any beans subsequently created.
 * Plain bean factories allow for programmatic registration of post-processors,
 * applying to all beans created through this factory.
 *
 * &amp;lt;p&amp;gt;Typically, post-processors that populate beans via marker interfaces
 * or the like will implement {@link #postProcessBeforeInitialization},
 * while post-processors that wrap beans with proxies will normally
 * implement {@link #postProcessAfterInitialization}.
 *
 * @author Juergen Hoeller
 * @since 10.10.2003
 * @see InstantiationAwareBeanPostProcessor
 * @see DestructionAwareBeanPostProcessor
 * @see ConfigurableBeanFactory#addBeanPostProcessor
 * @see BeanFactoryPostProcessor
 */
public interface BeanPostProcessor {

   /**
    *
    * 在 Bean 初始化之前执行
    * Apply this BeanPostProcessor to the given new bean instance &amp;lt;i&amp;gt;before&amp;lt;/i&amp;gt; any bean
    * initialization callbacks (like InitializingBean&#39;s {@code afterPropertiesSet}
    * or a custom init-method). The bean will already be populated with property values.
    * The returned bean instance may be a wrapper around the original.
    * &amp;lt;p&amp;gt;The default implementation returns the given {@code bean} as-is.
    * @param bean the new bean instance
    * @param beanName the name of the bean
    * @return the bean instance to use, either the original or a wrapped one;
    * if {@code null}, no subsequent BeanPostProcessors will be invoked
    * @throws org.springframework.beans.BeansException in case of errors
    * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet
    */
   @Nullable
   default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
      return bean;
   }

   /**
    * 在 Bean 初始化之后执行
    * Apply this BeanPostProcessor to the given new bean instance &amp;lt;i&amp;gt;after&amp;lt;/i&amp;gt; any bean
    * initialization callbacks (like InitializingBean&#39;s {@code afterPropertiesSet}
    * or a custom init-method). The bean will already be populated with property values.
    * The returned bean instance may be a wrapper around the original.
    * &amp;lt;p&amp;gt;In case of a FactoryBean, this callback will be invoked for both the FactoryBean
    * instance and the objects created by the FactoryBean (as of Spring 2.0). The
    * post-processor can decide whether to apply to either the FactoryBean or created
    * objects or both through corresponding {@code bean instanceof FactoryBean} checks.
    * &amp;lt;p&amp;gt;This callback will also be invoked after a short-circuiting triggered by a
    * {@link InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation} method,
    * in contrast to all other BeanPostProcessor callbacks.
    * &amp;lt;p&amp;gt;The default implementation returns the given {@code bean} as-is.
    * @param bean the new bean instance
    * @param beanName the name of the bean
    * @return the bean instance to use, either the original or a wrapped one;
    * if {@code null}, no subsequent BeanPostProcessors will be invoked
    * @throws org.springframework.beans.BeansException in case of errors
    * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet
    * @see org.springframework.beans.factory.FactoryBean
    */
   @Nullable
   default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
      return bean;
   }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;AnnotationAwareAspectJAutoProxyCreator 并没有添加 @Component 注解，所以 Spring 不会扫描它&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SuppressWarnings(&amp;quot;serial&amp;quot;)
public class AnnotationAwareAspectJAutoProxyCreator extends AspectJAwareAdvisorAutoProxyCreator {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来再回回到 prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) 的第 12 行内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在来看一下 addBeanPostProcessor() 方法的实现：&lt;/p&gt;
&lt;h4 id=&#34;addbeanpostprocessorbeanpostprocessor-beanpostprocessor&#34;&gt;addBeanPostProcessor(BeanPostProcessor beanPostProcessor)&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) {
   Assert.notNull(beanPostProcessor, &amp;quot;BeanPostProcessor must not be null&amp;quot;);
   // Remove from old position, if any
   this.beanPostProcessors.remove(beanPostProcessor);
   // Track whether it is instantiation/destruction aware
   if (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) {
      this.hasInstantiationAwareBeanPostProcessors = true;
   }
   if (beanPostProcessor instanceof DestructionAwareBeanPostProcessor) {
      this.hasDestructionAwareBeanPostProcessors = true;
   }
   // Add to end of list
   this.beanPostProcessors.add(beanPostProcessor);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看一下上述 addBeanPostProcessor 方法的第 14 行，向 beanPostProcessors 中添加了一个 beanPostProcessor，那么 beanPostProcessors  是什么呢？List&lt;BeanPostProcessor&gt; 集合&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** BeanPostProcessors to apply in createBean */
private final List&amp;lt;BeanPostProcessor&amp;gt; beanPostProcessors = new CopyOnWriteArrayList&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;postProcessBeforeInitialization&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来看 ApplicationContextAwareProcessor 类是如何实现 postProcessBeforeInitialization 方法的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
@Nullable
public Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException {
   AccessControlContext acc = null;

   if (System.getSecurityManager() != null &amp;amp;&amp;amp;
         (bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||
               bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||
               bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)) {
      acc = this.applicationContext.getBeanFactory().getAccessControlContext();
   }

   if (acc != null) {
      AccessController.doPrivileged((PrivilegedAction&amp;lt;Object&amp;gt;) () -&amp;gt; {
         invokeAwareInterfaces(bean);
         return null;
      }, acc);
   }
   else {
      invokeAwareInterfaces(bean);
   }

   return bean;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看上述 postProcessBeforeInitialization 方法的第 20 行，调用了 invokeAwareInterfaces(bean); 方法，具体实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void invokeAwareInterfaces(Object bean) {
   // 判断这个 bean 是不是 Aware 接口
   if (bean instanceof Aware) {
      if (bean instanceof EnvironmentAware) {
         ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());
      }
      if (bean instanceof EmbeddedValueResolverAware) {
         ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);
      }
      // 判断这个 bean 是不是 ResourceLoaderAware 接口
      if (bean instanceof ResourceLoaderAware) {
         ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);
      }
      if (bean instanceof ApplicationEventPublisherAware) {
         ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);
      }
      if (bean instanceof MessageSourceAware) {
         ((MessageSourceAware) bean).setMessageSource(this.applicationContext);
      }
      // Spring 帮助我们 set 了一个 applicationContext 对象
      // 所以当我们自己的一个对象实现了 ApplicationContextAware 对象只需要提供 setter 就能得到 applicationContext
      if (bean instanceof ApplicationContextAware) {
         ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;单例对象中有一个-prototype-属性会有问题如何解决&#34;&gt;单例对象中有一个 prototype 属性会有问题，如何解决：&lt;/h1&gt;
&lt;h2 id=&#34;repository&#34;&gt;@Repository&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Repository
@Scope(&amp;quot;prototype&amp;quot;)
public class IndexDaoImpl implements IndexDao {
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;lookup&#34;&gt;@Lookup&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
@Scope(&amp;quot;singleton&amp;quot;)
public abstract class IndexService {
    @Lookup
    public abstract IndexDao getIndexDao() ;
    public void service(){
        System.out.println(this);
        System.out.println(getIndexDao());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;applicationcontextaware&#34;&gt;ApplicationContextAware&lt;/h2&gt;
&lt;p&gt;implements ApplicationContextAware，重写 setApplicationContext 方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
@Scope(&amp;quot;singleton&amp;quot;)
public class IndexService implements ApplicationContextAware {
    @Autowired
    private IndexDao indexDao;
    private ApplicationContext applicationContext;
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
    public void service(){
        System.out.println(this);
        // 得到原型对象
       System.out.println(applicationContext.getBean(&amp;quot;indexDaoImpl&amp;quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;
">Spring系列（六）Spring源码解析</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/spring-xi-lie-wu-beanfactory-he-factorybean-de-qu-bie/"" data-c="
          &lt;h1 id=&#34;beanfactory-和-factorybean-的区别&#34;&gt;BeanFactory 和 FactoryBean 的区别？&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;BeanFactory 是 Spring 提供的一个工厂，能够产生对象。通过 getBean(&amp;quot;xxx&amp;quot;) 能够得到一个 Bean。&lt;/li&gt;
&lt;li&gt;FactoryBean 是一个 Bean：把一个对象交给 Spring 管理，就可以称之为一个 Bean，就是一个对象，FactoryBean 就是一个受 Spring 管理的对象。
&lt;ul&gt;
&lt;li&gt;当一个类的依赖关系很复杂，而我们想对外提供简单的关系，就让外部可以使用时，就使用 FactoryBean，经典场景：MyBatis 中的 SqlSessionFactoryBean 对象。&lt;/li&gt;
&lt;li&gt;如果类实现了 FactoryBean，那么 Spring 容器当中存在两个对象，一个是 getObject() 方法返回的对象（name=当前类名）；还有一个是当前对象（name=&amp;amp;+当前类名）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;spring-中声明一个-bean-的方式&#34;&gt;Spring 中声明一个 Bean 的方式&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;基于XML的 Bean 定义： &lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt;（需提供 setter 方法）&lt;/li&gt;
&lt;li&gt;基于注解的 Bean 定义：@Component、@Controller、@Service、@Repository&lt;/li&gt;
&lt;li&gt;基于 JavaConfig 的 Bean 定义：@Bean&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;factorybean&#34;&gt;FactoryBean&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
// 注解扫描包
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
public class SpringConfig {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果类实现了 FactoryBean，那么 Spring 容器当中存在两个对象，一个是 getObject() 方法返回的对象 TempDaoFactoryBean；还有一个是当前对象 DaoFactoryBean。&lt;/p&gt;
&lt;p&gt;在 Spring 容器中存储时，存储的 name 值是：&lt;/p&gt;
&lt;p&gt;getObject() 得到对象：TempDaoFactoryBean 存的名字是当前类指定的名字：daoFactoryBean；&lt;/p&gt;
&lt;p&gt;当前对象 DaoFactoryBean 是 &amp;quot;&amp;amp;&amp;quot; + 当前类的名字：&amp;amp;daoFactoryBean&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component(&amp;quot;daoFactoryBean&amp;quot;)
public class DaoFactoryBean implements FactoryBean {

    public void testBean(){
        System.out.println(&amp;quot;testBean...&amp;quot;);
    }

    @Override
    public Object getObject() throws Exception {
        return new TempDaoFactoryBean();
    }

    @Override
    public Class&amp;lt;?&amp;gt; getObjectType() {
        return TempDaoFactoryBean.class;
    }

    @Override
    public boolean isSingleton() {
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TempDaoFactoryBean {
  public void testBean(){
    System.out.println(&amp;quot;FactoryBean......&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        DaoFactoryBean daoFactoryBean = (DaoFactoryBean) context.getBean(&amp;quot;daoFactoryBean&amp;quot;);
        daoFactoryBean.testBean();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Exception in thread &amp;quot;main&amp;quot; java.lang.ClassCastException: com.ssm.dao.TempDaoFactoryBean cannot be cast to com.ssm.dao.DaoFactoryBean	at com.ssm.test.Test.main(Test.java:13)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ClassCastException：类型转换异常。将一个对象通过 @Component(&amp;quot;daoFactoryBean&amp;quot;) 放到 Spring 容器中，然后通过context.getBean(&amp;quot;daoFactoryBean&amp;quot;) 结果却类型转换异常。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        // 在 Spring 容器中：name=daoFactoryBean 对应的 Bean 为 TempDaoFactoryBean
        TempDaoFactoryBean daoFactoryBean = (TempDaoFactoryBean) context.getBean(&amp;quot;daoFactoryBean&amp;quot;);
        daoFactoryBean.test();

        // 在 Spring 容器中，name=&amp;amp;daoFactoryBean 对应的 Bean 为 DaoFactoryBean
        DaoFactoryBean bean = (DaoFactoryBean) context.getBean(&amp;quot;&amp;amp;daoFactoryBean&amp;quot;);
        bean.testBean();

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FactoryBean...
testBean...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;final-string-beanname-transformedbeannamename&#34;&gt;final String beanName = transformedBeanName(name);&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;通过 name 获取 beanName&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过 name 获取 beanName，这里不使用 name 直接作为 beanName 有两个原因：&lt;/p&gt;
&lt;p&gt;1.name 可能会以 &amp;amp; 字符开头，表名调用者想获取 FactoryBean 本身，而非 FactoryBean 实现类所创建的 bean。在 Spring 工厂中，FactoryBean 的实现类和其他的普通 bean 存储方式是一致的，即&amp;lt;beanName, bean&amp;gt;，beanName 中是没有 &amp;amp; 这个字符的。所以我们需要将 name 的首字符 &amp;amp; 移除，这样才能从缓存里取到 FactoryBean 实例。&lt;/p&gt;
&lt;p&gt;2.还是别名的问题 &lt;code&gt;&amp;lt;alias&amp;gt;&lt;/code&gt;，转换需要&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/transformedBeanName.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果有一个类相当复杂，里面有很多依赖，就要配置很多 &lt;property&gt;，有可能有的依赖还得不到。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;temp&amp;quot; class=&amp;quot;com.ssm.dao.TempDaoFactoryBean&amp;quot;&amp;gt;
  &amp;lt;!--假设这个类内有很多属性，就要配置很多 &amp;lt;property&amp;gt;--&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TempDaoFactoryBean{
  Util util;
  Config config;
  String str1;
  String str2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假如上述类是第三方框架写的，由于是第三方框架代码，不可能到它的源码上去添加@Component注解：&lt;/p&gt;
&lt;p&gt;解决办法1.在 xml 配置这个类；&lt;/p&gt;
&lt;p&gt;解决办法2.通过 JavConfig 把它 new 出来，然后添加一个 @Bean 标签&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 表明这是一个 xml 文件
@Configuration
// 注解扫描包
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
public class SpringConfig {

    @Bean
    public DataSource dataSource(){
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;);
        dataSource.setUsername(&amp;quot;root&amp;quot;);
        dataSource.setPassword(&amp;quot;123456&amp;quot;);
        dataSource.setUrl(&amp;quot;jdbc:mysql://localhost:3306/test&amp;quot;);
        return dataSource;
    }

    @Bean
    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){
        SqlSessionFactoryBean sqlSessionFactoryBean =  new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource);
        return sqlSessionFactoryBean;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;比如在-spring-中引入第三方工具-mybatis&#34;&gt;比如在 Spring 中引入第三方工具 Mybatis&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;1.在 bean 中配置一个 SqlSessionFactory&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;sqlSessionFactory&amp;quot; class=&amp;quot;org.apache.ibatis.session.defaults.DefaultSqlSessionFactory&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.我们发现 SqlSessionFactory 依赖了 Configuration，于是在 &lt;bean&gt; 配置 Configuration&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/SqlSessionFactory%E4%BE%9D%E8%B5%96Configuration.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;configuration&amp;quot; class=&amp;quot;org.apache.ibatis.session.Configuration&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;
&amp;lt;bean id=&amp;quot;sqlSessionFactory&amp;quot; class=&amp;quot;org.apache.ibatis.session.defaults.DefaultSqlSessionFactory&amp;quot;&amp;gt;
    &amp;lt;constructor-arg ref=&amp;quot;configuration&amp;quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.Configuration 有超级多依赖，就需要在 &lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt; 内添加很多 &lt;code&gt;&amp;lt;property&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Configuraion%E6%9C%89%E5%BE%88%E5%A4%9A%E4%BE%9D%E8%B5%96.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;configuration&amp;quot; class=&amp;quot;org.apache.ibatis.session.Configuration&amp;quot;&amp;gt;
  &amp;lt;property&amp;gt;&amp;lt;/property&amp;gt;
  &amp;lt;property&amp;gt;&amp;lt;/property&amp;gt;
  &amp;lt;property&amp;gt;&amp;lt;/property&amp;gt;
  &amp;lt;property&amp;gt;&amp;lt;/property&amp;gt;
  // ......
  &amp;lt;property&amp;gt;&amp;lt;/property&amp;gt;
  &amp;lt;property&amp;gt;&amp;lt;/property&amp;gt;
  &amp;lt;property&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id=&amp;quot;sqlSessionFactory&amp;quot; class=&amp;quot;org.apache.ibatis.session.defaults.DefaultSqlSessionFactory&amp;quot;&amp;gt;
    &amp;lt;constructor-arg ref=&amp;quot;configuration&amp;quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如此自己配置第三方依赖，操作太过复杂，最好的办法是 MyBatis 自己把 Configuration 这些复杂依赖关系都维护好，我们直接引入即可：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;dao&amp;quot; ref=&amp;quot;sqlSessionFactory&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是 MyBatis 无法更改我们的配置文件，所以它没有地方去配置，于是它提供了一个 SqlSessionFactoryBean 类，在这个类中把这些依赖关系都维护好了。&lt;/p&gt;
&lt;h2 id=&#34;sqlsessionfactorybean&#34;&gt;SqlSessionFactoryBean&lt;/h2&gt;
&lt;p&gt;Mybatis在 SqlSessionFactoryBean 内部维护了各种依赖关系：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/SqlSessionFactoryBean.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;getObject() 最终返回的对象是 SqlSessionFactory&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/SqlSessionFactoryBean%E8%BF%94%E5%9B%9ESqlSessionFactory.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;SqlSessionFactoryBean#afterPropertiesSet()&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/afterPropertiesSet.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;SqlSessionFactoryBean#buildSqlSessionFactory()&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/buildSqlSessionFactory.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;MyBatis 内部通过 SqlSessionFactoryBean 维护了各种依赖关系，我们只需直接使用 SqlSessionFactoryBean 对象即可获得 SqlSessionFactory，无需再手动维护各种依赖。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MyBatis 通过 sqlSessionFactoryBean.setDataSource(dataSource);&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Bean
public DataSource dataSource(){
    DriverManagerDataSource dataSource = new DriverManagerDataSource();
    dataSource.setDriverClassName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;);
    dataSource.setUsername(&amp;quot;root&amp;quot;);
    dataSource.setPassword(&amp;quot;123456&amp;quot;);
    dataSource.setUrl(&amp;quot;jdbc:mysql://localhost:3306/test&amp;quot;);
    return dataSource;
}
@Bean
public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){
    SqlSessionFactoryBean sqlSessionFactoryBean =  new SqlSessionFactoryBean();
    sqlSessionFactoryBean.setDataSource(dataSource);
    return sqlSessionFactoryBean;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;自定义通过-tempdaofactorybeansetmsg1str&#34;&gt;自定义通过 TempDaoFactoryBean.setMsg1(str);&lt;/h2&gt;
&lt;p&gt;1.JavaConfig 配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
// 注解扫描包
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
// 扫描 xml 配置文件
@ImportResource(&amp;quot;classpath:spring.xml&amp;quot;)
public class SpringConfig {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.配置文件 xml 内配置 DaoFactoryBean 对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&amp;quot;&amp;gt;
       
    &amp;lt;bean id=&amp;quot;daoFactory&amp;quot; class=&amp;quot;com.ssm.dao.DaoFactoryBean&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;msg&amp;quot; value=&amp;quot;msg1,msg2,msg3&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.DaoFactoryBean 内有一属性 msg&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class DaoFactoryBean implements FactoryBean {
    private String msg;
    public void setMsg(String msg) {
        this.msg = msg;
    }
    @Override
    public Object getObject() throws Exception {
        TempDaoFactoryBean temp = new TempDaoFactoryBean();
        String[] msgArray = msg.split(&amp;quot;,&amp;quot;);
        temp.setMsg1(msgArray[0]);
        temp.setMsg2(msgArray[1]);
        temp.setMsg3(msgArray[2]);
        return temp;
    }
    @Override
    public Class&amp;lt;?&amp;gt; getObjectType() {
        return TempDaoFactoryBean.class;
    }
    @Override
    public boolean isSingleton() {
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.TempDaoFactoryBean 内有三个属性：msg1、msg2、msg3&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TempDaoFactoryBean {

    private String msg1;
    private String msg2;
    private String msg3;

    public void test(){
        System.out.println(&amp;quot;FactoryBean...&amp;quot;);
    }

    public void setMsg1(String msg1) {
        this.msg1 = msg1;
    }

    public void setMsg2(String msg2) {
        this.msg2 = msg2;
    }

    public void setMsg3(String msg3) {
        this.msg3 = msg3;
    }

    public String getMsg1() {
        return msg1;
    }

    public String getMsg2() {
        return msg2;
    }

    public String getMsg3() {
        return msg3;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.测试类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        TempDaoFactoryBean temp = (TempDaoFactoryBean) context.getBean(&amp;quot;daoFactory&amp;quot;);
        System.out.println(temp.getMsg1());

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6.测试结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;msg1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@PostConstruct // 当 bean 实例化时，回调这个注解修饰的方法，进行初始化操作，比如 Redis 预热场景。
public void init(){
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;spring-如何完成扫描&#34;&gt;Spring 如何完成扫描&lt;/h1&gt;
&lt;h2 id=&#34;如何初始化-spring-环境&#34;&gt;如何初始化 Spring 环境？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;xml：ClassPathXmlApplicationContext；
&lt;ul&gt;
&lt;li&gt;类的扫描&lt;/li&gt;
&lt;li&gt;单独 bean 的注册：在 xml 中写一个&lt;bean&gt;，只要这个 xml 被解析，Spring 就帮助完成了 bean 的声明（定义&lt;bean&gt;）和注册（Spring 会自动创建一个对象放到容器中）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注解 Annotation：必须借助 xml:&amp;lt;context:component-scan base-package=&amp;quot;com.ssm&amp;quot;/&amp;gt;或 JavaConfig:@ComponentScan 完成对类的扫描；&lt;/li&gt;
&lt;li&gt;JavaConfig：AnnotationConfigApplicationContext。
&lt;ul&gt;
&lt;li&gt;类的扫描&lt;/li&gt;
&lt;li&gt;类的定义：如果只是写了一个@Component，并没有扫描这个类，称为只是定义一个 bean，并没有类的注册（因为没有被扫描 ）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么要初始化 Spring 环境？&lt;/p&gt;
&lt;p&gt;把我们交给 Spring 管理的类实例化&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class IndexService {}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
// 注解扫描包
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
public class SpringConfig {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;register() 可以注册两种类型的 bean：1.加了 @Configuration 的 bean；2.普通的 bean&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();

        context.register(SpringConfig.class);
        context.refresh();

        // register() 可以注册两种类型的 bean：加了 @Configuration 的 bean；普通的 bean
//        context.register(TestService.class);
        IndexService indexService = (IndexService) context.getBean(&amp;quot;indexService&amp;quot;);
        System.out.println(indexService);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;com.ssm.service.IndexService@1a451d4d
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;new-annotationconfigapplicationcontextspringconfigclass&#34;&gt;new AnnotationConfigApplicationContext(SpringConfig.class);&lt;/h3&gt;
&lt;p&gt;AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%AF%BB%E5%8F%96JavaConfig%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;AnnotationConfigApplicationContext#register：&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/AnnotationConfigApplicationContext%E6%BA%90%E7%A0%81.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;AnnotationConfigApplicationContext#register：&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/register%E6%BA%90%E7%A0%81.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;AnnotatedBeanDefinitionReader#register：&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/register%E6%BA%90%E7%A0%81_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;AnnotatedBeanDefinitionReader#registerBean：&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/registerBean%E6%BA%90%E7%A0%81.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;配置文件不扫描包使用-register-单独注册某个类&#34;&gt;配置文件不扫描包，使用 register() 单独注册某个类&lt;/h3&gt;
&lt;p&gt;配置类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
// 注解扫描包
//@ComponentScan(&amp;quot;com.ssm&amp;quot;)
public class SpringConfig {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
        // register() 注册加了 @Configuration 的 bean
        context.register(SpringConfig.class);
        // register() 注册普通的 bean
        context.register(IndexService.class);
        // 注意：无参的 AnnotationConfigApplicationContext 没有 refresh()，需要手动调用
        context.refresh();

        IndexService indexService = (IndexService) context.getBean(&amp;quot;indexService&amp;quot;);
        System.out.println(indexService);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/AnnotationConfigApplicationContext%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
context.register(SpringConfig.class); 和 context.register(IndexService.class); 调用的是同一个 register 方法：&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/register%E6%BA%90%E7%A0%81.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;context.scan(&amp;quot;com.ssm&amp;quot;); 也可以完成包扫描：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();

        context.register(SpringConfig.class);
        context.scan(&amp;quot;com.ssm&amp;quot;);
        context.refresh();

        IndexService indexService = (IndexService) context.getBean(&amp;quot;indexService&amp;quot;);
        System.out.println(indexService);

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;AnnotationConfigApplicationContext#scan：&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/scan%E6%BA%90%E7%A0%81.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
ClassPathBeanDefinitionScanner#scan：&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/scan%E6%BA%90%E7%A0%81_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
ClassPathBeanDefinitionScanner#doScan：&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/doScan.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/doScan%E6%89%AB%E6%8F%8F%E5%AE%8C%E6%88%90.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;ClassPathScanningCandidateComponentProvider#findCandidateComponents：&lt;br&gt;
进行类的扫描时，添加一个依赖，就可以按索引扫描，加快扫描速度。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/findCandidateComponents.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;ClassPathScanningCandidateComponentProvider#scanCandidateComponents：&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/scanCandidateComponents.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;自定义模拟实现扫描包-componentscan&#34;&gt;自定义模拟实现扫描包 @ComponentScan&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Retention(RetentionPolicy.RUNTIME)
public @interface Anno {
    public String value();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Anno(&amp;quot;userServiceImpl&amp;quot;)
public class UserServiceImpl implements UserService {
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class AnnotationConfigApplicationContext {

    public void scan(String basePackage){
        // 1.通过文件名得到 .class 文件，然后去掉 .class 就是最终的类名
        // 得到根目录
        String rootPath = this.getClass().getResource(&amp;quot;/&amp;quot;).getPath();
        // 2. 将 com.ssm 变为 com\ssm\，执行完此行代码后：basePackagePath=com\ssm\service\impl
        String basePackagePath = basePackage.replaceAll(&amp;quot;\\.&amp;quot;,&amp;quot;\\\\&amp;quot;);

        File file = new File(rootPath + &amp;quot;//&amp;quot; + basePackagePath);
        // 得到所有文件名的数组，即 UserServiceImpl.class
        String[] names = file.list();
        for (String name : names) {
            // 去掉文件的 .class 就得到了类名
            name = name.replaceAll(&amp;quot;.class&amp;quot;,&amp;quot;&amp;quot;);
            // 得到所有的文件名
            try {
                Class&amp;lt;?&amp;gt; clazz = Class.forName(basePackage + &amp;quot;.&amp;quot; + name);
                // 判断是否属于 @Service、@Component...
                // 判断是否加了 @Anno 注解
                if(clazz.isAnnotationPresent(Anno.class)){
                    Anno annotation = (Anno)clazz.getAnnotation(Anno.class);
                    System.out.println(annotation.value());
                    System.out.println(clazz.newInstance());
                }
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            } catch (InstantiationException e) {
                e.printStackTrace();
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestAnno {
    public static void main(String[] args) throws SpringException {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
        context.scan(&amp;quot;com.ssm.service.impl&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;userServiceImpl
com.ssm.service.impl.UserServiceImpl@1d44bcfa
&lt;/code&gt;&lt;/pre&gt;
">Spring系列（五）BeanFactory和FactoryBean的区别</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/spring-xi-lie-si-xml-mo-ni-springioc/"" data-c="
          &lt;p&gt;先来回顾一下自定义动态代理中获取对象的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获得代理对象：TestDao proxy = (TestDao) ProxyUtil.newInstance(TestDao.class, new TestCustomHandler(new TestDaoImpl()));&lt;/li&gt;
&lt;li&gt;获得目标对象：TestDao target = new TestDaoImpl();&lt;br&gt;
以上方式耦合度过高&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;spring-ioc-的思想&#34;&gt;Spring IOC 的思想&lt;/h1&gt;
&lt;p&gt;工厂方法的好处，工厂方法控制了 proxy 对象的产生过程，现在这个对象的产生过程是由编码控制的，通过 newInstance() 控制的，但是如果使用工厂的话，工厂也可以控制类的产生过程：比如通过类名：TestDao proxy = Factory.getBean(&amp;quot;testDao&amp;quot;);由于可以做到自己控制，提出一种思想：注入，依赖查找查找名为 &amp;quot;testDao&amp;quot; 的 bean，&lt;strong&gt;对象的产生过程通过外部第三方容器注入给我&lt;/strong&gt;，对于程序员来讲，编程的话，只需要写 TestDao testDao 即可，至于这个对象到底是什么东西，程序员无需关心，是由外部容器注入进来的，程序员正常编码即可，面向抽象编程这些方法都有，比如 testDao.query();&lt;/p&gt;
&lt;h1 id=&#34;模拟-springaop&#34;&gt;模拟 SpringAOP&lt;/h1&gt;
&lt;p&gt;实现将对象交给容器管理&lt;/p&gt;
&lt;h2 id=&#34;userdao&#34;&gt;UserDao&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserDao {
    void query();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;userdaoimpl&#34;&gt;UserDaoImpl&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserDaoImpl implements UserDao {
    @Override
    public void query() {
        System.out.println(&amp;quot;dao&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;userservice&#34;&gt;UserService&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserService {
    void find();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;userserviceimpl&#34;&gt;UserServiceImpl&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserServiceImpl implements UserService {

    private UserDao userDao;

    @Override
    public void find() {
        System.out.println(&amp;quot;service...&amp;quot;);
        userDao.query();
    }

    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;springxml&#34;&gt;spring.xml&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!--
    1.哪些类需要我（容器）来管理
    2.怎么告诉我这些类：&amp;lt;bean&amp;gt;
    3.怎么维护依赖关系：setter、constructor
    4.怎么体现 setter：&amp;lt;property&amp;gt; 或者 constructor：&amp;lt;constructor&amp;gt;
--&amp;gt;
&amp;lt;beans&amp;gt;

    &amp;lt;bean id=&amp;quot;userDao&amp;quot; class = &amp;quot;com.ssm.dao.impl.UserDaoImpl&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&amp;quot;userService&amp;quot; class=&amp;quot;com.ssm.service.impl.UserServiceImpl&amp;quot;&amp;gt;
        &amp;lt;!-- 注入：1.构造方法；
        2.set方法：UserService 中有一个 setUserDao(UserDao userDao)  方法，
        只要提供了 UserDao，容器自动调用 setUserDao() 方法给 UserService 内的 UserDao 赋值--&amp;gt;
        &amp;lt;property name=&amp;quot;userDao&amp;quot; ref = &amp;quot;userDao&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;解析-xml-的方式dom4j&#34;&gt;解析 xml 的方式：dom4j。&lt;/h2&gt;
&lt;p&gt;dom4j 官网：&lt;a href=&#34;https://dom4j.github.io/&#34;&gt;https://dom4j.github.io/&lt;/a&gt;&lt;br&gt;
导入 dom4j 依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- https://mvnrepository.com/artifact/dom4j/dom4j --&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;dom4j&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;dom4j&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.6.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;将对象交给容器管理setter-方法注入&#34;&gt;将对象交给容器管理（setter 方法注入）&lt;/h2&gt;
&lt;p&gt;解析 xml 文件，将 “对象名-对象类型” 放到 map 集合中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.dom4j.Attribute;
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.Element;
import org.dom4j.io.SAXReader;

import java.io.File;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

public class BeanFactory {

    // 得到每个 bean 的 id、class 存到 map 中
    Map&amp;lt;String,Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;();

    public BeanFactory(String xml){
        parseXml(xml);
    }

    /**
     * 解析 XML
     */
    public void parseXml(String xml){
        // 获取要解析的 xml 的路径
        File file = new File(this.getClass().getResource(&amp;quot;/&amp;quot;).getPath() + &amp;quot;//&amp;quot; + xml);
        // 解析 xml
        SAXReader reader = new SAXReader();
        Document document = null;
        try {
            document = reader.read(file);
            // 得到根目录
            Element elementRoot = document.getRootElement();
            // 获取根目录下的所有子目录
            for (Iterator&amp;lt;Element&amp;gt; itFirst = elementRoot.elementIterator(); itFirst.hasNext();) {
                /**
                 * setup1.实例化对象
                 */
                // 得到第一个子元素：spring.xml 中的 &amp;lt;bean&amp;gt;
                Element elementFirstChild = itFirst.next();
                // 获得 bean 标签的 id 属性值
                Attribute attributeId = elementFirstChild.attribute(&amp;quot;id&amp;quot;);
                String beanName = attributeId.getValue();
                // 获得 bean 标签的 class 属性值
                Attribute attributeClass = elementFirstChild.attribute(&amp;quot;class&amp;quot;);
                String clazzName = attributeClass.getValue();
                Class clazz = Class.forName(clazzName);
                Object object = clazz.newInstance();
                /**
                 * setup2.维护依赖关系
                 *  (1)看这个对象有没有依赖（判断类是否有属性，然后再判断&amp;lt;bean&amp;gt;中是否有 name=&amp;quot;属性值&amp;quot;的&amp;lt;property&amp;gt;）
                 *      如果有，则注入
                 */
                // 得到&amp;lt;bean&amp;gt;的子标签
                for (Iterator&amp;lt;Element&amp;gt; itSecond = elementFirstChild.elementIterator(); itSecond.hasNext();) {
                    // 得到 &amp;lt;property name=&amp;quot;userDao&amp;quot; ref = &amp;quot;userDao&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
                    Element elementSecondChild = itSecond.next();
                    if(&amp;quot;property&amp;quot;.equals(elementSecondChild.getName())){
                        // 1.得到 ref 的 value（userDao），通过 value 得到对象（map中id=&amp;quot;userDao&amp;quot;）
                        String refValue = elementSecondChild.attribute(&amp;quot;ref&amp;quot;).getValue();
                        // 需要注入的对象 UserDao
                        Object injetObject = map.get(refValue);
                        // 2.得到 name 的值（userDao），然后根据它获取一个 Field 的对象（UserServiceImpl 中的 UserDao userDao）
                        String nameValue = elementSecondChild.attribute(&amp;quot;name&amp;quot;).getValue();
                        // 通过反射得到 Field 对象，即UserDao
                        Field field = clazz.getDeclaredField(nameValue);
                        field.setAccessible(true);
                        // 相等于 UserService.setUserDao(userDao)
                        // 两个参数：userService、UserDao
                        // 3.通过 Field 的set 方法 set 这个对象
                        field.set(object,injetObject);
                    }

                }
                // 放到 map 中
                map.put(beanName,object);
            }
        } catch (DocumentException | ClassNotFoundException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        }
        System.out.println(map);
    }
    public Object getBean(String beanName){
        return map.get(beanName);
    }
}

## 测试类
```java
public class Test {
    public static void main(String[] args) {
        BeanFactory beanFactory = new BeanFactory(&amp;quot;spring.xml&amp;quot;);
        UserService userService = (UserService) beanFactory.getBean(&amp;quot;userService&amp;quot;);
        userService.find();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{userDao=com.ssm.dao.impl.UserDaoImpl@4dd8dc3, userService=com.ssm.service.impl.UserServiceImpl@6d03e736}
service...
dao
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;构造方法注入&#34;&gt;构造方法注入&lt;/h2&gt;
&lt;h3 id=&#34;userserviceimpluserdao-userdao-构造方法&#34;&gt;UserServiceImpl(UserDao userDao) 构造方法&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserServiceImpl implements UserService {
    private UserDao dao;
    public UserServiceImpl(UserDao userDao){
        this.dao = userDao;
    }

    @Override
    public void find() {
        System.out.println(&amp;quot;service...&amp;quot;);
        dao.query();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;###spring.xml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;    &amp;lt;bean id=&amp;quot;userService&amp;quot; class=&amp;quot;com.ssm.service.impl.UserServiceImpl&amp;quot;&amp;gt;
        &amp;lt;!-- 注入：1.构造方法；
        2.set方法：UserService 中有一个 setUserDao(UserDao userDao)  方法，
        只要提供了 UserDao，容器自动调用 setUserDao() 方法给 UserService 内的 UserDao 赋值
        name=&amp;quot;dao&amp;quot; :private UserDao dao--&amp;gt;
&amp;lt;!--        &amp;lt;property name=&amp;quot;dao&amp;quot; ref = &amp;quot;userDao&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;--&amp;gt;

        &amp;lt;!-- name=&amp;quot;userDao&amp;quot;：属性的名字：private UserDao dao;
            ref=&amp;quot;userDao&amp;quot;:引入&amp;lt;bean&amp;gt;的 id 为 userDao 的对象--&amp;gt;
        &amp;lt;constructor-arg name=&amp;quot;dao&amp;quot; ref=&amp;quot;userDao&amp;quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;###解析 xml 将对象放到 map 中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class BeanFactory {

    // 得到每个 bean 的 id、class 存到 map 中
    Map&amp;lt;String,Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;();

    public BeanFactory(String xml){
        parseXml(xml);
    }

    /**
     * 解析 XML
     */
    public void parseXml(String xml){
        // 获取要解析的 xml 的路径
        File file = new File(this.getClass().getResource(&amp;quot;/&amp;quot;).getPath() + &amp;quot;//&amp;quot; + xml);
        // 解析 xml
        SAXReader reader = new SAXReader();
        Document document = null;
        try {
            document = reader.read(file);
            // 得到根目录
            Element elementRoot = document.getRootElement();
            // 获取根目录下的所有子目录
            for (Iterator&amp;lt;Element&amp;gt; itFirst = elementRoot.elementIterator(); itFirst.hasNext();) {
                /**
                 * setup1.实例化对象
                 */
                // 得到第一个子元素：spring.xml 中的 &amp;lt;bean&amp;gt;
                Element elementFirstChild = itFirst.next();
                // 获得 bean 标签的 id 属性值
                Attribute attributeId = elementFirstChild.attribute(&amp;quot;id&amp;quot;);
                String beanName = attributeId.getValue();
                // 获得 bean 标签的 class 属性值
                Attribute attributeClass = elementFirstChild.attribute(&amp;quot;class&amp;quot;);
                String clazzName = attributeClass.getValue();
                Class clazz = Class.forName(clazzName);
                // 当使用构造方法注入时，就不能在这里 newInstance 了，因为没有默认构造方法了
//                Object object = clazz.newInstance();
                Object object = null;
                /**
                 * setup2.维护依赖关系
                 *  (1)看这个对象有没有依赖（判断类是否有属性，然后再判断&amp;lt;bean&amp;gt;中是否有 name=&amp;quot;属性值&amp;quot;的&amp;lt;property&amp;gt;）
                 *      如果有，则注入
                 */
                // 得到&amp;lt;bean&amp;gt;的子标签
                for (Iterator&amp;lt;Element&amp;gt; itSecond = elementFirstChild.elementIterator(); itSecond.hasNext();) {
                    // 得到 &amp;lt;property name=&amp;quot;userDao&amp;quot; ref = &amp;quot;userDao&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
                    Element elementSecondChild = itSecond.next();
                    // 如果使用 setter 方法注入
                    if(&amp;quot;property&amp;quot;.equals(elementSecondChild.getName())){
                        // 由于是 setter 注入，有一个默认构造方法，可以 newInstance()
                        object = clazz.newInstance();
                        // 1.得到 ref 的 value（userDao），通过 value 得到对象（map中id=&amp;quot;userDao&amp;quot;）
                        String refValue = elementSecondChild.attribute(&amp;quot;ref&amp;quot;).getValue();
                        // 需要注入的对象 UserDao
                        Object injectObject = map.get(refValue);
                        // 2.得到 name 的值（userDao），然后根据它获取一个 Field 的对象（UserServiceImpl 中的 UserDao userDao）
                        String nameValue = elementSecondChild.attribute(&amp;quot;name&amp;quot;).getValue();

                        // 3.通过 Field 的set 方法 set 这个对象
                        // 通过反射得到 Field 对象，即UserDao
                        Field field = clazz.getDeclaredField(nameValue);
                        field.setAccessible(true);
                        // 相等于 UserService.setUserDao(userDao)
                        // 两个参数：userService、UserDao
                        field.set(object,injectObject);
                    }else {// 通过构造方法注入 UserDao
                        // &amp;lt;constructor-arg name=&amp;quot;userDao&amp;quot; ref=&amp;quot;userDao&amp;quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
                        // 由于没有默认构造方法了，所以不可以 clazz.newInstance() 了
                        // 1.得到 ref 的 value（userDao），通过 value 得到对象（map中id=&amp;quot;userDao&amp;quot;）
                        String refValue = elementSecondChild.attribute(&amp;quot;ref&amp;quot;).getValue();
                        // 需要注入的对象 UserDao
                        Object injectObject = map.get(refValue);
                        // 得到 UserDao 的类型
                        Class injectObjectClazz = injectObject.getClass();
                        // 2.得到 UserService 的构造方法
                        Constructor constructor = clazz.getConstructor(injectObjectClazz.getInterfaces()[0]);
                        //  public UserServiceImpl(UserDao userDao){
                        object = constructor.newInstance(injectObject);

                    }

                }
                // 放到 map 中
                if(object == null){ //没有子标签，比如  &amp;lt;bean id=&amp;quot;userDao&amp;quot; class = &amp;quot;com.ssm.dao.impl.UserDaoImpl&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;
                    object = clazz.newInstance();
                }
                map.put(beanName,object);
            }
        } catch (DocumentException | ClassNotFoundException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
        System.out.println(map);
    }
    public Object getBean(String beanName){
        return map.get(beanName);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;自动注入&#34;&gt;自动注入&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserDaoImpl implements UserDao {
    @Override
    public void query() {
        System.out.println(&amp;quot;dao&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserDaoImpl2 implements UserDao {
    @Override
    public void query() {
        System.out.println(&amp;quot;dao2&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;UserServiceImpl 依赖 UserDao，但是既不提供构造方法，也不提供 setter。使用 byType 自动注入。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserServiceImpl implements UserService {
    private UserDao userDao;
    @Override
    public void find() {
        System.out.println(&amp;quot;service...&amp;quot;);
        userDao.query();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans default-autowire=&amp;quot;byType&amp;quot;&amp;gt;
    &amp;lt;bean id=&amp;quot;userDao&amp;quot; class = &amp;quot;com.ssm.dao.impl.UserDaoImpl&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&amp;quot;userDao2&amp;quot; class = &amp;quot;com.ssm.dao.impl.UserDaoImpl2&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&amp;quot;userService&amp;quot; class=&amp;quot;com.ssm.service.impl.UserServiceImpl&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class BeanFactory {

    // 得到每个 bean 的 id、class 存到 map 中
    Map&amp;lt;String,Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;();

    public BeanFactory(String xml)throws  SpringException{
        parseXml(xml);
    }

    /**
     * 解析 XML
     */
    public void parseXml(String xml) throws SpringException{
        // 获取要解析的 xml 的路径
        File file = new File(this.getClass().getResource(&amp;quot;/&amp;quot;).getPath() + &amp;quot;//&amp;quot; + xml);
        // 解析 xml
        SAXReader reader = new SAXReader();
        Document document = null;
        try {
            document = reader.read(file);
            // 得到根目录
            Element elementRoot = document.getRootElement();
            Attribute attribute = elementRoot.attribute(&amp;quot;default-autowire&amp;quot;);
            // 记录是否有 default-autowire 自动注入属性
            boolean flag = false;
            if(attribute != null){
                flag = true;
            }
            // 获取根目录下的所有子目录
            for (Iterator&amp;lt;Element&amp;gt; itFirst = elementRoot.elementIterator(); itFirst.hasNext();) {
                /**
                 * setup1.实例化对象
                 */
                // 得到第一个子元素：spring.xml 中的 &amp;lt;bean&amp;gt;
                Element elementFirstChild = itFirst.next();
                // 获得 bean 标签的 id 属性值
                Attribute attributeId = elementFirstChild.attribute(&amp;quot;id&amp;quot;);
                String beanName = attributeId.getValue();
                // 获得 bean 标签的 class 属性值
                Attribute attributeClass = elementFirstChild.attribute(&amp;quot;class&amp;quot;);
                String clazzName = attributeClass.getValue();
                Class clazz = Class.forName(clazzName);
                // 当使用构造方法注入时，就不能在这里 newInstance 了，因为没有默认构造方法了
//                Object object = clazz.newInstance();
                Object object = null;
                /**
                 * setup2.维护依赖关系
                 *  (1)看这个对象有没有依赖（判断类是否有属性，然后再判断&amp;lt;bean&amp;gt;中是否有 name=&amp;quot;属性值&amp;quot;的&amp;lt;property&amp;gt;）
                 *      如果有，则注入
                 */
                // 得到&amp;lt;bean&amp;gt;的子标签
                for (Iterator&amp;lt;Element&amp;gt; itSecond = elementFirstChild.elementIterator(); itSecond.hasNext();) {
                    // 得到 &amp;lt;property name=&amp;quot;userDao&amp;quot; ref = &amp;quot;userDao&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
                    Element elementSecondChild = itSecond.next();
                    // 如果使用 setter 方法注入
                    if(&amp;quot;property&amp;quot;.equals(elementSecondChild.getName())){
                        // 由于是 setter 注入，有一个默认构造方法，可以 newInstance()
                        object = clazz.newInstance();
                        // 1.得到 ref 的 value（userDao），通过 value 得到对象（map中id=&amp;quot;userDao&amp;quot;）
                        String refValue = elementSecondChild.attribute(&amp;quot;ref&amp;quot;).getValue();
                        // 需要注入的对象 UserDao
                        Object injectObject = map.get(refValue);
                        // 2.得到 name 的值（userDao），然后根据它获取一个 Field 的对象（UserServiceImpl 中的 UserDao userDao）
                        String nameValue = elementSecondChild.attribute(&amp;quot;name&amp;quot;).getValue();

                        // 3.通过 Field 的set 方法 set 这个对象
                        // 通过反射得到 Field 对象，即UserDao
                        Field field = clazz.getDeclaredField(nameValue);
                        field.setAccessible(true);
                        // 相等于 UserService.setUserDao(userDao)
                        // 两个参数：userService、UserDao
                        field.set(object,injectObject);
                    }else {// 通过构造方法注入 UserDao
                        // &amp;lt;constructor-arg name=&amp;quot;userDao&amp;quot; ref=&amp;quot;userDao&amp;quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
                        // 由于没有默认构造方法了，所以不可以 clazz.newInstance() 了
                        // 1.得到 ref 的 value（userDao），通过 value 得到对象（map中id=&amp;quot;userDao&amp;quot;）
                        String refValue = elementSecondChild.attribute(&amp;quot;ref&amp;quot;).getValue();
                        // 需要注入的对象 UserDao
                        Object injectObject = map.get(refValue);
                        // 得到 UserDao 的类型
                        Class injectObjectClazz = injectObject.getClass();
                        // 2.得到 UserService 的构造方法
                        Constructor constructor = clazz.getConstructor(injectObjectClazz.getInterfaces()[0]);
                        //  public UserServiceImpl(UserDao userDao){
                        object = constructor.newInstance(injectObject);

                    }
                }

                // 手动装配 &amp;gt; 自动装配。如果没有手动装配，就自动装配
                if(object == null){
                    // 如果配置了自动装配
                    if(flag){
                        if(&amp;quot;byType&amp;quot;.equals(attribute.getValue())){
                            // 1.判断是否有依赖
                            // 因为自动装配，所以&amp;lt;bean&amp;gt;没有&amp;lt;property&amp;gt;和&amp;lt;constructor&amp;gt;
                            // 就需要判断 UserServiceImpl 类中是否有属性 UserDao，
                            // 如果没有，就证明 UserServiceImpl 没有依赖；如果有，就证明 UserServiceImpl 有依赖
                            Field[] fields = clazz.getDeclaredFields();
                            for (Field field : fields) {
                                // 2.得到属性的类型，比如 private UserDao dao;那么field.getType()=UserDao.class
                                Class injectObjectClazz = field.getType();
                                /**
                                 * 由于是 byType，所以需要遍历 map 当中的所有对象，
                                 * 判断对象的类型是不是和这个 injectObjectClazz 类型相同
                                 */
                                // 记录 byType 找到的个数：比如找到多少个 UserDaoImpl
                                int count = 0;
                                Object injectObject = null;
                                for(String key : map.keySet()){
                                    Class&amp;lt;?&amp;gt; temp = map.get(key).getClass().getInterfaces()[0];
                                    if(temp.getName().equals(injectObjectClazz.getName())){
                                        injectObject = map.get(key);
                                        // 记录找到一个，因为可能找到多个
                                        count++;
                                    }
                                }
                                // 如果 byType 找到多个
                                if(count &amp;gt; 1){
                                    throw new SpringException(&amp;quot;需要一个对象，但是找到了两个对象&amp;quot;);
                                }else {
                                    // 如果只找到一个 type，注入
                                    field.setAccessible(true);
                                    object = clazz.newInstance();
                                    field.set(object, injectObject);
                                }
                            }
                        }
                    }
                }

                // 放到 map 中
                if(object == null){ //没有子标签，比如  &amp;lt;bean id=&amp;quot;userDao&amp;quot; class = &amp;quot;com.ssm.dao.impl.UserDaoImpl&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;
                    object = clazz.newInstance();
                }
                map.put(beanName,object);
            }
        } catch (DocumentException | ClassNotFoundException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
        System.out.println(map);
    }
    public Object getBean(String beanName){
        return map.get(beanName);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Exception in thread &amp;quot;main&amp;quot; com.ssm.org.spring.util.SpringException: 需要一个对象，但是找到了两个对象
	at com.ssm.org.spring.util.BeanFactory.parseXml(BeanFactory.java:137)
	at com.ssm.org.spring.util.BeanFactory.&amp;lt;init&amp;gt;(BeanFactory.java:25)
	at com.ssm.test.Test.main(Test.java:10)
&lt;/code&gt;&lt;/pre&gt;
">Spring系列（四）XML模拟SpringIOC</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/yi-pian-wen-zhang-xue-hui-jdk-dong-tai-dai-li-bing-shou-dong-mo-ni-yi-ge-dong-tai-dai-li/"" data-c="
          &lt;h1 id=&#34;什么是代理&#34;&gt;&lt;strong&gt;什么是代理&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;增强一个对象的功能&lt;/p&gt;
&lt;p&gt;买火车票，app就是一个代理，他代理了火车站；小区当中的代售窗口也是一个代理，代理了火车站。&lt;/p&gt;
&lt;h1 id=&#34;代理模式的引入&#34;&gt;代理模式的引入&lt;/h1&gt;
&lt;p&gt;1、UserDaoImpl 有一个查询数据库的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserDaoImpl{
    public void query(){
        System.out.println(&amp;quot;假装查询数据库&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、测试类中调用这个方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        UserDaoImpl userDao = new UserDaoImpl();
        LogUtil.log();
        userDao.query();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、现在有一个这样的需求：想要在每次执行 query() 时记录当前操作写到日志里面。写一个公共的日志方法 log()，那么把 LogUtil.log() 代码写到哪里呢？&lt;/p&gt;
&lt;p&gt;3.1 写到 query() 方法中：&lt;/p&gt;
&lt;p&gt;3.1.1 缺点：可能 UserDoImpl 是一个 jar，根本没有它的源码，无法进行修改。&lt;/p&gt;
&lt;p&gt;3.1.2 即使有源码，将 query() 改写成如下：破坏了单一职责。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void query(){
  LogUtil.log();
  // 进行数据库查询操作...
  System.out.println(&amp;quot;假装查询数据库&amp;quot;); 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;单一职责：只做一件事。将日志操作写到 query() 里面破坏了类的封装性，职责就不单一了 。&lt;/p&gt;
&lt;p&gt;3.2 写到 Test 类中：  每次调用查询操作前记录当前时间。&lt;/p&gt;
&lt;p&gt;缺点：会调用很多次 query 方法，也就要写很多次 Logutil.log() 大量重复代码。&lt;/p&gt;
&lt;p&gt;3.3 引入代理模式&lt;/p&gt;
&lt;h1 id=&#34;代理的名词&#34;&gt;代理的名词&lt;/h1&gt;
&lt;p&gt;代理对象——增强后的对象&lt;/p&gt;
&lt;p&gt;目标对象——被增强的对象&lt;/p&gt;
&lt;p&gt;他们不是绝对的，会根据情况发生变化&lt;/p&gt;
&lt;h1 id=&#34;java实现的代理的两种办法&#34;&gt;java实现的代理的两种办法&lt;/h1&gt;
&lt;h2 id=&#34;静态代理&#34;&gt;静态代理&lt;/h2&gt;
&lt;h3 id=&#34;继承&#34;&gt;继承&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;代理对象继承目标对象，重写需要增强的方法&lt;/li&gt;
&lt;li&gt;缺点：会代理类过多，非常复杂&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;回到上述代理模式引入的例子中：&lt;/p&gt;
&lt;p&gt;3.3 继承：自定义一个类&lt;strong&gt;继承&lt;/strong&gt;原来需要添加日志的类 UserDaoImpl，在执行业务操作前添加日志打印语句。既解决了 jar 包无法修改源码的问题，又没有破坏单一职责原则。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserDaoLogImpl extends UserDaoImpl {
    @Override
    public void query() {
        LogUtil.log();
        super.query();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        UserDao userDao = new UserDaoLogImpl();
        userDao.query();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析：如此得到了被增强后的 UserDaoImpl，可实现在 query() 前进行日志打印。&lt;/p&gt;
&lt;p&gt;UserDaoImpl：目标对象&lt;/p&gt;
&lt;p&gt;UserDaoLogImpl ：代理对象。&lt;/p&gt;
&lt;p&gt;代理对象和目标对象是相对而言的。UserDaoLogImpl 是代理对象，但是有一天它也有可能成为目标对象。&lt;/p&gt;
&lt;p&gt;4、有一个新需求：在 query 方法前添加一个权限验证。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserDaoPowerImpl extends UserDaoImpl {
    @Override
    public void query() {
        LogUtil.log(&amp;quot;power...&amp;quot;);
        super.query();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5、有一个新需求：在 query 方法前添加一个时间记录。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserDaoTimerImpl extends UserDaoImpl {
    @Override
    public void query() {
        LogUtil.log(&amp;quot;timer...&amp;quot;);
        super.query();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6、有一个新需求：在 query() 方法被调用前既实现日志打印、又实现记录当前时间的功能&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserDaoTimeAndLogImpl extends UserDaoLogImpl {
    @Override
    public void query() {
        // timer
        LogUtil.log(&amp;quot;timer...&amp;quot;);
        // logger &amp;amp; query
        super.query();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;timer...
logger...
假装查询数据库
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7、新需求：在 query() 前先打印日志，然后再记录时间&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserDaoLogAndTimeImpl extends UserDaoTimerImpl {
    @Override
    public void query() {
        LogUtil.log(&amp;quot;logger...&amp;quot;);
        // logger
        super.query();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;logger...
timer...
假装查询数据库
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只是改变了以一下日志记录顺序，就会增加一个新的类，不同的排列组合会造成代理类过多。&lt;/p&gt;
&lt;h3 id=&#34;聚合&#34;&gt;聚合&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;目标对象和代理对象实现同一个接口，代理对象当中要包含目标对象。&lt;/li&gt;
&lt;li&gt;缺点：也会产生类爆炸（UserDaoLog implements UserDao、OrderDaoLog implements OrderDao......），只不过比继承少一点点&lt;/li&gt;
&lt;li&gt;总结:如果在不确定的情况下，尽量不要去使用静态代理。因为一旦你写代码，就会产生类，一旦产生类就爆炸。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1、声明一个接口：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserDao {
    void query();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、目标对象 UserDaoImpl 实现 UserDao 接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserDaoImpl implements UserDao {
    public void query(){
        System.out.println(&amp;quot;假装查询数据库&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、代理对象实现 UserDao 接口，代理对象 UserDaoLog 中包含目标对象 UserDaoImpl（测试类传参为目标对象类）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserDaoLog implements UserDao {
    // 装饰者模式：写一个构造方法，通过传入一个目标对象指定代理/ 装饰具体的对象
    UserDao dao;
    public UserDaoLog(UserDao userDao){
        this.dao = userDao;
    }
    @Override
    public void query() {
        LogUtil.log(&amp;quot;logger...&amp;quot;);
        dao.query();
        // 代理模式：new UserDaoImpl().query();UserDao不是传递进来的，是写死的。
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、测试类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        UserDao target = new UserDaoImpl();
        UserDao proxy = new UserDaoLog(target);
        proxy.query();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;logger...
假装查询数据库 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5、新需求：记录时间&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserDaoTime implements UserDao {
    UserDao dao;
    public UserDaoTime(UserDao userDao){
        this.dao = userDao;
    }
    @Override
    public void query() {
        LogUtil.log(&amp;quot;timer...&amp;quot;);
        dao.query();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        UserDao target = new UserDaoImpl();
        UserDao proxy = new UserDaoTime(target);
        proxy.query();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;timer...
假装查询数据库
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6、新需求：完成对日志和时间的代理，无需新增一个类。只需将时间的代理对象作为目标对象，传递给日志代理对象即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        // time + logic(业务逻辑)
        UserDao target = new UserDaoTime(new UserDaoImpl());
        // log + time + logic
        UserDao proxy = new UserDaoLog(target);
        proxy.query();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;logger...
timer...
假装查询数据库
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6、新需求：完成先打印时间，再记录日志的操作。无需新增类，只需修改测试类即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        UserDao target = new UserDaoLog(new UserDaoImpl());
        UserDao proxy = new UserDaoTime(target);
        proxy.query();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;timer...
logger...
假装查询数据库动态代理
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;自己模拟的动态代理&#34;&gt;自己模拟的动态代理&lt;/h2&gt;
&lt;p&gt;如何拿到一个对象？&lt;/p&gt;
&lt;p&gt;不需要手动 new 创建类文件（因为一旦手动创建类文件，就会产生类爆炸），要通过接口反射生成一个类文件，然后调用第三方的编译技术，动态编译这个产生的类文件成 .class文件，继而利用URLClassLoader(因为这个动态产生的class不在工程当中所以需要使用URLClassLoader)把这个动态编译的类加载到 jvm 当中，最后通过反射把这个类实例化。&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先要通过接口反射生成类文件&lt;/li&gt;
&lt;li&gt;动态编译文件，将其变为 .class 文件&lt;/li&gt;
&lt;li&gt;需要一个 URLclassloader 将 .claass 加载进 jvm&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;软件性能的最终体现在IO操作&lt;/p&gt;
&lt;p&gt;file(.java) ---&amp;gt; .class ---&amp;gt; byte[] ---&amp;gt; object(Class 类对象)  ---&amp;gt; object.newInstance()&lt;/p&gt;
&lt;h3 id=&#34;准备一个接口&#34;&gt;准备一个接口：&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface TestDao {
    String query(String s1, String s2);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;准备一个接口实现类&#34;&gt;准备一个接口实现类：&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestDaoImpl implements TestDao {
    @Override
    public String query(String s1, String s2) {
        System.out.println(&amp;quot;查询数据库&amp;quot;);
        System.out.println(&amp;quot;daoImpl...&amp;quot; + s1 + &amp;quot; &amp;quot; + s2);
        return s1 + &amp;quot; &amp;quot; + s2;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;模拟动态代理&#34;&gt;模拟动态代理：&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.ssm.util;

import javax.tools.JavaCompiler;
import javax.tools.StandardJavaFileManager;
import javax.tools.ToolProvider;
import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLClassLoader;
import com.sun.jndi.toolkit.url.UrlUtil;

public class ProxyUtil {

    /**
     * 如何产生一个对象？
     *  content ---&amp;gt; String
     *  .java
     *  .class
     *  .new
     * @param target：目标对象
     * @return 代理对象
     */
    public static Object newInstance(Object target) throws IOException, IllegalAccessException, InstantiationException, NoSuchMethodException, ClassNotFoundException, InvocationTargetException {
        // targetInterface：目标对象的接口
        Class targetInterface = target.getClass().getInterfaces()[0];

        // 声明最终要返回的代理对象
        Object proxy=null;
        /**
         * package com.ssm.proxyInter;
         *
         * import com.ssm.dao.UserDao;
         *
         * public class UserDaoLog implements UserDao {
         *
         *     private UserDao target;
         *     public UserDaoLog(UserDao target){
         *         this.target = target;
         *     }
         *     @Override
         *     public void query(String p0, String p1) {
         *         System.out.println(&amp;quot;log...&amp;quot;);
         *         target.query(p0,p1);
         *     }
         * }
         * 将上述代码逐行变成字符串
         */
        // 换行
        String line = &amp;quot;\n&amp;quot;;
        // 缩进
        String tab = &amp;quot;\t&amp;quot;;
        // 得到接口名 UserDao
        String interfaceName = targetInterface.getSimpleName();
        // 得到接口中的所有方法 query()
        Method[] methods = targetInterface.getDeclaredMethods();
        String content = &amp;quot;&amp;quot;;
        String packageContent = &amp;quot;package com.ssm;&amp;quot; + line;
        String importContent = &amp;quot;import &amp;quot; + targetInterface.getName() + &amp;quot;;&amp;quot; + line;
        String classFirstLineContent = &amp;quot;public class $Proxy implements &amp;quot; +interfaceName+ &amp;quot;{&amp;quot; + line;
        String fieldContent = tab + &amp;quot;private &amp;quot; + interfaceName + &amp;quot; target;&amp;quot; + line;
        String constructorContent = tab + &amp;quot;public $Proxy (&amp;quot; + interfaceName + &amp;quot; target){&amp;quot; + line
                + tab + tab + &amp;quot;this.target = target; &amp;quot;+ line
                + tab +&amp;quot;}&amp;quot; + line;

        // 参数内容：target.query(p0,p1);
        String paramsContent = &amp;quot;&amp;quot;;
        String methodContent = &amp;quot;&amp;quot;;
        for (Method method : methods){
            // 得到当前方法的返回类型
            String returnType = method.getReturnType().getSimpleName();
            // 得到当前方法的方法名
            String methodName = method.getName();
            // 得到方法的参数类型：如 String.class
            Class[] args = method.getParameterTypes();
            // 方法参数名：query(String p0, String p1)
            String argsContent = &amp;quot;&amp;quot;;
            for (int i = 0 ; i &amp;lt; args.length ; i++){
                // 得到的是参数类型：如 String
                String temp = args[i].getSimpleName();
                // 最终构造成这个形式：String p0,String p1
                argsContent += temp + &amp;quot; p&amp;quot; + i + &amp;quot;,&amp;quot;;
                // 最终构造成这个形式：p0, p1，即 return target.query(p0, p1);
                paramsContent += &amp;quot;p&amp;quot; + i + &amp;quot;,&amp;quot;;
            }
            // 截取掉最后一个多余的 &#39;,&#39;
            if(argsContent.length() &amp;gt; 0){
                argsContent = argsContent.substring(0,argsContent.lastIndexOf(&amp;quot;,&amp;quot;));
                paramsContent = paramsContent.substring(0,paramsContent.lastIndexOf(&amp;quot;,&amp;quot;));
            }
            methodContent += tab + &amp;quot;public &amp;quot; + returnType + &amp;quot; &amp;quot; + methodName + &amp;quot;(&amp;quot; + argsContent + &amp;quot;) {&amp;quot; + line
                    + tab + tab + &amp;quot;System.out.println(\&amp;quot;log\&amp;quot;);&amp;quot; + line;
            // 判断是否有返回值
            if(&amp;quot;void&amp;quot;.equals(returnType)){
                methodContent += tab + tab + &amp;quot;target.&amp;quot; + methodName + &amp;quot;(&amp;quot; + paramsContent + &amp;quot;);&amp;quot; + line
                        + tab + &amp;quot;}&amp;quot; + line;
            }else {
                methodContent += tab + tab + &amp;quot; return target.&amp;quot; + methodName + &amp;quot;(&amp;quot; + paramsContent + &amp;quot;);&amp;quot; + line
                        + tab + &amp;quot;}&amp;quot; + line;
            }

        }

        content = packageContent + importContent + classFirstLineContent + fieldContent + constructorContent + methodContent + &amp;quot;}&amp;quot;;

        File file = new File(&amp;quot;C:\\Users\\Only\\com\\ssm\\$Proxy.java&amp;quot;);
        if(!file.exists()){
            file.createNewFile();
        }
        FileWriter fw = new FileWriter(file);
        fw.write(content);
        fw.flush();
        fw.close();

        // .java ---&amp;gt; .class
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null);
        Iterable units = fileMgr.getJavaFileObjects(file);
        JavaCompiler.CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units);
        t.call();
        fileMgr.close();

        // 通过反射得到构造函数 new 一个对象出来
        URL[] urls = new URL[]{new URL(&amp;quot;file:C:\\Users\\Only\\\\&amp;quot;)};
        URLClassLoader urlClassLoader = new URLClassLoader(urls);
        Class clazz = urlClassLoader.loadClass(&amp;quot;com.ssm.$Proxy&amp;quot;);
        Constructor constructor = clazz.getConstructor(targetInterface);
        proxy = constructor.newInstance(target);

        return proxy;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%A8%A1%E6%8B%9F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;测试类&#34;&gt;测试类&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) throws IOException, InvocationTargetException, NoSuchMethodException, ClassNotFoundException, InstantiationException, IllegalAccessException {
        TestDao proxy = (TestDao) ProxyUtil.newInstance(new TestDaoImpl());
        String res = proxy.query(&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;);
        System.out.println(&amp;quot;res = &amp;quot; + res);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终运行效果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;log
查询数据库
daoImpl...hello world
res = hello world
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;代理逻辑动态实现而不是写死的-sout&#34;&gt;代理逻辑动态实现，而不是写死的 sout&lt;/h2&gt;
&lt;h3 id=&#34;要代理的接口&#34;&gt;要代理的接口&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface TestDao {
    String delete() throws Exception;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;目标对象&#34;&gt;目标对象&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestDaoImpl implements TestDao {
    @Override
    public String delete() {
        System.out.println(&amp;quot;dao...delete&amp;quot;);
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;代理逻辑接口&#34;&gt;代理逻辑接口&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface CustomInvocationHandler {
    Object invoke(Method method);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;代理逻辑具体实现&#34;&gt;代理逻辑具体实现&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.ssm.test;
import com.ssm.dao.CustomInvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
public class TestCustomHandler implements CustomInvocationHandler {
    private Object target;
    public TestCustomHandler(Object target){
        this.target = target;
    }
    @Override
    public Object invoke(Method method) {
        System.out.println(&amp;quot;TestCustomHandler...&amp;quot;);
        try {
            return method.invoke(target);
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;自定义动态代理&#34;&gt;自定义动态代理&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.ssm.util;

import javax.tools.JavaCompiler;
import javax.tools.StandardJavaFileManager;
import javax.tools.ToolProvider;
import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLClassLoader;
import com.ssm.dao.CustomInvocationHandler;
import com.sun.jndi.toolkit.url.UrlUtil;
public class ProxyUtil {
    /**
     * 如何产生一个对象？
     *  content ---&amp;gt; String
     *  .java
     *  .class
     *  .new
     * @return
     */
    public static Object newInstance(Class targetInterface, CustomInvocationHandler h) throws IOException, IllegalAccessException, InstantiationException, NoSuchMethodException, ClassNotFoundException, InvocationTargetException {
        // targetInterface：目标对象的接口
//        Class targetInterface = target.getClass().getInterfaces()[0];

        // 声明最终要返回的代理对象
        Object proxy=null;
        /**
         * package com.ssm.proxyInter;
         *
         * import com.ssm.dao.UserDao;
         *
         * public class UserDaoLog implements UserDao {
         *
         *     private UserDao target;
         *     public UserDaoLog(UserDao target){
         *         this.target = target;
         *     }
         *     @Override
         *     public void query(String p0, String p1) {
         *         System.out.println(&amp;quot;log...&amp;quot;);
         *         target.query(p0,p1);
         *     }
         * }
         * 将上述代码逐行变成字符串
         */
        // 换行
        String line = &amp;quot;\n&amp;quot;;
        // 缩进
        String tab = &amp;quot;\t&amp;quot;;
        // 得到接口名 UserDao
        String interfaceName = targetInterface.getSimpleName();
        // 得到接口中的所有方法 query()
        Method[] methods = targetInterface.getDeclaredMethods();
        String content = &amp;quot;&amp;quot;;
        String packageContent = &amp;quot;package com.ssm;&amp;quot; + line;
        String importContent = &amp;quot;import &amp;quot; + targetInterface.getName() + &amp;quot;;&amp;quot; + line
                + &amp;quot;import com.ssm.dao.CustomInvocationHandler;&amp;quot; + line
                + &amp;quot;import java.lang.reflect.Method;&amp;quot; + line;
        String classFirstLineContent = &amp;quot;public class $Proxy implements &amp;quot; +interfaceName+ &amp;quot;{&amp;quot; + line;
        String fieldContent = tab + &amp;quot;private  CustomInvocationHandler h;&amp;quot; + line;
        String constructorContent = tab + &amp;quot;public $Proxy (CustomInvocationHandler h){&amp;quot; + line
                + tab + tab + &amp;quot;this.h = h; &amp;quot;+ line
                + tab +&amp;quot;}&amp;quot; + line;
                
        // 参数内容：target.query(p0,p1);
        String paramsContent = &amp;quot;&amp;quot;;
        String methodContent = &amp;quot;&amp;quot;;
        for (Method method : methods){
            // 得到当前方法的返回类型
            String returnType = method.getReturnType().getSimpleName();
            // 得到当前方法的方法名
            String methodName = method.getName();
            // 得到方法的参数类型：如 String.class
            Class[] args = method.getParameterTypes();
            String argsContent = &amp;quot;&amp;quot;;
            for (int i = 0 ; i &amp;lt; args.length ; i++){
                // 得到的是参数类型：如 String
                String temp = args[i].getSimpleName();
                // 最终构造成这个形式：String p0,String p1
                argsContent += temp + &amp;quot; p&amp;quot; + i + &amp;quot;,&amp;quot;;
                paramsContent += &amp;quot;p&amp;quot; + i + &amp;quot;,&amp;quot;;
            }
            // 截取掉最后一个多余的 &#39;,&#39;
            if(argsContent.length() &amp;gt; 0){
                argsContent = argsContent.substring(0,argsContent.lastIndexOf(&amp;quot;,&amp;quot;));
                paramsContent = paramsContent.substring(0,paramsContent.lastIndexOf(&amp;quot;,&amp;quot;));
            }
            methodContent += tab + &amp;quot;public &amp;quot; + returnType + &amp;quot; &amp;quot; + methodName + &amp;quot;(&amp;quot; + argsContent + &amp;quot;) throws Exception {&amp;quot; + line
                    + tab + tab + &amp;quot;Method method = Class.forName(\&amp;quot;&amp;quot; + targetInterface.getName() + &amp;quot;\&amp;quot;).getDeclaredMethod(\&amp;quot;&amp;quot; + methodName + &amp;quot;\&amp;quot;);&amp;quot; + line
                    + tab + tab + &amp;quot;return (&amp;quot;+ returnType +&amp;quot;)h.invoke(method);&amp;quot; + line
                    + tab + &amp;quot;}&amp;quot; + line;
        }

        content = packageContent + importContent + classFirstLineContent + fieldContent + constructorContent + methodContent + &amp;quot;}&amp;quot;;

        File file = new File(&amp;quot;C:\\Users\\Only\\com\\ssm\\$Proxy.java&amp;quot;);
        if(!file.exists()){
            file.createNewFile();
        }
        FileWriter fw = new FileWriter(file);
        fw.write(content);
        fw.flush();
        fw.close();

        // .java ---&amp;gt; .class
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null);
        Iterable units = fileMgr.getJavaFileObjects(file);
        JavaCompiler.CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units);
        t.call();
        fileMgr.close();

        // 通过反射得到构造函数 new 一个对象出来
        URL[] urls = new URL[]{new URL(&amp;quot;file:C:\\Users\\Only\\\\&amp;quot;)};
        URLClassLoader urlClassLoader = new URLClassLoader(urls);
        Class clazz = urlClassLoader.loadClass(&amp;quot;com.ssm.$Proxy&amp;quot;);
        Constructor constructor = clazz.getConstructor(CustomInvocationHandler.class);
        proxy = constructor.newInstance(h);

        return proxy;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;测试类-2&#34;&gt;测试类&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) throws Exception {
//         自定义动态代理
        TestDao proxy = (TestDao) ProxyUtil.newInstance(TestDao.class, new TestCustomHandler(new TestDaoImpl()));
        proxy.delete();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;TestCustomHandler...
dao...delete
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;jdk动态代理&#34;&gt;JDK动态代理&lt;/h2&gt;
&lt;p&gt;通过接口反射得到字节码 byte[] ，然后把字节码转成 class：native方法  openJDK  c++&lt;/p&gt;
&lt;h3 id=&#34;要代理的接口-2&#34;&gt;要代理的接口&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface TestDao {
    String query(String s1, String s2) throws Exception;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;目标对象-2&#34;&gt;目标对象&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestDaoImpl implements TestDao {
    @Override
    public String query(String s1, String s2) {
        System.out.println(&amp;quot;查询数据库&amp;quot;);
        System.out.println(&amp;quot;daoImpl...&amp;quot; + s1 + &amp;quot; &amp;quot; + s2);
        return s1 + &amp;quot; &amp;quot; + s2;
    } 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;代理的逻辑&#34;&gt;代理的逻辑&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.ssm.util;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class TestInvocationHandler implements InvocationHandler {
    Object target;

    /**
     *
     * @param target 目标对象
     */
    public TestInvocationHandler(Object target){
        this.target = target;
    }
    /**
     *
     * @param proxy 代理对象 $Proxy
     * @param method 目标对象 TestDao
     * @param args 目标方法的参数
     * @return
     * @throws Throwable
     *
     * 根据代理的逻辑执行：即打印 TestInvocationHandler...proxy
     * 执行目标对象的方法 ，即 TestDao 的 query()
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&amp;quot;TestInvocationHandler...proxy&amp;quot;);
        return method.invoke(target,args);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;测试类-3&#34;&gt;测试类&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) throws Exception {

        /**
         * JDK 动态代理
         * 参数：要代理哪些接口；new Class[]{TestDao.class}：TestDao 下所有方法的代理。
         *       代理的逻辑：new TestInvocationHandler(new TestDaoImpl())：在每个方法前打印 TestInvocationHandler...proxy
         */
        TestDao jdkProxy = (TestDao) Proxy.newProxyInstance(Test.class.getClassLoader(),
                new Class[]{TestDao.class},
                new TestInvocationHandler(new TestDaoImpl()));
        String result = jdkProxy.query(&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;);
        System.out.println(&amp;quot;result = &amp;quot; + result);

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;TestInvocationHandler...proxy
查询数据库
daoImpl...hello world
result = hello world
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;jdk-动态代理分析&#34;&gt;JDK 动态代理分析&lt;/h3&gt;
&lt;p&gt;JDK 动态代理：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;自定义动态代理：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;解析-proxynewproxyinstance-方法&#34;&gt;解析 Proxy.newProxyInstance 方法&lt;/h4&gt;
&lt;p&gt;JDK动态代理中最主要的方法就是 Proxy.newProxyInstance 方法，于是点进这个方法看：&lt;br&gt;
Proxy#newProxyInstance&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public static Object newProxyInstance(ClassLoader loader,
                                          Class&amp;lt;?&amp;gt;[] interfaces,
                                          InvocationHandler h)
        throws IllegalArgumentException
    {
        Objects.requireNonNull(h);

        final Class&amp;lt;?&amp;gt;[] intfs = interfaces.clone();
        final SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
        }

        /*
         * Look up or generate the designated proxy class.
         * 查找或生成指定的代理类 .java -&amp;gt; .class
         */
        Class&amp;lt;?&amp;gt; cl = getProxyClass0(loader, intfs);

        /*
         * Invoke its constructor with the designated invocation handler.
         * 使用自己实现的 InvocationHandler 作为参数，调用构造方法，获得代理类实例
         */
        try {
            if (sm != null) {
                checkNewProxyPermission(Reflection.getCallerClass(), cl);
            }

            final Constructor&amp;lt;?&amp;gt; cons = cl.getConstructor(constructorParams);
            final InvocationHandler ih = h;
            if (!Modifier.isPublic(cl.getModifiers())) {
                AccessController.doPrivileged(new PrivilegedAction&amp;lt;Void&amp;gt;() {
                    public Void run() {
                        cons.setAccessible(true);
                        return null;
                    }
                });
            }
            return cons.newInstance(new Object[]{h});
        } catch (IllegalAccessException|InstantiationException e) {
            throw new InternalError(e.toString(), e);
        } catch (InvocationTargetException e) {
            Throwable t = e.getCause();
            if (t instanceof RuntimeException) {
                throw (RuntimeException) t;
            } else {
                throw new InternalError(t.toString(), t);
            }
        } catch (NoSuchMethodException e) {
            throw new InternalError(e.toString(), e);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%BB%A3%E7%90%86%E7%B1%BB.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看到通过 Class&amp;lt;?&amp;gt; cl = getProxyClass0(loader, intfs); 产生了代理对象，于是点进 getProxyClass0() 方法&lt;/p&gt;
&lt;h4 id=&#34;class-cl-getproxyclass0loader-intfs&#34;&gt;Class&amp;lt;?&amp;gt; cl = getProxyClass0(loader, intfs);&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/getProxyClass0.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Proxy#getProxyClass0()&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    private static Class&amp;lt;?&amp;gt; getProxyClass0(ClassLoader loader,
                                           Class&amp;lt;?&amp;gt;... interfaces) {
        if (interfaces.length &amp;gt; 65535) {
            throw new IllegalArgumentException(&amp;quot;interface limit exceeded&amp;quot;);
        }

        // If the proxy class defined by the given loader implementing
        // the given interfaces exists, this will simply return the cached copy;
        // otherwise, it will create the proxy class via the ProxyClassFactory
        // // JDK对代理类进行了缓存，如果已经存在相应的代理类，则直接返回，否则才会通过ProxyClassFactory来创建代理
        return proxyClassCache.get(loader, interfaces);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果缓存中不存在相应的代理类，则通过 ProxyClassFactory来创建代理，于是点进 ProxyClassFactory ：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    private static final class ProxyClassFactory
        implements BiFunction&amp;lt;ClassLoader, Class&amp;lt;?&amp;gt;[], Class&amp;lt;?&amp;gt;&amp;gt;
    {
        // prefix for all proxy class names
        // 所有代理类名称的前缀
        private static final String proxyClassNamePrefix = &amp;quot;$Proxy&amp;quot;;

        // next number to use for generation of unique proxy class names
        // 同步类，用来实现生成代理类名字的计数器
        private static final AtomicLong nextUniqueNumber = new AtomicLong();

        @Override
        public Class&amp;lt;?&amp;gt; apply(ClassLoader loader, Class&amp;lt;?&amp;gt;[] interfaces) {

            Map&amp;lt;Class&amp;lt;?&amp;gt;, Boolean&amp;gt; interfaceSet = new IdentityHashMap&amp;lt;&amp;gt;(interfaces.length);
            for (Class&amp;lt;?&amp;gt; intf : interfaces) {
                /*
                 * Verify that the class loader resolves the name of this
                 * interface to the same Class object.
                 */
                Class&amp;lt;?&amp;gt; interfaceClass = null;
                try {
                    interfaceClass = Class.forName(intf.getName(), false, loader);
                } catch (ClassNotFoundException e) {
                }
                if (interfaceClass != intf) {
                    throw new IllegalArgumentException(
                        intf + &amp;quot; is not visible from class loader&amp;quot;);
                }
                /*
                 * Verify that the Class object actually represents an
                 * interface.
                 */
                if (!interfaceClass.isInterface()) {
                    throw new IllegalArgumentException(
                        interfaceClass.getName() + &amp;quot; is not an interface&amp;quot;);
                }
                /*
                 * Verify that this interface is not a duplicate.
                 */
                if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {
                    throw new IllegalArgumentException(
                        &amp;quot;repeated interface: &amp;quot; + interfaceClass.getName());
                }
            }

            // 代理类的包名
            String proxyPkg = null;     // package to define proxy class in
            int accessFlags = Modifier.PUBLIC | Modifier.FINAL;

            /*
             * Record the package of a non-public proxy interface so that the
             * proxy class will be defined in the same package.  Verify that
             * all non-public proxy interfaces are in the same package.
             */
            for (Class&amp;lt;?&amp;gt; intf : interfaces) {
                int flags = intf.getModifiers();
                if (!Modifier.isPublic(flags)) {
                    accessFlags = Modifier.FINAL;
                    String name = intf.getName();
                    int n = name.lastIndexOf(&#39;.&#39;);
                    String pkg = ((n == -1) ? &amp;quot;&amp;quot; : name.substring(0, n + 1));
                    if (proxyPkg == null) {
                        proxyPkg = pkg;
                    } else if (!pkg.equals(proxyPkg)) {
                        throw new IllegalArgumentException(
                            &amp;quot;non-public interfaces from different packages&amp;quot;);
                    }
                }
            }

            if (proxyPkg == null) {
                // if no non-public proxy interfaces, use com.sun.proxy package
                proxyPkg = ReflectUtil.PROXY_PACKAGE + &amp;quot;.&amp;quot;;
            }

            /*
             * Choose a name for the proxy class to generate.
             */
            // 获取计数用来生成代理类的类名（proxy+num）
            long num = nextUniqueNumber.getAndIncrement();
            // 生成类名，默认情况下，代理类的完全限定名为：com.sun.proxy.$Proxy0，com.sun.proxy.$Proxy1……依次递增
            String proxyName = proxyPkg + proxyClassNamePrefix + num;

            /*
             * Generate the specified proxy class.
             */
            // 这里才是真正的生成代理类的字节码的地方，通过ProxyGenerator.generateProxyClass方法。
            byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
                proxyName, interfaces, accessFlags);
            try {
                return defineClass0(loader, proxyName,
                                    proxyClassFile, 0, proxyClassFile.length);
            } catch (ClassFormatError e) {
                /*
                 * A ClassFormatError here means that (barring bugs in the
                 * proxy class generation code) there was some other
                 * invalid aspect of the arguments supplied to the proxy
                 * class creation (such as virtual machine limitations
                 * exceeded).
                 */
                throw new IllegalArgumentException(e.toString());
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;public-v-getk-key-p-parameter&#34;&gt;public V get(K key, P parameter) {&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/get.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;debugger&#34;&gt;debugger&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/debugger.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;v-value-supplierget&#34;&gt;V value = supplier.get();&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/suppiler.get.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;public-synchronized-v-get&#34;&gt;public synchronized V get() {&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%BF%94%E5%9B%9Evalue.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;value-objectsrequirenonnullvaluefactoryapplykey-parameter&#34;&gt;value = Objects.requireNonNull(valueFactory.apply(key, parameter))&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/requireNonNull.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;public-class-applyclassloader-loader-class-interfaces&#34;&gt;public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) {&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/apply.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;使用类加载器判断是否是同一个对象&#34;&gt;使用类加载器判断是否是同一个对象&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;判断接口的权限修饰符&#34;&gt;判断接口的权限修饰符&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%88%A4%E6%96%AD%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;string-proxyname-proxypkg-proxyclassnameprefix-num&#34;&gt;String proxyName = proxyPkg + proxyClassNamePrefix + num;&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/proxyName.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;类名加上标识0，是为了防止并发情况下产生问题。&lt;/p&gt;
&lt;h4 id=&#34;byte-proxyclassfile-proxygeneratorgenerateproxyclassproxyname-interfaces-accessflags&#34;&gt;byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/generateProxyClass.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上述通过 ProxyClassFactory 生成了代理类的 .class 文件。&lt;/p&gt;
&lt;p&gt;接下来沿着 Proxy#newProxyInstance 方法继续向下看：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        /*
         * Invoke its constructor with the designated invocation handler.
         * 使用自己实现的 InvocationHandler 作为参数，调用构造方法，获得代理类实例
         */
        try {
            if (sm != null) {
                checkNewProxyPermission(Reflection.getCallerClass(), cl);
            }

            final Constructor&amp;lt;?&amp;gt; cons = cl.getConstructor(constructorParams);
            final InvocationHandler ih = h;
            if (!Modifier.isPublic(cl.getModifiers())) {
                AccessController.doPrivileged(new PrivilegedAction&amp;lt;Void&amp;gt;() {
                    public Void run() {
                        cons.setAccessible(true);
                        return null;
                    }
                });
            }
            return cons.newInstance(new Object[]{h});
        } catch (IllegalAccessException|InstantiationException e) {
            throw new InternalError(e.toString(), e);
        } catch (InvocationTargetException e) {
            Throwable t = e.getCause();
            if (t instanceof RuntimeException) {
                throw (RuntimeException) t;
            } else {
                throw new InternalError(t.toString(), t);
            }
        } catch (NoSuchMethodException e) {
            throw new InternalError(e.toString(), e);
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;得到代理类的构造方法&#34;&gt;得到代理类的构造方法&lt;/h4&gt;
&lt;p&gt;得到上述 getProxyClass0 方法中生成的代理类 的构造方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    final Constructor&amp;lt;?&amp;gt; cons = cl.getConstructor(constructorParams);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过构造方法 new 对象出来&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    return cons.newInstance(new Object[]{h});
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%BE%97%E5%88%B0%E4%BB%A3%E7%90%86%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;使用代理类的构造方法-new-一个对象出来&#34;&gt;使用代理类的构造方法 new 一个对象出来&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95new%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%87%BA%E6%9D%A5.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;自定义模拟动态代理 与 JDK动态代理&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/JDK%E4%BB%A3%E7%90%86%E8%BF%87%E7%A8%8B.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;JDK动态代理源码分析参考文章：&lt;a href=&#34;https://www.jianshu.com/p/71bd883744e6&#34;&gt;https://www.jianshu.com/p/71bd883744e6&lt;/a&gt;&lt;/p&gt;
">Spring系列（三）一篇文章学会 JDK 动态代理并手动模拟一个动态代理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/springaop-ying-yong/"" data-c="
          &lt;h1 id=&#34;自定义注解&#34;&gt;自定义注解&lt;/h1&gt;
&lt;h2 id=&#34;xml-的作用&#34;&gt;xml 的作用？&lt;/h2&gt;
&lt;p&gt;答：&lt;strong&gt;描述数据&lt;/strong&gt;。&lt;br&gt;
举例：数据库中有一张 user 表，项目中有一个 User 类，如何将 User 类与 user 表&lt;strong&gt;关联&lt;/strong&gt;？&lt;br&gt;
答：使用 xml 来描述元数据。&lt;br&gt;
那为什么还要有自定义注解呢？因为xml 开发过程过于复杂。&lt;/p&gt;
&lt;h2 id=&#34;自定义注解-2&#34;&gt;自定义注解&lt;/h2&gt;
&lt;h3 id=&#34;一-准备阶段&#34;&gt;一、准备阶段&lt;/h3&gt;
&lt;h4 id=&#34;1定义实体类&#34;&gt;1.定义实体类&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.ssm.entity;

import com.ssm.anno.Entity;

public class CityEntity {

    private Integer id;
    private String name;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2定义工具类&#34;&gt;2.定义工具类&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.ssm.util;

public class CommonUtil {
    /**
     * 通过一个对象构建一条查询的 sql 语句
     * @param obj
     */
    public static String buildQuerySqlForEntity(Object obj){

        // 表名、字段应该根据传入的值动态变化，不应该写死
        // 办法：在实体类 CityEntity 中加入注解 @Table（需要导入JPA），我们使用自定义注解来实现
        String sql = &amp;quot;select * from ? where id=? and name=?&amp;quot;;

        return sql;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3测试方法&#34;&gt;3.测试方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
  public static void main(String[] args) {
    CommonUtil commonUtil = new CommonUtil();
    String sql = commonUtil.buildQuerySqlForEntity(new CityEntity());
    System.out.println(&amp;quot;sql = &amp;quot; + sql);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;code&gt;sql = select * from ? where id=? and name=?&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;二-自定义注解基本功能&#34;&gt;二、自定义注解——基本功能&lt;/h3&gt;
&lt;h4 id=&#34;1自定义注解&#34;&gt;1.自定义注解&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public @interface Entity {
    public String value();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2实体类添加注解&#34;&gt;2.实体类添加注解&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 注解里面的 value 方法，返回值是 String 类型
@Entity(value = &amp;quot;city&amp;quot;)
public class CityEntity {
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;三-自定义注解元注解&#34;&gt;三、自定义注解——元注解&lt;/h3&gt;
&lt;h4 id=&#34;1实体类体会元注解&#34;&gt;1.实体类体会元注解&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;@Override 只能用于修饰方法&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//@Override   
// @Override&#39; not applicable to type：@Override 不适用修饰类
public class CityEntity {
    // @Override 
    // &#39;@Override&#39; not applicable to field：@Override 不适用于修饰属性
    private Integer id;
    // @Override   
    // Method does not override method from its superclass：没有父类重写的方法。表名 @Override 注解可用于修饰方法
    public void setId(Integer id) {
        this.id = id;
    }    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析得知：@Override 注解可用于修饰方法，不可用于修饰类。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述 @Override 源码中的 &lt;code&gt;@Target(ElementType.METHOD)&lt;/code&gt; 就表示：@Override 只能用于修饰方法。&lt;/p&gt;
&lt;p&gt;于是我们来改动一下我们的自定义注解 @Entity，让它只能用于修饰类，不能用于修饰方法。&lt;br&gt;
我们可以看到 ElementType 为一个枚举类，可取的值：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum ElementType {
    /** Class, interface (including annotation type), or enum declaration */
    TYPE,

    /** Field declaration (includes enum constants) */
    FIELD,

    /** Method declaration */
    METHOD,

    /** Formal parameter declaration */
    PARAMETER,

    /** Constructor declaration */
    CONSTRUCTOR,

    /** Local variable declaration */
    LOCAL_VARIABLE,

    /** Annotation type declaration */
    ANNOTATION_TYPE,

    /** Package declaration */
    PACKAGE,

    /**
     * Type parameter declaration
     *
     * @since 1.8
     */
    TYPE_PARAMETER,

    /**
     * Use of a type
     *
     * @since 1.8
     */
    TYPE_USE
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2修改自定义注解类&#34;&gt;2.修改自定义注解类&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// @Entity 注解能够出现的目标位置：TYPE：类
@Target(ElementType.TYPE)
// @Target({ElementType.TYPE, ElementType.FIELD})：指定多个可以出现的位置：类、
public @interface Entity {
    public String value();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;四-获得注解内的值&#34;&gt;四、获得注解内的值&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.ssm.util;

import com.ssm.anno.Entity;

import java.lang.annotation.Annotation;

public class CommonUtil {
  public String buildQuerySqlForEntity(Object obj){
    String sql = &amp;quot;&amp;quot;;

    // 得到类的类对象
    Class clazz = obj.getClass();
    // setup1 判断是否加了这个注解
    if(clazz.isAnnotationPresent(Entity.class)){
      // setup2 得到注解
      Entity entity = (Entity) clazz.getDeclaredAnnotation(Entity.class);
      // setup3 调用方法
      String value = entity.value();  // city

      // 表名、字段应该根据传入的值动态变化，不应该写死
      // 办法：在实体类 CityEntity 中加入注解 @Table（需要导入JPA），我们使用自定义注解来实现
      sql = &amp;quot;select * from &amp;quot; + value + &amp;quot; where id = ? and name = ?&amp;quot;;
    }
    return sql;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行测试类发现，输出结果为 sql =&lt;br&gt;
经过 DEBUG 分析：&lt;code&gt;if(clazz.isAnnotationPresent(Entity.class)){&lt;/code&gt; 判断返回 false，&lt;br&gt;
而 &lt;code&gt;clazz = class com.ssm.entity.CityEntity&lt;/code&gt;，CityEntity 也确实添加了 @Entity 注解呀，到底为什么 &lt;code&gt;clazz.isAnnotationPresent(Entity.class)&lt;/code&gt; 会返回 false 呢？&lt;br&gt;
之前说过可以通过 “在实体类 CityEntity 中加入注解 @Table（需要导入JPA）”来实现读取表名的操作，于是我们添加 JPA 依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- https://mvnrepository.com/artifact/org.hibernate.javax.persistence/hibernate-jpa-2.0-api --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.hibernate.javax.persistence&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;hibernate-jpa-2.0-api&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0.1.Final&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看 @Table 注解的源码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Target(TYPE)
@Retention(RUNTIME)
public @interface Table {
	/**
	 * (Optional) The name of the table.
	 * &amp;lt;p/&amp;gt;
	 * Defaults to the entity name.
	 */
	String name() default &amp;quot;&amp;quot;;

	/**
	 * (Optional) The catalog of the table.
	 * &amp;lt;p/&amp;gt;
	 * Defaults to the default catalog.
	 */
	String catalog() default &amp;quot;&amp;quot;;

	/**
	 * (Optional) The schema of the table.
	 * &amp;lt;p/&amp;gt;
	 * Defaults to the default schema for user.
	 */
	String schema() default &amp;quot;&amp;quot;;

	/**
	 * (Optional) Unique constraints that are to be placed on
	 * the table. These are only used if table generation is in
	 * effect. These constraints apply in addition to any constraints
	 * specified by the &amp;lt;code&amp;gt;Column&amp;lt;/code&amp;gt; and &amp;lt;code&amp;gt;JoinColumn&amp;lt;/code&amp;gt;
	 * annotations and constraints entailed by primary key mappings.
	 * &amp;lt;p/&amp;gt;
	 * Defaults to no additional constraints.
	 */
	UniqueConstraint[] uniqueConstraints() default { };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果发现 @Table 上不仅有 &lt;code&gt;@Target(TYPE)&lt;/code&gt; 注解，而且还有一个&lt;code&gt;@Retention(RUNTIME)&lt;/code&gt; 注解，那么这个注解是用来干什么的呢？答：注解生命周期&lt;/p&gt;
&lt;h2 id=&#34;注解生命周期&#34;&gt;注解生命周期&lt;/h2&gt;
&lt;h3 id=&#34;retentionretentionpolicysource&#34;&gt;@Retention(RetentionPolicy.SOURCE)&lt;/h3&gt;
&lt;p&gt;注解的生命周期：默认情况下仅仅存在于 Java 源码中，即@Retention(RetentionPolicy.SOURCE)，当 JVM 一旦把它编译成字节码，注解会自动丢失。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%B3%A8%E8%A7%A3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9FSOURCE.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;retentionretentionpolicyclass&#34;&gt;@Retention(RetentionPolicy.CLASS)&lt;/h3&gt;
&lt;p&gt;会存在于 .class 文件中，但是在代码被运行时还是会被 JVM 忽略。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%B3%A8%E8%A7%A3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9FCLASS.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
测试：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.ssm.util;

import com.ssm.anno.Entity;

public class CommonUtil {

    public static String buildQuerySqlForEntity(Object obj){
        // 得到类的类对象
        Class clazz = obj.getClass();
        // setup1 判断是否加了这个注解
        boolean b = clazz.isAnnotationPresent(Entity.class); // false
        System.out.println(b);

        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;retentionretentionpolicyruntime&#34;&gt;@Retention(RetentionPolicy.RUNTIME)&lt;/h3&gt;
&lt;p&gt;只有当注解的生命周期声明为 RUNTIME 时，在执行时才会被 JVM 发觉到。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;boolean b = clazz.isAnnotationPresent(Entity.class);//true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;于是在 @Entity 上添加 &lt;code&gt;@Retention(RetentionPolicy.RUNTIME)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Entity {
  public String value();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行测试类输出结果：&lt;code&gt;sql = select * from city where id = ? and name = ?&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;aop-是什么&#34;&gt;AOP 是什么&lt;/h1&gt;
&lt;p&gt;传统的OOP开发中的代码逻辑是自上而下的，而这些过程会产生一些横切性问题，这些横切性的问题和我们的主业务逻辑关系不大，这些横切性问题不会影响到主逻辑实现的，但是会散落到代码的各个部分，难以维护。AOP就是用来&lt;strong&gt;处理横切性问题&lt;/strong&gt;，AOP的编程思想就是把这些问题和主业务逻辑分开，达到与主业务逻辑解耦的目的。使代码的重用性和开发效率更高。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/AOP%E6%98%AF%E4%BB%80%E4%B9%88.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;aop-的应用场景&#34;&gt;AOP 的应用场景&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;日志记录&lt;/li&gt;
&lt;li&gt;权限验证&lt;/li&gt;
&lt;li&gt;效率检查&lt;/li&gt;
&lt;li&gt;事务管理&lt;/li&gt;
&lt;li&gt;exception&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;springaop-的底层技术&#34;&gt;SpringAOP 的底层技术&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;JDK动态代理&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;CGLIB代理&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;编译时期的织入还是运行时期的织入?&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;运行时期织入&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;运行时期织入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;初始化时期织入还是获取对象时期织入？&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;初始化时期织入&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;初始化时期织入&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;springaop-和-aspectj-的关系&#34;&gt;SpringAOP 和 AspectJ 的关系&lt;/h2&gt;
&lt;p&gt;AOP 是一种概念&lt;br&gt;
SpringAOP、AspectJ 都是 AOP 的实现，SpringAOP 有自己的语法，但是语法复杂，所以SpringAOP 借助了AspectJ 的注解，但是底层实现还是自己的&lt;br&gt;
AspectJ 是静态注入：编译（.java -&amp;gt; .class）时就完成了注入，SpringAOP是动态注入：运行时才注入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;spring AOP提供两种编程风格
@AspectJ support         ------------&amp;gt;利用aspectj的注解
Schema-based AOP support -----------&amp;gt;xml aop:config 命名空间

证明：通过源码分析，我们可以知道 spring 底层使用的是 JDK 或者 CGLIB 来完成的代理，并且在官网上spring 给出了 aspectj 的文档，和 springAOP 是不同的。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果您只需要建议在Spring bean上执行操作，那么Spring AOP是正确的选择。如果需要通知Spring容器没有管理的对象(通常是域对象)，则需要使用AspectJ。&lt;br&gt;
Spring AOP的概念&lt;br&gt;
参考链接：&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-introduction-defn&#34;&gt;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-introduction-defn&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;aspect:一定要给spring去管理  抽象  aspectj-&amp;gt;类&lt;/li&gt;
&lt;li&gt;pointcut:切点表示连接点的集合  -----------------&amp;gt;   表 （我的理解：PointCut是JoinPoint的谓语，这是一个动作，主要是告诉通知连接点在哪里，切点表达式决定 JoinPoint 的数量）&lt;/li&gt;
&lt;li&gt;Joinpoint:连接点   目标对象中的方法 ----------------&amp;gt;    记录（我的理解：JoinPoint是要关注和增强的方法，也就是我们要作用的点）&lt;/li&gt;
&lt;li&gt;Weaving :把代理逻辑加入到目标对象上的过程叫做织入&lt;/li&gt;
&lt;li&gt;target 目标对象 原始对象&lt;/li&gt;
&lt;li&gt;aop Proxy 代理对象  包含了原始对象的代码和增加后的代码的那个对象&lt;/li&gt;
&lt;li&gt;advice:通知    (位置 + logic)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;aspect-切面&#34;&gt;Aspect 切面&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Aspect: A modularization of a concern that cuts across multiple classes. Transaction management is a good example of a crosscutting concern in enterprise Java applications. In Spring AOP, aspects are implemented by using regular classes (the schema-based approach) or regular classes annotated with the @Aspect annotation (the @AspectJ style).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;切面是：通知、切点、连接点的载体。通知、连接点要放到哪里去，好比 Java 中的属性、方法、构造方法，这些东西要放到哪里去？放到一个类里面，这个类就是方法以及参数属性的载体。切面就是连接点、切点、通知的载体，把这些连接点、切点、通知所在的位置称之为一个切面。&lt;/p&gt;
&lt;h2 id=&#34;join-point-连接点&#34;&gt;Join point 连接点&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Join point: A point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;连接点：程序执行过程中的一个点，如方法的执行或异常的处理。在Spring AOP中，连接点总是表示方法执行。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/AOP%E8%BF%9E%E6%8E%A5%E7%82%B9.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
ProceedingJoinPoint 和 JoinPoint 的区别:&lt;br&gt;
ProceedingJoinPoint  继承了JoinPoint ,proceed()这个是aop代理链执行的方法。并扩充实现了proceed()方法，用于继续执行连接点。JoinPoint 仅能获取相关参数，无法执行连接点。&lt;br&gt;
JoinPoint 的方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;java.lang.Object[] getArgs()：获取连接点方法运行时的入参列表；&lt;/li&gt;
&lt;li&gt;Signature getSignature() ：获取连接点的方法签名对象；&lt;/li&gt;
&lt;li&gt;java.lang.Object getTarget() ：获取连接点所在的目标对象；&lt;/li&gt;
&lt;li&gt;java.lang.Object getThis() ：获取代理对象本身；&lt;br&gt;
proceed()有重载,有个带参数的方法,可以修改目标方法的的参数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Advice 通知&lt;br&gt;
Advice: Action taken by an aspect at a particular join point. Different types of advice include “around”, “before” and “after” advice. (Advice types are discussed later.) Many AOP frameworks, including Spring, model an advice as an interceptor and maintain a chain of interceptors around the join point.&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/AOP%E9%80%9A%E7%9F%A5.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;advice通知类型:
&lt;ul&gt;
&lt;li&gt;Before 连接点执行之前，但是无法阻止连接点的正常执行，除非该段执行抛出异常&lt;/li&gt;
&lt;li&gt;After  连接点正常执行之后，执行过程中正常执行返回退出，非异常退出&lt;/li&gt;
&lt;li&gt;After throwing  执行抛出异常的时候&lt;/li&gt;
&lt;li&gt;After (finally)  无论连接点是正常退出还是异常退出，都会执行&lt;/li&gt;
&lt;li&gt;Around advice: 围绕连接点执行，例如方法调用。这是最有用的切面方式。around通知可以在方法调用之前和之后执行自定义行为。它还负责选择是继续加入点还是通过返回自己的返回值或抛出异常来快速建议的方法执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;after&#34;&gt;After&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@After(&amp;quot;pointCutTarget()&amp;quot;)
public void after(){
    System.out.println(&amp;quot;after&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;before&#34;&gt;Before&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Before(&amp;quot;pointCut()&amp;quot;)
public void before(JoinPoint joinPoint){
    System.out.println(&amp;quot;before&amp;quot;);
    System.out.println(joinPoint.getThis());
    System.out.println(joinPoint.getTarget());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;断点调试：&lt;br&gt;
1、joinPoint.getThis()&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%BF%9E%E6%8E%A5%E7%82%B9%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%BF%9E%E6%8E%A5%E7%82%B9%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
2、joinPoint.getTarget()&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%BF%9E%E6%8E%A5%E7%82%B9%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_3.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;around&#34;&gt;Around&lt;/h3&gt;
&lt;p&gt;在通知中拿到连接点，然后执行连接点。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Around(&amp;quot;pointCut()&amp;quot;)
// ProceedingJoinPoint：正在进行的 JointPoint：正在增强的方法
public void around(ProceedingJoinPoint pjp) throws Throwable {
    System.out.println(&amp;quot;around...before&amp;quot;);
    // 拿到方法并执行它
    pjp.proceed();
    System.out.println(&amp;quot;around...after&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;around...before
query
around...after
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;xml-通知&#34;&gt;XML 通知&lt;/h3&gt;
&lt;p&gt;1、编写 xml，定义切面、连接点、通知&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:aop=&amp;quot;http://www.springframework.org/schema/aop&amp;quot;
       xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans
                         http://www.springframework.org/schema/beans/spring-beans.xsd
                         http://www.springframework.org/schema/aop
                         http://www.springframework.org/schema/aop/spring-aop.xsd
                         http://www.springframework.org/schema/context
                         http://www.springframework.org/schema/context/spring-context.xsd&amp;quot;&amp;gt;

    &amp;lt;context:component-scan base-package=&amp;quot;com.ssm&amp;quot;/&amp;gt;
    &amp;lt;!-- 定义一个切面 --&amp;gt;
    &amp;lt;aop:config&amp;gt;
        &amp;lt;!-- 定义一个连接点 --&amp;gt;
        &amp;lt;aop:pointcut id=&amp;quot;allDao&amp;quot; expression=&amp;quot;execution(* com.ssm.dao.*.*(..))&amp;quot;/&amp;gt;
        &amp;lt;!-- 通知包含两部分：位置 pointcut-ref 、逻辑 ref --&amp;gt;
        &amp;lt;aop:aspect id=&amp;quot;aspect&amp;quot; ref=&amp;quot;xmlBean&amp;quot;&amp;gt;
            &amp;lt;aop:before pointcut-ref=&amp;quot;allDao&amp;quot;
                    method=&amp;quot;before&amp;quot;/&amp;gt;
        &amp;lt;/aop:aspect&amp;gt;
    &amp;lt;/aop:config&amp;gt;

    &amp;lt;bean id=&amp;quot;xmlBean&amp;quot; class=&amp;quot;com.ssm.app.XMLAopBean&amp;quot;/&amp;gt;
    &amp;lt;bean id=&amp;quot;indexDao&amp;quot; class=&amp;quot;com.ssm.dao.impl.IndexDaoImpl&amp;quot;/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、编写通知的逻辑&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class XMLAopBean {
    public void before(){
        System.out.println(&amp;quot;xml before...&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、测试&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestXML {
    public static void main(String[] args) throws IOException {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&amp;quot;spring.xml&amp;quot;);
        IndexDao dao = (IndexDao) context.getBean(&amp;quot;indexDao&amp;quot;);
        dao.query(&amp;quot;hello&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;xml before...
query
hello
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;环绕通知中改变参数值&#34;&gt;环绕通知中改变参数值&lt;/h4&gt;
&lt;p&gt;1、传递进来的参数为 &amp;quot;hello&amp;quot;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) throws IOException {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        IndexDao dao = (IndexDao) context.getBean(&amp;quot;indexDao&amp;quot;);
        dao.query(&amp;quot;hello&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、在环绕通知内将参数修改为  hello  world&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Around(&amp;quot;pointCut()&amp;quot;)
// ProceedingJoinPoint：正在进行的 JointPoint：正在增强的方法 
public void around(ProceedingJoinPoint pjp) throws Throwable {
    Object[] args = pjp.getArgs();
    if(args != null &amp;amp;&amp;amp; args.length &amp;gt; 0){
        for (int i = 0; i &amp;lt; args.length; i++) {
            args[i] += &amp;quot; world&amp;quot;;
        }
    }
    System.out.println(&amp;quot;around...before&amp;quot;);
    // 拿到方法并执行它
    pjp.proceed(args);
    System.out.println(&amp;quot;around...after&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、输出参数值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Repository(&amp;quot;indexDao&amp;quot;)
public class IndexDaoImpl implements IndexDao {
    @Override
    public void query(String str){
        System.out.println(&amp;quot;query&amp;quot;);
        System.out.println(str);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、输出结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;around...before
query
hello world
around...after
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;pointcut-切点&#34;&gt;Pointcut 切点&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Pointcut: A predicate that matches join points. Advice is associated with a pointcut expression and runs at any join point matched by the pointcut (for example, the execution of a method with a certain name). The concept of join points as matched by pointcut expressions is central to AOP, and Spring uses the AspectJ pointcut expression language by default.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;切点：连接点的集合。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/AOP%E5%88%87%E7%82%B9.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Introduction: Declaring additional methods or fields on behalf of a type. Spring AOP lets you introduce new interfaces (and a corresponding implementation) to any advised object. For example, you could use an introduction to make a bean implement an IsModified interface, to simplify caching. (An introduction is known as an inter-type declaration in the AspectJ community.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;实例&#34;&gt;实例&lt;/h3&gt;
&lt;p&gt;1、准备一个 IndexDao 接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface IndexDao {
    void query(String str);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、准备一个 IndexDao 接口的实现类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Repository(&amp;quot;indexDao&amp;quot;)
public class IndexDaoImpl implements IndexDao {
    @Override
    public void query(String str){
        System.out.println(&amp;quot;query&amp;quot;);
        System.out.println(str);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、再准备一个接口 OrderDAO，并把它注入到 Spring 容器中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Repository(&amp;quot;orderDao&amp;quot;)
public class OrderDao {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、引入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
// 切面
@Aspect
public class NotVeryUsefulAspect {
     // 找到 com.ssm.dao 下的所有类，让它引入 IndexDao 接口的 IndexDaoImpl 实现，
    // 即让 class OrderDao implements IndexDao，并且方法的具体实现与 IndexDaoImpl 相同
    @DeclareParents(value=&amp;quot;com.ssm.dao.*&amp;quot;, defaultImpl= IndexDaoImpl.class)
    public static IndexDao indexDao;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5、测试&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) throws IOException {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        IndexDao dao = (IndexDao) context.getBean(&amp;quot;orderDao&amp;quot;);
        dao.query(&amp;quot;hello&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;query
hello
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6、分析：orderDao 内并没有方法，但是获得容器内的 OrderDao 对象后却可以正常调用  query() 方法，原因就是使用了 Introduction。&lt;/p&gt;
&lt;h2 id=&#34;aspect-instantiation-models&#34;&gt;Aspect Instantiation Models&lt;/h2&gt;
&lt;p&gt;使用方式如下：&lt;br&gt;
@Aspect(&amp;quot;perthis(this(com.chenss.dao.IndexDaoImpl))&amp;quot;)&lt;br&gt;
要求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;AspectJ对象的注入类型为prototype&lt;/li&gt;
&lt;li&gt;目标对象也必须是prototype的&lt;br&gt;
原因为：只有目标对象是原型模式的，每次getBean得到的对象才是不一样的，由此针对每个对象就会产生新的切面对象，才能产生不同的切面结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;
&lt;p&gt;1、多例的 IndexDaoImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Repository(&amp;quot;indexDao&amp;quot;)
@Scope(&amp;quot;prototype&amp;quot;)
public class IndexDaoImpl implements IndexDao {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、单例的切面&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
@Aspect
public class NotVeryUsefulAspect {
    // 切点 com.ssm.dao 下的子包下的任意类的任意方法 任意返回值 任意修饰符
    @Pointcut(&amp;quot;execution(* com.ssm.dao.*.*(..))&amp;quot;)
    public void pointCut(){
    }

    @Around(&amp;quot;pointCut()&amp;quot;)
    // ProceedingJoinPoint：正在进行的 JointPoint：正在增强的方法
    public void around(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println(&amp;quot;this.hashCode = &amp;quot; + this.hashCode());
        Object[] args = pjp.getArgs();
        if(args != null &amp;amp;&amp;amp; args.length &amp;gt; 0){
            for (int i = 0; i &amp;lt; args.length; i++) {
                args[i] += &amp;quot; world&amp;quot;;
            }
        }
        System.out.println(&amp;quot;around...before&amp;quot;);
        // 拿到方法并执行它
        pjp.proceed(args);
        System.out.println(&amp;quot;around...after&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、测试类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) throws IOException {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        IndexDao dao = (IndexDao) context.getBean(&amp;quot;indexDao&amp;quot;);
        IndexDao dao1 = (IndexDao) context.getBean(&amp;quot;indexDao&amp;quot;);
        // com.ssm.dao.impl.IndexDaoImpl@24aed80c : com.ssm.dao.impl.IndexDaoImpl@3a52dba3
        System.out.println(dao+&amp;quot; : &amp;quot;+dao1);
        dao.query(&amp;quot;hello&amp;quot;);
        System.out.println(&amp;quot; - - - - - - - - - - - &amp;quot;);
        dao1.query(&amp;quot;hi&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;com.ssm.dao.impl.IndexDaoImpl@24aed80c : com.ssm.dao.impl.IndexDaoImpl@3a52dba3
this.hashCode = 1792550665
around...before
query
hello world
around...after
 - - - - - - - - - - - 
this.hashCode = 1792550665
around...before
query
hi world
around...after
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、分析：&lt;br&gt;
当 IndexDaoImpl 设置为原型时，两次 context.getBean(&amp;quot;indexDaoImpl&amp;quot;) 得到的 IndexDaoImpl 是不同的对象。但是不同的 bean 对象得到的切面却是完全相同的。&lt;/p&gt;
&lt;p&gt;更改：AspectJ 对象的注入类型为 prototype，为所有代理对象是 IndexDaoImpl 的单独创建一个切点出来&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
// 为所有代理对象是 IndexDaoImpl 的单独创建一个切点出来
@Aspect(&amp;quot;perthis(this(com.ssm.dao.impl.IndexDaoImpl))&amp;quot;)
@Scope(&amp;quot;prototype&amp;quot;)
public class NotVeryUsefulAspect {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CJLIB 动态代理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
// 开启 AspectJ 语法支持
@EnableAspectJAutoProxy(proxyTargetClass=true)
public class AppConfig {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;com.ssm.dao.impl.IndexDaoImpl@672872e1 : com.ssm.dao.impl.IndexDaoImpl@32910148
this.hashCode = 254801937
around...before
query
hello world
around...after
 - - - - - - - - - - - 
this.hashCode = 90767234
around...before
query
hi world
around...after
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;target-object目标对象&#34;&gt;Target object：目标对象&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Target object: An object being advised by one or more aspects. Also referred to as the “advised object”. Since Spring AOP is implemented by using runtime proxies, this object is always a proxied object.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/AOP%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;aop-proxy-代理对象&#34;&gt;AOP proxy 代理对象&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;AOP proxy: An object created by the AOP framework in order to implement the aspect contracts (advise method executions and so on). In the Spring Framework, an AOP proxy is a JDK dynamic proxy or a CGLIB proxy.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;weaving&#34;&gt;Weaving&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Weaving: linking aspects with other application types or objects to create an advised object. This can be done at compile time (using the AspectJ compiler, for example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks, performs weaving at runtime.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/AOP%E7%BB%87%E5%85%A5.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;springaop-支持-aspectj&#34;&gt;SpringAOP 支持 AspectJ&lt;/h1&gt;
&lt;p&gt;AOP 和 SpringAOP 的 关系？SpringAOP 是 AOP 的一种实现。&lt;br&gt;
实现 AOP 的技术：AspectJ、SpringAOP&lt;br&gt;
SpringAOP 和 AspectJ 的关系？Spring 原先版本的 AOP 语法过于繁琐，于是 Spring 借助了 AspectJ 的语法，底层技术还是用的 Spring 底层的技术。&lt;br&gt;
参考资料：&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-ataspectj&#34;&gt;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-ataspectj&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;0-导入-spring-依赖&#34;&gt;0、导入 Spring 依赖&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;5.0.9.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;准备一个 IndexDao：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Repository
public class IndexDao {
    public void query(){
        System.out.println(&amp;quot;query&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1-启用aspectj支持&#34;&gt;1、启用@AspectJ支持&lt;/h2&gt;
&lt;h3 id=&#34;java-configuration&#34;&gt;Java Configuration&lt;/h3&gt;
&lt;p&gt;要使用Java @Configuration启用@AspectJ支持，请添加@EnableAspectJAutoProxy注释&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
@EnableAspectJAutoProxy
public class AppConfig {

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;xml&#34;&gt;XML&lt;/h3&gt;
&lt;p&gt;要使用基于xml的配置启用@AspectJ支持，可以使用&lt;code&gt;&amp;lt;aop:aspectj-autoproxy/&amp;gt;&lt;/code&gt;元素&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;aop:aspectj-autoproxy/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-声明一个aspect&#34;&gt;2、声明一个Aspect&lt;/h2&gt;
&lt;p&gt;引入 Aspect 依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;aspectjweaver&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.9.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;声明一个@Aspect注释类，并且定义成一个bean交给Spring管理。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
@Aspect
public class UserAspect {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-声明一个pointcut&#34;&gt;3、声明一个PointCut&lt;/h2&gt;
&lt;p&gt;切入点表达式由@Pointcut注释表示。切入点声明由两部分组成:一个签名包含名称和任何参数，以及一个切入点表达式，该表达式确定我们对哪个方法执行感兴趣。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Pointcut(&amp;quot;execution(* transfer(..))&amp;quot;)// 切入点表达式
private void anyOldTransfer() {}// 切入点签名
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;切入点确定感兴趣的 join points（连接点），从而使我们能够控制何时执行通知。Spring AOP只支持Spring bean的方法执行 join points（连接点），所以您可以将切入点看作是匹配Spring bean上方法的执行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 声明Aspect，并且交给spring容器管理
 */
@Component
@Aspect
public class UserAspect {
    /**
     * 声明切入点，匹配UserDao所有方法调用
     * execution匹配方法执行连接点
     * within:将匹配限制为特定类型中的连接点
     * args：参数
     * target：目标对象
     * this：代理对象
     */
    @Pointcut(&amp;quot;execution(* com.yao.dao.UserDao.*(..))&amp;quot;)
    public void pintCut(){
        System.out.println(&amp;quot;point cut&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-声明一个advice通知&#34;&gt;4、声明一个Advice通知&lt;/h2&gt;
&lt;p&gt;advice通知与pointcut切入点表达式相关联，并在切入点匹配的方法执行@Before之前、@After之后或前后运行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 声明Aspect，并且交给spring容器管理
 */
@Component
@Aspect
public class UserAspect {
    /**
     * 声明切入点，匹配UserDao所有方法调用
     * execution匹配方法执行连接点
     * within:将匹配限制为特定类型中的连接点
     * args：参数
     * target：目标对象
     * this：代理对象
     */
    @Pointcut(&amp;quot;execution(* com.yao.dao.UserDao.*(..))&amp;quot;)
    public void pintCut(){
        System.out.println(&amp;quot;point cut&amp;quot;);
    }
    /**
     * 声明before通知,在pintCut切入点前执行
     * 通知与切入点表达式相关联，
     * 并在切入点匹配的方法执行之前、之后或前后运行。
     * 切入点表达式可以是对指定切入点的简单引用，也可以是在适当位置声明的切入点表达式。
     */
    @Before(&amp;quot;com.yao.aop.UserAspect.pintCut()&amp;quot;)
    public void beforeAdvice(){
        System.out.println(&amp;quot;before&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        IndexDao dao = context.getBean(IndexDao.class);
        dao.query();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;before
query
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;各种连接点-joinpoint-的意义&#34;&gt;各种连接点 JoinPoint 的意义:&lt;/h1&gt;
&lt;h2 id=&#34;execution&#34;&gt;execution&lt;/h2&gt;
&lt;p&gt;用于匹配方法执行连接点，最小粒度&lt;strong&gt;方法&lt;/strong&gt;，在 aop 中主要使用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern)
          throws-pattern?)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里问号表示当前项可以有也可以没有，其中各项的语义如下：&lt;br&gt;
modifiers-pattern：方法的可见性，如public，protected；&lt;br&gt;
ret-type-pattern：方法的返回值类型，如int，void等；&lt;br&gt;
declaring-type-pattern：方法所在类的全路径名，如com.spring.Aspect；&lt;br&gt;
name-pattern：方法名类型，如 buisinessService()；&lt;br&gt;
param-pattern：方法的参数类型，如java.lang.String；&lt;br&gt;
throws-pattern：方法抛出的异常类型，如java.lang.Exception；&lt;/p&gt;
&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;@&lt;code&gt;Pointcut(&amp;quot;execution(* com.chenss.dao.*.*(..))&amp;quot;)&lt;/code&gt;&lt;br&gt;
匹配com.chenss.dao包下的任意接口和类的任意方法【方法返回值类型任意，方法所在类的全路径名：com.chenss.dao，方法名类型任意，方法的参数类型任意】&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Pointcut(&amp;quot;execution(public * com.chenss.dao.*.*(..))&amp;quot;)&lt;/code&gt;&lt;br&gt;
匹配com.chenss.dao包下的任意接口和类的public方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Pointcut(&amp;quot;execution(public * com.chenss.dao.*.*())&amp;quot;)&lt;/code&gt;&lt;br&gt;
匹配com.chenss.dao包下的任意接口和类的public 无方法参数的方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Pointcut(&amp;quot;execution(* com.chenss.dao.*.*(java.lang.String, ..))&amp;quot;)&lt;/code&gt;&lt;br&gt;
匹配com.chenss.dao包下的任意接口和类的第一个参数为String类型的方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Pointcut(&amp;quot;execution(* com.chenss.dao.*.*(java.lang.String))&amp;quot;)&lt;/code&gt;&lt;br&gt;
匹配com.chenss.dao包下的任意接口和类的只有一个参数，且参数为String类型的方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Pointcut(&amp;quot;execution(* com.chenss.dao.*.*(java.lang.String))&amp;quot;)&lt;/code&gt;&lt;br&gt;
匹配com.chenss.dao包下的任意接口和类的只有一个参数，且参数为String类型的方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Pointcut(&amp;quot;execution(public * *(..))&amp;quot;)&lt;/code&gt;&lt;br&gt;
匹配任意的public方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Pointcut(&amp;quot;execution(* te*(..))&amp;quot;)&lt;/code&gt;&lt;br&gt;
匹配任意的以te开头的方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Pointcut(&amp;quot;execution(* com.chenss.dao.IndexDao.*(..))&amp;quot;)&lt;/code&gt;&lt;br&gt;
匹配com.chenss.dao.IndexDao接口中任意的方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Pointcut(&amp;quot;execution(* com.chenss.dao..*.*(..))&amp;quot;)&lt;/code&gt;&lt;br&gt;
匹配com.chenss.dao包及其子包中任意的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于这个表达式的详细写法,可以脑补也可以参考官网很容易的,可以作为一个看 Spring 官网文档的入门,打破你害怕看官方文档的心理,其实你会发觉官方文档也是很容易的&lt;br&gt;
&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-pointcuts-examples&#34;&gt;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-pointcuts-examples&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于 Spring 切面粒度最小是达到方法级别，而 execution 表达式可以用于明确指定方法返回类型，类名，方法名和参数名等与方法相关的信息，并且在 Spring 中，大部分需要使用 AOP 的业务场景也只需要达到方法级别即可，因而 execution 表达式的使用是最为广泛的。&lt;/p&gt;
&lt;h2 id=&#34;within&#34;&gt;within&lt;/h2&gt;
&lt;p&gt;表达式的最小粒度为类&lt;br&gt;
within 与 execution 相比，粒度更大，仅能实现到&lt;strong&gt;包和接口、类&lt;/strong&gt;级别。而 execution 可以精确到方法的返回值，参数个数、修饰符、参数类型等&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Pointcut(&amp;quot;within(com.chenss.dao.*)&amp;quot;)   // 匹配com.chenss.dao包中的任意方法
@Pointcut(&amp;quot;within(com.chenss.dao..*)&amp;quot;)  // 匹配com.chenss.dao包及其子包中的任意方法
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;args&#34;&gt;args&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;args: Limits matching to join points (the execution of methods when using Spring AOP) where the arguments are instances of the given types.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;限制连接点的匹配 (使用Spring AOP时方法的执行)，其中的参数是给定类型的实例。&lt;br&gt;
args 表达式的作用是匹配&lt;strong&gt;指定参数类型和指定参数数量的方法&lt;/strong&gt;，与包名和类名无关&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * args同execution不同的地方在于：
 * args匹配的是运行时传递给方法的参数类型
 * execution(* *(java.io.Serializable))匹配的是方法在声明时指定的方法参数类型。
 */
@Pointcut(&amp;quot;args(java.io.Serializable)&amp;quot;)     // 匹配运行时传递的参数类型为指定类型的、且参数个数和顺序匹配
@Pointcut(&amp;quot;@args(com.chenss.anno.Chenss)&amp;quot;)      // 接受一个参数，并且传递的参数的运行时类型具有@Classified
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;this&#34;&gt;this&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;this: Limits matching to join points (the execution of methods when using Spring AOP) where the bean reference (Spring AOP proxy) is an instance of the given type.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;限制连接点 (使用Spring AOP时方法的执行) 的匹配，其中 bean 引用 (Spring AOP代理) 是给定类型的实例。&lt;br&gt;
&lt;strong&gt;this JDK代理时，指向接口和代理类proxy，cglib代理时 指向接口和子类(不使用proxy)&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;target&#34;&gt;target&lt;/h2&gt;
&lt;p&gt;target: Limits matching to join points (the execution of methods when using Spring AOP) where the target object (application object being proxied) is an instance of the given type.&lt;br&gt;
限制对连接点 (使用Spring AOP时方法的执行) 的匹配，其中目标对象 (代理的应用程序对象) 是给定类型的实例。&lt;br&gt;
&lt;strong&gt;target  指向接口和子类&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 此处需要注意的是，如果配置设置proxyTargetClass=false，或默认为false，则是用JDK代理，否则使用的是CGLIB代理
 * JDK代理的实现方式是基于接口实现，代理类继承Proxy，实现接口。
 * 而 CGLIB 继承被代理的类来实现。
 * 所以使用 target 会保证目标不变，关联对象不会受到这个设置的影响。
 * 但是使用 this 对象时，会根据该选项的设置，判断是否能找到对象。
 */
@Pointcut(&amp;quot;target(com.chenss.dao.IndexDaoImpl)&amp;quot;)    // 目标对象，也就是被代理的对象。限制目标对象为com.chenss.dao.IndexDaoImpl类
@Pointcut(&amp;quot;this(com.chenss.dao.IndexDaoImpl)&amp;quot;)  // 当前对象，也就是代理对象，代理对象时通过代理目标对象的方式获取新的对象，与原值并非一个
@Pointcut(&amp;quot;@target(com.chenss.anno.Chenss)&amp;quot;)    // 具有@Chenss的目标对象中的任意方法
@Pointcut(&amp;quot;@within(com.chenss.anno.Chenss)&amp;quot;)    // 等同于@target
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个比较难.......&lt;br&gt;
proxy模式里面有两个重要的术语&lt;br&gt;
proxy Class&lt;br&gt;
target Class&lt;br&gt;
CGLIB 和 JDK 的区别：JDK 是基于接口，CGLIB 是基于继承，所有 this 可以在 CGLIB 作用&lt;/p&gt;
&lt;h2 id=&#34;annotation&#34;&gt;@annotation&lt;/h2&gt;
&lt;p&gt;这个很简单........&lt;br&gt;
作用&lt;strong&gt;方法&lt;/strong&gt;级别&lt;br&gt;
上述所有表达式都有@ 比如@Target(里面是一个注解类xx,表示所有加了xx注解的类,和包名无关)&lt;br&gt;
注意:上述所有的表达式可以混合使用,|| &amp;amp;&amp;amp; !&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Before(&amp;quot;pointCutWithin()&amp;amp;&amp;amp;!pointCutArgs()&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Pointcut(&amp;quot;@annotation(com.chenss.anno.Chenss)&amp;quot;)    // 匹配带有com.chenss.anno.Chenss注解的方法
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如下面这个方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Chenss
public void query(String str){
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;bean&#34;&gt;bean&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Pointcut(&amp;quot;bean(dao1)&amp;quot;)     // 名称为 dao1 的 bean 上的任意方法
@Pointcut(&amp;quot;bean(dao*)&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;aop-proxies&#34;&gt;AOP Proxies&lt;/h1&gt;
&lt;p&gt;参考链接：&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-introduction-proxies&#34;&gt;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-introduction-proxies&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring AOP defaults to using standard JDK dynamic proxies for AOP proxies. This enables any interface (or set of interfaces) to be proxied.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Spring AOP 默认使用标准 JDK 动态代理来完成 AOP 代理。这允许代理任何接口(或一组接口)。&lt;/p&gt;
&lt;h2 id=&#34;问题引入&#34;&gt;问题引入&lt;/h2&gt;
&lt;p&gt;1、定义一个接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface IndexDao {
    void query(String str);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、自定义一个注解&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Retention(RetentionPolicy.RUNTIME)
public @interface Luban {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、定义切面，@annotation 连接点&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
// 切面
@Aspect
public class NotVeryUsefulAspect {
    @Pointcut(&amp;quot;@annotation(com.ssm.anno.Luban)&amp;quot;)
    public void pointCutAnno(){
    }
    /**
     * 通知
     *  通知位置：pointCut() 的前面
     *  通知内容
     */
    @Before(&amp;quot;pointCutAnno()&amp;quot;)
    public void before(){
        System.out.println(&amp;quot;before&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、接口实现类，使用注解增强 query 方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Repository(&amp;quot;indexDao&amp;quot;)
public class IndexDaoImpl implements IndexDao {
    @Override
    @Luban
    public void query(String str){
        System.out.println(&amp;quot;query&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5、配置文件类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
// 开启 AspectJ 语法支持
@EnableAspectJAutoProxy
public class AppConfig {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6、测试类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        IndexDao dao = (IndexDao) context.getBean(&amp;quot;indexDao&amp;quot;);
        System.out.println(dao instanceof IndexDaoImpl);
        dao.query(&amp;quot;111&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7、运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;false
before
query
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;8、分析：为什么我们将一个 IndexDaoImpl 放入 Spring 容器（@Repository），然后再从 Spring 容器内取出来（context.getBean(&amp;quot;indexDao&amp;quot;)）类型却不是 IndexDaoImpl 了呢？&lt;br&gt;
9、在配置类中加上：@EnableAspectJAutoProxy(proxyTargetClass = true) 后，设置代理方式为 cglib 代理：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
// 开启 AspectJ 语法支持
@EnableAspectJAutoProxy(proxyTargetClass = true)
public class AppConfig {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;System.out.println(dao instanceof IndexDaoImpl); 返回 true 了。&lt;br&gt;
注：proxyTargetClass 默认是 false，所以 dao instanceof IndexDaoImpl 返回 false。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;boolean proxyTargetClass() default false;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;spring-aop-默认使用标准-jdk-动态代理来完成-aop-代理&#34;&gt;Spring AOP 默认使用标准 JDK 动态代理来完成 AOP 代理&lt;/h2&gt;
&lt;p&gt;当我们使用 JDK 动态代理时，即 @EnableAspectJAutoProxy(proxyTargetClass = false)，从 Spring 容器中取出来的对象与放进去的对象不一致：context.getBean(&amp;quot;indexDao&amp;quot;) instanceof IndexDaoImpl 返回 false。&lt;br&gt;
但是 context.getBean(&amp;quot;indexDao&amp;quot;) instanceof indexDao 返回 true，因为 JDK 动态代理底层用的是接口。&lt;br&gt;
context.getBean(&amp;quot;indexDao&amp;quot;) instanceof Proxy 也返回 true。&lt;br&gt;
实现代理的办法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承&lt;/li&gt;
&lt;li&gt;聚合接口（JDK 动态代理基于聚合）&lt;/li&gt;
&lt;li&gt;动态代理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;jdk-动态代理为什么只能是基于接口不能用继承&#34;&gt;JDK 动态代理为什么只能是基于接口，不能用继承？&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) throws IOException {
        Class&amp;lt;?&amp;gt;[] interfaces = new Class[]{IndexDao.class};
        byte[] bytes = ProxyGenerator.generateProxyClass(&amp;quot;SSM&amp;quot;,interfaces);
        File file = new File(&amp;quot;C:\\Users\\Only\\Test.class&amp;quot;);
        FileOutputStream fw = new FileOutputStream(file);
        fw.write(bytes);
        fw.flush();
        fw.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：ProxyGenerator 的使用是基于 JDK8 的，如果使用 JDK10 会报 “找不到符号” 错误，参考：&lt;a href=&#34;https://blog.csdn.net/weixin_46034990/article/details/105892718&#34;&gt;https://blog.csdn.net/weixin_46034990/article/details/105892718&lt;/a&gt;&lt;br&gt;
JDK 底层源码已经帮这个对象自动继承了一个 Proxy 对象了，由于 Java 是单继承，所以不可能再去继承目标对象，所以只能实现目标对象的接口。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
基于上图可以看出，这个代理对象等于 IndexDao、也等于 Proxy，但是不等于 IndexDaoImpl，这也就解释了上述 【context.getBean(&amp;quot;indexDao&amp;quot;) instanceof IndexDaoImpl 返回 false。context.getBean(&amp;quot;indexDao&amp;quot;) instanceof indexDao 返回 true、context.getBean(&amp;quot;indexDao&amp;quot;) instanceof Proxy 也返回 true。】的原因。&lt;/p&gt;
&lt;h2 id=&#34;this-切点&#34;&gt;this 切点&lt;/h2&gt;
&lt;p&gt;this 表示&lt;strong&gt;代理对象&lt;/strong&gt;的匹配类型&lt;br&gt;
前提：使用 JDK 动态代理，即 @EnableAspectJAutoProxy(proxyTargetClass = false)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
// 切面
@Aspect
public class NotVeryUsefulAspect {
    // this 表示代理对象的匹配类型，使用 JDK 动态代理后，代理对象的类型是：Proxy、IndexDao，但不是 IndexDaoImpl
    @Pointcut(&amp;quot;this(com.ssm.dao.IndexDao)&amp;quot;)
    public void pointCutThis(){
        System.out.println(&amp;quot;point cut&amp;quot;);
    }
    /**
     * 通知
     *  通知位置：pointCut() 的前面
     *  通知内容
     */
    @Before(&amp;quot;pointCutThis()&amp;quot;)
    public void before(){
        System.out.println(&amp;quot;before&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;增强成功：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;before
query
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// this 表示代理对象的匹配类型，使用 JDK 动态代理后，代理对象的类型是：Proxy、IndexDao，但不是 IndexDaoImpl
@Pointcut(&amp;quot;this(com.ssm.dao.impl.IndexDaoImpl)&amp;quot;)
public void pointCutThis(){
    System.out.println(&amp;quot;point cut&amp;quot;);
}

@Before(&amp;quot;pointCutThis()&amp;quot;)
public void before(){
    System.out.println(&amp;quot;before&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;增强失败：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;query
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;spring-aop-xml实现方式的注意事项&#34;&gt;Spring AOP XML实现方式的注意事项:&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;在aop:config中定义切面逻辑，允许重复出现，重复多次，以最后出现的逻辑为准，但是次数以出现的次数为准&lt;/li&gt;
&lt;li&gt;aop:aspect ID重复不影响正常运行，依然能够有正确结果&lt;/li&gt;
&lt;li&gt;aop:pointcut ID重复会出现覆盖，以最后出现的为准。不同aop:aspect内出现的pointcut配置，可以相互引用&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:aop=&amp;quot;http://www.springframework.org/schema/aop&amp;quot;
       xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/aop
                           http://www.springframework.org/schema/aop/spring-aop.xsd
                           http://www.springframework.org/schema/context
                           http://www.springframework.org/schema/context/spring-context.xsd&amp;quot;&amp;gt;
    &amp;lt;!-- 定义开始进行注解扫描 --&amp;gt;
    &amp;lt;context:component-scan base-package=&amp;quot;com.chenss&amp;quot;&amp;gt;&amp;lt;/context:component-scan&amp;gt;

    &amp;lt;!-- 定义AspectJ对象使用的逻辑类，类中提供切面之后执行的逻辑方法 --&amp;gt;
    &amp;lt;bean id=&amp;quot;aspectAop&amp;quot; class=&amp;quot;com.chenss.aspectj.Aspect&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&amp;quot;aspectAop2&amp;quot; class=&amp;quot;com.chenss.aspectj.Aspect2&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&amp;quot;indexDao&amp;quot; class=&amp;quot;com.chenss.entity.IndexDao&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;

    &amp;lt;!--在Config中定义切面逻辑，允许重复出现，重复多次，以最后出现的逻辑为准，但是次数以出现的次数为准--&amp;gt;
    &amp;lt;aop:config&amp;gt;
        &amp;lt;!-- aop:aspect ID重复不影响正常运行，依然能够有正确结果 --&amp;gt;
        &amp;lt;!-- aop:pointcut ID重复会出现覆盖，以最后出现的为准。不同aop:aspect内出现的pointcut配置，可以相互引用 --&amp;gt;
        &amp;lt;aop:aspect id=&amp;quot;aspect&amp;quot; ref=&amp;quot;aspectAop&amp;quot;&amp;gt;
            &amp;lt;aop:pointcut id=&amp;quot;aspectCut&amp;quot; expression=&amp;quot;execution(* com.chenss.entity.*.*())&amp;quot;/&amp;gt;
            &amp;lt;aop:before method=&amp;quot;before&amp;quot; pointcut-ref=&amp;quot;aspectCut&amp;quot;&amp;gt;&amp;lt;/aop:before&amp;gt;
      
            &amp;lt;aop:pointcut id=&amp;quot;aspectNameCut&amp;quot; expression=&amp;quot;execution(* com.chenss.entity.*.*(java.lang.String, ..))&amp;quot;/&amp;gt;
            &amp;lt;aop:before method=&amp;quot;before2&amp;quot; pointcut-ref=&amp;quot;aspectNameCut&amp;quot;&amp;gt;&amp;lt;/aop:before&amp;gt;
        &amp;lt;/aop:aspect&amp;gt;
    &amp;lt;/aop:config&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
">Spring系列（二）SpringAOP 应用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/spring-ioc/"" data-c="
          &lt;h1 id=&#34;what-is-ioc&#34;&gt;what is IOC&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;控制反转&lt;/strong&gt;（Inversion of Control，缩写为&lt;strong&gt;IOC&lt;/strong&gt;），是面向对象编程中的一种&lt;strong&gt;设计原则&lt;/strong&gt;，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称&lt;strong&gt;DI&lt;/strong&gt;），还有一种方式叫“依赖查找”（Dependency Lookup）&lt;/p&gt;
&lt;h2 id=&#34;ioc-和-di-的关系&#34;&gt;IOC 和 DI 的关系&lt;/h2&gt;
&lt;p&gt;IOC 是一种&lt;strong&gt;目标&lt;/strong&gt;，DI 是实现 IOC 的&lt;strong&gt;技术手段&lt;/strong&gt;。IOC 与 DI 的关系好似 ORM（对象关系映射） 和 Mybatis 的关系一样。&lt;/p&gt;
&lt;h2 id=&#34;dependency-injection&#34;&gt;Dependency Injection&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;依赖注入&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;关于什么是依赖&#34;&gt;关于什么是依赖&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// IndexService 依赖了 IndexDao 对象
public class IndexServiceImpl implements IndexService{
  private IndexDao indexDao;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;当一个类中拥有一个类的属性，或者构造方法中传了一个值，就可以说：当前这个类依赖于这个属性，或者依赖于构造方法里传入的对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Student 类中有一个 Address 类的属性，Student 类依赖于 Address 属性。&lt;/p&gt;
&lt;p&gt;Student 类的构造方法的参数中有一个 Address 类，Student 类依赖于构造方法里传入的 Address 对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Student{
  private String name;
  private Integer age;
  private Address address;
  publci Student(String name,Integer age,Address address){
    this.name = name;
    this.age = age;
    this.address = address;
  }
}

public class Address{
  private String province;
  private String city;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;为什么要使用-spring-ioc&#34;&gt;为什么要使用 Spring IOC&lt;/h1&gt;
&lt;h2 id=&#34;面向抽象编程&#34;&gt;面向抽象编程&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class IndexServiceImpl implements IndexService{
  public void test(){
     // 这样的写法会造成高耦合
     IndexDao indexDao = new IndexDaoImpl();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假设有一天要对这个 IndexDao 进行一个代理，就不能通过 new 了，而是通过 Proxy.newXXX(); 就需要&lt;strong&gt;更改代码&lt;/strong&gt;为：IndexDao indexDao = Proxy.newXXX(); &lt;strong&gt;一个类的产生不应该由程序员自己 new 出来&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;面向抽象编程正确写法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class IndexServiceImpl implements IndexService{
  private IndexDao indexDao;
    public void test(){
     indexDao.call();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;无论 IndexDao 是代理还是本身实现，它都叫做 IndexDao，如果有一天需要一个代理类的话，只需要产生一个代理类，并且把这个代理类的代理对象&lt;strong&gt;传递过来就可以了&lt;/strong&gt;。如果有一天不需要这个代理对象了，只需要把这个对象 new 出来传过来就可以了。&lt;/p&gt;
&lt;h2 id=&#34;如何传递过来呢&#34;&gt;如何传递过来呢？&lt;/h2&gt;
&lt;p&gt;提供一个 &lt;strong&gt;setter&lt;/strong&gt; 或&lt;strong&gt;构造方法&lt;/strong&gt;把这个类传递过来。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class IndexServiceImpl implements IndexService{
  // 1.setter 方法
  // 2.构造方法，别人在 new 这个ServiceImpl 时就需要把具体的实现传进来
    public IndexServiceImpl(IndexDao dao){
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;spring体系结构-ioc的位置&#34;&gt;spring体系结构----IOC的位置&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://spring.io/projects&#34;&gt;https://spring.io/projects&lt;/a&gt;&lt;br&gt;
Spring Framework&lt;br&gt;
Provides core support for dependency injection, transaction management, web apps, data access, messaging and more.&lt;br&gt;
提供了 DI、事务管理、web 开发和更多的核心支持&lt;br&gt;
&lt;a href=&#34;https://spring.io/projects/spring-framework&#34;&gt;https://spring.io/projects/spring-framework&lt;/a&gt;&lt;br&gt;
Features（特点）&lt;br&gt;
Core technologies（核心技术）: dependency injection（DI）, events, resources, i18n, validation, data binding, type conversion, SpEL, AOP.&lt;br&gt;
Testing: mock objects, TestContext framework, Spring MVC Test, WebTestClient.&lt;br&gt;
Data Access: transactions, DAO support, JDBC, ORM, Marshalling XML.&lt;br&gt;
Spring MVC and Spring WebFlux web frameworks.&lt;br&gt;
Integration: remoting, JMS, JCA, JMX, email, tasks, scheduling, cache.&lt;br&gt;
Languages: Kotlin, Groovy, dynamic languages.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;容器&#34;&gt;容器&lt;/h2&gt;
&lt;p&gt;在日常程序开发过程当中，我们推荐&lt;strong&gt;面向抽象&lt;/strong&gt;编程，面向抽象编程会产生&lt;strong&gt;类的依赖&lt;/strong&gt;，当然如果你够强大可以自己写一个&lt;strong&gt;管理的容器&lt;/strong&gt;，但是既然spring以及实现了，并且spring如此优秀，我们仅仅需要学习spring框架便可。&lt;/p&gt;
&lt;p&gt;当我们有了一个管理对象的容器之后，&lt;strong&gt;类的产生过程交给了容器&lt;/strong&gt;，至于我们自己的app则可以不需要去关系这些对象的产生了。&lt;/p&gt;
&lt;h1 id=&#34;spring-实现-ioc-的思路和方法&#34;&gt;Spring 实现 IOC 的思路和方法&lt;/h1&gt;
&lt;p&gt;Spring 实现 IOC 的思路是&lt;strong&gt;提供一些配置信息用来描述类之间的依赖关系，然后由容器去解析这些配置信息，继而维护好对象之间的依赖关系&lt;/strong&gt;，前提是对象之间的依赖关系必须在类中定义好，比如 A.class 中有一个 B.class 的属性，那么我们可以理解为 A 依赖了 B。既然我们在类中已经定义了他们之间的依赖关系那么为什么还需要在配置文件中去描述和定义呢？&lt;/p&gt;
&lt;h2 id=&#34;spring-实现-ioc-的思路大致可以拆分成-3-点&#34;&gt;Spring 实现 IOC 的思路大致可以拆分成 3 点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;应用程序中提供类，提供依赖关系（属性或者构造方法）&lt;/li&gt;
&lt;li&gt;把需要交给容器管理的&lt;strong&gt;对象&lt;/strong&gt;通过配置信息告诉容器（xml、Annotation，JavaConfig）&lt;/li&gt;
&lt;li&gt;把各个类之间的&lt;strong&gt;依赖关系&lt;/strong&gt;通过配置信息告诉容器&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/springIOC.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;1、定义一个类 A，把类 A 和 类 B 的关系通过应用程序描述出来：类 A 中有一个类 B 的属性&lt;br&gt;
2、将类 A、类 B 交给 Spring 容器进行管理：使用 &lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt;&lt;br&gt;
3、在 xml 定义中描述类 A、类 B 之间的依赖关系&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;既然我们在类中已经定义了他们之间的依赖关系那么为什么还需要在配置文件中去描述和定义呢&#34;&gt;既然我们在类中已经定义了他们之间的依赖关系那么为什么还需要在配置文件中去描述和定义呢？&lt;/h2&gt;
&lt;p&gt;类中定义了但是 Spring 感知不到你是否需要依赖注入&lt;/p&gt;
&lt;p&gt;配置这些信息的方法有三种分别是 xml，Annotation 和 JavaConfig&lt;/p&gt;
&lt;p&gt;维护的过程称为&lt;strong&gt;自动注入&lt;/strong&gt;，自动注入的方法有两种：&lt;strong&gt;构造方法&lt;/strong&gt; 和 &lt;strong&gt;setter&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自动注入的值可以是对象，数组，map，list和常量比如字符串整型等&lt;/p&gt;
&lt;h1 id=&#34;spring编程的风格&#34;&gt;spring编程的风格&lt;/h1&gt;
&lt;h2 id=&#34;schemal-based-xml&#34;&gt;schemal-based-------xml&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-schema-declaring-an-aspect&#34;&gt;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-schema-declaring-an-aspect&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;aop:config&amp;gt;
    &amp;lt;aop:aspect id=&amp;quot;myAspect&amp;quot; ref=&amp;quot;aBean&amp;quot;&amp;gt;
        ...
    &amp;lt;/aop:aspect&amp;gt;
&amp;lt;/aop:config&amp;gt;

&amp;lt;bean id=&amp;quot;aBean&amp;quot; class=&amp;quot;...&amp;quot;&amp;gt;
    ...
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;annotation-based-annotation&#34;&gt;annotation-based-----annotation&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-advice-before&#34;&gt;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-advice-before&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect
public class BeforeExample {

    @Before(&amp;quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&amp;quot;)
    public void doAccessCheck() {
        // ...
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-required-annotation&#34;&gt;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-required-annotation&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Required
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;java-based-java-configuration&#34;&gt;java-based----java Configuration&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-java-basic-concepts&#34;&gt;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-java-basic-concepts&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class AppConfig {

    @Bean
    public MyService myService() {
        return new MyServiceImpl();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;注入&#34;&gt;注入&lt;/h1&gt;
&lt;p&gt;想看一部电影，可以有如下两种方法：&lt;/p&gt;
&lt;p&gt;① 输入 url 到迅雷，然后下载下来：&lt;strong&gt;依赖查找&lt;/strong&gt;：输入一个 url 找到一个资源。&lt;/p&gt;
&lt;p&gt;② 下载一个播放器，输入我想要看的类型，就会自动推送这个类型的电影列表。&lt;/p&gt;
&lt;p&gt;IOC 也是如此，仅仅需要在代码中提供依赖关系，由容器维护好，自动把对象提供给我们使用，给的过程称之为&lt;strong&gt;注入&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;注入：提供一个 setter 方法或构造方法，Spring 就会把对象给我们。给我们的过程称为注入。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring3 有接口注入，但是从 Spring4 开始就已经取消了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;spring注入详细配置字符串-数组等&#34;&gt;spring注入详细配置（字符串、数组等）&lt;/h2&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-properties-detailed&#34;&gt;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-properties-detailed&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;字符串属性注入&#34;&gt;&lt;strong&gt;字符串属性注入&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;使用 value：&lt;code&gt;&amp;lt;property name=&amp;quot;str&amp;quot; value=&amp;quot;&amp;quot;/&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.ssm.dao.impl;
import com.ssm.dao.IndexDao;
public class IndexDaoImpl implements IndexDao {
    private String str=&amp;quot;&amp;quot;;
    public void setStr(String str) {
        this.str = str;
    }
    public String getStr() {
        return str;
    }
    @Override
    public void test() {
        System.out.println(&amp;quot;IndexDaoImpl...&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;dao&amp;quot; class=&amp;quot;com.ssm.dao.impl.IndexDaoImpl&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;str&amp;quot; value=&amp;quot;Hello world&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;myDataSource&amp;quot; class=&amp;quot;org.apache.commons.dbcp.BasicDataSource&amp;quot; destroy-method=&amp;quot;close&amp;quot;&amp;gt;
    &amp;lt;!-- results in a setDriverClassName (String) call --&amp;gt;
    &amp;lt;property name=&amp;quot;driverClassName&amp;quot; value=&amp;quot;com.mysql.jdbc.Driver&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;jdbc:mysql://localhost:3306/mydb&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;root&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;masterkaoli&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;内部-bean&#34;&gt;内部 bean&lt;/h3&gt;
&lt;p&gt;原来是通过在 &lt;code&gt;&amp;lt;property ref=&amp;quot;xxx&amp;quot;/&amp;gt;&lt;/code&gt;，ref 引入外部 bean&lt;/p&gt;
&lt;p&gt;内部 bean 是 &lt;code&gt;&amp;lt;property&amp;gt;&amp;lt;bean&amp;gt; ... &amp;lt;/bean&amp;gt;&amp;lt;/property&amp;gt;&lt;/code&gt;，在 property 标签内部注入 bean&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;outer&amp;quot; class=&amp;quot;...&amp;quot;&amp;gt;
    &amp;lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&amp;gt;
    &amp;lt;property name=&amp;quot;target&amp;quot;&amp;gt;
        &amp;lt;bean class=&amp;quot;com.example.Person&amp;quot;&amp;gt; &amp;lt;!-- this is the inner bean --&amp;gt;
            &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;Fiona Apple&amp;quot;/&amp;gt;
            &amp;lt;property name=&amp;quot;age&amp;quot; value=&amp;quot;25&amp;quot;/&amp;gt;
        &amp;lt;/bean&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;collections&#34;&gt;Collections&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;moreComplexObject&amp;quot; class=&amp;quot;example.ComplexObject&amp;quot;&amp;gt;
    &amp;lt;!-- results in a setAdminEmails(java.util.Properties) call --&amp;gt;
    &amp;lt;property name=&amp;quot;adminEmails&amp;quot;&amp;gt;
        &amp;lt;props&amp;gt;
            &amp;lt;prop key=&amp;quot;administrator&amp;quot;&amp;gt;administrator@example.org&amp;lt;/prop&amp;gt;
            &amp;lt;prop key=&amp;quot;support&amp;quot;&amp;gt;support@example.org&amp;lt;/prop&amp;gt;
            &amp;lt;prop key=&amp;quot;development&amp;quot;&amp;gt;development@example.org&amp;lt;/prop&amp;gt;
        &amp;lt;/props&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;!-- results in a setSomeList(java.util.List) call --&amp;gt;
    &amp;lt;property name=&amp;quot;someList&amp;quot;&amp;gt;
        &amp;lt;list&amp;gt;
            &amp;lt;value&amp;gt;a list element followed by a reference&amp;lt;/value&amp;gt;
            &amp;lt;ref bean=&amp;quot;myDataSource&amp;quot; /&amp;gt;
        &amp;lt;/list&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;!-- results in a setSomeMap(java.util.Map) call --&amp;gt;
    &amp;lt;property name=&amp;quot;someMap&amp;quot;&amp;gt;
        &amp;lt;map&amp;gt;
            &amp;lt;entry key=&amp;quot;an entry&amp;quot; value=&amp;quot;just some string&amp;quot;/&amp;gt;
            &amp;lt;entry key =&amp;quot;a ref&amp;quot; value-ref=&amp;quot;myDataSource&amp;quot;/&amp;gt;
        &amp;lt;/map&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;!-- results in a setSomeSet(java.util.Set) call --&amp;gt;
    &amp;lt;property name=&amp;quot;someSet&amp;quot;&amp;gt;
        &amp;lt;set&amp;gt;
            &amp;lt;value&amp;gt;just some string&amp;lt;/value&amp;gt;
            &amp;lt;ref bean=&amp;quot;myDataSource&amp;quot; /&amp;gt;
        &amp;lt;/set&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;xml-shortcut-with-the-p-namespace&#34;&gt;XML Shortcut with the p-namespace&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring supports extensible configuration formats with namespaces, which are based on an XML Schema definition. The beans configuration format discussed in this chapter is defined in an XML Schema document. However, the p-namespace is not defined in an XSD file and exists only in the core of Spring.&lt;/p&gt;
&lt;p&gt;Spring 支持带有名称空间的可扩展配置格式，这些名称空间基于XML模式定义。本章讨论的 bean 配置格式是在 XML 模式文档中定义的。但是，p-namespace 并没有在 XSD 文件中定义，它只存在于Spring 的核心中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、在原有的基础上添加 &lt;code&gt;xmlns:p=&amp;quot;http://www.springframework.org/schema/p&amp;quot;&lt;/code&gt; 命名空间&lt;/p&gt;
&lt;p&gt;2、&amp;lt;bean id=&amp;quot;dao&amp;quot; class=&amp;quot;com.ssm.dao.impl.IndexDaoImpl&amp;quot; &lt;span style=&#34;color:red&#34;&gt;p:str=&amp;quot;Hello world&amp;quot;&lt;/span&gt;&amp;gt;注入 等价于 原有的 &lt;code&gt;&amp;lt;property name=&amp;quot;str&amp;quot; value=&amp;quot;Hello world&amp;quot;/&amp;gt;&lt;/code&gt;  注入。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:p=&amp;quot;http://www.springframework.org/schema/p&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&amp;quot;&amp;gt;

    &amp;lt;bean id=&amp;quot;dao&amp;quot; class=&amp;quot;com.ssm.dao.impl.IndexDaoImpl&amp;quot; p:str=&amp;quot;Hello world&amp;quot;&amp;gt;
&amp;lt;!--        &amp;lt;property name=&amp;quot;str&amp;quot; value=&amp;quot;Hello world&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;--&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;xml-shortcut-with-the-c-namespace&#34;&gt;XML Shortcut with the c-namespace&lt;/h3&gt;
&lt;p&gt;如果类中定义了构造函数注入，但 bean 标签内没有声明 &lt;code&gt;&amp;lt;constructor-arg&amp;gt;&lt;/code&gt;就会产生 &lt;code&gt;Caused by: java.lang.NoSuchMethodException: com.ssm.service.IndexService.&amp;lt;init&amp;gt;()&lt;/code&gt; 异常&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&amp;quot;service&amp;quot; class=&amp;quot;com.ssm.service.IndexService&amp;quot;&amp;gt;
&amp;lt;!--        &amp;lt;constructor-arg ref=&amp;quot;dao&amp;quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;--&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 c-namespace 注入：&lt;br&gt;
1、添加 &lt;code&gt;xmlns:c=&amp;quot;http://www.springframework.org/schema/c&amp;quot;&lt;/code&gt; 命名空间&lt;/p&gt;
&lt;p&gt;2、&amp;lt;bean id=&amp;quot;service&amp;quot; class=&amp;quot;com.ssm.service.IndexService&amp;quot; &lt;span style=&#34;color:red&#34;&gt; c:indexDao-ref=&amp;quot;dao&amp;quot;&lt;/span&gt;&amp;gt; 注入 等价于 原来的  &lt;code&gt;&amp;lt;bean id=&amp;quot;service&amp;quot; class=&amp;quot;com.ssm.service.IndexService&amp;quot;&amp;gt; &amp;lt;constructor-arg ref=&amp;quot;dao&amp;quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt; &amp;lt;/bean&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:p=&amp;quot;http://www.springframework.org/schema/p&amp;quot;
       xmlns:c=&amp;quot;http://www.springframework.org/schema/c&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&amp;quot;&amp;gt;

    &amp;lt;bean id=&amp;quot;dao&amp;quot; class=&amp;quot;com.ssm.dao.impl.IndexDaoImpl&amp;quot; p:str=&amp;quot;Hello world&amp;quot;&amp;gt; 
&amp;lt;!--        &amp;lt;property name=&amp;quot;str&amp;quot; value=&amp;quot;Hello world&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;--&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&amp;quot;service&amp;quot; class=&amp;quot;com.ssm.service.IndexService&amp;quot; c:indexDao-ref=&amp;quot;dao&amp;quot;&amp;gt;
&amp;lt;!--        &amp;lt;constructor-arg ref=&amp;quot;dao&amp;quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;--&amp;gt;
    &amp;lt;/bean&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;spring-通过-setter-注入的应用实例&#34;&gt;Spring 通过 setter 注入的应用实例&lt;/h2&gt;
&lt;p&gt;1、pom.xml 导入 spring 依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- ioc 90% 以上的内容 --&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;5.0.9.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、应用程序中提供类，提供依赖关系（属性或者构造方法）&lt;/p&gt;
&lt;p&gt;IndexDao 类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.ssm.dao;

public interface IndexDao {
    void test();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;IndexDaoImpl 类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.ssm.dao.impl;

import com.ssm.dao.IndexDao;

public class IndexDaoImpl implements IndexDao {

    @Override
    public void test() {
        System.out.println(&amp;quot;IndexDaoImpl...&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;IndexService 依赖 IndexDao：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提供 setter 方法：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.ssm.service;

import com.ssm.dao.IndexDao;

public class IndexService {

    private IndexDao indexDao;

    public void service(){
        indexDao.test();
    }

    // 提供 setter 方法
    public void setIndexDao(IndexDao indexDao) {
        this.indexDao = indexDao;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、把需要交给容器管理的对象通过配置信息告诉容器（xml、Annotation，JavaConfig）&lt;/p&gt;
&lt;p&gt;4、把各个类之间的依赖关系通过配置信息告诉容器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&amp;quot;&amp;gt;

    &amp;lt;bean id=&amp;quot;dao&amp;quot; class=&amp;quot;com.ssm.dao.impl.IndexDaoImpl&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&amp;quot;service&amp;quot; class=&amp;quot;com.ssm.service.IndexService&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;indexDao&amp;quot; ref=&amp;quot;dao&amp;quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5、测试&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.ssm.test;

import com.ssm.service.IndexService;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test {
    public static void main(String[] args) {
        // ClassPathXmlApplicationContext：通过 ClassPath 下的 xml 初始化 Spring 应用环境
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&amp;quot;spring.xml&amp;quot;);
        IndexService service = (IndexService) context.getBean(&amp;quot;service&amp;quot;);
        service.service();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6、运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IndexDaoImpl...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;constructor-based-dependency-injection&#34;&gt;Constructor-based Dependency Injection&lt;/h3&gt;
&lt;p&gt;构造方法注入参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-constructor-injection&#34;&gt;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-constructor-injection&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;构造方法注入实例&#34;&gt;构造方法注入实例&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class IndexService {
    private IndexDao indexDao;
    public IndexService(IndexDao indexDao){
        this.indexDao = indexDao;
    }
    public void service(){
        indexDao.test();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;xml 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;dao&amp;quot; class=&amp;quot;com.ssm.dao.impl.IndexDaoImpl&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;
&amp;lt;bean id=&amp;quot;service&amp;quot; class=&amp;quot;com.ssm.service.IndexService&amp;quot;&amp;gt;
  &amp;lt;constructor-arg ref=&amp;quot;dao&amp;quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;setter-based-dependency-injection&#34;&gt;Setter-based Dependency Injection&lt;/h3&gt;
&lt;p&gt;setter参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-setter-injection&#34;&gt;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-setter-injection&lt;/a&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/setter%E6%B3%A8%E5%85%A5.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;注解-xml-混合使用&#34;&gt;注解 + xml 混合使用&lt;/h2&gt;
&lt;p&gt;1、xml 内 的ref 引用 dao&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:p=&amp;quot;http://www.springframework.org/schema/p&amp;quot;
       xmlns:c=&amp;quot;http://www.springframework.org/schema/c&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&amp;quot;&amp;gt;
    &amp;lt;bean id=&amp;quot;service&amp;quot; class=&amp;quot;com.ssm.service.IndexService&amp;quot; c:indexDao-ref=&amp;quot;dao&amp;quot;&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、使用注解声明 dao：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component(&amp;quot;dao&amp;quot;)
public class IndexDaoImpl implements IndexDao {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、报错：找不到 dao&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named &#39;dao&#39; available&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;4、分析：没有开启注解、没有注解扫描&lt;/p&gt;
&lt;h3 id=&#34;开启注解&#34;&gt;开启注解：&lt;/h3&gt;
&lt;p&gt;1、xml 中添加 context 相关内容&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
 xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、开启注解（现在 Spring 版本不写开启注解、只写注解扫描，也能实现功能）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;context:annotation-config /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、开启注解扫描&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;context:component-scan base-package=&amp;quot;com.ssm&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将 service 的 bean 声明也使用注解，于是就可以删除 xml 中的 id 为 service 的 bean 标签了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service(value = &amp;quot;service&amp;quot;)
public class IndexService {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完整代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:p=&amp;quot;http://www.springframework.org/schema/p&amp;quot;
       xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
       xmlns:c=&amp;quot;http://www.springframework.org/schema/c&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&amp;quot;&amp;gt;
    &amp;lt;!-- 开启注解 --&amp;gt;
    &amp;lt;context:annotation-config&amp;gt;&amp;lt;/context:annotation-config&amp;gt;
    &amp;lt;!-- 开启注解扫描 --&amp;gt;
    &amp;lt;context:component-scan base-package=&amp;quot;com.ssm&amp;quot;&amp;gt;&amp;lt;/context:component-scan&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、测试，运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IndexDaoImpl...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总结：以上这种注解方式一定需要 xml，因为需要在 xml 内&lt;strong&gt;开启注解扫描&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;有没有办法删掉 xml 呢？答：JavaConfig 配置方式&lt;/p&gt;
&lt;h2 id=&#34;javaconfig-配置方式&#34;&gt;JavaConfig 配置方式&lt;/h2&gt;
&lt;p&gt;1、编写配置类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.ssm.config;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.stereotype.Component;
// 表明这是一个 xml 文件
@Configuration
// 扫描包
@ComponentScan(&amp;quot;com.ssm&amp;quot;)      
public class SpringConfig {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、修改测试类 Test&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.ssm.test;
import com.ssm.config.SpringConfig;
import com.ssm.service.IndexService;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        IndexService service = (IndexService) context.getBean(&amp;quot;service&amp;quot;);
        service.service();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、测试，运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IndexDaoImpl...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;javaconfig-xml-注解配置&#34;&gt;JavaConfig + xml +注解配置&lt;/h2&gt;
&lt;p&gt;1、Sservice 的注入使用注解方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Service(&amp;quot;service&amp;quot;)
public class IndexService {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、Dao 的注入使用 xml 方式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class IndexDaoImpl implements IndexDao {
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:p=&amp;quot;http://www.springframework.org/schema/p&amp;quot;
       xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&amp;quot;&amp;gt;
    &amp;lt;!-- 开启注解 --&amp;gt;
    &amp;lt;context:annotation-config/&amp;gt;
    &amp;lt;!-- 开启注解扫描 --&amp;gt;
    &amp;lt;context:component-scan base-package=&amp;quot;com.ssm&amp;quot;/&amp;gt;
    &amp;lt;bean id=&amp;quot;dao&amp;quot; class=&amp;quot;com.ssm.dao.impl.IndexDaoImpl&amp;quot; p:str=&amp;quot;Hello world&amp;quot;&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、JavaConfig 配置类引入 xml 文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 表明这是一个 xml 文件
@Configuration
// 扫描包
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
// 引入 xml 配置文件
@ImportResource(&amp;quot;classpath:spring.xml&amp;quot;)
public class SpringConfig {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、测试类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        IndexService service = (IndexService) context.getBean(&amp;quot;service&amp;quot;);
        service.service();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IndexDaoImpl...
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;自动装配&#34;&gt;自动装配&lt;/h1&gt;
&lt;p&gt;上面说过，IOC 的注入有两个地方需要提供依赖关系，一是类的定义中，二是在spring的配置中需要去描述。自动装配则把第二个取消了，即我们仅仅需要在类中提供依赖，继而把对象交给容器管理即可完成注入。&lt;/p&gt;
&lt;p&gt;在实际开发中，描述类之间的依赖关系通常是大篇幅的，如果使用自动装配则省去了很多配置，并且如果对象的依赖发生更新我们可以不需要去更新配置，但是也带来了一定的缺点&lt;/p&gt;
&lt;h2 id=&#34;自动装配的优点&#34;&gt;自动装配的优点&lt;/h2&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire&#34;&gt;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Spring container can autowire relationships between collaborating beans. You can let Spring resolve collaborators (other beans) automatically for your bean by inspecting the contents of the ApplicationContext. Autowiring has the following advantages:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Spring容器可以自动创建协作 bean 之间的关系。通过检查 ApplicationContext 的内容，您可以让 Spring 为您的 bean 自动解析协作者(其他bean)。自动装配有以下优点:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Autowiring can significantly reduce the need to specify properties or constructor arguments. (Other mechanisms such as a bean template discussed elsewhere in this chapter are also valuable in this regard.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自动装配可以大大减少指定属性或构造函数参数的需要。(本章其他地方讨论的其他机制，如bean模板，在这方面也很有价值。)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Autowiring can update a configuration as your objects evolve. For example, if you need to add a dependency to a class, that dependency can be satisfied automatically without you needing to modify the configuration. Thus autowiring can be especially useful during development, without negating the option of switching to explicit wiring when the code base becomes more stable.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自动装配可以随着对象的演化更新配置。例如，如果需要向类添加依赖，则可以自动更新该依赖，而不需要修改配置。因此，自动装配在开发过程中特别有用，当代码库变得更加稳定时，自动装配可以避免切换到显式连接的选项。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;indexService&amp;quot; class=&amp;quot;com.ssm.service.IndexService&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;indexDao&amp;quot; ref=&amp;quot;dao&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析：上述配置需要手动添加依赖，比如现在 IndexService 新增了依赖 helloDao：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class IndexService{
  private IndexDao indexDao;
  private HelloDao helloDao;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就需要在 xml 的 &lt;bean&gt; 内增加 &lt;property name=&#34;hello&#34; ref=&#34;hello&#34;/&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;indexService&amp;quot; class=&amp;quot;com.ssm.service.IndexService&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;indexDao&amp;quot; ref=&amp;quot;dao&amp;quot;/&amp;gt;
     &amp;lt;property name=&amp;quot;hello&amp;quot; ref=&amp;quot;hello&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用了自动装配后，就无须手动在 xml 中增加依赖进行维护了，&lt;strong&gt;自动装配可以自动更新该依赖，而不需要修改配置&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;自动装配的缺点&#34;&gt;自动装配的缺点&lt;/h2&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-autowired-exceptions&#34;&gt;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-autowired-exceptions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作为我来讲，我觉得以上缺点都不是缺点&lt;/p&gt;
&lt;h2 id=&#34;自动装配的方法&#34;&gt;自动装配的方法&lt;/h2&gt;
&lt;p&gt;自动装配的方式参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire&#34;&gt;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Mode&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;no ( 不使用自动装配 )&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;(默认)没有自动装配。Bean 引用必须由 ref 元素定义。对于较大的部署，不建议更改默认设置，因为显式地指定协作者可以提供更好的控制和清晰度。在某种程度上，它记录了一个系统的结构。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;byName&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;通过属性名自动装配。Spring 寻找与需要自动装配的属性同名的 bean。例如，如果一个 bean 定义被按名称设置为自动装配，并且它包含一个主属性(也就是说，它有一个setMaster(..)方法)，Spring 会查找一个名为master 的 bean 定义并使用它来设置属性。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;byType&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如果容器中恰好存在该属性类型的一个 bean，则允许自动获取该属性。如果存在多个异常，则抛出一个致命异常，这表明您不能为该 bean 使用byType 自动装配。如果没有匹配的 bean，则什么也不会发生(属性没有设置)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;constructor&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;类似于 byType，但适用于构造函数参数。如果容器中没有一个构造函数参数类型的 bean，则会引发致命错误。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;bytype-自动装配实例&#34;&gt;byType 自动装配实例&lt;/h3&gt;
&lt;p&gt;1、IndexService 依赖 IndexDao&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class IndexService {
    private IndexDao indexDao;
    public void service(){
        indexDao.test();
    }
    public void setIndexDao(IndexDao indexDao) {
        this.indexDao = indexDao;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、使用自动装配：beans 标签内导入 default-autowire=&amp;quot;byType&amp;quot;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&amp;quot;
        default-autowire=&amp;quot;byType&amp;quot;&amp;gt;

    &amp;lt;!-- 开启注解 --&amp;gt;
    &amp;lt;context:annotation-config/&amp;gt;
    &amp;lt;!-- 开启注解扫描 --&amp;gt;
    &amp;lt;context:component-scan base-package=&amp;quot;com.ssm&amp;quot;/&amp;gt;

    &amp;lt;bean id=&amp;quot;dao&amp;quot; class=&amp;quot;com.ssm.dao.impl.IndexDaoImpl&amp;quot;&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!-- IndexService 内应该注入 IndexDao，但因为指定了自动装配，所以可以不显式通过 property 标签注入 IndexDao --&amp;gt;
    &amp;lt;bean id=&amp;quot;indexService&amp;quot; class=&amp;quot;com.ssm.service.IndexService&amp;quot;&amp;gt;
&amp;lt;!--        &amp;lt;property name=&amp;quot;indexDao&amp;quot; ref=&amp;quot;dao&amp;quot;/&amp;gt;--&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析：IndexService 内应该注入 IndexDao，但因为通过 &lt;code&gt;default-autowire=&amp;quot;byType&amp;quot;&lt;/code&gt; 指定了自动装配，所以可以不显式通过 property 标签注入 IndexDao。&lt;/p&gt;
&lt;p&gt;在扫描到 IndexService 类时，发现该类依赖了 IndexDao，发现它的类型是 IndexDao，到 Spring 容器中找类型或父类类型为 IndexDao 的，如果有，就把这个对象直接赋给 IndexService 中的 IndexDao。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;自动装配并不是完全不需要配置了，自动装配仍需要配置 bean，将类交给 Spring 容器管理，自动装配省略了类与类之间依赖的管理，比如类 A 依赖类 B，无需配置依赖关系了，Spring 会自动到容器中找到类 B 然后把它赋给类 A 的成员变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;bytype-自动装配多个相同类型的问题&#34;&gt;byType 自动装配多个相同类型的问题&lt;/h4&gt;
&lt;p&gt;当有多个相同类型时，会报错&lt;/p&gt;
&lt;p&gt;1、添加一个 IndexDaoImpl2 类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class IndexDaoImpl2 implements IndexDao {
    @Override
    public void test() {
        System.out.println(&amp;quot;IndexDaoImpl...2&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、把 IndexDaoImpl2 交给 Spring 容器管理，现在 Spring 容器内有两个 type = IndexDao 的类：IndexDaoImp、IndexDaoImpl2&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;dao2&amp;quot; class=&amp;quot;com.ssm.dao.impl.IndexDaoImpl2&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、测试结果：&lt;/p&gt;
&lt;p&gt;Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &#39;com.ssm.dao.IndexDao&#39; available: expected single matching bean but found 2: dao,dao2&lt;/p&gt;
&lt;p&gt;需要单个匹配，但是发现了两个：dao、dao2&lt;/p&gt;
&lt;h3 id=&#34;byname-自动装配实例&#34;&gt;byName 自动装配实例&lt;/h3&gt;
&lt;p&gt;1、beans 标签内指定 byName 自动装配：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;default-autowire=&amp;quot;byName&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、如果没有指定 &lt;bean&gt; 标签的 name 属性，name 默认为将 setIndexDao 的 set 去掉、第一个字母小写，即 name=indexDao&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class IndexService {
    private IndexDao indexDao;
    public void service(){
        indexDao.test();
    }
    public void setIndexDao(IndexDao indexDao) {
        this.indexDao = indexDao;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、于是到 Spring 容器内找 name=indexDao 的，没有找到，报错 Exception in thread &amp;quot;main&amp;quot; java.lang.NullPointerException&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;dao&amp;quot; class=&amp;quot;com.ssm.dao.impl.IndexDaoImpl&amp;quot;/&amp;gt;
&amp;lt;bean id=&amp;quot;dao2&amp;quot; class=&amp;quot;com.ssm.dao.impl.IndexDaoImpl2&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解决办法一：set方法的方法名与 bean 标签的 id 属性对应&lt;/p&gt;
&lt;p&gt;1、改变 set 方法的方法名&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void setDao(IndexDao indexDao) {
    this.indexDao = indexDao;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、测试成功：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IndexDaoImpl...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解决方法二：set 方法的方法名与 bean 标签的 name 属性对应&lt;/p&gt;
&lt;p&gt;1、set 方法不变&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void setIndexDao(IndexDao indexDao) {
    this.indexDao = indexDao;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、给 bean 标签添加 name 属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&amp;quot;dao2&amp;quot; class=&amp;quot;com.ssm.dao.impl.IndexDaoImpl2&amp;quot; name=&amp;quot;indexDao&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、测试成功&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IndexDaoImpl...2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;default-no-不使用自动装配&#34;&gt;default = no 不使用自动装配&lt;/h3&gt;
&lt;p&gt;beans 标签内部增加如下说明：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;default-autowire=&amp;quot;default&amp;quot;&lt;/code&gt; 或 &lt;code&gt;default=autowire=&amp;quot;no&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;异常信息：&lt;code&gt;Exception in thread &amp;quot;main&amp;quot; java.lang.NullPointerException&lt;/code&gt;，因为在 &lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt; 的内部未手动配置 &lt;code&gt;&amp;lt;property&amp;gt;&lt;/code&gt; ，且为声明自动装配，所以 IndexService 未能注入 IndexDao，在 IndexService 内调用 indexDao.test() 时抛出空指针异常。&lt;/p&gt;
&lt;p&gt;其他都想手动装配，唯独 IndexService 想自动装配，就不能在 beans 标签内添加 default-autowire 了，可以&lt;strong&gt;为每一个属性单独指定一个 autowire&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;indexService&amp;quot; class=&amp;quot;com.ssm.service.IndexService&amp;quot; autowire=&amp;quot;byType&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考资料：&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-stereotype-annotations&#34;&gt;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-stereotype-annotations&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring provides further stereotype annotations: @Component, @Service, and @Controller. @Component is a generic stereotype for any Spring-managed component. @Repository, @Service, and @Controller are specializations of @Component for more specific use cases (in the persistence, service, and presentation layers, respectively). Therefore, you can annotate your component classes with @Component, but, by annotating them with @Repository, @Service, or @Controller instead, your classes are more properly suited for processing by tools or associating with aspects. For example, these stereotype annotations make ideal targets for pointcuts. @Repository, @Service, and @Controller can also carry additional semantics in future releases of the Spring Framework. Thus, if you are choosing between using @Component or @Service for your service layer, @Service is clearly the better choice. Similarly, as stated earlier, @Repository is already supported as a marker for automatic exception translation in your persistence layer.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Spring提供了更多的的构造型注解:@Component， @Service，和@Controller。@Component 是任何spring管理组件的通用注解。@Repository、@Service和@Controller是@Component对更具体用例(分别在持久性、服务和表示层)的专门化。因此，您可以使用@Component来注释您的组件类，但是，通过使用@Repository、@Service或@Controller来注释它们，您的类更适合通过工具进行处理或与方面相关联。例如，这些构造型注释是切入点的理想目标。在Spring框架的未来版本中，@Repository、@Service和 @Controller 也可以包含额外的语义。因此，如果您在使用@Component或@Service作为服务层之间进行选择，那么@Service显然是更好的选择。类似地，如前所述，@Repository已经被支持作为持久层中自动异常转换的标记。&lt;/p&gt;
&lt;h2 id=&#34;autowired-默认采用-bytype-注入&#34;&gt;@Autowired 默认采用 byType 注入&lt;/h2&gt;
&lt;p&gt;1、JavaConfig 配置类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;声明这是一个注解类&lt;/li&gt;
&lt;li&gt;扫描包&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 表明这是一个 xml 文件
@Configuration
// 注解扫描包
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
public class SpringConfig {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、@Service 注解&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@Autowired注入 IndexDao&lt;/li&gt;
&lt;li&gt;setIndexDao 方法&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class IndexService {
    @Autowired
    private IndexDao indexDao;
    public void service(){
        indexDao.test();
    }
    // set 方法有没有都可以
    public void setIndexDao(IndexDao indexDao) {
        this.indexDao = indexDao;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、IndexDao 类型的 IndexDaoImpl 类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Repository
public class IndexDaoImpl implements IndexDao {
    @Override
    public void test() {
        System.out.println(&amp;quot;IndexDaoImpl...&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、相同 IndexDao 类型的 IndexDaoImpl2&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Repository
public class IndexDaoImpl2 implements IndexDao {
    @Override
    public void test() {
        System.out.println(&amp;quot;IndexDaoImpl...2&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5、测试类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        IndexService service = (IndexService) context.getBean(&amp;quot;indexService&amp;quot;);
        service.service();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6、运行结果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &#39;com.ssm.dao.IndexDao&#39; available: expected single matching bean but found 2: indexDaoImpl,indexDaoImpl2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;期望一个匹配的 IndexDao 类型的 bean，却发现了两个：indexDaoImpl、indexDaoImpl2&lt;/p&gt;
&lt;p&gt;7、分析&lt;/p&gt;
&lt;p&gt;@Autowired 注解默认使用的是 byType 自动装配方式。&lt;/p&gt;
&lt;p&gt;当执行 @Autowired 注入时，到 Spring 容器中找 IndexDao 类型或父类为 IndexDao 类型的，结果找到了 IndexDaoImpl、IndexDaoImpl2，注入失败。此时根据 byType 找到多个类，则根据 byName 注入（private IndexDao indexDao;）因为没有名为 indexDao 的组件（在@Repository未指定名称，则注入的 bean 名称默认为类名首字母小写，即 indexDaoImpl、indexDaoImpl2），所以注入失败。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@Autowired 默认采用 byType 注入，如果 byType 找到多个，则根据 byName 注入&lt;/strong&gt;，name 为属性名 indexDaoImpl2（private IndexDao indexDaoImpl2）。当根据 name 值注入时，仅与属性值有关，与 set 方法的方法名无关。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class IndexService {
    @Autowired
    private IndexDao indexDaoImpl2;
    public void service(){
        indexDaoImpl2.test();
    }
    public void setIndexDao(IndexDao indexDao) {
        this.indexDaoImpl2 = indexDao;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Spring 容器中找到 name 为 indexDaoImpl2 的组件，注入成功&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Repositorypublic class IndexDaoImpl2 implements IndexDao {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IndexDaoImpl...2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;resource-默认采用-byname-注入&#34;&gt;@Resource 默认采用 byName 注入&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Resource
private IndexDao indexDaoImpl2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;@Resource 模式采用 byName 注入，并且 name 的值为属性值 indexDaoImpl2，与 set 方法的名字无关。&lt;/p&gt;
&lt;h2 id=&#34;spring-默认-bean-名称的生成策略&#34;&gt;Spring 默认 bean 名称的生成策略&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Repository
public class IndexDaoImpl implements IndexDao {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Spring 中如果不显式指定 bean 的名字，默认 bean 的名称为类名首字母变小写，即：indexDaoImpl&lt;/p&gt;
&lt;p&gt;参考资料：&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-scanning-name-generator&#34;&gt;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-scanning-name-generator&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When a component is autodetected as part of the scanning process, its bean name is generated by the BeanNameGenerator strategy known to that scanner. By default, any Spring stereotype annotation (@Component, @Repository, @Service, and @Controller) that contains a name value thereby provides that name to the corresponding bean definition.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当一个组件作为扫描过程的一部分被自动检测时，它的bean名称由该扫描程序所知道的BeanNameGenerator策略生成。默认情况下，任何包含名称值的Spring构造型注释(@Component、@Repository、@Service和@Controller)都将该名称提供给相应的bean定义。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If such an annotation contains no name value or for any other detected component (such as those discovered by custom filters), the default bean name generator returns the uncapitalized non-qualified class name. For example, if the following component classes were detected, the names would be myMovieLister and movieFinderImpl:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果这样的注释不包含名称值或任何其他检测到的组件(例如由自定义过滤器发现的组件)，则默认bean名称生成器将返回未大写的非限定类名。例如，如果检测到以下组件类，其名称将是myMovieLister和movieFinderImpl:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service(&amp;quot;myMovieLister&amp;quot;)
public class SimpleMovieLister {
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@Repository
public class MovieFinderImpl implements MovieFinder {
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;If you do not want to rely on the default bean-naming strategy, you can provide a custom bean-naming strategy. First, implement the BeanNameGenerator interface, and be sure to include a default no-arg constructor. Then, provide the fully qualified class name when configuring the scanner, as the following example annotation and bean definition show.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果不希望依赖默认的 bean 命名策略，可以提供自定义 bean 命名策略。首先，实现BeanNameGenerator 接口，并确保包含一个默认的无参数构造函数。然后，在配置扫描程序时提供完全限定的类名，如下面的注释和 bean 定义示例所示。&lt;/p&gt;
&lt;p&gt;如果由于多个自动检测到的组件具有相同的非限定类名(即您可能需要配置一个BeanNameGenerator，该生成器默认为生成的bean名称的完全限定类名。从Spring Framework 5.2.3开始，FullyQualifiedAnnotationBeanNameGenerator位于包org.springframework.context中。注释可以用于这些目的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(basePackages = &amp;quot;org.example&amp;quot;, nameGenerator = MyNameGenerator.class)
public class AppConfig {
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;beans&amp;gt;
    &amp;lt;context:component-scan base-package=&amp;quot;org.example&amp;quot;
        name-generator=&amp;quot;org.example.MyNameGenerator&amp;quot; /&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;spring懒加载&#34;&gt;spring懒加载&lt;/h1&gt;
&lt;p&gt;官网已经解释的非常清楚了：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lazy-init&#34;&gt;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lazy-init&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;By default, ApplicationContext implementations eagerly create and configure all singleton beans as part of the initialization process. Generally, this pre-instantiation is desirable, because errors in the configuration or surrounding environment are discovered immediately, as opposed to hours or even days later. When this behavior is not desirable, you can prevent pre-instantiation of a singleton bean by marking the bean definition as being lazy-initialized. A lazy-initialized bean tells the IoC container to create a bean instance when it is first requested, rather than at startup.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;默认情况下，ApplicationContext实现将创建和配置所有的单例 bean 作为初始化过程的一部分。通常，这种预实例化是可取的，因为配置或周围环境中的错误会立即被发现，而不是几小时甚至几天之后。当此行为不可取时，您可以通过将 bean 定义标记为延迟初始化来防止单例 bean 的预实例化。延迟初始化的bean 告诉 IoC 容器在第一次请求时创建 bean 实例，而不是在启动时。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;lazy&amp;quot; class=&amp;quot;com.something.ExpensiveToCreateBean&amp;quot; lazy-init=&amp;quot;true&amp;quot;/&amp;gt;
&amp;lt;bean name=&amp;quot;not.lazy&amp;quot; class=&amp;quot;com.something.AnotherBean&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;您还可以使用 &lt;code&gt;&amp;lt;beans&amp;gt;&lt;/code&gt; 元素上的 &lt;code&gt;default-lazy-init&lt;/code&gt; 属性来控制容器级别的延迟初始化，如下面的示例所示：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://images-cdn.shimo.im/AL7NwUqEre0woKxB/image.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;spring-bean的作用域&#34;&gt;Spring bean的作用域&lt;/h1&gt;
&lt;p&gt;文档参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes&#34;&gt;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes&lt;/a&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/SpringBean%E4%BD%9C%E7%94%A8%E5%9F%9F.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;singleton&#34;&gt;singleton&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
// 默认也为 singleton
@Scope(&amp;quot;singleton&amp;quot;)
public class IndexService {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
  public static void main(String[] args) {
    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
    IndexService indexService = (IndexService) context.getBean(&amp;quot;indexService&amp;quot;);
    System.out.println(indexService);
    IndexService indexService2 = (IndexService) context.getBean(&amp;quot;indexService&amp;quot;);
    System.out.println(indexService2);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;com.ssm.service.IndexService@5884a914
IndexDaoImpl...2
com.ssm.service.IndexService@5884a914
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;两次获得到的 Service 对象是同一个实例：单例。&lt;/p&gt;
&lt;h2 id=&#34;prototype&#34;&gt;prototype&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
@Scope(&amp;quot;prototype&amp;quot;)
public class IndexService {
    @Autowired
    private IndexDao indexDaoImpl2;
    public void service(){
        indexDaoImpl2.test();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        IndexService service = (IndexService) context.getBean(&amp;quot;indexService&amp;quot;);
        System.out.println(service);
        service.service();
        service = (IndexService) context.getBean(&amp;quot;indexService&amp;quot;);
        System.out.println(service);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;com.ssm.service.IndexService@5884a914
IndexDaoImpl...2
com.ssm.service.IndexService@50378a4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;两次得到的 Service 对象是两个对象：多例。&lt;/p&gt;
&lt;h3 id=&#34;xml定义方式&#34;&gt;xml定义方式&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&amp;quot;accountService&amp;quot; class=&amp;quot;com.something.DefaultAccountService&amp;quot; scope=&amp;quot;singleton&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;annotation的定义方式&#34;&gt;annotation的定义方式&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
@Scope(&amp;quot;prototype&amp;quot;)
public class IndexService {
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;singleton-beans-with-prototype-bean-dependencies&#34;&gt;Singleton Beans with Prototype-bean Dependencies&lt;/h2&gt;
&lt;p&gt;意思是在 Singleton 当中引用了一个 Prototype 的 bean 的时候引发的问题：&lt;/p&gt;
&lt;p&gt;在单例对象中引用多例 bean，这个多例 bean 就失去了意义。&lt;/p&gt;
&lt;p&gt;1、IndexService 单例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
@Scope(&amp;quot;singleton&amp;quot;)
public class IndexService {
    @Autowired
    private IndexDao indexDao;
    public void service(){
        System.out.println(this);
        System.out.println(indexDao);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、IndexDao 多例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Repository
@Scope(&amp;quot;prototype&amp;quot;)
public class IndexDaoImpl implements IndexDao {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、测试&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        IndexService service = (IndexService) context.getBean(&amp;quot;indexService&amp;quot;);
        service.service();
        System.out.println(&amp;quot; - - - - - - - - - &amp;quot;);
        service = (IndexService) context.getBean(&amp;quot;indexService&amp;quot;);
        service.service();
        System.out.println(&amp;quot; - - - - - - - - - &amp;quot;);
        service = (IndexService) context.getBean(&amp;quot;indexService&amp;quot;);
        service.service();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;com.ssm.service.IndexService@4d14b6c2
com.ssm.dao.impl.IndexDaoImpl@7e990ed7
 - - - - - - - - - 
com.ssm.service.IndexService@4d14b6c2
com.ssm.dao.impl.IndexDaoImpl@7e990ed7
 - - - - - - - - - 
com.ssm.service.IndexService@4d14b6c2
com.ssm.dao.impl.IndexDaoImpl@7e990ed7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5、分析：&lt;/p&gt;
&lt;p&gt;虽然 IndexDaoImpl 是多例的，但是 IndexDaoImpl 是 IndexService 的一个属性，而 IndexService 是单例的，就造成了每次打印的 IndexDaoImpl 都是一样的。&lt;/p&gt;
&lt;p&gt;解决方案一：&lt;/p&gt;
&lt;p&gt;1、通过实现 ApplicationContextAware 接口，并在每次 bean A 需要时调用容器的 getBean(“B”) 来请求(通常是一个新的)bean B实例，从而使 bean A 知道容器。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
@Scope(&amp;quot;singleton&amp;quot;)
public class IndexService implements ApplicationContextAware {
    @Autowired
    private IndexDao indexDao;
    private ApplicationContext applicationContext;
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
    public void service(){
        System.out.println(this);
       System.out.println(applicationContext.getBean(&amp;quot;indexDaoImpl&amp;quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、测试结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;com.ssm.service.IndexService@50378a4
com.ssm.dao.impl.IndexDaoImpl@60f00693
 - - - - - - - - - 
com.ssm.service.IndexService@50378a4
com.ssm.dao.impl.IndexDaoImpl@79207381
 - - - - - - - - - 
com.ssm.service.IndexService@50378a4
com.ssm.dao.impl.IndexDaoImpl@491b9b8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、分析：单例 IndexService 内引用多例的 IndexDaoImpl，多次获取 IndexDaoImpl，打印的是不同值。&lt;/p&gt;
&lt;p&gt;解决方案二：Lookup Method Injection&lt;/p&gt;
&lt;p&gt;1、使用 @Lookup 注解&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
@Scope(&amp;quot;singleton&amp;quot;)
public abstract class IndexService {
    @Lookup
    public abstract IndexDao getIndexDao() ;
    public void service(){
        System.out.println(this);
        System.out.println(getIndexDao());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、测试结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;com.ssm.service.IndexService$$EnhancerBySpringCGLIB$$8432b830@6b09fb41
com.ssm.dao.impl.IndexDaoImpl@6f43c82
 - - - - - - - - - 
com.ssm.service.IndexService$$EnhancerBySpringCGLIB$$8432b830@6b09fb41
com.ssm.dao.impl.IndexDaoImpl@5db6b9cd
 - - - - - - - - - 
com.ssm.service.IndexService$$EnhancerBySpringCGLIB$$8432b830@6b09fb41
com.ssm.dao.impl.IndexDaoImpl@210ab13f
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、分析：单例 IndexService 内引用多例的 IndexDaoImpl，多次获取 IndexDaoImpl，打印的是不同值。&lt;/p&gt;
&lt;p&gt;官网引导我们参考&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-method-injection&#34;&gt;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-method-injection&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In most application scenarios, most beans in the container are singletons. When a singleton bean needs to collaborate with another singleton bean or a non-singleton bean needs to collaborate with another non-singleton bean, you typically handle the dependency by defining one bean as a property of the other. A problem arises when the bean lifecycles are different. Suppose singleton bean A needs to use non-singleton (prototype) bean B, perhaps on each method invocation on A. The container creates the singleton bean A only once, and thus only gets one opportunity to set the properties. The container cannot provide bean A with a new instance of bean B every time one is needed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在大多数应用程序场景中，容器中的大多数 bean 都是单例的。当一个单例 bean 需要与另一个单例 bean 协作，或者 一个非单例 bean 需要与另一个非单例 bean 协作时，通常通过将一个bean 定义为另一个 bean 的属性来处理依赖性。当 bean 的生命周期不同时，就会出现问题。假设单例 bean A 需要使用非单例(原型) bean B，可能是在 A 的每个方法调用上。&lt;strong&gt;容器只创建一次单例bean A&lt;/strong&gt;，因此只有一次机会来设置属性。容器不能每次需要 bean B 的新实例时都向 bean A 提供一个。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A solution is to forego some inversion of control. You can make bean A aware of the container by implementing the ApplicationContextAware interface, and by making a getBean(&amp;quot;B&amp;quot;) call to the container ask for (a typically new) bean B instance every time bean A needs it. The following example shows this approach:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决的办法是放弃一些控制反转。您可以通过实现 applicationcontext - ware 接口，并在每次 bean A 需要时调用容器的 getBean(“B”) 来请求(通常是一个新的)bean B实例，从而使 bean A 知道容器。下面的例子展示了这种方法:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// a class that uses a stateful Command-style class to perform some processing
package fiona.apple;

// Spring-API imports
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class CommandManager implements ApplicationContextAware {

    private ApplicationContext applicationContext;

    public Object process(Map commandState) {
        // grab a new instance of the appropriate Command
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    protected Command createCommand() {
        // notice the Spring API dependency!
        return this.applicationContext.getBean(&amp;quot;command&amp;quot;, Command.class);
    }

    public void setApplicationContext(
            ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;spring-生命周期的回调&#34;&gt;Spring 生命周期的回调&lt;/h1&gt;
&lt;h2 id=&#34;spring-生命周期的回调的实现方法&#34;&gt;Spring 生命周期的回调的实现方法：&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Initialization Callbacks AND Destruction Callbacks&lt;br&gt;
The org.springframework.beans.factory.InitializingBean interface lets a bean perform initialization work after the container has set all necessary properties on the bean. The InitializingBean interface specifies a single method:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;org.springframework.beans.factory.InitializingBean 接口允许 bean 在容器设置了 bean 上所有必需的属性之后执行初始化工作。InitializingBean 接口指定了一个方法:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void afterPropertiesSet() throws Exception;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1、创建一个 Dao 接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface IndexDao {
    void test();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、接口实现类，实现 InitializingBean 接口，在调用构造方法后回调 afterPropertiesSet&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Repository
public class IndexDaoImpl implements IndexDao, InitializingBean {
    public IndexDaoImpl(){
        System.out.println(&amp;quot;IndexDaoImpl...Constructor&amp;quot;);
    }
    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println(&amp;quot;IndexDaoImpl...init&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、测试&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、测试结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IndexDaoImpl...Constructor
IndexDaoImpl...init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5、分析&lt;br&gt;
在调用构造方法初始化时回调 afterPropertiesSet 方法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Implementing the org.springframework.beans.factory.DisposableBean interface lets a bean get a callback when the container that contains it is destroyed. The DisposableBean interface specifies a single method:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实现 org.springframework.beans.factory.DisposableBean 接口，当包含它的容器被销毁时，可处置bean 接口让 bean 获得一个回调。可处置 bean 接口指定了一个方法:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void destroy() throws Exception;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Repository
public class IndexDaoImpl implements IndexDao, DisposableBean {
    @Override
    public void destroy() throws Exception {
        System.out.println(&amp;quot;IndexDaoImpl...destory&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;default-initialization-and-destroy-methods&#34;&gt;Default Initialization and Destroy Methods&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;When you write initialization and destroy method callbacks that do not use the Spring-specific InitializingBean and DisposableBean callback interfaces, you typically write methods with names such as init(), initialize(), dispose(), and so on. Ideally, the names of such lifecycle callback methods are standardized across a project so that all developers use the same method names and ensure consistency.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当您编写不使用特定于 spring 的 InitializingBean 和 DisposableBean 回调接口的初始化和销毁方法回调时，您通常会编写具有 init()、initialize()、dispose() 等名称的方法。理想情况下，这样的生命周期回调方法的名称在整个项目中是标准化的，这样所有开发人员都可以使用相同的方法名称并确保一致性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You can configure the Spring container to “look” for named initialization and destroy callback method names on every bean. This means that you, as an application developer, can write your application classes and use an initialization callback called init(), without having to configure an init-method=&amp;quot;init&amp;quot; attribute with each bean definition. The Spring IoC container calls that method when the bean is created (and in accordance with the standard lifecycle callback contract described previously). This feature also enforces a consistent naming convention for initialization and destroy method callbacks.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;您可以将 Spring 容器配置为在每个bean上“查找”名为 initialization 和 destroy 的回调方法名。这意味着，作为应用程序开发人员，您可以编写应用程序类并使用名为 init() 的初始化回调，而不必为每个bean 定义配置 init-method=&amp;quot;init&amp;quot; 属性。在创建bean时，Spring IoC 容器调用该方法(并根据前面描述的标准生命周期回调契约)。该特性还强制对初始化和销毁方法回调使用一致的命名约定。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Suppose that your initialization callback methods are named init() and your destroy callback methods are named destroy(). Your class then resembles the class in the following example:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设您的初始化回调方法命名为init()，而销毁回调方法命名为destroy()。你的类类似于下面例子中的类:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class DefaultBlogService implements BlogService {

    private BlogDao blogDao;

    public void setBlogDao(BlogDao blogDao) {
        this.blogDao = blogDao;
    }

    // this is (unsurprisingly) the initialization callback method
    public void init() {
        if (this.blogDao == null) {
            throw new IllegalStateException(&amp;quot;The [blogDao] property must be set.&amp;quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后你可以在一个类似如下的bean中使用这个类:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;beans default-init-method=&amp;quot;init&amp;quot;&amp;gt;

    &amp;lt;bean id=&amp;quot;blogService&amp;quot; class=&amp;quot;com.something.DefaultBlogService&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;blogDao&amp;quot; ref=&amp;quot;blogDao&amp;quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;combining-lifecycle-mechanisms&#34;&gt;Combining Lifecycle Mechanisms&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;As of Spring 2.5, you have three options for controlling bean lifecycle behavior:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从spring2.5开始，你有三个控制bean生命周期行为的选项:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The InitializingBean and DisposableBean callback interfaces&lt;/li&gt;
&lt;li&gt;Custom init() and destroy() methods&lt;/li&gt;
&lt;li&gt;The @PostConstruct and @PreDestroy annotations. You can combine these mechanisms to control a given bean.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@PostConstruct
public void init(){
    System.out.println(&amp;quot;IndexDaoImpl...init&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用不同的初始化方法为同一个bean配置多个生命周期机制，调用方法如下:&lt;br&gt;
1、Methods annotated with @PostConstruct&lt;br&gt;
2、afterPropertiesSet() as defined by the InitializingBean callback interface&lt;br&gt;
3、A custom configured init() method&lt;/p&gt;
&lt;h1 id=&#34;其他&#34;&gt;其他&lt;/h1&gt;
&lt;h2 id=&#34;using-filters-to-customize-scanning&#34;&gt;Using Filters to Customize Scanning&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-scanning-filters&#34;&gt;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-scanning-filters&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 表明这是一个 xml 文件
@Configuration
// 注解扫描包
@ComponentScan(value = &amp;quot;com.ssm&amp;quot;,excludeFilters = {@ComponentScan.Filter(type = FilterType.REGEX, pattern = &amp;quot;com.ssm.service.*&amp;quot;)})
public class SpringConfig {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        IndexService indexService = (IndexService) context.getBean(&amp;quot;indexService&amp;quot;);
        indexService.service();

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Exception in thread &amp;quot;main&amp;quot; org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named &#39;indexService&#39; available&lt;br&gt;
分析：自定义扫描过滤 com.ssm.service.* ，于是无法扫描到 IndexService，因此报错没有名为 indexService 的 bean。&lt;/p&gt;
&lt;h2 id=&#34;providing-qualifier-metadata-with-annotations&#34;&gt;Providing Qualifier Metadata with Annotations&lt;/h2&gt;
&lt;p&gt;1、当有两个 IndexDao 的实现类时，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Repository
public class IndexDaoImpl implements IndexDao{
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Repository
public class IndexDaoImpl2 implements IndexDao {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、Service 类使用 @Autowired 注入 IndexDao&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class IndexService {
    @Autowired
    IndexDao indexDao;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、运行报错&lt;br&gt;
Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &#39;com.ssm.dao.IndexDao&#39; available: expected single matching bean but found 2: indexDaoImpl,indexDaoImpl2&lt;br&gt;
4、分析&lt;br&gt;
@Autowired 默认使用 byType 注入，结果发现了两个 IndexDao：IndexDaoImpl、IndexDaoImpl2，注入失败；于是采用 byName 注入（IndexDao indexDao;），在 Spring 容器中寻找 name = indexDao 的，没有找到（有名为 indexDaoImpl 和名为 indexDaoImpl2），注入失败。&lt;/p&gt;
&lt;h3 id=&#34;解决方案一primary&#34;&gt;解决方案一：@Primary&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Repository
@Primary
public class IndexDaoImpl implements IndexDao{
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当向 IndexDaoImpl 类加入 @Primary 注解时，通过 byType 找到两个，于是注入 @Primary 注解修饰的类 IndexDaoImpl。&lt;/p&gt;
&lt;h3 id=&#34;解决方案二qualifier&#34;&gt;解决方案二：@Qualifier&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-scanning-qualifiers&#34;&gt;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-scanning-qualifiers&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class IndexService {

    @Autowired
    @Qualifier(&amp;quot;indexDaoImpl2&amp;quot;)
    IndexDao indexDao;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;using-the-bean-annotation&#34;&gt;Using the @Bean Annotation&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-java-bean-annotation&#34;&gt;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-java-bean-annotation&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;@Bean is a method-level annotation and a direct analog of the XML &lt;bean/&gt; element. The annotation supports some of the attributes offered by &lt;bean/&gt;, such as: * init-method * destroy-method * autowiring * name.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;@Bean是方法级别的注释，是XML &lt;bean/&gt;元素的直接模拟。注释支持&lt;bean/&gt;提供的一些属性，比如:* init-method * destroy-method * autowiring * name。&lt;br&gt;
1、pom.xml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;
  &amp;lt;!-- spring-ioc --&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;5.0.9.RELEASE&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;

  &amp;lt;!-- mybatis --&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.4.6&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;

  &amp;lt;!-- spring-mybatis --&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis-spring&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;

  &amp;lt;!-- Spring 数据源 --&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;5.0.8.RELEASE&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;

  &amp;lt;!-- mysql --&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;5.1.6&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;

&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、@Bean 注解的使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 表明这是一个 xml 文件
@Configuration
// 注解扫描包
@ComponentScan(&amp;quot;com.ssm&amp;quot;)
public class SpringConfig {

    @Bean
    public DataSource dataSource(){
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;);
        dataSource.setUsername(&amp;quot;root&amp;quot;);
        dataSource.setPassword(&amp;quot;123456&amp;quot;);
        dataSource.setUrl(&amp;quot;jdbc:mysql://localhost:3306/test&amp;quot;);
        return dataSource;
    }

    @Bean
    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){
        SqlSessionFactoryBean sqlSessionFactoryBean =  new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource);
        return sqlSessionFactoryBean;
    }
}
&lt;/code&gt;&lt;/pre&gt;
">Spring系列（一）Spring IoC 应用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/java-bing-fa-cas-he-aqs/"" data-c="
          &lt;ul&gt;
&lt;li&gt;多线程
&lt;ul&gt;
&lt;li&gt;Synchronized Volatile单例&lt;/li&gt;
&lt;li&gt;锁：封锁。
&lt;ul&gt;
&lt;li&gt;悲观锁、写（增删改）多，读（查）少Lock&lt;/li&gt;
&lt;li&gt;乐观锁：读（查）多、写少版本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.5 JUC&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;一-cas&#34;&gt;一、CAS&lt;/h1&gt;
&lt;h2 id=&#34;1-概念&#34;&gt;1. 概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CompareAndSet：比较和设置&lt;/li&gt;
&lt;li&gt;CompareAndSwap：比较和交换。一种无锁的原子算法，乐观锁。&lt;/li&gt;
&lt;li&gt;思想：
&lt;ul&gt;
&lt;li&gt;给你一个期望值，与现有的值比较，如果相等则修改；如果不相等什么事情都不做。&lt;/li&gt;
&lt;li&gt;CAS(V,E,N)
&lt;ul&gt;
&lt;li&gt;V：目前拿到的值&lt;/li&gt;
&lt;li&gt;E：期望值&lt;/li&gt;
&lt;li&gt;N：新值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-作用及优点&#34;&gt;2. 作用及优点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CAS 实现稍微复杂，无锁，不存在阻塞，提高了效率，CPU的吞吐量高，性能好。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-实例&#34;&gt;3. 实例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package luban;

public class CASDemo1 {

    private static volatile int m = 0;

    public static void increase(){
        m ++;
    }
    public static void main(String[] args){
        for (int i = 0; i &amp;lt; 20; i++) {
            new Thread(() -&amp;gt; {
                CASDemo1.increase();
            }).start();
        }
        System.out.println(m);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;16
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析：&lt;br&gt;
m++ 不具有原子性。&lt;/p&gt;
&lt;p&gt;修改后：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package luban;

/**
 * volatile 变量
 * join()
 */
public class CASDemo3 {

    private static volatile int m = 0;
    public static void increase(){
        m ++;
    }
    public static void main(String[] args) throws InterruptedException {
        Thread[] threads = new Thread[20];
        for (int i = 0; i &amp;lt; threads.length; i++) {
            threads[i] = new Thread(() -&amp;gt; {
                CASDemo3.increase();
            });
            threads[i].start();
            threads[i].join();
        }
        System.out.println(m);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/join.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;join()&lt;/p&gt;
&lt;p&gt;反汇编：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;javap -c CASDemo3
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/i++.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;i++ 三步操作&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package luban;

/**
 * AtomicInteger 变量
 * join()
 */

import java.util.concurrent.atomic.AtomicInteger;

public class CASDemo2 {

    private static AtomicInteger atomicI = new AtomicInteger(0);

    public static void increastAtomic(){
        atomicI.incrementAndGet();
    }
    public static void main(String[] args) throws InterruptedException {
        Thread[] threads = new Thread[20];
        for (int i = 0; i &amp;lt; threads.length; i++) {
            threads[i] = new Thread(() -&amp;gt; {
                CASDemo2.increastAtomic();
            });
            threads[i].start();
            threads[i].join();// join()：加入。当前 threads[i] 线程加入到线程组中，当前线程等待 threads[i]线程执行完了之后再执行
        }
        System.out.println(atomicI.get());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;反汇编：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;javap -c CASDemo2
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/atomicI.incrementAndGet.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;atomicI.incrementAndGet() 实现 i++ 只需一步操作&lt;/p&gt;
&lt;h2 id=&#34;4-方法摘要&#34;&gt;4. 方法摘要&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/atomic%E6%96%B9%E6%B3%95.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;java.util.concurrent.atomic&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/AtomicInteger%E6%96%B9%E6%B3%95.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;AtomicInteger 方法摘要&lt;/p&gt;
&lt;h2 id=&#34;5-原理&#34;&gt;5. 原理&lt;/h2&gt;
&lt;p&gt;JUC下的atomic类都是通过CAS来实现的，下面就以AtomicInteger为例来阐述CAS的实现。如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/AtomicInteger%E7%B1%BB.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;AtomicInteger 类&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/getUnsafe.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;JVM 调用底层指令实现 getUnsafe()&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/incrementAndGet.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;incrementAndGet() 方法&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/getAndAddInt.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;getAndAddInt() 方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);
// var1：现在拿到的值
// var2：期望的值
// var4:最终改变的值
// var5：最后改变了的值  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总结：CAS的原子性流程&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/Unsafe.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;Unsafe 的返回值是 Atomic::cmpchg(x, addr, e)&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Unsafe_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;Atomic::cmpchg(jint exchange_value, volatile jint* dest, jint com)&lt;/p&gt;
&lt;p&gt;incrementAndGet -&amp;gt; unsafe.java -&amp;gt; unsafe.cpp -&amp;gt; 汇编 cmpxchg&lt;/p&gt;
&lt;p&gt;需要&lt;strong&gt;硬件支持&lt;/strong&gt;汇编指令 cmpxchg&lt;/p&gt;
&lt;p&gt;Unsafe是CAS的核心类，Java无法直接访问底层操作系统，而是通过本地（native）方法来访问。不过尽管如此，JVM还是开了一个后门：Unsafe，它提供了硬件级别的原子操作。&lt;/p&gt;
&lt;h2 id=&#34;6-缺点&#34;&gt;6. 缺点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;无法检测到中间值的变化：A(100) -&amp;gt; B(110) -&amp;gt; A(100)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CAS需要检查操作值有没有发生改变，如果没有发生改变则更新。但是存在这样一种情况：如果一个值原来是A，变成了B，然后又变成了A，那么在CAS检查的时候会发现没有改变，但是实质上它已经发生了改变，这就是所谓的ABA问题。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package luban;
/**
 * 无法检测到中间值的变化
 */
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class CASDemo4 {

    private static AtomicInteger atomicI = new AtomicInteger(100);

    public static void main(String[] args){
        ExecutorService service = Executors.newCachedThreadPool();
        service.execute(() -&amp;gt; {
            System.out.println(&amp;quot;(1) 100 变为 110：&amp;quot; + atomicI.compareAndSet(100,110));
        });

        service.execute(() -&amp;gt; {
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&amp;quot;(2) 110 变为 100：&amp;quot; + atomicI.compareAndSet(110,100));
        });

        service.execute(() -&amp;gt; {
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&amp;quot;(3) 110 变为 100：&amp;quot; + atomicI.compareAndSet(100,120));
        });

        service.shutdown();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(1) 100 变为 110：true
(2) 110 变为 100：true
(3) 110 变为 100：true
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;7-改进&#34;&gt;7. 改进&lt;/h2&gt;
&lt;p&gt;类 AtomicStampedReference&lt;V&gt;&lt;/p&gt;
&lt;p&gt;增加版本号声明：A1(100) -&amp;gt; B2(110) -&amp;gt; A3(100)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package luban;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicStampedReference;

public class CASDemo5 {

    // 设置初值时，给定版本号
    private static AtomicStampedReference asr = new AtomicStampedReference(100, 1);
    public static void main(String[] args){
        ExecutorService service = Executors.newCachedThreadPool();
        service.execute(() -&amp;gt; {
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&amp;quot;100 变为 110：&amp;quot; + asr.compareAndSet(100,110,asr.getStamp(), asr.getStamp() + 1));
            System.out.println(&amp;quot;110 变成 100：&amp;quot; +asr.compareAndSet(110,100,asr.getStamp(), asr.getStamp() + 1));
        });
        service.execute(() -&amp;gt; {
            // 得到版本号
            int stamp = asr.getStamp();
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(asr.getStamp());
            System.out.println(stamp);
            System.out.println(&amp;quot;100 变成 120：&amp;quot; +asr.compareAndSet( 100,120,stamp, stamp  + 1));
//            System.out.println(&amp;quot;100 变成 120：&amp;quot; +asr.compareAndSet( 100,120,asr.getStamp(), asr.getStamp()  + 1));
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;100 变为 110：true
110 变成 100：true
3
1
100 变成 120：false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析：第一个线程 sleep 2 秒后执行 set，所以第二个线程先 getStamp() 到的stamp 是初始化的，还未修改过的 stamp = 1；而第二个线程 sleep 后的 asr 得到的 stamp = 3，现有值与期望值不同，所以修改失败。&lt;br&gt;
CAS 的应用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用于简单的数据计算。&lt;/li&gt;
&lt;li&gt;适合线程冲突少的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;二-aqs&#34;&gt;二、AQS&lt;/h1&gt;
&lt;h2 id=&#34;1-概念-2&#34;&gt;1. 概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;AbstractQueuedSynchronizer&lt;/li&gt;
&lt;li&gt;同步发生器&lt;/li&gt;
&lt;li&gt;构建 LOCK&lt;/li&gt;
&lt;li&gt;JUC：java.util.current&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-基本思想&#34;&gt;2. 基本思想&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;通过内置得到 FIFO 同步队列来完成线程争夺资源的管理工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-clh同步队列&#34;&gt;3. CLH同步队列&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/CLH%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;CLH 同步队列&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static final class Node {
    /** Marker to indicate a node is waiting in shared mode */
    static final Node SHARED = new Node(); // 共享
    /** Marker to indicate a node is waiting in exclusive mode */
    static final Node EXCLUSIVE = null; // 排他

    /** waitStatus value to indicate thread has cancelled */
    static final int CANCELLED =  1; // 因中断、完成 退出队列
    /** waitStatus value to indicate successor&#39;s thread needs unparking */
    static final int SIGNAL    = -1; // 节点的后继结点被阻塞
    /** waitStatus value to indicate thread is waiting on condition */
    static final int CONDITION = -2; // 条件阻塞
    /**
     * waitStatus value to indicate the next acquireShared should
     * unconditionally propagate
     */
    static final int PROPAGATE = -3; // 共享模式下，头结点的状态
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;三-自定义锁&#34;&gt;三、自定义锁&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;AQS 写一个锁（Lock）
&lt;ul&gt;
&lt;li&gt;子类定义为非公共内部帮助器类（私有的内部类继承AQS），写锁的时候的一个帮助器，提供获取或和释放锁的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;方法
&lt;ul&gt;
&lt;li&gt;acquire(int arg)：以&lt;strong&gt;独占&lt;/strong&gt;模式获取，忽略中断。&lt;/li&gt;
&lt;li&gt;acquireShared(int arg)：以&lt;strong&gt;共享&lt;/strong&gt;模式获取，忽略中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;amp;&amp;amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;tryAcquire(int arg) ：尝试以独占模式获取对象状态。&lt;/li&gt;
&lt;li&gt;tryAcquireShared(int arg)：尝试以共享模式获取对象状态 。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    // Try the fast path of enq; backup to full enq on failure
    Node pred = tail;
    if (pred != null) {
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    enq(node);
    return node;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;release(int arg)：以独占模式释放对象。&lt;/li&gt;
&lt;li&gt;releaseShared(int arg)：以共享模式释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;实例&#34;&gt;实例&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Lock%E7%B1%BB%E6%96%B9%E6%B3%95.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;Lock 类的方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package luban;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.AbstractQueuedSynchronizer;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;

public class MyLock implements Lock {

    private Helper helper = new Helper();

    private class Helper extends AbstractQueuedSynchronizer{
        // 获取锁
        @Override
        protected boolean tryAcquire(int arg) {
            int state = getState();
            if(state == 0){
                // 利用 CAS 原理修改 state
                if(compareAndSetState(0, arg)){
                    // 设置当前线程占有资源
                    setExclusiveOwnerThread(Thread.currentThread());
                    return true;
                }
            }
            return false;
        }

        // 释放锁
        @Override
        protected boolean tryRelease(int arg) {// arg:信号量
            int state = getState() - arg;
            boolean flag = false;
            // 判断释放后是否为 0
            if(state == 0){
                setExclusiveOwnerThread(null);
                setState(state);
                return true;
            }
            setState(state);//不存在线程安全问题。重入性的问题，已经独占了资源state，其他线程不会干扰
            return false;
        }
        public Condition newConditionObject(){
            return new ConditionObject();
        }
    }
    @Override
    public void lock() {
        helper.acquire(1);
    }

    @Override
    public void lockInterruptibly() throws InterruptedException {
        helper.acquireInterruptibly(1);
    }

    @Override
    public boolean tryLock() {
        return helper.tryAcquire(1);
    }

    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return helper.tryAcquireNanos(1, unit.toNanos(time));
    }

    @Override
    public void unlock() {
        helper.release(1);
    }

    @Override
    public Condition newCondition() {
        return helper.newConditionObject();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;不加锁的实现有问题&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package luban;
import java.util.concurrent.TimeUnit;

public class Demo {
    private int m = 0;
    private int next(){
        try {
            TimeUnit.SECONDS.sleep(1);
            return m++;
        } catch (InterruptedException e) {
            throw new RuntimeException(&amp;quot;ERROR&amp;quot;);
        }
    }

    public static void main(String[] args){
        Demo demo = new Demo();
        Thread[] th = new Thread[10];
        for(int i = 0 ; i &amp;lt; 10 ; i ++){
            th[i] = new Thread(() -&amp;gt; {
                System.out.println(demo.next());
            });
            th[i].start();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
7
8
6
5
0
4
3
2
0
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;使用自定义锁的实现正确&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package luban;

public class Demo01 {

    private MyLock lock = new MyLock();

    private int m = 0;

    public int next(){
        lock.lock();
        try {
            return m++;
        } finally{
            lock.unlock();
        }
    }

    public static void main(String[] args){
        Demo01 demo = new Demo01();
        Thread[] th = new Thread[10];
        for(int i = 0 ; i &amp;lt; 10 ; i ++){
            th[i] = new Thread(() -&amp;gt; {
                System.out.println(demo.next());
            });
            th[i].start();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0
4
3
2
1
5
6
7
8
9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面实现的 MyLock 不具有可重入性。测试：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package luban;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Demo02 {

    private MyLock lock = new MyLock();

    private int m = 0;

    public void a(){
        lock.lock();
        System.out.println(&amp;quot;a&amp;quot;);
        b();
        lock.unlock();
    }
    public void b(){
        lock.lock();
        System.out.println(&amp;quot;b&amp;quot;);
        lock.unlock();
    }

    public int next(){
        lock.lock();
        try {
            return m++;
        } finally{
            lock.unlock();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Demo02 demo = new Demo02();
        ExecutorService service = Executors.newCachedThreadPool();
        service.execute(() -&amp;gt; {
            demo.a();
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a
（阻塞···）
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;可重入性&#34;&gt;可重入性&lt;/h2&gt;
&lt;p&gt;同一个锁对同一资源进行占有的时候，直接分配给这个线程。&lt;/p&gt;
&lt;p&gt;【占有锁的线程再次申请锁时仍可获取。获取一次，锁这个变量值(默认为 0) 加一。释放一次，锁这个变量值减一。锁这个变量值为 0 时，说明该锁没有被线程占用。】&lt;/p&gt;
&lt;p&gt;对 MyLock 代码进行修改，使其具有可重入性：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package luban;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.AbstractQueuedSynchronizer;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;

public class MyLock implements Lock {

    private Helper helper = new Helper();

    private class Helper extends AbstractQueuedSynchronizer{
        // 获取锁
        @Override
        protected boolean tryAcquire(int arg) {
            int state = getState();
            if(state == 0){
                // 利用 CAS 原理修改 state
                if(compareAndSetState(0, arg)){
                    // 设置当前线程占有资源
                    setExclusiveOwnerThread(Thread.currentThread());
                    return true;
                }
            }else if(getExclusiveOwnerThread() == Thread.currentThread()){//可重入
                setState(getState() + arg);
                return true;
            }
            return false;
        }

        // 释放锁
        @Override
        protected boolean tryRelease(int arg) {// arg:信号量
            int state = getState() - arg;
            boolean flag = false;
            // 判断释放后是否为 0
            if(state == 0){
                setExclusiveOwnerThread(null);
                setState(state);
                return true;
            }
            setState(state);//不存在线程安全问题。重入性的问题，已经独占了资源state，其他线程不会干扰
            return false;
        }

        public Condition newConditionObject(){
            return new ConditionObject();
        }
    }
    @Override
    public void lock() {
        helper.acquire(1);
    }

    @Override
    public void lockInterruptibly() throws InterruptedException {
        helper.acquireInterruptibly(1);
    }

    @Override
    public boolean tryLock() {
        return helper.tryAcquire(1);
    }

    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return helper.tryAcquireNanos(1, unit.toNanos(time));
    }

    @Override
    public void unlock() {
        helper.release(1);
    }

    @Override
    public Condition newCondition() {
        return helper.newConditionObject();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package luban;


import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Demo02 {

    private MyLock lock = new MyLock();

    private int m = 0;

    public void a(){
        lock.lock();
        System.out.println(&amp;quot;a&amp;quot;);
        b();
        lock.unlock();
    }
    public void b(){
        lock.lock();
        System.out.println(&amp;quot;b&amp;quot;);
        lock.unlock();
    }

    public int next(){
        lock.lock();
        try {
            return m++;
        } finally{
            lock.unlock();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Demo02 demo = new Demo02();
        ExecutorService service = Executors.newCachedThreadPool();
        service.execute(() -&amp;gt; {
            demo.a();
        });
        service.shutdown();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a
b
&lt;/code&gt;&lt;/pre&gt;
">Java 并发——CAS 和 AQS</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/java-bing-fa-bing-fa-suo-he-bing-fa-gong-ju/"" data-c="
          &lt;h1 id=&#34;一-并发锁&#34;&gt;一、并发锁&lt;/h1&gt;
&lt;h2 id=&#34;reentrantlock&#34;&gt;ReentrantLock&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一个&lt;strong&gt;可重入互斥Lock&lt;/strong&gt;，具有与使用synchronized方法和语句访问的隐式监视锁相同的基本行为和语义，但具有&lt;strong&gt;扩展功能&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; class X { 
   
   private final ReentrantLock lock = new ReentrantLock(); 
   // ... 
   
   public void m() { 
     lock.lock(); // block until condition holds 
     try { 
       // ... method body 
     } finally { 
       lock.unlock() 
     } 
  } 
  
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;构造方法：
&lt;ul&gt;
&lt;li&gt;ReentrantLock()：创建一个 ReentrantLock的实例。&lt;/li&gt;
&lt;li&gt;ReentrantLock(boolean fair)：根据给定的&lt;strong&gt;公平&lt;/strong&gt;政策创建一个 ReentrantLock的实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;reentrantreadwritelock&#34;&gt;ReentrantReadWriteLock&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ReadWriteLock&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/ReentrantReadWriteLock.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;ReadWriteLock 类的方法&lt;/center&gt;
&lt;ul&gt;
&lt;li&gt;write.unlock()写锁释放之前要加读锁read.lock()：锁降级：从写锁降级到读锁&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;二-并发工具&#34;&gt;二、并发工具&lt;/h1&gt;
&lt;p&gt;航班查询：APP ---&amp;gt;多个线程到不同的公司查询 ---&amp;gt; 全部线程都查询完毕后，整理结果 result 返回给前台用户。&lt;/p&gt;
&lt;h2 id=&#34;1-countdownlatch&#34;&gt;1. CountDownLatch&lt;/h2&gt;
&lt;h3 id=&#34;countdownlatch-用法&#34;&gt;CountDownLatch 用法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;CountDownLatch 类位于java.util.concurrent包下，利用它可以实现类似&lt;strong&gt;计数器&lt;/strong&gt;的功能。&lt;/li&gt;
&lt;li&gt;比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch 来实现这种功能了。&lt;/li&gt;
&lt;li&gt;CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;countdownlatch-如何工作&#34;&gt;CountDownLatch 如何工作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;构造方法
&lt;ul&gt;
&lt;li&gt;CountDownLatch(int count)：构造一个以给定计数初始化的CountDownLatch。&lt;/li&gt;
&lt;li&gt;构造器的计数值（count）实际上就是闭锁需要等待的线程数量。这个值只能被设置一次，而且CountDownLatch 没有提供任何机制去重新设置这个计数值。&lt;/li&gt;
&lt;li&gt;与CountDownLatch的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用CountDownLatch.await() 方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。&lt;/li&gt;
&lt;li&gt;其他N个线程必须引用闭锁对象，因为他们需要通知CountDownLatch对象，他们已经完成了各自的任务。这种通知机制是通过CountDownLatch.countDown() 方法来完成的；每调用一次这个方法，在构造函数中初始化的count值就减1。所以当N个线程都调用了这个方法，count的值等于0，然后主线程就能通过await() 方法，恢复执行自己的任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;await()
&lt;ul&gt;
&lt;li&gt;使当前线程在锁存器倒计时至零前一直等待，除非线程被中断。&lt;/li&gt;
&lt;li&gt;当 count 减少到零时，唤醒当前线程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;countDown()
&lt;ul&gt;
&lt;li&gt;递减锁存器的计数，如果计数达到零，则释放所有等待。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/CountDownLatch.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;CountDownLatch 航班查询流程图&lt;/center&gt;
&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package luban;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
public class FightQueryDemo {
    private static List&amp;lt;String&amp;gt; company = Arrays.asList(&amp;quot;东方航空&amp;quot;,&amp;quot;南方航空&amp;quot;,&amp;quot;海南航空&amp;quot;);
    // 结果列表
    private static List&amp;lt;String&amp;gt; fightList = new ArrayList&amp;lt;&amp;gt;();
    public static void main(String[] args) throws InterruptedException {
        // 出发地
        String origin = &amp;quot;BJ&amp;quot;;
        // 目的地
        String dest = &amp;quot;SH&amp;quot;;
        // 定义门闩
        CountDownLatch latch = new CountDownLatch(company.size());
        // 创建线程池
        ExecutorService service = Executors.newCachedThreadPool();
        // 创建线程
        for (int i = 0; i &amp;lt; company.size(); i++) {
            String name = company.get(i);
            service.execute(() -&amp;gt; {
                // 获取公司名称
                System.out.println(name + &amp;quot;查询从&amp;quot; + origin + &amp;quot;到&amp;quot; + dest + &amp;quot;的机票&amp;quot;);
                // 生成随机数表示此公司机票数量
                int val = new Random().nextInt(10);
                try {
                    TimeUnit.SECONDS.sleep(val);
                    fightList.add(name + &amp;quot;:&amp;quot; + val);
                    System.out.println(name + &amp;quot;查询成功！&amp;quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 这个公司查询完毕，门闩 - 1
                latch.countDown();
            });
        }
        service.shutdown();
        // 等待所有线程结束
        latch.await();
        System.out.println(&amp;quot;==== 查询结果如下 ====&amp;quot;);
        System.out.println(fightList);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;东方航空查询从BJ到SH的机票
海南航空查询从BJ到SH的机票
南方航空查询从BJ到SH的机票
海南航空查询成功！
南方航空查询成功！
东方航空查询成功！
==== 查询结果如下 ====
[海南航空:6, 南方航空:7, 东方航空:7]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-cyclicbarries&#34;&gt;2. CyclicBarries&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/CyclicBarries.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;CyclieBarries 模拟运动员跑步比赛&lt;/center&gt;
&lt;h3 id=&#34;cyclicbarrier用法&#34;&gt;CyclicBarrier用法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;字面意思&lt;strong&gt;回环栅栏&lt;/strong&gt;，通过它可以实现让一组线程等待至某个状态之后再&lt;strong&gt;全部同时执行&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;叫做回环是因为&lt;strong&gt;当所有等待线程都被释放以后&lt;/strong&gt;，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用awai() 方法之后，线程就处于barrier了。&lt;/li&gt;
&lt;li&gt;赛跑：
&lt;ul&gt;
&lt;li&gt;需要所有的子任务都完成时，才执行主任务，这个时候就可以选择使用CyclicBarrier。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;基本原理&#34;&gt;基本原理：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;每个线程执行时，都会碰到一个屏障，直到所有线程执行结束，然后屏障便会打开，使所有线程继续往下执行。&lt;/li&gt;
&lt;li&gt;在 CyclicBarrier 的内部定义了一个 Lock 对象，每当一个线调用 await 方法时，将拦截的线程数加减 1，然后判断计数器当前是否等于 0 ，如果不是，进入Lock对象的条件队列等待。如果是，执行 barrierAction 对象的 Runnable 方法，然后将锁的条件队列中的所有线程放入锁等待队列中，这些线程会依次的获取锁、释放锁。&lt;/li&gt;
&lt;li&gt;CyclicBarrier的两个&lt;strong&gt;构造函数&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;CyclicBarrier（int parties）：声明需要拦截的线程数&lt;/li&gt;
&lt;li&gt;CyclicBarrier（int parties，Runnable barierAction）：声明需要拦截的线程数，定义一个等待所有线程到达屏障优先执行的Runnable对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package luban;
import java.util.Random;
import java.util.concurrent.*;
public class RaceDemo {
    public static void main(String[] args) {
        CyclicBarrier barrier = new CyclicBarrier(8);
        ExecutorService service = Executors.newCachedThreadPool();
        for(int i = 0 ; i &amp;lt; 8 ; i++){
            service.execute(() -&amp;gt; {
                try {
                    TimeUnit.SECONDS.sleep(new Random().nextInt(10));
                    System.out.println(Thread.currentThread().getName() + &amp;quot;准备好了&amp;quot;);
                    // 此线程已经准备好，唤醒其他线程
                    barrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
                System.out.println(&amp;quot;选手&amp;quot; + Thread.currentThread().getName() + &amp;quot;起跑&amp;quot;);
            });
        }
        service.shutdown();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pool-1-thread-8准备好了
pool-1-thread-4准备好了
pool-1-thread-5准备好了
pool-1-thread-2准备好了
pool-1-thread-1准备好了
pool-1-thread-7准备好了
pool-1-thread-3准备好了
pool-1-thread-6准备好了
选手pool-1-thread-6起跑
选手pool-1-thread-8起跑
选手pool-1-thread-5起跑
选手pool-1-thread-4起跑
选手pool-1-thread-3起跑
选手pool-1-thread-7起跑
选手pool-1-thread-1起跑
选手pool-1-thread-2起跑
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;一般情况下对于两个非常相似的类，我们一般都会想当然地去把他们进行类比。对于CountDownLatch 和CyclicBarrier 两个类，我们可以看到CountDownLatch 类都是一个类似于集结点的概念，很多个线程做完事情之后等待其他线程完成，全部线程完成之后再恢复运行。不同的是CountDownLatch 类需要你自己调用countDown() 方法减少一个计数，然后调用await() 方法即可。而CyclicBarrier 则直接调用await() 方法即可。&lt;/li&gt;
&lt;li&gt;所以从上面来看，CountDownLatch更倾向于多个线程合作的情况，等你所有东西都准备好了，我这边就自动执行了。而CyclicBarrier则是我们都在一个地方等你，大家到齐了，大家再一起执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-semaphore&#34;&gt;3. Semaphore&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;资源有限共享&lt;/li&gt;
&lt;li&gt;停车场为例：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Semaphore.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.ssm;

import java.util.Random;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

public class CarDemo {
    public static void main(String[] args) throws InterruptedException {
        // 创建 Semaphore
        Semaphore semaphore = new Semaphore(3);
        Thread [] cars = new Thread[10];
        for (int i = 0; i &amp;lt; 10; i++) {
            cars[i] = new Thread(()-&amp;gt;{
                try {
                    // 请求许可
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName() + &amp;quot;可以进入停车场&amp;quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                // 使用资源
                try {
                    int val = new Random().nextInt(5);
                    TimeUnit.SECONDS.sleep(val);
                    System.out.println(Thread.currentThread().getName()+&amp;quot;停留了&amp;quot;+val+&amp;quot;秒&amp;quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 离开（释放资源）
                semaphore.release();
                System.out.println(Thread.currentThread().getName() + &amp;quot;离开了停车场&amp;quot;);
            },&amp;quot;car[&amp;quot;+i+&amp;quot;]&amp;quot;);
            cars[i].start();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;car[0]可以进入停车场
car[2]可以进入停车场
car[7]可以进入停车场
car[0]停留了0秒
car[0]离开了停车场
car[4]可以进入停车场
car[7]停留了2秒
car[7]离开了停车场
car[8]可以进入停车场
car[2]停留了3秒
car[8]停留了1秒
car[3]可以进入停车场
car[2]离开了停车场
car[5]可以进入停车场
car[8]离开了停车场
car[4]停留了4秒
car[4]离开了停车场
car[1]可以进入停车场
car[3]停留了2秒
car[3]离开了停车场
car[9]可以进入停车场
car[9]停留了0秒
car[9]离开了停车场
car[6]可以进入停车场
car[6]停留了0秒
car[6]离开了停车场
car[1]停留了1秒
car[1]离开了停车场
car[5]停留了3秒
car[5]离开了停车场
&lt;/code&gt;&lt;/pre&gt;
">Java 并发——并发锁和并发工具</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/http-xi-lie-si-an-quan-de-https/"" data-c="
          &lt;h1 id=&#34;一-http-与-https&#34;&gt;一、HTTP 与 HTTPS&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/HTTPS_1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/HTTPS_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;HTTP 协议：超文本传输协议，应用层协议，HTTP 协议通过 请求-响应的方式，在客户端和服务端之间进行通信。HTTP 协议传输&lt;strong&gt;明文&lt;/strong&gt;，不安全。&lt;/p&gt;
&lt;h2 id=&#34;明文信息传输&#34;&gt;明文信息传输&lt;/h2&gt;
&lt;p&gt;小风向向小萌发出一个请求 “小萌，我喜欢你！” 来表白。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%98%8E%E6%96%87%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;中间人攻击&#34;&gt;中间人攻击&lt;/h3&gt;
&lt;p&gt;但是由于传输信息是明文，这个信息可能被某个中间人恶意拦截甚至篡改：&lt;strong&gt;中间人攻击&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%98%8E%E6%96%87%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93_%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;加密信息传输&#34;&gt;加密信息传输&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;加密算法&#34;&gt;加密算法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;对称加密：加密、解密使用同一个秘钥&lt;/li&gt;
&lt;li&gt;非对称加密：加密、解密使用不同的秘钥，公钥加密私钥解密&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;对称加密传输&#34;&gt;对称加密传输&lt;/h3&gt;
&lt;p&gt;小风和小萌事先约定好一种加密方式，并且约定一个随机生成的秘钥，后续通信信息的发送方使用秘钥对信息进行加密，信息的接收方使用同一个秘钥对接收到的密文进行解密。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;小风发送聊天请求，小萌回复给小风一个秘钥，小风后面发送的信息都先使用秘钥加密后再发送。后续发送信息都是不可读的密文了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;如果不知道秘钥，即使拦截到了信息，也没有办法解析和篡改。&lt;br&gt;
但是这样做并不是绝对安全的，虽然在后续的通信中对明文进行了加密，但是&lt;strong&gt;第一次约定加密方式、约定加密方式之后的秘钥的传输&lt;/strong&gt;还是用明文。如果第一次通信就已经被拦截了，那么秘钥就会泄露给中间人， 中间人仍可以解密后续所有通信内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93_%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;非对称加密传输&#34;&gt;非对称加密传输&lt;/h2&gt;
&lt;p&gt;非对称加密的一组秘钥中包含一个公钥和一个私钥，既可以公钥加密私钥解密，也可以私钥加密公钥解密。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;在小风和小萌建立通信时，小萌首先把自己的公钥 KEY1 发送给小风。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;收到小萌的公钥后，小风自己生成一个用于对称加密的公钥 KEY2，这个秘钥是为了后续聊天加密来用的，就是上次被中间人发现的那个秘钥，为了安全不再明文约定发送，而是用刚才接收到的公钥 KEY1 对 KEY2 进行加密，得到 VA3=KEY1(KEY2)，把 VA3 发送给小萌。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_3.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;小萌可以用自己的非对称加密的私钥，解开公钥 KEY1 的加密，获得了 KEY2 的内容，从此以后用 KEY2 进行加密通信。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这个通信过程中，即使中间人一开始就截获了公钥 KEY1，由于不知道私钥是什么，也没有办法去解密。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_%E6%80%BB%E7%BB%93.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;发送方和接收方都有一套自己的公钥和私钥，公钥是所有人都知道的，私钥只有自己知道。&lt;br&gt;
&lt;strong&gt;发送方使用接收方的公钥进行加密，接收方使用自己的私钥对接收的密文进行解密。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;中间人攻击-2&#34;&gt;中间人攻击&lt;/h3&gt;
&lt;p&gt;中间人不知道小萌的私钥是什么，但是它截获了小萌的公钥 KEY1 后，可以自己另外生成一对公钥和私钥，把自己的公钥 KEY3 发送给小风，&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB_1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;小风以为 KEY3 就是小萌的公钥，用 KEY3 加密自己生成的对称加密的公钥 KEY2 得到 VA4=KEY3(KEY2)，发送给小萌，中间人用自己的私钥解开 KEY3 加密，获得了 KEY2，然后用小萌发来的 KEY1 重新加密，得到 VAL5，发给小萌。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;两个人的后续通信尽管一直在用 KEY2 做对称加密，但是中间人已经掌握了 KEY2，就可以轻松地解密获取内容了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;证书机构&#34;&gt;证书机构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;小萌把自己的公钥 KEY1 发给证书颁发机构去申请证书，证书颁发机构自己有一对公钥和私钥，机构利用自己的私钥来加密 KEY1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过了机构的私钥加密，这样制作完成一个证书，机构把这个证书发给服务端小萌。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84_3.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;当后续小风向小萌请求通信时，小萌不再返回自己的公钥，而是直接把自己申请的证书返回给小风。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84_4.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;小风收到证书后， 验证证书的真伪，各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥，所以，小风只需要知道是哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书的签名。接下来小风按照同样的签名规则，自己生成一个证书签名，如果两个签名一致，说明证书有效，验证成功后，小风就可以放心地再次利用机构的公钥解密出服务端小萌的公钥 KEY1，小风生成自己对应的对称加密的秘钥 KEY2，并且用服务端公钥 KEY1 加密 KEY2 生成 VA3，发送给小萌。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84_5.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;小萌用自己的私钥解开加密得到对称加密的秘钥 KEY2，于是两个人可以开始用 KEY2 进行对称加密通信。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;二-https-协议概述&#34;&gt;二、HTTPS 协议概述&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS可以认为是HTTP+TLS。&lt;/li&gt;
&lt;li&gt;TLS是传输层加密协议，它的前身是SSL协议。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;我们默认 TLS 和 SSL 指的是一个东西。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/SSL.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;TLS 建立在 传输层和应用层之间，TLS 实际上是 TCP 之上建立了一个加密通道，TLS 协议主要有五个部分：应用数据层协议、握手协议、报警协议、加密消息确认协议、心跳协议。&lt;br&gt;
目前常用的 HTTP 协议是 HTTP1.1，常用的 TLS 协议版本有：TLS1.2、TLS1.1、TLS1.0 和 SSL3.0 这样几个版本。其中 SSL3.0 由于某种攻击，认为 SSL3.0 协议是不安全的。TLS1.0 也存在部分安全漏洞，TLS1.1 和 TLS1.2 暂时没有已知的安全漏洞。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;https-功能介绍&#34;&gt;HTTPS 功能介绍&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP 本身是明文传输，没有经过任何安全处理，比如在百度搜索一个关键字：小米手机，中间人能够查看这个消息并且有可能打电话推销；在使用百度的过程中，搜索返回的结果页面有广告。这里的中间者主要指网络节点，用户数据在浏览器和百度服务器中间传输必须要经过的那些节点。比如 wifi 热点、路由器、防火墙、反向代理、缓存服务器等，在 HTTP 协议下，中间人可随意窃听用户的搜索内容，窃取客户隐私甚至篡改网页，HTTPS 协议就是这些攻击的克星。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;内容加密&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;浏览器到服务器的内容是以加密的形式传输的，中间者无法查看。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非对称秘钥交换&lt;/li&gt;
&lt;li&gt;对称内容加密&lt;br&gt;
对称加密的第一步：协商加密算法和秘钥，中间人依然可以在第一次通信时，截获加密方式和秘钥，这样有对称内容加密就安全了一些。&lt;br&gt;
非对称加密用公钥和私钥的方式把正常通信的秘钥 KEY2 协商好，但是在协商过程中，有一步骤是服务器把自己的公钥 KEY1 用明文传给客户端，&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;身份认证&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;证书的存在保证用户访问的是你想访问的服务，在使用慕课看视频，HTTPS 证书保证了此时访问的一定是慕课网，即使被 DNS 劫持到了第三方站点，也会提醒用户没有访问慕课服务，有可能被劫持。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;数据完整性&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;防止内容被第三方冒充或篡改。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;https-原理介绍&#34;&gt;HTTPS 原理介绍&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;内容加密&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;非对称密钥交换&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;非对称加密：公钥和私钥的方式把正常通信的 KEY2 协商好，协商的过程中，服务器把自己的公钥 KEY1 用明文传递给客户端，这里面涉及很多高级算法：对称加密的两种模式：流式加密、分组加密。在秘钥交换的过程中，中间人可以截获 KEY1，换成自己的公钥 KEY3，这样一来中间人依然可以获取正常通信时的秘钥，于是引入了数字证书。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对称内容加密&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对称加密：协商加密算法和秘钥，中间人可以在第一次通信时拦截加密方式和秘钥。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;身份认证&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数字证书&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;服务端向权威机构申请证书。&lt;br&gt;
客户端和服务端通信时，服务端先把证书传递给客户端，客户端收到证书后，用证书机构的公钥解密证书签名，然后用签名生成的规则再生成一个签名，对比一致就是真整数，不一致就是假证书。&lt;br&gt;
如果确认是真证书，解密服务器公钥 KEY1，再生成通信用的秘钥 KEY2，用服务器端的公钥 KEY1 加密，发给服务端。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;三-https-使用成本&#34;&gt;三、HTTPS 使用成本&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;证书费用以及更新维护&lt;/li&gt;
&lt;li&gt;HTTPS 降低用户访问速度&lt;/li&gt;
&lt;li&gt;消耗CPU资源，需要增加大量机器&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;四-https-对性能的影响&#34;&gt;四、HTTPS 对性能的影响&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;协议交互所增加的网络RTT&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;RTT：往返时延。从发送端发送数据开始，到发送端收到来自接收端的确认总共经过的时延。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;加解密相关的计算耗时&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;网络耗时&#34;&gt;网络耗时&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/HTTP%E7%BD%91%E7%BB%9C%E8%80%97%E6%97%B6.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP 协议访问网站，交互延迟如上图，用户只需要完成 TCP 三次握手，建立 TCP 连接就能直接发送 HTTP 请求获取应用层数据了。除此之外在访问网络的过程中，也没有需要消耗计算资源的地方。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/HTTPS%E7%BD%91%E7%BB%9C%E8%80%97%E6%97%B6.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTPS 访问流程如上图。&lt;br&gt;
① TCP 三次握手建立连接，一个 RTT&lt;br&gt;
② HTTP GET 请求服务端返回 302跳转到 HTTPS，一个 RTT 和 302 跳转时延。因为用户不会手动输入 https 访问网站，比如说百度，用户一般输入 baidu.com，而不会直接输入：https://www.baidu.com，所以服务端只能返回 302 强制浏览器跳转到 HTTPS。&lt;br&gt;
③ 而浏览器处理 302 跳转本身也需要耗时，这个耗时暂且不算，302 跳转到 https 服务器之后，由于端口和服务器不一样，所以需要重新完成三次握手，建立 TCP 连接。耗时一个 RTT。&lt;br&gt;
④ TLS 完全握手阶段1，耗时一个 RTT，这个阶段主要完成加密套件的协商和证书的身份确认。这个阶段下，服务端和浏览器会协商出来相同的秘钥交换算法、对称加密算法、内容一致性校验算法、证书签名算法等。&lt;br&gt;
浏览器获取到证书后，校验证书的有效性，比如证书是否过期，是否撤销等，浏览器首先获取证书里的 CA 域名，如果 CA 域名没有命中缓存的话，浏览器需要解析 CA 域名的 DNS，这个 DNS 解析至少耗费一个 RTT。DNS 解析到 ip 后，三次握手，建立 CA 站点的 TCP 连接，耗时一个 RTT，接着浏览器发送 Ocsp 请求获取响应，耗时一个 RTT,&lt;br&gt;
Ocsp：在线证书状态协议，维护服务器和其他网络资源安全性的两种普遍模式之一。另外一个叫做 CRL 证书注销列表。当用户试图访问一个服务器时，在线证书状态协议发送一个对于证书状态信息的请求，服务器会回复一个有效、过期或者未知的响应。协议规定了服务器和客户端应用程序的通信语法，在线证书状态协议给用户到期的证书一个宽限期，这样他们就可以在更新以前的一段时间继续访问到这个服务器。这里就需要发起对于证书状态信息的请求，也需要消耗一个 RTT。&lt;br&gt;
⑤ TLS 完全握手阶段2：秘钥协商，耗时一个 RTT 和计算时间，这个完全握手结束后，浏览器和服务器之间进行应用层也就是 HTTP 的数据传输。这和 HTTP 的方式几乎是相同的。&lt;br&gt;
一共耗时 7 个 RTT。&lt;br&gt;
如果不是第一次请求，比如 CA 域名解析，如果有缓存的话，就无需进行 DNS 解析，就可以减少一个 RTT。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;计算耗时&#34;&gt;计算耗时&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;浏览器计算耗时&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;浏览器解析证书签名，秘钥交换，应用层数据加密、解密，一致性的交换&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;服务端计算耗时&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;秘钥交换，应用层数据加密、解密耗时。&lt;br&gt;
由于客户端 CPU 和操作系统种类比较多，所以计算耗时不能一概而论。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;五-https-常见问题&#34;&gt;五、HTTPS 常见问题&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;https加密是不是需要我在电脑上安装证书/保存密码？&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;不需要，操作系统、浏览器把这些操作都做好了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;https 不就是在http后面加个s，很难么？&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTPS 包含证书、流量转发、负载均衡......&lt;br&gt;
小型网站不难，大型网站很难&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;https 解决了所有劫持问题吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;https 是为了解决中间人攻击，假设在 https 页面中加载了 http 资源，http 资源还是有劫持的风险，客户端、局域网的风险也很大，恶意插件、木马、路由器、DNS 也都非常脆弱。HTTPS 能够在绝大部分下保证互联网访问数据传输的安全性。&lt;/p&gt;
&lt;/blockquote&gt;
">HTTP系列（四）安全的HTTPS</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/http-xi-lie-san-shou-xi-http-xie-yi-jie-gou-he-tong-xun-yuan-li/"" data-c="
          &lt;h1 id=&#34;http-协议之身份认证&#34;&gt;HTTP 协议之身份认证&lt;/h1&gt;
&lt;h2 id=&#34;身份认证信息&#34;&gt;身份认证信息&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;密码&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;只有本人才知道的字符串信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;动态令牌&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;仅限本人持有的设备内显示的一次性密码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;数字证书&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;只有本人终端持有的信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;生物认证&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;指纹、虹膜&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;IC 卡等&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;仅限本人持有的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;身份认证信息时用来核对只有登陆者本人才知道、拥有的信息内容，但是即便对方是假冒用户，只要能够通过用户认证，HTTP 服务器就会默认这是出自于本人的行为。因此掌控机密性的密码不能让其他人得到，更不能轻易被破解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;常见认证方式&#34;&gt;常见认证方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;BASIC 认证（基本认证）&lt;/li&gt;
&lt;li&gt;DIGEST 认证（摘要认证）&lt;/li&gt;
&lt;li&gt;SSL 客户端认证&lt;/li&gt;
&lt;li&gt;FormBase 认证（基于表单认证）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;basic-认证&#34;&gt;BASIC 认证&lt;/h2&gt;
&lt;h3 id=&#34;什么是-basic-认证&#34;&gt;什么是 BASIC 认证&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;从 HTTP1.0 就定义的一种认证方式，现在仍有一部分网站在使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/BASIC%E8%AE%A4%E8%AF%81.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;WEB 服务器与通信客户端之间进行的统一认证方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;basic-认证过程&#34;&gt;BASIC 认证过程&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/BASIC%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;客户端发送需要 BASIC 认证的请求资源&lt;/li&gt;
&lt;li&gt;当请求的资源需要 BASIC 认证时，服务器会随状态码 401 返回一个 Authorization Required，告诉客户端需要身份认证&lt;/li&gt;
&lt;li&gt;接收到状态码 401 的客户端为了通过 BASIC 认证，需要将用户名、密码发送给服务器，发送的字符和内容形式为是用户名和密码，中间用 “：” 拼接，将其经过 Base64 的编码后写入到首部字段 Authorization，并在前面加上“Basic ”，表明要执行的是 Basic 认证，发送给服务器。&lt;/li&gt;
&lt;li&gt;服务器端接收到包含首部字段 Authorization 的请求后，会去认证信息的正确性，如果验证通过，返回包含 Request URI 的资源响应，返回的是 200；如果认证失败，继续返回 401，表示认证未通过。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;BASIC 认证虽然采用 Base64 的编码方式，但是这不是加密处理，不需要任何附加信息就可以对 Base64 进行解码，由于明文解码后就是用户名和密码，在 HTTP 这样非加密通信的线路上，进行 BASIC 认证的过程中，如果不小心被别人窃听了，被盗的可能性就会非常大。&lt;br&gt;
BASIC 认证在使用上不够便捷灵活，而且不安全，所以并不常用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;digest-认证&#34;&gt;DIGEST 认证&lt;/h2&gt;
&lt;h3 id=&#34;什么是digest认证&#34;&gt;什么是DIGEST认证？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;为弥补BASIC认证存在的弱点，从HTTP/1.1起就有了DIGEST认证。&lt;/li&gt;
&lt;li&gt;DIGEST 认证同样使用质询/响应的方式，但不会像BASIC认证那样直接发送明文密码。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;质询-响应方式：一方先发送认证要求给另一方，使用从另一方接收到的质询码，计算生成响应码，最后将响应码返回给对方进行认证。&lt;br&gt;
因为发送给对方的只是响应摘要，以及由质询码产生的计算结果，所以比 BASIC 认证多了一层保护，密码泄露的可能性也就降低了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;digest-认证过程&#34;&gt;DIGEST 认证过程&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/DIGEST%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;客户端发送需要 DIGEST 认证的请求&lt;/li&gt;
&lt;li&gt;服务端返回状态码 401，同时里面包含一个头部字段，包含质询-响应认证方式所需要的临时质询码，质询码是一个随机数 nonce，一次返回都是 401 响应生成的任意随机的 Base64 编码的字符串，多数情况下，由一串数字、或一串字符或一串其他的组成&lt;/li&gt;
&lt;li&gt;接收到 401 状态码的客户端返回的响应中包含 DIGEST 认证必须要的头部字段 Authorization，包含这些信息：Digest username=&amp;quot;xxx&amp;quot;, realm=&amp;quot;DIGEST&amp;quot;, nonce=&amp;quot;xxxxx&amp;quot;, url=&amp;quot;&amp;quot;, response=&amp;quot;&amp;quot; ，其中 realm 和 nonce 就是从服务器端接收和响应的字段。username 是 realm 限定范围内可进行认证的内容，response 存放经过 MD5 算法运算生成的密码字符串。&lt;/li&gt;
&lt;li&gt;服务器接收到包含首部字段的 Authorization，服务器端接收到这个请求会确认认证信息的正确性&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;DIGEST 认证提供了高于 BASIC 认证的安全等级，但是和 HTTPS 客户端认证相比还是很弱。DIGEST 认证提供了 &lt;strong&gt;“防止密码被窃听&lt;/strong&gt;” 的保护机制，但是并不存在 “&lt;strong&gt;防止用户伪装&lt;/strong&gt;” 的保护机制。DIGEST 认证和 BASIC 认证一样，使用上不那么便捷灵活，安全性不够，适用范围有限。&lt;br&gt;
使用用户名、密码的认证方式，只要二者的内容正确就可以认为是本人的行为，但是如果用户名和密码被盗，就很有可能&lt;strong&gt;被第三方冒充&lt;/strong&gt;。所以利用 SSL 客户端认证，就可以避免这种情况的发生。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;ssl客户端认证&#34;&gt;SSL客户端认证&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;SSL 客户端认证是借由HTTPS的客户端&lt;strong&gt;证书&lt;/strong&gt;完成认证的方式。凭借客户端证书认证，服务器可确认访问是否来自已登录的客户端。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;银行网银：先输入用户名、密码，输入正确后下载它们的证书，下载好之后，以后每次登录会把证书也通过 HTTP 报文的方式发给服务器，开始通信。&lt;br&gt;
细节过程：①当服务器接收到需要认证资源的请求，服务器给客户端发送一个报文要求客户端提供客户端证书，②用户选择将发送的客户端证书后，客户端会把客户端证书信息以报文方式发送给服务器，③服务器验证客户端证书，验证通过后，就可以领取证书内客户端的公开秘钥，然后开始 HTTPS 的加密通信。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;基于表单的认证&#34;&gt;基于表单的认证&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;基于表单的认证方法并不是在HTTP协议中定义的。&lt;/li&gt;
&lt;li&gt;使用由Web应用程序各自实现基于表单的认证方式。&lt;/li&gt;
&lt;li&gt;通过Cookie和Session的方式来保持用户的状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;http-的长连接与短连接&#34;&gt;HTTP 的长连接与短连接&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;资源消耗的优化：长连接。&lt;br&gt;
连接好比从 A 地到 B 地的交通方式，想从 A 地到 B 地，打车过去，这样是一个短连接，就连通了一下，没办法让更多的人上车；后来发现从 A 去 B 的人很多，于是开通了一条地铁线，建立了一条长连接，很多人都可以复用这个连接。&lt;br&gt;
能一次性节约很多资源的、服务很多次的是长连接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;HTTP协议是基于请求/响应模式的，因此只要服务端给了响应，本次HTTP请求就结束了。&lt;/li&gt;
&lt;li&gt;HTTP的长连接和短连接本质上是&lt;strong&gt;TCP长连接和短连接&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP 协议是应用层协议，传输层使用的是 TCP 协议，网络层使用的是IP 协议，IP 协议主要解决网络路由、寻址的问题， TCP 协议解决的是如何在 IP 层之上可靠的传递数据包，使得在接收端能收到发送方发送的所有包，并且顺序与发出顺序一致。&lt;br&gt;
HTTP 分成长连接和短连接，本质上就是 TCP 连接。TCP 连接是一个双向通道，可以保持一段时间不关闭，因此 TCP 连接才有真正的长连接和短连接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;HTTP/1.0中，默认使用的是&lt;strong&gt;短连接&lt;/strong&gt;。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，结束就中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如果客户端浏览器访问某个 html，该 html 内包含其他 js、css、img 资源，当浏览器每遇到一个 web 资源，就会建立一个 HTTP 会话。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;HTTP/1.1起，默认使用&lt;strong&gt;长连接&lt;/strong&gt;，用以保持连接特性。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/HTTP%E9%95%BF%E8%BF%9E%E6%8E%A5.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;使用长连接的情况时，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接，这个 keep-alive 不会永久保持连接，有一个保持时间，在不同的服务器软件可以设置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;短连接：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;建立连接一数据传输一关闭连接..建立连接一数据传输一关闭连接&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;客户端向服务器发送连接请求，Server 接到请求，双方建立连接，客户端向 Server 发送消息，Server 回应 Client，一次读写就完成了，这时候双方任何一个都可以发起 close 关闭的操作，一般都是 Client 先发起 close。短连接一般只会在 Client-Server 间传递一次读写操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;长连接：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;建立连接—数据传输…（保持连接）.…数据传输——关闭连接&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Client 向 Server 发起连接请求，Server 接受 Client 的请求，双方建立连接，Client 与 Server 完成一次读写之后，它们之间的连接不会主动关闭，后续的读写操作会继续使用这个连接。&lt;br&gt;
短连接对于服务器来说，它的管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段，但如果客户请求频繁，将在 TCP 建立和关闭的操作上浪费时间也浪费带宽，响应的反应速度就会变慢，客户体验感不好。&lt;br&gt;
长连接可以省去较多的 TCP 连接和关闭的时间，减少浪费、节约时间，对于频繁请求资源的客户来说，比较适合使用长连接。在长连接的应用场景下， Client 端一般不会主动关闭连接，与短连接不同，Client 与 Server 之间的连接如果一直不关闭的话，就会存在问题：随着客户端连接越来越多，Server 承受不住，这时 Server 端需要采取一些策略，比如说，关闭一些长时间没有读写事件发生的连接，可以避免一些恶意连接导致 Server 端服务受损。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;http-中介之代理&#34;&gt;HTTP 中介之代理&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/HTTP%E4%B8%AD%E4%BB%8B%E4%B9%8B%E4%BB%A3%E7%90%86.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;一般情况下是客户端直接与服务器连接，但是出于不方便或是其他的特殊原因，可能会通过一个中间人与服务器连接。这个中间人就叫做 &lt;strong&gt;web 代理&lt;/strong&gt;，这个中间人&lt;strong&gt;既是客户端、又是服务端&lt;/strong&gt;，对于服务器来说，由于请求是从代理访问过来的，所以在这个过程中，代理起到了客户端的作用；而对于真正的客户端来说，请求是发给代理的，所以代理起到了服务器的作用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;代理的作用&#34;&gt;代理的作用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;抓包&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;为了能够更好的分析 HTTP 请求，或者达到安全措施的目的，只有使用代理才可以更好的对客户端的数据包进行拦截，在这里代理的名字有另外一种叫法：拦截服务器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;FQ&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如果想通过计算机访问 facebook，由于长城防火墙屏蔽了 facebook、YouTube 这些网站，不可直接访问，就要通过代理翻墙。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/FQ.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;匿名访问&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP 协议本身具有匿名性，HTTP 代理服务器通过删除 HTTP 报文中的身份特性，比如客户端的 IP 地址、Cookie、会话 ID 等，从而对远端的服务器隐藏原始用户的 IP 地址以及其他细节，同时 HTTP 代理服务器上也不会记录原始用户访问记录，就使得代理上网的客户可以在更加安全隐秘的环境中访问网络。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;过滤器&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%BF%87%E6%BB%A4%E5%99%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP 协议并不知道在访问网络的是谁，即便是个小朋友登上父母的账号进行访问，认证起来我们也认为他就是他的父母。通过代理服务器进行分析和部分请求的拦截，进一步加强对网络的控制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;http-中介之网关&#34;&gt;HTTP 中介之网关&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;网关可以作为某种翻译器使用，它抽象出了一种能够到达资源的方法。网关是资源和应用程序之间的粘合剂。&lt;/li&gt;
&lt;li&gt;网关扮演的是“协议转换器”的角色。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/HTTP%E4%B8%AD%E4%BB%8B%E4%B9%8B%E7%BD%91%E5%85%B3.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;代理连接的是两个或多个使用相同协议的应用程序。&lt;br&gt;
网关连接的是两个或多个使用不同协议的端点，网关扮演的是 “&lt;strong&gt;协议转换器&lt;/strong&gt;” 的角色，网关可以向数据库发送查询数据、发邮件、生成动态内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;web-网关&#34;&gt;WEB 网关&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Web网关在一侧使用HTTP协议，在另一侧使用另一种协议。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;lt;客户端协议&amp;gt;/&amp;lt;服务器端协议&amp;gt;&lt;/p&gt;
&lt;p&gt;①（HTTP/）服务器端网关：通过HTTP协议与客户端对话，通过其他协议与服务器通信。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;发邮件就是服务器端网关，客户端是 HTTP 协议，邮件服务器是 SMTP 协议&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;②（/HTTP）客户端网关：通过其他协议与客户端对话，通过HTTP协议与服务器通信。&lt;/p&gt;
&lt;h2 id=&#34;常见的网关类型&#34;&gt;常见的网关类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;（HTTP/*）服务器端Web网关&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;客户端发送 HTTP 请求，服务器端 web网关会把这个请求转换为其他协议与服务器进行连接，完成获取资源后，会将对象放在一条 HTTP 响应中，发送给客户端：发邮件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;（HTTP/HTTPS）服务器端安全网关&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;客户端发送 HTTP 请求，网关自动进行加密，加密来自客户端的请求，然后再发送给服务器，为了安全问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;（HTTPS/HTTP）客户端安全加速器网关&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;客户端发送的请求是经过加密的安全的 HTTPS ，通过网关进行解密后再向 web 服务器发送普通的 HTTP 请求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;资源网关&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;客户端通过 HTTP 连接到应用程序的服务器，服务器并不回送文件，而是将请求通过网关 API 发送给运行在服务器上的应用程序，应用程序将请求资源回送给客户端。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;http-缓存&#34;&gt;HTTP 缓存&lt;/h1&gt;
&lt;h2 id=&#34;为什么要使用http缓存&#34;&gt;为什么要使用HTTP缓存？&lt;/h2&gt;
&lt;p&gt;请求一次服务器，请求头大小 1KB，响应头大小 1KB，请求的文件大小 10KB，一次请求的流量就是 12KB，10 次就是 120KB，n 次请求就是 12*n KB。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;客户端&lt;/strong&gt;每次都要请求服务器，浪费&lt;strong&gt;流量&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务器&lt;/strong&gt;每次都提供查找、下载，请求用户基数如果太大，服务器就会存在很大&lt;strong&gt;压力&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户端&lt;/strong&gt;每次请求完都要进行页面渲染，&lt;strong&gt;用户体验差&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;是否可以将请求的文件存放起来使用：HTTP 缓存。&lt;/p&gt;
&lt;h2 id=&#34;缓存的内容又是什么&#34;&gt;缓存的内容又是什么？&lt;/h2&gt;
&lt;p&gt;主要针对样式：CSS、JS、图片这一系列更新频率不大的&lt;strong&gt;静态文件&lt;/strong&gt;进行缓存。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;缓存是通过什么实现的？请求头-响应头&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;http缓存头部字段&#34;&gt;HTTP缓存头部字段&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Cache-Control请求/响应头，缓存控制字段&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;控制 HTTP 缓存的最高指令，要不要缓存也是 Cache-Control 说了算。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;no-store：所有内容都不缓存。&lt;/p&gt;
&lt;p&gt;no-cache：缓存，但是浏览器使用缓存前，都会请求服务器判断缓存资源是否是最新。&lt;/p&gt;
&lt;p&gt;max-age=X（单位秒）请求缓存后的X秒不再发起请求。&lt;/p&gt;
&lt;p&gt;s-maxage=X（单位秒）代理服务器请求源站缓存后的X秒不再发起请求，只对CDN缓存有效。&lt;/p&gt;
&lt;p&gt;public：客户端和代理服务器（CDN）都可缓存。&lt;/p&gt;
&lt;p&gt;private：只有客户端可以缓存。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Expires&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;响应头，代表资源过期时间，由服务器返回提供，是http1.0的属性，在与max-age共存的情况下，优先级要低。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Last-Modified&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;响应头，资源最新修改时间，由服务器告诉浏览器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if-Modified-Since&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请求头，资源最新修改时间，由浏览器告诉服务器，和Last-Modified是一对，它两会进行对比。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Etag&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;响应头，资源标识，由服务器告诉浏览器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if-None-Match&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请求头，缓存资源标识，由浏览器告诉服务器（其实就是上次服务器给的Etag），和Etag是一对，它两会进行对比。&lt;/p&gt;
&lt;h2 id=&#34;http缓存工作方式&#34;&gt;HTTP缓存工作方式&lt;/h2&gt;
&lt;h3 id=&#34;expires&#34;&gt;Expires&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;场景一：让服务器与浏览器约定一个文件过期时间一Expires&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Expires.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;① 第一次请求时，浏览器向服务器请求一个 f.js 文件&lt;br&gt;
② 服务器说文件给你，我们约定一个时间，通过响应头返回一个 Expires 过期约定时间，同时返回了 f.js&lt;br&gt;
③ 后续请求浏览器先对比当前时间是否已经大于 Expires，判断缓存的文件是否超过了约定的过期时间，时间没过的话，不发起请求，直接使用本地缓存；时间过期了，就发起请求，再返回到步骤 ①。&lt;br&gt;
假设 Expires 已经过期，浏览器请求服务器，但是 f.js 并未改变，如何避免这时发起请求呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;last-modified-与-if-modified-since&#34;&gt;Last-Modified 与 if-Modified-Since&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;场景二：让服务器与浏览器在约定文件过期时间的基础上，再加一个文件最新修改时间的对比——Last-Modified 与 if-Modified-Since&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Last-Modified.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;① 浏览器向服务器请求 f.js，并要一个过期时间&lt;br&gt;
② 服务器返回给浏览器 f.js 和 一个过期时间，再给一个文件最新修改时间 Last-Modified，通过设置响应头返回给浏览器，文件过期后，双方核对文件修改时间&lt;br&gt;
后续浏览器可能有如下三种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Expires 还未过期，浏览器使用本地缓存&lt;/li&gt;
&lt;li&gt;Expires 过期，浏览器请求服务器时带上文件最新修改时间，在请求头里面加上 if-Modified-Since，也就是上次请求服务器返回的 Last-Modified，把这个值又带回去。服务器把这个 if-Modified-Since（请求头里的文件最近修改时间） 和 服务器上的文件最新修改时间 Last-Modified 作对比，如果两个值不相等，服务器查找最新的 f.js + Expires + Last-Modified 返回给浏览器；如果相等，服务器返回状态码 304：文件未修改过，你还是用你的本地缓存吧。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Last-Modified_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;浏览器端可以随意修改 Expires，很极端的情况下，Last-Modified 只能精确到秒，假设文件在 1秒 内发生变化，Last-Modified 无法感知这个文件的变化，这样情况下，浏览器永远无法拿到最新文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;etag与lf-none-match&#34;&gt;Etag与lf-None-Match&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;场景三：让服务器与浏览器在过期时间Expires+Last-Modified的基础上，增加一个文件内容唯一对比标记——Etag与lf-None-Match。Expires不稳定，再加入一个max-age来加以代替。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Etag.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;① 浏览器请求 f.js&lt;br&gt;
② 服务器将 f.js + max-age(过期时间) + Last-Modified + Etag（文件内容的唯一标识）&lt;br&gt;
③ 浏览器 60s 内不发起请求，直接使用本地缓存，&lt;br&gt;
max-age=60代表成功缓存后的 60s 内不再向服务器发起请求，与 Expires 相似，但 max-age 优先级比 Expires 高，max-age 存在时 Expires 就没用了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;④ 60s 后，浏览器带上 If-Modified-Since 和 If-None-Match 向服务器发起请求，服务器对比 If-None-Match 与服务器端的 Etag，这时候尽管给出了 If-Modified-Since，但是不会再对比 If-Modified-Since 和 Last-Modified 了，因为 Etag 优先级比 Last-Modified 高，Etag 就是为了解决 1s 内文件发生改变的问题。如果 If-None-Match 与 Etag 不相等，说明 f.js 这个内容被修改过，服务器返回给浏览器最新的 f.js + 全新的 Etag + max-age +Last-Modified（没什么用了，优先级 &amp;lt; Etag） + Expires（没什么用了，优先级&amp;lt;max-age）；如果 Etag 与 If-None-Match 相等，返回 304 告诉浏览器继续使用之前的本地缓存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Etag_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;max-age 或 Expires 不过期的时候，浏览器没有办法主动感知服务器的文件变化。&lt;br&gt;
如果服务端改变了文件，怎样让客户端知道呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;缓存改进方案&#34;&gt;缓存改进方案&lt;/h2&gt;
&lt;h3 id=&#34;md5hash缓存&#34;&gt;md5/hash缓存&lt;/h3&gt;
&lt;p&gt;通过不缓存html，为静态文件添加MD5或者hash标识，解决浏览器无法跳过缓存过期时间主动感知文件变化的问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP 缓存方案：服务器与浏览器的文件修改时间对比，文件内容标识对比，前提的基础都是建立在两者文件路径完全相同的基础上，请求的都是 f.js，这才能够解读这样的缓存，但是如果第一次要获取的名字是 f-hash1.js，下一次文件修改了就变成了 f-hash2.js，这是两个完全不同的文件。&lt;br&gt;
浏览器第一次加载页面，请求并缓存了 f-hash1,js，第二次加载同样一个地方文件指向 f-hash2.js，浏览器不会询问缓存了，因为本地没有这个缓存，浏览器会直接重新请求 f-hash2.js，因为这就是两个不同的文件。&lt;br&gt;
通过这种方式就可以解决过期时间没到，浏览器无法主动请求服务器的问题，只需要在在项目每次发布迭代的时候，将修改过的静态文件添加不同的 MD5 或者 hash 标识即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;cdn缓存&#34;&gt;CDN缓存&lt;/h3&gt;
&lt;p&gt;CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假设多年前，我们所在的城市只有一个火车站，每次春运整个城市的人都得去这个火车站买票， 人流量及购票需求激增，为了缓解这个问题，城市的不同区都出现了火车票的代售点，这样每个区的人都可以就近买票，火车站总站的压力大大减轻。&lt;br&gt;
可以把每个区的售票点称之为 CDN 节点，也就是前面所说的 代理服务器，简而言之，可以把 CDN 理解成浏览器与服务器之间的临时站点，它会替服务器处理部分浏览器请求，从而减轻总服务器上的压力。静态资源也是一样的，可以分成多个临时站点来存储。&lt;br&gt;
把 CDN 的价值归纳为：&lt;br&gt;
①通过分流大大减轻了原站（服务器端）的压力。&lt;br&gt;
②解决了跨地区访问问题（就近站点访问）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;cdn-缓存工作方式&#34;&gt;CDN 缓存工作方式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;第一次请求&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/CDN%E7%BC%93%E5%AD%98%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AF%B7%E6%B1%82.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;后续请求&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/CDN%E7%BC%93%E5%AD%98%E5%90%8E%E7%BB%AD%E8%AF%B7%E6%B1%82.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可能出现以下几种情况：&lt;/p&gt;
&lt;p&gt;① CDN 节点自己缓存的文件还没过期，于是返回 304 给浏览器，打回了这次请求&lt;/p&gt;
&lt;p&gt;② CND 节点发现自己缓存的文件过期了，为了保险起见，自己发送请求给服务器，成功拿回最新数据，然后交还给浏览器。&lt;/p&gt;
&lt;p&gt;CND 缓存的问题和 HTTP 缓存的问题一样，CDN 缓存时间不过期，浏览器始终被拦截，无法拿到最新的文件。回归 HTTP 缓存本身，缓存本身针对于更新频率不高的静态文件，CDN 缓存提供了分流、访问加速等。&lt;/p&gt;
&lt;p&gt;CDN 与 HTTP 缓存不一样的是：CDN 类似于一个平台，可以通过登录手动更新 CDN 缓存，变相解决了浏览器缓存无法手动控制的问题。&lt;/p&gt;
&lt;h2 id=&#34;浏览器操作对http缓存的影响&#34;&gt;浏览器操作对HTTP缓存的影响&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;用户操作&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Expires/Cache-Control&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Last-Modihed/Etag&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;地址栏回车&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;有效&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;有效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;页面链接跳转&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;有效&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;有效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;新开窗口&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;有效&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;有效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;前进、后退&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;有效&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;有效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;F5刷新&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;无效&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;有效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Ctrl+F5刷新&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;无效&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;无效&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;内容协商机制&#34;&gt;内容协商机制&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;访问谷歌，同一个 URL，在国内打开谷歌是中文，在国外打开是英文的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言，字符集，编码方式等作为判断的基准。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;内容协商方式&#34;&gt;内容协商方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;客户端驱动&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;客户端发起请求，服务器发送可选项列表，客户端作出选择后在发送第二次请求。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器驱动&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;服务器检查客户端的请求头部集并决定提供哪个版本的页面。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;透明协商&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;某个中间设备（通常是缓存代理）代表客户端进行协商。&lt;/p&gt;
&lt;h2 id=&#34;服务器驱动内容协商-请求首部集&#34;&gt;服务器驱动内容协商-请求首部集&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Accept：告知服务器发送何种媒体类型&lt;/li&gt;
&lt;li&gt;Accept-Language：告知服务器发送何种语言&lt;/li&gt;
&lt;li&gt;Accept-Charset：告知服务器发送何种字符集&lt;/li&gt;
&lt;li&gt;Accept-Encoding：告知服务器采用何种编码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;服务器驱动内容协商-请求首部集-2&#34;&gt;服务器驱动内容协商-请求首部集&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Content-Type&lt;/li&gt;
&lt;li&gt;Content-Language&lt;/li&gt;
&lt;li&gt;Content-Type&lt;/li&gt;
&lt;li&gt;Content-Encoding&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;服务器驱动内容协商-近似匹配&#34;&gt;服务器驱动内容协商-近似匹配&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;客户端的 Accept-Language 指的是西班牙语，服务器端只有英语和法语，这个客户端希望在没有西班牙语的时候优先返回英语。这就意味着需要一种 HTTP 机制更详细的描述偏好：近似匹配方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Accept-Language:en; q=0.5, fr; q=0.0, nl; q=1.0, tr; q=0.0&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上述首部表示用户最愿意接受 nl：荷兰语(nl; q=1.0)；其次，如果没有荷兰语的话，英文也行：en;q=0.5；不接受法语：fr;q=0.0 ，不接受土耳其语：tr;q=0.0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;q 值的范围是 0-1，不代表所有权重和为 1，不是权重的概念，只是优先级的概念。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果服务端既没有 nl 也没有 en，服务器端猜测，服务器端设置默认值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;断点续传和多线程下载&#34;&gt;断点续传和多线程下载&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;断点续传？多线程下载？&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;下载文件时，下载到一半，突然网络不太好，下载中断了；&lt;br&gt;
或者主动暂停下载；&lt;br&gt;
用迅雷下载一个大文件，会分成好多块分开下载。&lt;br&gt;
上述叫断点续传。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP是通过在Header里两个参数实现的，客户端发请求时对应的是Range，服务器端响应时对应的是Content-Range。&lt;br&gt;
不论是断点续传还是迅雷的多线程分块下载，如果续传成功，返回 206，如果文件有变动，返回 200 和新文件的内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Range&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于请求头中，指定第一个字节的位置和最后一个字节的位置，一般格式：&lt;/li&gt;
&lt;li&gt;Range:（unit=first byte pos）-[last byte pos] 左开右闭区间
&lt;ul&gt;
&lt;li&gt;Range:bytes=0-499&lt;/li&gt;
&lt;li&gt;Range:bytes=500-999&lt;/li&gt;
&lt;li&gt;Range:bytes=-500  后 500 个字节的内容&lt;/li&gt;
&lt;li&gt;imooc Range:bytes=500-   从第 500 字节开始，到文件结束部分&lt;/li&gt;
&lt;li&gt;Range:bytes=500-600,601-999&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Content-Range&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于响应头中，在发出带 Range的请求后，服务器会在Content-Range 头部返回当前接受的范围和文件总大小。一般格式：
&lt;ul&gt;
&lt;li&gt;Content-Range:bytes（unit first byte pos）-[last byte pos]/[entity legth]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;而在响应完成后，返回的响应头内容也不同：
&lt;ul&gt;
&lt;li&gt;HTTP/1.1200 Ok（不使用断点续传方式）&lt;/li&gt;
&lt;li&gt;HTTP/1.1 206 Partial Content（使用断点续传方式）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;断点续传过程&#34;&gt;断点续传过程&lt;/h2&gt;
&lt;p&gt;1.客户端下载一个1024K的文件，已经下载了其中512K。&lt;/p&gt;
&lt;p&gt;2.网络中断，客户端请求续传，因此需要在HTTP头中申明本次需要续传的片段：Range:bytes=512000-&lt;/p&gt;
&lt;p&gt;这个头通知服务端从文件的512K位置开始传输文件。&lt;/p&gt;
&lt;p&gt;3.服务端收到断点续传请求，从文件的512K位置开始传输，并且在HTTP头中增加：&lt;/p&gt;
&lt;p&gt;Content-Range:bytes 512000-/1024000并且此时服务端返回的HTTP状态码应该是206，而不是200。&lt;/p&gt;
">HTTP 系列（三）熟悉 HTTP 协议结构和通讯原理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/jvm-la-ji-hui-shou/"" data-c="
          &lt;h1 id=&#34;一-如何判断对象可以回收&#34;&gt;一、如何判断对象可以回收&lt;/h1&gt;
&lt;h2 id=&#34;11-引用计数法&#34;&gt;1.1 引用计数法&lt;/h2&gt;
&lt;p&gt;如果一个对象被其他变量引用，计数器 +1，如果某个变量不再引用，计数器 -1。如果一个对象的&lt;strong&gt;引用次数为 0&lt;/strong&gt;，就可以被回收。&lt;/p&gt;
&lt;h3 id=&#34;循环引用问题&#34;&gt;循环引用问题&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;A 对象引用 B 对象，B 对象的引用计数 = 1；B 对象引用了 A 对象，A 对象的引用计数 = 1，但是没有其他对象在引用它们两个，它们本应被回收，却因彼此循环引用，计数器不为 0 ，不能被回收，造成内存泄露。&lt;/p&gt;
&lt;h2 id=&#34;12-可达性分析算法&#34;&gt;1.2 可达性分析算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Java 虚拟机中的垃圾回收器采用&lt;strong&gt;可达性分析&lt;/strong&gt;来探索所有存活的对象&lt;/li&gt;
&lt;li&gt;扫描&lt;strong&gt;堆&lt;/strong&gt;中的对象，看是否能够沿着 &lt;strong&gt;GC Root对象为起点的引用链找到该对象&lt;/strong&gt;，找不到，表示可以回收&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;哪些对象可以作为-gc-root&#34;&gt;哪些对象可以作为 GC Root ?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;虚拟机栈中局部变量引用的对象&lt;/li&gt;
&lt;li&gt;本地方法栈中 JNI 中引用的对象&lt;/li&gt;
&lt;li&gt;方法去区静态属性引用的对象&lt;/li&gt;
&lt;li&gt;方法区中的常量引用的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;13-四种引用&#34;&gt;1.3 四种引用&lt;/h2&gt;
&lt;h3 id=&#34;131-强引用&#34;&gt;1.3.1. 强引用&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;一个对象通过等号赋值运算符赋值给变量，如：List&lt;String&gt; list = new ArrayList&amp;lt;&amp;gt;();&lt;br&gt;
变量 list 强引用了对象 ArrayList。只要沿着 GC Root 能够找到这个对象，这个对象就不会被垃圾回收。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%BC%BA%E5%BC%95%E7%94%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%BC%BA%E5%BC%95%E7%94%A82.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;package cn.itcast.jvm.t2;

import java.io.IOException;
import java.lang.ref.SoftReference;
import java.util.ArrayList;
import java.util.List;

/**
 * 演示强引用
 * -Xmx20m -XX:+PrintGCDetails -verbose:gc
 */
public class Demo2_3 {
    private static final int _4MB = 4 * 1024 * 1024;
    public static void main(String[] args) throws IOException {
      List&amp;lt;byte[]&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
      for (int i = 0; i &amp;lt; 5; i++) {
          list.add(new byte[_4MB]);// 读取图片放到 list 集合中进行显示，但是图片资源并不属于核心业务资源，如果图片过多，用强引用就会导致溢出。不太重要的资源能不能在内存紧张时把它占用的内存释放掉，以后如果再用到的话再读取一遍呢？采用软引用。
      } 
      System.in.read();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过 &lt;code&gt;-Xmx20m -XX:+PrintGCDetails -verbose:gc&lt;/code&gt; 设置堆空间大小为 20M 并且打印 GC 信息，创建 list 变量强引用 ArrayLsit 对象，向 ArrayList 内放入 20M 对象，由于程序一直未被终止，所以 list 不能被回收，导致 堆内存溢出异常 &lt;code&gt;OutOfMemoryError: Java heap space&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Exception in thread &amp;quot;main&amp;quot; java.lang.OutOfMemoryError: Java heap space
	at cn.itcast.jvm.t2.Demo2_3.main(Demo2_3.java:21)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;132-软引用softreference&#34;&gt;1.3.2. 软引用（SoftReference）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;仅有软引用引用该对象时，在&lt;strong&gt;垃圾回收后，内存仍不足&lt;/strong&gt;时会再次触发垃圾回收，回收软引用对象&lt;/li&gt;
&lt;li&gt;可以配合&lt;strong&gt;引用队列&lt;/strong&gt;来释放软引用自身&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%BD%AF%E5%BC%95%E7%94%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;package cn.itcast.jvm.t2;

import java.io.IOException;
import java.lang.ref.SoftReference;
import java.util.ArrayList;
import java.util.List;

/**
 * 演示软引用
 * -Xmx20m -XX:+PrintGCDetails -verbose:gc
 */
public class Demo2_3 {

    private static final int _4MB = 4 * 1024 * 1024;

    public static void main(String[] args) throws IOException {
        soft();
    }

    public static void soft() {
        // list --&amp;gt; SoftReference --&amp;gt; byte[]
        // list 和 SoftReference 之间是强引用，SoftReference 和 byte[] 之间是软引用
        List&amp;lt;SoftReference&amp;lt;byte[]&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; 5; i++) {
            SoftReference&amp;lt;byte[]&amp;gt; ref = new SoftReference&amp;lt;&amp;gt;(new byte[_4MB]);
            System.out.println(ref.get());
            list.add(ref);
            System.out.println(list.size());

        }
        System.out.println(&amp;quot;循环结束：&amp;quot; + list.size());
        for (SoftReference&amp;lt;byte[]&amp;gt; ref : list) {
            System.out.println(ref.get());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%BD%AF%E5%BC%95%E7%94%A8GC.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;清理无用的软引用：引用队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软引用对象被释放后，没必要再保存在 list 中了，希望把&lt;strong&gt;软引用本身做一个清理&lt;/strong&gt;，从 list 集合中清理掉。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package cn.itcast.jvm.t2;

import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.SoftReference;
import java.util.ArrayList;
import java.util.List;

/**
 * 演示软引用, 配合引用队列
 */
public class Demo2_4 {
    private static final int _4MB = 4 * 1024 * 1024;

    public static void main(String[] args) {
        List&amp;lt;SoftReference&amp;lt;byte[]&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

        // 引用队列
        ReferenceQueue&amp;lt;byte[]&amp;gt; queue = new ReferenceQueue&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; 5; i++) {
            // 关联了引用队列， 当软引用所关联的 byte[]被回收时，软引用自己会加入到 queue 中去
            SoftReference&amp;lt;byte[]&amp;gt; ref = new SoftReference&amp;lt;&amp;gt;(new byte[_4MB], queue);
            System.out.println(ref.get());
            list.add(ref);
            System.out.println(list.size());
        }

        // 从队列中获取无用的 软引用对象，并移除
        Reference&amp;lt;? extends byte[]&amp;gt; poll = queue.poll();
        while( poll != null) {
            list.remove(poll);
            poll = queue.poll();
        }

        System.out.println(&amp;quot;===========================&amp;quot;);
        for (SoftReference&amp;lt;byte[]&amp;gt; reference : list) {
            System.out.println(reference.get());
        }

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：值为空的软引用都被从 list 集合中清除了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[B@6d6f6e28
1
[B@135fbaa4
2
[B@45ee12a7
3
[B@330bedb4
4
[B@2503dbd3
5
===========================
[B@2503dbd3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;133-弱引用weakreference&#34;&gt;1.3.3. 弱引用（WeakReference）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象&lt;/li&gt;
&lt;li&gt;可以配合引用队列来释放弱引用自身&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%BC%B1%E5%BC%95%E7%94%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;引用队列：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%BC%B1%E5%BC%95%E7%94%A8%E5%BC%95%E7%94%A8%E9%98%9F%E5%88%97.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;当软引用的对象被回收后，软引用自身也是一个对象，如果在创建时给他分配了一个引用队列，那在它&lt;strong&gt;引用的对象被回收&lt;/strong&gt;时，软引用就会进入这个&lt;strong&gt;引用队列&lt;/strong&gt;。当弱引用的对象被垃圾回收后，弱引用如果被分配了引用队列的话， 弱引用也会进入引用队列。因为软引用、弱引用自身也要占用一定内存，如果要对它俩占用的内存进一步释放，需要使用引用队列来找到它们。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package cn.itcast.jvm.t2;

import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.List;

/**
 * 演示弱引用
 * -Xmx20m -XX:+PrintGCDetails -verbose:gc
 */
public class Demo2_5 {
    private static final int _4MB = 4 * 1024 * 1024;

    public static void main(String[] args) {
        //  list --&amp;gt; WeakReference --&amp;gt; byte[]
        List&amp;lt;WeakReference&amp;lt;byte[]&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; 10; i++) {
            WeakReference&amp;lt;byte[]&amp;gt; ref = new WeakReference&amp;lt;&amp;gt;(new byte[_4MB]);
            list.add(ref);
            for (WeakReference&amp;lt;byte[]&amp;gt; w : list) {
                System.out.print(w.get()+&amp;quot; &amp;quot;);
            }
            System.out.println();

        }
        System.out.println(&amp;quot;循环结束：&amp;quot; + list.size());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%BC%B1%E5%BC%95%E7%94%A8GC.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在&lt;strong&gt;垃圾回收时，会把弱引用所占用的内存释放掉&lt;/strong&gt;，弱引用自身占用的内存要释放的话，要结合引用队列来实现。&lt;/p&gt;
&lt;h3 id=&#34;134-虚引用phantomreference&#34;&gt;1.3.4. 虚引用（PhantomReference）&lt;/h3&gt;
&lt;p&gt;虚引用和终结器引用必须配合引用队列使用。&lt;strong&gt;当创建虚引用和终结器引用时，都会关联一个引用队列。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队， 由 Reference Handler 线程调用虚引用相关方法&lt;strong&gt;释放直接内存&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%99%9A%E5%BC%95%E7%94%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;创建 ByteBuffer 的实现对象时，会创建一个名为 Cleaner 的&lt;strong&gt;虚引用对象&lt;/strong&gt;，ByteBuffer 会分配一块直接内存，并且会把直接内存的地址传递给虚引用对象。将来 ByteBuffer 没有被强引用引用时，ByteBuffer 就会被垃圾回收，但是给他分配的&lt;strong&gt;直接内存并不能被 Java 垃圾回收&lt;/strong&gt;管理。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%99%9A%E5%BC%95%E7%94%A82.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;所以在 ByteBuffer 被回收时，让虚引用对象进入引用队列，虚引用所在的引用队列会由 ReferenceHandler 线程定时到这个引用队列中找看有没有新入队的 Cleaner，如果有，就会调用 Cleaner 中的 clean() 方法，根据前面记录的直接内存的地址调用 Unsafe.freeMemory()，&lt;strong&gt;释放直接内存&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;135-终结器引用finalreference&#34;&gt;1.3.5. 终结器引用（FinalReference）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;无需手动编码，但其内部&lt;strong&gt;配合引用队列使用&lt;/strong&gt;，在&lt;strong&gt;垃圾回收&lt;/strong&gt;时，&lt;strong&gt;终结器引用入队&lt;/strong&gt;（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并&lt;strong&gt;调用它的 finalize 方法&lt;/strong&gt;，&lt;strong&gt;第二次 GC 时才能回收被引用对象&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E7%BB%88%E7%BB%93%E5%99%A8%E5%BC%95%E7%94%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;所有的 Java 对象都会继承在 Object 父类，Object 类中有一个 finalize() 终结方法。某个对象&lt;strong&gt;重写了 finalize() 方法&lt;/strong&gt;，当没有强引用引用它时，就由虚拟机创建它对应的终结器引用，当这个对象要被垃圾回收时，就会把这个&lt;strong&gt;终结器引用加入引用队列&lt;/strong&gt;，再由一个&lt;strong&gt;优先级很低的线程 &lt;strong&gt;（finalize() 迟迟未能被调用，导致对象很久不能被真正回收，所以不推荐使用 finalize() 释放资源）finalizeHandler 线程查看引用队列中是否有终结器引用，如果有，就会根据终结器引用找到那个&lt;/strong&gt;要被垃圾回收的对象&lt;/strong&gt;，并且&lt;strong&gt;调用它的 finalize()方法&lt;/strong&gt;，调用完了，&lt;strong&gt;下一次垃圾回收时就可以把这个对象占用的内存真正回收了&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&#34;二-垃圾回收算法&#34;&gt;二、垃圾回收算法&lt;/h1&gt;
&lt;h2 id=&#34;21-标记清除&#34;&gt;2.1 标记清除&lt;/h2&gt;
&lt;p&gt;定义： Mark Sweep&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;速度快&lt;/li&gt;
&lt;li&gt;会造成内存碎片&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;标记清除流程&#34;&gt;标记清除流程&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;标记&lt;/strong&gt;：沿着 GC Root 的引用链去找，扫描整个堆对象的过程中，如果发现某个堆对象确实被引用了，那么这个堆对象是非垃圾对象，如果某个对&lt;strong&gt;象没有任何一个 GC Root 直接或间接引用&lt;/strong&gt;它，那么把它&lt;strong&gt;标记为垃圾对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;清除&lt;/strong&gt;：将被标记为垃圾对象所占用的空间释放掉。这里说的释放不是把这个对象所占用的内存的每个字节清零，只需要把垃&lt;strong&gt;圾对象占用内存的起始、结束地址记录下来，放在一个空闲地址列表&lt;/strong&gt;，下次分配新对象时，到空闲地址列表中找是否有一块足够的空间能容纳新对象。&lt;/p&gt;
&lt;h3 id=&#34;优点&#34;&gt;优点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;速度快&lt;/strong&gt;，只需把垃圾对象的起始、结束地址记录下来。&lt;/p&gt;
&lt;h3 id=&#34;缺点&#34;&gt;缺点&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E5%86%85%E7%A2%8E%E7%89%87.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;易产生&lt;strong&gt;内存碎片&lt;/strong&gt;。清除垃圾对象后不会对内存空间进行整理，如果分配了一个较大的对象，比如数组，数组需要一段连续的内存。每个小的空闲空间都不足以容纳下这个较大的新对象，虽然总的空闲空间足够，但由于&lt;strong&gt;不连续&lt;/strong&gt;，造成新对象不能被保存。&lt;/p&gt;
&lt;h2 id=&#34;22-标记整理&#34;&gt;2.2 标记整理&lt;/h2&gt;
&lt;p&gt;定义：Mark Compact&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;速度慢&lt;/li&gt;
&lt;li&gt;没有内存碎片&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;标记整理流程&#34;&gt;标记整理流程&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;标记&lt;/strong&gt;：没有任何 GC Root 直接或间接指向的堆对象被标记为垃圾对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;整理&lt;/strong&gt;：避免标记清除时的内存碎片问题，在清理垃圾的过程中，会把可用的对象向前移动，让内存更为&lt;strong&gt;紧凑&lt;/strong&gt;，连续的内存空间就更大了。&lt;/p&gt;
&lt;h3 id=&#34;优点-2&#34;&gt;优点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;没有内碎片&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;缺点-2&#34;&gt;缺点&lt;/h3&gt;
&lt;p&gt;由于整理牵扯到对象的移动，&lt;strong&gt;效率降低&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对象在整理过程中发生移动，如果有其他局部变量引用了这个被移动的对象，就需要改变这些引用的地址。&lt;/p&gt;
&lt;h2 id=&#34;23-复制&#34;&gt;2.3 复制&lt;/h2&gt;
&lt;p&gt;定义：Copy&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不会有内存碎片&lt;/li&gt;
&lt;li&gt;需要占用双倍内存空间&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;复制流程&#34;&gt;复制流程&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%A4%8D%E5%88%B61.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;标记垃圾对象&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%A4%8D%E5%88%B62.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;复制 FROM 区域的非垃圾对象到 TO 区域&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%A4%8D%E5%88%B63.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;清空 FROM 区域剩余的垃圾对象后交换 FROM 和 TO 区域&lt;/p&gt;
&lt;p&gt;将内存区域划分成两块大小相等的区域，FROM 和 TO（空闲）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标记&lt;/strong&gt;：找到那些不被引用的对象标记为垃圾对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复制&lt;/strong&gt;：把 &lt;strong&gt;FROM 区域上的非垃圾对象复制到 TO 区域&lt;/strong&gt;中，复制的过程中完成碎片整理。复制完成后，&lt;strong&gt;FROM 区域&lt;/strong&gt;都是垃圾对象，&lt;strong&gt;全部清除&lt;/strong&gt;，并且&lt;strong&gt;交换 FROM 和 TO 区域&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;优点-3&#34;&gt;优点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;不会产生碎片。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;缺点-3&#34;&gt;缺点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;占用双倍内存空间。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;三-分代垃圾回收&#34;&gt;三、分代垃圾回收&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;堆内存划分&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新生代：用完了就丢弃。&lt;strong&gt;朝生夕死&lt;/strong&gt;的对象
&lt;ul&gt;
&lt;li&gt;伊甸园 Eden&lt;/li&gt;
&lt;li&gt;幸存区 FROM&lt;/li&gt;
&lt;li&gt;幸存区 TO&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;老年代：长时间使用的对象。&lt;strong&gt;长期存活&lt;/strong&gt;的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;有一栋居民楼，类似 Java 虚拟机中的堆内存，居民楼中每家每户每天要产生一些垃圾，需要保洁工人来处理，如果保洁工人挨家挨户去收垃圾，效率低，所以设立一个垃圾场（新生代），存放生命周期短的垃圾，比如盒饭、包装袋等，都是回收更为频繁的垃圾，保洁工人需要每天打扫了一次。 每家每户里存储的垃圾（老年代），比如用旧的椅子，暂存在家里，将来空间紧张到放不下时，找保洁员清理这些垃圾。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%A0%86%E5%86%85%E5%AD%98%E5%88%92%E5%88%86.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;对象首先分配在伊甸园区域&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1并且交换 from、to&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;对象的复制会更改对象地址，如果用户线程仍在运行，就会造成访问原来对象的地址找不到。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当对象寿命超过阈值时，会晋升至老年代，最大寿命是15&lt;/strong&gt;（对象头中占用 4bit：1111B）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时间更长，如果之后空间仍不足，就会内存溢出。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;31-分代垃圾回收机制原理&#34;&gt;3.1 分代垃圾回收机制原理&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;当伊甸园被占满时要添加新对象，触发 minor gc&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;将伊甸园区的对象进行标记后，非垃圾对象复制到幸存区 TO，并且将这些非垃圾对象的寿命 +1，清空伊甸园内剩余的垃圾对象&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_3.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;交换 FROM 和 TO&lt;/p&gt;
&lt;p&gt;创建一个新对象，存放到&lt;strong&gt;伊甸园&lt;/strong&gt;，当伊甸园被占满时，触发 &lt;strong&gt;minor gc&lt;/strong&gt;，先对伊甸园区域内的对象进行&lt;strong&gt;标记&lt;/strong&gt;，标记结束后，采用&lt;strong&gt;复制算法&lt;/strong&gt;，将非垃圾对象&lt;strong&gt;复制&lt;/strong&gt;到幸存区 TO，并让这些对象的寿命+1，伊甸园剩余的垃圾对象回收掉，&lt;strong&gt;交换&lt;/strong&gt; FROM 和 TO，第一次 minor gc 结束。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_4.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;将伊甸园和幸存区 FROM 中的非垃圾对象复制到幸存区 TO，并将这些对象的寿命 +1，清空伊甸园和幸存区 FROM 中的非垃圾对象，交换 FROM 和 TO。将新对象放入伊甸园。&lt;/p&gt;
&lt;p&gt;继续创建对象向伊甸园添加，伊甸园再次被填满，再次触发 minor gc，除了要将伊甸园中的非垃圾对象找到以外，还要把&lt;strong&gt;幸存区 FROM&lt;/strong&gt; 中的非垃圾对象找到，将非垃圾对象复制到幸存区 TO，并让这些对象的寿命 +1，伊甸园和幸存区 FROM 的垃圾对象清除，交换 FROM 和 TO，第二次 minor gc 结束。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_5.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;当幸存区对象的寿命 = 15时，将此对对象移动到老年代。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_6.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;当老年代空间不足，触发 FULL GC，对整个堆进行清理。&lt;/p&gt;
&lt;h2 id=&#34;32-相关-vm-参数&#34;&gt;3.2 相关 VM 参数&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;含义&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;堆初始大小&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-Xms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;堆最大大小&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-Xmx 或 -XX:MaxHeapSize=size&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;新生代大小&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;幸存区比例（动态）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;幸存区比例&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-XX:SurvivorRatio=ratio&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;晋升阈值&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-XX:MaxTenuringThreshold=threshold&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;晋升详情&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-XX:+PrintTenuringDistribution&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;GC详情&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-XX:+PrintGCDetails -verbose:gc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;FullGC 前 MinorGC&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-XX:+ScavengeBeforeFullGC&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol&gt;
&lt;li&gt;没有运行任何代码时，虚拟机参数 &lt;code&gt;-Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc&lt;/code&gt; 的堆内存占用情况&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;public class Demo2_1 {
    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc
    // -Xms20M：初始堆空间20M；
    // -Xmx20M：最大堆空间20M；
    // -Xmn10M：新生代10M；
    // -XX:+UseSerialGC：垃圾回收器，幸存区比例不会动态调整
    // -XX:+PrintGCDetails -verbose:gc：打印 gc 详情
    public static void main(String[] args) throws InterruptedException {


    }
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;25&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B0.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;2.Eden 区域不足时，触发 minor gc 时的堆内存占用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package cn.itcast.vm.t2;
import java.util.ArrayList;
public class Demo2_1 {
    private static final int _7MB = 7 * 1024 * 1024;

    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC
    public static void main(String[] args) throws InterruptedException {
        ArrayList&amp;lt;byte[]&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(new byte[_7MB]);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为 Eden 共 8M，类加载时创建一些对象占用了 29% 的空间，大概剩余 6M 空间，创建一个 7M 的对象，加入 Eden，Eden 内存不足，会触发垃圾回收。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B02.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package cn.itcast.jvm.t2;

import java.util.ArrayList;

/**
 *  演示内存的分配策略
 */
public class Demo2_1 {
    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * 1024 * 1024;
    private static final int _7MB = 7 * 1024 * 1024;
    private static final int _8MB = 8 * 1024 * 1024;

    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC
    public static void main(String[] args) throws InterruptedException {
        ArrayList&amp;lt;byte[]&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(new byte[_7MB]);
        list.add(new byte[_512KB]);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;26&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B03.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;新生代区域内存不足创建对象，放入老年代&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;package cn.itcast.jvm.t2;

import java.util.ArrayList;

/**
 *  演示内存的分配策略
 */
public class Demo2_1 {
    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * 1024 * 1024;
    private static final int _7MB = 7 * 1024 * 1024;
    private static final int _8MB = 8 * 1024 * 1024;

    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC
    public static void main(String[] args) throws InterruptedException {
        ArrayList&amp;lt;byte[]&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(new byte[_7MB]);
        list.add(new byte[_512KB]);
        list.add(new byte[_512KB]);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;27&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B04.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;添加的对象比新生代总内存大，直接放入老年代且不触发 GC。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;package cn.itcast.jvm.t2;
import java.util.ArrayList;
public class Demo2_1 {
    private static final int _8MB = 8 * 1024 * 1024;
    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC
    public static void main(String[] args) throws InterruptedException {
        ArrayList&amp;lt;byte[]&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(new byte[_8MB]);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;28&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B05.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;内存溢出&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;package cn.itcast.jvm.t2;

import java.util.ArrayList;

/**
 *  演示内存的分配策略
 */
public class Demo2_1 {
    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * 1024 * 1024;
    private static final int _7MB = 7 * 1024 * 1024;
    private static final int _8MB = 8 * 1024 * 1024;

    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC
    public static void main(String[] args) throws InterruptedException {
        ArrayList&amp;lt;byte[]&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(new byte[_8MB]);
        list.add(new byte[_8MB]);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;29&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B06.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;当内存溢出发生在子线程中，是否会导致 java 进程结束？&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;package cn.itcast.jvm.t2;

import java.util.ArrayList;

/**
 *  演示内存的分配策略
 */
public class Demo2_1 {
    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * 1024 * 1024;
    private static final int _7MB = 7 * 1024 * 1024;
    private static final int _8MB = 8 * 1024 * 1024;

    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails 
    public static void main(String[] args) throws InterruptedException {
        new Thread(() -&amp;gt; {
            ArrayList&amp;lt;byte[]&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
            list.add(new byte[_8MB]);
            list.add(new byte[_8MB]);

        }).start();

        System.out.println(&amp;quot;sleep....&amp;quot;);
        Thread.sleep(1000L);  
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;30&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B07.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;四-垃圾回收器&#34;&gt;四、垃圾回收器&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;串行&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;单线程&lt;/li&gt;
&lt;li&gt;堆内存较小，适合个人电脑&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;吞吐量优先&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;多线程&lt;/li&gt;
&lt;li&gt;堆内存较大，多核 cpu&lt;/li&gt;
&lt;li&gt;让单位时间内，STW 的时间最短。两次垃圾回收：0.2+0.2 = 0.4，&lt;strong&gt;垃圾回收时间占比最低，这样就称吞吐量高&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;响应时间优先&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;多线程&lt;/li&gt;
&lt;li&gt;堆内存较大，多核 cpu&lt;/li&gt;
&lt;li&gt;尽可能让&lt;strong&gt;单次 STW 的时间最短&lt;/strong&gt;。五次垃圾回收：0.1+0.1+0.1+0.1+0.1 = 0.5&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;41-串行&#34;&gt;4.1 串行&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;-XX:+UseSerialGC = Serial + SerialOld
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Serial：工作在&lt;strong&gt;新生代&lt;/strong&gt;。&lt;strong&gt;复制&lt;/strong&gt;算法&lt;br&gt;
SerialOld：工作在&lt;strong&gt;老年代&lt;/strong&gt;。&lt;strong&gt;标记整理&lt;/strong&gt;算法&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;31&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%B8%B2%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;四个 CPU 在运行，某时刻堆内存不足，触发垃圾回收。触发垃圾回收时，需要让这些线程到达一个&lt;strong&gt;安全点&lt;/strong&gt;再停下，因为在垃圾回收的过程中，可能对象的地址发生改变，为了保证安全地使用这些对象地址，需要所有正在工作的用户线程到达这个安全点在停下。因为 Serial、SerialOld 都是&lt;strong&gt;单线程&lt;/strong&gt;的垃圾回收器，因此在一个垃圾回收线程运行时，其他的用户线程都要&lt;strong&gt;阻塞&lt;/strong&gt;，等到垃圾回收线程结束后，其他的用户线程再恢复运行。&lt;/p&gt;
&lt;h2 id=&#34;42-吞吐量优先&#34;&gt;4.2 吞吐量优先&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;吞吐量&lt;/strong&gt;：CPU 用于运行用户程序的时间与总时间的比值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-XX:+UseParallelGC ~ -XX:+UseParallelOldGC
-XX:+UseAdaptiveSizePolicy
-XX:GCTimeRatio=ratio 
-XX:MaxGCPauseMillis=ms 
-XX:ParallelGCThreads=n 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-XX:+UseParallelGC ~ -XX:+UseParallelOldGC&lt;/code&gt;：JDK 1.8 默认使用 ParallelGC &lt;strong&gt;并行&lt;/strong&gt;的垃圾回收器。&lt;br&gt;
UseParallelGC 并行的新生代垃圾回收器，采用&lt;strong&gt;复制&lt;/strong&gt;算法；UseParallelOldGC 并行的老年代垃圾回收器，采用&lt;strong&gt;标记整理&lt;/strong&gt;算法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-XX:+UseAdaptiveSizePolicy&lt;/code&gt;：自适应大小调整（新生代：Eden 和 Survival）策略&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-XX:GCTimeRatio=ratio&lt;/code&gt;：根据设置目标调整堆的大小以达到期望的目标。吞吐量：垃圾回收时间和总时间占比。1/(1+ratio)。一般堆调大，减少垃圾回收次数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-XX:MaxGCPauseMillis=ms&lt;/code&gt;：最大暂停毫秒数（每一次垃圾回收耗时）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-XX:ParallelGCThreads=n&lt;/code&gt; ：控制 ParallelGC 运行时的&lt;strong&gt;线程数&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;32&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;四个 CPU 在运行，某一时刻内存不足触发垃圾回收，用户线程就会到达安全点然后停下来，垃圾回收器&lt;strong&gt;开启多个线程进行垃圾回收&lt;/strong&gt;。垃圾回收线程个数默认和 CPU 核数相关。回收结束后再恢复其他的线程运行。在垃圾回收时，四核 CPU 都去进行垃圾回收了，&lt;strong&gt;CPU 占用率&lt;/strong&gt;会一下达到 100%。&lt;/p&gt;
&lt;h2 id=&#34;43-响应时间优先&#34;&gt;4.3 响应时间优先&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld 
-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads 
-XX:CMSInitiatingOccupancyFraction=percent 
-XX:+CMSScavengeBeforeRemark
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-XX:+UseConcMarkSweepGC&lt;/code&gt; ：&lt;strong&gt;并发标记清除&lt;/strong&gt;。垃圾回收器工作的同时，其他用户线程也能同时进行。垃圾回收线程和用户线程并发执行，都要去抢占 CPU。&lt;br&gt;
&lt;code&gt;-XX:+UseParNewGC&lt;/code&gt;：工作在新生代，复制算法。 &lt;strong&gt;SerialOld&lt;/strong&gt;：老年代垃圾回收器由并发退化为单线程 （基于标记整理的老年垃圾回收器）。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;多个 CPU 并行执行，老年代内存不足，所有进程到达安全点，执行&lt;strong&gt;初始标记&lt;/strong&gt;，用户线程阻塞，STW；初始标记结束后，用户线程开始运行，停止 STW，与此同时垃圾回收线程&lt;strong&gt;并发标记&lt;/strong&gt;，把剩余的垃圾找出来；并发标记结束后，进行&lt;strong&gt;重新标记&lt;/strong&gt;，这个过程 STW，因为并发标记的过程用户线程可能对垃圾回收做了干扰，所以并发标记结束后还要再做一次重新标记；重新标记结束后，用户线程继续运行，垃圾回收线程&lt;strong&gt;并发清理&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;44-g1&#34;&gt;4.4 G1&lt;/h2&gt;
&lt;p&gt;定义：Garbage First&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2004 论文发布&lt;/li&gt;
&lt;li&gt;2009 JDK 6u14 体验&lt;/li&gt;
&lt;li&gt;2012 JDK 7u4 官方支持&lt;/li&gt;
&lt;li&gt;2017 JDK 9 默认。G1 取代了 CMS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;适用场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同时注重&lt;strong&gt;吞吐量&lt;/strong&gt;（Throughput）和&lt;strong&gt;低延迟&lt;/strong&gt;（Low latency），默认的暂停目标是 200 ms&lt;/li&gt;
&lt;li&gt;并发的垃圾回收器，和 CMS 一样追求低延迟，可以在用户线程工作的同时垃圾回收线程也并发执行。另外还借鉴了 Parallel：注重吞吐量垃圾回收器的思想，可以进行调整，设置默认暂停目标（&lt;code&gt;-XX:MaxGCPauseMillis&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;超大堆内存&lt;/strong&gt;，会&lt;strong&gt;将堆划分为多个大小相等的 Region&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;随着堆内存容量的增大，G1 与 CMS 相比优势更加明显。&lt;/p&gt;
&lt;p&gt;将堆划分为多个大小相等的 Region：每个区域都可以独立地作为 Eden、survive、老年代。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-XX:G1HeapRegionSize&lt;/code&gt;：设置区域的大小，必须是2的幂。如果堆内存过大，回收速度会变慢，因为会涉及对象的复制标记，而分成小的区域进行管理，可以化整为零，进行一些优化加快标记拷贝的速度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整体上是 &lt;strong&gt;标记+整理&lt;/strong&gt; 算法（避免标记清除算法产生的内碎片），两个区域之间是复制算法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相关 JVM 参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-XX:+UseG1GC 
-XX:G1HeapRegionSize=size 
-XX:MaxGCPauseMillis=time
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;33&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/G1_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1-g1-垃圾回收阶段&#34;&gt;1) G1 垃圾回收阶段&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;34&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%98%B6%E6%AE%B5.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;刚开始新生代垃圾收集，如果某时刻老年代内存超过阈值了，在新生代垃圾收集的同时进行并发标记，这个阶段结束后会进行混合收集：会对新生代、幸存区、老年代都进行收集。混合收集结束，Eden 内存释放掉，会再进入新生代垃圾收集。&lt;/p&gt;
&lt;h3 id=&#34;2-young-collection&#34;&gt;2) Young Collection&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;会 STW&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;35&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/G1%E5%88%86%E5%8C%BA.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;G1 垃圾回收器把&lt;strong&gt;堆内存划分成大小相等的一个个区域&lt;/strong&gt;，每个区域都可独立作为伊甸园、幸存区、老年代。刚开始白色的区域表示是空闲的区域，类加载时新创建的对象刚开始会分配到伊甸园区，绿色的 E 就代表 Eden 区，当 Eden 区域逐渐被占满，就会触发新生代的垃圾回收。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;36&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/G1%E6%96%B0%E7%94%9F%E4%BB%A3%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;新生代垃圾回收会把非垃圾对象以复制算法放入幸存区。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;37&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/G1%E8%80%81%E5%B9%B4%E4%BB%A3.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;当幸存区对象放不下，或幸存区对象寿命达到一定值，会触发垃圾回收，幸存区一部分对象会晋升到老年代，而寿命未达到阈值的会拷贝到另一个幸存区，新生代的非垃圾对象也会复制到这个幸存区。&lt;/p&gt;
&lt;h3 id=&#34;3-young-collection-cm&#34;&gt;3) Young Collection + CM&lt;/h3&gt;
&lt;p&gt;CM：Concurrent mark：并发标记&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;初始标记&lt;/strong&gt;：找到那些根对象，标记根对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并发标记&lt;/strong&gt;：从根对象出发，顺着引用链找到其他非垃圾对象，标记那些其他非垃圾对象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 Young GC 时会进行 GC Root 的&lt;strong&gt;初始标记&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;老年代占用堆空间比例达到阈值时，进行&lt;strong&gt;并发标记&lt;/strong&gt;（不会 STW），由下面的 JVM 参数决定&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;-XX:InitialtingHeapOccupancyPercent=percent（默认45%）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;老年代占用堆空间内存达到 45% 时，会进行并发标记。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/G1%E8%80%81%E5%B9%B4%E4%BB%A3%E8%BF%87%E5%A4%9A%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;E：Eden&lt;/p&gt;
&lt;p&gt;S：Survive&lt;/p&gt;
&lt;p&gt;O：Old&lt;/p&gt;
&lt;h3 id=&#34;4-mixed-collection&#34;&gt;4) Mixed Collection&lt;/h3&gt;
&lt;p&gt;会对 E、S、O 进行&lt;strong&gt;全面垃圾回收&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最终标记（Remark）会 STW&lt;/li&gt;
&lt;li&gt;拷贝存活（Evacuation）会 STW&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;-XX:MaxGCPauseMillis=ms&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;38&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/G1%E5%85%A8%E9%9D%A2%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Eden 区域的非垃圾对象被复制到 Survive 区域，Survive 区域寿命未达到阈值的非垃圾对象被复制到另一个 Survive 区域，寿命达到阈值的晋升到老年代区域。一部分老年代区域的幸存对象通过复制算法复制到新的的老年代区域，为什么没有把所有老年代都通过箭头指向新的老年代呢？因为 G1 会根据最大暂停时间有选择地进行回收，有时候堆内存空间太大了，老年代的垃圾回收可能时间比较长（复制算法大量对象的复制），就达不到&lt;strong&gt;最大暂停时间&lt;/strong&gt;的目标了，为了达到这个目标，G1 会从老年代中挑出&lt;strong&gt;回收价值最高&lt;/strong&gt;的区域（垃圾回收后能释放空间多的区域），只从老年代中挑选一部分区域复制，复制的区域少了，就可以达到暂停时间的目标了。如果老年代没有那么多，可以达到最大暂停时间的话， 就会把所有区域都进行复制。&lt;/p&gt;
&lt;h3 id=&#34;5-full-gc&#34;&gt;5) Full GC&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;SerialGC：串行
&lt;ul&gt;
&lt;li&gt;新生代内存不足发生的垃圾收集 - minor gc&lt;/li&gt;
&lt;li&gt;老年代内存不足发生的垃圾收集 - full gc&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ParallelGC：并行
&lt;ul&gt;
&lt;li&gt;新生代内存不足发生的垃圾收集 - minor gc&lt;/li&gt;
&lt;li&gt;老年代内存不足发生的垃圾收集 - full gc&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CMS
&lt;ul&gt;
&lt;li&gt;新生代内存不足发生的垃圾收集 - minor gc&lt;/li&gt;
&lt;li&gt;老年代内存不足
&lt;ul&gt;
&lt;li&gt;并发收集失败后 Full GC&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;G1
&lt;ul&gt;
&lt;li&gt;新生代内存不足发生的垃圾收集 - minor gc&lt;/li&gt;
&lt;li&gt;老年代内存不足
&lt;ul&gt;
&lt;li&gt;有一个阈值，当老年代内存达到阈值，就会触发并发标记、混合收集阶段。如果垃圾回收的速度高于新的用户线程产生垃圾的速度，就处于并发垃圾收集阶段，这阶段还不算 Full GC。&lt;/li&gt;
&lt;li&gt;当垃圾回收的速度跟不上垃圾产生的速度，并发收集失败，就会触发串行收集，这阶段叫做 Full GC。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;6-young-collection-跨代引用&#34;&gt;6) Young Collection 跨代引用&lt;/h3&gt;
&lt;p&gt;新生代回收的跨代引用（老年代引用新生代）问题&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;39&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Card.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;新生代垃圾回收：找到根对象，沿着引用链找到存活对象，存活对象进行复制到幸存区。要找新生代对象的根对象，&lt;strong&gt;根对象有一部分来自于老年代&lt;/strong&gt;，老年代的存活对象非常多，如果遍历老年代找根对象效率低，因此把&lt;strong&gt;老年代区域再进行细分&lt;/strong&gt;，分成一个个 Card，每个 Card 是512KB，如果老年代其中有一个 &lt;strong&gt;Card 中的对象引用了新生代的某一个对象&lt;/strong&gt;，就把这个 &lt;strong&gt;Card 标记为脏&lt;/strong&gt;，这样以后，做 GC Root 遍历的时候就不用去找整个老年代了，只需要关注那些脏 Card 即可，减少搜索范围，&lt;strong&gt;提高扫描根对象的效率&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;卡表与 Remembered Set&lt;/li&gt;
&lt;li&gt;在引用变更时通过 post-write barrier + dirty card queue&lt;/li&gt;
&lt;li&gt;concurrent refinement threads 更新 Remembered Set&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;40&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Card2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;粉色的 Card 都是&lt;strong&gt;脏卡区&lt;/strong&gt;，Card 内有对象指向新生代区域的对象，新生代会记录 &lt;strong&gt;Remembered Set：从外部对我的引用&lt;/strong&gt;，将来对新生代 Eden 进行垃圾回收时，就可以先通过 Remembered Set 知道它对应的哪些脏 Card，然后在到这些脏卡区遍历对象找到 GC Root。通过 &lt;strong&gt;post-write barrier&lt;/strong&gt;：写屏障在每次&lt;strong&gt;对象的引用发生变更时，去更新脏 Card&lt;/strong&gt;，这个过程是&lt;strong&gt;异步&lt;/strong&gt;操作，不会立刻完成脏卡的更新，会把更新指令放在 &lt;strong&gt;dirty card queue 脏卡队列&lt;/strong&gt;中，将来由一个线程完成脏卡更新的操作。&lt;/p&gt;
&lt;h3 id=&#34;7-remark-重标记阶段&#34;&gt;7) Remark 重标记阶段&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;pre-write barrier + satb_mark_queue&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;pre-write barrier&lt;/code&gt;：写屏障：在对象引用改变前，将对象加入到 &lt;code&gt;satb_mark_queue&lt;/code&gt; 队列，将来 remark 从队列中取出对象进一步判断。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;41&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E9%87%8D%E6%A0%87%E8%AE%B0_1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;并发标记阶段对象的 true 和 false，其中图中&lt;strong&gt;黑色&lt;/strong&gt;表示已经处理完成，并且有引用在引用它们，在垃圾回收后会被&lt;strong&gt;保留&lt;/strong&gt;下来。&lt;strong&gt;灰色&lt;/strong&gt;的是正在&lt;strong&gt;触发中&lt;/strong&gt;，灰色的因为有强引用黑色的在指向它，所以最终会变成黑色，&lt;strong&gt;白色&lt;/strong&gt;的是&lt;strong&gt;尚未处理&lt;/strong&gt;，如果有强引用指向它最后会变成黑色，如果没有引用指向它最终还是白色，会被当成垃圾回收。垃圾回收结束后，会根据对象的黑白状态区分它到底应该存活还是被回收。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E9%87%8D%E6%A0%87%E8%AE%B0_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E9%87%8D%E6%A0%87%E8%AE%B0_3.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark 流程：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E9%87%8D%E6%A0%87%E8%AE%B0_4.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;8-jdk-8u20-字符串去重&#34;&gt;8) JDK 8u20 字符串去重&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;优点：节省大量内存&lt;/li&gt;
&lt;li&gt;缺点：略微多占用了 cpu 时间，新生代回收时间略微增加&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;-XX:+UseStringDeduplication&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String s1 = new String(&amp;quot;hello&amp;quot;); // char[]{&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;} 
String s2 = new String(&amp;quot;hello&amp;quot;); // char[]{&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;将所有新分配的字符串放入一个&lt;strong&gt;队列&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当新生代回收时，G1并发检查队列中是否有字符串重复&lt;/li&gt;
&lt;li&gt;如果它们值一样，让它们&lt;strong&gt;引用同一个 char[]&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;注意，与 String.intern() 不一样
&lt;ul&gt;
&lt;li&gt;String.intern() 关注的是&lt;strong&gt;字符串对象&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;而字符串去重关注的是 &lt;strong&gt;char[]&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在 JVM 内部，使用了不同的字符串表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;9-jdk-8u40-并发标记类卸载&#34;&gt;9) JDK 8u40 并发标记类卸载&lt;/h3&gt;
&lt;p&gt;所有对象都经过并发标记后，就能知道&lt;strong&gt;哪些类不再被使用&lt;/strong&gt;，当一个类加载器的所有类都不再使用，则&lt;strong&gt;卸载它所加载的所有类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-XX:+ClassUnloadingWithConcurrentMark&lt;/code&gt; 默认启用&lt;/p&gt;
&lt;h3 id=&#34;10-jdk-8u60-回收巨型对象&#34;&gt;10) JDK 8u60 回收巨型对象&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;42&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%9B%9E%E6%94%B6%E5%B7%A8%E5%9E%8B%E5%AF%B9%E8%B1%A1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Region 区域内粉色的 H 就是巨型对象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个对象&lt;strong&gt;大于 region 的一半&lt;/strong&gt;时，称之为巨型对象&lt;/li&gt;
&lt;li&gt;G1 &lt;strong&gt;不会对巨型对象进行拷贝&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;回收时被优先考虑&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0 的巨型对象就可以在新生代垃圾回收时处理掉&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;43&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%9B%9E%E6%94%B6%E5%B7%A8%E5%9E%8B%E5%AF%B9%E8%B1%A1_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;11-jdk-9-并发标记起始时间的调整&#34;&gt;11) JDK 9 并发标记起始时间的调整&lt;/h3&gt;
&lt;p&gt;如果垃圾回收的速度跟不上垃圾产生的速度，最终会退化为 Full GC。G1 的 Full GC 是多线程的，Full GC 的 STW 过程很长，因此要尽可能避免 Full GC 的发生。如何减少 Full GC 呢？提前让垃圾回收开始，并发标记、混合收集提前开始，就能减少 Full GC 发生的几率。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并发标记必须在堆空间占满前完成，否则退化为 FullGC&lt;/li&gt;
&lt;li&gt;JDK 9 之前需要使用 &lt;code&gt;-XX:InitiatingHeapOccupancyPercent&lt;/code&gt;：老年代在堆内存的占比，当超过设置的这个阈值时，就会触发并发垃圾回收。&lt;/li&gt;
&lt;li&gt;JDK 9 可以动态调整
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-XX:InitiatingHeapOccupancyPercent&lt;/code&gt; 用来设置&lt;strong&gt;初始值&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;进行&lt;strong&gt;数据采样&lt;/strong&gt;并&lt;strong&gt;动态调整&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;总会添加一个安全的空档空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12-jdk-9-更高效的回收&#34;&gt;12) JDK 9 更高效的回收&lt;/h3&gt;
&lt;p&gt;250+增强&lt;/p&gt;
&lt;p&gt;180+bug修复&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/en/java/javase/12/gctuning&#34;&gt;https://docs.oracle.com/en/java/javase/12/gctuning&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;五-垃圾回收调优&#34;&gt;五、垃圾回收调优&lt;/h1&gt;
&lt;p&gt;预备知识&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;掌握 GC 相关的 VM 参数，会基本的空间调整&lt;/li&gt;
&lt;li&gt;掌握相关工具&lt;/li&gt;
&lt;li&gt;明白一点：调优跟应用、环境有关，没有放之四海而皆准的法则&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查看虚拟机运行参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;C:\Program Files\Java\jdk1.8.0_172\bin\java&amp;quot; -XX:+PrintFlagsFinal -version | findstr &amp;quot;GC&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;44&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%B0%83%E4%BC%98.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;51-调优领域&#34;&gt;5.1 调优领域&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;内存&lt;/li&gt;
&lt;li&gt;锁竞争&lt;/li&gt;
&lt;li&gt;cpu 占用&lt;/li&gt;
&lt;li&gt;io&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;52-确定目标&#34;&gt;5.2 确定目标&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;【低延迟】还是【高吞吐量】，选择合适的回收器&lt;/li&gt;
&lt;li&gt;CMS，G1，ZGC：低延迟&lt;/li&gt;
&lt;li&gt;ParallelGC：高吞吐量&lt;/li&gt;
&lt;li&gt;Zing&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;53-最快的-gc-是不发生-gc&#34;&gt;5.3 最快的 GC 是不发生 GC&lt;/h2&gt;
&lt;p&gt;答案是不发生 GC&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看 FullGC 前后的内存占用，考虑下面几个问题
&lt;ul&gt;
&lt;li&gt;数据是不是太多？
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;resultSet = statement.executeQuery(&amp;quot;select * from 大表 limit n&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据表示是否太臃肿？
&lt;ul&gt;
&lt;li&gt;对象图&lt;/li&gt;
&lt;li&gt;对象大小 16 Integer 24 int 4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;是否存在内存泄漏？
&lt;ul&gt;
&lt;li&gt;static Map map 不断向里面放数据&lt;/li&gt;
&lt;li&gt;软&lt;/li&gt;
&lt;li&gt;弱&lt;/li&gt;
&lt;li&gt;第三方缓存实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;54-新生代调优&#34;&gt;5.4 新生代调优&lt;/h2&gt;
&lt;h3 id=&#34;新生代的特点&#34;&gt;新生代的特点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;所有的 new 操作的内存分配非常廉价
&lt;ul&gt;
&lt;li&gt;TLAB thread-local allocation buffer
&lt;ul&gt;
&lt;li&gt;在 Eden 中给&lt;strong&gt;每个线程分配一块私有缓冲区 TLAB&lt;/strong&gt;，new 对象时会首先检查 TLAB 缓冲区内是否有空白区域，如果有就优先在 TLAB 这块内存分配。因为线程安全问题，比如线程 1 要用这块内存，分配还没结束时，线程 2 不能也要用这块内存，造成内存分配混乱，  因此在对象的内存分配时，要做线程安全的保护，&lt;strong&gt;减少线程之间对分配时的并发冲突&lt;/strong&gt;：TLAB  ：线程局部分配缓冲区。每个线程用自己私有的 Eden 内存来进行内存分配，多个线程即使同时创建对象，也不会产生对内存占用的干扰。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;死亡对象的回收代价是零
&lt;ul&gt;
&lt;li&gt;新生代发生垃圾回收时，垃圾回收器复制算法：把 Eden、幸存区 FROM 中的幸存对象都复制到幸存区 TO，Eden、FROM 中的内存就被释放了，因此死亡对象的回收代价是零。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;新生代大部分对象用过即死&lt;/li&gt;
&lt;li&gt;Minor GC 的时间远远低于 Full GC&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;新生代越大越好吗&#34;&gt;新生代越大越好吗？&lt;/h3&gt;
&lt;p&gt;-Xmn&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery).&lt;br&gt;
GC is performed in this region more often than in other regions. If the size for the young&lt;br&gt;
generation is too small, then a lot of minor garbage collections are performed. If the size is too  large, then only full garbage collections are performed, which can take a long time to complete.&lt;br&gt;
Oracle recommends that you keep the size for the young generation greater than 25% and less than 50% of the overall heap size.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;-Xmn：设置堆中新生代的初始和最大值。&lt;strong&gt;新生代设置小&lt;/strong&gt;了，&lt;strong&gt;可用空间少&lt;/strong&gt;，创建对象时一旦发现新生代的空间不足就会触发新生代的 &lt;strong&gt;minor gc&lt;/strong&gt;。如果新&lt;strong&gt;生代内存太大&lt;/strong&gt;了，&lt;strong&gt;老年代的可用空间相对少了&lt;/strong&gt;，老年代的空间少了，将来新生代觉得我空闲空间很多，新创建的对象都还不会触发垃圾回收，但是老年代的空间紧张，再触发垃圾回收，就是 full gc，&lt;strong&gt;full gc 的暂停时间比 minor gc 时间更长&lt;/strong&gt;。&lt;strong&gt;新生代大于堆内存的 1/4 ,小于 1/2 即可&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;45&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%96%B0%E7%94%9F%E4%BB%A3-%E5%90%9E%E5%90%90%E9%87%8F.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;吞吐量&lt;/strong&gt;：单位时间能响应的请求数量。&lt;/p&gt;
&lt;p&gt;随着新生代空间越来越大，吞吐量越来越高，垃圾回收占用整个 CPU 计算的时间比例少了，CPU时间更多用来处理请求了，吞吐量就变高了，但是到了一定的大小后，会有一个下降：&lt;strong&gt;新生代空间大了，意味着回收的时间较长&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;新生代调整尽可能大&lt;/strong&gt;，新生代的垃圾回收都是复制算法，复制算法分成：标记、复制两个阶段，复制阶段花费的时间更多，而&lt;strong&gt;新生代的对象，绝大部分都是朝生夕死的，最终只有少量的对象会存活下来，复制所占用的时间也是相对较短的&lt;/strong&gt;，而标记时间相对于复制时间来讲，就显得不是很重要了，所以&lt;strong&gt;新生代调大的情况下，主要时间还是耗费在复制上，即使增得很大，效率也不会有很明显的下降&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;新生代的大小设置&#34;&gt;新生代的大小设置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;新生代能容纳并发量 *  (一次请求-响应过程产生的对象)的数据&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;并发量 * 请求 - 响应过程中所产生的的对象&lt;/li&gt;
&lt;li&gt;如果一次 请求-响应 过程中产生的对象是 512KB，并发量是 1000，那么新生代理想的内存就是 1000* 512KB = 521M。因为一次 请求-响应的过程，在这次 请求-响应 结束后，大多数对象都会被回收，只要这一次 请求-响应 占用的内存不超过新生代的内存，就不会触发新生代的垃圾回收&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;幸存区大到能保留当前活跃对象+需要晋升对象&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;幸存区中有两类对象：&lt;strong&gt;①生命周期较短，下一次垃圾回收就把它回收掉了&lt;/strong&gt;，但由于现在还在使用，暂时不能回收；&lt;strong&gt;②将来会被晋升到老年代&lt;/strong&gt;，但是由于年龄不够，所以暂时存放在幸存区中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果幸存区较小，就会由 JVM 动态调整晋升阈值&lt;/strong&gt;，也许本来有些对象不应该晋升的，但是由于幸存区内存不够，导致会提前&lt;strong&gt;把本应回收的对象晋升到老年代&lt;/strong&gt;。如果存活时间短的对象被晋升到了老年代，需要等到老年代内存不足，触发 Full GC 时才能把它当做垃圾进行回收，延长了对象的生存时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;晋升阈值配置得当，让长时间存活对象尽快晋升&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;如果是一个&lt;strong&gt;长期存活的对象&lt;/strong&gt;，把它&lt;strong&gt;留到幸存区里&lt;/strong&gt;，只会&lt;strong&gt;耗费幸存区的内存&lt;/strong&gt;，并且新生代垃圾回收都是复制算法，要把幸存区的存活对象从 FROM 复制到 TO，如果大量长时间存活的对象不能及早晋升，那么就要留在幸存区被&lt;strong&gt;复制来复制去&lt;/strong&gt;。调整晋升阈值，让&lt;strong&gt;长时间存活的对象尽快晋升到老年代&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;调整最大晋升阈值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-XX:MaxTenuringThreshold=threshold 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示幸存区对象详情：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-XX:+PrintTenuringDistribution 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Desired survivor size 48286924 bytes, new threshold 10 (max 10) 
- age 1: 28992024 bytes, 28992024 total 
- age 2: 1366864 bytes, 30358888 total 
- age 3: 1425912 bytes, 31784800 total 
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;55-老年代调优&#34;&gt;5.5 老年代调优&lt;/h2&gt;
&lt;h3 id=&#34;以-cms-为例&#34;&gt;以 CMS 为例&lt;/h3&gt;
&lt;p&gt;CMS 垃圾回收器：&lt;strong&gt;低响应时间、并发的&lt;/strong&gt;（垃圾回收线程在工作的同时其他用户线程也能在并发的执行：垃圾回收的同时其他用户线程也在运行，就会产生新的浮动垃圾，如果浮动垃圾产生导致内存不足，就会造成 CMS 并发失败，CMS 垃圾回收器退化为 串行老年代垃圾回收器：STW）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CMS 的&lt;strong&gt;老年代内存越大越好&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;预留更多空间，避免浮动垃圾引起的并发失败&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;先尝试不做调优&lt;/strong&gt;，如果没有 Full GC 那么已经可以了，否则先尝试调优新生代&lt;/li&gt;
&lt;li&gt;观察&lt;strong&gt;发生 Full GC 时老年代内存占用&lt;/strong&gt;，将老年代内存预设调大 1/4 ~ 1/3&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;-XX:CMSInitiatingOccupancyFraction=percent
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;老年代的空间占用达到老年代的 percent% 时，触发垃圾回收 percent 越小，老年代垃圾回收触发时间越早。&lt;/p&gt;
&lt;h2 id=&#34;56-案例&#34;&gt;5.6 案例&lt;/h2&gt;
&lt;h3 id=&#34;案例1-full-gc-和-minor-gc频繁空间紧张&#34;&gt;案例1 Full GC 和 Minor GC频繁：空间紧张&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;问题分析：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新生代空间紧张：当业务高峰期来了，大量对象被创建，&lt;strong&gt;新生代被填满&lt;/strong&gt;，&lt;strong&gt;幸存区空间紧张&lt;/strong&gt;了，&lt;strong&gt;晋升对象的阈值就会降低&lt;/strong&gt;，导致很多原来&lt;strong&gt;生存周期很短的对象被晋升到老年代&lt;/strong&gt;了，老年代存了大量生存周期很短的对象，进一步触发老年代 &lt;strong&gt;Full GC&lt;/strong&gt; 发生。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;问题解决：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;增大新生代内存&lt;/strong&gt;，新生代内存增大了，内存充裕，新生代的垃圾回收不那么频繁了，增大了幸存区的空间以及晋升阈值，生命周期较短的对象尽可能在幸存区被回收，而不要晋升到老年代，减少老年代 Full GC。&lt;/p&gt;
&lt;h3 id=&#34;案例2-请求高峰期发生-full-gc单次暂停时间特别长-cms&#34;&gt;案例2 请求高峰期发生 Full GC，单次暂停时间特别长 （CMS）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;问题分析：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查看日志，看 CMS 哪个阶段耗费时间长&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;46&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;初始标记和并发标记都是比较快的，&lt;strong&gt;重新标记比较慢&lt;/strong&gt;， 查看 GC 日志会把每一阶段耗费的时间显示。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;问题解决：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重新标记会扫描整个内存，不光是要扫描老年代对象，也要同时扫描新生代对象，如果是业务高峰期，新生代对象比较多，扫描标记时间就会很长，因为要根据对象找它的引用，能不能&lt;strong&gt;在重新标记前把新生代的对象做一次垃圾回收&lt;/strong&gt;，减少新生代对象的数量，减少重新标记阶段耗费的时间。通过设置：&lt;code&gt;-XX:+CMSScavengeBeforeRemark&lt;/code&gt;：在重新标记发生之前，先对新生代进行一次垃圾清理。&lt;/p&gt;
&lt;h3 id=&#34;案例3-老年代充裕情况下发生-full-gc-cms-jdk17&#34;&gt;案例3 老年代充裕情况下，发生 Full GC （CMS jdk1.7）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;问题分析：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CMS 可能由于空间不足导致并发失败，或者由于空间碎片多都会产生 Full GC。但是经过排查，在 GC 日志没有并发失败或者碎片过多的提示。说明老年代空间充裕，不是由于老年代空间不足产生的 Full GC。&lt;strong&gt;JDK1.7 及以前采用永久代作为方法区的实现，永久代空间不足也会导致 Full GC 发生&lt;/strong&gt;，1.8 以后使用元空间就不是由 Java 控制了，所以元空间使用操作系统的空间一般情况是比较充裕的。1.7 以前永久代空间设置小了就会触发整个堆的 Full GC。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;问题解决：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;增大永久代的初始值和最大值&lt;/p&gt;
">JVM 垃圾回收</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/http-xi-lie-er-shou-xi-http-xie-yi-jie-gou-he-tong-xun-yuan-li/"" data-c="
          &lt;h1 id=&#34;http-特点&#34;&gt;HTTP 特点&lt;/h1&gt;
&lt;h2 id=&#34;支持-客户服务器-模式&#34;&gt;支持 客户/服务器 模式&lt;/h2&gt;
&lt;p&gt;客户/服务器模式工作的方式是由客户端向服务器发出请求，服务器端响应请求，并进行相应服务。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/client-server.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;简单快速&#34;&gt;简单快速&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;客户向服务器请求服务时，只需传送&lt;strong&gt;请求方法和路径&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;请求方法常用的有&lt;strong&gt;GET、HEAD、POST&lt;/strong&gt;。每种方法规定了客户与服务器联系的类型不同&lt;/li&gt;
&lt;li&gt;由于HTTP协议简单，使得HTTP服务器的程序规模小，因而&lt;strong&gt;通信速度很快&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;灵活&#34;&gt;灵活&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HTTP允许传输任意类型的数据对象&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;无连接&#34;&gt;无连接&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;无连接的含义是限制&lt;strong&gt;每次连接只处理一个请求&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;服务器处理完客户的请求，并收到客户的应答后，即断开连接&lt;/li&gt;
&lt;li&gt;采用这种方式可以&lt;strong&gt;节省传输时间&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;无状态&#34;&gt;无状态&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTP协议是无状态协议&lt;/li&gt;
&lt;li&gt;无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大&lt;/li&gt;
&lt;li&gt;另一方面，在服务器不需要先前信息时它的应答就较快&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;uri-与-url&#34;&gt;URI 与 URL&lt;/h1&gt;
&lt;p&gt;Q：我们输入在浏览器里的Web地址应该叫URL还是URI？&lt;/p&gt;
&lt;p&gt;小A：我们访问的就是&lt;strong&gt;URL&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;小B：不！其实那时&lt;strong&gt;URI&lt;/strong&gt;好不好！&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/URI.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;URI：一个紧凑的字符串用来标示抽象或物理资源&lt;/li&gt;
&lt;li&gt;A URI 可以进一步被分为定位符、名字或两者都是&lt;/li&gt;
&lt;li&gt;术语&amp;quot;Uniform Resource Locator&amp;quot;（URL）是URI的子集，除了确定一个资源，还提供一种定位该资源的主要访问机制（如其网络“位置”）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;维基百科解释&#34;&gt;维基百科解释&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;URI可以分为URL，URN或同时具备locators 和names特性的一个东西&lt;/li&gt;
&lt;li&gt;URN作用就好像一个人的&lt;strong&gt;名字&lt;/strong&gt;，URL就像一个人的&lt;strong&gt;地址&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;换句话说：URN确定了东西的身份，URL提供了找到它的方式&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;一家公司的总经理有一张名片，上面写了 “北京 xxx 公司总经理张三”、办公室地址 “北京市海淀区长安街35号 xx 楼 xxx 办公室”。&lt;br&gt;
头衔：北京 xxx 公司总经理 —— 张三，建立一个映射，这个头衔就是 URI，&lt;strong&gt;只要看到一个 URI 就知道它代表什么&lt;/strong&gt;。&lt;br&gt;
&lt;a href=&#34;http://www.baidu.cn&#34;&gt;www.baidu.cn&lt;/a&gt; —— 百度网，&lt;a href=&#34;http://www.baidu.com&#34;&gt;www.baidu.com&lt;/a&gt; 就是一个 URI&lt;br&gt;
admin@qq.com —— 代表某个人的 QQ 邮箱，admin@qq.com 也是一个 URI&lt;br&gt;
&lt;strong&gt;URI 是一个网络资源的头衔&lt;/strong&gt;，是一个统称，通过 URI 可以把网络世界里的每一个事务都加以标记并且区分开来。&lt;br&gt;
“北京 xxx 公司总经理” 是一个 URI，我们知道这个头衔对应的是张三，但是我们不能去找到这个人，因为不知道他的地址，要定位到他就必须要知道他的办公室地址。反映到网络世界，网络世界中的每个资源不只有头衔，还要能够被人访问，所以网络地址也是必须的，否则这个网络资源的存在就没有任何意义了，这个&lt;strong&gt;网络地址就叫做 URL&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;URL是URI的一种，但不是所有的URI都是URL&lt;/li&gt;
&lt;li&gt;URI和URL最大的差别是“访问机制（HTTP 还是 FTP）&amp;quot;&lt;/li&gt;
&lt;li&gt;URN 是唯一标识的一部分，是身份信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;安能辨我是雌雄&#34;&gt;安能辨我是雌雄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ftp://ftp.is.co.za/rfc/rfc1808.txt
&lt;ul&gt;
&lt;li&gt;URL，提供了访问机制是 FTP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;http://www.ietf.org/rfc/rfc2396.txt
&lt;ul&gt;
&lt;li&gt;URL，提供了访问机制是 HTTP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Idap://[2001:db8::7]/c=GB?objectClass?one
&lt;ul&gt;
&lt;li&gt;URL，提供了访问机制 LDAP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;mailto:John.Doe@example.com
&lt;ul&gt;
&lt;li&gt;URL，通过邮件进行访问&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;news:comp.infosystems.www.servers.unix
&lt;ul&gt;
&lt;li&gt;URL&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;tel:+1-816-555-1212
&lt;ul&gt;
&lt;li&gt;URI：电话号码可以标识某一个人，但是没有访问机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;telnet://192.0.2.16:80/
&lt;ul&gt;
&lt;li&gt;URL，访问机制 telnet&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;urn:oasis:names:specification:docbook:dtd:xml:4.1.2
&lt;ul&gt;
&lt;li&gt;URL，地址中已经显示了 urn，没有自己的访问方式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;http-报文结构分析-请求报文&#34;&gt;HTTP 报文结构分析 - 请求报文&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;报文头和报文体中间有一行空行&lt;br&gt;
报文体内是表单的数据，不同参数之间使用 &amp;amp; 进行拼接&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;http-报文头&#34;&gt;HTTP 报文头&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTP的报文头大体可以分为四类，分别是：通用报文头、请求报文头、响应报文头和实体报文头&lt;/li&gt;
&lt;li&gt;在HTTP/1.1里一共规范了47种报文头字段&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;通用报文头&#34;&gt;通用报文头&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;首部字段名&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Cache-Control&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;控制缓存的行为&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Connection&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;逐跳首部、连接的管理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Date&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;创建报文的日期时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Pragma&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;报文指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Trailer&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;报文末端的首部一览&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Transfer-Encoding&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;指定报文主体的传输编码方式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Upgrade&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;升级为其他协议&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Via&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;代理服务器的相关信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Warning&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;错误通知&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;请求报文头&#34;&gt;请求报文头&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;首部字段名&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Accept&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用户代理可处理的媒体类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Accept-Charset&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;优先的字符集&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Accept-Encoding&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;优先的内容编码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Accept-Language&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;优先的语言（自然语言）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Authorization&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Web 认证信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Expect&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;期待服务器的特定行为&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;From&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用户的电子邮箱地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Host&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;请求资源所在服务器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;If-Match&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;比较实体标记（ETag）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;If-Modified-Since&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;比较资源的更新时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;If-None-Match&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;比较实体标记（与 If-Match 相反）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;If-Range&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;资源未更新时发送实体 Byte 的范围请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;If-Unmodified-Since&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;比较资源的更新时间（与 If-Modified-Since相反）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Max-Forwards&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;最大传输逐跳数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Proxy-Authorization&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;代理服务器要求客户端的认证信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Range&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;实体的字节范围请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Referrer&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;对请求中 URI 的原始获取方&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;TE&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;传输编码的优先级&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;User-Agent&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;HTTP 客户端程序的信息&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;响应报文头&#34;&gt;响应报文头&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;首部字段名&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Accept-Ranges&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;是否接受字节范围请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Age&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;推算资源创建经过时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ETag&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;资源的匹配信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Location&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;令客户端重定向至指定 URI&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Proxy-Authenticate&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;代理服务器对客户端的认证信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Retry-After&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;对再次发起请求的时机要求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Server&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;HTTP服务器的安装信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Vary&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;代理服务器缓存的管理信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;WWW-Authenticate&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;服务器对客户端的认证信息&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;实体报文头&#34;&gt;实体报文头&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;首部字段名&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Allow&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;资源可支持的 HTTP 方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Content-Encoding&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;实体主体使用的编码方式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Content-Language&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;实体主体的自然语言&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Content-Length&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;实体主体的大小（单位：字节）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Content-Location&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;替代对应资源的 URI&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Content-MD5&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;实体主体的报文摘要&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Content-Range&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;实体主体的位置范围&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Content-Type&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;实体主体的媒体类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Expires&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;实体主体过期的日期时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Last-Modified&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;资源的最后修改日期时间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;accept&#34;&gt;ACCEPT&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;作用：&lt;strong&gt;浏览器端可以接受的媒体类型&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Accept:&lt;strong&gt;text/html&lt;/strong&gt; 代表浏览器可以接受服务器回发的类型为 text/html 也就是我们常说的 html 文档，如果服务器无法返回 text/html 类型的数据，服务器应该返回一个406错误（Non Acceptable）&lt;/p&gt;
&lt;p&gt;如果想要给显示的媒体类型增加优先级，则使用q=来额外表示权重值）；重值 q 的范围是0~1（可精确到小数点后 3 位），且 1 为最大值。不指定权重 q 值时，默认权重为 q=1.0。当服务器提供多种内容时，将会首先返回权重值最高的媒体类型。&lt;/p&gt;
&lt;h2 id=&#34;accept-encoding&#34;&gt;Accept-Encoding&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;作用：浏览器申明自己接收的&lt;strong&gt;编码方法&lt;/strong&gt;，通常指定&lt;strong&gt;压缩&lt;/strong&gt;方法，是否支持压缩，支持什么压缩方法（gzip，deflate）
&lt;ul&gt;
&lt;li&gt;Accept-Encoding:gzip，deflate&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;作用：浏览器申明自己接收的语言
&lt;ul&gt;
&lt;li&gt;Accept-Language:zh-cn, zh; q=0.7, en-us, en; q=0.3&lt;/li&gt;
&lt;li&gt;客户端在服务器有中文版资源的情况下，会请求其返回中文版对应的响应，没有中文版时，则请求返回英文版响应&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Connection:keep-alive&lt;/strong&gt; ：当一个网页打开完成后，客户端和服务器之间&lt;strong&gt;用于传输HTTP数据的TCP连接不会关闭&lt;/strong&gt;，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。&lt;/li&gt;
&lt;li&gt;Connection:close 代表&lt;strong&gt;一个Request&lt;/strong&gt;完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭，当客户端再次发送Request，需要重新建立TCP连接&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;host&#34;&gt;Host&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;作用：请求报头域主要用于指定被请求资源的 &lt;strong&gt;Internet主机和端口号&lt;/strong&gt;，它通常从HTTP URL中提取出来的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们在浏览器中输入：http://www.fljf.com:8080 刘览器发送的请求消息中，就会包含Host请求报头域，如下：Host：www.fljf.com:8080&lt;/p&gt;
&lt;h2 id=&#34;referer&#34;&gt;Referer&lt;/h2&gt;
&lt;p&gt;当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理&lt;/p&gt;
&lt;h2 id=&#34;user-agent&#34;&gt;User-Agent&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;作用：告诉HTTP服务器，客户端使用的操作系统和浏览器的名称和版本&lt;/li&gt;
&lt;li&gt;很多情况下我们会通过User-Agnet来判断浏览器类型，从而进行不同的兼容设计&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;content-type&#34;&gt;Content-Type&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;作用：说明了报文体内对象的媒体类型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;text/html：HTML格式&lt;/p&gt;
&lt;p&gt;text/plain：纯文本格式&lt;/p&gt;
&lt;p&gt;text/xml：XML格式&lt;/p&gt;
&lt;p&gt;image/gif：gif图片格式&lt;/p&gt;
&lt;p&gt;image/jpeg：jpg图片格式&lt;/p&gt;
&lt;p&gt;image/png：png图片格式&lt;/p&gt;
&lt;p&gt;application/xhtml+xml：XHTML格式&lt;/p&gt;
&lt;p&gt;application/xml：XML数据格式&lt;/p&gt;
&lt;p&gt;application/atom+xml：Atom XML聚合格式&lt;/p&gt;
&lt;p&gt;application/json：JSON数据格式&lt;/p&gt;
&lt;p&gt;application/pdf：pdf格式&lt;/p&gt;
&lt;p&gt;application/msword：Word文档格式&lt;/p&gt;
&lt;p&gt;application/octet-stream：二进制流数据（如常见的文件下载）&lt;/p&gt;
&lt;p&gt;application/x-www-form-urlencoded：表单提交&lt;/p&gt;
&lt;h1 id=&#34;http-报文结构分析-响应报文&#34;&gt;HTTP 报文结构分析 - 响应报文&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;http-请求方法剖析&#34;&gt;HTTP 请求方法剖析&lt;/h1&gt;
&lt;p&gt;HTTP/1.1常用方法&lt;/p&gt;
&lt;p&gt;①GET&lt;/p&gt;
&lt;p&gt;② POST&lt;/p&gt;
&lt;p&gt;③ PUT&lt;/p&gt;
&lt;p&gt;④HEAD&lt;/p&gt;
&lt;p&gt;⑤ DELETE&lt;/p&gt;
&lt;p&gt;⑥OPTIONS&lt;/p&gt;
&lt;p&gt;⑦TRACE&lt;/p&gt;
&lt;p&gt;③ CONNECT&lt;/p&gt;
&lt;h2 id=&#34;get-获取资源&#34;&gt;GET 获取资源&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;GET方法用来请求访问已被URI识别的资源&lt;/li&gt;
&lt;li&gt;指定的资源经服务器端解析后返回响应内容&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/GET%E8%AF%B7%E6%B1%82.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;GET方法也可以用来提交表单和其他数据&lt;/li&gt;
&lt;li&gt;http://localhost/login.php?username=aa&amp;amp;password=1234 从上面的 URL 请求中，很容易就可以辩认出表单提交的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;post&#34;&gt;POST&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;POST 方法与 GET 功能类似，一般用来&lt;strong&gt;传输实体的主体&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;POST 方法的主要目的不是获取响应主体的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/POST%E8%AF%B7%E6%B1%82.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;说下-get-和-post-的区别&#34;&gt;说下 GET 和 POST 的区别？&lt;/h3&gt;
&lt;p&gt;GET 和 POST 本质都是 HTTP 请求，只不过对它们的作用做了界定和适配，并且让他们适应各自的场景。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本质区别：GET 只是一次 HTTP请求，POST 先发请求头再发请求体，实际上是两次请求。&lt;/li&gt;
&lt;li&gt;从功能上讲，GET 一般用来&lt;strong&gt;从服务器上获取资源&lt;/strong&gt;，POST 一般用来&lt;strong&gt;更新服务器上的资源&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;从 REST 服务角度上说，&lt;strong&gt;GET 是幂等&lt;/strong&gt;的，即读取同一个资源，总是得到相同的数据，而 &lt;strong&gt;POST 不是幂等&lt;/strong&gt;的，因为每次请求对资源的改变并不是相同的；进一步地，GET 不会改变服务器上的资源，而 POST 会对服务器资源进行改变；&lt;/li&gt;
&lt;li&gt;从请求参数形式上看，&lt;strong&gt;GET 请求的数据会附在 URL 之后&lt;/strong&gt;，即将请求数据放置在 HTTP 报文的 请求头 中，以 ? 分割 URL 和传输数据，参数之间以 &amp;amp; 相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用 BASE64 加密，得出如：%E4%BD%A0%E5%A5%BD，其中 ％XX 中的 XX 为该符号以 16 进制表示的 ASCII)；而 **POST 请求会把提交的数据则放置在是 HTTP 请求报文的 **&lt;strong&gt;请求体&lt;/strong&gt; 中；&lt;/li&gt;
&lt;li&gt;就安全性而言，&lt;strong&gt;POST 的安全性要比 GET 的安全性高&lt;/strong&gt;，因为 GET 请求提交的数据将明文出现在 URL 上，而且 POST 请求参数则被包装到请求体中，相对更安全；&lt;/li&gt;
&lt;li&gt;从请求的大小看，GET 请求的长度受限于浏览器或服务器对 URL 长度的限制，允许发送的数据量比较小，而 POST 请求则是没有大小限制的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;put&#34;&gt;PUT&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;从客户端向服务器传送的数据&lt;strong&gt;取代指定的文档的内容&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;PUT方法与POST方法最大的不同是：PUT是幂等的，而POST是不幂等的&lt;/li&gt;
&lt;li&gt;因此，我们更多时候将PUT方法用作传输资源&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;创建对象用 POST，更新对象用 PUT。&lt;br&gt;
但是，HTTP1.1 的 PUT 方法不带有验证机制，存在一定的安全问题，所以一般不使用 PUT，更新对象可以使用 POST 请求，然后在后端代码逻辑处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;headdelete&#34;&gt;HEAD/DELETE&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HEAD类似于GET请求，只不过返回的响应中没有具体的内容，用于&lt;strong&gt;获取报头&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;DELETE请求服务器删除指定的资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;DELETE 方法没有验证机制，所以一般不使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;options&#34;&gt;OPTIONS&lt;/h2&gt;
&lt;p&gt;用来查询针对请求URI指定的资源支持的方法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不知道对方支持什么方法，询问一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/OPTIONS%E8%AF%B7%E6%B1%82.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;traceconnect&#34;&gt;TRACE/CONNECT&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;TRACE：回显服务器收到的请求，主要用于测试或诊断&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;容易引发 XSP 攻击，所以一般不使用 TRACE 请求&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;CONNECT：开启一个客户端与所请求资源之间的双向沟通的通道，它可以用来创建隧道&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;代理服务器访问互联网时，就是用 CONNECT 方法。&lt;br&gt;
浏览器向代理服务器发送 CONNECT 请求，代理服务器返回状态码 200，浏览器就和服务器三次握手交换数据，代理服务器只负责传输彼此的数据包，并不能读取数据内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;状态码&#34;&gt;状态码&lt;/h1&gt;
&lt;p&gt;是用以表示网页服务器超文本传输协议响应状态的3位数字代码。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E7%8A%B6%E6%80%81%E7%A0%81.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;http-状态码详解&#34;&gt;HTTP 状态码详解&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;分类&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1XX&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;表示消息。这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;2XX&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;表示&lt;strong&gt;成功&lt;/strong&gt;。这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;3XX&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;表示&lt;strong&gt;重定向&lt;/strong&gt;。这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;4XX&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;表示&lt;strong&gt;请求错误&lt;/strong&gt;。这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;5XX&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;表示&lt;strong&gt;服务器错误&lt;/strong&gt;。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;常用http状态码&#34;&gt;常用HTTP状态码&lt;/h3&gt;
&lt;p&gt;2XX 状态码：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;状态码&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;状态码英文名称&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;200&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OK&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;请求已成功，请求所希望的响应头或数据体将随此响应返回&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;202&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Accepted&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;已接受，已经接受请求，但未处理完成&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;206&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Partial Content&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;部分内容，服务器成功处理了部分GET请求&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;3XX 状态码：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;状态码&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;状态码英文名称&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;301&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Moved Permanently&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;永久移动&lt;/strong&gt;，请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替（&lt;strong&gt;更换域名&lt;/strong&gt;）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;302&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Found&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;临时移动，与301类似。但资源只是临时被移动。客户端应继续使用原有URI&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;4XX 状态码：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;状态码&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;状态码英文名称&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;400&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Bad Request&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;客户端请求的语法错误，服务器无法理解&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;401&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Unauthorized&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;请求要求用户的身份认证&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;403&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Forbidden&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;服务器理解请求客户端的请求，但是拒绝执行此请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;404&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Not Found&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;服务器无法根据客户端的请求找到资源（网页）。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;5XX 状态码：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;状态码&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;状态码英文名称&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;500&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Internal Server Error&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;服务器内部错误，无法完成请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;502&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Bad Gateway&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;充当网关或代理的服务器，从远端服务器接收到了一个无效的请求&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;http状态管理cookie与session&#34;&gt;HTTP状态管理：Cookie与Session&lt;/h1&gt;
&lt;p&gt;HTTP 是无状态协议，每个请求都是独立的，如果后续处理需要前面的信息，必须重传，就会导致连接传送的数据量增大，于是引入 Cookie 和 Session 保存 HTTP 连接状态。&lt;/p&gt;
&lt;h2 id=&#34;cookie&#34;&gt;Cookie&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就向客户端浏览器颁发一个Cookie。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户端浏览器&lt;/strong&gt;会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/cookie.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在浏览器地址栏输入 www.baidu.com ，浏览器向百度服务器发送读取网页的请求，并且把结果显示回显示器上。&lt;br&gt;
发送之前，这个网页在本机电脑上寻找百度网站设置的 cookie 文件，如果找到，浏览器会把 cookie 文件中的数据连同 url 一同发送给百度服务器，服务器收到数据，就会在它的数据库中检索 id、搜索记录等信息，并且记录下这次新的内容，增加到数据库和 cookie 文件中。如果没有检测到 cookie，或者 cookie 信息与数据库信息不符合，说明这是第一次浏览这个网站，服务器就会创建一个新的 id，并且保存到数据库，并给浏览器下发一个 cookie，这样下一次访问就会像前面描述的那样查到 cookie 记录了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;cookie-工作原理&#34;&gt;Cookie 工作原理&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/cookie%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;1.浏览器发送请求到服务器&lt;/p&gt;
&lt;p&gt;2.如果是第一次访问这个服务器，服务器 set-cookie&lt;/p&gt;
&lt;p&gt;3.服务器通过 set-cookie 这样的一个响应头把 cookie 发送给客户端&lt;/p&gt;
&lt;p&gt;4.客户端读取到 set-cookie 之后，把 cookie 存储到本地的文本文件中&lt;/p&gt;
&lt;p&gt;5.再次发送请求，会把 cookie 一起发送到服务器端&lt;/p&gt;
&lt;p&gt;6.服务器接收到这个 cookie，检查 cookie，证明没问题，确实是我已经存在的用户了，返回响应结果。&lt;/p&gt;
&lt;h2 id=&#34;session&#34;&gt;Session&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Session是另一种记录客户状态的机制，保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上&lt;/li&gt;
&lt;li&gt;客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##Session 工作原理&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/session%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用户访问一个服务器，如果服务器启用 session，服务器就要为这个用户创建一个 session，在创建这个 session 的时候，服务器首先检查这个用户发来的请求里，是否包含一个 sessionID，如果包含了，就说明这个用户此前已经登陆过，并且已经创建过 session，就按照这个 sessionID 把 session 从服务器的内存中查找出来。如果查找不到或客户端请求就不包含这个 sessionID，就为这个客户端创建一个新的 session，并且生成一个与此 session 相关的 sessionID，这个 sessionID 在服务端是唯一的，这个 sessionID会在这一次响应中返回到客户端进行保存，保存这个 sessionID 的正是 cookie。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;保存session-id的方式&#34;&gt;保存Session ID的方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Cookie&lt;/li&gt;
&lt;li&gt;URL重写：
&lt;ul&gt;
&lt;li&gt;https://.../xxx?sessionID=BpRZx3lQx33ccEoU6QZcEb64（参数）&lt;/li&gt;
&lt;li&gt;https://.../xxx;SessionID=BpRZx3lQx33ccEoU6QZcEb64（路径附加信息）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;隐藏表单&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;session的有效期&#34;&gt;Session的有效期&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Session超时失效
&lt;ul&gt;
&lt;li&gt;服务器空间有限，设置 session 有效时间，防止更多的用户访问造成服务器内存溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;程序调用HttpSession.invalidate()
&lt;ul&gt;
&lt;li&gt;点击退出，手动调用 session 失效方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务器进程被停止&lt;/li&gt;
&lt;li&gt;Cokie 与 Session理存放位置不同
&lt;ul&gt;
&lt;li&gt;Cookie 保存在客户端&lt;/li&gt;
&lt;li&gt;Session 保存在服务端&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;安全性（隐私策略）的不同
&lt;ul&gt;
&lt;li&gt;Cookie 存储在浏览器，对客户端可见，客户端的程序可修改 Cookie 中的内容&lt;/li&gt;
&lt;li&gt;Session 存储在服务器端，对客户端来说是透明的，不存在敏感信息泄露的风险&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有效期的不同
&lt;ul&gt;
&lt;li&gt;设置 Cookie 的过期时间为很大的数字，Cookie 就可以在浏览器保存很长时间&lt;/li&gt;
&lt;li&gt;服务器端会定时清理超时的 sessionID，避免出现过大的压力&lt;/li&gt;
&lt;li&gt;session 依赖名为 sessionID 这样类似的 cookie，而 cookie 的 sessionID 过期时间默许是 -1，所以只要关闭了浏览器，也就是&lt;strong&gt;一次会话&lt;/strong&gt;结束，这个 session 就失效了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对服务器压力的不同
&lt;ul&gt;
&lt;li&gt;session 保管在服务器端，每个用户都保存一个 session，耗费大量内存。&lt;/li&gt;
&lt;li&gt;cookie 保存在客户端，不太占用服务器的资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
">HTTP 系列（二）熟悉 HTTP 协议结构和通讯原理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/leetcode876-lian-biao-de-zhong-jian-jie-dian/"" data-c="
          &lt;h2 id=&#34;问题描述&#34;&gt;问题描述&lt;/h2&gt;
&lt;p&gt;给定一个带有头结点 head 的非空单链表，返回链表的中间结点。&lt;/p&gt;
&lt;p&gt;如果有两个中间结点，则返回第二个中间结点。&lt;/p&gt;
&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：[1,2,3,4,5]&lt;br&gt;
输出：此列表中的结点 3 (序列化形式：[3,4,5])&lt;br&gt;
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。&lt;br&gt;
注意，我们返回了一个 ListNode 类型的对象 ans，这样：&lt;br&gt;
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.&lt;/p&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;p&gt;输入：[1,2,3,4,5,6]&lt;br&gt;
输出：此列表中的结点 4 (序列化形式：[4,5,6])&lt;br&gt;
由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。&lt;/p&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;p&gt;给定链表的结点数介于 1 和 100 之间。&lt;/p&gt;
&lt;h2 id=&#34;方法一遍历两次链表&#34;&gt;方法一：遍历两次链表&lt;/h2&gt;
&lt;h3 id=&#34;问题分析&#34;&gt;问题分析&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;遍历链表，记录下链表长度 length。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再遍历链表返回第 length/2 个节点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;时间复杂度：O(n)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空间复杂度：O(1)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;链表节点数为奇数个时：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;链表节点数为偶数个时：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B92.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class AlgoCasts {
  public class ListNode {
    int val;
    ListNode next;
    ListNode(int x) {
      val = x;
    }
  }
  // Time: O(n), Space: O(1)
  public ListNode getMiddleNodeTwoPass(ListNode head) {
    ListNode p = head;
    int len = 0;
    for (; p != null; p = p.next) ++len;
    p = head;
    for (int i = 0; i &amp;lt; len/2; ++i) p = p.next;
    return p;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;方法二快慢指针&#34;&gt;方法二：快慢指针&lt;/h2&gt;
&lt;h3 id=&#34;问题分析-2&#34;&gt;问题分析&lt;/h3&gt;
&lt;p&gt;快指针一次走两步，慢指针一次走一步，&lt;strong&gt;当快指针遍历完链表时，慢指针正好指向中间节点&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;复杂度分析-2&#34;&gt;复杂度分析&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;时间复杂度：O(n)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空间复杂度：O(1)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;while(fast != nul &amp;amp;&amp;amp; fast.next != null){
  fast = fast.next.next; // 快指针移动两步
  slow = slow.next; // 慢指针移动一步
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;链表节点数为奇数个时：&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9_%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%881.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;链表节点数为偶数个时：&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9_%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%882.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码-2&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class AlgoCasts {
  public class ListNode {
    int val;
    ListNode next;
    ListNode(int x) {
      val = x;
    }
  }
  // Time: O(n), Space: O(1)
  public ListNode getMiddleNodeOnePass(ListNode head) {
    ListNode fast = head, slow = head;
    while (fast != null &amp;amp;&amp;amp; fast.next != null) {
      fast = fast.next.next;
      slow = slow.next;
    }
    return slow;
  }
}
&lt;/code&gt;&lt;/pre&gt;
">leetcode876. 链表的中间结点</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/httpyi-liao-jie-http-xie-yi/"" data-c="
          &lt;h1 id=&#34;浏览器背后的故事&#34;&gt;浏览器背后的故事&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%85%E4%BA%8B.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;在浏览器地址栏&lt;strong&gt;输入域名&lt;/strong&gt;想要访问某个网站，但是真正标识服务器的而是 IP 地址。&lt;/li&gt;
&lt;li&gt;根据域名到 &lt;strong&gt;DNS 服务器中查询目标服务器对应的 IP 地址&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;浏览器根据查询到的 IP 地址&lt;strong&gt;与 WEB 服务器进行通信&lt;/strong&gt;，通信的协议就是 HTTP 协议。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;把这个过程类比为电话通信的过程。如果我们想要给某个人打电话。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从通讯录翻到这个人的名字（域名）&lt;/li&gt;
&lt;li&gt;实际拨打过去的电话号（IP 地址）&lt;br&gt;
我们很容易记住姓名，但很难记住每个人的电话号。&lt;/li&gt;
&lt;li&gt;打通电话后需要进行对话，就需要两个人使用共同的语言（HTTP 协议）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;WEB 服务器收到请求，到后端进行执行，将执行结果以&lt;strong&gt;响应报文&lt;/strong&gt;的形式回传到浏览器，如果直接将响应报文展示出来，是一串串代码，普通人难以理解。&lt;/li&gt;
&lt;li&gt;浏览器对响应报文进行&lt;strong&gt;渲染&lt;/strong&gt;，使用 HTML 描述对应数据，把网页资源的源代码转换为图像结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;http&#34;&gt;HTTP&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;超文本传输协议（HTTP）是一种&lt;strong&gt;通信协议&lt;/strong&gt;，它允许将超文本标记语言（HTML）文档从Web服务器传送到客户端的浏览器。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;超文本传输协议：传输超文本（HTML）的协议。在服务端和客户端传输 HTML 要遵守的&lt;strong&gt;规则&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;HTTP是一个属于&lt;strong&gt;应用层的面向对象的协议&lt;/strong&gt;，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;web-与-http&#34;&gt;WEB 与 HTTP&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;WEB是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式&lt;strong&gt;图形信息系统&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;建立在Internet上的一种&lt;strong&gt;网络服务&lt;/strong&gt;，为浏览者在Internet上查找和浏览信息提供了图形化的、易于访问的直观界面，其中的文档及超级链接将Internet上的信息节点组织成一个互为关联的网状结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;http-协议的前世今生&#34;&gt;HTTP 协议的前世今生&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;透过-tcpip-看-http&#34;&gt;透过 TCP/IP 看 HTTP&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;HTTP协议是构建在 &lt;strong&gt;TCP/IP&lt;/strong&gt; 协议之上的，是TCP/IP协议的一个子集&lt;/li&gt;
&lt;li&gt;为了更好的理解HTTP协议，我们先了解一下TCP/IP的相关知识。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tcpip协议族&#34;&gt;TCP/IP协议族&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;TCP/IP 协议其实是一系列与互联网相关联的协议集合起来的总称&lt;/li&gt;
&lt;li&gt;分层管理是 TCP/IP 协议的重要特征&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tcpip协议族分层&#34;&gt;TCP/IP协议族分层&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;TCP/IP协议族是由一个四层协议组成的系统，这四层分别为：和数据链路层、网络层、运输层、应用层&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%9B%9B%E5%B1%82%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;应用层&#34;&gt;应用层&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;应用层一般是我们编写的应用程序，决定了向用户提供的应用服务。应用层可以通过系统调用与传输层进行通信。&lt;/li&gt;
&lt;li&gt;如：&lt;strong&gt;FTP、DNS、HTTP&lt;/strong&gt;等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;传输层&#34;&gt;传输层&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;传输层通过系统调用向应用层提供处于网络连接中的两台计算机之间的数据传输功能。&lt;/li&gt;
&lt;li&gt;在传输层有两个性质不同的协议：**TCP **和 &lt;strong&gt;UDP&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;网络层&#34;&gt;网络层&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;网络层用来处理在网络上流动的数据包，数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（&lt;strong&gt;传输路线&lt;/strong&gt;）到达对方计算机，并把数据包传输给对方。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;链路层&#34;&gt;链路层&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;链路层用来处理连接网络的&lt;strong&gt;硬件&lt;/strong&gt;部分，包括控制操作系统、硬件设备驱动、NIC（Network Interface Card，网络适配器）以及光纤等物理可见部分。硬件上的范畴均在链路层的作用范围之内。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据包的封装过程&#34;&gt;数据包的封装过程&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%B0%81%E8%A3%85%E7%9A%84%E8%BF%87%E7%A8%8B.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;http-数据传输过程&#34;&gt;HTTP 数据传输过程&lt;/h2&gt;
&lt;p&gt;发送端发送数据时，数据会从上层传输到下层，且每经过一层都会被打上该层的头部信息。而接收端接收数据时，数据会从下层传输到上层，传输前会把下层的头部信息删除&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/HTTP%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;发送端从应用层向下走，接收端从链路层向上走。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为发送端的客户端，在&lt;strong&gt;应用层&lt;/strong&gt;，通过 HTTP 协议发出一个请求，&lt;/li&gt;
&lt;li&gt;为了传输方便，在&lt;strong&gt;传输层&lt;/strong&gt;，通过 TCP 协议把应用层收到的数据（HTTP 请求报文）进行分割并且在各个报文上打上标记序号、端口号等信息，发送到网络层&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;网络层&lt;/strong&gt;，通过 IP 协议，增加作为目的地的 MAC 地址，转发给链路层。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;链路层&lt;/strong&gt;添加帧头、帧尾后，通过电信号传输给接收端。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;接收端&lt;/strong&gt;的服务器在链路层接收到请求的数据，按顺序向上层发送，一直发送到应用层。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;传输层-tcp-三次握手&#34;&gt;传输层 —— TCP 三次握手&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;使用TCP协议进行通信的双方必须先建立连接，然后才能开始传输数据。为了确保连接双方可靠性，在双方建立连接时，TCP协议采用了三次握手策略。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第一次握手&lt;/strong&gt;：客户端发送带有 SYN 标志的连接请求报文段，然后进入SYN_SEND状态，等待服务端的确认。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;客户端：客户端发送能力正常&lt;br&gt;
服务端：客户端发送能力正常、服务端接收能力正常&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第二次握手&lt;/strong&gt;：服务端接收到客户端的 SYN 报文段后，需要发送 ACK 信息对这个 SYN 报文段进行确认。同时，还要发送自己的 SYN 请求信息。服务端会将上述的信息放到一个报文段（SYN+ACK报文段）中，一并发送给客户端，此时服务端将会进入SYN_RECV状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;客户端：客户端发送能力正常、服务端接收能力正常、客户端接收能力正常、服务端发送能力正常&lt;br&gt;
服务端：客户端发送能力正常、服务端接收能力正常&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第三次握手&lt;/strong&gt;：客户端接收到服务端的 SYN+ACK 报文段后，会向服务端发送 ACK 确认报文段，这个报文段发送完毕后，客户端和服务端都进入 ESTABLISHED 状态，完成 TCP 三次握手。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;客户端：客户端发送能力正常、服务端接收能力正常、客户端接收能力正常、服务端发送能力正常&lt;br&gt;
服务端：客户端发送能力正常、服务端接收能力正常、客户端端接收能力正常、服务端发送能力正常&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;三次握手结束后，发送、接收双方都确认了彼此的发送和接收能力都正常。&lt;/p&gt;
&lt;h3 id=&#34;为什么两次握手不可以&#34;&gt;为什么两次握手不可以？&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8D%E5%8F%AF%E4%BB%A5.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;为了防止已经失效的连接请求报文段突然又传送到了 B，因而产生错误。比如下面这种情况：A 发出的第一个连接请求报文段并没有丢失，而是在网路结点长时间滞留了，以致于延误到连接释放以后的某个时间段才到达 B。本来这是一个早已失效的报文段。但是 B 收到此失效的链接请求报文段后，就&lt;strong&gt;误认为 A 又发出一次新的连接请求&lt;/strong&gt;。于是就向 A 发出确认报文段，同意建立连接。&lt;/p&gt;
&lt;p&gt;对于上面这种情况，如果不进行第三次握手，&lt;strong&gt;B 发出确认后就认为新的运输连接已经建立了&lt;/strong&gt;，并一直等待 A 发来数据。B 的许多资源就这样白白浪费了。&lt;/p&gt;
&lt;p&gt;如果采用了三次握手，由于 A 实际上并没有发出建立连接请求，所以不会理睬 B 的确认，也不会向 B 发送数据。B 由于收不到确认，就知道 A 并没有要求建立连接。&lt;/p&gt;
&lt;h1 id=&#34;dns-域名解析&#34;&gt;DNS 域名解析&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;已经介绍了与HTTP协议有着密切关系的TCP/IP协议，接下来介绍的DNS服务也是与HTTP协议有着密不可分的关系。&lt;/li&gt;
&lt;li&gt;通常我们访问一个网站，使用的是主机名或者域名来进行访问的。因为相对于IP地址（一组纯数字），域名更容易让人记住。 但TCP/IP协议使用的是IP地址进行访问的，所以必须有个机制或服务把域名转换成IP地址。&lt;strong&gt;DNS&lt;/strong&gt;服务就是用来解决这个问题的，它提供&lt;strong&gt;域名到IP地址之间的解析&lt;/strong&gt;服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;DNS 服务解析是有层次的，就近原则。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本地电脑会将经常使用的域名和 IP 地址建立映射关系并且保存到&lt;strong&gt;系统文件&lt;/strong&gt;中，在进行 DNS 解析时，系统会优先从 &lt;strong&gt;hosts 文件&lt;/strong&gt;去寻找对应的 IP 地址，如果找到，直接使用 hosts 文件中的 IP 地址。&lt;/li&gt;
&lt;li&gt;如果本地 hosts 文件没有找到该域名对应的 IP 地址的映射，向&lt;strong&gt;本地 DNS 服务器&lt;/strong&gt;发送请求，查询域名对应的 IP 地址，本地域名服务器找到对应的 IP 地址，响应给浏览器。本地 DNS 服务有限，如果没有找到，依次向上层 DNS 服务器发起请求，&lt;/li&gt;
&lt;li&gt;直到 &lt;strong&gt;DNS 根服务器&lt;/strong&gt;，如果找到则返回。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dns-解析过程&#34;&gt;DNS 解析过程&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;回溯-http-事务处理过程&#34;&gt;回溯 HTTP 事务处理过程&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/HTTP%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;当客户端访问Web站点时，首先会通过DNS服务查询到域名的IP地址。然后浏览器生成HTTP请求，并通过TCP/IP协议发送给Web服务器。Web服务器接收到请求后会根据请求生成响应内容，并通过TCP/IP协议返回给客户端。&lt;/p&gt;
&lt;h2 id=&#34;http-事务处理完整过程&#34;&gt;HTTP 事务处理完整过程&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/HTTP%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;如果使用客户端浏览器浏览页面，需要从中分解出协议名、主机名、端口、对象路径等，得到协议是 HTTP 协议、主机是 mooc.com 主机、端口是 80 端口、路径是 mooc 的根节点。在这一步需要通过 DNS 服务器解析出它的 &lt;strong&gt;IP 地址&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;封装 HTTP 请求的数据包&lt;/strong&gt;，把以上部分结合自己的本机信息封装成一个 HTTP 请求的数据包。&lt;/li&gt;
&lt;li&gt;数据报向下封装成 &lt;strong&gt;TCP 包&lt;/strong&gt;，&lt;strong&gt;三次握手建立 TCP 连接&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;客户端&lt;strong&gt;发送请求&lt;/strong&gt;给服务器&lt;/li&gt;
&lt;li&gt;服务器进行&lt;strong&gt;响应&lt;/strong&gt;，消息体有状态码、版本号&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;释放 TCP 连接&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;实验&#34;&gt;实验&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;现在，我们已经了解了HTTP协议的基本概念，也知道了我们是如何从浏览器访问到我们想要的网站资源的。&lt;/li&gt;
&lt;li&gt;那么对于浏览器来说，HTTP请求到底是什么样子的呢？让我们一起来跟踪查看一下！&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;环境搭建&#34;&gt;环境搭建&lt;/h2&gt;
&lt;p&gt;下载抓包工具：&lt;a href=&#34;https://www.wireshark.org/&#34;&gt;https://www.wireshark.org/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;实验过程&#34;&gt;实验过程&lt;/h2&gt;
&lt;p&gt;1.因为连接的是 WIFI，所以选择 WLAN，如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/wireshark%E9%80%89%E6%8B%A9WLAN.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;2.浏览器栏输入域名 &lt;a href=&#34;http://www.baidu.com&#34;&gt;www.baidu.com&lt;/a&gt;（HTTPS协议）&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.jszg.edu.cn/portal/home/index&#34;&gt;http://www.jszg.edu.cn/portal/home/index&lt;/a&gt;（HTTP协议）&lt;/p&gt;
&lt;p&gt;3.Wireshark 点击停止&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/wireshark%E5%81%9C%E6%AD%A2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;4.分析处理过程&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/wrieshark%E5%88%86%E6%9E%90%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">HTTP系列（一）了解 HTTP 协议</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/mysql-suo-yin-xiang-jie/"" data-c="
          &lt;h2 id=&#34;存储引擎&#34;&gt;存储引擎&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;InnoDB&lt;/code&gt;：不加任何条件 &lt;code&gt;select&lt;/code&gt; 出来的数据是排好序的（按主键字段排序）——聚簇索引。&lt;code&gt;MySQL&lt;/code&gt;默认的存储引擎是 &lt;code&gt;InnoDB&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MyISAM&lt;/code&gt;：不加任何条件 &lt;code&gt;select&lt;/code&gt; 出来的数据是没有排序的（按照插入顺序输出）——堆表&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;code&gt;MyISAM&lt;/code&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;code&gt;InnoDB&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;锁级别&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只有&lt;strong&gt;表级锁&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;支持&lt;strong&gt;行级锁和表级锁&lt;/strong&gt;，默认为行级锁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;查询性能&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;强调的是性能，每次查询具有原子性，执行速度快&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;使用了聚簇索引、或需要访问的数据可以放入内存的应用下速度快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;是否支持事务&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;不支持&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;是否支持崩溃后的安全恢复&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;不支持&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;支持。事务、回滚、崩溃修复能力和事务安全型表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是否支持外键&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;不支持&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是否支持 &lt;code&gt;MVCC&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;不支持&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;支持。应对高并发事务，&lt;code&gt;MVCC&lt;/code&gt;比单纯的加锁更高效。&lt;code&gt;MVCC&lt;/code&gt;只在&lt;code&gt;READ COMMITTED&lt;/code&gt; 和 &lt;code&gt;REPEATABLE READ&lt;/code&gt; 两个隔离级别下工作；&lt;code&gt;MVCC&lt;/code&gt; 可以使用乐观锁和悲观锁来实现。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;其他功能&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;全文索引、压缩、空间函数&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;索引的分类&#34;&gt;索引的分类&lt;/h2&gt;
&lt;h3 id=&#34;哈希索引&#34;&gt;哈希索引&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Hash索引底层的数据结构是&lt;strong&gt;哈希表&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;Hash 索引仅仅能满足 &amp;quot;=&amp;quot;、&amp;quot;IN&amp;quot; 的&lt;strong&gt;等值查询&lt;/strong&gt;，不能使用范围查询。&lt;/li&gt;
&lt;li&gt;Hash 索引不能利用组合索引的&lt;strong&gt;部分索引键&lt;/strong&gt;查询。&lt;/li&gt;
&lt;li&gt;Hash 索引遇到大量 Hash 值相等的情况后会发生&lt;strong&gt;碰撞&lt;/strong&gt;，性能不一定会比 B+树 高。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;b树-索引&#34;&gt;B+树 索引&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;B+树 索引底层的数据结构是 &lt;strong&gt;B+树&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;B+树 索引支持&lt;strong&gt;范围查询&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;B+树 索引可以使用组合索引的&lt;strong&gt;部分索引&lt;/strong&gt;键查询。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;innodb-的-b树聚簇索引&#34;&gt;&lt;code&gt;InnoDB&lt;/code&gt; 的 B+树：聚簇索引&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;InnoDB&lt;/code&gt; 中索引即数据，也就是聚簇索引的B+树的叶子节点中包含完整的数据记录。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;InnoDB&lt;/code&gt; 的 B+Tree 索引分为主索引和辅助索引。&lt;/p&gt;
&lt;p&gt;主索引的叶子节点 data 域记录着&lt;strong&gt;完整的数据记录&lt;/strong&gt;，这种索引方式被称为&lt;strong&gt;聚簇索引&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;辅助索引的叶子节点的 data 域记录着&lt;strong&gt;主键的值&lt;/strong&gt;，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。&lt;/p&gt;
&lt;h5 id=&#34;聚簇索引&#34;&gt;聚簇索引&lt;/h5&gt;
&lt;p&gt;聚簇索引的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;按&lt;strong&gt;主键值的大小&lt;/strong&gt;进行记录和页的排序：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据页(叶子节点)里的记录是按照主键值从小到大排序的一个单向链表。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据页(叶子节点)之间也是是按照主键值从小到大排序的一个双向链表。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;B+树中同一个层的页目录也是按照主键值从小到大排序的一个双向链表。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;B+树的&lt;strong&gt;叶子节点&lt;/strong&gt;存储的是完整的用户记录，就是指这个记录中&lt;strong&gt;存储了所有列的值&lt;/strong&gt;（包括隐藏列）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具有这两种特性的B+树称为&lt;strong&gt;聚簇索引&lt;/strong&gt;，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在&lt;code&gt;MySQL&lt;/code&gt;语句中显式的使用&lt;code&gt;INDEX&lt;/code&gt;语句去创建。&lt;code&gt;InnoDB&lt;/code&gt;存储引擎会自动的为我们创建聚簇索引。在&lt;code&gt;InnoDB&lt;/code&gt;存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的&lt;strong&gt;索引即数据&lt;/strong&gt;，数据即索引。&lt;/p&gt;
&lt;h4 id=&#34;myisam-的-b树非聚簇索引&#34;&gt;&lt;code&gt;MyISAM&lt;/code&gt; 的 B+树：非聚簇索引&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;InnoDB&lt;/code&gt; 中索引即数据，也就是聚簇索引的那棵B+树的叶子节点中已经把所有完整的用户记录都包含了，而&lt;code&gt;MyISAM&lt;/code&gt; 的索引方案虽然也使用树形结构，但是却将&lt;strong&gt;索引和数据分开存储&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将表中的记录按照记录的&lt;strong&gt;插入顺序&lt;/strong&gt;单独存储在一个文件中，称之为数据文件。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。我们可以通过&lt;strong&gt;行号&lt;/strong&gt;而快速访问到一条记录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;code&gt;MyISAM&lt;/code&gt; 存储引擎的表会把索引信息另外存储到一个称为&lt;strong&gt;索引文件&lt;/strong&gt;的另一个文件中。&lt;code&gt;MyISAM&lt;/code&gt;会单独为表的主键创建一个索引，只不过在索引的&lt;strong&gt;叶子节点&lt;/strong&gt;中存储的不是完整的用户记录，而是&lt;strong&gt;主键值+行号&lt;/strong&gt;的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录！这一点和&lt;code&gt;InnoDB&lt;/code&gt;是完全不相同的，在&lt;code&gt;lnnoDB&lt;/code&gt;存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在&lt;code&gt;MyISAM&lt;/code&gt;中却需要进行一次回表操作，意味着&lt;code&gt;MyISAM&lt;/code&gt;中建立的索引相当于全部都是二级索引！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果有需要的话，我们也可以对其它的列分别建立索引或者建立联合索引，原理和&lt;code&gt;InnoDB&lt;/code&gt;中的索引差不多，不过在叶子节点处存储的是相应的&lt;strong&gt;列+行号&lt;/strong&gt;。这些索引也全部都是二级索引。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么不自动为每个列都建立个索引呢？&lt;/p&gt;
&lt;p&gt;① 当对表中的数据进行增加、删除和修改的时候，索引也要&lt;strong&gt;动态的维护&lt;/strong&gt;，这样就降低了数据的维护速度。&lt;/p&gt;
&lt;p&gt;② 索引需要占&lt;strong&gt;物理空间&lt;/strong&gt;，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。&lt;/p&gt;
&lt;p&gt;③ 创建索引和维护索引要&lt;strong&gt;耗费时间&lt;/strong&gt;，这种时间随着数据量的增加而增加。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;二级索引辅助索引&#34;&gt;二级索引（辅助索引）&lt;/h3&gt;
&lt;p&gt;聚簇索引只能在搜索条件是主键值时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。当我们想以别的列作为搜索条件时我们可以多建几棵B+树，不同的B+树中的数据采用不同的排序规则。&lt;/p&gt;
&lt;p&gt;二级索引与聚簇索引有几处不同：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;按&lt;strong&gt;指定的索引列的值&lt;/strong&gt;来进行排序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;叶子节点&lt;/strong&gt;存储的不是完整的用户记录，而只是&lt;strong&gt;索引列+主键&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目录项记录中不是主键+页号，变成了&lt;strong&gt;索引列+页号&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在对二级索引进行查找数据时，需要根据主键值去聚簇索引中再查找一遍完整的用户记录，这个过程叫做 &lt;strong&gt;回表&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;联合索引&#34;&gt;联合索引&lt;/h3&gt;
&lt;p&gt;以多个列的大小为排序规则建立的 B+树 称为联合索引，本质上也是一个二级索引。&lt;/p&gt;
&lt;h2 id=&#34;覆盖索引&#34;&gt;覆盖索引&lt;/h2&gt;
&lt;h3 id=&#34;什么是覆盖索引&#34;&gt;什么是覆盖索引&lt;/h3&gt;
&lt;p&gt;如果&lt;strong&gt;一个索引包含（或者说覆盖）所有需要查询的字段的值&lt;/strong&gt;，我们就称之为“覆盖索引”。我们知道在&lt;code&gt;InnoDB&lt;/code&gt;存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！&lt;/p&gt;
&lt;h3 id=&#34;覆盖索引使用实例&#34;&gt;覆盖索引使用实例&lt;/h3&gt;
&lt;p&gt;现在我创建了索引(username,age)，在查询数据的时候：&lt;code&gt;select username , age from user where username = &#39;Java&#39; and age = 22&lt;/code&gt;。要查询出的列在叶子节点都存在！所以，就不用回表。&lt;/p&gt;
&lt;h2 id=&#34;目录项记录的唯一性&#34;&gt;目录项记录的唯一性&lt;/h2&gt;
&lt;p&gt;我们需要保证在 B+树 的同一层内节点的目录项记录除页号这个字段以外是唯一的。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;索引列的值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主键值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;页号&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;b树的索引总结&#34;&gt;B+树的索引总结&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;每个索引都对应一棵&lt;strong&gt;B+树&lt;/strong&gt;。用户记录都存储在 B+树 的叶子节点，所有目录记录都存储在非叶子节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;InnoDB&lt;/code&gt;存储引擎会自动为&lt;strong&gt;主键&lt;/strong&gt;（如果没有它会自动帮我们添加）建立&lt;strong&gt;聚簇索引&lt;/strong&gt;，聚簇索引的叶子节点包含完整的用户记录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以为指定的列建立二级索引，二级索引的叶子节点包含的用户记录由&lt;strong&gt;索引列 + 主键&lt;/strong&gt;组成，所以如果想通过二级索引来查找完整的用户记录的话，需要通过&lt;strong&gt;回表&lt;/strong&gt;操作，也就是在通过二级索引找到主键值之后再到聚簇索引中查找完整的用户记录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;B+树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是联合索引的话，则页面和记录先按照联合索引前边的列排序，如果该列值相同，再按照联合索引后边的列排序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过索引查找记录是从 B+树 的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了页目录，所以在这些页面中的查找非常快。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;表：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;create table t1(
  a int primary key, 
  b int,
  c int,
  d int, 
  e varchar(20)
)engine=InnoDB;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;表记录：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%A1%A8%E8%AE%B0%E5%BD%95.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;创建索引：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;create index idx_t1_bcd on t1(b,c,d);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B4%A2%E5%BC%95.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;自行创建索引&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;主键索引&lt;/p&gt;
&lt;h2 id=&#34;索引的代价&#34;&gt;索引的代价&lt;/h2&gt;
&lt;h3 id=&#34;空间上的代价&#34;&gt;空间上的代价&lt;/h3&gt;
&lt;p&gt;每建立一个索引都为要它建立一棵 B+树，每一棵 &lt;strong&gt;B+树 的每一个节点都是一个数据页&lt;/strong&gt;，一个页默认会占用 &lt;strong&gt;16KB&lt;/strong&gt; 的存储空间，一棵很大的 B+树 由许多数据页组成，那是很大的一片存储空间。&lt;/p&gt;
&lt;h3 id=&#34;时间上的代价&#34;&gt;时间上的代价&lt;/h3&gt;
&lt;p&gt;每次对表中的数据进行增、删、改操作时，都需要去修改各个 B+树 索引。而且我们讲过，B+树 每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收啥的操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的 B+树 都要进行相关的维护操作。&lt;/p&gt;
&lt;h2 id=&#34;b树索引实战&#34;&gt;B+树索引实战&lt;/h2&gt;
&lt;h3 id=&#34;全值匹配&#34;&gt;全值匹配&lt;/h3&gt;
&lt;p&gt;如果我们的搜索条件中的列和索引列一致的话，这种情况就称为全值匹配，比方说下边这个查找语句：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from t1 where b=1 and c=1 and d=1；
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;MySQL&lt;/code&gt;中有查询优化器，会分析这些搜索条件并且按照可以使用的索引中列的顺序来决定先使用哪个搜索条件。&lt;/p&gt;
&lt;h3 id=&#34;匹配左边的列&#34;&gt;匹配左边的列&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from t1 where b=1；
select * from t1 where b=1 and c=1；
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面这个&lt;code&gt;sql&lt;/code&gt;是用不到索引的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from t1 where c = 1；
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为 B+树 的数据页和记录先是按照 b 列的值排序的，在 b 列的值相同的情况下才使用 c 列进行排序，也就是说 b 列的值不同的记录中 c 的值可能是无序的。而现在你跳过 b 列直接根据 c 的值去查找，这是做不到的。&lt;/p&gt;
&lt;h3 id=&#34;匹配列前缀&#34;&gt;&lt;strong&gt;匹配列前缀&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;但是需要注意的是，如果只给出后缀或者中间的某个字符串，比如这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from t1 where b like &#39;&#39;%101%&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MySQL 就无法快速定位记录位置了，所以只能全表扫描了。有时候我们有一些匹配某些字符串后缀的需求，比方说某个表有一个url列，该列中存储了许多url：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;www.baidu.com 

www.google.com 

www.qq.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假设已经对该 url 列创建了索引，如果我们想查询以 com 为后缀的网址的话可以这样写查询条件：WHERE url LIKE &#39;%com&#39;，但是这样的话无法使用该 url 列的索引。为了在查询时用到这个索引而不至于全表扫描，我们可以把后缀查询改写成前缀查询，不过我们就得把表中的数据全部逆序存储一下，也就是说我们可以这样保存 url 列中的数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;moc.udiab.www 

moc.e1goog.www

moc.qq.www
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样再查找以com为后缀的网址时搜索条件便可以这么写：WHERE url LIKE &#39;moc%&#39;，这样就可以用到索引了。&lt;/p&gt;
&lt;h3 id=&#34;匹配范围值&#34;&gt;匹配范围值&lt;/h3&gt;
&lt;p&gt;查询方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;辅助索引查询成本+回表成本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全表扫描成本&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有记录都是按照索引列的值从小到大的顺序排好序的，所以这极大的方便我们查找索引列的值在某个范围内的记录。比方说下边这个查询语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from t1 where b &amp;gt; 1 and b &amp;lt; 2000;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于B+树中的数据页和记录是先按 b 列排序的，所以我们上边的查询过程其实是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;找到 b 值为 1 的记录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找到 b 值为 20000 的记录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于所有记录都是由链表连起来的（记录之间用单链表，数据页之间用双链表），所以他们之间的记录都可以很容易的取出来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找到这些记录的主键值，再到聚簇索引中回表查找完整的记录。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不过在使用联合进行范围查找的时候需要注意，如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到 B+树 索引，比方说这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from t1 where b &amp;gt; 1 and c &amp;gt; 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上边这个查询可以分成两个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;通过条件 b&amp;gt;1 来对 b 进行范围查找，查找的结果可能有多条 b 值不同的记录，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对这些 b 值不同的记录继续通过 c&amp;gt;1 继续过滤。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样子对于联合索引来说，只能用到 b 列的部分，而用不到 c 列的部分，因为只有 b 值相同的情况下才能用 c 列的值进行排序（select * from t1 where b = 1 and c &amp;gt;1），而这个查询中通过 b 进行范围查找的记录中可能并不是按照 c 列进行排序的，所以在搜索条件中继续以 c 列进行查找时是用不到这个B+树索引的。&lt;/p&gt;
&lt;h3 id=&#34;精确匹配某一列并范围匹配另外一列&#34;&gt;精确匹配某一列并范围匹配另外一列&lt;/h3&gt;
&lt;p&gt;对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找，比方说这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from t1 where b=1 and c&amp;gt;1；
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;排序&#34;&gt;排序&lt;/h3&gt;
&lt;p&gt;我们在写查询语句的时候经常需要对查询出来的记录通过 ORDER BY 子句按照某种规则进行排序。一般情况下，我们只能把记录都加载到内存中，再用一些排序算法，比如快速排序、归并排序等等在内存中对这些记录进行排序，有的时候可能查询的结果集太大以至于不能在内存中进行排序的话，还可能暂时借助磁盘的空间来存放中间结果，排序操作完成后再把排好序的结果集返回到客户端。在MySQL中，把这种在内存中或者磁盘上进行排序的方式统称为&lt;strong&gt;文件排序&lt;/strong&gt;（英文名：filesort），这些排序操作非常慢。但是如果 ORDER BY 子句里使用到了我们的索引列，就有可能省去在内存或文件中排序的步骤，比如下边这个简单的查询语句：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from t1 order by b，c，d
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个查询的结果集需要先按照 b 值排序，如果记录的 b 值相同，则需要按照 c 来排序，如果 c 的值相同，则需要按照 d 排序。因为这个 B+ 树索引本身就是按照上述规则排好序的，所以直接从索引中提取数据，然后进行回表操作取出该索引中不包含的列就好了。&lt;/p&gt;
&lt;h3 id=&#34;分组&#34;&gt;分组&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select b，c，d，count（*）from t1 group by b，c，d；
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个查询语句相当于做了3次分组操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;先把记录按照b值进行分组，所有 b 值相同的记录划分为一组。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将每个 b 值相同的分组里的记录再按照 c 的值进行分组，将 title 值相同的记录放到一个小分组里，所以看起来就像在一个大分组里又化分了好多小分组。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再将上一步中产生的小分组按照 d 的值分成更小的分组，所以整体上看起来就像是先把记录分成一个大分组，然后把大分组分成若干个小分组，然后把若干个小分组再细分成更多的小小分组。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然后针对那些小小分组进行统计，比如在我们这个查询语句中就是统计每个小小分组包含的记录条数。如果没有索引的话，这个分组过程全部需要在内存里实现，而如果有了索引的话，恰巧这个分组顺序又和我们的 B+树 中的索引列的顺序是一致的，而我们的 B+树 索引又是按照索引列排好序的，所以可以直接使用 B+树 索引进行分组。&lt;/p&gt;
&lt;p&gt;和使用 B+树 索引进行排序是一个道理，分组列的顺序也需要和索引列的顺序一致，也可以只使用索引列中左边的列进行分组。&lt;/p&gt;
&lt;h3 id=&#34;使用联合索引进行排序或分组的注意事项&#34;&gt;使用联合索引进行排序或分组的注意事项&lt;/h3&gt;
&lt;p&gt;对于联合索引有个问题需要注意，ORDER BY 的子句后边的列的顺序也必须按照索引列的顺序给出，如果给出 order by c，b 的顺序，那也是用不了 B+树 索引的。&lt;/p&gt;
&lt;p&gt;同理，order by b，order by b，c 这种匹配索引左边的列的形式可以使用部分的 B+树 索引。当联合索引左边列的值为常量，也可以使用后边的列进行排序，比如这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from t1 where b=1 order by c，d；
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个查询能使用联合索引进行排序是因为 b 列的值相同的记录是按照 c，d 排序的。&lt;/p&gt;
&lt;h3 id=&#34;不可以使用索引进行排序或分组的几种情况&#34;&gt;不可以使用索引进行排序或分组的几种情况&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ASC&lt;/code&gt;、&lt;code&gt;DESC&lt;/code&gt;混用&lt;/p&gt;
&lt;p&gt;对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是 &lt;code&gt;ASC&lt;/code&gt; 规则排序，要么都是 &lt;code&gt;DESC&lt;/code&gt; 规则排序。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ORDER BY 子句后的列如果不加 &lt;code&gt;ASC&lt;/code&gt; 或者 &lt;code&gt;DESC&lt;/code&gt; 默认是按照 &lt;code&gt;ASC&lt;/code&gt; 排序规则排序的，也就是升序排序的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from t1 order by b ASC，c DESC；
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个查询时用不到索引的。&lt;/p&gt;
&lt;h2 id=&#34;如何建立索引&#34;&gt;如何建立索引&lt;/h2&gt;
&lt;h3 id=&#34;考虑索引选择性&#34;&gt;考虑索引选择性&lt;/h3&gt;
&lt;p&gt;索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数的比值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;选择性=基数/记录数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选择性的取值范围为（0，1]，选择性越高的索引价值越大。如果选择性等于1，就代表这个列的不重复值和表记录数是一样的，那么对这个列建立索引是非常合适的，如果选择性非常小，那么就代表这个列的重复值是很多的，不适合建立索引。&lt;/p&gt;
&lt;h3 id=&#34;考虑前缀索引&#34;&gt;考虑前缀索引&lt;/h3&gt;
&lt;p&gt;用列的前缀代替整个列作为索引 key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引 key 变短而减少了索引文件的大小和维护开销。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用mysql官网提供的示例数据库：&lt;a href=&#34;https://dev.mysql.com/doc/employee/en/employees-installation.html&#34;&gt;https://dev.mysql.com/doc/employee/en/employees-installation.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;github地址：&lt;a href=&#34;https://github.com/datacharmer/test_db&#34;&gt;https://github.com/datacharmer/test_db&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;employees表只有一个索引&amp;lt;emp_no&amp;gt;，那么如果我们想按名字搜索一个人，就只能全表扫描了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;EXPLAIN SELECT * FROM employees.employees WHERE first_name=&#39;Eric&#39; AND last_name=&#39;Anido&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么可以对 &amp;lt;first_name&amp;gt; 或 &amp;lt;first_name，last_name&amp;gt; 建立索引，看下两个索引的选择性：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT count(DISTINCT(first_name))/count(*) AS Selectivity FROM employees.employees; -- 0.0042

SELECT count(DISTINCT(concat(first_name, last_name)))/count(*) AS Selectivity FROM employees.employees; -- 0.9313
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;first_name&amp;gt;显然选择性太低，&amp;lt;first_name，last_name&amp;gt;选择性很好，但是first_name和last_name加起来长度为30，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如&amp;lt;first_name, left(last_name, 3)&amp;gt;，看看其选择性：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT count(DISTINCT(concat(first_name, left(last_name, 3))))/count(*) AS Selectivity FROM employees.employees; -- 0.7879
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT count(DISTINCT(concat(first_name, left(last_name, 4))))/count(*) AS Selectivity FROM employees.employees; -- 0.9007
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时选择性已很理想了，而这个索引的长度只有18，比&amp;lt;first_name，last_name&amp;gt;短了接近一半，建立前缀索引的方式为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;ALTER TABLE employees.employees ADD INDEX first_name_last_name4 (first_name,last_name(4));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于 OFRDER BY 和 GROUP BY 操作，也不能用于覆盖索引。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;索引列的类型尽量小&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利用索引字符串值的前缀&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主键自增&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定位并删除表中的重复和冗余索引&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽量使用覆盖索引进行查询，避免回表带来的性能损耗。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;https://cyc2018.github.io/CS-Notes/#/notes/MySQL&lt;/p&gt;
">MySQL 索引详解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/yi-pian-wen-zhang-che-di-gao-ding-nio/"" data-c="
          &lt;h1 id=&#34;用发展的眼光看看-bio&#34;&gt;用发展的眼光看看 BIO&lt;/h1&gt;
&lt;h2 id=&#34;jdk14&#34;&gt;JDK1.4&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;java.io包  XXX 类&lt;/li&gt;
&lt;li&gt;BIO：Blocking IO：同步阻塞的 IO&lt;/li&gt;
&lt;li&gt;Socket 应用程序：
&lt;ul&gt;
&lt;li&gt;监听端口：ServerSocket(9999);&lt;/li&gt;
&lt;li&gt;获取客户端的 Socket：serverSocket.accept();&lt;/li&gt;
&lt;li&gt;获取 IO 流对象，进行服务端和客户端的数据交互：socket.getInputStream()、getOutputStream()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;jdk14-之后&#34;&gt;JDK1.4 之后&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;NIO：Non-Blocking IO 同步非阻塞&lt;/li&gt;
&lt;li&gt;java.nio 包&lt;/li&gt;
&lt;li&gt;对 NIO 做一个封装：netty&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;图解与代码展现bio及问题所在&#34;&gt;图解与代码展现BIO及问题所在&lt;/h1&gt;
&lt;h2 id=&#34;单线程-bio&#34;&gt;单线程 BIO&lt;/h2&gt;
&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package com.gupao;
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
public class BIOServer {
    public static void main(String[] args) {
        byte [] bs = new byte[1024];
        List&amp;lt;Socket&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        try(ServerSocket serverSocket = new ServerSocket(9999)) {
            System.out.println(&amp;quot;BIOServer has started, listening on port:&amp;quot; + serverSocket.getLocalSocketAddress());
            while (true){
                Socket clientSocket = serverSocket.accept();
                System.out.println(&amp;quot;Connection from &amp;quot; + clientSocket.getRemoteSocketAddress());
                // 业务处理的代码   
                try(Scanner input = new Scanner(clientSocket.getInputStream())) {
                    while (true){
                        String request = input.nextLine();
                        if(&amp;quot;quit&amp;quot;.equals(request)){
                            break;
                        }
                        System.out.println(String.format(&amp;quot;From %s : %s&amp;quot;, clientSocket.getRemoteSocketAddress(), request));
                        String response = &amp;quot;From BIOServer Hello &amp;quot; + request + &amp;quot;.\n&amp;quot;;
                        clientSocket.getOutputStream().write(response.getBytes());
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;运行结果&#34;&gt;运行结果&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%8D%95%E7%BA%BF%E7%A8%8BBIO%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;分析&#34;&gt;分析&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;第一个 Server 启动， 阻塞在 accept() 方法上，等待第二个 Server 的连接；&lt;/li&gt;
&lt;li&gt;第二个 Server 连接上后，第一个 Server 不再阻塞在 accept() 上，继续向下运行，阻塞在 Scanner 的 nextLine() 方法上，等待第二个 Server 发送数据；&lt;/li&gt;
&lt;li&gt;第二个 Server 数据准备好后，给第一个 Server 发送数据，第一个 Server 的 nextLine() 方法不再阻塞，继续向下运行，再次进行 while 循环，重新阻塞在 “等待数据准备好” 的方法上。&lt;/li&gt;
&lt;li&gt;第三个 Server 进行连接，第一个 Server 无法接收到第三个 Server 连接成功请求，第三个 Server 也无法向第一个 Server 发送数据。
&lt;ul&gt;
&lt;li&gt;只有第二个 Server 通过 &amp;quot;quit&amp;quot; 与第一个 Server 断开连接后，第三个 Server 才能与第一个 Server 进行交互&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;总结：不能使用两个客户端同时连接一个 Server 进行操作&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%8D%95%E7%BA%BF%E7%A8%8BBIO%E5%88%86%E6%9E%90.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;仔细想想bio的核心问题及解决方案&#34;&gt;仔细想想BIO的核心问题及解决方案&lt;/h1&gt;
&lt;h2 id=&#34;多线程&#34;&gt;多线程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;那么如何同时处理多个客户端数据交互请求呢？&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%A4%9A%E7%BA%BF%E7%A8%8BBIO.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;线程池&#34;&gt;线程池&lt;/h2&gt;
&lt;p&gt;Client 越来越多， Server 端的线程就会越来越多，但是 Server 端的线程受 Server 端资源、CPU 影响，不能无限增大。就需要有效地&lt;strong&gt;控制线程的数量&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E7%BA%BF%E7%A8%8B%E6%B1%A0BIO.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;线程池-bio&#34;&gt;线程池 BIO&lt;/h2&gt;
&lt;h3 id=&#34;代码-2&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package com.gupao;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ServerThreadPool {
    public static void main(String[] args) {
        // 线程池
        ExecutorService executor = Executors.newFixedThreadPool(2);

        RequestHandler requestHandler = new RequestHandler();
        // 监听
        try(ServerSocket serverSocket = new ServerSocket(9999)) {
            System.out.println(&amp;quot;NIOServer has started, listening on port:&amp;quot; + serverSocket.getLocalSocketAddress());
            while (true){
                Socket clientSocket = serverSocket.accept();
                System.out.println(&amp;quot;Connection from &amp;quot; + clientSocket.getRemoteSocketAddress());
                // 有客户端连接上来了，交给线程池处理
                executor.submit(new ClientHandler(clientSocket,requestHandler));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

package com.gupao;

import java.io.IOException;
import java.net.Socket;
import java.util.Scanner;

/**
 * 每个 Clinet 连接上来后，给它分配一个线程去执行对应的 Ruunable 任务
 */
public class ClientHandler implements Runnable {

    private final Socket clientSocket;
    private final RequestHandler requestHandler;

    public ClientHandler(Socket clientSocket, RequestHandler requestHandler) {
        this.clientSocket = clientSocket;
        this.requestHandler = requestHandler;
    }

    @Override
    public void run() {
        try(Scanner input = new Scanner(clientSocket.getInputStream())) {
            while (true){
                String request = input.nextLine();
                if(&amp;quot;quit&amp;quot;.equals(request)){
                    break;
                }
                System.out.println(String.format(&amp;quot;From %s : %s&amp;quot;, clientSocket.getRemoteSocketAddress(), request));
                // 真正的业务处理
                String response = requestHandler.handler(request);
                clientSocket.getOutputStream().write(response.getBytes());
            }
        } catch (IOException e) {
            System.out.println(&amp;quot;Caught exception: &amp;quot; + e);
            throw new RuntimeException(e);
        }
    }
}

package com.gupao;

/**
 * 业务处理代码
 */
public class RequestHandler {
    public String handler(String request){
        return &amp;quot;From Server Hello &amp;quot; + request + &amp;quot;.\n&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;运行结果-2&#34;&gt;运行结果&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E7%BA%BF%E7%A8%8B%E6%B1%A0BIO%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E7%BA%BF%E7%A8%8B%E6%B1%A0BIO%E7%BC%BA%E9%99%B7.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;顺其自带推导出nio的原理和代码实现&#34;&gt;顺其自带推导出NIO的原理和代码实现&lt;/h1&gt;
&lt;h2 id=&#34;选择器-selector&#34;&gt;选择器 Selector&lt;/h2&gt;
&lt;p&gt;如果线程池的大小为 60，来了 60 个请求，Server 端正常应该可以同时处理这 60个请求。但是线程要想被执行的话， 一定要去抢到 CPU 的执行权，CPU 进行这 60 个线程的切换，&lt;strong&gt;频繁的线程上下文切换&lt;/strong&gt;消耗 CPU 资源过多，利用率太低。多线程的情况下，线程的数量会影响 CPU 的性能，这就需要控制线程数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程创建的时机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每来一个 Client 请求连接 accept()，就为它创建一个线程，这个线程会一直等待客户端的数据:input.nextLine();（&lt;strong&gt;阻塞&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有没有办法不阻塞&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;延迟线程创建的时机&lt;/strong&gt;，&lt;strong&gt;等数据准备好以后，才去创建线程&lt;/strong&gt;。线程的数量就会得到有效控制（有的 Client 只是连接，并不进行 IO）-&amp;gt; CPU 用于上下文切换的时间减少 -&amp;gt; CPU 利用率提升。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/NIO%E9%80%89%E6%8B%A9%E5%99%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;注意看下面两段代码的注释：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.gupao;

import java.io.IOException;
import java.net.Socket;
import java.util.Scanner;

/**
 * 每个 Clinet 连接上来后，给它分配一个线程去执行对应的 Ruunable 任务
 */
public class ClientHandler implements Runnable {

    private final Socket clientSocket;
    private final RequestHandler requestHandler;

    public ClientHandler(Socket clientSocket, RequestHandler requestHandler) {
        this.clientSocket = clientSocket;
        this.requestHandler = requestHandler;
    }

    @Override
    public void run() {
        // 说明线程已经创建了，
        try(Scanner input = new Scanner(clientSocket.getInputStream())) {
            while (true){
                // 等待客户端的输入数据 —— 阻塞的（当前虽然创建了一个线程，但它没有被用到，就浪费了。能不能等到真正处理 IO 的时候才去创建线程）
                String request = input.nextLine();
                if(&amp;quot;quit&amp;quot;.equals(request)){
                    break;
                }
                System.out.println(String.format(&amp;quot;From %s : %s&amp;quot;, clientSocket.getRemoteSocketAddress(), request));
                // 响应客户端
                String response = requestHandler.handler(request);
                clientSocket.getOutputStream().write(response.getBytes());
            }
        } catch (IOException e) {
            System.out.println(&amp;quot;Caught exception: &amp;quot; + e);
            throw new RuntimeException(e);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com.gupao;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ServerThreadPool {
    public static void main(String[] args) {
        // 线程池
        ExecutorService executor = Executors.newFixedThreadPool(2);

        RequestHandler requestHandler = new RequestHandler();
        // 监听
        try(ServerSocket serverSocket = new ServerSocket(9999)) {
            System.out.println(&amp;quot;NIOServer has started, listening on port:&amp;quot; + serverSocket.getLocalSocketAddress());
            while (true){
                Socket clientSocket = serverSocket.accept();
                System.out.println(&amp;quot;Connection from &amp;quot; + clientSocket.getRemoteSocketAddress());
                // 线程创建的时机——每个客户端来了就为它创建一个线程

//                map.put(clientSocket,&amp;quot;Accepted&amp;quot;);   // 不创建线程
//                什么时候创建线程 —— clientSocket 真正进行 IO 时，采取创建线程

                executor.submit(new ClientHandler(clientSocket,requestHandler));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;通道-channel&#34;&gt;通道 Channel&lt;/h2&gt;
&lt;p&gt;Client 与 Server 连接进行数据交互，然后数据再返回给 Client。&lt;/p&gt;
&lt;p&gt;而在这个过程中，每次数据交互结束后，连接就会断开，&lt;/p&gt;
&lt;p&gt;而建立连接需要三次握手很耗时，连接是很宝贵的，优化连接的方式：建立一条条&lt;strong&gt;通道&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;连接和数据传输就在通道中进行，通道可以复用。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/NIO%E9%80%9A%E9%81%93.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;缓存-buffer&#34;&gt;缓存 Buffer&lt;/h2&gt;
&lt;p&gt;阻塞/非阻塞 IO：实际上是针对的应用程序和 OS 数据之间交互的这样一种方式。&lt;/p&gt;
&lt;p&gt;非阻塞 IO：OS 没有把所有数据全部传输完成，应用程序不会一直等待操作数据，应用程序允许 OS 一会传输一段数据。应用程序把每次接受到的一小段数据放到&lt;strong&gt;缓存&lt;/strong&gt;内。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/NIO%E7%BC%93%E5%AD%98.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;很多情况下会发现，处理数据的时候，的确用的是多线程，但这个多线程不是为了解决 IO 阻塞问题。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/NIO%E5%A4%9A%E7%BA%BF%E7%A8%8B.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;nio-代码&#34;&gt;NIO 代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;package com.gupao;

import java.awt.image.DataBufferByte;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.util.Iterator;
import java.util.Set;

public class NIOServer {
    public static void main(String[] args) throws IOException {
        // 1.Channel 通道
        // 服务端 Channel
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        // 服务端 Channel 设置为非阻塞
        serverSocketChannel.configureBlocking(false);
        // Channel 绑定端口
        serverSocketChannel.bind(new InetSocketAddress(9999));
        System.out.println(&amp;quot;NIOServer has started, listening on port: &amp;quot; + serverSocketChannel.getLocalAddress());

        // 2.Selector 选择器：注册和选择哪个 Channel 进行读/写
        Selector selector = Selector.open();
        // 将连接上来的 Channel 注册到 Selector 选择器上，并且将默认状态设置为 “Accepted”
        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

        // 3.缓冲区 Buffer
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        RequestHandler requestHandler = new RequestHandler();
        // Selector 不断轮询监听有多少个客户端 Channel已经连接上了
        while (true){
            // 从 Selector 中拿到一个个客户端的 Channel
            int select = selector.select();
            if(select == 0){
                continue;
            }
            // Set 集合维护了 客户端-服务端 的 Channel（SelectionKey）
            Set&amp;lt;SelectionKey&amp;gt; selectionKeys = selector.selectedKeys();
            // 迭代 set 集合，
            Iterator&amp;lt;SelectionKey&amp;gt; iterator = selectionKeys.iterator();
            while (iterator.hasNext()){
                // 拿到一个 SelectionKey，SelectionKey 里面有：服务端的 ServerSocketChannel；客户端的 SocketChannel
                SelectionKey key = iterator.next();
                // 如果有一个客户端的 Channel 连接上来了（状态为“Accepted”），需要进行读/写操作
                if(key.isAcceptable()){
                    // 根据 SelectionKey 获得 ServerSocketChannel
                    ServerSocketChannel channel = (ServerSocketChannel) key.channel();
                    // 根据 ServerSocketChannel 获得 SocketChannel
                    SocketChannel clientChannel = channel.accept();
                    System.out.println(&amp;quot;Connection from &amp;quot; + clientChannel.getRemoteAddress());
                    // 客户端 Channel 设置为非阻塞
                    clientChannel.configureBlocking(false);
                    // 将 Channel 的状态改变为 READ，说明该 Channel 要读数据了
                    clientChannel.register(selector, SelectionKey.OP_READ);
                }

                // 如果 Channel 的状态为 Read，可以进行 读操作了。
                // 处理读操作：还是放在 main 线程中，而不是为这个 Client 请求创建一个新的线程
                if(key.isReadable()){
                    // 获取到 客户端 Channel
                    SocketChannel channel = (SocketChannel) key.channel();
                    // 数据放到 Buffer 中
                    channel.read(buffer);
                    String request = new String(buffer.array()).trim();
                    buffer.clear();
                    System.out.println(String.format(&amp;quot;From %s : %s&amp;quot;, channel.getRemoteAddress(),request));
                    // 给客户端一个响应
                    String response = requestHandler.handler(request);
                    channel.write(ByteBuffer.wrap(response.getBytes()));
                }
                iterator.remove();
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
">一篇文章彻底搞定 NIO</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/mysql-explain-guan-jian-zi/"" data-c="
          &lt;h1 id=&#34;explain-关键字&#34;&gt;Explain 关键字&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;列名&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;id&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;在一个大的查询语句中每个SELECT关键字都对应一个唯一的id&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;select_type&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;SELECT关键字对应的那个查询的类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;table&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;表名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;partitions&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;匹配的分区信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;type&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;针对单表的访问方法&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;possible_keys&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;可能用到的索引&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;key&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;实际上使用的索引&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;key_len&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;实际使用到的索引长度&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ref&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当使用索引列等值查询时，与索引列进行等值匹配的对象信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;rows&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;预估的需要读取的记录条数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;filtered&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;某个表经过搜索条件过滤后剩余记录条数的百分比&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Extra&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;一些额外的信息&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;table&#34;&gt;table&lt;/h2&gt;
&lt;p&gt;表名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 join t2; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/table.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;explain select * from t1 join t2; &lt;/p&gt;
&lt;h2 id=&#34;id&#34;&gt;id&lt;/h2&gt;
&lt;p&gt;我们写的查询语句一般都以SELECT关键字开头，比较简单的查询语句里只有一个SELECT关键字，但是下边两种情况下在一条查询语句中会出现多个SELECT关键字：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查询中包含子查询的情况&lt;/li&gt;
&lt;li&gt;查询中包含UNION语句的情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查询语句中每出现&lt;strong&gt;一个SELECT关键字&lt;/strong&gt;，MySQL就会为它分配&lt;strong&gt;一个唯一的id值&lt;/strong&gt;。这个id值就是EXPLAIN语句的第一个列。对于连接查询来说，一个SELECT关键字后边的&lt;strong&gt;FROM子句中可以跟随多个表&lt;/strong&gt;，所以在连接查询的执行计划中，&lt;strong&gt;每个表都会对应一条记录，但是这些记录的id值都是相同的。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 join t2; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/id1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;一个 select 关键字，两条记录 id 值相同&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，出现在前边的表是驱动表，出现在后边的表是被驱动表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于&lt;strong&gt;包含子查询的&lt;/strong&gt;查询语句来说，就可能涉及&lt;strong&gt;多个SELECT&lt;/strong&gt;关键字，所以在包含子查询的查询语句的执行计划中，&lt;strong&gt;每个SELECT关键字都会对应一个唯一的id值&lt;/strong&gt;，比如这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 where a in (select a from t2) or c = &#39;c&#39;; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/id2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt; 两个 select 关键字，两个不同的 id  值&lt;/p&gt;
&lt;p&gt;但是这里大家需要特别注意，&lt;strong&gt;查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询&lt;/strong&gt;。所以如果我们想知道查询优化器对某个包含子查询的语句是否进行了重写，直接查看执行计划就好了，比如说：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 where a in (select a from t2); 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E5%B0%86%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E4%B8%BA%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;查询优化器将子查询优化为连接查询&lt;/p&gt;
&lt;p&gt;可以看到，虽然我们的查询语句是一个子查询，但是执行计划中t1和t2表对应的记录的id值全部是1，这就表明了&lt;strong&gt;查询优化器将子查询转换为了连接查询&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对&lt;strong&gt;于包含UNION子句的查询语句来说，每个SELECT关键字对应一个id值&lt;/strong&gt;也是没错的，不过还是有点儿特别的东西，比方说下边这个查询：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 union select * from t2; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/union%E5%8E%BB%E9%87%8D.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;union 去重&lt;/p&gt;
&lt;p&gt;这个语句的执行计划的第三条记录是什么？为什么id值是NULL？UNION会把多个查询的结果集合并起来并对结果集中的记录进行去重，怎么去重呢？MySQL使用的是内部的临时表。正如上边的查询计划中所示，&lt;strong&gt;UNION子句是为了把id为1的查询和id为2的查询的结果集合并起来并去重，所以在内部创建了一个名为的临时表&lt;/strong&gt;（就是执行计划第三条记录的table列的名称），id为NULL表明这个临时表是为了合并两个查询的结果集而创建的。&lt;/p&gt;
&lt;p&gt;跟UNION对比起来，&lt;strong&gt;UNION ALL就不需要为最终的结果集进行去重&lt;/strong&gt;，它只是单纯的把多个查询的结果集中的记录合并成一个并返回给用户，所以也就不需要使用临时表。所以在包含UNION ALL子句的查询的执行计划中，就没有那个id为NULL的记录，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 union all select * from t2; 
+----+-------------+-------+------------+------+---------------+------+---------+----- 
-+------+----------+-------+ 
| id | select_type | table | partitions | type | possible_keys | key | key_len | ref  
| rows | filtered | Extra | 
+----+-------------+-------+------------+------+---------------+------+---------+----- 
-+------+----------+-------+ 
| 1 | PRIMARY | t1 | NULL | ALL | NULL | NULL | NULL | NULL 
| 8 | 100.00 | NULL | 
| 2 | UNION | t2 | NULL | ALL | NULL | NULL | NULL | NULL 
| 8 | 100.00 | NULL | 
+----+-------------+-------+------------+------+---------------+------+---------+----- 
-+------+----------+-------+ 
2 rows in set, 1 warning (0.00 sec) 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;select_type&#34;&gt;select_type&lt;/h2&gt;
&lt;p&gt;每一个SELECT关键字代表的小查询都定义了一个称之为select_type的属性，意思是我们只要知道了某个小查询的select_type属性，就知道了这个小查询在整个大查询中扮演了一个什么角色。&lt;/p&gt;
&lt;h3 id=&#34;simple&#34;&gt;SIMPLE&lt;/h3&gt;
&lt;p&gt;查询语句中&lt;strong&gt;不包含UNION或者子查询的查询&lt;/strong&gt;都算作是SIMPLE类型。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2SIMPLE.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;简单查询 select_type = SIMPLE&lt;/p&gt;
&lt;p&gt;连接查询也算是SIMPLE类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 join t2; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2SIMPLE.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;连接查询 select_type = SIMPLE&lt;/p&gt;
&lt;h3 id=&#34;primary&#34;&gt;PRIMARY&lt;/h3&gt;
&lt;p&gt;对于包含UNION、UNION ALL或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的 select_type值就是PRIMARY，比方说：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 where a in (select a from t2) or c = &#39;c&#39;; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/PRIMARY.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;主查询的 select_type = PRIMARY；子查询的 select_type = SUBQUERY&lt;/p&gt;
&lt;p&gt;从结果中可以看到，最左边的小查询select * from t1对应的是执行计划中的第一条记录，它的select_type值就是 PRIMARY。&lt;/p&gt;
&lt;h3 id=&#34;union&#34;&gt;UNION&lt;/h3&gt;
&lt;p&gt;对于包含UNION或者UNION ALL的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外， 其余的小查询的select_type值就是UNION。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 union select * from t2; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/UNION.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;UNION 查询的最左边查询 select_type = RIMARY，其余小查询的 select_type = UNION&lt;/p&gt;
&lt;h3 id=&#34;union-result&#34;&gt;UNION RESULT&lt;/h3&gt;
&lt;p&gt;MySQL选择使用临时表来完成UNION查询的去重工作，针对该临时表的查询的select_type就是UNION RESULT，例子上边有。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/UNION_RESULT.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;union 查询中临时表的 select_type = UNION RESULT&lt;/p&gt;
&lt;h3 id=&#34;subquery&#34;&gt;SUBQUERY&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;非相关子查询&lt;/strong&gt;，由于 select_type 为 SUBQUERY 的子查询由于会被物化，所以&lt;strong&gt;只需要执行一遍。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 where a in (select a from t2) or c = &#39;c&#39;; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/SUBQUERY.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;非相关子查询 select_type = SUBQUERY&lt;/p&gt;
&lt;h3 id=&#34;dependent-subqurey&#34;&gt;DEPENDENT SUBQUREY&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;相关子查询&lt;/strong&gt;，select_type 为 DEPENDENT SUBQUERY 的查询可能&lt;strong&gt;会被执行多次&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 where a in (select a from t2 where t1.a = t2.a) or c = &#39;c&#39;; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/DEPENDENT_SUBQUREY.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;相关子查询 select_type = DEPENDENT SUBQUERY&lt;/p&gt;
&lt;h3 id=&#34;derived&#34;&gt;DERIVED&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from (select a, count(*) from t2 group by a ) as deliver1; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/DERIVED.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;派生表 select_type = DRIVED &lt;/p&gt;
&lt;p&gt;从执行计划中可以看出，id为2的记录就代表子查询的执行方式，它的select_type是DERIVED，说明该子查询是以物化的方式执行的。id为1的记录代表外层查询，大家注意看它的table列显示的是&lt;derived2&gt;，表示该查询是针对将派生表物化之后的表进行查询的。&lt;/p&gt;
&lt;h3 id=&#34;materialized&#34;&gt;MATERIALIZED&lt;/h3&gt;
&lt;p&gt;当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的 select_type属性就是MATERIALIZED。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 where a in (select c from t2 where e = 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/MATERIALIZED.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;物化表 select_type = MATERIALIZED &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将子查询出来的结果集放到一个物化表内，再将物化表与外层查询进行连接查询。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;type&#34;&gt;TYPE&lt;/h2&gt;
&lt;p&gt;访问方法（全表扫描还是走哪个索引）&lt;/p&gt;
&lt;h3 id=&#34;system&#34;&gt;system&lt;/h3&gt;
&lt;p&gt;当&lt;strong&gt;表中只有一条记录并且该表使用的存储引擎的统计数据是精确&lt;/strong&gt;的，比如MyISAM、Memory，那么对该表的访问方法就是system。比方说我们新建一个MyISAM表，并为其插入一条记录：&lt;/p&gt;
&lt;p&gt;创建表 t&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; CREATE TABLE t(i int) Engine=MyISAM; 
Query OK, 0 rows affected (0.05 sec) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;向 t 表内插入一条数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; INSERT INTO t VALUES(1); 
Query OK, 1 row affected (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行 explain 语句&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/system.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;表中只有一条数据、存储引擎精确统计 type = system&lt;/p&gt;
&lt;h3 id=&#34;const&#34;&gt;const&lt;/h3&gt;
&lt;p&gt;当我们根据&lt;strong&gt;主键&lt;/strong&gt;或者&lt;strong&gt;唯一二级索引列&lt;/strong&gt;与&lt;strong&gt;常数&lt;/strong&gt;进行&lt;strong&gt;等值匹配时&lt;/strong&gt;，对单表的访问方法就是const。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 where a = 1; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/const.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;根据主键与常数进行等值匹配 type = const&lt;/p&gt;
&lt;h3 id=&#34;eq_ref&#34;&gt;eq_ref&lt;/h3&gt;
&lt;p&gt;在连接查询时，如果&lt;strong&gt;被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的&lt;/strong&gt;（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是eq_ref&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 join t2 on t1.a = t2.a; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/eq_ref.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;被驱动表通过主键等值匹配的方式访问，被驱动表的 type = eq_ref&lt;/p&gt;
&lt;h3 id=&#34;ref&#34;&gt;ref&lt;/h3&gt;
&lt;p&gt;当通过&lt;strong&gt;普通的二级索引列&lt;/strong&gt;与&lt;strong&gt;常量&lt;/strong&gt;进行&lt;strong&gt;等值匹配&lt;/strong&gt;时来查询某个表，那么对该表的访问方法就可能是ref。&lt;/p&gt;
&lt;p&gt;查看所有索引：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show keys for t1;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%B4%A2%E5%BC%95.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;查看所有索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 where b = 1; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/ref.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;当通过普通的二级索引列与常量进行等值匹配时来查询某个表 type = ref&lt;/p&gt;
&lt;h3 id=&#34;ref_of_null&#34;&gt;ref_of_null&lt;/h3&gt;
&lt;p&gt;当对&lt;strong&gt;普通二级索引进行等值匹配查询&lt;/strong&gt;，&lt;strong&gt;该索引列的值也可以是NULL值&lt;/strong&gt;时，那么对该表的访问方法就可能是 ref_or_null&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 where b = 1 or b is null; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/ref_of_null.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;对普通二级索引进行等值匹配查询，该索引列的值也可以是NULL值 type = ref_of_null&lt;/p&gt;
&lt;h3 id=&#34;index_merge&#34;&gt;index_merge&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;索引合并&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 where a = 1 or b = 1; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/index_merge.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;索引合并 type = index_merge&lt;/p&gt;
&lt;h3 id=&#34;unique_subquery&#34;&gt;unique_subquery&lt;/h3&gt;
&lt;p&gt;如果&lt;strong&gt;查询优化器决定将IN子查询转换为EXISTS子查询，&lt;strong&gt;而且&lt;/strong&gt;子查询可以使用到主键进行等值匹配&lt;/strong&gt;的话，那么该子查询执行计划的type列的值就是unique_subquery。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 where c in (select a from t2 where t1.e = t2.e) or a = 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上查询可以优化为 EXISTS 子查询：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 where exists(select a from t2 where t1.e = t2.e and t1.c = t2.a) or a = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/unique_subquery.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;查询优化器将IN子查询转换为EXISTS子查询，而且子查询可以使用到主键进行等值匹配 &lt;/p&gt;
&lt;p&gt;type = unique_subquery&lt;/p&gt;
&lt;h3 id=&#34;index_subquery&#34;&gt;index_subquery&lt;/h3&gt;
&lt;p&gt;index_subquery与unique_subquery类似，只不过访问子查询中的表时使用的是普通的索引。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 where c in (select b from t2 where t1.e = t2.e) or a = 1;
+----+--------------------+-------+------------+----------------+---------------+----- 
---------+---------+------+------+----------+-------------+ 
| id | select_type | table | partitions | type | possible_keys | key  
| key_len | ref | rows | filtered | Extra | 
+----+--------------------+-------+------------+----------------+---------------+----- 
---------+---------+------+------+----------+-------------+ 
| 1 | PRIMARY | t1 | NULL | ALL | PRIMARY | NULL  
| NULL | NULL | 9 | 100.00 | Using where | 
| 2 | DEPENDENT SUBQUERY | t2 | NULL | index_subquery | idx_t2_b_c_d | 
idx_t2_b_c_d | 5 | func | 1 | 12.50 | Using where | 
+----+--------------------+-------+------------+----------------+---------------+----- 
---------+---------+------+------+----------+-------------+ 
2 rows in set, 2 warnings (0.00 sec) 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;range&#34;&gt;range&lt;/h3&gt;
&lt;p&gt;范围查询&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 where a &amp;gt; 1; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%A4%A7%E4%BA%8E_range.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;a &gt; 1 type = range&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 where a in (1);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/in_range.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;a in (1) type = const&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 where a in (1,2);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;25&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/in_range2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;a in (1,2) type = range&lt;/p&gt;
&lt;h3 id=&#34;index&#34;&gt;index&lt;/h3&gt;
&lt;p&gt;当我们可以使用覆盖索引，但&lt;strong&gt;需要扫描全部的索引记录&lt;/strong&gt;时，该表的访问方法就是index。&lt;/p&gt;
&lt;p&gt;遍历索引上的所有叶子节点，因为B+树所有数据都存储在叶子节点上，而非叶子结点是用来过滤筛选条件的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select a from t1; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;26&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/index_1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;使用辅助索引没有使用主键索引的原因：辅助索引体积较小，辅助索引只存储字段b、c、d和主键a字段；而主索引存储所有字段值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select b from t1;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;27&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/index_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; ecplain select e from t1;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;28&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/index_3.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;e 字段没有索引，所以 type = ALL&lt;/p&gt;
&lt;h3 id=&#34;all&#34;&gt;ALL&lt;/h3&gt;
&lt;p&gt;全表扫描&lt;/p&gt;
&lt;h2 id=&#34;possible_keys-和-key&#34;&gt;possible_keys 和 key&lt;/h2&gt;
&lt;p&gt;possible_keys列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些，key列表示实际用到的索引有哪些。&lt;/p&gt;
&lt;p&gt;不过有一点比较特别，就是在使用index访问方法来查询某个表时，possible_keys列是空的，而key列展示的是实际使用到的索引 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;possible_keys列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长 时间，所以如果可以的话，尽量删除那些用不到的索引&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;key_len&#34;&gt;key_len&lt;/h2&gt;
&lt;p&gt;key_len列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度，它是由这三个部分构成的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是VARCHAR(100)，使用的字符集是 utf8，那么该列实际占用的最大存储空间就是100 × 3 = 300个字节。&lt;/li&gt;
&lt;li&gt;如果该索引列可以存储NULL值，则key_len比不可以存储NULL值时多1个字节。&lt;/li&gt;
&lt;li&gt;对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;29&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/key_len.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;ref-2&#34;&gt;ref&lt;/h2&gt;
&lt;p&gt;当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是const、eq_ref、ref、ref_or_null、 unique_subquery、index_subquery其中之一时，ref列展示的就是与索引列作等值匹配的东西是什么，比如只是一个常数或者是某个列。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select b from t1 where b = 1; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;30&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/ref_1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 where a in (select a from t2); 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;31&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/ref_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;rows&#34;&gt;rows&lt;/h2&gt;
&lt;p&gt;如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的rows列就代表预计需要扫描的行数， 如果使用索引来执行查询时，执行计划的rows列就代表预计扫描的索引记录行数。&lt;/p&gt;
&lt;h2 id=&#34;filtered&#34;&gt;filtered&lt;/h2&gt;
&lt;p&gt;代表查询优化器预测在这扫描的记录中，有多少条记录满足其余的搜索条件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 where a &amp;gt; 1 and e = 1; 
+----+-------------+-------+------------+-------+---------------+---------+---------+- 
-----+------+----------+-------------+ 
| id | select_type | table | partitions | type | possible_keys | key | key_len | 
ref | rows | filtered | Extra | 
+----+-------------+-------+------------+-------+---------------+---------+---------+- 
-----+------+----------+-------------+ 
| 1 | SIMPLE | t1 | NULL | range | PRIMARY | PRIMARY | 4 | 
NULL | 8 | 11.11 | Using where | 
+----+-------------+-------+------------+-------+---------------+---------+---------+- 
-----+------+----------+-------------+ 
1 row in set, 1 warning (0.00 sec) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从执行计划的key列中可以看出来，该查询使用PRIMARY索引来执行查询，从rows列可以看出满足a &amp;gt; 1的记录有 8条。执行计划的filtered列就代表查询优化器预测在这8条记录中，&lt;strong&gt;有多少条记录满足其余的搜索条件&lt;/strong&gt;，也就是e = 1这个条件的百分比。此处filtered列的值是11.11，说明查询优化器预测在8条记录中有11.11%的记录满足e = 1 这个条件。&lt;br&gt;
对于单表查询来说，这个 filtered 列的值没什么意义，我们更关注在连接查询中驱动表对应的执行计划记录的  filtered 值，比方说下边这个查询：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 join t2 on t1.a = t2.a where t1.e = 1; 
+----+-------------+-------+------------+--------+---------------+---------+--------- 
+------------+------+----------+-------------+ 
| id | select_type | table | partitions | type | possible_keys | key | key_len | 
ref | rows | filtered | Extra | 
+----+-------------+-------+------------+--------+---------------+---------+--------- 
+------------+------+----------+-------------+ 
| 1 | SIMPLE | t1 | NULL | ALL | PRIMARY | NULL | NULL | 
NULL | 9 | 11.11 | Using where | 
| 1 | SIMPLE | t2 | NULL | eq_ref | PRIMARY | PRIMARY | 4 | 
luban.t1.a | 1 | 100.00 | NULL | 
+----+-------------+-------+------------+--------+---------------+---------+--------- 
+------------+------+----------+-------------+ 
2 rows in set, 1 warning (0.00 sec) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从执行计划中可以看出来，查询优化器打算把t1当作驱动表，t2当作被驱动表。我们可以看到驱动表t1表的执行计划的rows列为9， filtered 列为11.11，这意味着驱动表t1表经过条件过滤后有9 × 11.11% = 0.9999条记录，这说明还&lt;strong&gt;要对被驱动表执行大约1次(row * filtered)查询&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;extra&#34;&gt;Extra&lt;/h2&gt;
&lt;p&gt;Extra列是用来说明一些额外信息的，我们可以通过这些额外信息来更准确的理解MySQL到底将如何执行给定的查询语句。&lt;/p&gt;
&lt;h3 id=&#34;no-tables-used&#34;&gt;No tables used&lt;/h3&gt;
&lt;p&gt;当&lt;strong&gt;查询语句的没有FROM子句&lt;/strong&gt;时将会提示该额外信息。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select 1; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;32&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Notablesused.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;查询语句没有 FROM 子句时：Extra = No tables used&lt;/p&gt;
&lt;h3 id=&#34;impossible-where&#34;&gt;Impossible WHERE&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;查询语句的WHERE子句永远为FALSE&lt;/strong&gt;时将会提示该额外信息。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select b from t1 where 1=0; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;33&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/ImpossibleWHERE.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;WHERE 子句永远为 FALSE时：Extra = Impossible WHERE&lt;/p&gt;
&lt;h3 id=&#34;no-matching-minmax-row&#34;&gt;No matching min/max row&lt;/h3&gt;
&lt;p&gt;当&lt;strong&gt;查询列表处有MIN或者MAX聚集函数，但是并没有符合WHERE子句中的搜索条件的记录&lt;/strong&gt;时，将会提示该额外信息。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select max(a) from t1 where a=100; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;34&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/No_matching_minmax_row.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;查询列表处有MIN或者MAX聚集函数，但是并没有符合WHERE子句中的搜索条件的记录时：Extra = No matching min/max row&lt;/p&gt;
&lt;h3 id=&#34;using-index&#34;&gt;Using index&lt;/h3&gt;
&lt;p&gt;当我们的&lt;strong&gt;查询列表以及搜索条件中只包含属于某个索引的列&lt;/strong&gt;，也就是在&lt;strong&gt;可以使用索引覆盖&lt;/strong&gt;的情况下，在Extra列将会提示该额外信息。&lt;/p&gt;
&lt;p&gt;辅助索引包含 b、c、d 字段，根据查询条件 b=1 找到字段 d 的值，无需回表。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select d from t1 where b =1; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;35&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/UsingIndex.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;覆盖索引 Extra = Using index&lt;/p&gt;
&lt;h3 id=&#34;using-index-condition&#34;&gt;Using index condition&lt;/h3&gt;
&lt;p&gt;有些&lt;strong&gt;搜索条件中虽然出现了索引列，但却不能使用到索引&lt;/strong&gt;（在MySQL 5.6版本后加入的新特性）&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;36&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Using_index_condition.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 where b =1 and c like &#39;%1&#39;; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;37&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Using_index_condition2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;搜索条件中虽然出现了索引列，但却不能使用到索引 Extra = Using index condition&lt;/p&gt;
&lt;h3 id=&#34;using-where&#34;&gt;Using where&lt;/h3&gt;
&lt;p&gt;当我们使用&lt;strong&gt;全表扫描来执行对某个表的查询，并且该语句的WHERE子句中有针对该表的搜索条件时&lt;/strong&gt;，在Extra列中会提示上述额外信息。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 where e = 1; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;38&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/UsingWhere.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;全表扫描来执行对某个表的查询，并且该语句的WHERE子句中有针对该表的搜索条件时：Extra = Using where&lt;/p&gt;
&lt;h3 id=&#34;using-joinbufferblock-nested-loop&#34;&gt;Using joinbuffer(Block Nested Loop)&lt;/h3&gt;
&lt;p&gt;在&lt;strong&gt;连接查询&lt;/strong&gt;执行过程中，当被驱动表&lt;strong&gt;不能有效的利用索引&lt;/strong&gt;加快访问速度，MySQL一般会为其分配一块名叫join buffer 的内存块来加快查询速度。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 join t2 on t1.e = t2.e; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;39&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Using_joinbuffer.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;连接查询不能用到索引，分配 join buffer 内存块：Extra = Using join buffer&lt;/p&gt;
&lt;p&gt;可以在对t2表的执行计划的Extra列显示了两个提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Using join buffer (Block Nested Loop)：这是因为对表t2的访问不能有效利用索引，只好退而求其次，使用join buffer来减少对t2表的访问次数，从而提高性能。&lt;/li&gt;
&lt;li&gt;Using where：可以看到查询语句中有一个t1.e = t2.e条件，因为t1是驱动表，t2是被驱动表，所以在访问t2表时，t1.e的值已经确定下来了，所以实际上查询t2表的条件就是t2.e = 一个常数，所以提示了Using where额外信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;using-filesort&#34;&gt;Using filesort&lt;/h3&gt;
&lt;p&gt;很多情况下排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）进行排序，这种&lt;strong&gt;在内存中或者磁盘上进行排序的方式统称为文件排序&lt;/strong&gt;（英文名：filesort）。如果&lt;strong&gt;某个查询需要使用文件排序的方式执行查询&lt;/strong&gt;，就会在执行计划的Extra列中显示Using filesort提示。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 order by e; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;40&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Using_filesort.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;排序 Extra = Using filesort&lt;/p&gt;
&lt;h3 id=&#34;using-temporary&#34;&gt;Using temporary&lt;/h3&gt;
&lt;p&gt;在许多查询的执行过程中，MySQL可能会借助&lt;strong&gt;临时表&lt;/strong&gt;来完成一些功能，比如&lt;strong&gt;去重、排序&lt;/strong&gt;之类的，比如我们在执行许多包含&lt;strong&gt;DISTINCT、GROUP BY、UNION&lt;/strong&gt;等子句的查询过程中，如果&lt;strong&gt;不能&lt;/strong&gt;有效&lt;strong&gt;利用索引&lt;/strong&gt;来完成查询，MySQL很有可能寻求通过&lt;strong&gt;建立内部的临时表&lt;/strong&gt;来执行查询。如果查询中使用到了内部的临时表，在执行计划的Extra列将会显示Using temporary提示。&lt;/p&gt;
&lt;p&gt;能利用索引：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select distinct b from t1; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;41&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Using_temporary.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;利用索引distinct：Extra = Using index&lt;/p&gt;
&lt;p&gt;不能利用索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select distinct e from t1; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;42&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Using_temporary2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;不能利用索引的 distinct，建立内部临时表：Extra = Using temporary&lt;/p&gt;
&lt;p&gt;即有Using temporary，又有Using filesort，因为group by默认会先排序 （Using filesort）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select e, count(1) from t1 group by e; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;43&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Using_temporary3.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;Extra = Using temporary; Using filesort&lt;/p&gt;
&lt;p&gt;使用order by null禁用排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select e, count(1) from t1 group by e order by null; 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;44&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Using_temporary4.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;禁用排序，Extra = Using temporary&lt;/p&gt;
&lt;h3 id=&#34;start-temporary-end-temporary&#34;&gt;Start temporary、End temporary&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;查询优化器会优先尝试将IN子查询转换成semi-join&lt;/strong&gt;，而semi-join又有好多种执行策略，当执行策略为 &lt;strong&gt;DuplicateWeedout &lt;strong&gt;时，也就是通过&lt;/strong&gt;建立临时表&lt;/strong&gt;来实现为外层查询中的记录进行&lt;strong&gt;去重&lt;/strong&gt;操作时，&lt;strong&gt;驱动表&lt;/strong&gt;查询执行计划的Extra列将显示&lt;strong&gt;Start temporary&lt;/strong&gt;提示，&lt;strong&gt;被驱动表&lt;/strong&gt;查询执行计划的Extra列将显示&lt;strong&gt;End temporary&lt;/strong&gt;提示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 where a in (select e from t2 where e = 1); 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;45&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Start_temporary.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;firstmatch表名&#34;&gt;FirstMatch（表名）&lt;/h3&gt;
&lt;p&gt;在将In子查询转为semi-join时，如果采用的是&lt;strong&gt;FirstMatch&lt;/strong&gt;执行策略，则在&lt;strong&gt;被驱动表&lt;/strong&gt;执行计划的Extra列就是显示 **FirstMatch(tbl_name)**提示。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from t1 where a in (select c from t2 where c = 1); 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;46&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/FirstMatch.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;h2 id=&#34;性能按-type-排序&#34;&gt;性能按 type 排序&lt;/h2&gt;
&lt;p&gt;system &amp;gt; const &amp;gt; eq_ref &amp;gt; ref &amp;gt; ref_or_null &amp;gt; index_merge &amp;gt; unique_subquery &amp;gt; index_subquery &amp;gt; range &amp;gt; index &amp;gt; ALL&lt;/p&gt;
&lt;h2 id=&#34;性能按-extra-排序&#34;&gt;性能按 Extra 排序&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Using index：用了覆盖索引&lt;/li&gt;
&lt;li&gt;Using index condition：用了条件索引（索引下推）&lt;/li&gt;
&lt;li&gt;Using where：从索引查出来数据后继续用where条件过滤&lt;/li&gt;
&lt;li&gt;Using join buffer (Block Nested Loop)：join的时候利用了join buffer（优化策略：去除外连接、增 大join buffer大小）&lt;/li&gt;
&lt;li&gt;Using filesort：用了文件排序，排序的时候没有用到索引&lt;/li&gt;
&lt;li&gt;Using temporary：用了临时表（优化策略：增加条件以减少结果集、增加索引，思路就是要么减少待排序的数量，要么就提前排好序）&lt;/li&gt;
&lt;li&gt;Start temporary, End temporary：子查询的时候，可以优化成半连接，但是使用的是通过临时表来去重&lt;/li&gt;
&lt;li&gt;FirstMatch(tbl_name)：子查询的时候，可以优化成半连接，但是使用的是直接进行数据比较来去重&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;常见的优化手段&#34;&gt;常见的优化手段&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;SQL语句中IN包含的值不应过多，不能超过200个，200个以内查询优化器计算成本时比较精准，超过200 个是估算的成本，另外建议能用between就不要用in，这样就可以使用range索引了。&lt;/li&gt;
&lt;li&gt;SELECT语句务必指明字段名称：SELECT * 增加很多不必要的消耗（cpu、io、内存、网络带宽）；增加了使用覆盖索引的可能性；当表结构发生改变时，前端也需要更新。所以要求直接在select后面接上字段名。&lt;/li&gt;
&lt;li&gt;当只需要一条数据的时候，使用limit 1&lt;/li&gt;
&lt;li&gt;排序时注意是否能用到索引&lt;/li&gt;
&lt;li&gt;使用 or 时如果没有用到索引，可以改为union all 或者union&lt;/li&gt;
&lt;li&gt;如果in不能用到索引，可以改成exists看是否能用到索引&lt;/li&gt;
&lt;li&gt;使用合理的分页方式以提高分页的效率&lt;/li&gt;
&lt;li&gt;不建议使用%前缀模糊查询&lt;/li&gt;
&lt;li&gt;避免在where子句中对字段进行表达式操作&lt;/li&gt;
&lt;li&gt;避免隐式类型转换 （字符 ‘a’ -&amp;gt; 数字 0，数字 !-&amp;gt; 字符）&lt;/li&gt;
&lt;li&gt;对于联合索引来说，要遵守最左前缀法则&lt;/li&gt;
&lt;li&gt;必要时可以使用force index来强制查询走某个索引&lt;/li&gt;
&lt;li&gt;对于联合索引来说，如果存在范围查询，比如between,&amp;gt;,&amp;lt;等条件时，会造成后面的索引字段失效。&lt;/li&gt;
&lt;li&gt;尽量使用inner join，避免left join，让查询优化器来自动选择小表作为驱动表&lt;/li&gt;
&lt;li&gt;必要时刻可以使用straight_join来指定驱动表，前提条件是本身是inner join&lt;/li&gt;
&lt;/ol&gt;
">MySQL —— Explain 关键字</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/leetcode53-zui-da-zi-xu-he/"" data-c="
          &lt;h2 id=&#34;问题描述&#34;&gt;问题描述&lt;/h2&gt;
&lt;p&gt;给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;h2 id=&#34;示例&#34;&gt;示例:&lt;/h2&gt;
&lt;p&gt;输入: [-2,1,-3,4,-1,2,1,-5,4],&lt;br&gt;
输出: 6&lt;/p&gt;
&lt;p&gt;解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。&lt;/p&gt;
&lt;p&gt;进阶:&lt;br&gt;
如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。&lt;/p&gt;
&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;strong&gt;当前数字&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;strong&gt;连续子序列最大和 maxSum&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;strong&gt;子序列当前累加和 cur&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-8&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-3 &amp;lt; 0, 更新 cur = 3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-10&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;第一个数：2。连续子序列最大和 &lt;code&gt;maxSum = 2&lt;/code&gt;；子序列当前累加和 &lt;code&gt;cur=2&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;第二个数：-8。&lt;code&gt;2 - 8 = -6 &amp;lt; maxSum&lt;/code&gt;，不更新 maxSum&lt;/li&gt;
&lt;li&gt;第三个数：3。&lt;code&gt;-6 + 3 = -3 &amp;lt; maxSum&lt;/code&gt;，不更新 maxSum
&lt;ul&gt;
&lt;li&gt;如果不加 -6，而是让 3 自成一个子序列，&lt;code&gt;3 &amp;gt; maxSum&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;maxSum = 3；cur = 3&lt;/li&gt;
&lt;li&gt;如果前面累加的和为负数或零，对后面的求和不会有正向贡献，因此可以舍弃前面这段子序列的和，重新开始一个新的子序列。当前连续子序列的和记为 cur&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if ( cur&amp;lt;= 0 )&lt;/code&gt;，就从当前元素重新开始一个新的子序列，当前和 cur 更新为当前的元素值 &lt;code&gt;cur = a[i];&lt;/code&gt; 否则子序列就继续向前相加 &lt;code&gt;cur = cur + a[i]&lt;/code&gt; 。每次子序列的和更新后，都要和最大值 maxSum 对比，以此更新最大值 &lt;code&gt;maxSum = max(maxSum, cur)&lt;/code&gt;，这样遍历完数组，就能找到连续子序列的最大和&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第四个数：-2。&lt;code&gt;3 - 2 = 1&lt;/code&gt;，&lt;code&gt;cur=1 &amp;gt; 0&lt;/code&gt;，于是保留 &lt;code&gt;cur=1&lt;/code&gt;。&lt;code&gt;cur=1 &amp;lt; maxSum=3&lt;/code&gt;，不更新 maxSum&lt;/li&gt;
&lt;li&gt;第五个数：4。&lt;code&gt;1+4=5 &amp;gt; maxSum&lt;/code&gt;，保留 &lt;code&gt;cur=5&lt;/code&gt;，更新 maxSum=5&lt;/li&gt;
&lt;li&gt;第六个数：-10。&lt;code&gt;5-10=-5 &amp;lt; 5&lt;/code&gt;，不更新 maxSum&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;T = O(n)&lt;br&gt;
遍历数组一遍，时间复杂度为 O(n)。&lt;/li&gt;
&lt;li&gt;S = O(1)&lt;br&gt;
没有使用额外的存储空间，空间复杂度为 O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;class Solution {

  // Time: O(n), Space: O(1)
  public int maxSubArray(int[] nums) {
      // 初始化子序列最大和 max 和 子序列当前累加和
      int max = Integer.MIN_VALUE, cur = 0;
    // for 循环遍历数组
    for (int i = 0; i &amp;lt; nums.length; ++i) {
      // 累加和 &amp;lt;= 0，则用当前元素值 nums[i] 更新累加和，表示开始一个新的子序列；否则继续累加当前元素的值
      cur = cur &amp;lt;= 0 ? nums[i] : (cur + nums[i]);
      // 更新当前子序列的最大值
      max = Math.max(max, cur);
    }
    return max;
  }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;来源&#34;&gt;来源&lt;/h2&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：&lt;a href=&#34;https://leetcode-cn.com/problems/maximum-subarray&#34;&gt;https://leetcode-cn.com/problems/maximum-subarray&lt;/a&gt;&lt;/p&gt;
">leetcode53. 最大子序和</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/shen-ru-xue-xi-bing-fa-bian-cheng-zhong-de-synchronized/"" data-c="
          &lt;h1 id=&#34;第一章并发编程中的三个问题&#34;&gt;第一章：并发编程中的三个问题&lt;/h1&gt;
&lt;h2 id=&#34;可见性&#34;&gt;可见性&lt;/h2&gt;
&lt;p&gt;可见性（Visibility）：是指&lt;strong&gt;一个线程对共享变量进行修改，另一个线程立即得到修改后的最新值&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;可见性演示&#34;&gt;可见性演示&lt;/h3&gt;
&lt;p&gt;案例演示：一个线程根据 &lt;code&gt;boolean&lt;/code&gt; 类型的标记 &lt;code&gt;flag&lt;/code&gt;， &lt;code&gt;while&lt;/code&gt; 循环，另一个线程改变这个 &lt;code&gt;flag&lt;/code&gt; 变量的值，这个线程并不会停止循环。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.itheima.demo01_concurrent_problem;

/**
 *目标:演示可见性问题
 *     1.创建一个共享变量
 *     2.创建一个线程不断读取共享变量
 *     3.创建一饿线程修改共享变量
 */
public class Test01Visibility {
    // 1.创建一个共享变量
    private static boolean flag = true;

    public static void main(String[] args) throws InterruptedException {
        // 2.创建一个线程不断读取共享变量
        new Thread(() -&amp;gt; {
            while (flag) {

            }
        }).start();

        Thread.sleep(2000);

        // 3.创建一个线程修改共享变量
        new Thread(() -&amp;gt; {
            flag = false;
            System.out.println(&amp;quot;线程修改了变量的值为false&amp;quot;);
        }).start();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;线程修改了变量的值为false
（阻塞···）
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;小结&#34;&gt;小结&lt;/h3&gt;
&lt;p&gt;并发编程时，会出现可见性问题，当一个线程对共享变量进行了修改，另外的线程并没有立即看到修改后的最新值。&lt;/p&gt;
&lt;h2 id=&#34;原子性&#34;&gt;原子性&lt;/h2&gt;
&lt;p&gt;原子性（Atomicity）：&lt;strong&gt;在一次或多次操作中，要么所有的操作都执行并且不会受其他因素干扰而中断，要么所有的操作都不执行&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;原子性演示&#34;&gt;原子性演示&lt;/h3&gt;
&lt;p&gt;案例演示:5个线程各执行1000次 i++;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.itheima.demo01_concurrent_problem;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

/**
 * 目标:演示原子性问题
 *     1.定义一个共享变量number
 *     2.对number进行1000的++操作
 *     3.使用5个线程来进行
 */
public class Test02Atomicity {
    // 1.定义一个共享变量number
    private static int number = 0;

    public static void main(String[] args) throws InterruptedException {
        // 2.对number进行1000的++操作
        Runnable increment = () -&amp;gt; {
            for (int i = 0; i &amp;lt; 1000; i++) {
                number++;
            }
        };
        List&amp;lt;Thread&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        // 3.使用5个线程来进行
        for (int i = 0; i &amp;lt; 5; i++) {
            Thread t = new Thread(increment);
            t.start();
            list.add(t);
        }

        for (Thread t : list) {
            t.join();
        }

        System.out.println(&amp;quot;number = &amp;quot; + number);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;number = 4955
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;javap&lt;/code&gt;反汇编&lt;code&gt;class&lt;/code&gt;文件，得到下面的字节码指令：&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%8E%9F%E5%AD%90%E6%80%A7%E6%BC%94%E7%A4%BA.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中，对于 &lt;code&gt;number++&lt;/code&gt; 而言（number 为静态变量），实际会产生如下的 JVM 字节码指令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;9: getstatic #12    // 从类信息中加载 12 号 static 变量
12: iconst_1         // 把 int 类型常量 1 压入操作数栈
13: iadd               // 将操作数栈顶和次栈顶元素弹出并相加
14: putstatic #12 // 设置 12 号 static 变量
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由此可见&lt;code&gt;number++&lt;/code&gt;是由多条语句组成，以上多条指令在一个线程的情况下是不会出问题的，但是在多线程情况下就可能会出现问题。比如一个线程在执行&lt;code&gt;13: iadd&lt;/code&gt;时，另一个线程又执行&lt;code&gt;9: getstatic&lt;/code&gt;。会导致两次&lt;code&gt;number++&lt;/code&gt;，实际上只加了1。&lt;/p&gt;
&lt;h3 id=&#34;小结-2&#34;&gt;小结&lt;/h3&gt;
&lt;p&gt;并发编程时，会出现原子性问题，当一个线程对共享变量操作到一半时，另外的线程也有可能来操作共享变量，干扰了前一个线程的操作。&lt;/p&gt;
&lt;h2 id=&#34;有序性&#34;&gt;有序性&lt;/h2&gt;
&lt;p&gt;有序性（Ordering）：是指程序中代码的执行顺序，Java在编译时和运行时会对代码进行优化，会导致&lt;strong&gt;程序最终的执行顺序不一定就是我们编写代码时的顺序&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
    int a = 10;
    int b = 20;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;有序性演示&#34;&gt;有序性演示&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;jcstress&lt;/code&gt;是&lt;code&gt;Java&lt;/code&gt;并发压测工具。&lt;a href=&#34;https://wiki.openjdk.java.net/display/CodeTools/jcstress&#34;&gt;https://wiki.openjdk.java.net/display/CodeTools/jcstress&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;修改pom文件，添加依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt; 
  &amp;lt;groupId&amp;gt;org.openjdk.jcstress&amp;lt;/groupId&amp;gt; 
  &amp;lt;artifactId&amp;gt;jcstress-core&amp;lt;/artifactId&amp;gt; 
  &amp;lt;version&amp;gt;${jcstress.version}&amp;lt;/version&amp;gt; 
&amp;lt;/dependency&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码&lt;br&gt;
Test03Orderliness.java&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import org.openjdk.jcstress.annotations.*;
import org.openjdk.jcstress.infra.results.I_Result;
@JCStressTest
@Outcome(id = {&amp;quot;1&amp;quot;, &amp;quot;4&amp;quot;}, expect = Expect.ACCEPTABLE, desc = &amp;quot;ok&amp;quot;)
@Outcome(id = &amp;quot;0&amp;quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &amp;quot;danger&amp;quot;)
@State
public class Test03Orderliness {
    int num = 0;
    boolean ready = false;
    // 线程一执行的代码
    @Actor
    public void actor1(I_Result r) {
        if(ready) {
            r.r1 = num + num;
        } else {
            r.r1 = 1;
        }
    }
    // 线程2执行的代码
    @Actor
    public void actor2(I_Result r) {
        num = 2;
        ready = true;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;I_Result&lt;/code&gt; 是一个对象，有一个属性 &lt;code&gt;r1&lt;/code&gt; 用来保存结果，在多线程情况下可能出现几种结果？
&lt;ul&gt;
&lt;li&gt;情况1：线程1先执行&lt;code&gt;actor1&lt;/code&gt;，这时&lt;code&gt;ready = false&lt;/code&gt;，所以进入else分支结果为1。&lt;/li&gt;
&lt;li&gt;情况2：线程2执行到&lt;code&gt;actor2&lt;/code&gt;，执行了&lt;code&gt;num = 2;&lt;/code&gt;和&lt;code&gt;ready = true&lt;/code&gt;，线程1执行，这回进入 if 分支，结果为 4。&lt;/li&gt;
&lt;li&gt;情况3：线程2先执行&lt;code&gt;actor2&lt;/code&gt;，只执行&lt;code&gt;num = 2&lt;/code&gt;；但没来得及执行 &lt;code&gt;ready = true&lt;/code&gt;，线程1执行，还是进入 else分支，结果为1。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;还有一种结果0&lt;/strong&gt;。代码重排序将 &lt;code&gt;actor2&lt;/code&gt; 中 &lt;code&gt;num = 2&lt;/code&gt; 和 &lt;code&gt;ready = true&lt;/code&gt; 反序。先执行 &lt;code&gt;actor2&lt;/code&gt; 中的 &lt;code&gt;ready = true&lt;/code&gt;，然后执行 &lt;code&gt;actor1&lt;/code&gt; 中 if 判断，结果为 0 + 0 = 0。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;运行测试：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mvn clean install 
java -jar target/jcstress.jar
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;小结-3&#34;&gt;小结&lt;/h3&gt;
&lt;p&gt;程序代码在执行过程中的先后顺序，由于&lt;code&gt;Java&lt;/code&gt;在编译期以及运行期的优化，导致了代码的执行顺序未必就是开发者编写代码时的顺序。&lt;/p&gt;
&lt;h1 id=&#34;第二章java内存模型jmm&#34;&gt;第二章：Java内存模型(JMM)&lt;/h1&gt;
&lt;p&gt;在介绍Java内存模型之前，先来看一下到底什么是计算机内存模型。&lt;/p&gt;
&lt;h2 id=&#34;计算机结构&#34;&gt;计算机结构&lt;/h2&gt;
&lt;h3 id=&#34;计算机结构简介&#34;&gt;计算机结构简介&lt;/h3&gt;
&lt;p&gt;冯诺依曼，提出计算机由五大组成部分，&lt;strong&gt;输入设备，输出设备，存储器，控制器，运算器&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center&#34;&gt;计算机结构&lt;/p&gt;
&lt;h3 id=&#34;cpu&#34;&gt;CPU&lt;/h3&gt;
&lt;p&gt;中央处理器，是计算机的&lt;strong&gt;控制和运算&lt;/strong&gt;的核心，我们的程序最终都会变成指令让CPU去执行，处理程序中的数据。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/CPU.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p style = &#34;text-align:center&#34;&gt;CPU&lt;/p&gt;
&lt;h3 id=&#34;内存&#34;&gt;内存&lt;/h3&gt;
&lt;p&gt;我们的程序都是在内存中运行的，&lt;strong&gt;内存会保存程序运行时的数据&lt;/strong&gt;，供CPU处理。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%86%85%E5%AD%98.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center&#34;&gt;内存&lt;/p&gt;
&lt;h3 id=&#34;缓存&#34;&gt;缓存&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;CPU的运算速度和内存的访问速度相差比较大&lt;/strong&gt;。这就导致CPU每次操作内存都要耗费很多等待时间。内存的读写速度成为了计算机运行的瓶颈。于是就有了在CPU和主内存之间增加缓存的设计。最靠近CPU 的缓存称为L1，然后依次是 L2，L3和主内存，CPU缓存模型如图下图所示。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/CPU%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9E%8B.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center&#34;&gt;CPU 缓存模型&lt;/p&gt;
&lt;p&gt;CPU Cache分成了三个级别: L1， L2， L3。级别越小越接近CPU，速度也更快，同时也代表着容量越小。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;L1是最接近CPU的，它容量最小，例如32K，速度最快，每个核上都有一个L1 Cache。&lt;/li&gt;
&lt;li&gt;L2 Cache 更大一些，例如256K，速度要慢一些，一般情况下每个核上都有一个独立的L2 Cache。&lt;/li&gt;
&lt;li&gt;L3 Cache是三级缓存中最大的一级，例如12MB，同时也是缓存中最慢的一级，在同一个CPU插槽之间的核共享一个L3 Cache。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/CPU%E5%8F%82%E6%95%B0.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Latency：延迟&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Cache的出现是为了解决&lt;strong&gt;CPU直接访问内存效率低下&lt;/strong&gt;问题的，程序在运行的过程中，CPU接收到指令后，它会最先向CPU中的一级缓存（L1 Cache）去寻找相关的数据，如果命中缓存，CPU进行计算时就可以直接对CPU Cache中的数据进行读取和写入，当运算结束之后，再将CPU Cache中的最新数据刷新到主内存当中，CPU通过直接访问Cache的方式替代直接访问主存的方式极大地提高了CPU 的吞吐能力。但是由于一级缓存（L1 Cache）容量较小，所以不可能每次都命中。这时CPU会继续向下一级的二级缓存（L2 Cache）寻找，同样的道理，当所需要的数据在二级缓存中也没有的话，会继续转向L3 Cache、内存(主存)和硬盘。&lt;/p&gt;
&lt;h3 id=&#34;小结-4&#34;&gt;小结&lt;/h3&gt;
&lt;p&gt;计算机的主要组成：CPU，内存，输入设备，输出设备。&lt;/p&gt;
&lt;h2 id=&#34;java内存模型&#34;&gt;Java内存模型&lt;/h2&gt;
&lt;p&gt;Java Memory Molde (Java内存模型/JMM)，千万不要和Java内存结构混淆&lt;/p&gt;
&lt;p&gt;关于“Java内存模型”的权威解释，请参考 &lt;a href=&#34;https://download.oracle.com/otn-pub/jcp/memory_model-1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.pdf?AuthParam=1581232382_a0e88fb559ae2cdd224df3335e1eb9d3&#34;&gt;https://download.oracle.com/otn-pub/jcp/memory_model-1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.pdf&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Java 内存模型，是 Java 虚拟机规范中所定义的一种内存模型，Java 内存模型是标准化的，屏蔽掉了底层不同计算机的区别。&lt;/p&gt;
&lt;p&gt;Java内存模型是一套规范，描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节，具体如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主内存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主内存是&lt;strong&gt;所有线程都共享&lt;/strong&gt;的，都能访问的。所有的&lt;strong&gt;共享变量&lt;/strong&gt;都存储于主内存。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工作内存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;每一个线程有自己的工作内存&lt;/strong&gt;，工作内存只存储该线程对&lt;strong&gt;共享变量的副本&lt;/strong&gt;。线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接访问对方工作内存中的变量。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center&#34;&gt; Java 内存模型&lt;/p&gt;
&lt;h3 id=&#34;java-内存模型的作用&#34;&gt;Java 内存模型的作用&lt;/h3&gt;
&lt;p&gt;Java内存模型是一套在多线程读写共享数据时，对共享数据的可见性、有序性、和原子性的规则和保障。&lt;/p&gt;
&lt;p&gt;synchronized,volatile&lt;/p&gt;
&lt;h3 id=&#34;cpu缓存内存与-java-内存模型的关系&#34;&gt;CPU缓存，内存与 Java 内存模型的关系&lt;/h3&gt;
&lt;p&gt;通过对前面的CPU硬件内存架构、Java内存模型以及Java多线程的实现原理的了解，我们应该已经意识到，&lt;strong&gt;多线程的执行最终都会映射到硬件处理器上进行执行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但 Java 内存模型和硬件内存架构并不完全一致。对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存和主内存之分，也就是说 Java 内存模型对内存的划分对硬件内存并没有任何影响， 因为 JMM 只是一种抽象的概念，是一组规则，不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说，Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种&lt;strong&gt;抽象概念划分与真实物理硬件的交叉&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JMM内存模型与CPU硬件内存架构的关系：&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/JMM%E4%B8%8ECPU%E7%A1%AC%E4%BB%B6%E5%86%85%E5%AD%98%E6%9E%B6%E6%9E%84%E7%9A%84%E5%85%B3%E7%B3%BB.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java 内存模型是一套&lt;strong&gt;规范&lt;/strong&gt;，描述了 &lt;strong&gt;Java 程序中各种变量(线程共享变量)的访问规则&lt;/strong&gt;，以及在 JVM 中将变量存储到内存和从内存中读取变量这样的底层细节，Java 内存模型是对共享数据的可见性、有序性、和原子性的规则和保障。&lt;/p&gt;
&lt;h2 id=&#34;主内存与工作内存之间的数据交互过程&#34;&gt;主内存与工作内存之间的数据交互过程&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%B8%BB%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E7%9A%84%E4%BA%A4%E4%BA%92.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Java内存模型中定义了以下8种操作来完成，主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的。&lt;/p&gt;
&lt;p&gt;对应如下的流程图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%B8%BB%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E5%85%B7%E4%BD%93%E7%9A%84%E4%BA%A4%E4%BA%92%E5%8D%8F%E8%AE%AE.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;read：从主内存读取共享变量（&lt;code&gt;boolean x= true&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;load：将共享变量（&lt;code&gt;boolean x = tru&lt;/code&gt;e）放入工作内存的变量副本中&lt;/li&gt;
&lt;li&gt;use：把工作内存中一个变量的&lt;strong&gt;值&lt;/strong&gt;（true）传递给执行引擎&lt;/li&gt;
&lt;li&gt;assign：把一个从执行引擎接收到的值赋给工作内存的变量&lt;/li&gt;
&lt;li&gt;store：把工作内存的一个共享变量传送到主内存中&lt;/li&gt;
&lt;li&gt;write：在 store 之后执行，把 store 得到的值放入主内存的变量中&lt;/li&gt;
&lt;li&gt;lock：作用于主内存的变量&lt;/li&gt;
&lt;li&gt;unlock&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果对一个变量执行lock操作，将会&lt;strong&gt;清空工作内存中此变量的值&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对一个变量执行unlock操作之前，必须先&lt;strong&gt;把此变量同步到主内存中&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;小结-5&#34;&gt;小结&lt;/h3&gt;
&lt;p&gt;主内存与工作内存之间的数据交互过程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lock -&amp;gt; read -&amp;gt; load -&amp;gt; use -&amp;gt; assign -&amp;gt; store -&amp;gt; write -&amp;gt; unlock
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;第三章synchronized保证三大特性&#34;&gt;第三章：synchronized保证三大特性&lt;/h1&gt;
&lt;p&gt;synchronized能够保证在同一时刻最多只有一个线程执行该段代码，以达到保证并发安全的效果。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;synchronized (锁对象) { 
    // 受保护资源; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;synchronized与原子性&#34;&gt;synchronized与原子性&lt;/h2&gt;
&lt;h3 id=&#34;使用synchronized保证原子性&#34;&gt;使用synchronized保证原子性&lt;/h3&gt;
&lt;p&gt;案例演示:5个线程各执行1000次 i++;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.ArrayList;
/**
 案例演示:5个线程各执行1000次 i++; 
 */
public class Test01Atomicity {
    private static int number = 0;
    public static void main(String[] args) throws InterruptedException {
        Runnable increment = new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i &amp;lt; 1000; i++) {
                    synchronized (Test01Atomicity.class) {
                        number++;
                    }
                }
            }
        };
        ArrayList&amp;lt;Thread&amp;gt; ts = new ArrayList&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; 50; i++) {
            Thread t = new Thread(increment);
            t.start();
            ts.add(t);
        }
        for (Thread t : ts) {
            t.join();
        }
        System.out.println(&amp;quot;number = &amp;quot; + number);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;number = 50000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主要代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (int i = 0; i &amp;lt; 1000; i++) {
    synchronized (Test01Atomicity.class) {
        number++;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;synchronized保证原子性的原理&#34;&gt;synchronized保证原子性的原理&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/synchronized%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8E%9F%E7%90%86.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;对&lt;code&gt;number++&lt;/code&gt;;增加同步代码块后，保证同一时间只有一个线程操作&lt;code&gt;number++&lt;/code&gt;;。就不会出现安全问题。&lt;/p&gt;
&lt;h3 id=&#34;小结-6&#34;&gt;小结&lt;/h3&gt;
&lt;p&gt;synchronized保证原子性的原理：synchronized保证只有一个线程拿到锁，能够进入同步代码块。&lt;/p&gt;
&lt;h2 id=&#34;synchronized与可见性&#34;&gt;synchronized与可见性&lt;/h2&gt;
&lt;h3 id=&#34;使用synchronized保证可见性&#34;&gt;使用synchronized保证可见性&lt;/h3&gt;
&lt;p&gt;案例演示：一个线程根据boolean类型的标记flag， while循环，另一个线程改变这个flag变量的值，使用 synchronized 加锁这个线程会停止循环。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*
    目标:演示可见性问题
        1.创建一个共享变量
        2.创建一个线程不断读取共享变量
        3.创建一个线程修改共享变量
 */
public class Test01Visibility {
    // 1.创建一个使用 volatile 修饰的共享变量
    private static boolean flag = true;
    private static Object obj = new Object();
    public static void main(String[] args) throws InterruptedException {
        // 2.创建一个线程不断读取共享变量
        new Thread(() -&amp;gt; {
            while (flag) {
                synchronized (obj){

                }
            }
        }).start();

        Thread.sleep(2000);

        // 3.创建一个线程修改共享变量
        new Thread(() -&amp;gt; {
            flag = false;
            System.out.println(&amp;quot;线程修改了变量的值为false&amp;quot;);
        }).start();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;线程修改了变量的值为false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析：&lt;br&gt;
synchronized ：当线程 2 将 flag 的值改为 false 后，线程 1 再次执行 while 操作时：读取主内存变量到工作空间前，执行 Lock 操作，使工作内存内的共享变量失效，再次去主内存读取刷新共享变量的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;synchronized保证可见性的原理&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%B8%BB%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E5%85%B7%E4%BD%93%E7%9A%84%E4%BA%A4%E4%BA%92%E5%8D%8F%E8%AE%AE.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果 while 方法内增加输出语句 &lt;code&gt;System.out.println(&amp;quot;run = &amp;quot; + run);&lt;/code&gt;，即使不显式使用 &lt;code&gt;synchronized&lt;/code&gt; 加锁也能终止死循环。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 案例演示:
 一个线程根据boolean类型的标记flag， while循环，另一个线程改变这个flag变量的值，
 另一个线程并不会停止循环.
 */
public class Test01Visibility {
    // 多个线程都会访问的数据，我们称为线程的共享数据
    private static boolean run = true;
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -&amp;gt; {
            while (run) {
                // 增加对象共享数据的打印，println是同步方法
                System.out.println(&amp;quot;run = &amp;quot; + run);
            }
        });
        t1.start();
        Thread.sleep(1000);
        Thread t2 = new Thread(() -&amp;gt; {
            run = false;
            System.out.println(&amp;quot;时间到，线程2设置为false&amp;quot;);
        });
        t2.start();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;run = true
run = true
run = true
······
run = true
run = true
run = true
时间到，线程2设置为false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析：&lt;br&gt;
使用 sout 输出，程序会停止，而不是一直阻塞，因为 sout 内部使用了 synchronized&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/sout.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;使用-volatile-保证可见性&#34;&gt;使用 volatile 保证可见性&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package com.itheima.demo02_concurrent_problem;

/*
    目标:演示可见性问题
        1.创建一个共享变量
        2.创建一个线程不断读取共享变量
        3.创建一个线程修改共享变量
 */
public class Test01Visibility {
    // 1.创建一个使用 volatile 修饰的共享变量
    private static volatile boolean flag = true;
    private static Object obj = new Object();
    public static void main(String[] args) throws InterruptedException {
        // 2.创建一个线程不断读取共享变量
        new Thread(() -&amp;gt; {
            while (flag) {

            }
        }).start();

        Thread.sleep(2000);

        // 3.创建一个线程修改共享变量
        new Thread(() -&amp;gt; {
            flag = false;
            System.out.println(&amp;quot;线程修改了变量的值为false&amp;quot;);
        }).start();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;线程修改了变量的值为false
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;小结-7&#34;&gt;小结&lt;/h3&gt;
&lt;p&gt;synchronized保证可见性的原理，执行synchronized时，会对应lock原子操作会刷新工作内存中共享变量的值&lt;/p&gt;
&lt;h2 id=&#34;synchronized与有序性&#34;&gt;synchronized与有序性&lt;/h2&gt;
&lt;h3 id=&#34;为什么要重排序&#34;&gt;为什么要重排序&lt;/h3&gt;
&lt;p&gt;为了&lt;strong&gt;提高程序的执行效率&lt;/strong&gt;，编译器和CPU会对程序中代码进行重排序。&lt;/p&gt;
&lt;h3 id=&#34;as-if-serial语义&#34;&gt;as-if-serial语义&lt;/h3&gt;
&lt;p&gt;as-if-serial语义的意思是：不管编译器和CPU如何重排序，必须保证在&lt;strong&gt;单线程情况下程序的结果是正确&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;以下数据有依赖关系，不能重排序。&lt;/p&gt;
&lt;p&gt;写后读：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a = 1;
int b = a;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;写后写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a = 1;
int a = 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;读后写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a = 1;
int b = a;
int a = 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a = 1;
int b = 2;
int c = a + b;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面3个操作的数据依赖关系如图所示：&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%B8%89%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上图所示 a 和 c 之间存在数据依赖关系，同时 b 和 c 之间也存在数据依赖关系。因此在最终执行的指令序列中，c 不能被重排序到 a 和 b 的前面。但 a 和 b 之间没有数据依赖关系，编译器和处理器可以重排序 a 和 b 之间的执行顺序。下图是该程序的两种执行顺序。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%B8%89%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;可以这样：
int a = 1;
int b = 2;
int c = a + b;

也可以重排序这样：
int b = 2;
int a = 1;
int c = a + b; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用-synchronized-保证有序性&#34;&gt;使用 synchronized 保证有序性&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package com.itheima.demo02_concurrent_problem;

import org.openjdk.jcstress.annotations.*;
import org.openjdk.jcstress.infra.results.I_Result;
@JCStressTest
@Outcome(id = {&amp;quot;1&amp;quot;}, expect = Expect.ACCEPTABLE, desc = &amp;quot;ok&amp;quot;)
@Outcome(id = {&amp;quot;4&amp;quot;}, expect = Expect.ACCEPTABLE_INTERESTING, desc = &amp;quot;danger2&amp;quot;)
@Outcome(id = &amp;quot;0&amp;quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &amp;quot;danger&amp;quot;)
@State
public class Test03Ordering {
    private Object obj = new Object();
    volatile int num = 0;
    volatile boolean ready = false;
    // 线程1执行的代码
    @Actor
    public void actor1(I_Result r) {
        synchronized (obj){
            if (ready) {
                r.r1 = num + num;
            } else {
                r.r1 = 1;
            }
        }
    }
    // 线程2执行的代码
    @Actor
    public void actor2(I_Result r) {
        synchronized (obj){
            num = 2;
            ready = true;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果只有 1 和 4，没有 0。&lt;/p&gt;
&lt;h3 id=&#34;synchronized保证有序性的原理&#34;&gt;synchronized保证有序性的原理&lt;/h3&gt;
&lt;p&gt;synchronized后，虽然进行了重排序，保证&lt;strong&gt;只有一个线程会进入同步代码块&lt;/strong&gt;，也能保证有序性。&lt;/p&gt;
&lt;h3 id=&#34;小结-8&#34;&gt;小结&lt;/h3&gt;
&lt;p&gt;synchronized 保证有序性的原理，我们加 synchronized 后，依然会发生重排序，只不过，我们有同步代码块，可以保证只有一个线程执行同步代码中的代码，保证有序性。&lt;/p&gt;
&lt;h1 id=&#34;第四章synchronized的特性&#34;&gt;第四章：synchronized的特性&lt;/h1&gt;
&lt;h2 id=&#34;可重入特性&#34;&gt;可重入特性&lt;/h2&gt;
&lt;p&gt;一个线程可以多次执行 synchronized, 重复获取同一把锁。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.itheima.demo03_synchronized_nature;

/**
 * 目标:演示 synchronized 可重入
 *     1.自定义一个线程类
 *     2.在线程类的run方法中使用嵌套的同步代码块
 *     3.使用两个线程来执行
 */
public class Demo01 {
    public static void main(String[] args) {
        new MyThread().start();
        new MyThread().start();
    }
    public static void test01() {
        synchronized (MyThread.class) {
            String name = Thread.currentThread().getName();
            System.out.println(name + &amp;quot;进入了同步代码块2&amp;quot;);
        }
    }
}
// 1.自定义一个线程类
class MyThread extends Thread {
    @Override
    public void run() {
        synchronized (MyThread.class) {
            System.out.println(getName() + &amp;quot;进入了同步代码块1&amp;quot;);

            Demo01.test01();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Thread-0进入了同步代码块1
Thread-0进入了同步代码块2
Thread-1进入了同步代码块1
Thread-1进入了同步代码块2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;可重入原理&#34;&gt;可重入原理&lt;/h3&gt;
&lt;p&gt;synchronized 的锁对象中有一个计数器（recursions变量）会&lt;strong&gt;记录线程获得几次锁&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;可重入的好处&#34;&gt;可重入的好处&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;可以避免死锁&lt;/li&gt;
&lt;li&gt;可以让我们更好的来封装代码&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;小结-9&#34;&gt;小结&lt;/h3&gt;
&lt;p&gt;synchronized 是可重入锁，内部锁对象中会有一个计数器记录线程获取几次锁了，在执行完同步代码块时，计数器的数量会-1，直到计数器的数量为0，就释放这个锁。&lt;/p&gt;
&lt;h2 id=&#34;不可中断特性&#34;&gt;不可中断特性&lt;/h2&gt;
&lt;p&gt;一个线程获得锁后，另一个线程想要获得锁，必须处于阻塞或等待状态，如果第一个线程不释放锁，第二个线程会一直&lt;strong&gt;阻塞或等待，不可被中断&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;synchronized不可中断演示&#34;&gt;synchronized不可中断演示&lt;/h3&gt;
&lt;p&gt;synchronized 是不可中断，处于阻塞状态的线程会一直等待锁。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*
    目标:演示synchronized不可中断
    1.定义一个Runnable
    2.在Runnable定义同步代码块
    3.先开启一个线程来执行同步代码块,保证不退出同步代码块
    4.后开启一个线程来执行同步代码块(阻塞状态)
    5.停止第二个线程
*/
public class Demo02_Uninterruptible {
    private static Object obj = new Object();
    public static void main(String[] args) throws InterruptedException {
        // 1.定义一个Runnable
        Runnable run = () -&amp;gt; {
            // 2.在Runnable定义同步代码块
            synchronized (obj) {
                String name = Thread.currentThread().getName();
                System.out.println(name + &amp;quot;进入同步代码块&amp;quot;);
                // 保证不退出同步代码块
                try {
                    Thread.sleep(888888);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };
        // 3.先开启一个线程来执行同步代码块
        Thread t1 = new Thread(run);
        t1.start();
        Thread.sleep(1000);
        // 4.后开启一个线程来执行同步代码块(阻塞状态)
        Thread t2 = new Thread(run);
        t2.start();
        // 5.停止第二个线程
        System.out.println(&amp;quot;停止线程前&amp;quot;);
        t2.interrupt();
        System.out.println(&amp;quot;停止线程后&amp;quot;);
        System.out.println(t1.getState());
        System.out.println(t2.getState());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Thread-0进入同步代码块
停止线程前
停止线程后
TIMED_WAITING
BLOCKED//处于阻塞状态，不可被中断
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;reentrantlock不可中断演示&#34;&gt;ReentrantLock不可中断演示&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package com.itheima.demo03_synchronized_nature;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 目标:演示Lock不可中断
 */
public class Demo03_Interruptible {
    private static Lock lock = new ReentrantLock();
    public static void main(String[] args) throws InterruptedException {
         test01();
    }

    // 演示Lock不可中断
    public static void test01() throws InterruptedException {
        Runnable run = () -&amp;gt; {
            String name = Thread.currentThread().getName();
            try {
                lock.lock();
                System.out.println(name + &amp;quot;获得锁,进入锁执行&amp;quot;);
                Thread.sleep(88888);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
                System.out.println(name + &amp;quot;释放锁&amp;quot;);
            }
        };
        Thread t1 = new Thread(run);
        t1.start();
        Thread.sleep(1000);
        Thread t2 = new Thread(run);
        t2.start();

        System.out.println(&amp;quot;停止t2线程前&amp;quot;);
        t2.interrupt();
        System.out.println(&amp;quot;停止t2线程后&amp;quot;);
        Thread.sleep(1000);
        System.out.println(t1.getState());
        System.out.println(t2.getState());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Thread-0获得锁,进入锁执行
停止t2线程前
停止t2线程后
TIMED_WAITING
WAITING //t2 interrupt中断失败，一直处于等待状态
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;reentrantlock可中断演示&#34;&gt;ReentrantLock可中断演示&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package com.itheima.demo03_synchronized_nature;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 目标:演示Lock可中断
 */
public class Demo03_Interruptible {
    private static Lock lock = new ReentrantLock();
    public static void main(String[] args) throws InterruptedException { 
        test02();
    }

    // 演示Lock可中断
    public static void test02() throws InterruptedException {
        Runnable run = () -&amp;gt; {
            String name = Thread.currentThread().getName();
            boolean b = false;
            try {
                b = lock.tryLock(3, TimeUnit.SECONDS);
                if (b) {
                    System.out.println(name + &amp;quot;获得锁,进入锁执行&amp;quot;);
                    Thread.sleep(88888);
                } else {
                    System.out.println(name + &amp;quot;在指定时间没有得到锁做其他操作&amp;quot;);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                if (b) {
                    lock.unlock();
                    System.out.println(name + &amp;quot;释放锁&amp;quot;);
                }
            }
        };

        Thread t1 = new Thread(run);
        t1.start();
        Thread.sleep(1000);
        Thread t2 = new Thread(run);
        t2.start();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Thread-0获得锁,进入锁执行
Thread-1在指定时间没有得到锁做其他操作
(阻塞很久)
Thread-0释放锁
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;小结-10&#34;&gt;小结&lt;/h3&gt;
&lt;p&gt;不可中断是指，当一个线程获得锁后，另一个线程一直处于阻塞或等待状态，前一个线程不释放锁，后一个线程会一直阻塞或等待，不可被中断。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt; 属于不可被中断&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Lock&lt;/code&gt; 的 &lt;code&gt;lock&lt;/code&gt; 方法是不可中断的&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Lock&lt;/code&gt; 的 &lt;code&gt;tryLock&lt;/code&gt; 方法是可中断的&lt;/p&gt;
&lt;h1 id=&#34;第五章synchronized-原理&#34;&gt;第五章：synchronized 原理&lt;/h1&gt;
&lt;h2 id=&#34;javap-反汇编&#34;&gt;javap 反汇编&lt;/h2&gt;
&lt;p&gt;我们编写一个简单的synchronized代码，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Demo01 {
    private static Object obj = new Object();
    public static void main(String[] args) {
        synchronized (obj) {
            System.out.println(&amp;quot;1&amp;quot;);
        }
    }
    public synchronized void test() {
        System.out.println(&amp;quot;a&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们要看 synchronized 的原理，但是 synchronized 是一个关键字，看不到源码。我们可以将class文件进行反汇编。&lt;/p&gt;
&lt;p&gt;JDK自带的一个工具： javap ，对字节码进行反汇编，查看字节码指令。&lt;/p&gt;
&lt;p&gt;在 DOS 命令行输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;javap -p -v C:\Users\Only\悄悄的努力\AQS\synchronized资料\案例\Synchronized\target\classes\com\itheima\demo04_synchronized_monitor\Demo01
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;反汇编后的效果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=3, args_size=1
         0: getstatic     #2                  // Field obj:Ljava/lang/Object;
         3: dup
         4: astore_1
         5: monitorenter
         6: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
         9: ldc           #4                  // String 1
        11: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        14: aload_1
        15: monitorexit
        16: goto          24
        19: astore_2
        20: aload_1
        21: monitorexit
        22: aload_2
        23: athrow
        24: return
      Exception table:
         from    to  target type
             6    16    19   any
            19    22    19   any
      LineNumberTable:
        line 7: 0
        line 8: 6
        line 9: 14
        line 10: 24
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      25     0  args   [Ljava/lang/String;
      StackMapTable: number_of_entries = 2
        frame_type = 255 /* full_frame */
          offset_delta = 19
          locals = [ class &amp;quot;[Ljava/lang/String;&amp;quot;, class java/lang/Object ]
          stack = [ class java/lang/Throwable ]
        frame_type = 250 /* chop */
          offset_delta = 4

  public synchronized void test();
    descriptor: ()V
    flags: (0x0021) ACC_PUBLIC, ACC_SYNCHRONIZED
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #6                  // String a
         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      LineNumberTable:
        line 13: 0
        line 14: 8
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       9     0  this   Lcom/itheima/demo04_synchronized_monitor/Demo01;
  static {};
    descriptor: ()V
    flags: (0x0008) ACC_STATIC
    Code:
      stack=2, locals=0, args_size=0
         0: new           #7                  // class java/lang/Object
         3: dup
         4: invokespecial #1                  // Method java/lang/Object.&amp;quot;&amp;lt;init&amp;gt;&amp;quot;:()V
         7: putstatic     #2                  // Field obj:Ljava/lang/Object;
        10: return
      LineNumberTable:
        line 4: 0
}

SourceFile: &amp;quot;Demo01.java&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;同步代码块&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/synchronized.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;monitorenter&#34;&gt;monitorenter&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;首先我们来看一下JVM规范中对于monitorenter的描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter&#34;&gt;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Each object is associated with a monitor. A monitor is locked if and only if it has an owner.&lt;br&gt;
The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref， as follows:&lt;br&gt;
If the entry count of the monitor associated with objectref is zero， the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.&lt;br&gt;
If the thread already owns the monitor associated with objectref， it reenters the monitor， incrementing its entry count.&lt;br&gt;
If another thread  already owns the monitor associated with objectref， the thread blocks until the monitor&#39;s entry count is zero， then tries again to gain ownership.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译过来： 每一个对象都会和一个监视器 monitor 关联。监视器被占用时会被锁住，其他线程无法来获 取该 monitor。 当 JVM 执行某个线程的某个方法内部的 monitorenter 时，它会尝试去获取当前对象对应的 monitor 的所有权。其过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若 monior 的进入数为 0，线程可以进入 monitor，并将 monitor 的进入数置为 1。当前线程成为 monitor 的owner（所有者）&lt;/li&gt;
&lt;li&gt;若当前线程已拥有 monitor 的所有权，允许它重入 monitor，则进入 monitor 的进入数加 1&lt;/li&gt;
&lt;li&gt;若其他线程已经占有 monitor 的所有权，那么当前尝试获取 monitor 的所有权的线程会被阻塞，直到 monitor 的进入数变为 0，才能重新尝试获取 monitor 的所有权。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;monitorenter小结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;synchronized 的锁对象会关联一个 monitor, 这个 monitor 不是我们主动创建的，是 JVM 的线程执行到这个同步代码块,发现锁对象没有 monitor 就会创建 monitor, monitor 内部有两个重要的成员变量 &lt;strong&gt;owner:拥有这把锁的线程&lt;/strong&gt;, &lt;strong&gt;recursions会记录线程拥有锁的次数&lt;/strong&gt;，当一个线程拥有 monito r后其他线程只能等待。&lt;/p&gt;
&lt;h3 id=&#34;monitorexit&#34;&gt;monitorexit&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;首先我们来看一下JVM规范中对于monitorexit的描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit&#34;&gt;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.&lt;br&gt;
The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero， the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译过来：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;能执行 monitorexit 指令的线程一定是拥有当前对象的 monitor 的所有权的线程。&lt;/li&gt;
&lt;li&gt;执行 monitorexit 时会将 monitor 的进入数减 1。当 monitor 的进入数减为 0 时，当前线程退出 monitor，不再拥有 monitor 的所有权，此时其他被这个 monitor 阻塞的线程可以尝试去获取这个 monitor 的所有权 。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;monitorexit-释放锁&#34;&gt;monitorexit 释放锁。&lt;/h4&gt;
&lt;p&gt;monitorexit 插入在&lt;strong&gt;方法结束处&lt;/strong&gt;和&lt;strong&gt;异常处&lt;/strong&gt;，JVM保证每个 monitorenter 必须有对应的monitorexit。&lt;/p&gt;
&lt;h4 id=&#34;面试题-synchroznied-出现异常会释放锁吗&#34;&gt;面试题 synchroznied 出现异常会释放锁吗?&lt;/h4&gt;
&lt;p&gt;会释放锁&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/synchronized%E5%87%BA%E7%8E%B0%E5%BC%82%E5%B8%B8%E4%BC%9A%E9%87%8A%E6%94%BE%E9%94%81.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;synchronized出现异常会释放锁&lt;/p&gt;
&lt;h3 id=&#34;同步方法&#34;&gt;同步方法&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10&#34;&gt;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以看到同步方法在反汇编后，会增加 &lt;code&gt;ACC_SYNCHRONIZED&lt;/code&gt; 修饰。会隐式调用 monitorenter 和 monitorexit。在执行同步方法前会调用 monitorenter，在执行完同步方法后会调用 monitorexit。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center&#34;&gt;同步方法&lt;/p&gt;
&lt;h3 id=&#34;小结-11&#34;&gt;小结&lt;/h3&gt;
&lt;p&gt;通过 javap 反汇编我们看到 synchronized 使用变成了 monitorenter 和 monitorexit 两个指令.每个锁对象都会关联一个 monitor(监视器,它才是真正的锁对象),它内部有两个重要的成员变量owner 会保存获得锁的线程，recursions 会保存线程获得锁的次数,当执行到 monitorexit 时,recursions 会 -1,当计数器减到 0 时这个线程就会释放锁。&lt;/p&gt;
&lt;h3 id=&#34;面试题synchronized与lock的区别&#34;&gt;面试题：synchronized与Lock的区别&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;synchronized 是关键字，而 Lock 是一个接口。&lt;/li&gt;
&lt;li&gt;synchronized 会自动释放锁，而 Lock 必须手动释放锁。&lt;/li&gt;
&lt;li&gt;synchronized 是不可中断的，Lock 可以中断也可以不中断。&lt;/li&gt;
&lt;li&gt;通过 Lock 可以知道线程有没有拿到锁（tryLock()的返回值），而 synchronized 不能。&lt;/li&gt;
&lt;li&gt;synchronized 能锁住方法和代码块，而 Lock 只能锁住代码块。&lt;/li&gt;
&lt;li&gt;Lock 可以使用读锁提高多线程读效率（ReentrantReadWriteLock）。&lt;/li&gt;
&lt;li&gt;synchronized 是非公平锁，ReentrantLock 可以控制是否是公平锁。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;深入jvm源码&#34;&gt;深入JVM源码&lt;/h2&gt;
&lt;h3 id=&#34;jvm源码下载&#34;&gt;JVM源码下载&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://openjdk.java.net/&#34;&gt;http://openjdk.java.net/&lt;/a&gt; --&amp;gt; Mercurial --&amp;gt; jdk8 --&amp;gt; hotspot --&amp;gt; zip&lt;/p&gt;
&lt;h3 id=&#34;ideclion-下载&#34;&gt;IDE(Clion )下载&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jetbrains.com/&#34;&gt;https://www.jetbrains.com/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;monitor监视器锁&#34;&gt;monitor监视器锁&lt;/h3&gt;
&lt;p&gt;可以看出无论是 synchronized 代码块还是 synchronized 方法，其线程安全的语义实现最终依赖一个叫 monitor 的东西，那么这个神秘的东西是什么呢？下面让我们来详细介绍一下。&lt;/p&gt;
&lt;p&gt;在 HotSpot 虚拟机中，monitor 是由 ObjectMonitor 实现的。其源码是用 C++ 来实现的，位于HotSpot 虚拟机源码 ObjectMonitor.hpp 文件中(src/share/vm/runtime/objectMonitor.hpp)。ObjectMonitor 主要数据结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ObjectMonitor() { 
  _header = NULL; 
  _count = 0; 
  _waiters = 0， 
  _recursions = 0; // 线程的重入次数
  _object = NULL; // 存储该monitor的对象 
  _owner = NULL; // 标识拥有该monitor的线程 
  _WaitSet = NULL; // 处于wait状态的线程，会被加入到_WaitSet 
  _WaitSetLock = 0 ; 
  _Responsible = NULL; 
  _succ = NULL; 
  _cxq = NULL; // 多线程竞争锁时的单向列表 
  FreeNext = NULL; 
  _EntryList = NULL; // 处于等待锁block状态的线程，会被加入到该列表 
  _SpinFreq = 0; 
  _SpinClock = 0; 
  OwnerIsThread = 0; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;_owner：初始时为NULL。当有&lt;strong&gt;线程占有该monitor&lt;/strong&gt;时，owner 标记为该线程的唯一标识。当线程释放 monitor 时，owner又恢复为 NULL。owner 是一个临界资源，JVM 是通过 CAS 操作来保证其线程安全的。&lt;/li&gt;
&lt;li&gt;_cxq：竞争队列，&lt;strong&gt;所有请求锁的线程&lt;/strong&gt;首先会被放在这个队列中（单向链接）。_cxq 是一个临界资源，JVM 通过 CAS 原子指令来修改 _cxq 队列。修改前 _cxq 的旧值填入了 node 的 next 字段，_cxq 指向新值（新线程）。因此_cxq 是一个后进先出的 stack（栈）。&lt;/li&gt;
&lt;li&gt;_EntryList：_cxq 队列中&lt;strong&gt;有资格成为候选资源的线程&lt;/strong&gt;会被移动到该队列中。&lt;/li&gt;
&lt;li&gt;_WaitSet：因为&lt;strong&gt;调用wait方法而被阻塞&lt;/strong&gt;的线程会被放在该队列中。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/monitor%E7%9B%91%E8%A7%86%E5%99%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;每一个 Java 对象都可以与一个监视器 monitor 关联，我们可以把它理解成为一把锁，当一个线程想要执行一段被 synchronized 圈起来的同步方法或者代码块时，该线程得先获取到 synchronized 修饰的对象对应的 monitor。&lt;/p&gt;
&lt;p&gt;我们的 Java 代码里不会显示地去创造这么一个 monitor 对象，我们也无需创建，事实上可以这么理解： monitor 并不是随着对象创建而创建的。我们是通过 synchronized 修饰符告诉 JVM 需要为我们的某个对象创建关联的 monitor 对象。每个线程都存在两个 ObjectMonitor 对象列表，分别为free 和 used 列表。 同时 JVM 中也维护着 global locklist。当线程需要 ObjectMonitor 对象时，首先从线程自身的 free 表中申请，若存在则使用，若不存在则从 global list 中申请。&lt;/p&gt;
&lt;p&gt;ObjectMonitor 的数据结构中包含：_owner、_WaitSet 和 _EntryList，它们之间的关系转换可以用下图表示：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/monitor%E7%9B%91%E8%A7%86%E5%99%A8%E9%94%812.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;monitor竞争&#34;&gt;monitor竞争&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;什么时候会产生 monitor 竞争
&lt;ul&gt;
&lt;li&gt;两个线程同时执行 synchronized 时，会发生竞争。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;如何竞争&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;执行 monitorenter 时，会调用InterpreterRuntime.cpp&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(位于：src/share/vm/interpreter/interpreterRuntime.cpp) 的 InterpreterRuntime::monitorenter 函数。具体代码可参见 HotSpot 源码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))
#ifdef ASSERT
  thread-&amp;gt;last_frame().interpreter_frame_verify_monitor(elem);
#endif
  if (PrintBiasedLockingStatistics) {
    Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
  }
  Handle h_obj(thread, elem-&amp;gt;obj());
  assert(Universe::heap()-&amp;gt;is_in_reserved_or_null(h_obj()),
         &amp;quot;must be NULL or an object&amp;quot;);
  if (UseBiasedLocking) {//是否设置使用了偏向锁
    // Retry fast entry if bias is revoked to avoid unnecessary inflation
    ObjectSynchronizer::fast_enter(h_obj, elem-&amp;gt;lock(), true, CHECK);
  } else {  // 使用重量级锁
    ObjectSynchronizer::slow_enter(h_obj, elem-&amp;gt;lock(), CHECK);
  }
  assert(Universe::heap()-&amp;gt;is_in_reserved_or_null(elem-&amp;gt;obj()),
         &amp;quot;must be NULL or an object&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;对于重量级锁，monitorenter 函数中会调用 ObjectSynchronizer::slow_enter&lt;/li&gt;
&lt;li&gt;最终调用 ObjectMonitor::enter（位于：src/share/vm/runtime/objectMonitor.cpp），源码如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;void ATTR ObjectMonitor::enter(TRAPS) { 
  // The following code is ordered to check the most common cases first 
  // and to reduce RTS-&amp;gt;RTO cache line upgrades on SPARC and IA32 processors. 
  Thread * const Self = THREAD ; 
  void * cur ; 
  
  // 通过CAS操作尝试把monitor的_owner字段设置为当前线程 
  cur = Atomic::cmpxchg_ptr (Self， &amp;amp;_owner， NULL) ; 
  if (cur == NULL) { 
    // Either ASSERT _recursions == 0 or explicitly set _recursions = 0. 
    assert (_recursions == 0 ， &amp;quot;invariant&amp;quot;) ; 
    assert (_owner == Self， &amp;quot;invariant&amp;quot;) ; 
    // CONSIDER: set or assert OwnerIsThread == 1 
    return ; 
  }
  // 线程重入，recursions++ 
  if (cur == Self) { 
    // TODO-FIXME: check for integer overflow! BUGID 6557169. 
    _recursions ++ ; 
    return ; 
  }
  
  // 如果当前线程是第一次进入该monitor，设置_recursions为1，_owner为当前线程
  if (Self-&amp;gt;is_lock_owned ((address)cur)) {
    assert (_recursions == 0， &amp;quot;internal state error&amp;quot;);
    _recursions = 1 ;
    // Commute owner from a thread-specific on-stack BasicLockObject address to
    // a full-fledged &amp;quot;Thread *&amp;quot;.
    _owner = Self ;
    OwnerIsThread = 1 ;
    return ;
  }
  
  // 省略一些代码
  for (;;) {
    jt-&amp;gt;set_suspend_equivalent();
    // cleared by handle_special_suspend_equivalent_condition()
    // or java_suspend_self()
    
    // 如果获取锁失败，则阻塞，等待锁的释放，进入_cxq列表；
    EnterI (THREAD) ;
    
    if (!ExitSuspendEquivalent(jt)) break ;

  //
  // We have acquired the contended monitor， but while we were
  // waiting another thread suspended us. We don&#39;t want to enter
  // the monitor while suspended because that would surprise the
  // thread that suspended us.
  //
      _recursions = 0 ;
    _succ = NULL ;
    exit (false， Self) ;
  
    jt-&amp;gt;java_suspend_self();
  }
  Self-&amp;gt;set_current_pending_monitor(NULL);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此处省略锁的自旋优化等操作，统一放在后面synchronzied优化中说。&lt;br&gt;
以上代码的具体流程概括如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过CAS尝试把 monitor 的 owner 字段设置为当前线程。&lt;/li&gt;
&lt;li&gt;如果设置之前的 owner 指向当前线程，说明当前线程再次进入monitor，即重入锁，执行 _recursions++ ，记录重入的次数。&lt;/li&gt;
&lt;li&gt;如果当前线程是第一次进入该 monitor，设置 _recursions 为 1，_owner 为当前线程，该线程成功获得锁并返回。&lt;/li&gt;
&lt;li&gt;如果获取锁失败，则等待锁的释放。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;monitor等待&#34;&gt;monitor等待&lt;/h3&gt;
&lt;p&gt;竞争失败等待调用的是 ObjectMonitor 对象的 EnterI 方法（位于：src/share/vm/runtime/objectMonitor.cpp），源码如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void ATTR ObjectMonitor::EnterI (TRAPS) { 
  Thread * Self = THREAD ;
  
  // Try the lock - TATAS 
  if (TryLock (Self) &amp;gt; 0) { 
    assert (_succ != Self , &amp;quot;invariant&amp;quot;) ; 
    assert (_owner == Self , &amp;quot;invariant&amp;quot;) ; 
    assert (_Responsible != Self , &amp;quot;invariant&amp;quot;) ; 
    return ; 
  }
  
  if (TrySpin (Self) &amp;gt; 0) { 
    assert (_owner == Self , &amp;quot;invariant&amp;quot;) ; 
    assert (_succ != Self , &amp;quot;invariant&amp;quot;) ; 
    assert (_Responsible != Self , &amp;quot;invariant&amp;quot;) ; 
    return ; 
  }
  
  // 省略部分代码 
  
  // 当前线程被封装成ObjectWaiter对象node，状态设置成ObjectWaiter::TS_CXQ； 
  ObjectWaiter node(Self) ; 
  Self-&amp;gt;_ParkEvent-&amp;gt;reset() ; 
  node._prev = (ObjectWaiter *) 0xBAD ; 
  node.TState = ObjectWaiter::TS_CXQ ; 
  
  // 通过CAS把node节点push到_cxq列表中 
  ObjectWaiter * nxt ; 
  for (;;) { 
    node._next = nxt = _cxq ; 
    if (Atomic::cmpxchg_ptr (&amp;amp;node， &amp;amp;_cxq， nxt) == nxt) break ; 
    
    // Interference - the CAS failed because _cxq changed. Just retry. 
    // As an optional optimization we retry the lock. 
    if (TryLock (Self) &amp;gt; 0) { 
      assert (_succ != Self ， &amp;quot;invariant&amp;quot;) ; 
      assert (_owner == Self ， &amp;quot;invariant&amp;quot;) ; 
      assert (_Responsible != Self ， &amp;quot;invariant&amp;quot;) ; 
      return ; 
    } 
  }
  
  // 省略部分代码 
  for (;;) { 
    // 线程在被挂起前做一下挣扎，看能不能获取到锁 
    if (TryLock (Self) &amp;gt; 0) break ; 
    assert (_owner != Self， &amp;quot;invariant&amp;quot;) ; 
    if ((SyncFlags &amp;amp; 2) &amp;amp;&amp;amp; _Responsible == NULL) { 
      Atomic::cmpxchg_ptr (Self， &amp;amp;_Responsible， NULL) ; 
    }
    
    // park self 
    if (_Responsible == Self || (SyncFlags &amp;amp; 1)) { 
      TEVENT (Inflated enter - park TIMED) ; 
      Self-&amp;gt;_ParkEvent-&amp;gt;park ((jlong) RecheckInterval) ; 
      // Increase the RecheckInterval， but clamp the value. 
      RecheckInterval *= 8 ; 
      if (RecheckInterval &amp;gt; 1000) RecheckInterval = 1000 ; 
    } else { 
      TEVENT (Inflated enter - park UNTIMED) 
      // 通过park将当前线程挂起，等待被唤醒 
      Self-&amp;gt;_ParkEvent-&amp;gt;park() ; 
    }
    // 被唤醒后尝试获取锁
    if (TryLock(Self) &amp;gt; 0) break ; 
    // 省略部分代码 
  }
  
  // 省略部分代码 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当该线程被唤醒时，会从挂起的点继续执行，通过 ObjectMonitor::TryLock 尝试获取锁，TryLock方法实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int ObjectMonitor::TryLock (Thread * Self) { 
  for (;;) { 
    void * own = _owner ; 
    if (own != NULL) return 0 ; 
    // CAS 尝试获取锁
    if (Atomic::cmpxchg_ptr (Self， &amp;amp;_owner， NULL) == NULL) { 
      // Either guarantee _recursions == 0 or set _recursions = 0. 
      assert (_recursions == 0， &amp;quot;invariant&amp;quot;) ; 
      assert (_owner == Self， &amp;quot;invariant&amp;quot;) ; 
      // CONSIDER: set or assert that OwnerIsThread == 1 
      return 1 ; 
    }
    // The lock had been free momentarily， but we lost the race to the lock. 
    // Interference -- the CAS failed. 
    // We can either return -1 or retry. 
    // Retry doesn&#39;t make as much sense because the lock was just acquired. 
    if (true) return -1 ; 
  } 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上代码的具体流程概括如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当前线程被封装成 ObjectWaiter 对象 node，状态设置成 ObjectWaiter::TS_CXQ。&lt;/li&gt;
&lt;li&gt;在 for 循环中，通过 CAS 把 node 节点 push 到 _cxq 列表中，同一时刻可能有多个线程把自己的 node 节点 pus h到 _cxq 列表中。&lt;/li&gt;
&lt;li&gt;node 节点 push 到 _cxq 列表之后，通过自旋尝试获取锁，如果还是没有获取到锁，则通过 park 将当前线程挂起，等待被唤醒。&lt;/li&gt;
&lt;li&gt;当该线程被唤醒时，会从挂起的点继续执行，通过 ObjectMonitor::TryLock 尝试获取锁。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;monitor释放&#34;&gt;monitor释放&lt;/h3&gt;
&lt;p&gt;当某个持有锁的线程执行完同步代码块时，会进行锁的释放，给其它线程机会执行同步代码，在 HotSpot 中，通过退出 monitor 的方式实现锁的释放，并通知被阻塞的线程，具体实现位于 ObjectMonitor 的 exit 方法中。（位于：src/share/vm/runtime/objectMonitor.cpp），源码如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void ATTR ObjectMonitor::exit(bool not_suspended， TRAPS) { 
  Thread * Self = THREAD ; 
  // 省略部分代码 
  // 重入锁
  if (_recursions != 0) { 
    _recursions--; // this is simple recursive enterTEVENT (Inflated exit - recursive) ; 
    return ; 
  }
  
  // 省略部分代码 
  // 等待的线程用 ObjectWaiter 包装，使用变量 w 存放被唤醒的线程
  ObjectWaiter * w = NULL ; 
  int QMode = Knob_QMode ; 
  
  // qmode = 2：直接绕过EntryList队列，从cxq队列中获取线程用于竞争锁 
  if (QMode == 2 &amp;amp;&amp;amp; _cxq != NULL) { 
    w = _cxq ; // _cxq 的链表头赋值给 w
    assert (w != NULL， &amp;quot;invariant&amp;quot;) ; 
    assert (w-&amp;gt;TState == ObjectWaiter::TS_CXQ， &amp;quot;Invariant&amp;quot;) ; 
    ExitEpilog (Self， w) ; // 唤醒线程
    return ; 
  }
  
  // qmode =3：cxq队列插入EntryList尾部； 
  if (QMode == 3 &amp;amp;&amp;amp; _cxq != NULL) { 
    w = _cxq ; 
    for (;;) { 
      assert (w != NULL， &amp;quot;Invariant&amp;quot;) ; 
      ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL， 
      &amp;amp;_cxq， w) ; 
      if (u == w) break ; 
      w = u ; 
    }
    assert (w != NULL ， &amp;quot;invariant&amp;quot;) ; 
    
    ObjectWaiter * q = NULL ; 
    ObjectWaiter * p ; 
    for (p = w ; p != NULL ; p = p-&amp;gt;_next) { 
      guarantee (p-&amp;gt;TState == ObjectWaiter::TS_CXQ， &amp;quot;Invariant&amp;quot;) ; 
      p-&amp;gt;TState = ObjectWaiter::TS_ENTER ; 
      p-&amp;gt;_prev = q ; 
      q = p ; 
    }
    ObjectWaiter * Tail ; 
    for (Tail = _EntryList ; Tail != NULL &amp;amp;&amp;amp; Tail-&amp;gt;_next != NULL ; Tail = Tail-&amp;gt;_next) ; 
    if (Tail == NULL) { 
      _EntryList = w ; 
    } else { 
      Tail-&amp;gt;_next = w ; 
      w-&amp;gt;_prev = Tail ; 
    } 
  }
  
  // qmode =4：cxq队列插入到_EntryList头部 
  if (QMode == 4 &amp;amp;&amp;amp; _cxq != NULL) { 
    w = _cxq ; 
    for (;;) { 
      assert (w != NULL， &amp;quot;Invariant&amp;quot;) ; 
      ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL， 
      &amp;amp;_cxq， w) ; 
      if (u == w) break ; 
      w = u ;
    }
    assert (w != NULL ， &amp;quot;invariant&amp;quot;) ; 
    
    ObjectWaiter * q = NULL ; 
    ObjectWaiter * p ; 
    for (p = w ; p != NULL ; p = p-&amp;gt;_next) { 
      guarantee (p-&amp;gt;TState == ObjectWaiter::TS_CXQ， &amp;quot;Invariant&amp;quot;) ; 
      p-&amp;gt;TState = ObjectWaiter::TS_ENTER ; 
      p-&amp;gt;_prev = q ; 
      q = p ; 
    }
    if (_EntryList != NULL) { 
      q-&amp;gt;_next = _EntryList ; 
      _EntryList-&amp;gt;_prev = q ; 
    }
    _EntryList = w ; 
  }
  w = _EntryList ; 
  if (w != NULL) { 
    assert (w-&amp;gt;TState == ObjectWaiter::TS_ENTER， &amp;quot;invariant&amp;quot;) ; 
    ExitEpilog (Self， w) ; 
    return ; 
  }
  w = _cxq ; 
  if (w == NULL) continue ; 
  for (;;) { 
    assert (w != NULL， &amp;quot;Invariant&amp;quot;) ; 
    ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL， &amp;amp;_cxq，w) ; 
    if (u == w) break ; 
    w = u ; 
  }
  TEVENT (Inflated exit - drain cxq into EntryList) ; 
  assert (w != NULL ， &amp;quot;invariant&amp;quot;) ; 
  assert (_EntryList == NULL ， &amp;quot;invariant&amp;quot;) ; 
  if (QMode == 1) { 
    // QMode == 1 : drain cxq to EntryList， reversing order 
    // We also reverse the order of the list. 
    ObjectWaiter * s = NULL ; 
    ObjectWaiter * t = w ; 
    ObjectWaiter * u = NULL ; 
    while (t != NULL) { 
      guarantee (t-&amp;gt;TState == ObjectWaiter::TS_CXQ， &amp;quot;invariant&amp;quot;) ; 
      t-&amp;gt;TState = ObjectWaiter::TS_ENTER ; 
      u = t-&amp;gt;_next ; 
      t-&amp;gt;_prev = u ; 
      t-&amp;gt;_next = s ; 
      s = t; 
      t = u ; 
    }
    _EntryList = s ; 
    assert (s != NULL， &amp;quot;invariant&amp;quot;) ;
  } else { 
    // QMode == 0 or QMode == 2 
    _EntryList = w ; 
    ObjectWaiter * q = NULL ; 
    ObjectWaiter * p ; 
    for (p = w ; p != NULL ; p = p-&amp;gt;_next) { 
      guarantee (p-&amp;gt;TState == ObjectWaiter::TS_CXQ， &amp;quot;Invariant&amp;quot;) ; 
      p-&amp;gt;TState = ObjectWaiter::TS_ENTER ; 
      p-&amp;gt;_prev = q ; 
      q = p ; 
      } 
    }
    if (_succ != NULL) continue; 
    
    w = _EntryList ; 
    if (w != NULL) { 
      guarantee (w-&amp;gt;TState == ObjectWaiter::TS_ENTER， &amp;quot;invariant&amp;quot;) ; 
      ExitEpilog (Self， w) ; // 唤醒线程
      return ; 
    } 
  } 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;退出同步代码块时会让 _recursions 减 1，当 _recursions 的值减为0时，说明线程释放了锁。&lt;/li&gt;
&lt;li&gt;根据不同的策略（由QMode指定），从 _cxq 或 EntryList 中获取头节点，通过ObjectMonitor::ExitEpilog 方法唤醒该节点封装的线程，唤醒操作最终由 unpark 完成，实现如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;void ObjectMonitor::ExitEpilog (Thread * Self， ObjectWaiter * Wakee) { 
  assert (_owner == Self， &amp;quot;invariant&amp;quot;) ; 
  
  _succ = Knob_SuccEnabled ? Wakee-&amp;gt;_thread : NULL ; 
  ParkEvent * Trigger = Wakee-&amp;gt;_event ; 
  
  Wakee = NULL ; 
  
  // Drop the lock 
  OrderAccess::release_store_ptr (&amp;amp;_owner， NULL) ; 
  OrderAccess::fence() ; // ST _owner vs LD in 
  unpark() 
  if (SafepointSynchronize::do_call_back()) { 
    TEVENT (unpark before SAFEPOINT) ; 
  }
  
  DTRACE_MONITOR_PROBE(contended__exit， this， object()， Self); 
  Trigger-&amp;gt;unpark() ; // 唤醒之前被pack()挂起的线程. 
  
  // Maintain stats and report events to JVMTI 
  if (ObjectMonitor::_sync_Parks != NULL) { 
    ObjectMonitor::_sync_Parks-&amp;gt;inc() ; 
  } 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;被唤醒的线程，会回到 void ATTR ObjectMonitor::EnterI (TRAPS) 的第600行，继续执行monitor 的竞争。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// park self 
if (_Responsible == Self || (SyncFlags &amp;amp; 1)) { 
  TEVENT (Inflated enter - park TIMED) ; 
  Self-&amp;gt;_ParkEvent-&amp;gt;park ((jlong) RecheckInterval) ; 
  // Increase the RecheckInterval， but clamp the value. 
  RecheckInterval *= 8 ; 
  if (RecheckInterval &amp;gt; 1000) RecheckInterval = 1000 ; 
} else { 
  TEVENT (Inflated enter - park UNTIMED) ; 
  Self-&amp;gt;_ParkEvent-&amp;gt;park() ; 
}
if (TryLock(Self) &amp;gt; 0) break ;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;monitor是重量级锁&#34;&gt;monitor是重量级锁&lt;/h3&gt;
&lt;p&gt;可以看到 ObjectMonitor 的函数调用中会涉及到 Atomic::cmpxchg_ptr，Atomic::inc_ptr 等内核函数，执行同步代码块，没有竞争到锁的对象会 park() 被挂起，竞争到锁的线程会 unpark() 唤醒。这个时候就会存在操作系统&lt;strong&gt;用户态和内核态的转换&lt;/strong&gt;，这种切换会消耗大量的系统资源。所以synchronized 是 Java 语言中是一个重量级(Heavyweight)的操作。&lt;/p&gt;
&lt;p&gt;用户态和和内核态是什么东西呢？要想了解用户态和内核态还需要先了解一下 Linux 系统的体系架构：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center&#34;&gt;Linux系统的体系架构&lt;/p&gt;
&lt;p&gt;从上图可以看出，Linux操作系统的体系架构分为：用户空间（应用程序的活动空间）和内核。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内核&lt;/strong&gt;：本质上可以理解为一种软件，控制计算机的硬件资源，并提供上层应用程序运行的环境。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户空间&lt;/strong&gt;：上层应用程序活动的空间。应用程序的执行必须依托于内核提供的资源，包括CPU资源、存储资源、I/O资源等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系统调用&lt;/strong&gt;：为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用。&lt;/p&gt;
&lt;p&gt;所有进程初始都运行于用户空间，此时即为用户运行状态（简称：用户态）；但是当它调用系统调用执行某些操作时，例如 I/O调用，此时需要陷入内核中运行，我们就称进程处于内核运行态（或简称为内核态）。 系统调用的过程可以简单理解为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户态程序将一些数据值放在寄存器中， 或者使用参数创建一个堆栈， 以此表明需要操作系统提供的服务。&lt;/li&gt;
&lt;li&gt;用户态程序执行系统调用。&lt;/li&gt;
&lt;li&gt;CPU切换到内核态，并跳到位于内存指定位置的指令。&lt;/li&gt;
&lt;li&gt;系统调用处理器(system call handler)会读取程序放入内存的数据参数，并执行程序请求的服务。&lt;/li&gt;
&lt;li&gt;系统调用完成后，操作系统会重置CPU为用户态并返回系统调用的结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由此可见用户态切换至内核态需要传递许多变量，同时内核还需要保护好用户态在切换时的一些寄存器值、变量等，以备内核态切换回用户态。&lt;strong&gt;这种切换就带来了大量的系统资源消耗&lt;/strong&gt;，这就是在 synchronized 未优化之前，效率低的原因。&lt;/p&gt;
&lt;h1 id=&#34;第六章jdk6-synchronized优化&#34;&gt;第六章：JDK6 synchronized优化&lt;/h1&gt;
&lt;h2 id=&#34;cas&#34;&gt;CAS&lt;/h2&gt;
&lt;p&gt;CAS的全称是： Compare And Swap(比较相同再交换)。是现代CPU广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。&lt;/p&gt;
&lt;p&gt;CAS的作用：CAS可以将比较和交换转换为原子操作，这个&lt;strong&gt;原子操作直接由CPU保证&lt;/strong&gt;。CAS可以保证共享变量赋值时的原子操作。CAS操作依赖3个值：内存中的值V，旧的预估值X，要修改的新值B，如果旧的预估值X等于内存中的值V，就将新的值B保存到内存中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CAS 和 volatile 实现无锁并发&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.itheima.demo05_cas;
import java.util.ArrayList;
import java.util.concurrent.atomic.AtomicInteger;
public class Demo01 {
    public static void main(String[] args) throws InterruptedException {
        AtomicInteger atomicInteger = new AtomicInteger();
        Runnable mr = () -&amp;gt; {
            for (int i = 0; i &amp;lt; 1000; i++) {
                atomicInteger.incrementAndGet();
            }
        };
        ArrayList&amp;lt;Thread&amp;gt; ts = new ArrayList&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; 5; i++) {
            Thread t = new Thread(mr);
            t.start();
            ts.add(t);
        }
        for (Thread t : ts) {
            t.join();
        }
        System.out.println(&amp;quot;atomicInteger = &amp;quot; + atomicInteger.get());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;atomicInteger  = 5000
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;cas原理&#34;&gt;CAS原理&lt;/h3&gt;
&lt;p&gt;通过刚才 AtomicInteger 的源码我们可以看到，Unsafe 类提供了原子操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Unsafe类介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Unsafe 类使 Java 拥有了像 C 语言的指针一样操作内存空间的能力，同时也带来了指针的问题。过度的使用 Unsafe 类会使得出错的几率变大，因此 Java 官方并不建议使用的，官方文档也几乎没有。Unsafe 对象不能直接调用，只能通过反射获得。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/unsafe%E7%B1%BB.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;public class AtomicInteger extends Number implements java.io.Serializable {
    private static final long serialVersionUID = 6214790243416807050L;

    // setup to use Unsafe.compareAndSwapInt for updates
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    // value 的偏移地址
    private static final long valueOffset;

    static {
        try {
            valueOffset = unsafe.objectFieldOffset
                (AtomicInteger.class.getDeclaredField(&amp;quot;value&amp;quot;));
        } catch (Exception ex) {
             throw new Error(ex); 
        }
    }
    // 数字保存在 value 中。根据 AtomicInteger 对象的内存地址 和 value 的偏移地址，找到 value 的值
    private volatile int value;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Unsafe实现CAS&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/unsafe%E5%AE%9E%E7%8E%B0CAS.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;乐观锁和悲观锁&#34;&gt;乐观锁和悲观锁&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;悲观锁&lt;/strong&gt;从悲观的角度出发：&lt;/p&gt;
&lt;p&gt;总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞。因此&lt;strong&gt;synchronized&lt;/strong&gt;我们也将其称之为悲观锁。JDK中的&lt;strong&gt;ReentrantLock&lt;/strong&gt;也是一种悲观锁。性能较差！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;乐观锁&lt;/strong&gt;从乐观的角度出发:&lt;/p&gt;
&lt;p&gt;总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，就算改了也没关系，再重试即可。所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去修改这个数据，如果没有人修改则更新，如果有人修改则重试。&lt;/p&gt;
&lt;p&gt;CAS这种机制我们也可以将其称之为乐观锁。综合性能较好！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CAS获取共享变量时，为了保证该变量的可见性，需要使用volatile修饰。结合CAS和volatile可以实现无锁并发，适用于竞争不激烈、多核 CPU 的场景下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一。&lt;/li&gt;
&lt;li&gt;但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;小结-12&#34;&gt;小结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CAS的作用?&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Compare And Swap，CAS可以将比较和交换转换为原子操作，这个原子操作直接由处理器保证。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CAS的原理？&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;CAS需要3个值:内存地址V，旧的预期值A，要修改的新值B，如果内存地址V和旧的预期值A相等就修改内存地址值为B&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;synchronized锁升级过程&#34;&gt;synchronized锁升级过程&lt;/h2&gt;
&lt;p&gt;高效并发是从 JDK5 到 JDK6 的一个重要改进，HotSpot 虛拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术，包括偏向锁( Biased Locking )、轻量级锁( Lightweight Locking )和如适应性自旋(Adaptive Spinning)、锁消除( Lock Elimination)、锁粗化( Lock Coarsening )等，这些技术都是为了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无锁 --&amp;gt; 偏向锁 --&amp;gt; 轻量级锁 –&amp;gt; 重量级锁&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;java对象的布局&#34;&gt;Java对象的布局&lt;/h2&gt;
&lt;p&gt;术语参考: &lt;a href=&#34;http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html&#34;&gt;http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。如下图所示：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%AF%B9%E8%B1%A1%E5%A4%B4.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;对象头&#34;&gt;对象头&lt;/h3&gt;
&lt;p&gt;当一个线程尝试访问 synchronized 修饰的代码块时，它首先要获得锁，那么这个锁到底存在哪里呢？是存在锁对象的对象头中的。&lt;/p&gt;
&lt;p&gt;HotSpot 采用 instanceOopDesc 和 arrayOopDesc 来描述对象头，arrayOopDesc 对象用来描述数组类型。instanceOopDesc 的定义的在 Hotspot 源码的 instanceOop.hpp 文件中，另外，arrayOopDesc 的定义对应 arrayOop.hpp 。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class instanceOopDesc : public oopDesc {
    public:
    // aligned header size.
    static int header_size() { return sizeof(instanceOopDesc)/HeapWordSize; }
    // If compressed, the offset of the fields of the instance may not be aligned.
    static int base_offset_in_bytes() {
    // offset computation code breaks if UseCompressedClassPointers
    // only is true
            return (UseCompressedOops &amp;amp;&amp;amp; UseCompressedClassPointers) ?
            klass_gap_offset_in_bytes() :
            sizeof(instanceOopDesc);
    }
    static bool contains_field_offset(int offset, int nonstatic_field_size) {
        int base_in_bytes = base_offset_in_bytes();
        return (offset &amp;gt;= base_in_bytes &amp;amp;&amp;amp;
            (offset-base_in_bytes) &amp;lt; nonstatic_field_size * heapOopSize);
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从 instanceOopDesc 代码中可以看到 instanceOopDesc 继承自 oopDesc，oopDesc 的定义在Hotspot 源码中的 oop.hpp 文件中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class oopDesc {
    friend class VMStructs;
   private:
    volatile markOop _mark;
    union _metadata {
        Klass* _klass;
        narrowKlass _compressed_klass;
    } _metadata;
// Fast access to barrier set. Must be initialized. 
    static BarrierSet* _bs;
// 省略其他代码 
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在普通实例对象中，oopDesc 的定义包含两个成员，分别是 _mark 和 _metadata&lt;/p&gt;
&lt;p&gt;_mark 表示&lt;strong&gt;对象标记&lt;/strong&gt;、属于 markOop 类型，也就是接下来要讲解的 Mark World，它记录了&lt;strong&gt;对象和锁有关的信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;_metadata 表示&lt;strong&gt;类元信息&lt;/strong&gt;，类元信息存储的是&lt;strong&gt;对象指向它的类元数据(Klass)的首地址&lt;/strong&gt;，其中 Klass 表示普通指针、 _compressed_klass 表示压缩类指针。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%AF%B9%E8%B1%A1%E5%A4%B4.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;对象头由两部分组成，一部分用于存储自身的运行时数据，称之为 Mark Word，另外一部分是类型指针，及对象指向它的类元数据的指针。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mark Word&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Mark Word用于存储&lt;strong&gt;对象自身的运行时数据&lt;/strong&gt;，如&lt;strong&gt;哈希码（HashCode）、GC分代年龄、锁状态标志、 线程持有的锁、偏向线程ID、偏向时间戳&lt;/strong&gt;等等，占用内存大小与虚拟机位长一致。Mark Word对应的类型是 markOop 。源码位于 markOop.hpp 中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Bit-format of an object header (most significant first, big endian layout below): 
//
// 32 bits: 
// -------- 
// hash:25 ------------&amp;gt;| age:4 biased_lock:1 lock:2 (normal object)// JavaThread*:23 epoch:2 age:4 biased_lock:1 lock:2 (biased object) 
// size:32 ------------------------------------------&amp;gt;| (CMS free block) 
// PromotedObject*:29 ----------&amp;gt;| promo_bits:3 -----&amp;gt;| (CMS promoted object) 
//
// 64 bits: 
// -------- 
// unused:25 hash:31 --&amp;gt;| unused:1 age:4 biased_lock:1 lock:2 (normal object) 
// JavaThread*:54 epoch:2 unused:1 age:4 biased_lock:1 lock:2 (biased object) 
// PromotedObject*:61 ---------------------&amp;gt;| promo_bits:3 -----&amp;gt;| (CMS promoted object) 
// size:64 -----------------------------------------------------&amp;gt;| (CMS free block) 
// [JavaThread* | epoch | age | 1 | 01] lock is biased toward given thread 
// [0 | epoch | age | 1 | 01] lock is anonymously biased 
//
// - the two lock bits are used to describe three states: locked/unlocked and monitor. 
//
// [ptr | 00] locked ptr points to real header on stack 
// [header | 0 | 01] unlocked regular object header 
// [ptr | 10] monitor inflated lock (header is wapped out) 
// [ptr | 11] marked used by markSweep to mark an object 
// not valid at any other time 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%AF%B9%E8%B1%A1%E5%A4%B42.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在64位虚拟机下，Mark Word 是 64bit 大小的，其存储结构如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/64%E4%BD%8D%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E5%A4%B4.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在32位虚拟机下，Mark Word 是 32bit 大小的，其存储结构如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/32%E4%BD%8D%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E5%A4%B4.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;klass pointer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一部分用于存储对象的类型指针，该指针指向它的类元数据，JVM通过这个指针确定对象是&lt;strong&gt;哪个类的实例&lt;/strong&gt;。该指针的位长度为 JVM 的一个字大小，即 32 位的 JVM 为 32 位，64 位的 JVM 为 64 位。&lt;/p&gt;
&lt;p&gt;如果应用的对象过多，使用 64 位的指针将浪费大量内存，统计而言，64 位的 JVM 将会比 32 位的 JVM 多耗费 50% 的内存。为了节约内存可以使用选项 &lt;code&gt;-XX:+UseCompressedOops&lt;/code&gt; 开启指针压缩，其中，oop 即 ordinary object pointer 普通对象指针。开启该选项后，下列指针将压缩至 32 位：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个Class的属性指针（即静态变量）&lt;/li&gt;
&lt;li&gt;每个对象的属性指针（即对象变量）&lt;/li&gt;
&lt;li&gt;普通对象数组的每个元素指针&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然，也不是所有的指针都会压缩，一些特殊类型的指针 JVM 不会优化，比如指向 PermGen 的 Class 对象指针(JDK8 中指向元空间的 Class 对象指针)、本地变量、堆栈元素、入参、返回值和 NULL 指针等。&lt;/p&gt;
&lt;p&gt;对象头 = Mark Word + 类型指针（未开启指针压缩的情况下）&lt;/p&gt;
&lt;p&gt;在32位系统中，Mark Word = 4 bytes，类型指针 = 4bytes，对象头 = 8 bytes = 64 bits；&lt;/p&gt;
&lt;p&gt;在64位系统中，Mark Word = 8 bytes，类型指针 = 8bytes，对象头 = 16 bytes = 128bits；&lt;/p&gt;
&lt;h3 id=&#34;实例数据&#34;&gt;实例数据&lt;/h3&gt;
&lt;p&gt;就是类中定义的成员变量。&lt;/p&gt;
&lt;h3 id=&#34;对齐填充&#34;&gt;对齐填充&lt;/h3&gt;
&lt;p&gt;对齐填充并不是必然存在的，也没有什么特别的意义，他仅仅起着占位符的作用，由于 HotSpot VM 的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头正好是8字节的倍数，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。&lt;/p&gt;
&lt;h3 id=&#34;查看java对象布局&#34;&gt;查看Java对象布局&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.openjdk.jol&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;jol-core&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;0.9&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com.itheima.demo06_object_layout;

public class LockObj {
    private int x;
    private boolean b;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com.itheima.demo06_object_layout;

import org.openjdk.jol.info.ClassLayout;

public class Demo01 {
    public static void main(String[] args) {
        LockObj obj = new LockObj();

        obj.hashCode();
        System.out.println(obj.hashCode());
        System.out.println(Integer.toHexString(obj.hashCode()));

        System.out.println(ClassLayout.parseInstance(obj).toPrintable());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%AF%B9%E8%B1%A1%E5%A4%B43.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;小结-13&#34;&gt;小结&lt;/h3&gt;
&lt;p&gt;Java对象由3部分组成，对象头，实例数据，对齐数据&lt;/p&gt;
&lt;p&gt;对象头分成两部分：Mark World + Klass pointer&lt;/p&gt;
&lt;h2 id=&#34;偏向锁&#34;&gt;偏向锁&lt;/h2&gt;
&lt;p&gt;偏向锁是 JDK6 中的重要引进，因为HotSpot作者经过研究实践发现，在大多数情况下，&lt;strong&gt;锁不仅不存在多线程竞争，而且总是由同一线程多次获得&lt;/strong&gt;，为了让线程获得锁的代价更低，引进了偏向锁。&lt;/p&gt;
&lt;p&gt;偏向锁的“偏”，就是偏心的“偏”、偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程，会在对象头存储锁偏向的线程ID，以后该线程进入和退出同步块时只需要检查是否为偏向锁、锁标志位以 ThreadID 即可。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;25&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%81%8F%E5%90%91%E9%94%81.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;不过&lt;strong&gt;一旦出现多个线程竞争时必须撤销偏向锁&lt;/strong&gt;，所以撤销偏向锁消耗的性能必须小于之前节省下来的CAS原子操作的性能消耗，不然就得不偿失了。&lt;/p&gt;
&lt;h3 id=&#34;偏向锁原理&#34;&gt;偏向锁原理&lt;/h3&gt;
&lt;p&gt;当线程第一次访问同步块并获取锁时，偏向锁处理流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;虚拟机将会把对象头中的标志位设为“01”，即偏向模式。&lt;/li&gt;
&lt;li&gt;同时使用 CAS 操作把获取到这个锁的线程的 ID 记录在对象的 Mark Word 之中 ，如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;26&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%81%8F%E5%90%91%E9%94%81.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以&lt;strong&gt;不再进行任何同步操作&lt;/strong&gt;，偏向锁的效率高。&lt;/p&gt;
&lt;h3 id=&#34;偏向锁的撤销&#34;&gt;偏向锁的撤销&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;偏向锁的撤销动作必须等待&lt;strong&gt;全局安全点&lt;/strong&gt; （所有线程都停下来的点。举例：统计 9 点某地有多少人，9 点让所有人停下来，不能进出，开始统计）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;暂停拥有偏向锁的线程&lt;/strong&gt;，判断锁对象是否处于被锁定状态&lt;/li&gt;
&lt;li&gt;撤销偏向锁，恢复到无锁（标志位为 &lt;strong&gt;01&lt;/strong&gt;）或轻量级锁（标志位为 &lt;strong&gt;00&lt;/strong&gt;）的状态&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;偏向锁在 Java6 之后是默认启用的，但在应用程序启动几秒钟之后才激活，可以使用 &lt;code&gt;-XX:BiasedLockingStartupDelay=0&lt;/code&gt; 参数关闭延迟，如果确定应用程序中所有锁通常情况下处于竞争状态，可以通过 &lt;code&gt;XX:-UseBiasedLocking=false&lt;/code&gt; 参数关闭偏向锁。&lt;/p&gt;
&lt;h3 id=&#34;偏向锁好处&#34;&gt;偏向锁好处&lt;/h3&gt;
&lt;p&gt;偏向锁是在只有一个线程执行同步块时进一步提高性能，适用于&lt;strong&gt;一个线程反复获得同一锁&lt;/strong&gt;的情况。偏向锁可以提高带有同步但无竞争的程序性能。&lt;/p&gt;
&lt;p&gt;它同样是一个带有效益权衡性质的优化，也就是说，它并不一定总是对程序运行有利，如果程序中&lt;strong&gt;大多数的锁总是被多个不同的线程访问&lt;/strong&gt;比如&lt;strong&gt;线程池&lt;/strong&gt;，那偏向模式就是多余的。&lt;/p&gt;
&lt;p&gt;在 JDK5 中偏向锁默认是关闭的，而到了 JDK6 中偏向锁已经默认开启。但在应用程序启动几秒钟之后才激活，可以使用 &lt;code&gt;-XX:BiasedLockingStartupDelay=0&lt;/code&gt; 参数关闭延迟，如果确定应用程序中所有锁通常情况下处于竞争状态，可以通过 &lt;code&gt;XX:-UseBiasedLocking=false&lt;/code&gt; 参数关闭偏向锁。&lt;/p&gt;
&lt;h3 id=&#34;小结-14&#34;&gt;小结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;偏向锁的原理是什么?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，偏向锁设置为“1”，即偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中 ，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;偏向锁的好处是什么?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;偏向锁是在只有一个线程执行同步块时进一步提高性能，适用于&lt;strong&gt;一个线程反复获得同一锁&lt;/strong&gt;的情况。偏向锁可以提高带有同步但无竞争的程序性能。&lt;/p&gt;
&lt;h2 id=&#34;轻量级锁&#34;&gt;轻量级锁&lt;/h2&gt;
&lt;p&gt;轻量级锁是 JDK6 之中加入的新型锁机制，它名字中的“轻量级”是相对于使用 monitor 的传统锁而言的，因此传统的锁机制就称为“重量级”锁。首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的。&lt;/p&gt;
&lt;p&gt;引入轻量级锁的目的：在&lt;strong&gt;多线程交替执行同步块&lt;/strong&gt;的情况下，尽量避免重量级锁引起的性能消耗，但是如果多个线程在同一时刻进入临界区，会导致轻量级锁膨胀升级重量级锁，所以轻量级锁的出现并非是要替代重量级锁。&lt;/p&gt;
&lt;h3 id=&#34;轻量级锁原理&#34;&gt;轻量级锁原理&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;27&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%86.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步骤如下： 获取锁&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;判断当前对象是否处于无锁状态（hashcode、0、01），如果是，则 JVM 首先将在当前线程的&lt;strong&gt;栈帧&lt;/strong&gt;中建立一个名为&lt;strong&gt;锁记录&lt;/strong&gt;（Lock Record）的空间，用于存储&lt;strong&gt;锁对象目前的 Mark Word 的拷贝&lt;/strong&gt;（官方把这份拷贝加了一个 Displaced 前缀，即 Displaced Mark Word），将对象的 Mark Word 复制到栈帧中的 Lock Record 中，将 Lock Reocrd 中的 owner 指向当前对象。&lt;/li&gt;
&lt;li&gt;JVM 利用 CAS 操作尝试&lt;strong&gt;将对象的 Mark Word 更新为指向 Lock Record 的指针&lt;/strong&gt;，如果&lt;strong&gt;成功&lt;/strong&gt;表示&lt;strong&gt;竞争到锁&lt;/strong&gt;，则将锁标志位变成 00，执行同步操作。&lt;/li&gt;
&lt;li&gt;如果失败则&lt;strong&gt;判断当前对象的 Mark Word 是否指向当前线程的栈帧&lt;/strong&gt;，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成 10，后面等待的线程将会进入阻塞状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81CAS%E6%93%8D%E4%BD%9C%E4%B9%8B%E5%89%8D%E5%A0%86%E6%A0%88%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%8A%B6%E6%80%81.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81CAS%E6%93%8D%E4%BD%9C%E4%B9%8B%E5%90%8E%E5%A0%86%E6%A0%88%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%8A%B6%E6%80%81.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;轻量级锁的释放&#34;&gt;轻量级锁的释放&lt;/h3&gt;
&lt;p&gt;轻量级锁的释放也是通过 CAS 操作来进行的，主要步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;取出在获取轻量级锁保存在 Displaced Mark Word 中的数据。&lt;/li&gt;
&lt;li&gt;用 CAS 操作将取出的数据替换当前对象的 Mark Word 中，如果成功，则说明释放锁成功。&lt;/li&gt;
&lt;li&gt;如果 CAS 操作替换失败，说明有其他线程尝试获取该锁，则需要将轻量级锁需要膨胀升级为重量级锁。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，&lt;strong&gt;在整个生命周期内都是不会存在竞争的&lt;/strong&gt;”，如果打破这个依据则除了互斥的开销外，还有额外的 CAS 操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢。&lt;/p&gt;
&lt;h3 id=&#34;轻量级锁好处&#34;&gt;轻量级锁好处&lt;/h3&gt;
&lt;p&gt;在多线程&lt;strong&gt;交替&lt;/strong&gt;执行同步块的情况下，可以避免重量级锁引起的性能消耗。&lt;/p&gt;
&lt;h3 id=&#34;小结-15&#34;&gt;小结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;轻量级锁的原理是什么？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将对象的 Mark Word 复制到栈帧中的 Lock Recod 中。Mark Word 更新为指向 Lock Record 的指针。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;轻量级锁好处是什么？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。&lt;/p&gt;
&lt;h2 id=&#34;自旋锁&#34;&gt;自旋锁&lt;/h2&gt;
&lt;h3 id=&#34;自旋锁原理&#34;&gt;自旋锁原理&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;synchronized (Demo01.class) {
  ...
  System.out.println(&amp;quot;aaa&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前面我们讨论 monitor 实现锁的时候，知道monitor会阻塞和唤醒线程，线程的阻塞和唤醒需要CPU从用户态转为核心态，&lt;strong&gt;频繁的阻塞和唤醒对CPU来说是一件负担很重的工作&lt;/strong&gt;，这些操作给系统的并发性能带来了很大的压力。同时，虚拟机的开发团队也注意到在许多应用上，&lt;strong&gt;共享数据的锁定状态只会持续很短的一段时间&lt;/strong&gt;，为了这段时间阻塞和唤醒线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个&lt;strong&gt;忙循环(自旋) ,&lt;/strong&gt; 这项技术就是所谓的&lt;strong&gt;自旋锁&lt;/strong&gt;。&lt;br&gt;
自旋锁在 JDK1.4.2 中就已经引入 ，只不过默认是关闭的，可以使用 &lt;code&gt;-XX:+UseSpinning&lt;/code&gt; 参数开启，在 JDK6 中就已经改为默认开启了。自旋等待不能代替阻塞，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，&lt;strong&gt;如果锁被占用的时间很短，自旋等待的效果就会非常好&lt;/strong&gt;，反之，如果锁被占用的时间很长。那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。因此，自旋等待的时间必须要有一定的限度，如果在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是10次，用户可以使用参数 &lt;code&gt;-XX:PreBlockSpin&lt;/code&gt;来更改。&lt;/p&gt;
&lt;h3 id=&#34;适应性自旋锁&#34;&gt;适应性自旋锁&lt;/h3&gt;
&lt;p&gt;在 JDK6 中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是&lt;strong&gt;由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定&lt;/strong&gt;。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100次循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虛拟机就会变得越来越“聪明”了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int ObjectMonitor::TrySpin_VaryDuration (Thread * Self) {

    // Dumb, brutal spin.  Good for comparative measurements against adaptive spinning.
    // 固定次数的自旋锁
    int ctr = Knob_FixedSpin ;
    if (ctr != 0) {
        while (--ctr &amp;gt;= 0) {
            if (TryLock (Self) &amp;gt; 0) return 1 ;
            SpinPause () ;
        }
        return 0 ;
    }
    // 适应性自旋锁
    for (ctr = Knob_PreSpin + 1; --ctr &amp;gt;= 0 ; ) {
      // 如果抢到了锁
      if (TryLock(Self) &amp;gt; 0) {
        // Increase _SpinDuration ...
        // Note that we don&#39;t clamp SpinDuration precisely at SpinLimit.
        // Raising _SpurDuration to the poverty line is key.
        int x = _SpinDuration ;
        if (x &amp;lt; Knob_SpinLimit) {
           if (x &amp;lt; Knob_Poverty) x = Knob_Poverty ;
           // 修改自旋时间
           _SpinDuration = x + Knob_BonusB ;
        }
        return 1 ;
      }
      SpinPause () ;
    }

    // 省略部分代码
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;锁消除&#34;&gt;锁消除&lt;/h2&gt;
&lt;p&gt;锁消除是指虚拟机即时编译器（JIT）在运行时，对&lt;strong&gt;一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁&lt;/strong&gt;进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中，&lt;strong&gt;堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行&lt;/strong&gt;。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是程序员自己应该是很清楚的，怎么会在明知道不存在数据争用的情况下要求同步呢?实际上有许多同步措施并不是程序员自己加入的，同步的代码在Java程序中的普遍程度也许超过了大部分读者的想象。下面这段非常简单的代码仅仅是输出3个字符串相加的结果，无论是源码字面上还是程序语义上都没有同步。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Demo01 {
    public static void main(String[] args) {
        contactString(&amp;quot;aa&amp;quot;, &amp;quot;bb&amp;quot;, &amp;quot;cc&amp;quot;);
    }

    public static String contactString(String s1, String s2, String s3) {
        return new StringBuffer().append(s1).append(s2).append(s3).toString();
    }
}
@Override
public synchronized StringBuffer append(String str) {
    toStringCache = null;
    super.append(str);
    return this;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;StringBuffffer 的 append() 是一个同步方法，锁就是 this 也就是(new StringBuilder())。虚拟机发现它的动态作用域被限制在 concatString() 方法内部。也就是说, new StringBuilder()对象的引用永远不会“逃逸”到 concatString() 方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除掉，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了。&lt;/p&gt;
&lt;h2 id=&#34;锁粗化&#34;&gt;锁粗化&lt;/h2&gt;
&lt;p&gt;原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对&lt;strong&gt;同一个对象反复加锁和解锁&lt;/strong&gt;，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Demo01 {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i &amp;lt; 100; i++) {
            sb.append(&amp;quot;aa&amp;quot;);
        }
        System.out.println(sb.toString());
    }
}
@Override
public synchronized StringBuffer append(String str) {
    toStringCache = null;
    super.append(str);
    return this;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;28&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E9%94%81%E7%B2%97%E5%8C%96.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;小结-16&#34;&gt;小结&lt;/h3&gt;
&lt;p&gt;什么是锁粗化？&lt;/p&gt;
&lt;p&gt;JVM会探测到一连串细小的操作都使用同一个对象加锁，将同步代码块的范围放大，放到这串操作的外面，这样只需要加一次锁即可。&lt;/p&gt;
&lt;h2 id=&#34;平时写代码如何对synchronized优化&#34;&gt;平时写代码如何对synchronized优化&lt;/h2&gt;
&lt;h3 id=&#34;减少-synchronized-的范围&#34;&gt;减少 synchronized 的范围&lt;/h3&gt;
&lt;p&gt;同步代码块中尽量短，减少同步代码块中代码的执行时间，减少锁的竞争。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;synchronized (Demo01.class) {
    System.out.println(&amp;quot;aaa&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;降低synchronized锁的粒度&#34;&gt;降低synchronized锁的粒度&lt;/h3&gt;
&lt;p&gt;将一个锁拆分为多个锁提高并发度&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Hashtable hs = new Hashtable(); 
hs.put(&amp;quot;aa&amp;quot;, &amp;quot;bb&amp;quot;); 
hs.put(&amp;quot;xx&amp;quot;, &amp;quot;yy&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;29&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Hashtable%E9%94%81%E5%AE%9A%E6%95%B4%E4%B8%AA%E5%93%88%E5%B8%8C%E8%A1%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;30&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/ConcurrentHashMap%E5%B1%80%E9%83%A8%E9%94%81%E5%AE%9A.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;31&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/LinkedBlockingQueue%E5%85%A5%E9%98%9F%E5%87%BA%E9%98%9F%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E9%94%81.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;LinkedBlockingQueue入队和出队使用不同的锁，相对于读写只有一个锁效率要高&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;32&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/LinkedBlockingQueue%E5%85%A5%E9%98%9F%E5%87%BA%E9%98%9F%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E9%94%812.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;读写分离&#34;&gt;读写分离&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;读取时不加锁，写入和删除时加锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ConcurrentHashMap，CopyOnWriteArrayList 和 ConyOnWriteSet&lt;/p&gt;
">深入学习并发编程中的synchronized</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/leetcode-191-wei-1-de-ge-shu/"" data-c="
          &lt;h2 id=&#34;问题描述&#34;&gt;问题描述&lt;/h2&gt;
&lt;p&gt;编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。&lt;/p&gt;
&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;
&lt;p&gt;示例 1：&lt;br&gt;
输入：00000000000000000000000000001011&lt;br&gt;
输出：3&lt;br&gt;
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。&lt;/p&gt;
&lt;p&gt;示例 2：&lt;br&gt;
输入：00000000000000000000000010000000&lt;br&gt;
输出：1&lt;br&gt;
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。&lt;/p&gt;
&lt;p&gt;示例 3：&lt;br&gt;
输入：11111111111111111111111111111101&lt;br&gt;
输出：31&lt;br&gt;
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。&lt;/p&gt;
&lt;p&gt;提示：&lt;br&gt;
请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。&lt;br&gt;
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。&lt;/p&gt;
&lt;h2 id=&#34;方法一&#34;&gt;方法一&lt;/h2&gt;
&lt;h3 id=&#34;分析&#34;&gt;分析&lt;/h3&gt;
&lt;p&gt;利用与运算&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0 &amp;amp; 0 = 0
0 &amp;amp; 1 = 0
1 &amp;amp; 0 = 0
1 &amp;amp; 1 = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们发现，1 与 任何数相与，结果为任何数。于是我们可以利用这个性质，首先初始化 count = 0，&lt;strong&gt;将二进制表达式中的每一位数字依次与 1 进行与运算&lt;/strong&gt;，如果结果为 1，就代表此位二进制数为 1，count++；如果结果为 0，就代表此位二进制数为 0。最终返回 count 值即为二进制表达式中数字位数为 ‘1’ 的个数。&lt;/p&gt;
&lt;h3 id=&#34;实例分析&#34;&gt;实例分析&lt;/h3&gt;
&lt;p&gt;输入：00000000000000000000000000001011&lt;br&gt;
输出：3&lt;br&gt;
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/leetcode191_1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/leetcode191_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/leetcode191_3.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/leetcode191_4.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        // 字符 &#39;1&#39; 的个数 count 初始化为 0
        int count = 0;
        // 初始化掩码为 1
        int mark = 1;
        // 循环直至掩码左移 32 为后为 0
        while(mark != 0){
            // 将数字 n 的二进制表达式中每一位数字依次与 1 进行与运算
            if((n &amp;amp; mark) != 0){ // 如果结果不为0，表示此位为 1
                count ++;
            }
            // 掩码左移，让前一位对应的数字与 1 进行与运算
            mark &amp;lt;&amp;lt;= 1;
        }
        return count;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;T = O(m)&lt;br&gt;
遍历每一位二进制位，所以时间复杂度为 O(m)，m 为二进制位数的个数&lt;/li&gt;
&lt;li&gt;S = O(1)&lt;br&gt;
没有使用额外的空间，所以空间复杂度为 O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;方法二&#34;&gt;方法二&lt;/h2&gt;
&lt;h3 id=&#34;实例分析-2&#34;&gt;实例分析&lt;/h3&gt;
&lt;p&gt;输入：00000000000000000000000000001011&lt;br&gt;
输出：3&lt;br&gt;
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n = 1011
n-1 = 1010
n &amp;amp; n-1 = 1010
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也就是说，对于整数 n ，n &amp;amp; (n-1) 的效果是把 n 的二进制表示中最低位的 1 消除，有了这个特性，我们就只需不断去检查 n 是否为 0，不为 0 时，计数器 + 1，然后把它最低位的 1 消除，这样循环操作后，n 最后一定会变成 0，而计数器中保存的则是整数 n 二进制表示中 1 的个数 。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/leetcode191_5.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/leetcode191_6.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/leetcode191_7.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码-2&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int count = 0;
        while(n!= 0){
            ++count;
            n = n &amp;amp; (n-1);
        }
        return count;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;复杂度&#34;&gt;复杂度&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;T：O(k)&lt;br&gt;
k 表示整数二进制表示中 1 的个数&lt;/li&gt;
&lt;li&gt;S：O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;来源&#34;&gt;来源&lt;/h2&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：&lt;a href=&#34;https://leetcode-cn.com/problems/number-of-1-bits&#34;&gt;https://leetcode-cn.com/problems/number-of-1-bits&lt;/a&gt;&lt;/p&gt;
">leetcode191. 位1的个数</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/redis-shao-bing/"" data-c="
          &lt;h1 id=&#34;哨兵简介&#34;&gt;哨兵简介&lt;/h1&gt;
&lt;h2 id=&#34;主机宕机&#34;&gt;主机“宕机”&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%B8%BB%E6%9C%BA%E5%AE%95%E6%9C%BA.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;master 宕机，需要选取一个 slave 作为 master&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;将宕机的 master 下线&lt;/li&gt;
&lt;li&gt;找一个slave作为master&lt;/li&gt;
&lt;li&gt;通知所有的 slave 连接新的 master&lt;/li&gt;
&lt;li&gt;启动新的master与slave&lt;/li&gt;
&lt;li&gt;全量复制&lt;em&gt;N+部分复制&lt;/em&gt;N&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%93%A8%E5%85%B5.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;谁来确认 master 宕机了&lt;/li&gt;
&lt;li&gt;找一个主？怎么找法？&lt;/li&gt;
&lt;li&gt;修改配置后，原始的主恢复了怎么办？&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;哨兵&#34;&gt;哨兵&lt;/h2&gt;
&lt;p&gt;哨兵(sentinel) 是一个&lt;strong&gt;分布式系统&lt;/strong&gt;，用于对主从结构中的每台服务器进行&lt;strong&gt;监控&lt;/strong&gt;，当出现故障时通过&lt;strong&gt;投票&lt;/strong&gt;机制选择新的 master并将所有slave连接到新的master。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%93%A8%E5%85%B5.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;哨兵的作用&#34;&gt;哨兵的作用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;监控
&lt;ul&gt;
&lt;li&gt;不断的检查master和slave是否正常运行。&lt;/li&gt;
&lt;li&gt;master存活检测、master与slave运行情况检测&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通知（提醒）
&lt;ul&gt;
&lt;li&gt;当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自动故障转移
&lt;ul&gt;
&lt;li&gt;断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;哨兵也是一台&lt;strong&gt;redis服务器&lt;/strong&gt;，只是不提供数据服务&lt;/p&gt;
&lt;p&gt;通常哨兵配置数量为&lt;strong&gt;单数&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;启用哨兵模式&#34;&gt;启用哨兵模式&lt;/h1&gt;
&lt;h2 id=&#34;配置哨兵&#34;&gt;配置哨兵&lt;/h2&gt;
&lt;p&gt;清空 data 下数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@iZ2ze4u2bufi0915gyi843Z data]# rm -rf *
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;配置一拖二的主从结构&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-一个-master&#34;&gt;1. 一个 master&lt;/h3&gt;
&lt;p&gt;（1）配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@iZ2ze4u2bufi0915gyi843Z conf]# vim redis-6379.conf 
port 6379
daemonize no
#logfile &amp;quot;6379.log&amp;quot;
dir /root/redis-5.0.7/data
dbfilename dump-6379.rdb
rdbcompression yes 
rdbchecksum yes 
appendonly yes
appendfsync everysec
appendfilename appendonly-6379.aof
bind 127.0.0.1
databases 16
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（2）启动master:6379 redis 服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@iZ2ze4u2bufi0915gyi843Z conf]# redis-server redis-6379.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-两个-slave&#34;&gt;2. 两个 slave&lt;/h3&gt;
&lt;p&gt;（1）配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@iZ2ze4u2bufi0915gyi843Z conf]# vim redis-6380.conf 
port 6380
daemonize no
#logfile &amp;quot;6379.log&amp;quot;
dir &amp;quot;/root/redis-5.0.7/data&amp;quot;
replicaof 127.0.0.1 6379
[root@iZ2ze4u2bufi0915gyi843Z conf]# vim redis-6381.conf 
port 6381
daemonize no
#logfile &amp;quot;6379.log&amp;quot;
dir &amp;quot;/root/redis-5.0.7/data&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（2）启动 slave:6380、slave:6381 服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@iZ2ze4u2bufi0915gyi843Z conf]# redis-server redis-6380.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[root@iZ2ze4u2bufi0915gyi843Z conf]# redis-server redis-6381.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;配置三个哨兵配置相同端口不同&#34;&gt;配置三个哨兵（配置相同，端口不同）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;参看sentinel.conf&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（1）查看 sentinel.conf 配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@iZ2ze4u2bufi0915gyi843Z redis-5.0.7]# cat sentinel.conf | grep -v &amp;quot;#&amp;quot; | grep -v &amp;quot;^$&amp;quot; // 过滤到注释和空行
port 26379
daemonize no
pidfile /var/run/redis-sentinel.pid
logfile &amp;quot;&amp;quot;
dir /tmp
sentinel monitor mymaster 127.0.0.1 6379 2
sentinel down-after-milliseconds mymaster 30000
sentinel parallel-syncs mymaster 1
sentinel failover-timeout mymaster 180000
sentinel deny-scripts-reconfig yes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/sentinel.conf.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
sentinel.conf&lt;/p&gt;
&lt;p&gt;（2）将配置文件 复制到 redis-5.0.7/conf 目录下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@iZ2ze4u2bufi0915gyi843Z redis-5.0.7]#cat sentinel.conf | grep -v &amp;quot;#&amp;quot; | grep -v &amp;quot;^$&amp;quot; &amp;gt; ./conf/sentinel-26379.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（3）修改 sentinel-26379.conf 配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@iZ2ze4u2bufi0915gyi843Z conf]# vim sentinel-26379.conf 
port 26379
daemonize no
dir /root/redis-5.0.7/data
sentinel monitor mymaster 127.0.0.1 6379 2
sentinel down-after-milliseconds mymaster 30000
sentinel parallel-syncs mymaster 1
sentinel failover-timeout mymaster 180000
sentinel deny-scripts-reconfig yes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（4）复制生成 sentinel-26380.conf、 sentinel-26381.conf 两个配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@iZ2ze4u2bufi0915gyi843Z conf]# sed &#39;s/26379/26380/g&#39; sentinel-26379.conf &amp;gt; sentinel-26380.conf
[root@iZ2ze4u2bufi0915gyi843Z conf]# sed &#39;s/26379/26381/g&#39; sentinel-26379.conf &amp;gt; sentinel-26381.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;启动哨兵&#34;&gt;启动哨兵&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;redis-sentinel sentinel-端口号.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动三个哨兵：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis-sentinel sentinel-26379.conf

redis-sentinel sentinel-26380.conf

redis-sentinel sentinel-26381.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当 master:6379 下线后，哨兵投票选举出新的 master:6381&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/master%E4%B8%8B%E7%BA%BF%E5%90%8E%EF%BC%8C%E5%93%A8%E5%85%B5%E6%8A%95%E7%A5%A8%E9%80%89%E4%B8%BE%E6%96%B0%E7%9A%84master.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;master 下线后，哨兵投票选举新的 master&lt;/p&gt;
&lt;h2 id=&#34;配置哨兵-2&#34;&gt;配置哨兵&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;配置项&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;范例&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sentinel auth-pass    &amp;lt;服务器名称&amp;gt; &lt;password&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;sentinel auth-pass mymaster   itcast&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;连接服务器口令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sentinel down-after-milliseconds &amp;lt;自定义服务名称&amp;gt;&amp;lt;主机地址&amp;gt;&amp;lt;端口&amp;gt;&amp;lt;主从服务器总量&amp;gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;sentinel monitor mymaster    192.168.194.131 6381 1&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;设置哨兵监听的主服务器信息，最后的参数决定了最终参与选举的服务器 数量（-1）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sentinel down-after-milliseconds    &amp;lt;服务名称&amp;gt;&amp;lt;毫秒数（整数）&amp;gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;sentinel down-after  milliseconds mymaster 3000&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;指定哨兵在监控Redis服务时，判定服务器挂掉的时间周期，默认30秒 （30000），也是主从切换的启动条件之一&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sentinel parallel-syncs    &amp;lt;服务名称&amp;gt;&amp;lt;服务器数（整数）&amp;gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;sentinel parallel-syncs    mymaster 1&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;指定同时进行主从的slave数量，数值越大，要求网络资源越高，要求越小，同步时间越长&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sentinel failover-timeout    &amp;lt;服务名称&amp;gt;&amp;lt;毫秒数（整数）&amp;gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;sentinel failover-timeout    mymaster 9000&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;指定出现故障后，故障切换的最大超时时间，超过该值，认定切换失败，默认3分钟&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sentinel notification-script    &amp;lt;服务名称&amp;gt;&amp;lt;脚本路径&amp;gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;服务器无法正常联通时，设定的执行脚本，通常调试使用。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;哨兵工作原理&#34;&gt;哨兵工作原理&lt;/h1&gt;
&lt;h2 id=&#34;主从切换&#34;&gt;主从切换&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;哨兵在进行主从切换过程中经历三个阶段
&lt;ul&gt;
&lt;li&gt;监控&lt;/li&gt;
&lt;li&gt;通知&lt;/li&gt;
&lt;li&gt;故障转移&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;阶段一监控阶段&#34;&gt;阶段一：监控阶段&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E7%9B%91%E6%8E%A7%E9%98%B6%E6%AE%B5.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;用于同步各个节点的状态信息
&lt;ul&gt;
&lt;li&gt;获取各个sentinel的状态（是否在线）&lt;/li&gt;
&lt;li&gt;获取master的状态
&lt;ul&gt;
&lt;li&gt;master属性
&lt;ul&gt;
&lt;li&gt;runid&lt;/li&gt;
&lt;li&gt;role：master&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;各个slave的详细信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;获取所有slave的状态（根据master中的slave信息）
&lt;ul&gt;
&lt;li&gt;slave属性
&lt;ul&gt;
&lt;li&gt;runid&lt;/li&gt;
&lt;li&gt;role：slave&lt;/li&gt;
&lt;li&gt;master_host、master_port&lt;/li&gt;
&lt;li&gt;offset&lt;/li&gt;
&lt;li&gt;......&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E7%9B%91%E6%8E%A7%E9%98%B6%E6%AE%B52.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;① 第一个哨兵进去的时候，只有 master 和 slave 可以连，哨兵先&lt;strong&gt;连接 master&lt;/strong&gt;，发送 info 指令。&lt;br&gt;
② 为了方便后期 master 和 sentinel 命令交换，&lt;strong&gt;建立了一个 cmd 连接&lt;/strong&gt;，专门用于发送命令。&lt;br&gt;
在这个过程中，保存了所有哨兵状态 SentinelState，在哨兵端把所有信息进行记录；在 master 端记录 redis 实例对应信息：SentinelRedisInstance&lt;br&gt;
③ sentinel 根据从 master 获取的 slaves 信息&lt;strong&gt;去与每一个 slave 进行连接&lt;/strong&gt;，发送 info 命令。&lt;br&gt;
④ 下一个 sentinel 进入，&lt;strong&gt;发送 info 命令连接 master&lt;/strong&gt;，发现 master 端的 SentinelRedisInstance 中的 sentinels 有信息，知道了在它之前有对应的 sentinel 与master 建立了连接。&lt;br&gt;
⑤ sentinel &lt;strong&gt;与 master 建立 cmd 连接&lt;/strong&gt;。&lt;br&gt;
在 sentinel 端创建 SentinelState（包含两个 sentinel 节点信息）。&lt;br&gt;
为了保证两个 sentinel 信息同步，在两个 sentinel 之间建立沟通的桥梁进行发布订阅，向这个通道发送信息大家可以互联，为了保证连接，两个 sentinel 还会互相发送 ping 命令看对方是不是还在&lt;br&gt;
⑥ sentinel 与 slave 连接&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E7%9B%91%E6%8E%A7%E9%98%B6%E6%AE%B53.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;当第三个节点进来时，除了连接 master 和 slaves，还需要与现存的 sentinel 进行连接，此时三个 sentinel 组成了一个小的网络，彼此间交换信息，在这个网络中：哪个哨兵拿到信息，快速扩散给大家，由于每个 sentinel 之间都是信任的，一旦有一个 sentinel 发送信息，其他哨兵接收，发现和自己的信息不一致，就更新掉。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;监控阶段的信息获取：sentinel 会向 master、slave、其他的 sentinel 要状态，sentinel 之间会组建对应的频道，大家在这里发布、订阅、同步信息。&lt;/p&gt;
&lt;h2 id=&#34;阶段二通知阶段&#34;&gt;阶段二：通知阶段&lt;/h2&gt;
&lt;p&gt;信息的长期维护阶段&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E9%80%9A%E7%9F%A5%E9%98%B6%E6%AE%B5.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;三个 sentinel 组成了一个小群体，它们之间进行信息互通，提供数据的 master 和 slave 正常工作，sentinel 会通过 cmd 连接获取它们对应的工作状态，通过发布 hello 信息来获取，无论是哪个 sentinel 拿到结果，都会在 sentinel 内部网络进行信息互通，告诉其他 sentinel。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;阶段三故障转移阶段&#34;&gt;阶段三：故障转移阶段&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E9%98%B6%E6%AE%B5.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;① sentinel 向 master 发送 hello 指令，master 没有回复，sentinel 就不停给 master 发送 hello，发送了到了一定阶段后，sentinel 认为 master 掉线了，给 master 标记为 S_DOWN 状态。&lt;br&gt;
② sentinel1 把这个信息传递到内网中。如果是某个 sentinel 断了导致无法和 master 建立连接，该 sentinel 把 master 状态标记为 S_DOWN，并把信息发送到内网时，发送失败（此 sentinel 断线了）。&lt;br&gt;
③ 当内网中的其他 sentinel 接收到 master 挂掉的信息后，于是去围观不停地给 master 发送 hello，仍然没有回复，该 master 果然掉线了。&lt;br&gt;
④ 于是把它们接收到的结果信息也传送到内网中确认 sentinel1 说的对，master 果然挂了。&lt;br&gt;
⑤ 此时所有 sentinel 都认为 master 挂了，master 端的状态信息更改为：O_DOWN。事实上，只要半数以上的 sentinel 认为 master 挂了，状态就标记为 O_DOWN，不必要等所有 sentinel 都确认。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;主观下线：一个 sentinel 认为 master 挂了。&lt;/p&gt;
&lt;p&gt;客观下线：半数以上 sentinel 认为 master 挂了。&lt;/p&gt;
&lt;h3 id=&#34;1-投票选举-sentinel-代表&#34;&gt;1. 投票选举 sentinel 代表&lt;/h3&gt;
&lt;p&gt;客观下线后，进入下一环节：开始清理队伍。清理队伍前，需选出一个 sentinel 作为代表去清理。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%8A%95%E7%A5%A8%E9%80%89%E4%B8%BE%E5%93%A8%E5%85%B5%E4%BB%A3%E8%A1%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;所有 sentinel 同时发送指令表示我要作为代表去清理队伍。&lt;br&gt;
发送的指令中携带以下信息：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;挂的 ip&lt;/li&gt;
&lt;li&gt;挂的端口&lt;/li&gt;
&lt;li&gt;竞选次数（我在这方面处理的经验：参与竞选的次数）&lt;/li&gt;
&lt;li&gt;自己的 runid&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%93%A8%E5%85%B5%E6%8A%95%E7%A5%A82.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;那么到底应该选哪一个呢？&lt;br&gt;
投票机制&lt;br&gt;
每一个 sentinel 作为参选者，同时也是投票者，每人有一票，当 sentinel1 和 sentinel4 同时把信息发送到微信群中时，sentinel2 先接收到谁的就把票投给谁。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%93%A8%E5%85%B5%E6%8A%95%E7%A5%A83.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;所有信息沟通完毕会得到一个投票结果，假如有一个 sentinel 获得超过半数以上的票，就当选，如果没有得到这样的一个结果，就重新投一轮，每增加一轮，竞选次数+1.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;2-sentinel-代表从备选-slave-中选择一个当-master&#34;&gt;2. sentinel 代表从备选 slave 中选择一个当 master&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;服务器列表中挑选备选master
&lt;ul&gt;
&lt;li&gt;在线的&lt;/li&gt;
&lt;li&gt;响应慢的&lt;/li&gt;
&lt;li&gt;与原master断开时间久的&lt;/li&gt;
&lt;li&gt;优先原则
&lt;ul&gt;
&lt;li&gt;优先级&lt;/li&gt;
&lt;li&gt;offset&lt;/li&gt;
&lt;li&gt;runid&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;发送指令（ sentinel ）
&lt;ul&gt;
&lt;li&gt;向新的master发送slaveof no one&lt;/li&gt;
&lt;li&gt;向其他slave发送slaveof 新masterIP端口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;主从切换过程总结&#34;&gt;主从切换过程总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;监控
&lt;ul&gt;
&lt;li&gt;同步信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通知
&lt;ul&gt;
&lt;li&gt;保持联通&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;故障转移
&lt;ul&gt;
&lt;li&gt;发现问题&lt;/li&gt;
&lt;li&gt;竞选负责人&lt;/li&gt;
&lt;li&gt;优选新master&lt;/li&gt;
&lt;li&gt;新master上任，其他slave切换master，原master作为slave故障恢复后连接&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B%E6%97%A5%E5%BF%97.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;主从切换过程日志信息&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;哨兵模式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是哨兵 （监控整体工作过程）&lt;/li&gt;
&lt;li&gt;哨兵模式搭建&lt;/li&gt;
&lt;li&gt;哨兵工作原理
&lt;ul&gt;
&lt;li&gt;监控&lt;/li&gt;
&lt;li&gt;通知&lt;/li&gt;
&lt;li&gt;故障转移&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
">Redis 哨兵</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/dubbo/"" data-c="
          &lt;h1 id=&#34;一-基础知识&#34;&gt;一、基础知识&lt;/h1&gt;
&lt;h2 id=&#34;1-分布式基础理论&#34;&gt;1、分布式基础理论&lt;/h2&gt;
&lt;h3 id=&#34;11-什么是分布式系统&#34;&gt;1.1）、什么是分布式系统？&lt;/h3&gt;
&lt;p&gt;《分布式系统原理与范型》定义：&lt;/p&gt;
&lt;p&gt;“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”&lt;/p&gt;
&lt;p&gt;分布式系统（distributed system）是建立在网络之上的软件系统。&lt;/p&gt;
&lt;p&gt;随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需&lt;strong&gt;一个治理系统&lt;/strong&gt;确保架构有条不紊的演进。&lt;/p&gt;
&lt;h3 id=&#34;12-发展演变&#34;&gt;1.2）、发展演变&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E6%BC%94%E5%8F%98.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;单一应用架构&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%8D%95%E4%B8%80%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。

缺点： 1、性能扩展比较难 （如果修改或添加某个功能，都需要把整个应用重新打包，重新放部署到 服务器）

       2、协同开发问题（所有人都去修改一个应用，容易乱）

       3、不利于升级维护
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;将多个功能放到一个应用内，打包后放到服务器上即可。访问量增大，一个服务器无法承受时，再添加一个服务器同时跑这个应用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%8D%95%E4%B8%80%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%842.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;垂直应用架构&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%9E%82%E7%9B%B4%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。

缺点： 公用模块无法重复利用，开发性的浪费
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;将一个大应用拆分成几个独立的小应用，每一个应用都是从头到尾完成的（从页面到业务逻辑程序到数据库）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%9E%82%E7%9B%B4%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%842.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;垂直应用架构&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当某一块应用的访问量比较大时，将这个应用多扩展几个服务器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%9E%82%E7%9B%B4%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%843.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;扩展某个小应用即可&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;好处：1）分工合作容易，每个人负责开发维护不同的应用，互不干扰。&lt;br&gt;
2）性能扩展容易，比如“用户”应用的访问量增大， 就把它多放几台服务器，扩展的是某个小应用，其他小应用无需变动。&lt;br&gt;
缺点：1）由于每个小应用都是完整的（界面+业务逻辑+数据库），但是界面要求经常变化，每个界面的变化都会导致应用的重新部署。无法做到页面 和 业务逻辑 的分离&lt;br&gt;
2） 随着应用的逐步增多，垂直应用会越来越多，这样的情况下，不可能理想的应用和应用之间互相独立，订单模块需要用户模块和商品模块信息，应用之间交互，不可能完全独立。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%9E%82%E7%9B%B4%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%844.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;界面与业务逻辑无法分离，各个应用间需要交互&lt;/p&gt;
&lt;p&gt;&lt;em&gt;分布式服务架构&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的&lt;strong&gt;分布式服务框架(RPC)是关键&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%841.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;将用户抽取成“用户界面” 和 “用户业务”，订单抽取成 “订单界面” 和 “订单业务” 等。&lt;br&gt;
当业务逻辑不变的情况下，如果只想修改界面，重启界面服务器即可，核心业务逻辑还在其他服务器上，无需变动。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%842.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;用户界面放在 A 服务器上，用户业务放在 B 服务器上，订单业务放在 C 服务器上，如果 A 服务器（用户界面）需要调用 B 服务器（用户业务）的功能。如果写在一个应用内，A 调用 B，直接“方法 A . 方法 B” 即可，直接调用，进程类通讯，都在一个服务器上，都是同一个 tomcat，同一个进程类通讯。但如果是分布式服务架构，A 和 B 在两台服务器上，这样的不同服务器间的互相调用称为 RPC（远程过程调用）。分布式服务架构的难点：如何进行远程过程调用，如果拆分应用，提升业务的复用程度。&lt;br&gt;
随着业务的不断增多，分拆的业务越来越多，成千上万的服务器在跑不同的服务，出现的资源浪费问题愈加严重，比如用户业务访问量较小，但却有 100 台服务器在跑，就造成了浪费；而 商品业务 访问量很大，但却只有 10 台服务器在跑。应该有一个基于访问压力的调度中心能够实时监控数据动态调度，提高资源利用率，让更多的服务器去跑业务量更大的业务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;流动计算架构&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于&lt;strong&gt;提高机器利用率的资源调度和治理中心(SOA)[ Service Oriented Architecture]是关键&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%B5%81%E5%8A%A8%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;采用流动计算架构，引入调度中心，负责维护服务间的复杂关系，实时管理集群，比如 A 服务器访问量大了，给 A 多增加几台服务器，假设 第一台 有 100 个请求，第二台 有 2 个请求，第三台有 10000 个请求，那么下次请求进来，就应该找比较闲的第二台服务器来处理请求，以此提高整个集群利用率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%B5%81%E5%8A%A8%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%842.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;流动计算架构&lt;/p&gt;
&lt;h3 id=&#34;13-rpc&#34;&gt;1.3）、RPC&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;什么叫RPC&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;RPC基本原理&lt;/em&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/RPC%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;需求：A 服务器客户端（client）有一个小功能，想要调用 B 服务器的一个小功能。&lt;br&gt;
实现：A 服务器客户端（client）先找一个小助手（client stub），这个小助手一看，A 服务器想要调用 B 服务器上的功能，先跟 B 服务器在网络上建立一个 sockets 连接，将要调用 B 的一些信息（比如要调用 B 的某个方法的方法名、参数）传递给 B 模型，B 服务器上的小助手（server stub）收到这些信息，知道了 A 服务器想要调用 我的一个方法，执行这个方法后，将返回值依次传回 A 客户端。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/RPC%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%862.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;RPC两个核心模块：通讯，序列化。&lt;/p&gt;
&lt;p&gt;RPC 框架有很多如：dubbo、gRPC、Thrift、HSF(High Speed Service Framework)&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/RPC%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%863.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;A 服务器上有一个 hello()方法，想要调用 B 服务器上的 hi() 方法，同时传入一个 User  对象，B 服务器上的 hi() 方法执行完了以后，返回一个 String 给 A 服务器，A服务器调完 B服务器的方法后，收到 B 服务器的返回值并在控制台打印。&lt;br&gt;
调用过程：A 服务器客户端（Client） 想要 调用 B 服务器的代码，A 服务器上有一个小助手（Client Stub）这个小助手一看 A 服务器 要调用 B 服务器，先与 B 服务器建议连接，建立连接后，由于调用方法要传递参数，这个参数要发给 B 服务器，参数对象要在网络间传递需要先序列化 ，序列化后将要调用的信息传递给 B 服务器的小助手（Server Stub），B 服务器的小助手收到信息，一看有来自外界的 A 服务器想要调用我的 hi() 方法，同时还传递来了一个参数值，由于是序列化传递过来的，如果使用则需反序列化成对象，B服务器上的小助手调用 B 服务器上的方法，拿到反序列化的对象、一些属性值，方法调用完就会有一个返回值，返回值过来要在网络间传递数据，将返回的 String 对象序列化传递给 A 服务器的小助手，Client Stub 收到后再反序列化，输出。&lt;br&gt;
整个过程两个核心：建立连接、传递数据（序列化和反序列化）。所以，影响一个 RPC 框架性能的重要两点：能否快速地在各个服务器间建立连接；序列化/反序列化机制的速度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-dubbo核心概念&#34;&gt;2、dubbo核心概念&lt;/h2&gt;
&lt;h3 id=&#34;21-简介&#34;&gt;2.1）、简介&lt;/h3&gt;
&lt;p&gt;Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。&lt;/p&gt;
&lt;p&gt;官网：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://dubbo.apache.org/zh-cn/&#34;&gt;http://dubbo.apache.org/zh-cn/&lt;/a&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/dubbo%E7%89%B9%E6%80%A7.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;面向接口代理的高性能 RPC 调用&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用 dubbo 时，A 服务器 要调用 B 服务器上的代码，只需将 B 功能方法的接口 InterfaceB拿过来，调用接口所在的方法 InterfaceB.fun()，就会自动去找服务器 B 上的代码代码调用，屏蔽了远程的调用细节。类似在用 Mybatis ，操作数据库时，只需要写一个 mapper 接口，调用接口的方法即可。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;智能负载均衡&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如用户业务访问量很大，就需要多放几台服务器，“用户界面” 想要调用 “用户业务” 的功能，调用 “用户业务” 的哪一台服务器都可以，假设 第一台用户业务服务器当前有 100 个请求， 第二台用户业务服务器当前有 2 个请求， 第三台用户业务服务器当前有 1000 个请求， 第四台用户业务服务器当前有 10 个请求，就应该找一个非常空闲的服务器快速处理这次响应，这个机制就叫做&lt;strong&gt;负载均衡&lt;/strong&gt;，让每个服务器都有一个很均衡的负载，不要让某一台服务器做太多的响应，把它压垮，也不要让某一台服务器太闲，资源浪费。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%99%BA%E8%83%BD%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;服务自动注册与发现&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;想象这样一个场景：业务非常多，每一块的访问量都特别大，比如用户业务在 1、2、3、4 号服务器都有，支付业务在 9、11、13 号服务器都有，那么 订单web 想要调用支付业务，RPC 框架爱如何知道支付业务都在哪些服务器上呢？如果 11 号服务器出问题了，框架如何自动地知道这个事呢？引入&lt;strong&gt;注册中心&lt;/strong&gt;机制。&lt;/p&gt;
&lt;p&gt;为了能动态感知到每一个服务，可以将所有的服务都注册到注册中心，包括前端程序也可以都注册到注册中心内，注册中心相当于维护了一个 “业务 - 服务器” 清单，比如：用户业务：1、2、3、4 号服务器，如果 2 号服务器出问题了，就把它从清单中删掉。如果 订单web 要调用支付业务，先到注册中心的清单内找支付业务都在哪一台服务器上，然后随机选择或者选择请求量最少的一台服务器进行访问。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;高度可扩展&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;微内核 + 插件&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;运行期流量调度&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;内置条件、脚本等路由策略，通过配置不同的路由规则，轻松实现&lt;strong&gt;灰度发布&lt;/strong&gt;，同机房优先等功能。&lt;/p&gt;
&lt;p&gt;灰度发布：一个用户服务在 100 台服务器上跑，用户服务做了开发升级，先选定 20 台服务器，让它们先用新版本的服务，剩下的 80 台使用旧版本的服务，等这 20 台用着都没问题了，再选 20 台，这样逐步过渡，直到 100 台全用到新的用户服务。配置不同的路由规则，请求进来后，让一部分请求用新升级的服务，剩下的来用旧的服务，通过这种方式从旧服务转化成新服务的过程就叫做&lt;strong&gt;灰度发布&lt;/strong&gt;。&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;&lt;strong&gt;可视化的服务治理和运维&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过可视化的 WEB 界面动态查询服务的信息、调整一些参数。&lt;/p&gt;
&lt;h3 id=&#34;22-基本概念&#34;&gt;2.2）、基本概念&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/dubbo%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;服务提供者（Provider）&lt;/strong&gt;：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务消费者（Consumer）&lt;/strong&gt;: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注册中心（Registry）&lt;/strong&gt;：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;监控中心（Monitor）&lt;/strong&gt;：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;框架容器（Container&lt;/strong&gt;）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用关系说明
&lt;ul&gt;
&lt;li&gt;服务容器负责启动，加载，运行服务提供者。&lt;/li&gt;
&lt;li&gt;服务提供者在启动时，向注册中心注册自己提供的服务。&lt;/li&gt;
&lt;li&gt;服务消费者在启动时，向注册中心订阅自己所需的服务。&lt;/li&gt;
&lt;li&gt;注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。&lt;/li&gt;
&lt;li&gt;服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。&lt;/li&gt;
&lt;li&gt;服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用户业务是实际的业务功能，web 界面要去调用这些业务功能，所以，用户业务是一个服务提供者（Provider），而 web 界面是服务消费者（Consumer）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;运行流程：容器 Container 启动，初始化 init ，服务提供者 Provider 将自己提供的信息注册 register 到注册中心 Registry ，注册中心就知道有哪些服务上线了，当服务消费者 Consumer 启动，从注册中心订阅 subscribe 自己所需要的服务，如果服务提供者发生变更（3 号服务器下线了），注册中心将这次变更推送 notify 给消费者，消费者拿到所有它能调用的服务，调用的时候可以同步调用 invoke 服务提供者提供的服务，如果消费者要调用的服务有多台服务器在提供，消费者根据负载均衡算法选择一个进行调用。每次的调用信息会定时地每隔一分钟将信息发送到监控中心 Monitor，监控中心就能监控到服务的状态。&lt;br&gt;
0、1、2 这三步是在初始化、启动应用时完成的。&lt;br&gt;
3、5 是异步过程，&lt;br&gt;
4 服务消费者调用服务提供者提供的功能是一个同步的调用。&lt;br&gt;
了解了 dubbo 框架，在编写 dubbo 应用时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先写一个服务提供者，将服务提供者提供的服务注册到注册中心；&lt;/li&gt;
&lt;li&gt;编写一个服务消费者，消费者从注册中心订阅提供者提供的服务；&lt;/li&gt;
&lt;li&gt;测试消费者如何调用提供者提供的功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;3-dubbo环境搭建&#34;&gt;3、dubbo环境搭建&lt;/h2&gt;
&lt;h3 id=&#34;31-windows-安装zookeeper&#34;&gt;3.1）、【windows】-安装zookeeper&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;1、下载zookeeper网址 &lt;a href=&#34;https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/&#34;&gt;https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/&lt;/a&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2、解压zookeeper解压运行zkServer.cmd ，初次运行会报错，没有zoo.cfg配置文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3、修改zoo.cfg配置文件将conf下的zoo_sample.cfg复制一份改名为zoo.cfg即可。注意几个重要位置：dataDir=./   临时数据存储的目录（可写相对路径）clientPort=2181   zookeeper的端口号修改完成后再次启动zookeeper&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4、使用zkCli.cmd测试ls /：列出zookeeper根下保存的所有节点create –e /atguigu 123：创建一个atguigu节点，值为123get /atguigu：获取/atguigu节点的值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注：记录一个小 bug&lt;/p&gt;
&lt;p&gt;问题：【zookeeper】报错-Dzookeeper.log.dir=xxx&amp;quot;&#39; 不是内部或外部命令，也不是可运行的程序 或批处理文件的解决&lt;/p&gt;
&lt;p&gt;解决：修改zkServer.cmd文件。将 call %JAVA% 改成 java&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java &amp;quot;-Dzookeeper.log.dir=%ZOO_LOG_DIR%&amp;quot; &amp;quot;-Dzookeeper.root.logger=%ZOO_LOG4J_PROP%&amp;quot; -cp &amp;quot;%CLASSPATH%&amp;quot; %ZOOMAIN% &amp;quot;%ZOOCFG%&amp;quot; %*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考博客：&lt;a href=&#34;https://blog.csdn.net/pangdongh/article/details/90208230&#34;&gt;https://blog.csdn.net/pangdongh/article/details/90208230&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;32-windows-安装dubbo-admin管理控制台&#34;&gt;3.2）、【windows】-安装dubbo-admin管理控制台&lt;/h3&gt;
&lt;p&gt;dubbo本身并不是一个服务软件。它其实就是一个jar包能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。所以你不用在Linux上启动什么dubbo服务。&lt;/p&gt;
&lt;p&gt;但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序，不过这个监控即使不装也不影响使用。&lt;/p&gt;
&lt;p&gt;1、下载dubbo-admin&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/apache/incubator-dubbo-ops&#34;&gt;https://github.com/apache/incubator-dubbo-ops&lt;/a&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/dubbo-admin%E4%B8%8B%E8%BD%BD.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;2、进入目录，修改dubbo-admin配置&lt;/p&gt;
&lt;p&gt;修改 src\main\resources\application.properties 指定zookeeper地址&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/dubbo-admin%E9%85%8D%E7%BD%AE.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;3、打包dubbo-admin&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mvn clean package -Dmaven.test.skip=true 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、运行dubbo-admin&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java -jar dubbo-admin-0.0.1-SNAPSHOT.jar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：【有可能控制台看着启动了，但是网页打不开，需要在控制台按下ctrl+c即可】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认使用root/root 登陆&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%BF%90%E8%A1%8Cdubbo-admin.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;33-linux-安装zookeeper&#34;&gt;3.3）、【linux】-安装zookeeper&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;1、安装jdk&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;1、下载jdk&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&#34;&gt;http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&lt;/a&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%B8%8B%E8%BD%BDjdk.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;不要使用wget命令获取jdk链接，这是默认不同意，导致下载来的jdk压缩内容错误&lt;/p&gt;
&lt;p&gt;2、上传到服务器并解压&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/jdk%E8%A7%A3%E5%8E%8B.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;3、设置环境变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/usr/local/java/jdk1.8.0_171
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;文件末尾加入下面配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export JAVA_HOME=/usr/local/java/jdk1.8.0_171

export JRE_HOME=${JAVA_HOME}/jre

export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib

export PATH=${JAVA_HOME}/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/jdk%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;4、使环境变量生效&amp;amp;测试JDK&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/jdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%94%9F%E6%95%88.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;2、安装zookeeper&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;1、下载zookeeper&lt;/p&gt;
&lt;p&gt;网址 &lt;a href=&#34;https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/&#34;&gt;https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;wget &lt;a href=&#34;https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/zookeeper-3.4.11.tar.gz&#34;&gt;https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/zookeeper-3.4.11.tar.gz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、解压&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;25&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%A7%A3%E5%8E%8Bzk.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;3、移动到指定位置并改名为zookeeper&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;26&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/zk%E7%A7%BB%E5%8A%A8%E5%91%BD%E5%90%8D.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;27&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/zk%E6%9F%A5%E7%9C%8B%E7%9B%AE%E5%BD%95.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;3、开机启动zookeeper&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;1）-复制如下脚本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash

#chkconfig:2345 20 90

#description:zookeeper

#processname:zookeeper

ZK_PATH=/usr/local/zookeeper

export JAVA_HOME=/usr/local/java/jdk1.8.0_171

case $1 in

         start) sh  $ZK_PATH/bin/zkServer.sh start;;

         stop)  sh  $ZK_PATH/bin/zkServer.sh stop;;

         status) sh  $ZK_PATH/bin/zkServer.sh status;;

         restart) sh $ZK_PATH/bin/zkServer.sh restart;;

         *)  echo &amp;quot;require start|stop|status|restart&amp;quot;  ;;

esac
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;28&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8zk.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;2）-把脚本注册为Service&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;29&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%84%9A%E6%9C%AC%E6%B3%A8%E5%86%8C%E4%B8%BAservice.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;3）-增加权限&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;30&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%A2%9E%E5%8A%A0%E6%9D%83%E9%99%90.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;4、配置zookeeper&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;1、初始化zookeeper配置文件&lt;/p&gt;
&lt;p&gt;拷贝/usr/local/zookeeper/conf/zoo_sample.cfg&lt;/p&gt;
&lt;p&gt;到同一个目录下改个名字叫zoo.cfg&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;31&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%88%9D%E5%A7%8B%E5%8C%96zk%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;2、启动zookeeper&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;32&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%90%AF%E5%8A%A8zk.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;34-linux-安装dubbo-admin管理控制台&#34;&gt;3.4）、【linux】-安装dubbo-admin管理控制台&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;1、安装Tomcat8（旧版dubbo-admin是war，新版是jar不需要安装Tomcat）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;1、下载Tomcat8并解压&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://tomcat.apache.org/download-80.cgi&#34;&gt;https://tomcat.apache.org/download-80.cgi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;wget &lt;a href=&#34;http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v8.5.32/bin/apache-tomcat-8.5.32.tar.gz&#34;&gt;http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v8.5.32/bin/apache-tomcat-8.5.32.tar.gz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、解压移动到指定位置&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;33&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%A7%A3%E5%8E%8Btomcat.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;3、开机启动tomcat8&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;34&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8tomcat.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;复制如下脚本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash

#chkconfig:2345 21 90

#description:apache-tomcat-8

#processname:apache-tomcat-8

CATALANA_HOME=/opt/apache-tomcat-8.5.32

export JAVA_HOME=/opt/java/jdk1.8.0_171

case $1 in

start)

    echo &amp;quot;Starting Tomcat...&amp;quot;  

    $CATALANA_HOME/bin/startup.sh

    ;;

stop)

    echo &amp;quot;Stopping Tomcat...&amp;quot;  

    $CATALANA_HOME/bin/shutdown.sh

    ;;

restart)

    echo &amp;quot;Stopping Tomcat...&amp;quot;  

    $CATALANA_HOME/bin/shutdown.sh

    sleep 2

    echo  

    echo &amp;quot;Starting Tomcat...&amp;quot;  

    $CATALANA_HOME/bin/startup.sh

    ;;

*)

    echo &amp;quot;Usage: tomcat {start|stop|restart}&amp;quot;  

    ;; esac
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、注册服务&amp;amp;添加权限&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;35&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/sgrlw1jLRksvtDuA.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;36&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/yFBPAQA9wQcuLiLK.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;5、启动服务&amp;amp;访问tomcat测试&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;37&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/PCItXvgg0c8lpyxk.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;38&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/UkCJSOTip08WixDn.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;2、安装dubbo-admin&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;dubbo本身并不是一个服务软件。它其实就是一个jar包能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。所以你不用在Linux上启动什么dubbo服务。&lt;/p&gt;
&lt;p&gt;但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序，不过这个监控即使不装也不影响使用。&lt;/p&gt;
&lt;p&gt;1、下载dubbo-admin&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/apache/incubator-dubbo-ops&#34;&gt;https://github.com/apache/incubator-dubbo-ops&lt;/a&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;39&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/NB3VdgOwTJUVLKd7.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;2、进入目录，修改dubbo-admin配置&lt;/p&gt;
&lt;p&gt;修改 src\main\resources\application.properties 指定zookeeper地址&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;40&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/Ky405QqumK4BCVLb.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;3、打包dubbo-admin&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mvn clean package -Dmaven.test.skip=true 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、运行dubbo-admin&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java -jar dubbo-admin-0.0.1-SNAPSHOT.jar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认使用root/root 登陆&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;41&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/QwVB9l4fvmYkh6a2.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;4-dubbo-helloworld&#34;&gt;4、dubbo-helloworld&lt;/h2&gt;
&lt;h3 id=&#34;41-提出需求&#34;&gt;4.1）、提出需求&lt;/h3&gt;
&lt;p&gt;某个电商系统，订单服务需要调用用户服务获取某个用户的所有地址；&lt;/p&gt;
&lt;p&gt;我们现在 需要创建两个服务模块进行测试&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;模块&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;订单服务web模块&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;创建订单等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用户服务service模块&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;查询用户地址等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;测试预期结果：&lt;/p&gt;
&lt;p&gt;订单服务web模块在A服务器，用户服务模块在B服务器，A可以远程调用B的功能。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;42&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/zu5t5nNfM7A5kcbM.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;42-工程架构&#34;&gt;4.2）、工程架构&lt;/h3&gt;
&lt;p&gt;根据 dubbo《服务化最佳实践》&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1、分包&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;建议将服务接口，服务模型，服务异常等均放在 API 包中，因为服务模型及异常也是 API 的一部分，同时，这样做也符合分包原则：重用发布等价原则(REP)，共同重用原则(CRP)。&lt;/p&gt;
&lt;p&gt;如果需要，也可以考虑在 API 包中放置一份 spring 的引用配置，这样使用方，只需在 spring 加载过程中引用此配置即可，配置建议放在模块的包目录下，以免冲突，如：com/alibaba/china/xxx/dubbo-reference.xml。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2、粒度&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将面临分布式事务问题，Dubbo 暂未提供分布式事务支持。&lt;/p&gt;
&lt;p&gt;服务接口建议以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。&lt;/p&gt;
&lt;p&gt;不建议使用过于抽象的通用接口，如：Map query(Map)，这样的接口没有明确语义，会给后期维护带来不便。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;43&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/JGqDnycGLrAYNogH.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;43-创建模块&#34;&gt;4.3）、创建模块&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;1、gmall-interface：公共接口层（model，service，exception…）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;作用：定义公共接口，也可以导入公共依赖&lt;/p&gt;
&lt;p&gt;1、Bean模型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class UserAddress implements Serializable{
    private Integer id;
    private String userAddress;
    private String userId;
    private String consignee;
    private String phoneNum;
    private String isDefault;
    // getter、setter、Constructure、toString
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、Service接口&lt;br&gt;
UserService&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.atguigu.gmall.service;

import com.atguigu.gmall.bean.UserAddress;
import java.util.List;
// 用户服务
public interface UserService {
   /**
    * 按照用户id返回所有的收货地址
    * @param userId
    * @return
    */
   public List&amp;lt;UserAddress&amp;gt; getUserAddressList(String userId);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;OrderService&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 订单服务
public interface OrderService {
   /**
    * 初始化订单
    * @param userId
    */
   public void initOrder(String userId);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;44&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/wyNzvleAZIggOiT2.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;2、gmall-user：用户模块（对用户接口的实现）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;1、pom.xml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.atguigu.gmall&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;gmall-interface&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、Service&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class UserServiceImpl implements UserService {
		
	@Override
	public List&amp;lt;UserAddress&amp;gt; getUserAddressList(String userId) {
		// TODO Auto-generated method stub
		return userAddressDao.getUserAddressById(userId);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;4、gmall-order-web：订单模块（调用用户模块）&lt;/em&gt;&lt;br&gt;
1、pom.xml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.atguigu.gmall&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;gmall-interface&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、测试&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class OrderService {	
	UserService userService;	
	/**
	 * 初始化订单，查询用户的所有地址并返回
	 * @param userId
	 * @return
	 */
	public List&amp;lt;UserAddress&amp;gt; initOrder(String userId){
		return userService.getUserAddressList(userId);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在这样是无法进行调用的。我们gmall-order-web引入了gmall-interface，但是interface的实现是gmall-user，我们并没有引入，而且实际他可能还在别的服务器中。&lt;/p&gt;
&lt;h3 id=&#34;44-使用dubbo改造&#34;&gt;4.4）、使用dubbo改造&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;1、改造gmall-user作为服务提供者&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;1）导入 dubbo 依赖（2.6.2）、导入操作 zookeeper 的客户端（curator）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;		&amp;lt;!-- 引入dubbo --&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;dubbo&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;2.6.2&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;
	&amp;lt;!-- 由于我们使用zookeeper作为注册中心，所以需要操作zookeeper
	dubbo 2.6以前的版本引入zkclient操作zookeeper 
	dubbo 2.6及以后的版本引入curator操作zookeeper
	下面两个zk客户端根据dubbo版本2选1即可
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;com.101tec&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;zkclient&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;0.10&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;
    --&amp;gt;
		&amp;lt;!-- curator-framework --&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.apache.curator&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;curator-framework&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;2.12.0&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2）配置提供者&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:dubbo=&amp;quot;http://dubbo.apache.org/schema/dubbo&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd        http://dubbo.apache.org/schema/dubbo        http://dubbo.apache.org/schema/dubbo/dubbo.xsd&amp;quot;&amp;gt;

    &amp;lt;!-- 1.指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名） --&amp;gt;
    &amp;lt;dubbo:application name=&amp;quot;user-service-provider&amp;quot;  /&amp;gt;

    &amp;lt;!-- 2.指定注册中心的位置 --&amp;gt;
    &amp;lt;dubbo:registry address=&amp;quot;zookeeper://127.0.0.1:2181&amp;quot; /&amp;gt;

    &amp;lt;!-- 3.指定通信规则（通信协议、通信端口） --&amp;gt;
    &amp;lt;dubbo:protocol name=&amp;quot;dubbo&amp;quot; port=&amp;quot;20880&amp;quot; /&amp;gt;

    &amp;lt;!-- 4.暴露服务 ref：指向服务的真正实现对象--&amp;gt;
    &amp;lt;dubbo:service interface=&amp;quot;com.atguigu.gmall.service.UserService&amp;quot; ref=&amp;quot;userServiceImpl&amp;quot; /&amp;gt;

    &amp;lt;!-- 服务的实现  --&amp;gt;
    &amp;lt;bean id=&amp;quot;userServiceImpl&amp;quot; class=&amp;quot;com.atguigu.gmall.service.impl.UserServiceImpl&amp;quot; /&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3）启动服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.atguigu.gmall;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import java.io.IOException;
public class MainApplication {
    public static void main(String[] args) throws IOException {
        ClassPathXmlApplicationContext ioc = new ClassPathXmlApplicationContext(&amp;quot;provider.xml&amp;quot;);
        ioc.start();
        System.in.read();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;45&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/STJJRpsgwTkLRkmY.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;4）测试&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;46&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/reVohj16x2sHjsEN.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;2、改造gmall-order-web作为服务消费者&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;1）引入dubbo&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;		&amp;lt;!-- 引入dubbo --&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;dubbo&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;2.6.2&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;
	&amp;lt;!-- 由于我们使用zookeeper作为注册中心，所以需要引入zkclient或curator操作zookeeper --&amp;gt;
		&amp;lt;!-- curator-framework --&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.apache.curator&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;curator-framework&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;2.12.0&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2）配置消费者信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:dubbo=&amp;quot;http://dubbo.apache.org/schema/dubbo&amp;quot; xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-4.3.xsd
       http://dubbo.apache.org/schema/dubbo
       http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&amp;quot;&amp;gt;
    &amp;lt;!-- 1.指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名 --&amp;gt;
    &amp;lt;dubbo:application name=&amp;quot;order-service-consumer&amp;quot;  /&amp;gt;

    &amp;lt;!-- 2.注册中心地址 --&amp;gt;
    &amp;lt;dubbo:registry address=&amp;quot;zookeeper://127.0.0.1:2181&amp;quot; /&amp;gt;

    &amp;lt;!-- 3.声明需要调用的远程服务的接口 --&amp;gt;
    &amp;lt;dubbo:reference interface=&amp;quot;com.atguigu.gmall.service.UserService&amp;quot; id=&amp;quot;userService&amp;quot; /&amp;gt;
    &amp;lt;!-- 包扫描 --&amp;gt;
    &amp;lt;context:component-scan base-package=&amp;quot;com.atguigu.gmall.service.impl&amp;quot;&amp;gt;&amp;lt;/context:component-scan&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3）Service 注解&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.atguigu.gmall.service.impl;

import com.atguigu.gmall.bean.UserAddress;
import com.atguigu.gmall.service.OrderService;
import com.atguigu.gmall.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * 1.让服务提供者注册到注册中心（暴露服务）
 *  1）导入 dubbo 依赖（2.6.2）、导入操作 zookeeper 的客户端（curator）
 *  2）配置服务提供者
 * 2.让消费者去注册中心订阅服务提供者的地址
 */
@Service
public class OrderServiceImpl implements OrderService {
    @Autowired
    UserService userService;
    @Override
    public void initOrder(String userId) {
        // 1. 查询用户收货地址
        List&amp;lt;UserAddress&amp;gt; list = userService.getUserAddressList(userId);
        System.out.println(list);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4）main方法测试&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.atguigu.gmall;

import com.atguigu.gmall.service.OrderService;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import java.io.IOException;

public class MainApplication {
    public static void main(String[] args) throws IOException {
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&amp;quot;consumer.xml&amp;quot;);
        OrderService orderService = applicationContext.getBean(OrderService.class);
        orderService.initOrder(&amp;quot;1&amp;quot;);
        System.out.println(&amp;quot;调用结束...&amp;quot;);

        System.in.read();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;3、测试调用&lt;/em&gt;&lt;br&gt;
访问gmall-order-web的initOrder请求，会调用UserService获取用户地址；&lt;/p&gt;
&lt;p&gt;调用成功。说明我们order已经可以调用远程的UserService了；&lt;/p&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;用户 id ：1
北京市昌平区宏福科技园综合楼3层
深圳市宝安区西部硅谷大厦B座3层（深圳分校）
调用结束...
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;47&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/60BuhhwD1HUmxziW.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;4、注解版&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;1、服务提供方&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:application name=&amp;quot;gmall-user&amp;quot;&amp;gt;&amp;lt;/dubbo:application&amp;gt;  
&amp;lt;dubbo:registry address=&amp;quot;zookeeper://118.24.44.169:2181&amp;quot; /&amp;gt;  
&amp;lt;dubbo:protocol name=&amp;quot;dubbo&amp;quot; port=&amp;quot;20880&amp;quot; /&amp;gt;
&amp;lt;dubbo:annotation package=*&amp;quot;com.atguigu.gmall.user.impl&amp;quot;/&amp;gt;  

import com.alibaba.dubbo.config.annotation.Service;
import com.atguigu.gmall.bean.UserAddress;  
import com.atguigu.gmall.service.UserService;  
import com.atguigu.gmall.user.mapper.UserAddressMapper;

@Service //使用dubbo提供的service注解，注册暴露服务
public class UserServiceImpl implements UserService {	
     @Autowired		
    UserAddressMapper userAddressMapper; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、服务消费方&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:application name=&amp;quot;gmall-order-web&amp;quot;&amp;gt;&amp;lt;/dubbo:application&amp;gt;  
&amp;lt;dubbo:registry address=&amp;quot;zookeeper://118.24.44.169:2181&amp;quot; /&amp;gt;  
&amp;lt;dubbo:annotation package=&amp;quot;com.atguigu.gmall.order.controller&amp;quot;/&amp;gt;

@Controller  
public class OrderController {  	  	
    @Reference  //使用dubbo提供的reference注解引用远程服务  	
    UserService userService; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-监控中心&#34;&gt;5、监控中心&lt;/h2&gt;
&lt;h3 id=&#34;51-dubbo-admin&#34;&gt;5.1）、dubbo-admin&lt;/h3&gt;
&lt;p&gt;图形化的服务管理页面；安装时需要指定注册中心地址，即可从注册中心中获取到所有的提供者/消费者进行配置管理&lt;/p&gt;
&lt;h3 id=&#34;52-dubbo-monitor-simple&#34;&gt;5.2）、dubbo-monitor-simple&lt;/h3&gt;
&lt;p&gt;简单的监控中心；&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1、安装&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;1、下载 dubbo-ops  &lt;a href=&#34;https://github.com/apache/incubator-dubbo-ops&#34;&gt;https://github.com/apache/incubator-dubbo-ops&lt;/a&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2、修改配置指定注册中心地址进入 dubbo-monitor-simple\src\main\resources\conf修改 dubbo.properties文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;48&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/hiBXL60A0HIHytCX.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;3、打包dubbo-monitor-simplemvn clean package -Dmaven.test.skip=true&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;4、解压 tar.gz 文件，并运行start.bat&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;49&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/3VuJjpqB1NQs3dTZ.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;如果缺少servlet-api，自行导入servlet-api再访问监控中心&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;5、启动访问8080&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;50&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/8yKt4JScy58YqdVP.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;2、监控中心配置&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;所有服务配置连接监控中心，进行监控统计    &lt;!-- 监控中心协议，如果为protocol=&#34;registry&#34;，表示从注册中心发现监控中心地址，否则直连监控中心 --&gt;  	&lt;a href=&#34;dubbo:monitor%C2%A0protocol=%22registry%22&#34;&gt;dubbo:monitor protocol=&amp;quot;registry&amp;quot;&lt;/a&gt;&amp;lt;/dubbo:monitor&amp;gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Simple Monitor 挂掉不会影响到 Consumer 和 Provider 之间的调用，所以用于生产环境不会有风险。&lt;/p&gt;
&lt;p&gt;Simple Monitor 采用磁盘存储统计信息，请注意安装机器的磁盘限制，如果要集群，建议用mount共享磁盘。&lt;/p&gt;
&lt;h2 id=&#34;6-整合springboot&#34;&gt;6、整合SpringBoot&lt;/h2&gt;
&lt;p&gt;1）引入&lt;strong&gt;spring-boot-starter以及dubbo和curator的依赖&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;dubbo-spring-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.2.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意starter版本适配：&lt;br&gt;
&lt;img src=&#34;https://uploader.shimo.im/f/d2JLjRxIZZsumBaC.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;2）配置application.properties&lt;/p&gt;
&lt;p&gt;&lt;em&gt;提供者配置：&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dubbo.application.name=gmall-user
dubbo.registry.protocol=zookeeper
dubbo.registry.address=192.168.67.159:2181
dubbo.scan.base-package=com.atguigu.gmall
dubbo.protocol.name=dubbo
dubbo.protocol.port=20880
dubbo.monitor.protocol=registry
## application.name就是服务名，不能跟别的dubbo提供端重复
## registry.protocol  是指定注册中心协议
## registry.address 是注册中心的地址加端口号
## protocol.name 是分布式固定是dubbo,不要改。
## base-package  注解方式要扫描的包
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;消费者配置：&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server.port=8081

dubbo.application.name=gmall-order-web
dubbo.registry.protocol=zookeeper
dubbo.registry.address=192.168.67.159:2181
dubbo.scan.base-package=com.atguigu.gmall
dubbo.protocol.name=dubbo
dubbo.monitor.protocol=registry
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、dubbo注解&lt;br&gt;
@Service、@Reference&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【如果没有在配置中写dubbo.scan.base-package,还需要在启动类使用@EnableDubbo注解】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;消费者：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Reference
UserService userService;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;服务提供者：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@com.alibaba.dubbo.config.annotation.Service // 暴露服务
@Service
public class UserServiceImpl implements UserService {
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;二-dubbo配置&#34;&gt;二、dubbo配置&lt;/h1&gt;
&lt;h2 id=&#34;1-配置原则&#34;&gt;1、配置原则&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;51&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/B1hW7n2x1bYU1d7w.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。&lt;/p&gt;
&lt;p&gt;XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。&lt;/p&gt;
&lt;p&gt;Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。&lt;/p&gt;
&lt;h2 id=&#34;2-重试次数&#34;&gt;2、重试次数&lt;/h2&gt;
&lt;p&gt;失败自动切换，当出现失败，重试其它服务器，但重试会带来更长延迟。可通过 retries=&amp;quot;2&amp;quot; 来设置重试次数(不含第一次)。&lt;/p&gt;
&lt;p&gt;重试次数配置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:service retries=&amp;quot;2&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:reference retries=&amp;quot;2&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:reference&amp;gt;
    &amp;lt;dubbo:method name=&amp;quot;findFoo&amp;quot; retries=&amp;quot;2&amp;quot; /&amp;gt;
&amp;lt;/dubbo:reference&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;幂等操作（执行多次和执行一次效果相同：查询、删除、修改）可设置重试次数，非幂等操作（执行多次和执行一次效果不同：新增）不宜设置重试次数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;3-超时时间&#34;&gt;3、超时时间&lt;/h2&gt;
&lt;p&gt;由于网络或服务端不可靠，会导致调用出现一种不确定的中间状态（超时）。为了避免超时导致客户端资源（线程）挂起耗尽，必须设置超时时间。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;服务消费方引用服务提供方时，可能有雨网络等原因，服务提供方要执行一个方法可能有很长时间，如果很长时间都没有返回，导致大量线程阻塞，可能会引起性能下降，为了解决这个问题，可以指定超时时间，只要这个方法在指定时间内没有返回，就立即终止，不让大量线程阻塞。设置单位 ms&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1-dubbo消费端&#34;&gt;1、Dubbo消费端&lt;/h3&gt;
&lt;p&gt;全局超时配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:consumer timeout=&amp;quot;5000&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指定接口以及特定方法超时配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:reference interface=&amp;quot;com.foo.BarService&amp;quot; timeout=&amp;quot;2000&amp;quot;&amp;gt;
    &amp;lt;dubbo:method name=&amp;quot;sayHello&amp;quot; timeout=&amp;quot;3000&amp;quot; /&amp;gt;
&amp;lt;/dubbo:reference&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-dubbo服务端&#34;&gt;2、Dubbo服务端&lt;/h3&gt;
&lt;p&gt;全局超时配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:provider timeout=&amp;quot;5000&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指定接口以及特定方法超时配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:provider interface=&amp;quot;com.foo.BarService&amp;quot; timeout=&amp;quot;2000&amp;quot;&amp;gt;
    &amp;lt;dubbo:method name=&amp;quot;sayHello&amp;quot; timeout=&amp;quot;3000&amp;quot; /&amp;gt;
&amp;lt;/dubbo:provider&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-配置原则&#34;&gt;3、配置原则&lt;/h3&gt;
&lt;p&gt;dubbo推荐在Provider上尽量多配置Consumer端属性：&lt;/p&gt;
&lt;p&gt;1、作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等&lt;/p&gt;
&lt;p&gt;2、在Provider配置后，Consumer不配置则会使用Provider的配置值，即Provider配置可以作为Consumer的缺省值。否则，Consumer会使用Consumer端的全局设置，这对于Provider不可控的，并且往往是不合理的&lt;/p&gt;
&lt;p&gt;配置的覆盖规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;方法级别配置优于接口级别，即小Scope优先&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Consumer端配置 优于 Provider配置 优于 全局配置，&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;3) 最后是Dubbo Hard Code的配置值（见配置文档）&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;52&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/5xoy9sunaRc44qdE.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;4-版本号&#34;&gt;4、版本号&lt;/h2&gt;
&lt;p&gt;当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。&lt;/p&gt;
&lt;p&gt;可以按照以下的步骤进行版本迁移：&lt;/p&gt;
&lt;p&gt;在低压力时间段，先升级一半提供者为新版本&lt;/p&gt;
&lt;p&gt;再将所有消费者升级为新版本&lt;/p&gt;
&lt;p&gt;然后将剩下的一半提供者升级为新版本&lt;/p&gt;
&lt;p&gt;老版本服务提供者配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:service interface=&amp;quot;com.foo.BarService&amp;quot; version=&amp;quot;1.0.0&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新版本服务提供者配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:service interface=&amp;quot;com.foo.BarService&amp;quot; version=&amp;quot;2.0.0&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;老版本服务消费者配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:reference id=&amp;quot;barService&amp;quot; interface=&amp;quot;com.foo.BarService&amp;quot; version=&amp;quot;1.0.0&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新版本服务消费者配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:reference id=&amp;quot;barService&amp;quot; interface=&amp;quot;com.foo.BarService&amp;quot; version=&amp;quot;2.0.0&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果不需要区分版本，可以按照以下的方式配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:reference id=&amp;quot;barService&amp;quot; interface=&amp;quot;com.foo.BarService&amp;quot; version=&amp;quot;*&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-启动时检查&#34;&gt;5、启动时检查&lt;/h2&gt;
&lt;p&gt;Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 check=&amp;quot;true&amp;quot;。&lt;/p&gt;
&lt;p&gt;可以通过 check=&amp;quot;false&amp;quot; 关闭检查，比如，测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。&lt;/p&gt;
&lt;p&gt;另外，如果你的 Spring 容器是懒加载的，或者通过 API 编程延迟引用服务，请关闭 check，否则服务临时不可用时，会抛出异常，拿到 null 引用，如果 check=&amp;quot;false&amp;quot;，总是会返回引用，当服务恢复时，能自动连上。&lt;/p&gt;
&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;通过 spring 配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关闭某个服务的启动时检查 (没有提供者时报错)：如果启动时没有提供者可以成功启动，但调用时因没有提供者调用失败会抛出异常&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:reference interface=&amp;quot;com.foo.BarService&amp;quot; check=&amp;quot;false&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置当前消费者的统一规则，所有的服务启动时都不检查：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:consumer check=&amp;quot;false&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关闭注册中心启动时检查 (注册订阅失败时报错)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:registry check=&amp;quot;false&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;通过 dubbo.properties&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dubbo.reference.com.foo.BarService.check=false
dubbo.reference.check=false
dubbo.consumer.check=false
dubbo.registry.check=false
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-多版本&#34;&gt;6、多版本&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://dubbo.apache.org/zh-cn/docs/user/demos/multi-versions.html&#34;&gt;http://dubbo.apache.org/zh-cn/docs/user/demos/multi-versions.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用场景：某一个接口功能出现了不兼容的升级，先让一部分人使用新功能，另外一部分人还是先用旧版本，如果新功能版本都稳定了，再把所有老版本替换成新版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;服务提供方提供新旧两个版本供消费者使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 4.暴露服务 ref：指向服务的真正实现对象--&amp;gt;
&amp;lt;dubbo:service interface=&amp;quot;com.atguigu.gmall.service.UserService&amp;quot; ref=&amp;quot;userServiceImpl01&amp;quot; version=&amp;quot;1.0.0&amp;quot;/&amp;gt;
&amp;lt;!-- 服务的实现  --&amp;gt;
&amp;lt;bean id=&amp;quot;userServiceImpl01&amp;quot; class=&amp;quot;com.atguigu.gmall.service.impl.UserServiceImpl&amp;quot; /&amp;gt;
&amp;lt;!-- 连接监控中心 --&amp;gt;
&amp;lt;dubbo:monitor protocol=&amp;quot;registry&amp;quot;&amp;gt;&amp;lt;/dubbo:monitor&amp;gt;
&amp;lt;!-- 检测多版本 --&amp;gt;
&amp;lt;dubbo:service interface=&amp;quot;com.atguigu.gmall.service.UserService&amp;quot; ref=&amp;quot;userServiceImpl02&amp;quot; version=&amp;quot;2.0.0&amp;quot;/&amp;gt;
&amp;lt;bean id=&amp;quot;userServiceImpl02&amp;quot; class=&amp;quot;com.atguigu.gmall.service.impl.UserServiceImpl2&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;服务消费方可选择哪一个版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 3.声明需要调用的远程服务的接口 --&amp;gt;
&amp;lt;dubbo:reference interface=&amp;quot;com.atguigu.gmall.service.UserService&amp;quot; id=&amp;quot;userService&amp;quot; check=&amp;quot;false&amp;quot; version=&amp;quot;2.0.0&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;由此实现灰度发布。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;7-本地存根&#34;&gt;7、本地存根&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html&#34;&gt;http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;远程服务后，客户端通常只剩下接口，而实现全在服务器端，但提供方有些时候想在客户端也执行部分逻辑，比如：做 ThreadLocal 缓存，提前验证参数，调用失败后伪造容错数据等等，此时就需要在 API 中带上 Stub，客户端生成 Proxy 实例，会把 Proxy 通过构造函数传给 Stub &lt;a href=&#34;http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html#fn1&#34;&gt;[1]&lt;/a&gt;，然后把 Stub 暴露给用户，Stub 可以决定要不要去调 Proxy。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;53&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/fCMOKYxIU74ZSiof.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在 spring 配置文件中按以下方式配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:service interface=&amp;quot;com.foo.BarService&amp;quot; stub=&amp;quot;true&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:service interface=&amp;quot;com.foo.BarService&amp;quot; stub=&amp;quot;com.foo.BarServiceStub&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提供 Stub 的实现 &lt;a href=&#34;http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html#fn2&#34;&gt;[2]&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.foo;
public class BarServiceStub implements BarService {
    private final BarService barService;
    
    // 构造函数传入真正的远程代理对象
    public BarServiceStub(BarService barService){
        this.barService = barService;
    }
 
    public String sayHello(String name) {
        // 此代码在客户端执行, 你可以在客户端做ThreadLocal本地缓存，或预先验证参数是否合法，等等
        try {
            return barService.sayHello(name);
        } catch (Exception e) {
            // 你可以容错，可以做任何AOP拦截事项
            return &amp;quot;容错数据&amp;quot;;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Stub 必须有可传入 Proxy 的构造函数。 &lt;a href=&#34;http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html#fnref1&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 interface 旁边放一个 Stub 实现，它实现 BarService 接口，并有一个传入远程 BarService 实例的构造函数 &lt;a href=&#34;http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html#fnref2&#34;&gt;↩︎&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;8-springboot-与-dubbo-整合的三种方式&#34;&gt;8、Springboot 与 dubbo 整合的三种方式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;（1） application.properties&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;导入 dubb-starter，在 application.properties 中配置属性，使用 @Service 暴露服务；使用 @Reference 引用服务&lt;/p&gt;
&lt;p&gt;（注意 @EnableDubbo 开启基于注解的 dubbo 或在 properties 文件中包扫描）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）保留 dubbo xml配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;导入 dubb-starter，使用 @ImportResource 导入配置文件即可（不再使用 @EnableDubbo 注解，转而使用 @ImportResource(locations=&amp;quot;classpath:provider.xml&amp;quot;)&lt;/p&gt;
&lt;p&gt;暴露 Service 也不再使用 @Service 了，因为 xml 中已经设置了暴露服务）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）使用注解 API 方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将每一个组件手动创建到容器中，让 dubbo 来扫描其他的组件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  @EnableDubbo(scanBasePackages=&amp;quot;com.atguigu.gmall&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com.atguigu.gmall.config;

import com.alibaba.dubbo.config.*;
import com.atguigu.gmall.service.UserService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.ArrayList;
import java.util.List;

@Configuration
public class MyDubboConfig {

//        &amp;lt;dubbo:application name=&amp;quot;boot-user-service-provider&amp;quot;  /&amp;gt;
    @Bean
    public ApplicationConfig applicationConfig(){
        ApplicationConfig config = new ApplicationConfig();
        config.setName(&amp;quot;boot-user-service-provider&amp;quot;);
        return config;
    }

    // &amp;lt;dubbo:registry address=&amp;quot;zookeeper://127.0.0.1:2181&amp;quot; /&amp;gt;
    @Bean
    public RegistryConfig registryConfig(){
        System.out.println(&amp;quot;--------&amp;quot;);
        RegistryConfig registryConfig = new RegistryConfig();
        registryConfig.setProtocol(&amp;quot;zookeeper&amp;quot;);
        registryConfig.setAddress(&amp;quot;127.0.0.1:2181&amp;quot;);
        return registryConfig;
    }

    //&amp;lt;dubbo:protocol name=&amp;quot;dubbo&amp;quot; port=&amp;quot;20882&amp;quot; /&amp;gt;
    @Bean
    public ProtocolConfig protocolConfig(){
        ProtocolConfig config = new ProtocolConfig();
        config.setName(&amp;quot;dubbo&amp;quot;);
        config.setPort(20882);
        return config;
    }

    //    &amp;lt;dubbo:service interface=&amp;quot;com.atguigu.gmall.service.UserService&amp;quot; ref=&amp;quot;userServiceImpl01&amp;quot;&amp;gt;
    //        &amp;lt;dubbo:method name=&amp;quot;getUserAddressList&amp;quot; timeout=&amp;quot;1000&amp;quot;&amp;gt;&amp;lt;/dubbo:method&amp;gt;
    //    &amp;lt;/dubbo:service&amp;gt;
    @Bean
    public ServiceConfig&amp;lt;UserService&amp;gt; serviceConfig(UserService userService){
        ServiceConfig&amp;lt;UserService&amp;gt; config = new ServiceConfig&amp;lt;&amp;gt;();
        config.setInterface(UserService.class);
        config.setRef(userService);

        // 配置每一个 method 信息
        MethodConfig methodConfig = new MethodConfig();
        methodConfig.setName(&amp;quot;getUserAddressList&amp;quot;);
        methodConfig.setTimeout(1000);

        // 将 method 的设置关联到 servie 中
        List&amp;lt;MethodConfig&amp;gt; methods = new ArrayList&amp;lt;&amp;gt;();
        methods.add(methodConfig);
        config.setMethods(methods);

        return config;
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;三-高可用&#34;&gt;三、高可用&lt;/h1&gt;
&lt;h2 id=&#34;1-zookeeper宕机与dubbo直连&#34;&gt;1、zookeeper宕机与dubbo直连&lt;/h2&gt;
&lt;p&gt;现象：zookeeper注册中心（zkServer.cmd）宕机，还可以消费dubbo暴露的服务。&lt;/p&gt;
&lt;p&gt;原因：&lt;/p&gt;
&lt;p&gt;健壮性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;监控中心宕掉不影响使用，只是丢失部分采样数据&lt;/li&gt;
&lt;li&gt;数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务&lt;/li&gt;
&lt;li&gt;注册中心对等集群，任意一台宕掉后，将自动切换到另一台&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;服务提供者无状态，任意一台宕掉后，不影响使用&lt;/li&gt;
&lt;li&gt;服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;高可用：通过设计，减少系统不能提供服务的时间；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dubbo 直连（绕过注册中心）&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Reference(url = &amp;quot;127.0.0.1:20882&amp;quot;)
UserService userService;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-集群下dubbo负载均衡配置&#34;&gt;2、集群下dubbo负载均衡配置&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://dubbo.apache.org/zh-cn/docs/user/demos/loadbalance.html&#34;&gt;http://dubbo.apache.org/zh-cn/docs/user/demos/loadbalance.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。&lt;/p&gt;
&lt;h3 id=&#34;负载均衡策略&#34;&gt;负载均衡策略&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Random LoadBalance&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随机，按权重设置随机概率。&lt;/p&gt;
&lt;p&gt;在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;54&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/t9CCH4EHEeoW2iry.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;基于权重的随机负载均衡机制：orderService 想要调用 userService，userService 分别在 1、2、3 台机器内，分别为每一台机器的服务设置权重为 100、200、50，总权重 350，那么对于 1 号机器来说，它的概率就是 100/350 = 2/7，在负载均衡的情况下，大量请求过来，大约有 2/7 的请求会来到 1 号机器。第一次请求来调用的是 1 号机器，第二次来有可能还调用 1 号机器，但总体上，按照大量请求概率分布来看，1 号机器会占 2/7 的概率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;RoundRobin LoadBalance&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;轮循，按公约后的权重设置轮循比率。&lt;/p&gt;
&lt;p&gt;存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;55&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/fnw0VbVMqhIoKq6S.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;轮询负载均衡机制：orderService 想要调用 userService，第一个请求过来先用 1 号 userService 服务，第二个请求过来使用 2 号 userService 服务，下一个请求过来使用 3 号userService 服务，再下一次 1 号，再下一次 2 号...... 依次轮询。&lt;br&gt;
基于权重的轮询负载均衡机制：为每个服务设置权重，3 台服务器的权重分别为 2/7、4/7、1/7，按照轮询机制，第一个请求到来使用 1 号服务器，第二个请求使用 2 号服务器，第三个请求使用 3 号服务器，第四个请求使用 1 号服务器，第五个请求使用 2 号服务器，第六个请求本应使用 3 号服务器，&lt;strong&gt;但是&lt;/strong&gt;，由于 3 号服务器的权重是 1/7（如果有 7 个请求，则 7 个之中的 1 个使用 3 号服务器），已经有第三个请求使用了 3 号服务器，第一个、第四个请求已经使用了 两次 1 号服务器，所以第六个请求只能使用 2 号服务器，同理，第七个请求也使用 2 号服务器。&lt;br&gt;
&lt;strong&gt;LeastActive LoadBalance&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。&lt;/p&gt;
&lt;p&gt;使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;56&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/S8G9zCwCrP81SVr3.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;最少活跃数：orderService 要调用 userService，在确定要使用几号 userService前，根据 “每一个服务器统计的上一次的调用时间”：三台服务器上一次请求的处理时间分别为 100ms、1000ms、300ms，说明 1 号服务器处理最快，于是此次请求会来到 1 号服务器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;ConsistentHash LoadBalance&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一致性 Hash，相同参数的请求总是发到同一提供者。&lt;/p&gt;
&lt;p&gt;当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：&lt;a href=&#34;http://en.wikipedia.org/wiki/Consistent_hashing&#34;&gt;http://en.wikipedia.org/wiki/Consistent_hashing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;缺省只对第一个参数 Hash，如果要修改，请配置 &amp;lt;dubbo:parameter key=&amp;quot;hash.arguments&amp;quot; value=&amp;quot;0,1&amp;quot; /&amp;gt;&lt;/p&gt;
&lt;p&gt;缺省用 160 份虚拟节点，如果要修改，请配置 &amp;lt;dubbo:parameter key=&amp;quot;hash.nodes&amp;quot; value=&amp;quot;320&amp;quot; /&amp;gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;57&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/TKBZTSuulaQxa01m.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;一致性 hash：orderService 想要调用 userService，都是调用的同一个 getUser 方法，将参数 hash 后的不同值分不到不同的服务器上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;负载均衡配置&#34;&gt;负载均衡配置&lt;/h3&gt;
&lt;p&gt;服务端服务级别，暴露服务时&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:service interface=&amp;quot;...&amp;quot; loadbalance=&amp;quot;roundrobin&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;客户端服务级别，消费时&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:reference interface=&amp;quot;...&amp;quot; loadbalance=&amp;quot;roundrobin&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;服务端方法级别&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:service interface=&amp;quot;...&amp;quot;&amp;gt;
    &amp;lt;dubbo:method name=&amp;quot;...&amp;quot; loadbalance=&amp;quot;roundrobin&amp;quot;/&amp;gt;
&amp;lt;/dubbo:service&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;客户端方法级别&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:reference interface=&amp;quot;...&amp;quot;&amp;gt;
    &amp;lt;dubbo:method name=&amp;quot;...&amp;quot; loadbalance=&amp;quot;roundrobin&amp;quot;/&amp;gt;
&amp;lt;/dubbo:reference&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-整合hystrix服务熔断与降级处理&#34;&gt;3、整合hystrix，服务熔断与降级处理&lt;/h2&gt;
&lt;h3 id=&#34;1-服务降级&#34;&gt;1、服务降级&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;什么是服务降级？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。&lt;/p&gt;
&lt;p&gt;向注册中心写入动态配置覆盖规则：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();
Registry registry = registryFactory.getRegistry(URL.valueOf(&amp;quot;zookeeper://10.20.153.10:2181&amp;quot;));
registry.register(URL.valueOf(&amp;quot;override://0.0.0.0/com.foo.BarService?category=configurators&amp;amp;dynamic=false&amp;amp;application=foo&amp;amp;mock=force:return+null&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mock=force:return+null 表示消费方对该服务的方法调用都&lt;strong&gt;直接返回 null 值，不发起远程调用&lt;/strong&gt;。用来屏蔽不重要服务不可用时对调用方的影响。&lt;/li&gt;
&lt;li&gt;还可以改为 mock=fail:return+null 表示消费方对该服务的方法&lt;strong&gt;调用在失败后，再返回 null 值&lt;/strong&gt;，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-集群容错&#34;&gt;2、集群容错&lt;/h3&gt;
&lt;p&gt;在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;集群容错模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Failover Cluster&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;失败自动切换，当&lt;strong&gt;出现失败，重试其它服务器&lt;/strong&gt;。通常用于读操作，但重试会带来更长延迟。可通过 retries=&amp;quot;2&amp;quot; 来设置重试次数(不含第一次)。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A 服务调用 B 服务，B 服务超时后，配置一个重试次数，可以重新切换到能提供 B服务的其他机器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;重试次数配置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:service retries=&amp;quot;2&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:reference retries=&amp;quot;2&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:reference&amp;gt;
    &amp;lt;dubbo:method name=&amp;quot;findFoo&amp;quot; retries=&amp;quot;2&amp;quot; /&amp;gt;
&amp;lt;/dubbo:reference&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Failfast Cluster&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;快速失败，只发起一次调用，&lt;strong&gt;失败立即报错&lt;/strong&gt;。通常用于非幂等性的写操作，比如新增记录。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A 服务调用 B服务，只发起一次调用，失败立即报错。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Failsafe Cluster&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;失败安全，出现异常时，直接&lt;strong&gt;忽略&lt;/strong&gt;。通常用于写入审计日志等操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Failback Cluster&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;失败自动恢复，后台记录失败请求，定时重发&lt;/strong&gt;。通常用于消息通知操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A 服务调用 B 服务，失败后可以后台记录一下，隔一段时间定时再调用一次。适用于：一定要成功的服务调用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Forking Cluster&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;并行调用多个服务器，只要一个成功即返回。通常用于&lt;strong&gt;实时性要求较高&lt;/strong&gt;的读操作，但需要浪费更多服务资源。可通过 forks=&amp;quot;2&amp;quot; 来设置最大并行数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A 服务调用 B服务，有可能会失败，能提供 B 服务的在三台服务器上，同时给这三台服务器都发起请求，只要其中一个服务器响应成功就可以使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Broadcast Cluster&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;广播调用所有提供者，逐个调用，任意一台报错则报错 [2]。通常用于通知所有提供者更新缓存或日志等本地资源信息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A 服务调用 B服务，B 服务的提供者有四台机器，每一台机器都调用一遍，只要有任意一台出现错误，都认为这次调用是失败的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;集群模式配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按照以下示例在服务提供方和消费方配置集群模式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:service cluster=&amp;quot;failsafe&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:reference cluster=&amp;quot;failsafe&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-整合hystrix&#34;&gt;3、整合hystrix&lt;/h3&gt;
&lt;p&gt;Hystrix 旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1、配置spring-cloud-starter-netflix-hystrix&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;spring boot官方提供了对hystrix的集成，直接在pom.xml里加入依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.4.4.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在Application类上增加@EnableHystrix来启用hystrix starter：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@SpringBootApplication
@EnableHystrix
public class ProviderApplication {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;2、配置Provider端&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在Dubbo的Provider上增加@HystrixCommand配置，这样子调用就会经过Hystrix代理。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Service(version = &amp;quot;1.0.0&amp;quot;)
public class HelloServiceImpl implements HelloService {
    @HystrixCommand(commandProperties = {
     @HystrixProperty(name = &amp;quot;circuitBreaker.requestVolumeThreshold&amp;quot;, value = &amp;quot;10&amp;quot;),
     @HystrixProperty(name = &amp;quot;execution.isolation.thread.timeoutInMilliseconds&amp;quot;, value = &amp;quot;2000&amp;quot;) })
    @Override
    public String sayHello(String name) {
        // System.out.println(&amp;quot;async provider received: &amp;quot; + name);
        // return &amp;quot;annotation: hello, &amp;quot; + name;
        throw new RuntimeException(&amp;quot;Exception to show hystrix enabled.&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;3、配置Consumer端&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;对于Consumer端，则可以增加一层method调用，并在method上配置@HystrixCommand。当调用出错时，会走到fallbackMethod = &amp;quot;reliable&amp;quot;的调用里。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    @Reference(version = &amp;quot;1.0.0&amp;quot;)
    private HelloService demoService;
    @HystrixCommand(fallbackMethod = &amp;quot;reliable&amp;quot;)
    public String doSayHello(String name) {
        return demoService.sayHello(name);
    }
    public String reliable(String name) {
        return &amp;quot;hystrix fallback value&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;四-dubbo原理&#34;&gt;四、dubbo原理&lt;/h1&gt;
&lt;h2 id=&#34;1-rpc原理&#34;&gt;1、RPC原理&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;58&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/VT5w26Fy18AWw61q.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;一次完整的RPC调用流程（同步调用，异步另说）如下：&lt;/p&gt;
&lt;p&gt;**1）服务消费方（client）调用以本地调用方式调用服务； **&lt;/p&gt;
&lt;p&gt;2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；&lt;/p&gt;
&lt;p&gt;3）client stub找到服务地址，并将消息发送到服务端；&lt;/p&gt;
&lt;p&gt;4）server stub收到消息后进行解码；&lt;/p&gt;
&lt;p&gt;5）server stub根据解码结果调用本地的服务；&lt;/p&gt;
&lt;p&gt;6）本地服务执行并将结果返回给server stub；&lt;/p&gt;
&lt;p&gt;7）server stub将返回结果打包成消息并发送至消费方；&lt;/p&gt;
&lt;p&gt;8）client stub接收到消息，并进行解码；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9）服务消费方得到最终结果。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明的，不可见的。&lt;/p&gt;
&lt;h2 id=&#34;2-netty通信原理&#34;&gt;2、netty通信原理&lt;/h2&gt;
&lt;p&gt;Netty是一个异步事件驱动的网络应用程序框架， 用于快速开发可维护的高性能协议服务器和客户端。它极大地简化并简化了TCP和UDP套接字服务器等网络编程。&lt;/p&gt;
&lt;p&gt;BIO：(Blocking IO)&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;59&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/2W5W02pWhRc1tfWH.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;BIO：阻塞式 IO。每一个请求进来，开一个 Socket 开一个线程来处理数据，读取到数据后业务逻辑操作完成后返回。服务器收到很多请求，同时操作，在这个业务逻辑完成前这个线程不能得到释放，服务器就不能同时处理大量请求，因为有大量线程在阻塞，等待业务逻辑的完成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;NIO (Non-Blocking IO)&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;60&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/i2Hhf1AEfLE0e9rK.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;Channel：通道，通道里面有 Buffer 用来进行数据传输。&lt;br&gt;
一个 Selector 注册进了很多通道，每个请求使用通道进行数据传递通信，Selector 通过监听多个通道，当发现某一个通道里的数据准备好了，Selector 执行相应操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Selector 一般称 为&lt;strong&gt;选择器&lt;/strong&gt; ，也可以翻译为 &lt;strong&gt;多路复用器，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Connect（连接就绪）、Accept（接受就绪）、Read（读就绪）、Write（写就绪）&lt;/p&gt;
&lt;p&gt;Netty基本原理：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;61&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/M16PnkZ6fGY7YG8J.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;Netty 服务器启动（ServerBootstrap.bind），绑定监听某一个端口，比如 dubbo 的20880端口，这样所有给这个端口发的数据 netty 就能收到，启动后初始化服务器的通道（NioServerSockerChannel），注册到 selector，selector 负责监听 accept 事件（当通道接收准备就绪后，处理通道里的信息），netty 与客户端建立连接， 生成 NioSocketChannel，把这个  通道注册到 Selector 里面，这个 selector 监听 read、write 事件（通道中数据读、写准备就绪），读写准备就绪后来处理这个事件，抛给用户队列，netty 把这个任务队列执行完&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;3-dubbo原理&#34;&gt;3、dubbo原理&lt;/h2&gt;
&lt;h3 id=&#34;1-dubbo原理-框架设计&#34;&gt;1、dubbo原理	-框架设计&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;62&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/mktdQ0QVP0s1eieu.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;dubbo 框架整体分层：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Business 业务逻辑层：&lt;br&gt;
1.1 Service服务层：面向接口编程。接口、实现。想要远程调用只需要调用接口的方法，就自动调实现了。 对于用户编程，只需要关心这一层就结束了。&lt;br&gt;
2.RPC层：完成远程过程调用：&lt;br&gt;
2.1 Config 配置层，封装配置文件里解析出来的信息 ReferenceConfig、ServiceConfig；&lt;br&gt;
2.2 Proxy 服务代理层：利用代理的方式，生成客户端代理对象、服务端代理对象，代理对象互相调用方法；&lt;br&gt;
2.2 Registry 注册中心层：完成服务的发现和注册；很多服务要注册到注册中心，消费者要从注册中心订阅所需要的服务来调用；&lt;br&gt;
2.3 Cluster 路由层：负载均衡。invoker 调用者要调用很多的服务，服务在很多机器上跑，需要负载均衡；&lt;br&gt;
2.4 Monitor 监控层：每一次的调用信息都会向监控层发送一些数据；&lt;br&gt;
2.5 Protocol 远程调用层：封装 RPC 调用，RPC 调用核心的三个：Invoker、Protocol、Exporter；&lt;/li&gt;
&lt;li&gt;Remoting 层：远程要调用就要跟 A、B两个服务器架起通信管道，通信以及在通信间传递数据&lt;br&gt;
3.1 Exchange 信息交换层：创建一个客户端 ExchangeClient、服务端 ExchangeServer&lt;br&gt;
两端架起网架进行数据的互联互通；&lt;br&gt;
3.2 Transport 传输层：真正传输数据用 Transporter 来封装传输的，Transporter 底层就是 netty 框架，netty 框架就是在这一层封装；&lt;br&gt;
3.3 Serialize 序列化层：序列化&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类&lt;/li&gt;
&lt;li&gt;proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory&lt;/li&gt;
&lt;li&gt;registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService&lt;/li&gt;
&lt;li&gt;cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance&lt;/li&gt;
&lt;li&gt;monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService&lt;/li&gt;
&lt;li&gt;protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter&lt;/li&gt;
&lt;li&gt;exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer&lt;/li&gt;
&lt;li&gt;transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec&lt;/li&gt;
&lt;li&gt;serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-dubbo原理-启动解析-加载配置信息&#34;&gt;2、dubbo原理	-启动解析、加载配置信息&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;63&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/iFVXso8DLkEuO0r6.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;3-dubbo原理-服务暴露&#34;&gt;3、dubbo原理	-服务暴露&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;64&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/2ocFX7K06DopwxGs.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;4-dubbo原理-服务引用&#34;&gt;4、dubbo原理	-服务引用&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;65&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/DxTlKd889QMR0jp1.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;5-dubbo原理-服务调用&#34;&gt;5、dubbo原理	-服务调用&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;66&#34;&gt;&lt;img src=&#34;https://uploader.shimo.im/f/rugf4MklrfIiNoOW.png!thumbnail&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">dubbo</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/ji-yi-ge-mian-shi-ti-shi-xian-yi-ge-du-xie-suo/"" data-c="
          &lt;h1 id=&#34;用共享对象实现写优先的读者写者锁&#34;&gt;用共享对象实现写优先的读者写者锁&lt;/h1&gt;
&lt;p&gt;首先，我们实现一个读者/写者锁。类似于一个普通的互斥锁，一个读者/写者锁(RWLock)保护共享数据。然而，它会做如下的优化。为了最大化性能，一个 RWLock 允许多个“读者”线程同时访问共享数据。任意数量的线程可以在同一时间安全地读共享数据，只要没有线程在修改数据。然而，任意时刻，至多只能有 1 个写者线程可以持有 RWLock（读者线程只能读共享数据，写者线程既可以写也可以读共享数据）。当一个写者线程持有 RWLock，它可以安全地修改数据，因为锁保证了不会有其他的线程同时持有该锁。读者写者锁常常被用于数据库，它们被用于支持对数据库的更快的搜索查询，同时也支持不太频繁的更新。另一个常见的应用是在操作系统内核中，核心的数据结构常常被许多线程读但更新却不太频繁。为了将我们的互斥锁一般化为一个读者/写者锁，我们实现了一个新类型的共享对象，RWLock，来保护对共享数据的访问。RWLock 采用了我们标准化的同步构建模块：互斥锁和条件变量来实现。&lt;br&gt;
一个线程想要（原子地）读共享数据，其过程如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rwLock-&amp;gt;startRead();
read shared data
rwLock-&amp;gt;doneRead();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类似的，一个线程想要（原子地）写共享数据，其过程如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rwLock-&amp;gt;startWrite();
Read and write shared data
rwLock-&amp;gt;doneWrite();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了设计 RWLock 类，我们首先定义它的接口（如上面代码所示），和它的共享状态。这里，对象的行为可以通过&lt;strong&gt;正在读和正在写的线程的数量和等待读和等代写的线程的数量&lt;/strong&gt;来刻画。所以，我们需要 4 个整数来追踪这些值。 代码 5.9 展示了 RWLock 类的成员和接口. 接下来，我们通过提出以下的问题来添加同步变量，“什么时候方法需要等待？”首先，我们添加一个互斥锁：保证当有线程在访问 RWLock 的方法的时候，其他访问 RWLock 的方法的线程必须等待。接下来，我们观察到 startRead 或 startWrite 可能需要等待，因此我们为每种情况添加了一个条件变量：readGo 和 writeGo.&lt;/p&gt;
&lt;h2 id=&#34;读者写者锁的接口和成员变量&#34;&gt;读者/写者锁的接口和成员变量&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;class RWLock{
    private:
        //Synchronization variables
        Lock lock;
        CV readGo;
        CV writeGo;

        // State variables
        int activeReaders;
        int activeWriters;
        int waitingReaders;
        int waitingWriters;
    public:
        RWLock();
        ~RWLock(){};
        void startRead();
        void doneRead();
        void startWrite();
        void doneWrite();
    private:
        bool readShouldWait();
        bool writeShouldWait();
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码 5.9：  我们的读者/写者锁的接口和成员变量&lt;br&gt;
RWLock: doneRead 和 doneWrite 不需要等待（不包括获取互斥锁）。因此，这些方法不需要额外的条件变量。&lt;br&gt;
现在我们实现 RWLock。&lt;br&gt;
首先，我们先给每个方法添加上锁的获取和锁的释放。如下图所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void RWLock :: startRead(){
    lock.acquire();

    lock.release();
}

void RWLock::doneRead(){
    lock.acquire();

    lock.release();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;RWLock::startWrite 和 RWLock::doneWrite 也类似。&lt;/p&gt;
&lt;p&gt;由于我们知道 startRead 和 startWrite 必须等待，因此我们可以在每个方法的中间写上while(…){wait();}的循环。然后，我们开始思考其中的细节，例如循环等待的判断条件。代码 5.10 展示了完整的解法。&lt;/p&gt;
&lt;h2 id=&#34;读者写者锁完整代码&#34;&gt;读者写者锁完整代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// Wait until no active or waiting writers,then proceed
void RWLock::startRead(){
    lock.acquire();
    waitingReaders++;
    while(readShouldWait()){
        readGo.Wait(&amp;amp;lock);
    }
    waitingReaders--;
    activeReaders++;
    lock.release();
}

// Done reading.If no other active readers,a write may proceed.
void RWLock::doneRead(){
    lock.acquire();
    activeReaders--;
    if(activeReaders == 0 &amp;amp;&amp;amp; waitingWriters &amp;gt; 0){
        writeGo.signal();
    }
    lock.release();
}

// Read waits if any active or waiting write(&amp;quot;writers preferred&amp;quot;).
bool RWLock::readShouldWait(){
    return (activeWriters &amp;gt; 0 || waitingWriters &amp;gt; 0);
}

// Wait until no active read or write then proceed;
void RWLock::startWrite(){
    lock.acquire();
    waitingWriterw++;
    while(writeShouldWait()){
        writeGo.Wait(&amp;amp;lock);
    }
    waitingWriters--;
    activeWriters++;
    lock.release();
}

// Done writing. A waiting write or read may proceed.
void RWLock::doneWrite(){
    lock.acquire();
    activeWriters--;
    assert(activeWriters == 0);
    if(waitingWriters &amp;gt; 0){
        writeGo.signal();
    }else{
        readGo.broadcast();
    }
    lock.release();
}

// Write waits for active read or write.
bool RWLock::writeShouldWait(){
    return(activeWriters &amp;gt; 0 || activeReaders &amp;gt; 0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码 5.10：  一个读者写者锁的实现&lt;/p&gt;
">记一个面试题 —— 实现一个读写锁</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/redis-chi-jiu-hua/"" data-c="
          &lt;h1 id=&#34;持久化简介&#34;&gt;持久化简介&lt;/h1&gt;
&lt;h2 id=&#34;意外的断电&#34;&gt;意外的断电&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%96%AD%E7%94%B5.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;自动备份&#34;&gt;“自动备份”&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;什么是持久化&#34;&gt;什么是持久化&lt;/h2&gt;
&lt;p&gt;利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化。&lt;/p&gt;
&lt;h2 id=&#34;为什么要进行持久化&#34;&gt;为什么要进行持久化&lt;/h2&gt;
&lt;p&gt;防止数据的意外丢失，确保数据安全性&lt;/p&gt;
&lt;h2 id=&#34;持久化过程保存什么&#34;&gt;持久化过程保存什么&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;将当前数据状态进行保存，&lt;strong&gt;快照&lt;/strong&gt;形式，存储数据结果，存储格式简单，关注点在&lt;strong&gt;数据&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将数据的操作过程进行保存，&lt;strong&gt;日志&lt;/strong&gt;形式，存储操作过程，存储格式复杂，关注点在&lt;strong&gt;数据的操作过程&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/redis%E6%8C%81%E4%B9%85%E5%8C%96.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;rdb&#34;&gt;RDB&lt;/h1&gt;
&lt;h2 id=&#34;rdb启动方式&#34;&gt;RDB启动方式&lt;/h2&gt;
&lt;h2 id=&#34;谁什么时间干什么事情&#34;&gt;谁，什么时间，干什么事情&lt;/h2&gt;
&lt;p&gt;命令执行&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;谁：redis操作者（用户）&lt;/li&gt;
&lt;li&gt;什么时间：即时（随时进行）&lt;/li&gt;
&lt;li&gt;干什么事情：保存数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rdb启动方式-save指令&#34;&gt;RDB启动方式 —— save指令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;命令&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;save 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;作用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;手动执行一次保存操作&lt;/p&gt;
&lt;p&gt;redis-cli&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; set name ssm
OK
127.0.0.1:6379&amp;gt; save
OK
127.0.0.1:6379&amp;gt; set age 20
OK
127.0.0.1:6379&amp;gt; save
OK
127.0.0.1:6379&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[root@iZ2ze4u2bufi0915gyi843Z data]# ll
total 4
-rw-r--r-- 1 root root 3918 Feb 25 21:23 6379.log
[root@iZ2ze4u2bufi0915gyi843Z data]# ll
total 8
-rw-r--r-- 1 root root 3969 Feb 25 21:24 6379.log
-rw-r--r-- 1 root root  107 Feb 25 21:24 dump.rdb
[root@iZ2ze4u2bufi0915gyi843Z data]# ll
total 8
-rw-r--r-- 1 root root 4020 Feb 25 21:24 6379.log
-rw-r--r-- 1 root root  114 Feb 25 21:24 dump.rdb
[root@iZ2ze4u2bufi0915gyi843Z data]# cat dump.rdb 
REDIS0009	redis-ver5.0.7
redis-bits󿿀򳨭e
              Uused-memx
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;rdb启动方式-save指令相关配置&#34;&gt;RDB启动方式 —— save指令相关配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;dbfilename dump.rdb
&lt;ul&gt;
&lt;li&gt;说明：设置本地数据库文件名，默认值为 dump.rdb&lt;/li&gt;
&lt;li&gt;经验：通常设置为**dump-&lt;strong&gt;&lt;strong&gt;端口号&lt;/strong&gt;&lt;/strong&gt;.rdb **&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;dir
&lt;ul&gt;
&lt;li&gt;说明：设置存储.rdb文件的路径&lt;/li&gt;
&lt;li&gt;经验：通常设置成存储空间较大的目录中，目录名称**data **&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;rdbcompression yes
&lt;ul&gt;
&lt;li&gt;说明：设置存储至本地数据库时是否&lt;strong&gt;压缩数据&lt;/strong&gt;，默认为 yes，采用 LZF 压缩&lt;/li&gt;
&lt;li&gt;经验：通常默认为开启状态，如果设置为no，可以节省 CPU 运行时间，但会使存储的文件变大（巨大）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;rdbchecksum yes
&lt;ul&gt;
&lt;li&gt;说明：设置是否进行RDB&lt;strong&gt;文件格式校验&lt;/strong&gt;，该校验过程在写文件和读文件过程均进行&lt;/li&gt;
&lt;li&gt;经验：通常默认为开启状态，如果设置为no，可以节约读写性过程约10%时间消耗，但是存储一定的数据损坏风险&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rdb启动方式-save指令工作原理&#34;&gt;RDB启动方式 —— save指令工作原理&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Redis%E6%8C%87%E4%BB%A4save.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/Redis%E6%8C%87%E4%BB%A4save2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;strong&gt;save指令的执行会&lt;/strong&gt;阻塞&lt;/strong&gt;当前Redis服务器，直到当前RDB过程完成为止，有可能会造成长时间阻塞，线上环境不建议使用。&lt;/p&gt;
&lt;h2 id=&#34;数据量过大单线程执行方式造成效率过低如何处理&#34;&gt;数据量过大，单线程执行方式造成效率过低如何处理？&lt;/h2&gt;
&lt;h3 id=&#34;后台执行-bgsave&#34;&gt;后台执行 （bgsave）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;谁：redis操作者（用户）发起指令；redis服务器控制指令执行&lt;/li&gt;
&lt;li&gt;什么时间：即时（发起）；合理的时间（执行）&lt;/li&gt;
&lt;li&gt;干什么事情：保存数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bgsave指令&#34;&gt;bgsave指令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;命令&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;bgsave 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;作用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;手动启动后台保存操作，但不是立即执行&lt;/p&gt;
&lt;h3 id=&#34;bgsave指令工作原理&#34;&gt;bgsave指令工作原理&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/bgsave.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;注意： &lt;strong&gt;bgsave命令是针对save阻塞问题做的优化。Redis内部所有涉及到RDB操作都采用bgsave的方式，save命令可以放弃使用&lt;/strong&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;bgsave指令相关配置&#34;&gt;bgsave指令相关配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;dbfilename dump.rdb&lt;/li&gt;
&lt;li&gt;dir&lt;/li&gt;
&lt;li&gt;rdbcompression yes&lt;/li&gt;
&lt;li&gt;rdbchecksum yes&lt;/li&gt;
&lt;li&gt;stop-writes-on-bgsave-error yes
&lt;ul&gt;
&lt;li&gt;说明：后台存储过程中如果出现错误现象，是否停止保存操作&lt;/li&gt;
&lt;li&gt;经验：通常默认为开启状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;反复执行保存指令忘记了怎么办不知道数据产生了多少变化何时保存&#34;&gt;反复执行保存指令，忘记了怎么办？不知道数据产生了多少变化，何时保存？&lt;/h2&gt;
&lt;h3 id=&#34;自动执行&#34;&gt;自动执行&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;谁：redis服务器发起指令（基于条件）&lt;/li&gt;
&lt;li&gt;什么时间：满足条件&lt;/li&gt;
&lt;li&gt;干什么事情：保存数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;save配置&#34;&gt;save配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;redis-6379.conf 内配置&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;save second changes 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;作用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;满足限定时间范围内key的变化数量达到指定数量即进行持久化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参数
&lt;ul&gt;
&lt;li&gt;second：监控时间范围&lt;/li&gt;
&lt;li&gt;changes：监控key的变化量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;位置
&lt;ul&gt;
&lt;li&gt;在conf文件中进行配置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;范例&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;save 900 1 
save 300 10 
save 60 10000
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;save配置原理&#34;&gt;save配置原理&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Redis%E6%8C%87%E4%BB%A4save3.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;注意： save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的&lt;/p&gt;
&lt;p&gt;save配置中对于second与changes设置通常具有互补对应关系，尽量不要设置成包含性关系&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;save配置启动后执行的是bgsave操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;save配置相关配置&#34;&gt;save配置相关配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;dbfilename dump.rdb&lt;/li&gt;
&lt;li&gt;dir&lt;/li&gt;
&lt;li&gt;rdbcompression yes&lt;/li&gt;
&lt;li&gt;rdbchecksum yes&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rdb三种启动方式对比&#34;&gt;RDB三种启动方式对比&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;方式&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;save指令&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;bgsave指令（save配置）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;读写&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;同步&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;异步&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;阻塞客户端指令&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;是&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;额外内存消耗&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;否&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;启动新进程&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;否&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;rdb特殊启动形式&#34;&gt;RDB特殊启动形式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;全量复制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在主从复制中详细讲解&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器运行过程中重启&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;debug reload 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;关闭服务器时指定保存数据&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;shutdown save 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认情况下执行shutdown命令时，自动执行 bgsave(如果没有开启AOF持久化功能)&lt;/p&gt;
&lt;h2 id=&#34;rdb优点&#34;&gt;RDB优点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;RDB是一个紧凑压缩的&lt;strong&gt;二进制&lt;/strong&gt;文件，**存储效率较高 **&lt;/li&gt;
&lt;li&gt;RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景&lt;/li&gt;
&lt;li&gt;RDB&lt;strong&gt;恢复数据&lt;/strong&gt;的&lt;strong&gt;速度&lt;/strong&gt;要比AOF&lt;strong&gt;快&lt;/strong&gt;很多&lt;/li&gt;
&lt;li&gt;应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于&lt;strong&gt;灾难恢复&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rdb缺点&#34;&gt;RDB缺点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性&lt;strong&gt;丢失数据&lt;/strong&gt;（10点备份一次，11点备份一次，那么10点45的数据就丢失了）&lt;/li&gt;
&lt;li&gt;bgsave指令每次运行要执行fork操作&lt;strong&gt;创建子进程&lt;/strong&gt;，要**牺牲掉一些性能 **&lt;/li&gt;
&lt;li&gt;Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现&lt;strong&gt;各版本&lt;/strong&gt;服务之间数据格式&lt;strong&gt;无法兼容&lt;/strong&gt;现象&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;aof&#34;&gt;AOF&lt;/h1&gt;
&lt;h2 id=&#34;rdb存储的弊端&#34;&gt;RDB存储的弊端&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;存储&lt;strong&gt;数据量较大&lt;/strong&gt;，效率较低
&lt;ul&gt;
&lt;li&gt;基于&lt;strong&gt;快照&lt;/strong&gt;思想，每次读写都是&lt;strong&gt;全部&lt;/strong&gt;数据，当数据量巨大时，效率非常低&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;大数据量下的**IO性能较低 **&lt;/li&gt;
&lt;li&gt;基于fork创建&lt;strong&gt;子进程&lt;/strong&gt;，&lt;strong&gt;内存&lt;/strong&gt;产生额外&lt;strong&gt;消耗&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;宕机带来的&lt;strong&gt;数据丢失&lt;/strong&gt;风险 （快照是某个时间点的数据）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;解决思路&#34;&gt;解决思路&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;不写全数据，仅**记录部分数据 **&lt;/li&gt;
&lt;li&gt;降低区分数据是否改变的难度，改记录数据为**记录操作过程 **&lt;/li&gt;
&lt;li&gt;对所有操作均进行记录，&lt;strong&gt;排除丢失数据的风险&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;aof概念&#34;&gt;AOF概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;AOF(append only file)持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令达到恢复数据的目的。与RDB相比可以简单描述为改记录数据为记录数据产生的过程&lt;/li&gt;
&lt;li&gt;AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;aof写数据过程&#34;&gt;AOF写数据过程&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/AOF.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;aof写数据三种策略appendfsync&#34;&gt;AOF写数据三种策略(****appendfsync)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;always(每次）
&lt;ul&gt;
&lt;li&gt;每次写入操作均同步到AOF文件中，&lt;strong&gt;数据零误差&lt;/strong&gt;，**性能较低 **，不建议使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;everysec（每秒）
&lt;ul&gt;
&lt;li&gt;每秒将缓冲区中的指令同步到AOF文件中，数据准确性较高，**性能较高 **，建议使用，也是默认配置&lt;/li&gt;
&lt;li&gt;在系统突然宕机的情况下丢失1秒内的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;no（系统控制）
&lt;ul&gt;
&lt;li&gt;由操作系统控制每次同步到AOF文件的周期，整体过程&lt;strong&gt;不可控&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;aof功能开启&#34;&gt;AOF功能开启&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;配置&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;appendonly yes|no 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;作用
&lt;ul&gt;
&lt;li&gt;是否开启AOF持久化功能，默认为不开启状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;配置&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;appendfsync always|everysec|no 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;作用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AOF写数据策略&lt;/p&gt;
&lt;h2 id=&#34;aof相关配置&#34;&gt;AOF相关配置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;配置&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;appendfilename filename 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;作用
&lt;ul&gt;
&lt;li&gt;AOF持久化文件名，默认文件名为appendonly.aof，建议配置为appendonly-端口号.aof&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;配置&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;dir 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;作用
&lt;ul&gt;
&lt;li&gt;AOF持久化文件保存路径，与RDB持久化文件保持一致即可&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;aof写数据遇到的问题&#34;&gt;AOF写数据遇到的问题&lt;/h2&gt;
&lt;h3 id=&#34;如果连续执行如下指令该如何处理&#34;&gt;如果连续执行如下指令该如何处理&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/AOF%E4%BE%8B%E5%AD%90.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;aof重写&#34;&gt;AOF重写&lt;/h3&gt;
&lt;p&gt;随着命令不断写入AOF，&lt;strong&gt;文件会越来越大&lt;/strong&gt;，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。AOF文件重写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程。简单说就是&lt;strong&gt;将对同一个数据的若干个条命令执行结果转化成最终结果数据对应的指令&lt;/strong&gt;进行记录。&lt;/p&gt;
&lt;h3 id=&#34;aof重写作用&#34;&gt;AOF重写作用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;降低磁盘占用量，提高磁盘利用率&lt;/li&gt;
&lt;li&gt;提高持久化效率，降低持久化写时间，提高IO性能&lt;/li&gt;
&lt;li&gt;降低数据恢复用时，提高数据恢复效率&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;aof重写规则&#34;&gt;AOF重写规则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;进程内已超时的数据不再写入文件&lt;/li&gt;
&lt;li&gt;忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令
&lt;ul&gt;
&lt;li&gt;如del key1、 hdel key2、srem key3、set key4 111、set key4 222等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对同一数据的多条写命令合并为一条命令
&lt;ul&gt;
&lt;li&gt;如lpush list1 a、lpush list1 b、 lpush list1 c 可以转化为：lpush list1 a b c。&lt;/li&gt;
&lt;li&gt;为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;aof重写方式&#34;&gt;AOF重写方式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;手动重写&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;bgrewriteaof 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;自动重写&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;auto-aof-rewrite-min-size size 
auto-aof-rewrite-percentage percentage
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;aof手动重写-bgrewriteaof指令工作原理&#34;&gt;AOF手动重写 —— bgrewriteaof指令工作原理&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/bgsave%E6%8C%87%E4%BB%A4%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/bgrewriteaof%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;aof自动重写方式&#34;&gt;AOF自动重写方式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;自动重写触发条件设置&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;auto-aof-rewrite-min-size size 
auto-aof-rewrite-percentage percent 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;自动重写触发比对参数（ 运行指令info Persistence获取具体信息 ）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;aof_current_size 
aof_base_size 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;自动重写触发条件&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91%E9%87%8D%E5%86%99%E6%9D%A1%E4%BB%B6.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;aof重写流程&#34;&gt;AOF重写流程&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/AOF%E9%87%8D%E5%86%99%E6%B5%81%E7%A8%8B1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;aof重写流程-2&#34;&gt;AOF重写流程&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/AOF%E9%87%8D%E5%86%99%E6%B5%81%E7%A8%8B2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;AOF缓冲区同步文件策略，由参数appendfsync控制&lt;/p&gt;
&lt;p&gt;系统调用write和fsync说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;write操作会触发延迟写（delayed write）机制，Linux在内核提供页缓冲区用来提高硬盘IO性能。write操作在写入系统缓冲区后直接返回。同步硬盘操作依赖于系统调度机制，列如：缓冲区页空间写满或达到特定时间周期。同步文件之前，如果此时系统故障宕机，缓冲区内数据将丢失。&lt;/li&gt;
&lt;li&gt;fsync针对单个文件操作（比如AOF文件），做强制硬盘同步，fsync将阻塞知道写入硬盘完成后返回，保证了数据持久化。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了write、fsync、Linx还提供了sync、fdatasync操作，具体API说明参见：&lt;/p&gt;
&lt;h1 id=&#34;rdb与aof区别&#34;&gt;RDB与AOF区别&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;持久化方式&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;RDB&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;AOF&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;占用存储空间&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;小（数据级：压缩）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;大（指令级：重写）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;存储速度&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;慢&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;恢复速度&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;快&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;慢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;数据安全性&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;会丢失数据&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;依据策略决定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;资源消耗&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;高 / 重量级&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;低 / 轻量级&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;启动优先级&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;低&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;高&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;rdb与aof的选择之惑&#34;&gt;RDB与AOF的选择之惑&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;对&lt;strong&gt;数据非常敏感&lt;/strong&gt;，建议使用默认的&lt;strong&gt;AOF&lt;/strong&gt;持久化方案
&lt;ul&gt;
&lt;li&gt;AOF持久化策略使用everysecond，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出现问题时，最多丢失0-1秒内的数据。&lt;/li&gt;
&lt;li&gt;注意：由于AOF文件存储体积较大，且恢复速度较慢&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据呈现&lt;strong&gt;阶段有效性&lt;/strong&gt;，建议使用&lt;strong&gt;RDB&lt;/strong&gt;持久化方案
&lt;ul&gt;
&lt;li&gt;数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且恢复速度较快，阶段点数据恢复通常采用RDB方案&lt;/li&gt;
&lt;li&gt;注意：利用RDB实现紧凑的数据持久化会使Redis降的很低&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;综合比对
&lt;ul&gt;
&lt;li&gt;RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊&lt;/li&gt;
&lt;li&gt;如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF&lt;/li&gt;
&lt;li&gt;如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB&lt;/li&gt;
&lt;li&gt;灾难恢复选用RDB&lt;/li&gt;
&lt;li&gt;双保险策略，同时开启 RDB 和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据的量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;持久化应用场景&#34;&gt;持久化应用场景&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Tips 1：&lt;s&gt;redis用于控制&lt;/s&gt;&lt;strong&gt;&lt;s&gt;数据库表主键id&lt;/s&gt;&lt;/strong&gt;~~，为数据库表主键提供生成策略，保障数据库表的主键唯一性 ~~【假如现在计算机停止工作，下一次启动要恢复时，不期望数据是从 redis 读取的。比如 id  如果用到 18 了，下一次恢复的时候从 18 恢复，大概率有问题，中间断的会导致 id 不连续，比如有一秒用了 19，但是 redis 没有记下来，下次从 18 恢复就会 id 重复。解决方案：从数据库读取，找出最大的 id ，然后加一使用。所以数据库主键 id 不建议持久化】&lt;/li&gt;
&lt;li&gt;Tips 3：&lt;s&gt;redis应用于各种结构型和非结构型&lt;/s&gt;&lt;strong&gt;&lt;s&gt;高热度数据访问加速&lt;/s&gt;&lt;/strong&gt;~~ ~~（缓存里的数据要不要数据化？）【缓存中的数据从数据库读取加载来的，从 redis 读取出来和从数据库读出来没什么区别】&lt;/li&gt;
&lt;li&gt;Tips 4：&lt;s&gt;redis 应用于&lt;/s&gt;&lt;strong&gt;&lt;s&gt;购物车&lt;/s&gt;&lt;/strong&gt;&lt;s&gt;数据存储设计&lt;/s&gt; 【购物车信息数据库内肯定要存，就导致 redis 和数据库内存的一样，所以 redis 就不额外存储】&lt;/li&gt;
&lt;li&gt;Tips 5：redis 应用于&lt;strong&gt;抢购&lt;/strong&gt;，限购类、限量发放优惠卷、激活码等业务的数据存储设计 【抢购：速度非常快，几秒钟内完成然后消失掉，如在这个过程中出现问题了，数据库可能没有持久化， 也可能记录了过程。 快速存储、快速消失的数据持久化】&lt;/li&gt;
&lt;li&gt;Tips 6：redis 应用于具有&lt;strong&gt;操作先后顺序&lt;/strong&gt;的数据控制 【临时任务，如果消息存储量不大，建议持久化】&lt;/li&gt;
&lt;li&gt;Tips 7：redis 应用于&lt;strong&gt;最新消息展示&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Tips 9：&lt;s&gt;redis 应用于同类信息的&lt;/s&gt;&lt;strong&gt;&lt;s&gt;关联搜索&lt;/s&gt;&lt;/strong&gt;~~，二度关联搜索，深度关联搜索 ~~【关系网庞大，存到数据库】&lt;/li&gt;
&lt;li&gt;Tips 12：redis 应用于基于&lt;strong&gt;黑名单&lt;/strong&gt;与&lt;strong&gt;白名单&lt;/strong&gt;设定的服务控制 【永久性存到数据库，临时性持久化】&lt;/li&gt;
&lt;li&gt;Tips 13：redis 应用于计数器组合排序功能对应的&lt;strong&gt;排名 【20个主播一起主播，进行排名，主播结束数据就消失了，如果不持久化这个信息，它也不在数据库内存储就没有了。20万人在线观看，如果不持久化记录服务器一宕机就0人在线了，所以需持久化记录快速恢复】&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Tips 15：redis 应用于&lt;strong&gt;即时任务/消息队列&lt;/strong&gt;执行管理&lt;/li&gt;
&lt;li&gt;Tips 16：redis 应用于&lt;strong&gt;按次结算的服务控制&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;Redis持久化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是持久化&lt;/li&gt;
&lt;li&gt;RDB
&lt;ul&gt;
&lt;li&gt;save&lt;/li&gt;
&lt;li&gt;bgsave&lt;/li&gt;
&lt;li&gt;配置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;AOF
&lt;ul&gt;
&lt;li&gt;持久化写策略&lt;/li&gt;
&lt;li&gt;重写&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
">Redis 持久化</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/42-dao-ji-suan-ji-wang-luo-mian-shi-gao-pin-ti-da-an-mian-shi-guan-xi-huan-de-da-an-du-zai-zhe-li/"" data-c="
          &lt;h1 id=&#34;1-谈下你对五层网络协议体系结构的理解&#34;&gt;1、谈下你对五层网络协议体系结构的理解（*）&lt;/h1&gt;
&lt;p&gt;学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%BA%94%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;1-应用层&#34;&gt;1. 应用层&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%BA%94%E7%94%A8%E5%B1%82.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;应用层（application-layer）的任务是&lt;strong&gt;通过应用进程间的交互来完成特定网络应用&lt;/strong&gt;。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。我们把应用层交互的数据单元称为报文。&lt;/p&gt;
&lt;h2 id=&#34;2-运输层&#34;&gt;2. 运输层&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%BF%90%E8%BE%93%E5%B1%82.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;运输层（transport layer）的主要任务就是负责&lt;strong&gt;向两台主机进程之间的通信提供通用的数据传输服务&lt;/strong&gt;。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%BF%90%E8%BE%93%E5%B1%82_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。&lt;/p&gt;
&lt;h2 id=&#34;3-网络层&#34;&gt;3. 网络层&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E7%BD%91%E7%BB%9C%E5%B1%82.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是&lt;strong&gt;选择合适的网间路由和交换结点， 确保数据及时传送&lt;/strong&gt;。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP / IP 体系结构中，由于网络层使用 IP 协议，因此&lt;strong&gt;分组&lt;/strong&gt;也叫 &lt;strong&gt;IP 数据报&lt;/strong&gt;，简称数据报。&lt;/p&gt;
&lt;h2 id=&#34;4-数据链路层&#34;&gt;4. 数据链路层&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;数据链路层（data link layer）通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，&lt;strong&gt;数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧&lt;/strong&gt;。每一帧包括数据和必要的控制信息（如：同步信息，地址信息，差错控制等）。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%B7%AE%E9%94%99%E6%A3%80%E9%AA%8C.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出&lt;strong&gt;数据部分&lt;/strong&gt;，上交给网络层。控制信息还使接收端能够检测到所收到的帧中&lt;strong&gt;有无差错&lt;/strong&gt;。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用&lt;strong&gt;可靠性传输协议&lt;/strong&gt;来纠正出现的差错。这种方法会使链路层的协议复杂些。&lt;/p&gt;
&lt;h2 id=&#34;5-物理层&#34;&gt;5. 物理层&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E7%89%A9%E7%90%86%E5%B1%82.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在物理层上所传送的数据单位是&lt;strong&gt;比特&lt;/strong&gt;。物理层（physical layer）的作用是实现相邻计算机节点之间&lt;strong&gt;比特流的透明传送&lt;/strong&gt;，尽可能&lt;strong&gt;屏蔽掉具体传输介质和物理设备的差异&lt;/strong&gt;。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。&lt;/p&gt;
&lt;h1 id=&#34;2-简单说下每一层对应的网络协议有哪些&#34;&gt;2、简单说下每一层对应的网络协议有哪些？（**）&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;简单记住两三个常见的就行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;计算机五层网络体系中涉及的协议非常多，下面就常用的做了列举：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%AF%8F%E4%B8%80%E5%B1%82%E5%AF%B9%E5%BA%94%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;3-arp-协议的工作原理&#34;&gt;3、ARP 协议的工作原理？（*）&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/ARP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;mac-地址&#34;&gt;MAC 地址&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/MAC%E5%9C%B0%E5%9D%80.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/MAC%E5%9C%B0%E5%9D%80_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;MAC 地址有时也被称为&lt;strong&gt;物理地址&lt;/strong&gt;，但这不意味着 MAC 属于网络体系结构中的物理层，MAC 地址属于&lt;strong&gt;数据链路层&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;ip-地址&#34;&gt;IP 地址&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/IP%E5%9C%B0%E5%9D%80.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%BB%8E%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9C%8BIP%E5%9C%B0%E5%9D%80%E4%B8%8EMAC%E5%9C%B0%E5%9D%80.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%95%B0%E6%8D%AE%E5%8C%85%E8%BD%AC%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%ADIP%E5%9C%B0%E5%9D%80%E4%B8%8EMAC%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%95%B0%E6%8D%AE%E5%8C%85%E8%BD%AC%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%ADIP%E5%9C%B0%E5%9D%80%E4%B8%8EMAC%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%95%B0%E6%8D%AE%E5%8C%85%E8%BD%AC%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%ADIP%E5%9C%B0%E5%9D%80%E4%B8%8EMAC%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5_3.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;arp-协议&#34;&gt;ARP 协议&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/ARP%E5%8D%8F%E8%AE%AE.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/ARP%E5%8D%8F%E8%AE%AE_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/ARP%E5%8D%8F%E8%AE%AE_3.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/ARP%E5%8D%8F%E8%AE%AE_4.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/ARP%E5%8D%8F%E8%AE%AE_5.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/ARP%E5%8D%8F%E8%AE%AE_6.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ARP 只能在一段链路或一个网络上使用，不能跨网络使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;网络层&lt;/strong&gt;的 ARP 协议完成了 &lt;strong&gt;IP 地址与物理地址的映射&lt;/strong&gt;。首先，每台主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP 列表中是否存在该 IP 地址对应的 MAC 地址：如果有，就直接将数据包发送到这个 MAC 地址；如果没有，就向本地网段发起一个 ARP 请求的广播包，查询此目的主机对应的 MAC 地址。&lt;/p&gt;
&lt;p&gt;此 ARP 请求数据包里包括源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址。网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址；源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。&lt;/p&gt;
&lt;h1 id=&#34;4-谈下你对-ip-地址分类的理解&#34;&gt;4、谈下你对 IP 地址分类的理解？&lt;/h1&gt;
&lt;p&gt;IP 地址是指互联网协议地址，是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP 地址编址方案将 IP 地址空间划分为 A、B、C、D、E 五类，其中 A、B、C 是基本类，D、E 类作为多播和保留使用，为特殊地址。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;每个 IP 地址包括两个标识码（ID），即网络 ID 和主机 ID。同一个物理网络上的所有主机都使用同一个网络 ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机 ID 与其对应。A~E 类地址的特点如下：&lt;/p&gt;
&lt;p&gt;A 类地址：以 0 开头，第一个字节范围：0~127；&lt;/p&gt;
&lt;p&gt;B 类地址：以 10 开头，第一个字节范围：128~191；&lt;/p&gt;
&lt;p&gt;C 类地址：以 110 开头，第一个字节范围：192~223；&lt;/p&gt;
&lt;p&gt;D 类地址：以 1110 开头，第一个字节范围为 224~239；&lt;/p&gt;
&lt;p&gt;E 类地址：以 1111 开头，保留地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB_3.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB_4.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB_5.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB_6.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;5-tcp-的主要特点是什么&#34;&gt;5、TCP 的主要特点是什么？（*）&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;TCP 是&lt;strong&gt;面向连接&lt;/strong&gt;的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的（&lt;strong&gt;一对一&lt;/strong&gt;）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP 提供&lt;strong&gt;可靠&lt;/strong&gt;交付的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复、并且按序到达；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP 提供&lt;strong&gt;全双工&lt;/strong&gt;通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面向&lt;strong&gt;字节流&lt;/strong&gt;。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;6-udp-的主要特点是什么&#34;&gt;6、UDP 的主要特点是什么？&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;UDP 是&lt;strong&gt;无连接&lt;/strong&gt;的；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UDP 使用尽最大努力交付，即&lt;strong&gt;不&lt;/strong&gt;保证&lt;strong&gt;可靠&lt;/strong&gt;交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UDP 是&lt;strong&gt;面向报文&lt;/strong&gt;的；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UDP &lt;strong&gt;没有拥塞控制&lt;/strong&gt;，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UDP 支持&lt;strong&gt;一对一、一对多、多对一和多对多&lt;/strong&gt;的交互通信；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UDP 的&lt;strong&gt;首部开销小&lt;/strong&gt;，只有 8 个字节，比 TCP 的 20 个字节的首部要短。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;7-tcp-和-udp-的区别&#34;&gt;7、TCP 和 UDP 的区别？（*）&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的运输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。&lt;/p&gt;
&lt;p&gt;UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如：QQ 语音、 QQ 视频 、直播等等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB_1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB_3.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB_4.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB_5.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;8-tcp-和-udp-分别对应的常见应用层协议有哪些&#34;&gt;8、TCP 和 UDP 分别对应的常见应用层协议有哪些？&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;TCP 对应的应用层协议&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;FTP：定义了文件传输协议，使用 21 端口。常说某某计算机开了 FTP 服务便是启动了文件传输服务。下载文件，上传主页，都要用到 FTP 服务。&lt;/p&gt;
&lt;p&gt;Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于 DOS 模式下的通信服务。如以前的 BBS 是-纯字符界面的，支持 BBS 的服务器将 23 端口打开，对外提供服务。&lt;/p&gt;
&lt;p&gt;SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么 SMTP 端口设置这个栏，服务器开放的是 25 号端口。&lt;/p&gt;
&lt;p&gt;POP3：它是和 SMTP 对应，POP3 用于接收邮件。通常情况下，POP3 协议所用的是 110 端口。也是说，只要你有相应的使用 POP3 协议的程序（例如 Fo-xmail 或 Outlook），就可以不以 Web 方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163 邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。&lt;/p&gt;
&lt;p&gt;HTTP：从 Web 服务器传输超文本到本地浏览器的传送协议。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;UDP 对应的应用层协议&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DNS：用于域名解析服务，将域名地址转换为 IP 地址。DNS 用的是 53 号端口。&lt;/p&gt;
&lt;p&gt;SNMP：简单网络管理协议，使用 161 号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。&lt;/p&gt;
&lt;p&gt;TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口 69 上使用 UDP 服务。&lt;/p&gt;
&lt;h1 id=&#34;9-详细说下-tcp-三次握手的过程&#34;&gt;9、详细说下 TCP 三次握手的过程？（*）&lt;/h1&gt;
&lt;p&gt;TCP 建立连接的过程叫做握手，握手需要在客户和服务器之间交换三个 TCP 报文段。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;最初客户端和服务端都处于 CLOSED(关闭) 状态。本例中 A（Client） 主动打开连接，B（Server） 被动打开连接。&lt;/p&gt;
&lt;p&gt;一开始，B 的 TCP 服务器进程首先创建传输控制块TCB，准备接受客户端进程的连接请求。然后服务端进程就处于 LISTEN(监听) 状态，等待客户端的连接请求。如有，立即作出响应。&lt;/p&gt;
&lt;p&gt;第一次握手：A 的 TCP 客户端进程也是首先创建传输控制块 TCB。然后，在打算建立 TCP 连接时，向 B 发出连接请求报文段，这时首部中的同步位 SYN=1，同时选择一个初始序号 seq = x。TCP 规定，SYN 报文段（即 SYN = 1 的报文段）不能携带数据，但要消耗掉一个序号。这时，TCP 客户进程进入 SYN-SENT（同步已发送）状态。&lt;/p&gt;
&lt;p&gt;第二次握手：B 收到连接请求报文后，如果同意建立连接，则向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置 1，确认号是 ack = x + 1，同时也为自己选择一个初始序号 seq = y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时 TCP 服务端进程进入 SYN-RCVD（同步收到）状态。&lt;/p&gt;
&lt;p&gt;第三次握手：TCP 客户进程收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置 1，确认号 ack = y +  1，而自己的序号 seq = x + 1。这时 ACK 报文段可以携带数据。但如果不携带数据则不消耗序号，这种情况下，下一个数据报文段的序号仍是 seq = x + 1。这时，TCP 连接已经建立，A 进入 ESTABLISHED（已建立连接）状态。&lt;/p&gt;
&lt;h1 id=&#34;10-为什么两次握手不可以呢&#34;&gt;10、为什么两次握手不可以呢？（*）&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8D%E5%8F%AF%E4%BB%A5.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;为了防止已经失效的连接请求报文段突然又传送到了 B，因而产生错误。比如下面这种情况：A 发出的第一个连接请求报文段并没有丢失，而是在网路结点长时间滞留了，以致于延误到连接释放以后的某个时间段才到达 B。本来这是一个早已失效的报文段。但是 B 收到此失效的链接请求报文段后，就误认为 A 又发出一次新的连接请求。于是就向 A 发出确认报文段，同意建立连接。&lt;/p&gt;
&lt;p&gt;对于上面这种情况，如果不进行第三次握手，B 发出确认后就认为新的运输连接已经建立了，并一直等待 A 发来数据。B 的许多资源就这样白白浪费了。&lt;/p&gt;
&lt;p&gt;如果采用了三次握手，由于 A 实际上并没有发出建立连接请求，所以不会理睬 B 的确认，也不会向 B 发送数据。B 由于收不到确认，就知道 A 并没有要求建立连接。&lt;/p&gt;
&lt;h1 id=&#34;11-为什么不需要四次握手&#34;&gt;11、为什么不需要四次握手？（*）&lt;/h1&gt;
&lt;p&gt;有人可能会说 A 发出第三次握手的信息后在没有接收到 B 的请求就已经进入了连接状态，那如果 A 的这个确认包丢失或者滞留了怎么办？&lt;/p&gt;
&lt;p&gt;我们需要明白一点，完全可靠的通信协议是不存在的。在经过三次握手之后，客户端和服务端已经可以确认之前的通信状况，都收到了确认信息。所以即便再增加握手次数也不能保证后面的通信完全可靠，所以是没有必要的。&lt;/p&gt;
&lt;h1 id=&#34;12-server-端收到-client-端的-syn-后为什么还要传回-syn&#34;&gt;12、Server 端收到 Client 端的 SYN 后，为什么还要传回 SYN？&lt;/h1&gt;
&lt;p&gt;接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。&lt;/p&gt;
&lt;p&gt;SYN 是 TCP / IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符，在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误]）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。&lt;/p&gt;
&lt;h1 id=&#34;13-传了-syn为什么还要传-ack&#34;&gt;13、传了 SYN，为什么还要传 ACK？&lt;/h1&gt;
&lt;p&gt;双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。&lt;/p&gt;
&lt;h1 id=&#34;14-详细说下-tcp-四次挥手的过程&#34;&gt;14、详细说下 TCP 四次挥手的过程？（*）&lt;/h1&gt;
&lt;p&gt;据传输结束后，通信的双方都可以释放连接。现在 A 和 B 都处于 ESTABLISHED 状态。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;第一次挥手：A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的终止控制位 FIN 置 1，其序号 seq = u（等于前面已传送过的数据的最后一个字节的序号加 1），这时 A 进入 FIN-WAIT-1（终止等待1）状态，等待 B 的确认。请注意：TCP 规定，FIN 报文段即使不携带数据，也将消耗掉一个序号。&lt;/p&gt;
&lt;p&gt;第二次挥手：B 收到连接释放报文段后立即发出确认，确认号是 ack = u + 1，而这个报文段自己的序号是 v（等于 B 前面已经传送过的数据的最后一个字节的序号加1），然后 B 就进入 CLOSE-WAIT（关闭等待）状态。TCP 服务端进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于半关闭（half-close）状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一段时间。A 收到来自 B 的确认后，就进入 FIN-WAIT-2(终止等待2)状态，等待 B 发出的连接释放报文段。&lt;/p&gt;
&lt;p&gt;第三次挥手：若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 FIN = 1。假定 B 的序号为 w（在半关闭状态，B 可能又发送了一些数据）。B 还必须重复上次已发送过的确认号 ack = u + 1。这时 B 就进入 LAST-ACK(最后确认)状态，等待 A 的确认。&lt;/p&gt;
&lt;p&gt;第四次挥手：A 在收到 B 的连接释放报文后，必须对此发出确认。在确认报文段中把 ACK 置 1，确认号 ack = w + 1，而自己的序号 seq = u + 1（前面发送的 FIN 报文段要消耗一个序号）。然后进入 TIME-WAIT(时间等待) 状态。请注意，现在 TCP 连接还没有释放掉。必须经过时间等待计时器设置的时间 2MSL（MSL：最长报文段寿命）后，A 才能进入到 CLOSED 状态，然后撤销传输控制块，结束这次 TCP 连接。当然如果 B 一收到 A 的确认就进入 CLOSED 状态，然后撤销传输控制块。所以在释放连接时，B 结束 TCP 连接的时间要早于 A。&lt;/p&gt;
&lt;h1 id=&#34;15-为什么-time-wait-状态必须等待-2msl-的时间呢&#34;&gt;15、为什么 TIME-WAIT 状态必须等待 2MSL 的时间呢？（*）&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/TIME-WAIT%E7%AD%89%E5%BE%852MSL.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;为了保证 A 发送的最后一个 ACK 报文段能够到达 B。这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK 状态的 B 收不到对已发送的 FIN + ACK 报文段的确认。B 会超时重传这个 FIN+ACK 报文段，而 A 就能在 2MSL 时间内（超时 + 1MSL 传输）收到这个重传的 FIN+ACK 报文段。接着 A 重传一次确认，重新启动 2MSL 计时器。最后，A 和 B 都正常进入到 CLOSED 状态。如果 A 在 TIME-WAIT 状态不等待一段时间，而是在发送完 ACK 报文段后立即释放连接，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段，这样，B 就无法按照正常步骤进入 CLOSED 状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;防止已失效的连接请求报文段出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;16-为什么第二次跟第三次不能合并-第二次和第三次之间的等待是什么&#34;&gt;16、为什么第二次跟第三次不能合并, 第二次和第三次之间的等待是什么?&lt;/h1&gt;
&lt;p&gt;当服务器执行第二次挥手之后, 此时证明客户端不会再向服务端请求任何数据, 但是服务端可能还正在给客户端发送数据（可能是客户端上一次请求的资源还没有发送完毕），所以此时服务端会等待把之前未传输完的数据传输完毕之后再发送关闭请求。&lt;/p&gt;
&lt;h1 id=&#34;17-保活计时器的作用&#34;&gt;17、保活计时器的作用？&lt;/h1&gt;
&lt;p&gt;除时间等待计时器外，TCP 还有一个保活计时器（keepalive  timer）。设想这样的场景：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。&lt;/p&gt;
&lt;p&gt;服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔  75 秒钟发送一次。若连续发送 10个 探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。&lt;/p&gt;
&lt;h1 id=&#34;18-tcp-协议是如何保证可靠传输的&#34;&gt;18、TCP 协议是如何保证可靠传输的？（*）&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据包校验&lt;/strong&gt;：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;对失序数据包重排序&lt;/strong&gt;：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;丢弃重复数据&lt;/strong&gt;：对于重复数据，能够丢弃重复数据；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;应答机制&lt;/strong&gt;：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;超时重发&lt;/strong&gt;：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;流量控制&lt;/strong&gt;：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP 使用的流量控制协议是可变大小的滑动窗口协议。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;19-谈谈你对停止等待协议的理解&#34;&gt;19、谈谈你对停止等待协议的理解？&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。主要包括以下几种情况：无差错情况、出现差错情况（超时重传）、确认丢失和确认迟到、确认丢失和确认迟到。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE_3.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;20-谈谈你对-arq-协议的理解&#34;&gt;20、谈谈你对 ARQ 协议的理解？&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;自动重传请求 ARQ 协议&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连续 ARQ 协议&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。&lt;/p&gt;
&lt;h1 id=&#34;21-谈谈你对滑动窗口的了解&#34;&gt;21、谈谈你对滑动窗口的了解？（*）&lt;/h1&gt;
&lt;p&gt;TCP 利用滑动窗口实现流量控制的机制。滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。&lt;/p&gt;
&lt;p&gt;TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3_1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3_3.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;22-谈下你对流量控制的理解&#34;&gt;22、谈下你对流量控制的理解？（*）&lt;/h1&gt;
&lt;p&gt;TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。&lt;/p&gt;
&lt;h1 id=&#34;23-谈下你对-tcp-拥塞控制的理解使用了哪些算法&#34;&gt;23、谈下你对 TCP 拥塞控制的理解？使用了哪些算法？&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6_1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。在某段时间，若&lt;strong&gt;对网络中某一资源的需求超过了该资源所能提供的可用部分&lt;/strong&gt;，网络的性能就要变坏。这种情况就叫&lt;strong&gt;拥塞&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致于过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。&lt;/p&gt;
&lt;p&gt;为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。&lt;/p&gt;
&lt;p&gt;TCP 的拥塞控制采用了四种算法，即：慢开始、拥塞避免、快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如：主动队列管理 AQM），以减少网络拥塞的发生。&lt;/p&gt;
&lt;h2 id=&#34;慢开始&#34;&gt;慢开始：&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%85%A2%E5%BC%80%E5%A7%8B.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。&lt;strong&gt;cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;拥塞避免&#34;&gt;拥塞避免：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D_1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D_3.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D_4.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把&lt;strong&gt;发送方的 cwnd 加 1&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D_5.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;快重传与快恢复&#34;&gt;快重传与快恢复：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%BF%AB%E9%87%8D%E4%BC%A0%E4%B8%8E%E5%BF%AB%E6%81%A2%E5%A4%8D_1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%BF%AB%E9%87%8D%E4%BC%A0%E4%B8%8E%E5%BF%AB%E6%81%A2%E5%A4%8D_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%BF%AB%E9%87%8D%E4%BC%A0%E4%B8%8E%E5%BF%AB%E6%81%A2%E5%A4%8D_3.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%BF%AB%E9%87%8D%E4%BC%A0%E4%B8%8E%E5%BF%AB%E6%81%A2%E5%A4%8D_4.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;在 TCP/IP 中，快速重传和快恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。&lt;/p&gt;
&lt;p&gt;有时，个别报文段会在网络中丢失，但实际上网络并未发生拥塞，这将导致发送方超时重传，并误认为网络发生了拥塞；发送方把拥塞窗口 cwnd 又设置为最小值 1，并错误地启动慢开始算法，因而降低了传输效率。采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。&lt;/p&gt;
&lt;p&gt;所谓快重传，就是使发送方尽快进行重传，而不是等超时重传计时器超时再重传。&lt;/p&gt;
&lt;p&gt;要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认；&lt;/p&gt;
&lt;p&gt;即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。&lt;/p&gt;
&lt;p&gt;发送方一旦收到3个连续的重复确认，就将相应的报文段立即重传，而不是等该报文段的超时重传计时器超时再重传。&lt;/p&gt;
&lt;h1 id=&#34;24-什么是粘包&#34;&gt;24、什么是粘包？&lt;/h1&gt;
&lt;p&gt;在进行 Java NIO 学习时，可能会发现：如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 把这些数据块仅仅看成一连串无结构的字节流，没有边界；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。&lt;/p&gt;
&lt;p&gt;接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。拆包和粘包的问题导致接收端在处理的时候会非常困难，因为无法区分一个完整的数据包。&lt;/p&gt;
&lt;h1 id=&#34;25-tcp-黏包是怎么产生的&#34;&gt;25、TCP 黏包是怎么产生的？&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;发送方产生粘包&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;采用 TCP 协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据。但当发送的数据包过于的小时，那么 TCP 协议默认的会启用 Nagle 算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;接收方产生粘包&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接收方采用 TCP 协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的 TCP 协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C 语言用 recv、read 等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 &amp;gt; 应用层拿数据速度）&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;h1 id=&#34;26-怎么解决拆包和粘包&#34;&gt;26、怎么解决拆包和粘包？&lt;/h1&gt;
&lt;p&gt;分包机制一般有两个通用的解决方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;特殊字符控制；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在包头首都添加数据包的长度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果使用 netty 的话，就有专门的编码器和解码器解决拆包和粘包问题了。&lt;/p&gt;
&lt;p&gt;tips：UDP 没有粘包问题，但是有丢包和乱序。不完整的包是不会有的，收到的都是完全正确的包。传送的数据单位协议是 UDP 报文或用户数据报，发送的时候既不合并，也不拆分。&lt;/p&gt;
&lt;h1 id=&#34;27-你对-http-状态码有了解吗&#34;&gt;27、你对 HTTP 状态码有了解吗？&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/HTTP%E7%8A%B6%E6%80%81%E7%A0%81.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1XX 信息&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2XX 成功&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;200 OK&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;3XX 重定向&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;301 Moved Permanently ：永久性重定向；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;302 Found ：临时性重定向；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;4XX 客户端错误&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;400 Bad Request ：请求报文中存在语法错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;403 Forbidden ：请求被拒绝。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;404 Not Found&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;5XX 服务器错误&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;500 Internal Server Error ：服务器正在执行请求时发生错误；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;28-http-状态码-301-和-302-代表的是什么有什么区别&#34;&gt;28、HTTP 状态码 301 和 302 代表的是什么？有什么区别？&lt;/h1&gt;
&lt;p&gt;301，302 都是 HTTP 状态的编码，都代表着某个 URL 发生了转移。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;区别&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;301 redirect: 301 代表永久性转移（Permanently Moved）&lt;/p&gt;
&lt;p&gt;302 redirect: 302 代表暂时性转移（Temporarily Moved）&lt;/p&gt;
&lt;h1 id=&#34;29-forward-和-redirect-的区别&#34;&gt;29、forward 和 redirect 的区别？&lt;/h1&gt;
&lt;p&gt;Forward 和 Redirect 代表了两种请求转发方式：直接转发和间接转发。&lt;/p&gt;
&lt;p&gt;直接转发方式（Forward）：客户端和浏览器只发出&lt;strong&gt;一次请求&lt;/strong&gt;，Servlet、HTML、JSP 或其它信息资源，由第二个信息资源响应该请求，在请求对象 request 中，保存的对象对于每个信息资源是共享的。&lt;/p&gt;
&lt;p&gt;间接转发方式（Redirect）：实际是&lt;strong&gt;两次 HTTP 请求&lt;/strong&gt;，服务器端在响应第一次请求的时候，让浏览器再向另外一个 URL 发出请求，从而达到转发的目的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;举个通俗的例子：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;直接转发就相当于：“A 找 B 借钱，B 说没有，B 去找 C 借，借到借不到都会把消息传递给 A”；&lt;/p&gt;
&lt;p&gt;间接转发就相当于：&amp;quot;A 找 B 借钱，B 说没有，让 A 去找 C 借&amp;quot;。&lt;/p&gt;
&lt;h1 id=&#34;30-http-方法有哪些&#34;&gt;30、HTTP 方法有哪些？&lt;/h1&gt;
&lt;p&gt;客户端发送的 请求报文 第一行为请求行，包含了方法字段。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;GET：获取资源，当前网络中绝大部分使用的都是 GET；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HEAD：获取报文首部，和 GET 方法类似，但是不返回报文实体主体部分；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;POST：传输实体主体&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PUT：上传文件，由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PATCH：对资源进行部分修改。PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OPTIONS：查询指定的 URL 支持的方法；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CONNECT：要求在与代理服务器通信时建立隧道。使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TRACE：追踪路径。服务器会将通信路径返回给客户端。发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;31-说下-get-和-post-的区别&#34;&gt;31、说下 GET 和 POST 的区别？（**）&lt;/h1&gt;
&lt;p&gt;GET 和 POST 本质都是 HTTP 请求，只不过对它们的作用做了界定和适配，并且让他们适应各自的场景。&lt;/p&gt;
&lt;p&gt;本质区别：GET 只是一次 HTTP请求，POST 先发请求头再发请求体，实际上是两次请求。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;从功能上讲，GET 一般用来从服务器上获取资源，POST 一般用来更新服务器上的资源；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从 REST 服务角度上说，GET 是幂等的，即读取同一个资源，总是得到相同的数据，而 POST 不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET 不会改变服务器上的资源，而 POST 会对服务器资源进行改变；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从请求参数形式上看，GET 请求的数据会附在 URL 之后，即将请求数据放置在 HTTP 报文的 请求头 中，以 ? 分割 URL 和传输数据，参数之间以 &amp;amp; 相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用 BASE64 加密，得出如：%E4%BD%A0%E5%A5%BD，其中 ％XX 中的 XX 为该符号以 16 进制表示的 ASCII)；而 POST 请求会把提交的数据则放置在是 HTTP 请求报文的 请求体 中；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;就安全性而言，POST 的安全性要比 GET 的安全性高，因为 GET 请求提交的数据将明文出现在 URL 上，而且 POST 请求参数则被包装到请求体中，相对更安全；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从请求的大小看，GET 请求的长度受限于浏览器或服务器对 URL 长度的限制，允许发送的数据量比较小，而 POST 请求则是没有大小限制的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;32-在浏览器中输入-url-地址到显示主页的过程&#34;&gt;32、在浏览器中输入 URL 地址到显示主页的过程？（*）&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;DNS 解析：浏览器查询 DNS，获取域名对应的 IP 地址：具体过程包括浏览器搜索自身的 DNS 缓存、搜索操作系统的 DNS 缓存、读取本地的 Host 文件和向本地 DNS 服务器进行查询等。对于向本地 DNS 服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP 连接：浏览器获得域名对应的 IP 地址以后，浏览器向服务器请求建立链接，发起三次握手；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发送 HTTP 请求：TCP 连接建立起来后，浏览器向服务器发送 HTTP 请求；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器处理请求并返回 HTTP 报文：服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;浏览器解析渲染页面：浏览器解析并渲染视图，若遇到对 js 文件、css 文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连接结束。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;33-dns-的解析过程&#34;&gt;33、DNS 的解析过程？（**）&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/DNS%E8%A7%A3%E6%9E%90_1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/DNS%E8%A7%A3%E6%9E%90_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;主机向本地域名服务器&lt;/strong&gt;的查询一般都是采用递归查询。所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的 IP 地址，或者是报错，表示无法查询到所需的 IP 地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;本地域名服务器向根域名服务器&lt;/strong&gt;的查询的迭代查询。迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，本地域名服务器得到了所要解析的 IP 地址或报错，然后把这个结果返回给发起查询的主机。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;34-谈谈你对域名缓存的了解&#34;&gt;34、谈谈你对域名缓存的了解？&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%9F%9F%E5%90%8D%E7%BC%93%E5%AD%98_1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%9F%9F%E5%90%8D%E7%BC%93%E5%AD%98_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;为了提高 DNS 查询效率，并减轻服务器的负荷和减少因特网上的 DNS 查询报文数量，在&lt;strong&gt;域名服务器&lt;/strong&gt;中广泛使用了&lt;strong&gt;高速缓存&lt;/strong&gt;，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。&lt;/p&gt;
&lt;p&gt;由于名字到地址的绑定并不经常改变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置&lt;strong&gt;计时器&lt;/strong&gt;并处理超过合理时间的项（例如：每个项目两天）。当域名服务器已从缓存中删去某项信息后又被请求查询该项信息，就必须重新到授权管理该项的域名服务器绑定信息。当权限服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名解析的正确性。&lt;/p&gt;
&lt;p&gt;不仅在本地域名服务器中需要高速缓存，在&lt;strong&gt;主机&lt;/strong&gt;中也需要。许多主机在启动时从本地服务器下载名字和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到名字时才使用域名服务器。维护本地域名服务器数据库的主机应当定期地检查域名服务器以获取新的映射信息，而且主机必须从缓存中删除无效的项。由于域名改动并不频繁，大多数网点不需花精力就能维护数据库的一致性。&lt;/p&gt;
&lt;h1 id=&#34;35-谈下你对-http-长连接和短连接的理解分别应用于哪些场景&#34;&gt;35、谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？&lt;/h1&gt;
&lt;p&gt;在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如：JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。&lt;/p&gt;
&lt;p&gt;而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码：&lt;/p&gt;
&lt;p&gt;Connection:keep-alive&lt;/p&gt;
&lt;p&gt;在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。&lt;/p&gt;
&lt;p&gt;Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如：Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。&lt;/p&gt;
&lt;h1 id=&#34;36-谈下-http-10-和-11-12-的主要变化&#34;&gt;36、谈下 HTTP 1.0 和 1.1、1.2 的主要变化？&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HTTP1.1 的主要变化：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;HTTP1.0 经过多年发展，在 1.1 提出了改进。首先是提出了长连接，HTTP 可以在一次 TCP 连接中不断发送请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后 HTTP1.1 支持只发送 header 而不发送 body。原因是先用 header 判断能否成功，再发数据，节约带宽，事实上，post 请求默认就是这样做的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTP1.1 的 host 字段。由于虚拟主机可以支持多个域名，所以一般将域名解析后得到 host。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HTTP2.0 的主要变化：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;HTTP2.0 支持多路复用，同一个连接可以并发处理多个请求，方法是把 HTTP数据包拆为多个帧，并发有序的发送，根据序号在另一端进行重组，而不需要一个个 HTTP请求顺序到达；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTP2.0 支持服务端推送，就是服务端在 HTTP 请求到达后，除了返回数据之外，还推送了额外的内容给客户端；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTP2.0 压缩了请求头，同时基本单位是二进制帧流，这样的数据占用空间更少；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTP2.0 适用于 HTTPS 场景，因为其在 HTTP和 TCP 中间加了一层 SSL 层。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;37-https-的工作过程&#34;&gt;37、HTTPS 的工作过程？（**）&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;客户端发送自己支持的加密规则给服务器，代表告诉服务器要进行连接了；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器从中选出一套加密算法和 hash 算法以及自己的身份信息（地址等）以证书的形式发送给浏览器，证书中包含服务器信息，加密公钥，证书的办法机构；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端收到网站的证书之后要做下面的事情：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;3.1 验证证书的合法性；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3.2 如果验证通过证书，浏览器会生成一串随机数，并用证书中的公钥进行加密；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3.3 用约定好的 hash 算法计算握手消息，然后用生成的密钥进行加密，然后一起发送给服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;服务器接收到客户端传送来的信息，要做下面的事情：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;4.1 用私钥解析出密码，用密码解析握手消息，验证 hash 值是否和浏览器发来的一致；&lt;/li&gt;
&lt;li&gt;4.2 使用密钥加密消息；&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;如果计算法 hash 值一致，握手成功。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;38-http-和-https-的区别&#34;&gt;&lt;strong&gt;38、HTTP 和 HTTPS 的区别？&lt;/strong&gt;&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;开销：HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;资源消耗：HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输协议，需要消耗更多的 CPU 和内存资源；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;端口不同：HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是  80，后者是 443；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安全性：HTTP 的连接很简单，是无状态的；HTTPS 协议是由 TSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;39-https-的优缺点&#34;&gt;&lt;strong&gt;39、HTTPS 的优缺点？&lt;/strong&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近 50%，增加 10% 到 20% 的耗电；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;40-什么是数字签名&#34;&gt;&lt;strong&gt;40、什么是数字签名？&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;为了避免数据在传输过程中被替换，比如黑客修改了你的报文内容，但是你并不知道，所以我们让发送端做一个数字签名，把数据的摘要消息进行一个加密，比如 MD5，得到一个签名，和数据一起发送。然后接收端把数据摘要进行 MD5 加密，如果和签名一样，则说明数据确实是真的。&lt;/p&gt;
&lt;h1 id=&#34;41-什么是数字证书&#34;&gt;&lt;strong&gt;41、什么是数字证书？&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;对称加密中，双方使用公钥进行解密。虽然数字签名可以保证数据不被替换，但是数据是由公钥加密的，如果公钥也被替换，则仍然可以伪造数据，因为用户不知道对方提供的公钥其实是假的。所以为了保证发送方的公钥是真的，CA 证书机构会负责颁发一个证书，里面的公钥保证是真的，用户请求服务器时，服务器将证书发给用户，这个证书是经由系统内置证书的备案的。&lt;/p&gt;
&lt;h1 id=&#34;42-什么是对称加密和非对称加密&#34;&gt;&lt;strong&gt;42、什么是对称加密和非对称加密？&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;对称密钥加密是指&lt;strong&gt;加密和解密使用同一个密钥&lt;/strong&gt;的方式，这种方式存在的最大问题就是密钥发送问题，即如何&lt;strong&gt;安全地将密钥发给对方&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;非对称加密指使用一对非对称密钥，即：公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的&lt;strong&gt;公钥&lt;/strong&gt;进行&lt;strong&gt;加密&lt;/strong&gt;处理，对方接收到加密信息后，使用自己的&lt;strong&gt;私钥&lt;/strong&gt;进行&lt;strong&gt;解密&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性。但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。&lt;/p&gt;
&lt;p&gt;附：计网思维导图&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
链接：&lt;a href=&#34;https://pan.baidu.com/s/1Tcrix2jNpqlS6QyobotIXw&#34;&gt;https://pan.baidu.com/s/1Tcrix2jNpqlS6QyobotIXw &lt;/a&gt;&lt;br&gt;
提取码：4l3t&lt;/p&gt;
&lt;h1 id=&#34;参考链接&#34;&gt;参考链接&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/Gy4ElItSvBoeQnN4YbMPGQ&#34;&gt;https://mp.weixin.qq.com/s/Gy4ElItSvBoeQnN4YbMPGQ&lt;/a&gt;&lt;/p&gt;
">42道计算机网络面试高频题+答案</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/mian-shi-ti-threadlocal/"" data-c="
          &lt;h1 id=&#34;一-threadlocal-介绍&#34;&gt;一、ThreadLocal 介绍&lt;/h1&gt;
&lt;h2 id=&#34;11-官方介绍&#34;&gt;1.1 官方介绍&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;/**
 * This class provides thread-local variables.  These variables differ from
 * their normal counterparts in that each thread that accesses one (via its
 * {@code get} or {@code set} method) has its own, independently initialized
 * copy of the variable.  {@code ThreadLocal} instances are typically private
 * static fields in classes that wish to associate state with a thread (e.g.,
 * a user ID or Transaction ID).
 *
 * &amp;lt;p&amp;gt;For example, the class below generates unique identifiers local to each
 * thread.
 * A thread&#39;s id is assigned the first time it invokes {@code ThreadId.get()}
 * and remains unchanged on subsequent calls.
 * &amp;lt;pre&amp;gt;
 * import java.util.concurrent.atomic.AtomicInteger;
 *
 * public class ThreadId {
 *     // Atomic integer containing the next thread ID to be assigned
 *     private static final AtomicInteger nextId = new AtomicInteger(0);
 *
 *     // Thread local variable containing each thread&#39;s ID
 *     private static final ThreadLocal&amp;amp;lt;Integer&amp;amp;gt; threadId =
 *         new ThreadLocal&amp;amp;lt;Integer&amp;amp;gt;() {
 *             &amp;amp;#64;Override protected Integer initialValue() {
 *                 return nextId.getAndIncrement();
 *         }
 *     };
 *
 *     // Returns the current thread&#39;s unique ID, assigning it if necessary
 *     public static int get() {
 *         return threadId.get();
 *     }
 * }
 * &amp;lt;/pre&amp;gt;
 * &amp;lt;p&amp;gt;Each thread holds an implicit reference to its copy of a thread-local
 * variable as long as the thread is alive and the {@code ThreadLocal}
 * instance is accessible; after a thread goes away, all of its copies of
 * thread-local instances are subject to garbage collection (unless other
 * references to these copies exist).
 *
 * @author  Josh Bloch and Doug Lea
 * @since   1.2
 */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从 Java 官方文档中的描述：&lt;code&gt;ThreadLocal&lt;/code&gt;类用来提供&lt;strong&gt;线程内部的局部变量&lt;/strong&gt;。这种变量在多线程环境下访问（通过&lt;code&gt;get&lt;/code&gt;和&lt;code&gt;set&lt;/code&gt;方法访问）时能保证各个线程的变量相对独立于其他线程内的变量。&lt;code&gt;ThreadLocal&lt;/code&gt;实例通常来说都是&lt;code&gt;private static&lt;/code&gt;类型的，用于关联线程和线程上下文。&lt;br&gt;
我们可以得知&lt;code&gt;ThreadLocal&lt;/code&gt;的作用是：提供线程内的局部变量，不同的线程之间不会相互干扰，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或组件之间一些公共变量传递的复杂度。&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;线程并发：在多并发的场景下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传递数据：我们可以通过 &lt;code&gt;ThreadLocal&lt;/code&gt; 在同一线程，不同组件中传递公共变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程隔离：每个线程的变量都是独立的，不会互相影响。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;12-基本使用&#34;&gt;1.2 基本使用&lt;/h2&gt;
&lt;h3 id=&#34;121-常用方法&#34;&gt;1.2.1 常用方法&lt;/h3&gt;
&lt;p&gt;在使用之前，我们先来认识几个 &lt;code&gt;ThreadLoal&lt;/code&gt; 的常用方法&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;方法声明&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ThreadLocal()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;创建 ThreadLocal 对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;public void set(T value)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;设置当前线程绑定的局部变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;public T get()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;获取当前线程绑定的局部变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;public void remove()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;移除当前线程绑定的局部变量&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;122-使用案列&#34;&gt;1.2.2 使用案列&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package com.ssm.threadlocal;
/**
 * 需求：线程隔离
 *  在多线程并发的场景下，每个线程中的变量都是互相独立
 *      线程 A：设置(变量1)    获取(变量1)
 *      线程 B：设置(变量2)    获取(变量2)
 */
public class MyDemo01 {
    private String content;
    private String getContent(){
        return content;
    }
    private void setContent(String content){
        this.content = content;
    }

    public static void main(String[] args) {
        MyDemo01 demo = new MyDemo01();
        for (int i = 0; i &amp;lt; 5; i++) {
            Thread thread = new Thread(()-&amp;gt;{
                /*
                    每个线程：存一个变量，过一会 取出这个变量
                 */
                demo.setContent(Thread.currentThread().getName() + &amp;quot;的数据&amp;quot;);
                System.out.println(&amp;quot; ---------------- &amp;quot;);
                System.out.println(Thread.currentThread().getName() + &amp;quot;---&amp;gt;&amp;quot; + demo.getContent());
            });
            thread.setName(&amp;quot;线程&amp;quot; + i);
            thread.start();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：部分线程取出的数据 与 它存入的数据不一样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; ---------------- 
 ---------------- 
线程2---&amp;gt;线程3的数据
 ---------------- 
线程1---&amp;gt;线程4的数据
 ---------------- 
线程4---&amp;gt;线程4的数据
线程0---&amp;gt;线程2的数据
 ---------------- 
线程3---&amp;gt;线程4的数据
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果可以看出多个线程在访问同一个变量的时候出现的异常，线程间的数据没有隔离。下面我们来看下采用 ThreadLocal 的方式来解决这个问题的例子。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.ssm.threadlocal;

/**
 * 需求：线程隔离
 *  在多线程并发的场景下，每个线程中的变量都是互相独立
 *      线程 A：设置(变量1)    获取(变量1)
 *      线程 B：设置(变量2)    获取(变量2)
 *
 *      ThreadLocal:
 *          1.set()：将变量绑定到当前线程中；
 *          2.get()：获取当前线程绑定的变量
 */
public class MyDemo01 {
    ThreadLocal&amp;lt;String&amp;gt; threadLocal = new ThreadLocal&amp;lt;&amp;gt;();
    private String getContent(){
        return threadLocal.get();
    }
    private void setContent(String content){
        // 变量绑定到当前线程中
        threadLocal.set(content);
    }

    public static void main(String[] args) {
        MyDemo01 demo = new MyDemo01();
        for (int i = 0; i &amp;lt; 5; i++) {
            Thread thread = new Thread(()-&amp;gt;{
                /*
                    每个线程：存一个变量，过一会 取出这个变量
                 */
                demo.setContent(Thread.currentThread().getName() + &amp;quot;的数据&amp;quot;);
                System.out.println(&amp;quot; ---------------- &amp;quot;);
                System.out.println(Thread.currentThread().getName() + &amp;quot;---&amp;gt;&amp;quot; + demo.getContent());
            });
            thread.setName(&amp;quot;线程&amp;quot; + i);
            thread.start();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; ---------------- 
 ---------------- 
线程3---&amp;gt;线程3的数据
 ---------------- 
线程2---&amp;gt;线程2的数据
 ---------------- 
 ---------------- 
线程4---&amp;gt;线程4的数据
线程0---&amp;gt;线程0的数据
线程1---&amp;gt;线程1的数据
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果来看，这样很好的解决了多线程之间数据隔离的问题，十分方便。&lt;/p&gt;
&lt;h2 id=&#34;13-threadlocal-与-synchronized-关键字&#34;&gt;1.3 ThreadLocal 与 synchronized 关键字&lt;/h2&gt;
&lt;h3 id=&#34;131-synchronized-同步方式&#34;&gt;1.3.1 synchronized 同步方式&lt;/h3&gt;
&lt;p&gt;这里可能有的朋友会觉得在上述例子中我们完全可以通过加锁来实现这个功能。我们首先来看一下用synchronized代码块实现的效果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.ssm.threadlocal;

/**
 * 需求：线程隔离
 *  在多线程并发的场景下，每个线程中的变量都是互相独立
 *      线程 A：设置(变量1)    获取(变量1)
 *      线程 B：设置(变量2)    获取(变量2)
 */
public class MyDemo02 {
    private String content;
    private String getContent(){
        return content;
    }
    private void setContent(String content){
        this.content = content;
    }

    public static void main(String[] args) {
        MyDemo02 demo = new MyDemo02();
        for (int i = 0; i &amp;lt; 5; i++) {
            Thread thread = new Thread(()-&amp;gt;{
                /*
                    每个线程：存一个变量，过一会 取出这个变量
                 */
                synchronized (MyDemo02.class){
                    demo.setContent(Thread.currentThread().getName() + &amp;quot;的数据&amp;quot;);
                    System.out.println(&amp;quot; ---------------- &amp;quot;);
                    System.out.println(Thread.currentThread().getName() + &amp;quot;---&amp;gt;&amp;quot; + demo.getContent());
                }

            });
            thread.setName(&amp;quot;线程&amp;quot; + i);
            thread.start();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果可以发现，加锁确实可以解决这个问题，但是在这里我们强调的是&lt;strong&gt;线程数据隔离&lt;/strong&gt;的问题，并不是&lt;strong&gt;多线程共享数据的&lt;/strong&gt;问题，在这个案例中使用&lt;code&gt;synchronized&lt;/code&gt;关键字是不合适的。&lt;/p&gt;
&lt;h3 id=&#34;132-threadlocal-与-synchronized-关键字的区别&#34;&gt;1.3.2 ThreadLocal 与 synchronized 关键字的区别&lt;/h3&gt;
&lt;p&gt;虽然T&lt;code&gt;hreadLocal&lt;/code&gt;模式与&lt;code&gt;synchronized&lt;/code&gt;关键字都用于处理多线程并发访问变量的问题，不过两者处理问题的角度和思路不同。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;synchronized&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;ThreadLocal&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;原理&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;同步机制采用 “&lt;strong&gt;以时间换空间&lt;/strong&gt;” 的方式，只提供了一分变量，让不用的线程派对访问&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ThreadLocal 采用 “&lt;strong&gt;以空间换时间&lt;/strong&gt;” 的方式，为每一个线程都提供了一份变量的副本，从而实现同时访问互不干扰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;侧重点&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;多个线程之间访问资源的同步&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;多线程中让每个线程之间的数据相互隔离&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;总结：在刚刚的案例中，虽然使用&lt;code&gt;ThreadLocal&lt;/code&gt;和&lt;code&gt;synchronized&lt;/code&gt;都能解决问题，但是使用&lt;code&gt;ThreadLocal&lt;/code&gt;更为合适，因为这样可以使程序拥有更高的并发性。&lt;/p&gt;
&lt;h1 id=&#34;二-运用场景_事务案例&#34;&gt;二、 运用场景_事务案例&lt;/h1&gt;
&lt;p&gt;​通过以上的介绍，我们已经基本了解&lt;code&gt;ThreadLocal&lt;/code&gt;的特点。但是它具体是运用在什么场景中呢？ 接下来让我们看一个案例： 事务操作。&lt;/p&gt;
&lt;h2 id=&#34;21-转账案例&#34;&gt;2.1 转账案例&lt;/h2&gt;
&lt;h3 id=&#34;211-场景构建&#34;&gt;2.1.1 场景构建&lt;/h3&gt;
&lt;p&gt;​这里我们先构建一个简单的转账场景： 有一个数据表&lt;code&gt;account&lt;/code&gt;，里面有两个用户&lt;code&gt;Jack&lt;/code&gt;和&lt;code&gt;Rose&lt;/code&gt;，用户&lt;code&gt;Jack&lt;/code&gt;  给用户&lt;code&gt;Rose&lt;/code&gt; 转账。&lt;/p&gt;
&lt;p&gt;案例的实现主要用&lt;code&gt;mysql&lt;/code&gt;数据库，&lt;code&gt;JDBC&lt;/code&gt; 和 &lt;code&gt;C3P0&lt;/code&gt; 框架。以下是详细代码 ：&lt;/p&gt;
&lt;p&gt;（1） 项目结构&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/001.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
（2） 数据准备&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 使用数据库
use test;
-- 创建一张账户表
create table account(
	id int primary key auto_increment,
	name varchar(20),
	money double
);
-- 初始化数据
insert into account values(null, &#39;Jack&#39;, 1000);
insert into account values(null, &#39;Rose&#39;, 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（3） C3P0配置文件和工具类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;c3p0-config&amp;gt;
  &amp;lt;!-- 使用默认的配置读取连接池对象 --&amp;gt;
  &amp;lt;default-config&amp;gt;
  	&amp;lt;!--  连接参数 --&amp;gt;
    &amp;lt;property name=&amp;quot;driverClass&amp;quot;&amp;gt;com.mysql.jdbc.Driver&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;jdbcUrl&amp;quot;&amp;gt;jdbc:mysql://localhost:3306/test&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;user&amp;quot;&amp;gt;root&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;password&amp;quot;&amp;gt;1234&amp;lt;/property&amp;gt;
    
    &amp;lt;!-- 连接池参数 --&amp;gt;
    &amp;lt;property name=&amp;quot;initialPoolSize&amp;quot;&amp;gt;5&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;maxPoolSize&amp;quot;&amp;gt;10&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;checkoutTimeout&amp;quot;&amp;gt;3000&amp;lt;/property&amp;gt;
  &amp;lt;/default-config&amp;gt;

&amp;lt;/c3p0-config&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（4） 工具类 ： JdbcUtils&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.itheima.transfer.utils;

import com.mchange.v2.c3p0.ComboPooledDataSource;
import java.sql.Connection;
import java.sql.SQLException;

public class JdbcUtils {
    // c3p0 数据库连接池对象属性
    private static final ComboPooledDataSource ds = new ComboPooledDataSource();
    // 获取连接
    public static Connection getConnection() throws SQLException {
        return ds.getConnection();
    }
    //释放资源
    public static void release(AutoCloseable... ios){
        for (AutoCloseable io : ios) {
            if(io != null){
                try {
                    io.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }
    
    
    public static void commitAndClose(Connection conn) {
        try {
            if(conn != null){
                //提交事务
                conn.commit();
                //释放连接
                conn.close();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void rollbackAndClose(Connection conn) {
        try {
            if(conn != null){
                //回滚事务
                conn.rollback();
                //释放连接
                conn.close();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（5） dao层代码 ： AccountDao&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.itheima.transfer.dao;

import com.itheima.transfer.utils.JdbcUtils;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class AccountDao {

    public void out(String outUser, int money) throws SQLException {
        String sql = &amp;quot;update account set money = money - ? where name = ?&amp;quot;;

        Connection conn = JdbcUtils.getConnection();
        PreparedStatement pstm = conn.prepareStatement(sql);
        pstm.setInt(1,money);
        pstm.setString(2,outUser);
        pstm.executeUpdate();

        JdbcUtils.release(pstm,conn);
    }

    public void in(String inUser, int money) throws SQLException {
        String sql = &amp;quot;update account set money = money + ? where name = ?&amp;quot;;

        Connection conn = JdbcUtils.getConnection();
        PreparedStatement pstm = conn.prepareStatement(sql);
        pstm.setInt(1,money);
        pstm.setString(2,inUser);
        pstm.executeUpdate();

        JdbcUtils.release(pstm,conn);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（6） service层代码 ： AccountService&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.itheima.transfer.service;

import com.itheima.transfer.dao.AccountDao;
import java.sql.SQLException;

public class AccountService {

    public boolean transfer(String outUser, String inUser, int money) {
        AccountDao ad = new AccountDao();
        try {
            // 转出
            ad.out(outUser, money);
            // 转入
            ad.in(inUser, money);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（7） web层代码 ： AccountWeb&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.itheima.transfer.web;

import com.itheima.transfer.service.AccountService;

public class AccountWeb {

    public static void main(String[] args) {
        // 模拟数据 : Jack 给 Rose 转账 100
        String outUser = &amp;quot;Jack&amp;quot;;
        String inUser = &amp;quot;Rose&amp;quot;;
        int money = 100;

        AccountService as = new AccountService();
        boolean result = as.transfer(outUser, inUser, money);

        if (result == false) {
            System.out.println(&amp;quot;转账失败!&amp;quot;);
        } else {
            System.out.println(&amp;quot;转账成功!&amp;quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;212-引入事务&#34;&gt;2.1.2 引入事务&lt;/h3&gt;
&lt;p&gt;​案例中的转账涉及两个DML操作： 一个转出，一个转入。这些操作是需要具备原子性的，不可分割。不然就有可能出现数据修改异常情况。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class AccountService {
    public boolean transfer(String outUser, String inUser, int money) {
        AccountDao ad = new AccountDao();
        try {
            // 转出
            ad.out(outUser, money);
            // 模拟转账过程中的异常
            int i = 1/0;
            // 转入
            ad.in(inUser, money);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以这里就需要操作事务，来保证转出和转入操作具备原子性，要么同时成功，要么同时失败。&lt;br&gt;
（1） JDBC中关于事务的操作的api&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Connection接口的方法&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;void  setAutoCommit(false)&lt;/td&gt;
&lt;td&gt;禁用事务自动提交（改为手动）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;void  commit();&lt;/td&gt;
&lt;td&gt;提交事务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;void rollback();&lt;/td&gt;
&lt;td&gt;回滚事务&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;（2） &lt;strong&gt;开启事务的注意点&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;为了保证所有的操作在一个事务中,案例中使用的连接必须是同一个:  &lt;code&gt;service&lt;/code&gt;层开启事务的&lt;code&gt;connection&lt;/code&gt;需要跟&lt;code&gt;dao&lt;/code&gt;层访问数据库的&lt;code&gt;connection&lt;/code&gt;保持一致&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程并发情况下, 每个线程只能操作各自的 &lt;code&gt;connection&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;22-常规解决方案&#34;&gt;2.2  常规解决方案&lt;/h2&gt;
&lt;h3 id=&#34;221-常规方案的实现&#34;&gt;2.2.1 常规方案的实现&lt;/h3&gt;
&lt;p&gt;基于上面给出的前提， 大家通常想到的解决方案是 ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传参: 从&lt;code&gt;service&lt;/code&gt;层将&lt;code&gt;connection&lt;/code&gt;对象向&lt;code&gt;dao&lt;/code&gt;层传递&lt;/li&gt;
&lt;li&gt;加锁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是代码实现修改的部分：&lt;/p&gt;
&lt;p&gt;（1 ) AccountService 类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.itheima.transfer.service;

import com.itheima.transfer.dao.AccountDao;
import com.itheima.transfer.utils.JdbcUtils;
import java.sql.Connection;

public class AccountService {

    public boolean transfer(String outUser, String inUser, int money) {
        AccountDao ad = new AccountDao();
        //线程并发情况下,为了保证每个线程使用各自的connection,故加锁
        synchronized (AccountService.class) {

            Connection conn = null;
            try {
                conn = JdbcUtils.getConnection();
                //开启事务
                conn.setAutoCommit(false);
                // 转出
                ad.out(conn, outUser, money);
                // 模拟转账过程中的异常
//            int i = 1/0;
                // 转入
                ad.in(conn, inUser, money);
                //事务提交
                JdbcUtils.commitAndClose(conn);
            } catch (Exception e) {
                e.printStackTrace();
                //事务回滚
                JdbcUtils.rollbackAndClose(conn);
                return false;
            }
            return true;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（2) AccountDao 类 （这里需要注意的是： connection不能在dao层释放，要在service层，不然在dao层释放，service层就无法使用了）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.itheima.transfer.dao;

import com.itheima.transfer.utils.JdbcUtils;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class AccountDao {

    public void out(Connection conn, String outUser, int money) throws SQLException{
        String sql = &amp;quot;update account set money = money - ? where name = ?&amp;quot;;
        //注释从连接池获取连接的代码,使用从service中传递过来的connection
//        Connection conn = JdbcUtils.getConnection();
        PreparedStatement pstm = conn.prepareStatement(sql);
        pstm.setInt(1,money);
        pstm.setString(2,outUser);
        pstm.executeUpdate();
        //连接不能在这里释放,service层中还需要使用
//        JdbcUtils.release(pstm,conn);
        JdbcUtils.release(pstm);
    }

    public void in(Connection conn, String inUser, int money) throws SQLException {
        String sql = &amp;quot;update account set money = money + ? where name = ?&amp;quot;;
//        Connection conn = JdbcUtils.getConnection();
        PreparedStatement pstm = conn.prepareStatement(sql);
        pstm.setInt(1,money);
        pstm.setString(2,inUser);
        pstm.executeUpdate();
//        JdbcUtils.release(pstm,conn);
        JdbcUtils.release(pstm);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;222-常规方案的弊端&#34;&gt;2.2.2 常规方案的弊端&lt;/h3&gt;
&lt;p&gt;上述方式我们看到的确按要求解决了问题，但是仔细观察，会发现这样实现的弊端：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;直接从&lt;code&gt;service&lt;/code&gt;层传递&lt;code&gt;connection&lt;/code&gt;到&lt;code&gt;dao&lt;/code&gt;层, 造成代码耦合度提高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加锁会造成线程失去并发性，程序性能降低&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;23-threadlocal解决方案&#34;&gt;2.3 ThreadLocal解决方案&lt;/h2&gt;
&lt;h3 id=&#34;231-threadlocal方案的实现&#34;&gt;2.3.1 ThreadLocal方案的实现&lt;/h3&gt;
&lt;p&gt;像这种需要在项目中进行&lt;strong&gt;数据传递&lt;/strong&gt;和&lt;strong&gt;线程隔离&lt;/strong&gt;的场景，我们不妨用&lt;code&gt;ThreadLocal&lt;/code&gt;来解决：&lt;/p&gt;
&lt;p&gt;（1） 工具类的修改： 加入ThreadLocal&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.itheima.transfer.utils;

import com.mchange.v2.c3p0.ComboPooledDataSource;
import java.sql.Connection;
import java.sql.SQLException;

public class JdbcUtils {
    //ThreadLocal对象 : 将connection绑定在当前线程中
    private static final ThreadLocal&amp;lt;Connection&amp;gt; tl = new ThreadLocal();

    // c3p0 数据库连接池对象属性
    private static final ComboPooledDataSource ds = new ComboPooledDataSource();

    // 获取连接
    public static Connection getConnection() throws SQLException {
        //取出当前线程绑定的connection对象
        Connection conn = tl.get();
        if (conn == null) {
            //如果没有，则从连接池中取出
            conn = ds.getConnection();
            //再将connection对象绑定到当前线程中
            tl.set(conn);
        }
        return conn;
    }

    //释放资源
    public static void release(AutoCloseable... ios) {
        for (AutoCloseable io : ios) {
            if (io != null) {
                try {
                    io.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public static void commitAndClose() {
        try {
            Connection conn = getConnection();
            //提交事务
            conn.commit();
            //解除绑定
            tl.remove();
            //释放连接
            conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void rollbackAndClose() {
        try {
            Connection conn = getConnection();
            //回滚事务
            conn.rollback();
            //解除绑定
            tl.remove();
            //释放连接
            conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（2） AccountService类的修改：不需要传递connection对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.itheima.transfer.service;

import com.itheima.transfer.dao.AccountDao;
import com.itheima.transfer.utils.JdbcUtils;
import java.sql.Connection;

public class AccountService {

    public boolean transfer(String outUser, String inUser, int money) {
        AccountDao ad = new AccountDao();

        try {
            Connection conn = JdbcUtils.getConnection();
            //开启事务
            conn.setAutoCommit(false);
            // 转出 ： 这里不需要传参了 ！
            ad.out(outUser, money);
            // 模拟转账过程中的异常
//            int i = 1 / 0;
            // 转入
            ad.in(inUser, money);
            //事务提交
            JdbcUtils.commitAndClose();
        } catch (Exception e) {
            e.printStackTrace();
            //事务回滚
           JdbcUtils.rollbackAndClose();
            return false;
        }
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（3） AccountDao类的修改：照常使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.itheima.transfer.dao;

import com.itheima.transfer.utils.JdbcUtils;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class AccountDao {

    public void out(String outUser, int money) throws SQLException {
        String sql = &amp;quot;update account set money = money - ? where name = ?&amp;quot;;
        Connection conn = JdbcUtils.getConnection();
        PreparedStatement pstm = conn.prepareStatement(sql);
        pstm.setInt(1,money);
        pstm.setString(2,outUser);
        pstm.executeUpdate();
        //照常使用
//        JdbcUtils.release(pstm,conn);
        JdbcUtils.release(pstm);
    }

    public void in(String inUser, int money) throws SQLException {
        String sql = &amp;quot;update account set money = money + ? where name = ?&amp;quot;;
        Connection conn = JdbcUtils.getConnection();
        PreparedStatement pstm = conn.prepareStatement(sql);
        pstm.setInt(1,money);
        pstm.setString(2,inUser);
        pstm.executeUpdate();
//        JdbcUtils.release(pstm,conn);
        JdbcUtils.release(pstm);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;232-threadlocal方案的好处&#34;&gt;2.3.2 ThreadLocal方案的好处&lt;/h3&gt;
&lt;p&gt;从上述的案例中我们可以看到， 在一些特定场景下，&lt;code&gt;ThreadLocal&lt;/code&gt;方案有两个突出的优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;传递数据 ： 保存每个线程绑定的数据，在需要的地方可以直接获取, 避免参数直接传递带来的代码耦合问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程隔离 ： 各线程之间的数据相互隔离却又具备并发性，避免同步方式带来的性能损失&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;三-threadlocal的内部结构&#34;&gt;三、ThreadLocal的内部结构&lt;/h1&gt;
&lt;p&gt;通过以上的学习，我们对&lt;code&gt;ThreadLocal&lt;/code&gt;的作用有了一定的认识。现在我们一起来看一下&lt;code&gt;ThreadLocal&lt;/code&gt;的内部结构，探究它能够实现线程数据隔离的原理。&lt;/p&gt;
&lt;h2 id=&#34;31常见的误解&#34;&gt;3.1常见的误解&lt;/h2&gt;
&lt;p&gt;通常，如果我们不去看源代码的话，我猜 &lt;code&gt;ThreadLocal&lt;/code&gt; 是这样子设计的：每个&lt;code&gt;ThreadLocal&lt;/code&gt; 类都创建一个 &lt;code&gt;Map&lt;/code&gt;，然后用线程作为&lt;code&gt;Map&lt;/code&gt;的&lt;code&gt;key&lt;/code&gt;，要存储的局部变量作为&lt;code&gt;Map&lt;/code&gt;的&lt;code&gt;value&lt;/code&gt;，这样就能达到各个线程的局部变量隔离的效果。这是最简单的设计方法，&lt;code&gt;JDK&lt;/code&gt;最早期的&lt;code&gt;ThreadLocal&lt;/code&gt;就是这样设计的。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%97%A9%E6%9C%9FThreadLocal.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;32-现在的设计&#34;&gt;3.2 现在的设计&lt;/h2&gt;
&lt;p&gt;但是，&lt;code&gt;JDK&lt;/code&gt;后面优化了设计方案，&lt;code&gt;JDK8&lt;/code&gt; 中 &lt;code&gt;ThreadLocal&lt;/code&gt;的设计是：每个&lt;code&gt;Thread&lt;/code&gt;维护一个&lt;code&gt;ThreadLocalMap&lt;/code&gt; 哈希表，这个哈希表的&lt;code&gt;key&lt;/code&gt;是&lt;code&gt;ThreadLocal&lt;/code&gt;实例本身，&lt;code&gt;value&lt;/code&gt;才是真正要存储的值&lt;code&gt;object&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;（1）每个&lt;code&gt;Thread&lt;/code&gt;线程内部都有一个&lt;code&gt;Map（ThreadLocalMap）&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（2）&lt;code&gt;Map&lt;/code&gt;里面存储&lt;code&gt;ThreadLocal&lt;/code&gt;对象（&lt;code&gt;key&lt;/code&gt;）和线程的变量副本（&lt;code&gt;value&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;（3）&lt;code&gt;Thread&lt;/code&gt;内部的&lt;code&gt;Map&lt;/code&gt;是由&lt;code&gt;ThreadLocal&lt;/code&gt;维护的，由ThreadLocal负责向map获取和设置线程的变量值。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/JDK8ThreadLocal.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;33-jdk8的设计方案两个好处&#34;&gt;3.3 JDK8的设计方案两个好处&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;每个&lt;code&gt;Map&lt;/code&gt;存储的&lt;code&gt;Entry&lt;/code&gt;数量变少&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;[在早期版本内，Map 的 Entry 数量由 Thread 决定；而 JDK8 中，Map 的 Entry 数量由 ThreadLocal 决定，一般情况下 ThreadLocal 数量是比 Thread 少的]&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;当&lt;code&gt;Thread&lt;/code&gt;销毁的时候，&lt;code&gt;ThreadLocalMap&lt;/code&gt;也会随之销毁，减少内存的使用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;[早期版本内，ThreadLocalMap 由 ThreadLocal 维护；而 JDK8 中，ThreadLocalMap 由 Thread 维护，当 Thread 销毁，ThreadLocalMap 也会销毁]&lt;/p&gt;
&lt;h1 id=&#34;四-threadlocal-的和核心方法源码&#34;&gt;四、ThreadLocal 的和核心方法源码&lt;/h1&gt;
&lt;p&gt;基于&lt;code&gt;ThreadLocal&lt;/code&gt;的内部结构，我们继续分析它的核心方法源码，更深入的了解其操作原理。&lt;/p&gt;
&lt;p&gt;除了构造方法之外，&lt;code&gt;ThreadLocal&lt;/code&gt;对外暴露的方法有以下4个：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;方法声明&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;protected T initialValue()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;返回当前线程局部变量的初始值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;public void set(T value)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;设置当前线程绑定的局部变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;public T get()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;获取当前线程绑定的局部变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;public void remove()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;移除当前线程绑定的局部变量&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以下是这4个方法的详细源码分析（为了保证思路清晰，&lt;code&gt;ThreadLocalMap&lt;/code&gt;部分暂时不展开，下一个知识点详解）&lt;/p&gt;
&lt;h2 id=&#34;41-set方法&#34;&gt;4.1 set方法&lt;/h2&gt;
&lt;p&gt;（1）源码和对应的中文注释&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 设置当前线程对应的 ThreadLocal 的值
 * @param value 将要保存在当前线程对应的ThreadLocal的值
 */
public void set(T value) {
    // 获取当前线程对象
    Thread t = Thread.currentThread();
    // 获取当前线程对象中维护的 ThreadLocalMap 对象
    ThreadLocalMap map = getMap(t);
    // 判断 map 是否存在
    if (map != null)
        // 存在则调用 map.set 设置此实体 Entry
        map.set(this, value);
    else
        // 1）当前线程 Thread 不存在 ThreadLocalMap 对象
        // 2）则调用 createMap 进行 ThreadLocalMap 对象的初始化
        // 3）并将 t（当前线程）和value（t对应的值）作为第一个 entry 存放至 ThreadLocalMap 中
        createMap(t, value);
}
/**
 * 获取当前线程 Thread 对应维护的 ThreadLocalMap
 *
 * @param  t the current thread 当前线程
 * @return the map 对应维护的 ThreadLocalMap
 */

ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}

/**
 * 创建当前线程 Thread 对应维护的 ThreadLocalMap
 *
 * @param t the current thread 当前线程
 * @param firstValue value for the initial entry of the map 存放到 map 中第一个 entry 值 
 */
void createMap(Thread t, T firstValue) {
    // 这里的 this 是调用此方法的threadLocal
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（2）代码执行流程&lt;br&gt;
A.首先获取当前线，并根据当前线程获取一个&lt;code&gt;Map&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;B.如果获取的&lt;code&gt;Map&lt;/code&gt;不为空，则将参数设置到&lt;code&gt;Map&lt;/code&gt;中（当前&lt;code&gt;ThreadLocal&lt;/code&gt;的引用作为&lt;code&gt;key&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;C.如果&lt;code&gt;Map&lt;/code&gt;为空，则给该线程创建&lt;code&gt;Map&lt;/code&gt;，并设置初始值&lt;/p&gt;
&lt;h2 id=&#34;42-get方法&#34;&gt;4.2 get方法&lt;/h2&gt;
&lt;p&gt;（1）源码和对应的中文注释&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 返回当前线程中保存 ThreadLocal 的值
 * 当前线程没有此 ThreadLocal 变量
 * 则它会通过调用 {@link #initialValue} 方法进行初始化
 *
 * @return 返回当前线程对应此 ThreadLocal 的值
 */
public T get() {
    // 获取当前线程对象
    Thread t = Thread.currentThread();
    // 获取当前线程中维护的 ThreadLocalMap 对象
    ThreadLocal.ThreadLocalMap map = getMap(t);
    // 如果此 map 存在
    if (map != null) {
        // 以当前的 ThreadLocal 为 key，调用 getEntry 获取对应的存储实体 e
        ThreadLocal.ThreadLocalMap.Entry e = map.getEntry(this);
        // 对 e 进行判空
        if (e != null) {
            @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
            // 获取存储实体 e 对应的 value 值，即为我们想要的当前线程对应此 ThreadLocal 的值
            T result = (T)e.value;
            return result;
        }
    }
    /*
        初始化：有两种情况执行当前代码
        第一种情况：map 不存在，表示此线程没有维护的 ThreadLocalMap 对象
        第二种情况：map 存在，但是没有与当前 ThreadLocal 关联的 Entry
     */
    return setInitialValue();
}
/**
 * 初始化
 *
 * @return the initial value
 */
private T setInitialValue() {
    // 调用 initialValue 获取初始化的值
    // 此方法可以被子类重写，如果不重写默认返回 null
    T value = initialValue();
    // 获取当前线程对象
    Thread t = Thread.currentThread();
    // 获取此线程对象中维护的 ThreadLocalMap 对象
    ThreadLocal.ThreadLocalMap map = getMap(t);
    // 判断 map 是否存在
    if (map != null)
        // 存在则调用 map.set 设置此实体 entry
        map.set(this, value);
    else
        // 1)当前线程 Thread 不存在 ThreadLocalMap 对象
        // 2)则调用 createMap 进行 ThreadLocalMap 对象的初始化
        // 3)并将 t(当前线程)和 value(t对应的值)作为第一个 entry 存放至 ThreadLocalMap 中
        createMap(t, value);
    // 返回设置的值 value
    return value;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（2）代码执行流程&lt;br&gt;
A.首先获取当前线程，根据当前线程获取一个&lt;code&gt;Map&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;B.如果获取的&lt;code&gt;Map&lt;/code&gt;不为空，则在&lt;code&gt;Map&lt;/code&gt;中以&lt;code&gt;ThreadLocal&lt;/code&gt;的引用作为&lt;code&gt;key&lt;/code&gt;来在&lt;code&gt;Map&lt;/code&gt;中获取对应的&lt;code&gt;Entry&lt;/code&gt;，否则转到D&lt;/p&gt;
&lt;p&gt;C.如果&lt;code&gt;e&lt;/code&gt;不为&lt;code&gt;null&lt;/code&gt;，则返回&lt;code&gt;e.value&lt;/code&gt;，否则转到D&lt;/p&gt;
&lt;p&gt;D.&lt;code&gt;Map&lt;/code&gt;为空或者&lt;code&gt;e&lt;/code&gt;为空，则通过&lt;code&gt;initiaValue&lt;/code&gt;函数获取初始值&lt;code&gt;value&lt;/code&gt;，然后用&lt;code&gt;ThreadLocal&lt;/code&gt;的引用和&lt;code&gt;value&lt;/code&gt;作为&lt;code&gt;firstKey&lt;/code&gt;和&lt;code&gt;firstValue&lt;/code&gt;创建一个新的&lt;code&gt;Map&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;总结：&lt;strong&gt;先获取当前线程的ThreadLocalMap变量，如果存在则返回值，不存在则创建并返回初始值&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;43-remove方法&#34;&gt;4.3 remove方法&lt;/h2&gt;
&lt;p&gt;（1）源码和对应的中文注释&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 删除当前线程中保存的 ThreadLocal 对应的实体 entry
 */
public void remove() {
    // 获取当前线程对象中维护的 ThreadLocalMap
    ThreadLocal.ThreadLocalMap m = getMap(Thread.currentThread());
    // 如果此 map 存在
    if (m != null)
        // 存在则调用 map.remove
        // 以当前 ThreadLocal 为 key 删除对应的实体 entry
        m.remove(this);
}

        /**
         * 移除 key 为给定值的 Entry 节点
         */
        private void remove(ThreadLocal&amp;lt;?&amp;gt; key) {
            // 暂存 Entry 数组
            Entry[] tab = table;
            int len = tab.length;
            // 获取当前 key 对应的 Entry 在数组中的位置
            int i = key.threadLocalHashCode &amp;amp; (len-1);
            for (Entry e = tab[i];
                 e != null;
                 e = tab[i = nextIndex(i, len)]) {
                if (e.get() == key) {
                    e.clear();
                    expungeStaleEntry(i);
                    return;
                }
            }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（2）代码执行流程&lt;br&gt;
A.首先获取当前线程，并根据当前线程获取一个&lt;code&gt;Map&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;B.如果获取的&lt;code&gt;Map&lt;/code&gt;不为空，则移除当前&lt;code&gt;ThreadLocal&lt;/code&gt;对象对应的&lt;code&gt;Entry&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;44-initialvalue方法&#34;&gt;4.4 initialValue方法&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 返回当前线程对应的ThreadLocal的初始值
 * 
 * 此方法的第一次调用发生在，当线程通过get方法访问此线程的ThreadLocal值时
 * 除非线程先调用了set方法，在这种情况下，initialvalue 才不会被这个线程调用。
 * 通常情况下，每个线程最多调用一次这个方法。
 * &amp;lt;p&amp;gt;这个方法仅仅简单的返回nu11{@code nu11}；
 * 如果程序员想ThreadLocal线程局部变量有一个除null 以外的初始值，
 * 必须通过子类继承{@code ThreadLocal}的方式去重写此方法
 * 通常，可以通过匿名内部类的方式实现
 * 
 * @return 当前 ThreadLocal 的初始值
 */
protected T initialValue() {
    return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此方法的作用是返回该线程局部变量的初始值。&lt;br&gt;
（1）这个方法是一个延迟调用方法，从面的代码我们得知，在&lt;code&gt;set&lt;/code&gt;方法还未调用而先调用了&lt;code&gt;get&lt;/code&gt;方法时才执行，并且仅执行1次。&lt;/p&gt;
&lt;p&gt;（2）这个方法缺省实现直接返回一个&lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;（3）如果想要一个除&lt;code&gt;null&lt;/code&gt;之外的初始值，可以重写此方法。（备注：该方法是一个&lt;code&gt;protected&lt;/code&gt;的方法，显然是为了让子类覆盖而设计的）&lt;/p&gt;
&lt;h1 id=&#34;五-threadlocalmap源码分析&#34;&gt;五、ThreadLocalMap源码分析&lt;/h1&gt;
&lt;p&gt;在分析&lt;code&gt;ThreadLocal&lt;/code&gt;方法的时候，我们了解到&lt;code&gt;ThreadLocal&lt;/code&gt;的操作实际上是围绕&lt;code&gt;ThreadLocalMap&lt;/code&gt;展开的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ThreadLocalMap&lt;/code&gt;的源码相对比较复杂，我们从以下三个方面进行讨论。&lt;/p&gt;
&lt;h2 id=&#34;51基本结构&#34;&gt;5.1基本结构&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ThreadLocalMap&lt;/code&gt;是&lt;code&gt;ThreadLocal&lt;/code&gt;的内部类，没有实现&lt;code&gt;Map&lt;/code&gt;接口，用独立的方式实现了&lt;code&gt;Map&lt;/code&gt;的功能，其内部的&lt;code&gt;Entry&lt;/code&gt;也是独立实现。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/ThreadLocal%E7%9A%84UML.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;（1）成员变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 初始容量 - 必须是 2 的整次幂
 */
private static final int INITIAL_CAPACITY = 16;

/**
 * 存放数据的 table，Entry类的定义在下面分析
 * 同样，数组长度必须是 2 的整次幂。
 */
private ThreadLocal.ThreadLocalMap.Entry[] table;

/**
 * 数组里面 entrys 的个数，可以用于判断 table 当前使用量是否超过阈值
 */
private int size = 0;

/**
 * 进行扩容的阈值，表使用量大于它的时候进行扩容。
 */
private int threshold; // Default to 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;跟HashMap类似，&lt;code&gt;INITIAL_CAPACITY&lt;/code&gt;代表这个&lt;code&gt;Map&lt;/code&gt;的初始容量；&lt;code&gt;table&lt;/code&gt;是一个&lt;code&gt;Entry&lt;/code&gt;类型的数组，用于存储数据；&lt;code&gt;size&lt;/code&gt;代表表中的存储数目；&lt;code&gt;threshold&lt;/code&gt; 代表需要扩容时对应 &lt;code&gt;size&lt;/code&gt;的阈值。&lt;br&gt;
（2）存储结构-Entry&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Entry 继承 WeakReference，并且用 ThreadLocal 作为 key
 * 如果 key 为 null(entry.get() == null)，意味着 key 不再被引用，
 * 因此这时候 entry 也可以从 table 中清除
 */
static class Entry extends WeakReference&amp;lt;ThreadLocal&amp;lt;?&amp;gt;&amp;gt; {
    /** The value associated with this ThreadLocal. */
    Object value;

    Entry(ThreadLocal&amp;lt;?&amp;gt; k, Object v) {
        super(k);
        value = v;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;ThreadLocalMap&lt;/code&gt;中，也是用&lt;code&gt;Entry&lt;/code&gt;来保存&lt;code&gt;K-V&lt;/code&gt;结构数据的。不过&lt;code&gt;Entry&lt;/code&gt;中的&lt;code&gt;key&lt;/code&gt;只能是&lt;code&gt;ThreadLocal&lt;/code&gt;对象，这点在构造方法中已经限定死了。&lt;br&gt;
另外，&lt;code&gt;Entry&lt;/code&gt;继承&lt;code&gt;WeakReference&lt;/code&gt;，也就是&lt;code&gt;key（ThreadLocal）&lt;/code&gt;是弱引用，其目的是将&lt;code&gt;ThreadLocal&lt;/code&gt;对象的生命周期和线程生命周期解绑。&lt;/p&gt;
&lt;h2 id=&#34;52弱引用和内存泄漏&#34;&gt;5.2弱引用和内存泄漏&lt;/h2&gt;
&lt;p&gt;有些程序员在使用&lt;code&gt;ThreadLocal&lt;/code&gt;的过程中会发现有内存泄漏的情况发生，就猜测这个内存泄漏跟&lt;code&gt;Entry&lt;/code&gt;中使用了&lt;strong&gt;弱引用&lt;/strong&gt;的&lt;code&gt;key&lt;/code&gt;有关系。这个理解其实是不对的。&lt;/p&gt;
&lt;p&gt;我们先来回顾这个问题中涉及的几个名词概念，再来分析问题。&lt;/p&gt;
&lt;h3 id=&#34;1内存泄漏相关概念&#34;&gt;（1）内存泄漏相关概念&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Memory overflow：内存溢出，没有足够的内存提供申请者使用。&lt;/li&gt;
&lt;li&gt;Memory leak：内存泄漏是指程序中&lt;strong&gt;己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费&lt;/strong&gt;，导致程序运行速度减慢甚至系统溃等严重后果。内存泄漏的堆积终将导致内存溢出。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2弱引用相关概念&#34;&gt;（2）弱引用相关概念&lt;/h3&gt;
&lt;p&gt;Java中的引用有4种类型：强、软、弱、虚。当前这个问题主要涉及到强引用和弱引用：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;强引用&lt;/strong&gt;（&amp;quot;Strong”Reference），就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾回收器就不会回收这种对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;弱引用&lt;/strong&gt;（WeakReference），垃圾回收器一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。&lt;/p&gt;
&lt;h3 id=&#34;3如果key使用强引用&#34;&gt;（3）如果key使用强引用&lt;/h3&gt;
&lt;p&gt;假设&lt;code&gt;ThreadLocalMap&lt;/code&gt;中的&lt;code&gt;key&lt;/code&gt;使用了强引用，那么会出现内存泄漏吗？&lt;/p&gt;
&lt;p&gt;此时&lt;code&gt;ThreadLocal&lt;/code&gt;的内存图（实线表示强引用）如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/key%E5%BC%BA%E5%BC%95%E7%94%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;1.假设在业务代码中使用完&lt;code&gt;ThreadLocal&lt;/code&gt;，&lt;code&gt;ThreadLocal Ref&lt;/code&gt;被回收了。&lt;/p&gt;
&lt;p&gt;2.但是因为&lt;code&gt;ThreadLocalMap&lt;/code&gt;的&lt;code&gt;Entry&lt;/code&gt;强引用了&lt;code&gt;ThreadLocal&lt;/code&gt;，造成&lt;code&gt;ThreadLocal&lt;/code&gt;无法被回收。&lt;/p&gt;
&lt;p&gt;3.在没有手动删除这个&lt;code&gt;Entry&lt;/code&gt;以及&lt;code&gt;CurrentThread&lt;/code&gt;依然运行的前提下，始终有强引用链&lt;code&gt;ThreadRef-&amp;gt;CurrentThread-&amp;gt;ThreadLocalMap-&amp;gt;Entry&lt;/code&gt;，&lt;code&gt;Entry&lt;/code&gt;就不会被回收（&lt;code&gt;Entry&lt;/code&gt;中包括了&lt;code&gt;ThreadLocal&lt;/code&gt;实例和&lt;code&gt;value&lt;/code&gt;），&lt;strong&gt;导致&lt;code&gt;Entry&lt;/code&gt;内存泄漏&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;也就是说，&lt;code&gt;ThreadLocalMap&lt;/code&gt;中的&lt;code&gt;key&lt;/code&gt;使用了强引用，是无法完全避免内存泄漏的。&lt;/p&gt;
&lt;h3 id=&#34;4如果key使用弱引用&#34;&gt;（4）如果key使用弱引用&lt;/h3&gt;
&lt;p&gt;那么&lt;code&gt;ThreadLocalMap&lt;/code&gt;中的&lt;code&gt;key&lt;/code&gt;使用了弱引用，会出现内存泄漏吗？此时&lt;code&gt;ThreadLocal&lt;/code&gt;的内存图（实线表示强引用，虚线表示弱引用）如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/key%E5%BC%B1%E5%BC%95%E7%94%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;同样假设在业务代码中使用完&lt;code&gt;ThreadLocal&lt;/code&gt;，&lt;code&gt;ThreadLocal Ref&lt;/code&gt;被回收了。&lt;/p&gt;
&lt;p&gt;由于&lt;code&gt;ThreadLocalMap&lt;/code&gt;只持有&lt;code&gt;ThreadLocal&lt;/code&gt;的弱引用，没有任何强引用指向&lt;code&gt;Threadlocal&lt;/code&gt;实例，所以&lt;code&gt;Threadlocal&lt;/code&gt;就可以顺利被&lt;code&gt;gc&lt;/code&gt;回收，此时&lt;code&gt;Entry&lt;/code&gt;中的&lt;code&gt;key=null&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但是在没有手动删除这个&lt;code&gt;Entry&lt;/code&gt;以及&lt;code&gt;CurrentThread&lt;/code&gt;依然运行的前提下，也存在有强引用链 &lt;code&gt;ThreadRef -&amp;gt;CurrentThread-&amp;gt;ThreadLocalMap-&amp;gt;Entry-&amp;gt;value&lt;/code&gt;，&lt;code&gt;value&lt;/code&gt;不会被回收，而这块&lt;code&gt;value&lt;/code&gt;永远不会被访问到了，&lt;strong&gt;导致&lt;code&gt;value&lt;/code&gt;内存泄漏&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;也就是说，&lt;code&gt;ThreadLocalMap&lt;/code&gt;中的&lt;code&gt;key&lt;/code&gt;使用了弱引用，也有可能内存泄漏。&lt;/p&gt;
&lt;h3 id=&#34;5出现内存泄漏的真实原因&#34;&gt;（5）出现内存泄漏的真实原因&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9C%9F%E6%AD%A3%E5%8E%9F%E5%9B%A0.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;比较以上两种情况，我们就会发现，内存泄漏的发生跟&lt;code&gt;ThreadLocalMap&lt;/code&gt;中的&lt;code&gt;key&lt;/code&gt;是否使用弱引用是没有关系的。那么内存泄漏的的真正原因是什么呢？&lt;/p&gt;
&lt;p&gt;细心的同学会发现，在以上两种内存泄漏的情况中，都有两个前提：&lt;/p&gt;
&lt;p&gt;1.没有手动删除这个&lt;code&gt;Entry&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;code&gt;CurrentThread&lt;/code&gt;依然运行&lt;/p&gt;
&lt;p&gt;第一点很好理解，只要在使用完&lt;code&gt;ThreadLocal&lt;/code&gt;，调用其&lt;code&gt;remove&lt;/code&gt;方法删除对应的&lt;code&gt;Entry&lt;/code&gt;，就能避免内存泄漏。第二点稍微复杂一点，由于&lt;code&gt;ThreadLocalMap&lt;/code&gt;是&lt;code&gt;Thread&lt;/code&gt;的一个属性，被当前线程所引用，所以它的生命周期跟&lt;code&gt;Thread&lt;/code&gt;一样长。那么在使用完&lt;code&gt;ThreadLocal&lt;/code&gt;的使用，如果当前&lt;code&gt;Thread&lt;/code&gt;也随之执行结束，&lt;code&gt;ThreadLocalMap&lt;/code&gt;自然也会被&lt;code&gt;gc&lt;/code&gt;回收，从根源上避免了内存泄漏。&lt;/p&gt;
&lt;p&gt;综上，&lt;code&gt;ThreadLocal&lt;/code&gt;内存泄漏的根源是：由于&lt;code&gt;ThreadLocalMap&lt;/code&gt;的生命周期跟&lt;code&gt;Thread&lt;/code&gt;一样长，如果没有手动删除对应&lt;code&gt;key&lt;/code&gt;就会导致内存泄漏。&lt;/p&gt;
&lt;h3 id=&#34;6为什么使用弱引用&#34;&gt;（6）为什么使用弱引用&lt;/h3&gt;
&lt;p&gt;根据刚才的分析，我们知道了：无论使用&lt;code&gt;ThreadLocalMap&lt;/code&gt;中的&lt;code&gt;key&lt;/code&gt;使用哪种类型引用都无法完全避免内存泄漏，跟使用弱引用没有关系。要避免内存泄漏有两种方式：&lt;/p&gt;
&lt;p&gt;1.使用完&lt;code&gt;ThreadLocal&lt;/code&gt;，调用其&lt;code&gt;remove&lt;/code&gt;方法删除对应的&lt;code&gt;Entry&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2.使用完&lt;code&gt;ThreadLocal&lt;/code&gt;，当前&lt;code&gt;Thread&lt;/code&gt;也随之运行结束&lt;/p&gt;
&lt;p&gt;相对第一种方式，第二种方式显然更不好控制，特别是使用线程池的时候，线程结束是不会销毁的。&lt;/p&gt;
&lt;p&gt;也就是说，只要记得在使用完&lt;code&gt;ThreadLocal&lt;/code&gt;及时的调用&lt;code&gt;remove&lt;/code&gt;，无论&lt;code&gt;key&lt;/code&gt;是强引用还是弱引用都不会有问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么为什么key要用弱引用呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事实上，在&lt;code&gt;ThreadLocalMap&lt;/code&gt;中的&lt;code&gt;set/getEntry&lt;/code&gt;方法中，会对&lt;code&gt;key&lt;/code&gt;为&lt;code&gt;null&lt;/code&gt;（也即是&lt;code&gt;ThreadLocal&lt;/code&gt;为&lt;code&gt;null&lt;/code&gt;）进行判断，如果为&lt;code&gt;null&lt;/code&gt;的话，那么是会对&lt;code&gt;value&lt;/code&gt;置为&lt;code&gt;null&lt;/code&gt;的。&lt;/p&gt;
&lt;p&gt;这就意味着使用完&lt;code&gt;ThreadLocal&lt;/code&gt;，&lt;code&gt;CurrentThread&lt;/code&gt;依然运行的前提下，就算忘记调用&lt;code&gt;remove&lt;/code&gt;方法，弱引用比强引用可以多一层保障：弱引用的&lt;code&gt;ThreadLocal&lt;/code&gt;会被回收，对应的&lt;code&gt;value&lt;/code&gt;在下一次&lt;code&gt;ThreadLocalMap&lt;/code&gt;调用&lt;code&gt;set&lt;/code&gt;，&lt;code&gt;get&lt;/code&gt;，&lt;code&gt;remove&lt;/code&gt;中的任一方法的时候会被清除，从而避免内存泄漏。&lt;/p&gt;
&lt;h2 id=&#34;53hash冲突的解决&#34;&gt;5.3hash冲突的解决&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;hash&lt;/code&gt;冲突的解决是&lt;code&gt;Map&lt;/code&gt;中的一个重要内容。我们以&lt;code&gt;hash&lt;/code&gt;冲突的解决为线索，来研究一下&lt;code&gt;ThreadLocalMap&lt;/code&gt;的核心源码。&lt;/p&gt;
&lt;h3 id=&#34;1首先从threadlocal的set方法入手&#34;&gt;（1）首先从ThreadLocal的set(）方法入手&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}
void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个方法我们刚才分析过，其作用是设置当前线程绑定的局部变量：&lt;br&gt;
A.首先获取当前线程，并根据当前线程获取一个&lt;code&gt;Map&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;B.如果获取的&lt;code&gt;Map&lt;/code&gt;不为空，则将参数设置到&lt;code&gt;Map&lt;/code&gt;中（当前&lt;code&gt;ThreadLocal&lt;/code&gt;的引用作为&lt;code&gt;key&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;（这里调用了&lt;code&gt;ThreadLocalMap&lt;/code&gt;的&lt;code&gt;set&lt;/code&gt;方法）&lt;/p&gt;
&lt;p&gt;C.如果&lt;code&gt;Map&lt;/code&gt;为空，则给该线程创建&lt;code&gt;Map&lt;/code&gt;，并设置初始值&lt;/p&gt;
&lt;p&gt;（这里调用了&lt;code&gt;ThreadLocalMap&lt;/code&gt;的构造方法）&lt;/p&gt;
&lt;h3 id=&#34;2构造方法threadlocalmapthreadlocal-firstkey-object-firstvalue&#34;&gt;（2）构造方法ThreadLocalMap(ThreadLocal&amp;lt;?&amp;gt; firstKey, Object firstValue)&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @param firstKey 本地 ThreadLocal 实例(this)
 * @param firstValue 要保存的线程本地变量
 */
ThreadLocalMap(ThreadLocal&amp;lt;?&amp;gt; firstKey, Object firstValue) {
    // 初始化 table
    table = new ThreadLocal.ThreadLocalMap.Entry[INITIAL_CAPACITY];
    // 计算索引（重点代码）
    int i = firstKey.threadLocalHashCode &amp;amp; (INITIAL_CAPACITY - 1);
    // 设置值
    table[i] = new ThreadLocal.ThreadLocalMap.Entry(firstKey, firstValue);
    size = 1;
    // 设置阈值
    setThreshold(INITIAL_CAPACITY);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;构造函数首先创建一个长度为16的&lt;code&gt;Entry&lt;/code&gt;数组，然后计算出&lt;code&gt;firstKey&lt;/code&gt;对应的索引，然后存储到&lt;code&gt;table&lt;/code&gt;中，并设置&lt;code&gt;size&lt;/code&gt;和&lt;code&gt;threshold&lt;/code&gt;。&lt;br&gt;
重点分析：&lt;code&gt;int i = firstKey.threadLocalHashCode &amp;amp; (INITIAL_CAPACITY - 1);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;a.关于&lt;code&gt;firstkey.threadLocalHashcode&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private final int threadLocalHashCode = nextHashCode();
private static int nextHashCode() {
    return nextHashCode.getAndAdd(HASH_INCREMENT);
}
// AtomicInteger 是一个提供原子操作的 Integer类，通过线程安全的方式操作加减，适合高并发情况下的使用
private static AtomicInteger nextHashCode =
    new AtomicInteger();
// 特殊的 hash 值
private static final int HASH_INCREMENT = 0x61c88647;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里定义了一个&lt;code&gt;Atomiclnteger&lt;/code&gt;类型，每次获取当前值并加上&lt;code&gt;HASH_INCREMENT&lt;/code&gt;，&lt;code&gt;HASH_INCREMENT=0x61c88647&lt;/code&gt;，这个值跟斐波那契数列（黄金分割数）有关，其主要目的就是为了让哈希码能均匀的分布在2的n次方的数组里，也就是&lt;code&gt;Entry[]]table&lt;/code&gt;中，这样做可以尽量避免&lt;code&gt;hash&lt;/code&gt;冲突。&lt;/p&gt;
&lt;p&gt;b.关于&lt;code&gt;&amp;amp;（INITIAL_CAPACITY-1）&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;计算&lt;code&gt;hash&lt;/code&gt;的时候里面采用了&lt;code&gt;hashCode&amp;amp;(size-1)&lt;/code&gt;的算法，这相当于取模运算&lt;code&gt;hashCode%size&lt;/code&gt;的一个更高效的实现。正是因为这种算法，我们要求&lt;code&gt;size&lt;/code&gt;必须是2的整次幂，这也能保证保证在索引不越界的前提下，使得&lt;code&gt;hash&lt;/code&gt;发生冲突的次数减小。&lt;/p&gt;
&lt;h3 id=&#34;3threadlocalmap中的set方法&#34;&gt;（3）ThreadLocalMap中的set方法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;private void set(ThreadLocal&amp;lt;?&amp;gt; key, Object value) {

    // We don&#39;t use a fast path as with get() because it is at
    // least as common to use set() to create new entries as
    // it is to replace existing ones, in which case, a fast
    // path would fail more often than not.

    ThreadLocal.ThreadLocalMap.Entry[] tab = table;
    int len = tab.length;
    // 计算索引（重点代码）
    int i = key.threadLocalHashCode &amp;amp; (len-1);

    /**
     * 使用线性探测法查找元素（重点代码）
     */
    for (ThreadLocal.ThreadLocalMap.Entry e = tab[i];
         e != null;
         e = tab[i = nextIndex(i, len)]) {
        ThreadLocal&amp;lt;?&amp;gt; k = e.get();
        // ThreadLocal 对应的 key 存在，直接覆盖之前的值
        if (k == key) {
            e.value = value;
            return;
        }

        // key 为 null，但是值不为 null，说明之前的 ThreadLocal 对象已经被回收了
        // 当前数组中的 Entry 是一个陈旧（stale）的元素
        if (k == null) {
            // 用新元素替换旧元素，这个方法进行了不少的垃圾清理动作，防止内存泄漏
            replaceStaleEntry(key, value, i);
            return;
        }
    }
    //ThreadLocal对应的key不存在并且没有找到陈旧的元素，则在空元素的位置创建一个新的Entry。
    tab[i] = new ThreadLocal.ThreadLocalMap.Entry(key, value);
    int sz = ++size;
    /**
     * cleanSomeslots用于清除那些e.get()==nu11的元素，
     * 这种数据key关联的对象已经被回收，所以这个Entry（table[index]）可以被置nu11。
     * 如果没有清除任何entry，并且当前使用量达到了负载因子所定义（长度的2/3），那么进行
     * rehash（执行一次全表的扫描清理工作）
     */
    if (!cleanSomeSlots(i, sz) &amp;amp;&amp;amp; sz &amp;gt;= threshold)
        rehash();
}
// 获取环形数组的下一个索引
private static int nextIndex(int i, int len) {
    return ((i + 1 &amp;lt; len) ? i + 1 : 0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码执行流程：&lt;br&gt;
A.首先还是根据&lt;code&gt;key&lt;/code&gt;计算出索引 i，然后查找位置上的&lt;code&gt;Entry&lt;/code&gt;，&lt;br&gt;
B.若是&lt;code&gt;Entry&lt;/code&gt;已经存在并且&lt;code&gt;key&lt;/code&gt;等于传入的&lt;code&gt;key&lt;/code&gt;，那么这时候直接给这个&lt;code&gt;Entry&lt;/code&gt;赋新的&lt;code&gt;value&lt;/code&gt;值&lt;br&gt;
C.若是&lt;code&gt;Entry&lt;/code&gt;存在，但是&lt;code&gt;key&lt;/code&gt;为&lt;code&gt;null&lt;/code&gt;，则调用&lt;code&gt;replaceStaleEntry&lt;/code&gt;来更换这个&lt;code&gt;key&lt;/code&gt;为空的&lt;code&gt;Entry&lt;/code&gt;，&lt;br&gt;
D.不断循环检测，直到遇到为&lt;code&gt;null&lt;/code&gt;的地方，这时候要是还没在循环过程中&lt;code&gt;return&lt;/code&gt;，那么就在这个&lt;code&gt;null&lt;/code&gt;的位置新建一个&lt;code&gt;Entry&lt;/code&gt;，并且插入，同时&lt;code&gt;size&lt;/code&gt;增加1。&lt;/p&gt;
&lt;p&gt;最后调用&lt;code&gt;cleanSomeSlots&lt;/code&gt;，清理&lt;code&gt;key&lt;/code&gt;为&lt;code&gt;null&lt;/code&gt;的&lt;code&gt;Entry&lt;/code&gt;，最后返回是否清理了&lt;code&gt;Entry&lt;/code&gt;，接下来再判断&lt;code&gt;size&lt;/code&gt;是否&lt;code&gt;&amp;gt;=thresgold&lt;/code&gt;达到了&lt;code&gt;rehash&lt;/code&gt;的条件，达到的话就会调用&lt;code&gt;rehash&lt;/code&gt;函数执行一次全表的扫描清理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重点分析&lt;/strong&gt;：&lt;code&gt;ThreadLocalMap&lt;/code&gt;使用&lt;strong&gt;线性探测法&lt;/strong&gt;来解决哈希冲突的。&lt;/p&gt;
&lt;p&gt;该方法一次探测下一个地址，直到有空的地址后插入，若整个空间都找不到空余的地址，则产生溢出。&lt;/p&gt;
&lt;p&gt;举个例子，假设当前&lt;code&gt;table&lt;/code&gt;长度为16，也就是说如果计算出来&lt;code&gt;key&lt;/code&gt;的&lt;code&gt;hash&lt;/code&gt;值为14，如果&lt;code&gt;table&lt;/code&gt;[14]上已经有值，并且其&lt;code&gt;key&lt;/code&gt;与当前&lt;code&gt;key&lt;/code&gt;不一致，那么就发生了&lt;code&gt;hash&lt;/code&gt;冲突，这个时候将14+1得到15，取table[15]进行判断，这个时候如果还是冲突会回到0，取table[0]，以此类推，直到可以插入。&lt;/p&gt;
&lt;p&gt;按照上面的描述，可以把&lt;code&gt;Entry[]table&lt;/code&gt;看成一个环形数组。&lt;/p&gt;
">面试题 —— 由浅入深全面解析 ThreadLocal</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/mian-shi-ti-xi-lie-java-bing-fa/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;Java 并发的东西比较多，今天先总结一部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;1什么是线程和进程&#34;&gt;1.什么是线程和进程？&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;进程是 OS 资源分配的基本单位。进程拥有独立的虚拟地址空间。&lt;/li&gt;
&lt;li&gt;线程是 CPU 调度的基本单位。线程共享进程的堆、方法区资源，但每个线程有自己的程序计数器、虚拟机栈、本地方法栈。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2并发和并行的区别&#34;&gt;2.并发和并行的区别？&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;并发：统一时间段内，多个任务都在执行。&lt;/li&gt;
&lt;li&gt;并行：同一时间内，多个任务同时执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;3为什么要使用多线程&#34;&gt;3.为什么要使用多线程？&lt;/h1&gt;
&lt;p&gt;先从总体上来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从计算机底层来说：线程可以比作是轻量级的进程，是程序执行的最小单位，&lt;strong&gt;线程间的切换和调度的成本远远小于进程&lt;/strong&gt;另外，多核CPU时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。&lt;/li&gt;
&lt;li&gt;从当代互联网发展趋势来说：现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再深入到计算机底层来探讨：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单核时代：在单核时代多线程主要是为了提高CPU和IO设备的综合利用率。举个例子：当只有一个线程的时候会导致CPU计算时，IO设备空闲；进行IO操作时，CPU空闲。我们可以简单地说这两者的利用率目前都是50%左右。但是当有两个线程的时候就不一样了，当一个线程执行CPU计算时，另外一个线程可以进行IO操作，这样两个的利用率就可以在理想情况下达到100%了。&lt;/li&gt;
&lt;li&gt;多核时代：多核时代多线程主要是为了&lt;strong&gt;提高CPU利用率&lt;/strong&gt;。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU只会一个CPU核心被利用到，而创建多个线程就可以让多个CPU核心被利用到，这样就提高了CPU的利用率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;4创建线程的方式&#34;&gt;4.创建线程的方式&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;实现 Runnable 接口&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// 1. 实现 Runnable 接口
class MyRunnable implements Runnbale{
  // 2. 实现 run 方法
  public void run(){
    // ...
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args){
  // 3. 使用自定义 runnable 对象创建线程
  MyRunnable runnable = new MyRunnable();
  Thread thread = new Thread(runnable);
  // 4. start() 启动线程
  thread.start();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;实现 Callable 接口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与 Runnable 相比，Callable 可以有返回值，返回值由 FutureTask 进行封装。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 1. 实现 Callable 接口，并声明泛型
class MyCallable implements Callable&amp;lt;Integer&amp;gt;{
  // 2. 重写 call 方法
  public Integer call(){
    return 123;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) throws ExecutionException, InterruptedException{
  MyCallable callable = new MyCallable();
  // 3. 使用 FutureTask 封装 call 方法的返回值
  FutureTask&amp;lt;Integer&amp;gt; ft = new FutureTask&amp;lt;&amp;gt;(callable);
  Thread thread = new Thread(ft);
  thread.start();
  System.out.println(ft.get());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;继承 Thread 类&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;class MyThread extends Thread{
  public void run(){
    // ...
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args){
  MyThread thread = new MyThread();
  thread.start();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;继承-vs-实现接口&#34;&gt;继承 vs 实现接口&lt;/h2&gt;
&lt;p&gt;实现接口更好一些，因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java 不支持多重继承，因此继承了 Thread 类就无法集成其它类，但是可以实现多个接口。&lt;/li&gt;
&lt;li&gt;适合多个线程进行资源共享（Runnable 类可以作为多个 Thread 构造方法的参数）&lt;/li&gt;
&lt;li&gt;线程池内只能放入 Runnable 或 Callable 接口的实现类，不能放入继承 Thread 对象的类。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;5runnable-接口和-callable-接口的区别&#34;&gt;5.Runnable 接口和 Callable 接口的区别&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Runnable 接口重写的是 run 方法，Callable 接口重写的是 call 方法&lt;/li&gt;
&lt;li&gt;run 方法执行后不能有返回值，call 方法执行后可以有返回值。&lt;/li&gt;
&lt;li&gt;call()方法可以抛出异常，run()方法不可以&lt;/li&gt;
&lt;li&gt;运行Callable任务可以拿到一个Future对象，表示异步计算的结果 。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;6start-方法和-run-方法的区别&#34;&gt;6.start() 方法和 run() 方法的区别&lt;/h1&gt;
&lt;p&gt;new 一个 Thread，线程进入了新建状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;start() 方法可以启动一个线程，将线程由新建状态切换到就绪态。&lt;/li&gt;
&lt;li&gt;run() 方法不会启动一个线程，只会把它当做一个普通方法去执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;7sleep-方法和-wait-方法有什么区别&#34;&gt;7.sleep 方法和 wait 方法有什么区别？&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;wait() 是 Object 类的方法，而 sleep() 是 Thread 的静态方法。&lt;/li&gt;
&lt;li&gt;sleep 和 wait 方法都可以用来放弃 CPU 一定时间，&lt;strong&gt;暂停线程的执行&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;是否释放锁&lt;/strong&gt;：两者最主要的区别在于：sleep 方法不会释放锁，而 wait 方法会释放锁。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用途&lt;/strong&gt;：wait 通常用于线程间交互 / 通信，sleep 通常被用于暂停执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;是否会自动苏醒&lt;/strong&gt;：wait 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout) 超时后线程会自动苏醒。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;8reentrantlock-和-synchronized-的比较&#34;&gt;8.ReentrantLock 和 synchronized 的比较&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;锁的实现&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;性能&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 和 ReentrantLock 大致相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;等待可中断&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当持有锁的线程长期不释放锁时，正在等待的线程可以选择放弃等待，改为处理其他事情。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ReentrantLock 可中断，而 synchronized 不行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;公平锁&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;synchronized 是不公平锁，而 ReentrantLock 默认情况下也是非公平的，但是可以在构造函数中设置公平还是不公平锁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;锁绑定多个条件&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;一个 ReentrantLock 可以同时绑定多个 Condition 对象&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;使用选择&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一 种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;9cyclicbarrier和countdownlatch的区别&#34;&gt;9.CyclicBarrier和CountDownLatch的区别&lt;/h1&gt;
&lt;h2 id=&#34;countdownlatch&#34;&gt;CountDownLatch&lt;/h2&gt;
&lt;p&gt;用来控制一个线程等待多个线程。&lt;/p&gt;
&lt;p&gt;维护了一个计数器 cnt，&lt;strong&gt;每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;cyclicbarrier&#34;&gt;CyclicBarrier&lt;/h2&gt;
&lt;p&gt;用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。&lt;/p&gt;
&lt;p&gt;和 CountdownLatch 相似，都是通过维护计数器来实现的。&lt;strong&gt;线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做&lt;strong&gt;循环屏障&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。&lt;/p&gt;
&lt;h1 id=&#34;10semaphore有什么作用&#34;&gt;10.Semaphore有什么作用&lt;/h1&gt;
&lt;p&gt;Semaphore就是一个信号量，它的作用是&lt;strong&gt;限制某段代码块的并发数&lt;/strong&gt;。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。&lt;/p&gt;
&lt;h1 id=&#34;11volatile关键字的作用&#34;&gt;11.volatile关键字的作用&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;保证了可见性，不能保证原子性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;立刻将缓存中的值写到内存；线程通过嗅探总线上传播过来的数据监测自己的缓存是否过期了，如果过期了，就把缓存内的值设置为失效，如果要修改时，就去主存读取新值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;禁止指令重排&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;12使用-blockingqueue-生产者消费者问题&#34;&gt;12.使用 BlockingQueue 生产者消费者问题&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;public class ProductConsumer{
  private static BlockingQueue&amp;lt;String&amp;gt; queue = new BlockingQueue&amp;lt;&amp;gt;();
  private static class Producer extends Thread{
    @Override
    public void run(){
      try{
        queue.put(&amp;quot;product&amp;quot;);
      }catch(InterruptedException e){
        e.printStackTrace();
      }
      System.out.print(&amp;quot;produce...&amp;quot;);
    }
  }
  private static class Consumer extends Thread{
    @Override
    public void run(){
      try{
        String product = queue.take();
      }catch(InterruptedException e){
        e.printStackTrace();
      }
      System.out.print(&amp;quot;consume...&amp;quot;)
    }
  }
  public static void main(String[] args) {
    for (int i = 0; i &amp;lt; 2; i++) {
        Producer producer = new Producer();
        producer.start();
    }
    for (int i = 0; i &amp;lt; 5; i++) {
        Consumer consumer = new Consumer();
        consumer.start();
    }
    for (int i = 0; i &amp;lt; 3; i++) {
        Producer producer = new Producer();
        producer.start();
    } 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;produce..produce..consume..consume..produce..consume..produce..consume..produce..consume.. 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;13一个线程如果出现了运行时异常会怎么样&#34;&gt;13.一个线程如果出现了运行时异常会怎么样&lt;/h1&gt;
&lt;p&gt;如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：&lt;strong&gt;如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;14threadlocal有什么用&#34;&gt;14.ThreadLocal有什么用&lt;/h1&gt;
&lt;p&gt;线程局部变量，&lt;strong&gt;以空间换时间&lt;/strong&gt;，每个线程内都有一个，把数据进行隔离，解决多线程之间共享数据的安全问题。&lt;/p&gt;
&lt;h1 id=&#34;15wait方法和notifynotifyall方法在放弃对象监视器时有什么区别&#34;&gt;15.wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别&lt;/h1&gt;
&lt;p&gt;wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：&lt;strong&gt;wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&#34;16为什么要使用线程池&#34;&gt;16.为什么要使用线程池&lt;/h1&gt;
&lt;p&gt;来一个请求创建一个线程，执行结束再销毁线程，资源耗费太大，使用线程池达到对&lt;strong&gt;线程的复用&lt;/strong&gt;。使用线程池还可以灵活地控制并发的数目。&lt;/p&gt;
&lt;h1 id=&#34;17怎么检测一个线程是否持有对象监视器&#34;&gt;17.怎么检测一个线程是否持有对象监视器&lt;/h1&gt;
&lt;p&gt;我也是在网上看到一道多线程面试题才知道有方法可以判断某个线程是否持有对象监视器：Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着&amp;quot;某条线程&amp;quot;指的是当前线程。&lt;/p&gt;
&lt;h1 id=&#34;18concurrenthashmap的并发度是什么&#34;&gt;18.ConcurrentHashMap的并发度是什么&lt;/h1&gt;
&lt;p&gt;ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？&lt;/p&gt;
&lt;h1 id=&#34;19futuretask是什么&#34;&gt;19.FutureTask是什么&lt;/h1&gt;
&lt;p&gt;在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class FutureTask&amp;lt;V&amp;gt; implements RunnableFuture&amp;lt;V&amp;gt; 
public interface RunnableFuture&amp;lt;V&amp;gt; extends Runnable, Future&amp;lt;V&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;FutureTask 可用&lt;strong&gt;于异步获取执行结果&lt;/strong&gt;或&lt;strong&gt;取消执行任务的场景&lt;/strong&gt;。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。&lt;/p&gt;
&lt;h1 id=&#34;20aqs&#34;&gt;20.AQS&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;概念&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;AbstractQueuedSynchronizer&lt;/li&gt;
&lt;li&gt;同步发生器&lt;/li&gt;
&lt;li&gt;构建 LOCK&lt;/li&gt;
&lt;li&gt;JUC：java.util.current&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;基本思想&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。&lt;/li&gt;
&lt;li&gt;CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CLH同步队列&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/CLH%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private volatile int state;//共享变量，使用volatile修饰保证线程可见性
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;状态信息通过 protected 类型的getState，setState，compareAndSetState进行操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//返回同步状态的当前值
protected final int getState() {
        return state;
}
 // 设置同步状态的值
protected final void setState(int newState) {
        state = newState;
}
//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）
protected final boolean compareAndSetState(int expect, int update) {
        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;参考链接&#34;&gt;参考链接&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/JavaConcurrencyBasicsCommonInterviewQuestionsSummary.md&#34;&gt;https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/JavaConcurrencyBasicsCommonInterviewQuestionsSummary.md&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://mp.weixin.qq.com/s/SCugxnAV1_f3sq-UhFD7wg&#34;&gt;https://mp.weixin.qq.com/s/SCugxnAV1_f3sq-UhFD7wg&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/AQS.md&#34;&gt;https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/AQS.md&lt;/a&gt;&lt;/p&gt;
">面试题系列 —— Java 并发</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/ji-yi-ge-mian-shi-ti-redis-yi-qi-dong-gua-liao-zen-me-ban/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;面试官：Redis 一启动就挂了怎么办？&lt;br&gt;
答：添加 Redis 集群&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;集群简介&#34;&gt;集群简介&lt;/h1&gt;
&lt;h2 id=&#34;现状问题&#34;&gt;现状问题&lt;/h2&gt;
&lt;h3 id=&#34;业务发展过程中遇到的峰值瓶颈&#34;&gt;业务发展过程中遇到的峰值瓶颈&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;redis提供的服务OPS可以达到10万/秒，当前业务OPS已经达到20万/秒&lt;/li&gt;
&lt;li&gt;内存单机容量达到256G，当前业务需求内存容量1T&lt;/li&gt;
&lt;li&gt;使用集群的方式可以快速解决上述问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;集群架构&#34;&gt;集群架构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;集群就是使用网络将若干台计算机联通起来，并提供统一的管理方式，使其对外呈现单机的服务效果&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Redis%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;集群作用&#34;&gt;集群作用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;分散单台服务器的访问压力，实现负载均衡&lt;/li&gt;
&lt;li&gt;分散单台服务器的存储压力，实现可扩展性&lt;/li&gt;
&lt;li&gt;降低单台服务器宕机带来的业务灾难&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Redis%E9%9B%86%E7%BE%A4%E4%BD%9C%E7%94%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;redis集群结构设计&#34;&gt;Redis集群结构设计&lt;/h1&gt;
&lt;h2 id=&#34;数据存储设计&#34;&gt;&lt;strong&gt;数据存储设计&lt;/strong&gt;&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E8%AE%BE%E8%AE%A1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;一个 key 放在 Redis 存储空间：单机方案。&lt;br&gt;
一个 key 对应多个存储空间，变成多台计算机了，应该怎样存储呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Redis%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A82.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;通过算法设计，计算出key应该保存的位置&lt;/li&gt;
&lt;li&gt;将所有的存储空间计划切割成16384份，每台主机保存一部分
&lt;ul&gt;
&lt;li&gt;每份代表的是一个存储空间，不是一个key的保存空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将key按照计算出的结果放到对应的存储空间&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Redis%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A83.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;假定现在有三个存储空间，突然又增加了一个存储空间。把原来的三个 Redis 存储空间都进行优化，每个存储空间拿出一部分给新的存储空间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;增强可扩展性&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Redis%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A85.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;旧的存储空间给新的存储空间 的 这一小块空间（也就是前面标记的37）叫做槽，用来放数据的空间区域。所谓的增加、删除 Redis 存储空间就是：改变槽所存储的位置不同。&lt;br&gt;
槽更换位置后，如何知道它被换到哪里了呢？&lt;br&gt;
内部通讯设计&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;集群内部通讯设计&#34;&gt;&lt;strong&gt;集群内部通讯设计&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;各个数据库相互通信，保存各个库中槽的编号数据&lt;/li&gt;
&lt;li&gt;一次命中，直接返回&lt;/li&gt;
&lt;li&gt;一次未命中，告知具体位置&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Redis%E9%9B%86%E7%BE%A4%E5%86%85%E9%83%A8%E9%80%9A%E8%AE%AF%E8%AE%BE%E8%AE%A1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;假定现在有 A、B、C 三个机器互联，三个机器存储好了以后，会进行互联，互联的目的：谁那有什么样的东西一清二楚。每一台计算机都有一个账本，存储各个计算机里对应的存储空间的槽是几到几。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Redis%E9%9B%86%E7%BE%A4%E5%86%85%E9%83%A8%E9%80%9A%E8%AE%AF%E8%AE%BE%E8%AE%A12.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;假定现在来了一台计算机，发出一个 key 要访问 Redis，key 通过两个算法计算后得到 key 对应的存储槽在哪里，假定它访问的就是 A，一次命中，直接返回。假设它没有命中，会根据这个 key 对应的槽位置在 A 的小本子里面找，发现这个东西在 B 里面，于是就让这个 key 去 B 里面找，不是 A 去 B 里面找，而是这个连接请求客户端直接去 B 里面找。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;key 加密就是为了确定存储位置，保证最多两次命中&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;集群内存存储结构设计：&lt;/p&gt;
&lt;p&gt;1.槽用来区分数据存储空间&lt;/p&gt;
&lt;p&gt;2.key 加密后确定存储的位置&lt;/p&gt;
&lt;p&gt;3.一次命中或两次命中就可以找到数据&lt;/p&gt;
&lt;h1 id=&#34;cluster集群结构搭建&#34;&gt;cluster集群结构搭建&lt;/h1&gt;
&lt;h2 id=&#34;搭建方式&#34;&gt;搭建方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;原生安装（单条命令）
&lt;ul&gt;
&lt;li&gt;配置服务器（3主3从）&lt;/li&gt;
&lt;li&gt;建立通信（Meet）&lt;/li&gt;
&lt;li&gt;分槽（Slot）&lt;/li&gt;
&lt;li&gt;搭建主从（master-slave）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;工具安装（批处理）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cluster节点操作命令&#34;&gt;Cluster节点操作命令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;查看集群节点信息&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;cluster nodes 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;进入一个从节点 redis，切换其主节点&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;cluster replicate &amp;lt;master-id&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;发现一个新节点，新增主节点&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;cluster meet ip:port 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;忽略一个没有solt的节点&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;cluster forget &amp;lt;id&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;手动故障转移&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;cluster failover
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;redis-trib命令&#34;&gt;redis-trib命令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;添加节点&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;redis-trib.rb add-node 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;删除节点&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;redis-trib.rb del-node 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;重新分片&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;redis-trib.rb reshard
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cluster配置&#34;&gt;Cluster配置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;添加节点&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;cluster-enabled yes|no 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;cluster配置文件名，该文件属于自动生成，仅用于快速查找文件并查询文件内容&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;cluster-config-file &amp;lt;filename&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;节点服务响应超时时间，用于判定该节点是否下线或切换为从节点&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;cluster-node-timeout &amp;lt;milliseconds&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;master连接的slave最小数量&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt; cluster-migration-barrier &amp;lt;count&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;修改 redis.conf 配置文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;[root@iZ2ze4u2bufi0915gyi843Z conf]# vim redis-6379.conf 
port 6379
daemonize no
#logfile &amp;quot;6379.log&amp;quot;
dir &amp;quot;/root/redis-5.0.7/data&amp;quot;
dbfilename &amp;quot;dump-6379.rdb&amp;quot;
rdbcompression yes
rdbchecksum yes
appendonly yes
appendfsync everysec
appendfilename &amp;quot;appendonly-6379.aof&amp;quot;
bind 127.0.0.1
databases 16

cluster-enabled yes
cluster-config-file nodes-6379.conf
cluster-node-timeout 10000
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[root@iZ2ze4u2bufi0915gyi843Z conf]# sed &amp;quot;s/6379/6380/g&amp;quot; redis-6379.conf &amp;gt; redis-6380.conf 
[root@iZ2ze4u2bufi0915gyi843Z conf]# sed &amp;quot;s/6379/6381/g&amp;quot; redis-6379.conf &amp;gt; redis-6381.conf 
[root@iZ2ze4u2bufi0915gyi843Z conf]# sed &amp;quot;s/6379/6382/g&amp;quot; redis-6379.conf &amp;gt; redis-6382.conf 
[root@iZ2ze4u2bufi0915gyi843Z conf]# sed &amp;quot;s/6379/6383/g&amp;quot; redis-6379.conf &amp;gt; redis-6383.conf 
[root@iZ2ze4u2bufi0915gyi843Z conf]# sed &amp;quot;s/6379/6384/g&amp;quot; redis-6379.conf &amp;gt; redis-6384.conf 
[root@iZ2ze4u2bufi0915gyi843Z conf]# sed &amp;quot;s/6379/6385/g&amp;quot; redis-6379.conf &amp;gt; redis-6385.conf 
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;启动 redis 客户端&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;[root@iZ2ze4u2bufi0915gyi843Z conf]# redis-server redis-6379.conf 
[root@iZ2ze4u2bufi0915gyi843Z conf]# redis-server redis-6380.conf 
[root@iZ2ze4u2bufi0915gyi843Z conf]# redis-server redis-6381.conf 
[root@iZ2ze4u2bufi0915gyi843Z conf]# redis-server redis-6382.conf 
[root@iZ2ze4u2bufi0915gyi843Z conf]# redis-server redis-6383.conf 
[root@iZ2ze4u2bufi0915gyi843Z conf]# redis-server redis-6384.conf 
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;每个 reids 服务都以 cluster 节点呈现&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;[root@iZ2ze4u2bufi0915gyi843Z conf]# ps -ef | grep redis-
root      9015  8373  0 18:44 pts/1    00:00:00 redis-server 127.0.0.1:6379 [cluster]
root      9019  8430  0 18:44 pts/5    00:00:00 redis-server 127.0.0.1:6380 [cluster]
root      9023  8411  0 18:45 pts/4    00:00:00 redis-server 127.0.0.1:6381 [cluster]
root      9028  8469  0 18:45 pts/6    00:00:00 redis-server 127.0.0.1:6382 [cluster]
root      9033  8488  0 18:45 pts/7    00:00:00 redis-server 127.0.0.1:6383 [cluster]
root      9037  8507  0 18:46 pts/8    00:00:00 redis-server 127.0.0.1:6384 [cluster]
root      9045  8545  0 18:46 pts/10   00:00:00 grep --color=auto redis-
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;把这些  cluster 节点 连接在一起&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;redis5.0之前的版本需要部署 ruby 和 gem：&lt;a href=&#34;https://blog.51cto.com/wujianwei/2460638&#34;&gt;部署ruby环境遇到的坑&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;redis5.0以上的版本可以使用redis-cli命令&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.im/post/5d16206b518825597909b5f9&#34;&gt;https://juejin.im/post/5d16206b518825597909b5f9&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@iZ2ze4u2bufi0915gyi843Z redis-5.0.7]# src/redis-cli --cluster create 127.0.0.1:6379 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 --cluster-replicas 1
// --cluster-replicas 1：一个 master 连接一个 slave；2：一个 master 连接两个 slave
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;输入 yes 重写配置文件后：&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;解析-master-和-slave-日志信息&#34;&gt;解析 master 和 slave 日志信息&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E9%9B%86%E7%BE%A4master%E6%97%A5%E5%BF%97.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;master：6379 日志&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E9%9B%86%E7%BE%A4slave%E6%97%A5%E5%BF%97.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;slave：6382 日志&lt;/p&gt;
&lt;h2 id=&#34;设置与获取数据&#34;&gt;设置与获取数据&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;[root@iZ2ze4u2bufi0915gyi843Z ~]# redis-cli
127.0.0.1:6379&amp;gt; set name itheima   // 把 name 对应的 key 进行转化后，对应的槽在 6380，不能在 6379 set
(error) MOVED 5798 127.0.0.1:6380 
127.0 .0.1:6379&amp;gt; set lll sss      //  lll 对应的 key 进行转化后，对应的槽在 6379，所以此处 set 成功
OK

[root@iZ2ze4u2bufi0915gyi843Z ~]# redis-cli -c   // -c 专门用来操作 cluster 集群的
127.0.0.1:6379&amp;gt; set name itheima
-&amp;gt; Redirected to slot [5798] located at 127.0.0.1:6380  // 重定向到 5798 这个槽，这个槽在 6380 下
OK
127.0.0.1:6380&amp;gt; get name
&amp;quot;itheima&amp;quot;
[root@iZ2ze4u2bufi0915gyi843Z ~]# redis-cli -c -p 6382
127.0.0.1:6382&amp;gt; get name
-&amp;gt; Redirected to slot [5798] located at 127.0.0.1:6380
&amp;quot;itheima&amp;quot;
127.0.0.1:6380&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;主从下线与主从切换&#34;&gt;主从下线与主从切换&lt;/h2&gt;
&lt;h3 id=&#34;slave6382-下线&#34;&gt;slave:6382 下线&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/slave%E4%B8%8B%E7%BA%BF%E4%B8%BB%E8%8A%82%E7%82%B9%E6%97%A5%E5%BF%97.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;master:6381（slave:6382 的 master） 日志打印&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/slave%E4%B8%8B%E7%BA%BFmaster%E6%97%A5%E5%BF%97.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;master:6379 日志打印&lt;/p&gt;
&lt;h3 id=&#34;slave6382-重新上线&#34;&gt;slave:6382 重新上线&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/slave%E9%87%8D%E6%96%B0%E4%B8%8A%E7%BA%BFmaster%E6%97%A5%E5%BF%97.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;master:6381（slave:6382 的 master） 日志打印&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E9%87%8D%E6%96%B0%E4%B8%8A%E7%BA%BF%E7%9A%84master%E5%8F%98%E6%88%90slave%E4%BA%86.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;master:6379 日志打印&lt;/p&gt;
&lt;h3 id=&#34;master6379-下线&#34;&gt;master:6379 下线&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/master%E4%B8%8B%E7%BA%BFslave%E6%97%A5%E5%BF%97.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;slave:6383（master:6379 的 slave）日志打印&lt;/p&gt;
&lt;p&gt;查看 cluster 信息：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/master%E4%B8%8B%E7%BA%BFcluster%E6%97%A5%E5%BF%97.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;slave:6383 自己当 master&lt;/p&gt;
&lt;h3 id=&#34;master6379-重新上线&#34;&gt;master:6379 重新上线&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/master%E9%87%8D%E6%96%B0%E4%B8%8A%E7%BA%BFmaster%E6%97%A5%E5%BF%97.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;**master:6383**（slave:6379 的 master） 日志信息&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E9%87%8D%E6%96%B0%E4%B8%8A%E7%BA%BF%E7%9A%84master%E5%8F%98%E6%88%90slave%E4%BA%86.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p style = &#34;text-align:center;font-family:楷体&#34;&gt;再次上线的 6379 变成 slave 了&lt;/p&gt;
&lt;h1 id=&#34;总结-2&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;集群&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集群简介&lt;/li&gt;
&lt;li&gt;集群结构&lt;/li&gt;
&lt;li&gt;cluster集群结构搭建&lt;/li&gt;
&lt;/ul&gt;
">记一个面试题 —— Redis 一启动挂了怎么办</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/mian-shi-chang-wen-zhi-huan-cun-chuan-tou-huan-cun-xue-beng/"" data-c="
          &lt;h1 id=&#34;缓存预热&#34;&gt;缓存预热&lt;/h1&gt;
&lt;h2 id=&#34;宕机&#34;&gt;“宕机”&lt;/h2&gt;
&lt;p&gt;服务器&lt;strong&gt;启动后迅速宕机&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;问题排查&#34;&gt;问题排查&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;请求数量较高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主从之间数据吞吐量较大（不停地加载数据），数据同步操作频度较高&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;数据库读的频度高：服务器一启动，缓存中没有数据，自然就会给服务器带来压力，这时候如果请求比较多的话，redis 服务器就会宕机。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;前置准备工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;日常例行统计数据访问记录，统计访问频度较高的热点数据&lt;/li&gt;
&lt;li&gt;利用LRU数据删除策略，构建数据留存队列
&lt;ul&gt;
&lt;li&gt;例如：storm与kafka配合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;准备工作：&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据&lt;/li&gt;
&lt;li&gt;利用分布式多服务器同时进行数据读取，提速数据加载过程&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;实施：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用脚本程序固定触发数据预热过程&lt;/li&gt;
&lt;li&gt;如果条件允许，使用了CDN（内容分发网络），效果会更好&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;缓存预热就是系统启动前，&lt;strong&gt;提前将相关的缓存数据直接加载到缓存系统&lt;/strong&gt;。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！&lt;/p&gt;
&lt;h1 id=&#34;缓存雪崩&#34;&gt;缓存雪崩&lt;/h1&gt;
&lt;h2 id=&#34;数据库服务器崩溃1&#34;&gt;数据库服务器崩溃（1）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;系统平稳运行过程中，忽然数据库连接量激增&lt;/li&gt;
&lt;li&gt;应用服务器无法及时处理请求&lt;/li&gt;
&lt;li&gt;大量408，500错误页面出现&lt;/li&gt;
&lt;li&gt;客户反复刷新页面获取数据&lt;/li&gt;
&lt;li&gt;数据库崩溃&lt;/li&gt;
&lt;li&gt;应用服务器崩溃&lt;/li&gt;
&lt;li&gt;重启应用服务器无效&lt;/li&gt;
&lt;li&gt;Redis服务器崩溃&lt;/li&gt;
&lt;li&gt;Redis集群崩溃&lt;/li&gt;
&lt;li&gt;重启数据库后再次被瞬间流量放倒&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;问题排查-2&#34;&gt;问题排查&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在一个&lt;span style=&#34;color:red&#34;&gt;较短&lt;/span&gt;的时间内，缓存中较多的&lt;span style=&#34;color:red&#34;&gt;key集中过期 &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据&lt;/li&gt;
&lt;li&gt;数据库同时接收到大量的请求无法及时处理&lt;/li&gt;
&lt;li&gt;Redis大量请求被积压，开始出现超时现象&lt;/li&gt;
&lt;li&gt;数据库流量激增，数据库崩溃&lt;/li&gt;
&lt;li&gt;重启后仍然面对缓存中无数据可用&lt;/li&gt;
&lt;li&gt;Redis服务器资源被严重占用，Redis服务器崩溃&lt;/li&gt;
&lt;li&gt;Redis集群呈现崩塌，集群瓦解&lt;/li&gt;
&lt;li&gt;应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃&lt;/li&gt;
&lt;li&gt;应用服务器，redis，数据库全部重启，效果不理想&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;问题分析&#34;&gt;问题分析&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;短时间范围内&lt;/li&gt;
&lt;li&gt;大量key集中过期&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;解决方案道&#34;&gt;解决方案（道）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;更多的页面静态化处理&lt;/li&gt;
&lt;li&gt;构建多级缓存架构&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Nginx缓存+redis缓存+ehcache缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;检测Mysql严重耗时业务进行优化&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;对数据库的瓶颈排查：例如超时查询、耗时较高事务等&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;灾难预警机制&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;监控redis服务器性能指标
&lt;ul&gt;
&lt;li&gt;CPU占用、CPU使用率&lt;/li&gt;
&lt;li&gt;内存容量&lt;/li&gt;
&lt;li&gt;查询平均响应时间&lt;/li&gt;
&lt;li&gt;线程数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;限流、降级&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;解决方案术&#34;&gt;解决方案（术）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;LRU与LFU切换&lt;/li&gt;
&lt;li&gt;数据有效期策略调整&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;根据业务数据有效期进行分类错峰，A类90分钟，B类80分钟，C类70分钟&lt;/li&gt;
&lt;li&gt;过期时间使用固定时间+随机值的形式，稀释集中到期的key的数量&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;超热数据使用永久key&lt;/li&gt;
&lt;li&gt;定期维护（自动+人工）&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;加锁&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;慎用！&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总结-2&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;缓存雪崩就是&lt;strong&gt;瞬间过期数据量太大&lt;/strong&gt;，导致对数据库服务器造成压力。如能够有&lt;strong&gt;效避免过期时间集中&lt;/strong&gt;，可以有效解决雪崩现象的出现 （约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9-1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;大量 key 集中过期，更多向 mysql 发起请求&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9-2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;缓存击穿&#34;&gt;缓存击穿&lt;/h1&gt;
&lt;h2 id=&#34;数据库服务器崩溃2&#34;&gt;数据库服务器崩溃（2）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;系统平稳运行过程中&lt;/li&gt;
&lt;li&gt;数据库连接量瞬间激增&lt;/li&gt;
&lt;li&gt;Redis服务器无大量key过期&lt;/li&gt;
&lt;li&gt;Redis内存平稳，无波动&lt;/li&gt;
&lt;li&gt;Redis服务器CPU正常&lt;/li&gt;
&lt;li&gt;数据库崩溃&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;问题排查-3&#34;&gt;问题排查&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Redis中&lt;strong&gt;某个key过期，该key访问量巨大&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;多个数据请求从服务器直接压到Redis后，均未命中&lt;/li&gt;
&lt;li&gt;Redis在短时间内发起了大量对数据库中同一数据的访问&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;问题分析-2&#34;&gt;问题分析&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;单个key高热数据&lt;/li&gt;
&lt;li&gt;key过期&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;解决方案术-2&#34;&gt;解决方案（术）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;预先设定&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时长&lt;/li&gt;
&lt;li&gt;注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;现场调整&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;后台刷新数据&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;二级缓存&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;设置不同的失效时间，保障不会被同时淘汰就行&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;加锁&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重！&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总结-3&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;缓存击穿就是&lt;strong&gt;单个高热数据过期的瞬间，数据访问量较大&lt;/strong&gt;，未命中redis后，发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度较高，配合雪崩处理策略即可。&lt;/p&gt;
&lt;h1 id=&#34;缓存穿透&#34;&gt;缓存穿透&lt;/h1&gt;
&lt;h2 id=&#34;数据库服务器崩溃3&#34;&gt;数据库服务器崩溃（3）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;系统平稳运行过程中&lt;/li&gt;
&lt;li&gt;应用服务器流量随时间增量较大&lt;/li&gt;
&lt;li&gt;Redis服务器命中率随时间逐步降低&lt;/li&gt;
&lt;li&gt;Redis内存平稳，内存无压力&lt;/li&gt;
&lt;li&gt;Redis服务器CPU占用激增&lt;/li&gt;
&lt;li&gt;数据库服务器压力激增&lt;/li&gt;
&lt;li&gt;数据库崩溃&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;问题排查-4&#34;&gt;问题排查&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Redis中大面积出现未命中&lt;/li&gt;
&lt;li&gt;出现非正常URL访问&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;问题分析-3&#34;&gt;问题分析&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;获取的数据在数据库中也不存在，数据库查询未得到对应数据&lt;/li&gt;
&lt;li&gt;Redis获取到null数据未进行持久化，直接返回&lt;/li&gt;
&lt;li&gt;下次此类数据到达重复上述过程&lt;/li&gt;
&lt;li&gt;出现黑客攻击服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解决方案（术）&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;缓存null&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;对查询结果为null的数据进行缓存（长期使用，定期清理），设定短时限，例如30-60秒，最高5分钟&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;白名单策略&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;提前预热各种分类数据id对应的bitmaps，id作为bitmaps的offset，相当于设置了数据白名单。当加载正常数据时，放行，加载异常数据时直接拦截（效率偏低）&lt;/li&gt;
&lt;li&gt;使用布隆过滤器（有关布隆过滤器的命中问题对当前状况可以忽略）&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;实施监控&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;实时监控redis命中率（业务正常范围时，通常会有一个波动值）与null数据的占比
&lt;ul&gt;
&lt;li&gt;非活动时段波动：通常检测3-5倍，超过5倍纳入重点排查对象&lt;/li&gt;
&lt;li&gt;活动时段波动：通常检测10-50倍，超过50倍纳入重点排查对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控（运营）&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;key加密&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验&lt;/li&gt;
&lt;li&gt;例如每天随机分配60个加密串，挑选2到3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总结-4&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;缓存击穿&lt;strong&gt;访问了不存在的数据&lt;/strong&gt;，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时报警。应对策略应该在临时预案防范方面多做文章。&lt;/p&gt;
&lt;p&gt;无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除。&lt;/p&gt;
&lt;h1 id=&#34;性能指标监控&#34;&gt;性能指标监控&lt;/h1&gt;
&lt;h2 id=&#34;监控指标&#34;&gt;监控指标&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;性能指标：Performance&lt;/li&gt;
&lt;li&gt;内存指标：Memory&lt;/li&gt;
&lt;li&gt;基本活动指标：Basic activity&lt;/li&gt;
&lt;li&gt;持久性指标：Persistence&lt;/li&gt;
&lt;li&gt;错误指标：Error&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;性能指标performance&#34;&gt;性能指标：Performance&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Name&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;latency&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Redis响应一个请求的时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;instantaneous_ops_per_sec&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;平均每秒处理总数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;hit rate(calculate)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;缓存命中率（计算出来的）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;内存指标memory&#34;&gt;内存指标：Memory&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Name&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;used_memory&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;已使用内存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;mem_fragmentation_ratio&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;内存碎片化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;evicted_keys&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;由于最大内存限制被移除的 key 的数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;blocked_clients&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;由于 BLPOP、BRPOP、or BRPOPLPUSH 而备受阻塞的客户端&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;基本活动指标basic-activity&#34;&gt;基本活动指标：Basic activity&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Name&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;connected_clients&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;客户端连接数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;connected_slaves&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Slave 数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;master_last_io_seconds_ago&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;最近一次主从交互之后的秒数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;keyspace&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;数据库中的 key 值总数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;持久性指标persistence&#34;&gt;持久性指标：Persistence&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Name&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;rdb_last_save_time&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;最后一次持久化保存到磁盘的时间戳&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;rdb_changes_since_last_save&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;自最后一次持久化依赖数据库的更改数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;错误指标error&#34;&gt;错误指标：Error&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Name&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;rejected_connections&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;由于达到 maxclient 限制而被拒绝的连接数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;keyspace_misses&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;key 值查找失败（没有命中）次数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;master_link_down_since_seconds&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;主从断开的持续时间（以秒为单位）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;监控方式&#34;&gt;监控方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;工具
&lt;ul&gt;
&lt;li&gt;Cloud Insight Redis&lt;/li&gt;
&lt;li&gt;Prometheus&lt;/li&gt;
&lt;li&gt;Redis-stat&lt;/li&gt;
&lt;li&gt;Redis-faina&lt;/li&gt;
&lt;li&gt;RedisLive&lt;/li&gt;
&lt;li&gt;zabbix&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;命令
&lt;ul&gt;
&lt;li&gt;benchmark&lt;/li&gt;
&lt;li&gt;redis cli
&lt;ul&gt;
&lt;li&gt;monitor&lt;/li&gt;
&lt;li&gt;showlog&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;benchmark&#34;&gt;benchmark&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;命令&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;redis-benchmark [-h ] [-p ] [-c ] [-n &amp;lt;requests]&amp;gt; [-k ] 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;范例1&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;[root@iZ2ze4u2bufi0915gyi843Z ~]# redis-benchmark 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明：50个连接，10000次请求对应的性能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;范例2&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;redis-benchmark -c 100 -n 5000 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明：100个连接，5000次请求对应的性能&lt;/p&gt;
&lt;h2 id=&#34;benchmark-2&#34;&gt;&lt;strong&gt;benchmark&lt;/strong&gt;&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/benchmark.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;monitor&#34;&gt;monitor&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;命令&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;monitor 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打印服务器调试信息&lt;/p&gt;
&lt;h2 id=&#34;slowlog&#34;&gt;slowlog&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;命令&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;slowlog [operator] 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;get ：获取慢查询日志&lt;/li&gt;
&lt;li&gt;len ：获取慢查询日志条目数&lt;/li&gt;
&lt;li&gt;reset ：重置慢查询日志&lt;/li&gt;
&lt;li&gt;相关配置&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;slowlog-log-slower-than 1000 #设置慢查询的时间下线，单位：微妙 
slowlog-max-len 100 #设置慢查询命令对应的日志显示长度，单位：命令数
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;总结-5&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;企业级解决方案&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存预热&lt;/li&gt;
&lt;li&gt;缓存雪崩&lt;/li&gt;
&lt;li&gt;缓存击穿&lt;/li&gt;
&lt;li&gt;缓存穿透&lt;/li&gt;
&lt;li&gt;性能指标监控
&lt;ul&gt;
&lt;li&gt;工具&lt;/li&gt;
&lt;li&gt;命令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
">面试常问之缓存预热、缓存雪崩、缓存击穿、缓存穿透</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/xian-cheng/"" data-c="
          &lt;h1 id=&#34;p-stylecolorred1-线程抽象p&#34;&gt;&lt;p style=&#34;color:red&#34;&gt;1. 线程抽象&lt;/p&gt;&lt;/h1&gt;
&lt;p&gt;一个线程是一个单一的执行序列，它表示了一个单独被调度的任务.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单一的执行序列&lt;/strong&gt;. 每个线程执行一个指令序列——赋值，条件，循环，过程, 等等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单独被调度的任务&lt;/strong&gt;. 操作系统可以在任意时刻，运行，暂停或者继续一个线程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行，挂起和继续执行的线程&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线程提供了一个有无限个处理机的幻象。OS 如何实现这样的幻象呢？它必须执行每个进程的指令使得每个线程都有进展，但实际的硬件只有有限个数的处理机，甚至只有 1 个&lt;/p&gt;
&lt;p&gt;为了将任意数量的线程映射到有限个处理机上，OS 包含一个调度器(scheduler)能够在运行和就绪的线程之间来回切换。但是线程的切换对线程来说是透明的，只是某些时刻处理机的执行变得比较慢而已。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%90%8C%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.jpg&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;图 4.3&lt;/strong&gt;: 一个线程 3 种可能的执行方式 ，对于程序员来说是无差的.&lt;/p&gt;
&lt;p&gt;上图说明了一个程序员角度的一个简单程序有三种不同的执行方式，这取决于调度器。从线程的角度，除了执行的速度不一样，这些是没差的。确实，线程并不知道有其他线程在执行。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E7%BA%BF%E7%A8%8B%E4%BA%A4%E9%94%99%E6%89%A7%E8%A1%8C.jpg&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;图 4.4&lt;/strong&gt;: 3 个线程在运行时许多种可能的交错执行的方式.&lt;/p&gt;
&lt;p&gt;上图展示了 3 个线程的交替执行。他们的这种速度是不可控的，每次执行可能都不一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例子&lt;/strong&gt;:内核中断处理程序是一个线程?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回答： 不，一个中断处理程序不是一个线程&lt;/strong&gt;. 一个内核中断处理程序和线程有一些相似性: 它是一个指令的序列， 从开头执行到结尾。然而，一个中断处理程序&lt;strong&gt;不是独立可调度的&lt;/strong&gt;: 它被一个硬件I/O 事件所触发执行,  而不是内核中线程调度器来决定什么时候执行. 一旦开始，中断处理程序运行到结束，除非被另外一个优先级更高的中断抢占.&lt;/p&gt;
&lt;h1 id=&#34;p-stylecolorred2-简化的线程-apip&#34;&gt;&lt;p style=&#34;color:red&#34;&gt;2. 简化的线程 API&lt;/p&gt;&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;void thread_create  (thread, func,arg)&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;创建一个新线程, 把信息存入 thread. 和调用的线程并发执行，线程执行函数 func，其参数为 arg.&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;void thread_yield()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;调用的线程自愿放弃处理机让其他线程来运行。调度器也可以继续运行调用的线程.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;int thread_join  (thread)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;等待 thread 结束如果 thread 还没有结束的话; 然后返回由 thread 通过 thread_exit 传递来的参数. 注意， 对每个线程，thread_join 只能被调用一次.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;void thread_exit(ret)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;完成当前的线程. 将 ret 的值存在当前线程的数据结构中。如果另一个线程已经用 thread_join 等待该线程, 则继续执行那个等待的线程.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;图 4.5&lt;/strong&gt;:使用线程简化的 API&lt;/p&gt;
&lt;p&gt;图 4.5 展示了使用线程的简单的API. 这个简化的API 是基于POSIX 标准的pthreads API, 但是它忽略了某些POSIX 选项和错误处理(为了简化). 绝大多数其他线程包也类似，如果你理解如何用这个 API 编程的话，你会发现对于绝大多数标准的线程 API 来说，其代码很容易编写.&lt;/p&gt;
&lt;p&gt;我们看见 UNIX 进程抽象中有类似的概念. thread_create 类似于UNIX 进程 fork 和 exec, 而 thread_join 类似于 UNIX 进程wait. UNIX fork 创建了一个新的进程和原来调用 fork 的进程并发的执行;UNIX exec 导致进程运行一个指定的程序。UNIX wait 运行调用的进程暂停执行直到新的进程完成为止。&lt;/p&gt;
&lt;h2 id=&#34;1-多线程的hello-world&#34;&gt;1. 多线程的Hello World!&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%A4%9A%E7%BA%BF%E7%A8%8Bhelloworld%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;图 4.6&lt;/strong&gt;: 用简单线程API 来打印”Hello”十次的多线程编程的例子。也展示了一种可能的输出。&lt;/p&gt;
&lt;p&gt;上图是一个多线程的程序，用了简单的线程 API 来打印 hello 十次。也展示了一个可能的输出结果。Main 函数用 thread_create 创建了 10 个子线程。有趣的参数是第二个和第三个。第二个参数 go 是一个函数指针——新创建的检测应该开始执行的代码位置。第三个参数 i 传递给 go 函数。因此，thread_create 初始化第i 个线程的状态使得它准备调用函数 go，参数是 i。&lt;/p&gt;
&lt;p&gt;当调度者运行第 i 个线程，线程运行函数go，参数为 i，打印 hello from 线程 i。 线程接着返回值 i+100 通过调用 thread_exit. 这个调用将特定的值保存到 trhead_t 的对象里，使得 thread_join 能够找到它。&lt;/p&gt;
&lt;p&gt;Main 函数用thread_join 来等待每个它创建的线程。当每个线程完成的时候，main 的代码会的读取完成线程的退出值并打印。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例子&lt;/strong&gt;：为什么来自线程 2 的“线程 returned”的消息&lt;strong&gt;一定是&lt;/strong&gt;在来自线程 5 的线程 returned 的消息打印之前先打印？&lt;/p&gt;
&lt;p&gt;回答：虽然每个创建的线程完成的顺序是不确定的，但是主线程是按照创建的顺序按顺序检查的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例子&lt;/strong&gt;：当线程 5 打印 hello 的时候未退出的线程的最少数是多少？最多数是多少？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回答&lt;/strong&gt;：最少是 2，最多是 11&lt;/p&gt;
&lt;h2 id=&#34;2-创建线程thread_create和线程等待thread_join在并行计算中的应用&#34;&gt;2. 创建线程(thread_create)和线程等待(thread_join)在并行计算中的应用&lt;/h2&gt;
&lt;p&gt;尽管线程接口很简单，但非常强大。例如用”&lt;strong&gt;fork-join 并行”&lt;/strong&gt;（&lt;strong&gt;fork-join 并行&lt;/strong&gt;即 thread_create 和 thread_join 一起使用来实现并行化计算）, 一个线程可以创建子线程来执行工作(“fork”, 或者 thread_create), 它可以等待他们的结果(“join”).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 为了传递两个参数，我们需要一个结构来保存它们.
typedef struct bzeroparams {
   unsigned char *buffer; int length;
};
#define NTHREADS 10
void go (struct bzeroparams *p) {
   memset(p-&amp;gt;buffer, 0, p-&amp;gt;length);
}
//用多线程对一个块进行清零.
void blockzero (unsigned char *p, int length) {
  int i;
  thread_t threads[NTHREADS];
  struct bzeroparams params[NTHREADS];
  // 为了简化，假设长度可以被NTHREADS 整除. assert((length   NTHREADS) == 0);
  for (i = 0; i &amp;lt; NTHREADS; i++) {
      params[i].buffer = p + i * length/NTHREADS; params[i].length = length/NTHREADS; thread_create_p(&amp;amp;(threads[i]), &amp;amp;go, &amp;amp;params[i]);
  }
  for (i = 0; i &amp;lt; NTHREADS; i++) {
      thread_join(threads[i]);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;图 4.7&lt;/strong&gt;: 使用多线程并行地对一个内存连续区域清零的程序.&lt;br&gt;
&lt;strong&gt;例子：并行的块清零&lt;/strong&gt;.在操作系统中一个应用 fork-join 并行的简单例子是对一段连续内存块清零的过程. 每当一个进程结束的时候，为了阻止无意的数据泄露, 操作系统必须把分配给这个进程中的内存清零。否则，一个新的进程可能会被重新分配给这个内存, 使得这个进程可以读取潜在的敏感的数据。例如，一个操作系统的远程登录程序可能暂时存储一个用户的密码在内存中，但是下一个使用同一内存区间的进程可能会是一个被一个恶意用户调用的扫描内存的程序.&lt;/p&gt;
&lt;p&gt;对于一个大的进程，并行地清零的函数是合理的。在现代计算机上，对 1GB 的内存清零需要大约 50 毫秒; 相比之下，创建和启动一个新的线程只需要几十微秒.&lt;/p&gt;
&lt;p&gt;图 4.7 展示了一个使用fork-join 并行清零的代码。多线程的 blockzero 创建了一系列线程并给每个分配了一段不相交的内存区间; 当所有线程都完成它们的工作的时候整个区间都被清零. 操作系统可以创建一系列低优先级的线程来运行 blockzero. 之后，当内存被需要的时候，内核可以调用 thread_join. 如果那个时候已经完全清零，则join 会立即返回；否则它需要等待直到这块内存可以被安全使用.&lt;/p&gt;
&lt;h1 id=&#34;p-stylecolorred3-线程的数据结构p&#34;&gt;&lt;p style=&#34;color:red&#34;&gt;3. 线程的数据结构&lt;/p&gt;&lt;/h1&gt;
&lt;p&gt;为了理解操作系统如何实现线程的抽象，我们必须定义两种状态，一个是每个线程的状态(the Per-Thread State)， 另一个是多个线程的共享状态(the Shared State)。然后我们才能给描述一个线程的生命周期——提供上述抽象，操作系统是如何能够创建，开始，暂停和删除线程的。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;图 4.8&lt;/strong&gt;: 一个多线程的进程或者操作系统的内核既有每个线程的状态也有共享状态. 线程控制块（TCB）存储了每个线程的状态: 线程当前的计算状态(例如，被保存的处理机的寄存器和一个指向(内核)栈的指针)和需要管理该线程的元数据(例如，线程的 ID，调度优先级，拥有者). 共享的状态包括程序的代码，全局静态变量和堆.&lt;/p&gt;
&lt;p&gt;一个多线程的进程或者操作系统内核都有每个线程的状态和共享状态。线程控制块保存着每个线程的状态: 线程计算当前的状态(例如，保存的处理机的寄存器和(内核)栈指针)和需要管理这个线程的元数据(例如，线程的 ID， 调度的优先级，拥有者)。共享状态包括：程序的代码，全局变量和堆。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;每个线程的状态(Per-Thread State)和线程控制块(TCB)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;操作系统需要一个数据结构来表示一个线程的状态；线程就好比是这个数据结构下的一个具体的对象。这个数据结构被称为线程控制块(线程控制块, TCB)。对于每个操作系统创建的线程，它就创建一个TCB。&lt;/p&gt;
&lt;p&gt;线程控制块记录两种类型的每个线程的信息：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这个线程当前的计算状态：栈和处理器中寄存器的值&lt;/li&gt;
&lt;li&gt;用于管理该线程的元数据&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;共享状态&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有一些状态是属于同一应用进程里的不同线程之间共享的状态，或者是操作系统内核内的线程之间共享的状态。特别的，程序代码是同一进程中所有线程共享的，尽管每个线程可能执行代码的不同位置。除此以外，静态分配的  全局变量和动态分配的堆变量也是同一进程的所有线程所共享的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告&lt;/strong&gt;：这是逻辑上的区分状态（Per-Thread State 和 Shared State），而操作系统往往不强制这种区分，换句话说，一个线程可以去访问同一进程内的其他线程的每个线程的状态，例如访问其他线程的用户栈。&lt;strong&gt;这是被允许的&lt;/strong&gt;。那么为了避免不要的错误，编写一个多线程的程序的时候必须要清楚哪些变量是线程之间共享的，哪些是私有的。以防一个线程会破坏其他线程。&lt;/p&gt;
&lt;h1 id=&#34;p-stylecolorred4-线程的生命周期p&#34;&gt;&lt;p style=&#34;color:red&#34;&gt;4. 线程的生命周期&lt;/p&gt;&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;图 4.9: 一个线程在它的生命周期中的状态.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上图展示了一个线程的生命周期。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;新建&lt;/strong&gt;：线程创建会把一个线程设为新建状态，分配和初始化每个线程的的数据结构。一旦这些完成，thread_ creation 代码会把该线程放到就绪队列中（隐含的意思是设置为READY 状态）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;就绪&lt;/strong&gt;：一个线程是就绪态就是指它可以运行但当前还没有运行。它的 TCB 被放在就绪队列上，它的寄存器的值被保存在它的 TCB 中。在任意时刻，调度器可以让一个线程从就绪态到运行态，只需要把它保存在 TCB 中的寄存器的值恢复到处理机的寄存器上。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行&lt;/strong&gt;：一个线程是运行态就是指它正在一个处理机上运行。此时，它的寄存器的值还在处理机的寄存器上，而不是TCB 中。一个运行态的线程可以按下面两种方式切换到就绪态：
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;调度器抢占一个运行的线程，然后将它放到就绪态，通过（1）保存线程的寄存器值到它的 TCB 中；并且（2）将处理机切换去执行就绪队列中某线程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个运行态的线程可以自愿地放弃(relinquish)处理机然后从运行态到就绪态，通过调用 yield(例如，线程库中的 thread_yield)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：一个线程可以从就绪态到运行态，再从运行态到就绪态，这样多次切换。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;等待&lt;/strong&gt;：一个线程在等待态是指它在等待某个事件。调度器能够将一个线程从就绪态移动到运行态，一个在等待态的线程却不能切换到运行态，它必须要等待某个其他的线程将它从等待态移动到就绪态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;完成&lt;/strong&gt;：一个线程在完成态就意味着它用于不会再运行了。系统能够释放部分或者它的全部状态，但它仍然要保留线程残留的一些信息，并把线程的 TCB 放到一个完成队列上。例如，thread_exit 调用会让一个线程将它的退出值通过 thread_join 传递给它的父亲线程。当一个线程的状态再没任何用处的时候（例如，当它的退出值已经被 thread_join 读取了），系统就可以删除和取回该线程的状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%B8%8D%E5%90%8C%E7%8A%B6%E6%80%81%E4%B8%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%8D%E7%BD%AE.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;图 4.10: 在不同状态下线程的每个线程状态的位置.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;理解这些状态的一种方式就是考虑一个线程的 TCB 和寄存器值存放的位置，如上图所示。当所有线程在就绪态，它们的 TCB 被放在就绪队列，它们的寄存器的值的拷贝也放在 TCB 中。所有在运行态的线程，它们的 TCB 被放在运行队列上，它们的寄存器值是在硬件寄存器上。所有在等待态的线程它们的 TCB 是放在不同的同步变量的等待队列上。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;idle 线 程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一个系统有 k 个处理机,  绝大多数操作系统确保正好有 k 个执行态的线程,  通过在每个处理机上维护一个低优先级的 &lt;strong&gt;idle 线程&lt;/strong&gt;以保证当该处理机没有什么事情可做的时候，仍然有线程在执行.&lt;/p&gt;
&lt;p&gt;在旧机器上，idle 线程会在一个紧凑循环中什么也不做. 而今天，idle 线程仍然在一个loop 中 spin, 但是为了省电，在每次迭代中，它把处理机进入一个低耗电的睡眠模式。在睡眠模式中，处理机暂停执行指令直到出现一个硬件中断。然后，处理机醒来并按照通常的方式来处理中断—保存当前正在执行的线程(idle 线程)的状态并执行处理程序. 在运行了处理程序之后，一个等待此 I/O 事件的线程现在可以是就绪态. 如果是这样的话，调度器接下来就执行这个进入就绪态的线程；否则 idle 线程继续执行，让处理机再次去睡觉.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;例子&lt;/strong&gt;：对于线程 Hello 程序，在一个单处理机上，主线程进入就绪态的最少次数是多少？最多次数又是多少？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回答&lt;/strong&gt;：当主线程被创建时，它必须进入就绪态；否则它永远不会被调度。在一个单处理机上，它必须放弃处理机为了让它的线程运行。在主线程被重新调度之前，子线程们接下来可以完成运行。一旦孩子们完成，主线程可以完成运行。&lt;strong&gt;因此最小的次数是 2&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最大的次数则是接近于无穷大&lt;/strong&gt;。一个运行的线程可以被抢占然后被重新调度若干次，而不影响执行的正确性。&lt;/p&gt;
&lt;h1 id=&#34;p-stylecolorred5-实现内核线程p&#34;&gt;&lt;p style=&#34;color:red&#34;&gt;5. 实现内核线程&lt;/p&gt;&lt;/h1&gt;
&lt;p&gt;我们介绍内核线程的实现。这是所有线程实现中最基础的，也是最简单的。&lt;/p&gt;
&lt;h2 id=&#34;p-stylecolorreda-创建内核线程代码不要求但后面介绍的基本步骤需要掌握p&#34;&gt;&lt;p style=&#34;color:red&#34;&gt;a. 创建内核线程（代码不要求，但后面介绍的基本步骤需要掌握）&lt;/p&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// func 是一个指向线程要运行的过程的指针.
// arg 是传递给这个过程的参数.
void thread_create(thread_t *thread, void (*func)(int), int arg) {
  // Allocate TCB and stack TCB *tcb = new TCB();
  thread -&amp;gt;tcb = tcb;
  tcb-&amp;gt;stack_size = INITIAL_STACK_SIZE;
  tcb-&amp;gt;stack = new Stack(INITIAL_STACK_SIZE);
  // 初始化寄存器使得当线程继续执行的时候，它从 stub 开始执行。
  //栈从分配的区域的顶端开始，然后向下增长. tcb-&amp;gt;sp = tcb-&amp;gt;stack + INITIAL_STACK_SIZE; tcb-&amp;gt;pc = stub;
  // 通过把 stub 的参数压栈来创建一个栈帧
  *(tcb-&amp;gt;sp) = arg; tcb-&amp;gt;sp--;
  *(tcb-&amp;gt;sp) = func; tcb-&amp;gt;sp--;
  // 创建另一个栈帧使得 thread_switch 正确工作. 这个 routine 在本章后面解释. thread_dummySwitchFrame(tcb);
  tcb-&amp;gt;state = READY;
  readyList.add(tcb); // 把 TCB 放在就绪队列
}
void stub(void (*func)(int), int arg) {
  (*func)(arg); // 执行函数 func()
  thread_exit(0); // 如果 func()不调用 exit,在这里调用 exit.
}


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;图 4.13&lt;/strong&gt;创建线程的伪代码。对栈的初始化和传参给初始函数是和机器相关的。在 intel x86 架构中，栈从搞地址开始然后向下增长，而参数被传递到栈上。在其他系统，栈能够向上增长，参数是通过寄存器传递。图 4.14 提供了thread_dummySwitchFrame 的伪代码&lt;br&gt;
图 4.13 展示了创建一个新线程的伪代码。thread_create 的目标是执行一个异步的过程调用给 func，其参数为 arg。当线程运行时，它执行 func(arg)【与父进程并发执行】&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建一个线程有 3 个步骤&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;分配每个线程的状态&lt;/strong&gt;. 第一步是为线程的每个线程的状态分配空间：TCB 和栈。正如我们所提到的，TCB 是操作系统用于管理线程的数据结构。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化每个线程的状态&lt;/strong&gt;. 为了初始化TCB，需要初始化各个寄存器的值。当该线程被调度时，我们想要我们想要它运行 func(arg)。然而，是先从一个 dummy 函数, stub, 运行，stub 接着调用func。我们需要这个步骤是因为 func 是返回而不是调用 thread_exit。没有这个 stub 的话，func 会返回栈顶的一个随机的位置。，有了 stub，函数 func 返回到stub，然后再由 stub 调用 thread_exit 来完成线程。在伪代码中，我们给 stub 压入两个参数进栈：func 和 arg。当线程开始运行，stub 的代码就会访问它的代码就行一个普通的procedure。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将TCB 放到就绪队列&lt;/strong&gt;. 创建一个线程的最后一步就是将它的状态设置为就绪态，然后把新的 TCB 放到就绪队列， 使得该线程能够被调度。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;p-stylecolorred-b-一个自愿的内核线程切换代码不要求但线程上下文切换的基本步骤需要掌握即保存旧线程的寄存器的值到tcb-中把新线程的tcb-中寄存器的值加载到cpu-的寄存器中p&#34;&gt;&lt;p style=&#34;color:red&#34;&gt; b. 一个自愿的内核线程切换（代码不要求，但线程上下文切换的基本步骤需要掌握，即：保存旧线程的寄存器的值到TCB 中，把新线程的TCB 中寄存器的值加载到CPU 的寄存器中&lt;/p&gt;&lt;/h2&gt;
&lt;p&gt;图 4.14 展示了在Intel x86 硬件架构下，thread_yiled 的简单实现的伪代码.一个线程调用 thread_yield 自愿地放弃处理机给另一个线程用. 调用的线程的寄存器被拷贝到它的 TCB 和栈中，便于当调度器再次选择它的时候，可以继续运行.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//我们以一个旧线程进入，而以新线程返回.
//以新线程的寄存器和栈返回.
void thread_switch(oldThreadTCB, newThread TCB) { 
    pushad; //把通用寄存器的值压入旧的栈中. 
    oldThreadTCB-&amp;gt;sp = esp; //保存旧线程的栈指针. 
    esp = newThreadTCB-&amp;gt;sp; // 切 换 到 新 的 栈 . 
    popad; // 从新的栈弹出寄存器的值.
    return;
}
void thread_yield() {
  TCB *chosenTCB, *finishedTCB;
  // 在切换的中间过程中阻止有中断暂停. disableInterrupts();
  // 从 就 绪 队 列 中 选 择 另 一 个 TCB. chosenTCB = readyList.getNext 线程(); 
  if (chosenTCB == NULL) {
    // 没有什么可以运行的，回去运行原始的线程.
  } else {
    // 将运行的线程移动到就绪队列. runningThread-&amp;gt;state = ready; readyList.add(runningThread);
    thread_switch(runningThread, chosenTCB); // 切换到新的线程. runningThread -&amp;gt;state = running;
  }
  //删除完成队列上的任意线程.
  while ((finishedTCB = finishedList-&amp;gt;getNextThread()) != NULL) {
    delete finishedTCB-&amp;gt;stack;
    delete finishedTCB;
  }
  enableInterrupts();
}
//thread_create 必须在它的栈顶放一个 dummy frame:
// 返回的 PC 和给 pushad 的空间来存储寄存器的备份.
// 这样的话，当某人切换到一个新创建的线程, thread_switch 的最后两行能正确工作.
void thread_dummySwitchFrame(new 线程) {
  *(tcb-&amp;gt;sp) = stub; //返回到 stub 的开头. tcb-&amp;gt;sp--;
  tcb-&amp;gt;sp -= SizeOfPopad;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;图 4.14&lt;/strong&gt;: 在 Intel x86 架构上 thread_switch 和 thread_yield 的伪代码。注意， thread_yield 是一个空操作如果没有其他线程可以运行。否则，它保存旧线程的状态并恢复新线程的状态。当旧线程被重新调度，它从thread_switch 返回到正在运行的线程.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;thread_yield 的伪代码首先关闭中断来阻止线程系统试图在同一时间做两个上下文切换. 伪代码接着把下一个线程拉出就绪队列(如果有的话)，然后切换到它. thread_switch 代码也许看上去有点不易理解, 由于它是在旧线程的上下文中被调用，而完成的时候是在新线程的上下文. 为了完成切换，thread_switch 把寄存器的状态保存到栈上，然后把栈指针保存到 TCB 中。接着它切换到新的线程的栈，从新线程的栈来恢复新线程的状态，然后返回到存储在新栈中的程序计数器的位置. 一个比较扭曲的地方是返回的位置可能不是 thread_yield!  返回到了新线程之前被暂停的地方.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;一个 0-线程的内核&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们不仅可以有一个单线程的内核或者一个多线程的内核，还有可能有一个没有线程的内核——0 线程的内核。实际上，这也是常见的。因为几乎内核中所有事情都是事件驱动的，例如响应一个中断，处理机异常或者系统调用。&lt;/p&gt;
&lt;p&gt;在一个简单的操作系统中，就没有必要创建内核线程或者内核线程控制块来追踪正在进行的计算。而是，当发生一个中断，陷阱或者异常，栈指针就设置为指向中断栈的栈底，指令指针设置为处理程序的地址。接着，处理程序开始执行，要不就立即返回到用户级的进程要不就暂停用户级的进程，然后返回到其他用户级进程。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;p-stylecolorred6-实现多线程的进程p&#34;&gt;&lt;p style=&#34;color:red&#34;&gt;6. 实现多线程的进程&lt;/p&gt;&lt;/h1&gt;
&lt;p&gt;所有广泛被应用的操作系统既支持内核线程也支持多线程进程。编程语言，例如 Java，和标准库接口例如 POSIX 用操作系统的这种支持来为编程者提供线程的抽象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用内核线程实现多线程的进程&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;支持多线程进程的最简单的方式是使用内核线程的实现。当一个用户级线程访问线程库要做同样的事情，它用系统调用来请求内核做同样的操作。&lt;/p&gt;
&lt;p&gt;如图 4.12 所示，一个进程的线程有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个用户级的栈用于执行用户代码&lt;/li&gt;
&lt;li&gt;一个内核中断栈：当该线程做系统调用时，或者引发了一次处理机异常，或者被中断&lt;/li&gt;
&lt;li&gt;一个内核TCB：用于保存和恢复每个线程的状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了创建一个线程，&lt;strong&gt;用户线程库&lt;/strong&gt;分配一个用户级的栈给新的线程，然后做一个系统调用进入内核。内核分配一个TCB 和内核栈，设置线程的状态使其用用户级栈从被请求的过程的开始处开始执行。内核需要在&lt;strong&gt;进程控制块&lt;/strong&gt;（&lt;strong&gt;PCB&lt;/strong&gt;） 中保存一个指向该TCB 的指针；如果进程退出，内核必须终止在这个进程内的任意线程。在创建了线程后，内核把新的线程放到就绪队列上，就像其他线程一样可以被调度，然后返回一个唯一的标识符给用户程序，以便于以后想要指定这个新创建的线程的时候使用（例如，for join）。线程的 join, yield,和 exit 用同样的方式实现：&lt;strong&gt;通过系统调用进入内核来执行所请求的函数&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&#34;p-stylecolorred7-实现用户级线程没有内核支持p&#34;&gt;&lt;p style=&#34;color:red&#34;&gt;7. 实现用户级线程（没有内核支持）&lt;/p&gt;&lt;/h1&gt;
&lt;p&gt;也可以实现一个完全在用户级的线程（作为库函数），不需要任何操作系统的支持。早期线程库函数采用这种纯用户级方法的原因是：因为极少有操作系统支持多线程的进程。在 JAVA 虚拟机中，也被称为绿线程。&lt;/p&gt;
&lt;p&gt;基本思想比较简单。线程库函数在进程中初始化线程的所有数据结构：TCB，就绪队列，完成队列，等待队列，这些全部在进程的用户地址空间。对线程库函数的调用就是普通的过程调用。&lt;/p&gt;
&lt;p&gt;在操作系统内核看来，一个用户级多线程的应用程序就是一个普通的单线程进程。绿线程的限制是操作系统&lt;strong&gt;内核不知道用户级就绪队列&lt;/strong&gt;。如果应用程序的某个线程执行一个系统调用需要等待 I/O，内核不知道还有别的用户级线程可以运行。就会&lt;strong&gt;把整个进程都阻塞&lt;/strong&gt;。类似的，在一个多处理机上，内核也不能让一个进程的多个线程在不同的处理机上运行。&lt;/p&gt;
">线程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/jin-cheng/"" data-c="
          &lt;h1 id=&#34;p-stylecolorred1-为什么引入进程p&#34;&gt;&lt;p style=&#34;color:red&#34;&gt;1. 为什么引入进程？&lt;/p&gt;&lt;/h1&gt;
&lt;p&gt;操作系统需要一种统一的方法监视、管理、控制处理器中不同程序的动态执行过程，“进程”的概念被引入！&lt;/p&gt;
&lt;h1 id=&#34;p-stylecolorred2-进程的定义p&#34;&gt;&lt;p style=&#34;color:red&#34;&gt;2. 进程的定义&lt;/p&gt;&lt;/h1&gt;
&lt;p&gt;进程没有严格的定义，但可以通过不同的角度去描述：计算机中正在运行的程序的一个实例（Instance。它包含（内存中的）代码段，数据段，堆，栈（用户栈和内核栈）；和当前的执行上下文（PC，SP 和其他寄存器），操作系统通过维护数据结构——进程控制块（PCB）来管理每个进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程控制块（Process Control Block——PCB&lt;/strong&gt;：PCB 是是操作系统用来管理进程的数据结构，是进程存在的唯一标识。每当操作系统创建一个进程，就是由操作系统为该进程设置一个 PCB；进程执行完成时，由系统收回其 PCB， 该进程便消亡了。PCB 的内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程的状态（就绪，执行，等待，完成）&lt;/li&gt;
&lt;li&gt;进程的 ID&lt;/li&gt;
&lt;li&gt;进程的名字&lt;/li&gt;
&lt;li&gt;进程的执行上下文（PC，SP，ELFAGS，其他寄存器）&lt;/li&gt;
&lt;li&gt;调度需要的信息（优先级，调度参数，使用的 CPU 时间，进程开始的时间…）&lt;/li&gt;
&lt;li&gt;内存管理的信息（基址和界限…）&lt;/li&gt;
&lt;li&gt;I/O 状态信息（打开的文件，占用的 I/O 设备…）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;p-stylecolorred3-内核线程和用户进程放到一起p&#34;&gt;&lt;p style=&#34;color:red&#34;&gt;3. 内核线程和用户进程放到一起&lt;/p&gt;&lt;/h1&gt;
&lt;p&gt;下面两个图展示了包含用户进程（上图是单线程进程，下图是多线程进程）和内核线程的内存空间信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有&lt;strong&gt;内核线程&lt;/strong&gt;都&lt;strong&gt;共享&lt;/strong&gt;内核的代码段（Code），全局变量(Globals)，堆(Heap)，和自己&lt;strong&gt;专门&lt;/strong&gt;的 TCB 和内核栈。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单线程的用户进程&lt;/strong&gt;在用户空间有自己的代码段，数据段，堆，栈，在内核空间有内核用于管理该进程使用的 PCB和内核栈。&lt;/li&gt;
&lt;li&gt;多线程的用户进程在用户空间有自己的代码段，数据段，堆和多个线程。每个线程有自己的用户栈，和内核空间的内核栈以及内核用于管理该线程的TCB。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B-%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B.jpg&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;图 4.11&lt;/strong&gt;:一个多线程的内核：有 3 个内核线程和两个单线程的用户级进程. 每个内核线程 有它自己的 TCB 和它自己的栈. 每个用户进程有一个用户级的栈用于执行用户的代码和一个内核中断栈用于执行系统调用和中断.&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%86%85%E6%A0%B8.jpg&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;图 4.12&lt;/strong&gt;: 一个多线程的内核：有 3 个内核线程和两个用户级的进程, 每个进程有 2 个线程. 每个用户级线程有一个用户级栈和一个内核中的中断栈用于执行系统调用和中断.&lt;/p&gt;
&lt;h1 id=&#34;p-stylecolorred4-进程的状态及其变迁p&#34;&gt;&lt;p style=&#34;color:red&#34;&gt;4. 进程的状态及其变迁&lt;/p&gt;&lt;/h1&gt;
&lt;h2 id=&#34;a-三状态变迁图&#34;&gt;a)  三状态变迁图&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;运行中的&lt;/strong&gt;进程至少具有以下三种基本状态（如下图所示）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;就绪状态&lt;/strong&gt;– 在某时刻，进程已获得除处理机以外的所有资源，一旦分到了处理机就可以立即执行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行状态&lt;/strong&gt;– 进程已经获得必要资源，并占有处理机运行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;等待状态&lt;/strong&gt;（也叫&lt;strong&gt;阻塞状态&lt;/strong&gt;） – 正在执行的进程，由于发生某事件而暂时无法执行下去&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%E5%9B%BE-%E4%B8%89%E7%8A%B6%E6%80%81.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;例如，下图展示了 3 个进程的状态的变迁。其中调度程序是操作系统内核中用于从就绪队列中选择下一个占用CPU 执行的进程的调度程序。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%E5%BA%8F%E5%88%97%E5%9B%BE%E4%B8%BE%E4%BE%8B-%E4%B8%89%E7%8A%B6%E6%80%81.jpg&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;b-五状态变迁图&#34;&gt;b)  五状态变迁图&lt;/h2&gt;
&lt;p&gt;其状态变迁图如下图所示，比 3 状态图多了两个状态：新建和退出。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;新建状态&lt;/strong&gt;– 至少建立PCB，但进程相关的其他内容可能未调入主存&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;退出状态&lt;/strong&gt;– 进程已经终止，但资源等待父进程或系统回收&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%E5%9B%BE-%E4%BA%94%E7%8A%B6%E6%80%81.jpg&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;触发进程状态变迁的事件&lt;/strong&gt;描述如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建&lt;/strong&gt;→&lt;strong&gt;就绪&lt;/strong&gt;：(1)系统初始化，(2)用户请求创建一个新进程，(3)进程执行了创建进程的系统调用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;就绪&lt;/strong&gt;→&lt;strong&gt;执行&lt;/strong&gt;：内核的调度程序(scheduler)选择了一个就绪的进程，让它占用处理机执行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行&lt;/strong&gt;→&lt;strong&gt;等待&lt;/strong&gt;: 需要等待某个事件发生才可以继续执行，例如 I/O 请求或者某个共享数据被锁住不能访问&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行&lt;/strong&gt;→&lt;strong&gt;就绪&lt;/strong&gt;（被&lt;strong&gt;抢占&lt;/strong&gt;）：高优先级的进程进入就绪态，进程的时间片用完&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;等待&lt;/strong&gt;→&lt;strong&gt;就绪&lt;/strong&gt;(被&lt;strong&gt;唤醒&lt;/strong&gt;)：等待的事件发生，例如 I/O 请求完成，共享数据可以访问&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行&lt;/strong&gt;→&lt;strong&gt;结束&lt;/strong&gt;：可能是正常退出（调用 exit 系统调用），可能是出错（异常，由操作系统强制终止）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;c-七状态变迁图&#34;&gt;c.) 七状态变迁图&lt;/h2&gt;
&lt;p&gt;当内存不够的时候，执行状态的进程，就绪状态的进程和等待状态的进程都有可能因为优先级较低而被从内存移出放到外存，如果是执行态和就绪态的进程被移出到外存，则被称为&lt;strong&gt;就绪挂起&lt;/strong&gt;；如果是等待态的进程被移出到外存，则被称为&lt;strong&gt;等待挂起&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;等待挂起&lt;/strong&gt;：进程在外存等待某事件的出现&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;就绪挂起&lt;/strong&gt;：进程在外存，但只要进入内存就可以运行新加入的&lt;strong&gt;状态变迁&lt;/strong&gt;有两类：挂起和激活。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;挂起：把一个进程从内存移到外存&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;等待&lt;/strong&gt;→&lt;strong&gt;等待挂起&lt;/strong&gt;：没有进程处于就绪状态或者就绪进程要求更多的内存&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;就绪&lt;/strong&gt;→&lt;strong&gt;就绪挂起&lt;/strong&gt;：当有高优先级等待的进程和低优先级的就绪进程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行&lt;/strong&gt;→&lt;strong&gt;就绪挂起&lt;/strong&gt;：当有高优先级等待挂起进程因为等待的事件发生了而进入就绪挂起&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;等待挂起&lt;/strong&gt;→&lt;strong&gt;就绪挂起&lt;/strong&gt;：当有等待挂起的进程所等待的事件发生了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;激活：把一个进程从外存移到内存&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;就绪挂起&lt;/strong&gt;→&lt;strong&gt;就绪&lt;/strong&gt;：没有就绪进程或挂起就绪进程优先级高于就绪进程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;等待挂起&lt;/strong&gt;→&lt;strong&gt;等待&lt;/strong&gt;：当一个进程释放足够内存，并有高优先级等待挂起进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%E5%9B%BE-%E4%B8%83%E7%8A%B6%E6%80%81.jpg&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;p-stylecolorred5-进程状态的队列p&#34;&gt;&lt;p style=&#34;color:red&#34;&gt;5. 进程状态的队列&lt;/p&gt;&lt;/h1&gt;
&lt;p&gt;进程控制块根据不同状态被放到不同的队列中，如下图所示&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;就绪队列：状态为就绪的PCB 队列，该队列可以是链表也可以是索引，还可以多个队列&lt;/li&gt;
&lt;li&gt;执行队列：状态为执行的PCB 队列&lt;/li&gt;
&lt;li&gt;等待队列：状态为等待的PCB 队列，不同的等待事件对应不同的等待队列&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E9%98%9F%E5%88%97.jpg&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;p-stylecolorred6-进程状态切换的实现p&#34;&gt;&lt;p style=&#34;color:red&#34;&gt;6. 进程状态切换的实现&lt;/p&gt;&lt;/h1&gt;
&lt;p&gt;我们用下图来说明两个进程之间的切换过程。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如上图所示，有两个并发执行的进程，P0 和 P1.首先是 P0 执行，当出现一个中断或系统调用，硬件开始执行相应的处理程序，假设该处理程序调用了 scheduler（调度程序），该调度程序决定让进程 P1 执行，于是需要切换进程的上下文。具体地，(1)先将进程 P0 的进程上下文（PC，SP 和其他寄存器信息）保存到 PCB0，(2)如果是时钟中断，将PCB0 加入就绪队列中等待下一次被 scheduler 调度；如果是一次 I/O 系统调用，则将 PCB0 放入相应的等待队列中， (3)把进程 P1 的 PCB1 从就绪队列中移除，放进执行队列中，(4)将进程上下文从 PCB1 中恢复到寄存器中，此时 PC 指向了进程 P1 要执行的指令，SP 指向了进程 P1 的执行栈，于是 P1 开始执行。当再次出现时钟中断或者系统调用，再用同样的方式保存 P1 的状态到 PCB1 中。不再赘述。&lt;/p&gt;
&lt;h1 id=&#34;p-stylecolorred7-windows-的进程管理p&#34;&gt;&lt;p style=&#34;color:red&#34;&gt;7. Windows 的进程管理&lt;/p&gt;&lt;/h1&gt;
&lt;p&gt;进程管理之一就是增加一个系统调用，用于创建一个进程。这个理论上很简单但实际实现却比较复杂。在Windows 中，有一个程序，称为CreateProcess，它的简化形式如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Boolean CreateProcess(char *prog, char *args);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们称创建进程的进程为&lt;strong&gt;父亲&lt;/strong&gt;，而被创建的进程被称为&lt;strong&gt;孩子&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;CreateProcess 需要执行哪些步骤呢？我们之前已有介绍，内核需要&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建并初始化内核中的 PCB&lt;/li&gt;
&lt;li&gt;创建和初始化一个新的地址空间&lt;/li&gt;
&lt;li&gt;加载程序prog 进入地址空间&lt;/li&gt;
&lt;li&gt;将参数 args 拷贝到地址空间的内存中&lt;/li&gt;
&lt;li&gt;初始化硬件上下文来从第一条指令开始执行&lt;/li&gt;
&lt;li&gt;通知调度程序有新的进程准备运行了&lt;br&gt;
不幸的是，实际的实现要复杂的多，CreateProcess 有十个参数需要设置，如下图所示。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/CreateProcess.png&#34; alt=&#34;**Figure 3.3**: 一个如何用 Windows 的系统调用 CreateProcess 的例子. 前两个参数指定程序和它的参数；剩下的关心进程的运行环境.&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Figure 3.3: 一个如何用 Windows 的系统调用 CreateProcess 的例子. 前两个参数指定程序和它的参数；剩下的关心进程的运行环境.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;p-stylecolorred-8-unix-的进程管理p&#34;&gt;&lt;p style=&#34;color:red&#34;&gt; 8. UNIX 的进程管理&lt;/p&gt;&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;创建和管理进程的 API&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;fork()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;创建一个子进程作为当前进程的一个克隆。fork 调用有两个  返回，一个是返回到父进程，另一个返回到子进程.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;exec(prog, args)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;在当前进程中运行应用程序 prog.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;exit()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;告诉内核当前的进程完成了，它的数据结构需要被垃圾回收.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;wait(processID)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;暂停一直到该子进程结束.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;signal(processID, type)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;发送一个特定类型的中断给其他一个进程.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Figure 3.7&lt;/strong&gt;: UNIX 中管理和创建进程的 API.&lt;/p&gt;
&lt;p&gt;UNIX 用一种不同的方法来创建进程，这种实现是在理论上复杂，但实现上却比较简单。UNIX 把 CreateProcess 分割成两个阶段，分别称为 fork 和 exec，如下图所示&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/fork-exec.jpg&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Figure 3.4&lt;/strong&gt;: UNIX 的系统调用 fork 和 exec 的操作. UNIX 的 fork 对父进程做了一个拷贝; UNIX 的 exec 将子进程改变成新运行的程序.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UNIX 的 fork&lt;/strong&gt;创建一个和父进程完全一致的拷贝，只有一项例外（我们需要某种方法来区分父进程和孩子）。一旦上下文设置好，子进程就调用 UNIX 的 exec 程序。exec 加载新的可执行镜像进入内存并开始执行。看上去先拷贝父进程，然后又用一个新的可执行镜像覆盖看上去有些没必要。实际上 fork 和 exec 来创建新进程的实现确是非常快速的，其中所使用的技术我们会在后面介绍。&lt;/p&gt;
&lt;p&gt;在这个设计中, UNIX 的 fork 不接受参数，并返回一个整数。UNIX 的 exec 接受两个参数(要运行的程序的名字和传递给该程序的参数的数组). 这里是 CreateProcess 需要 10 个参数. 部分是因为 UNIX 的 fork 和 exec 的简洁性， 这个接口从 70 年代初期被设计出来到现在几乎没有改变.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UNIX 的 fork&lt;/strong&gt;程序包含以下步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建和初始化内核中的 PCB&lt;/li&gt;
&lt;li&gt;创建一个新的地址空间&lt;/li&gt;
&lt;li&gt;初始化地址空间，将父进程的地址空间完全拷贝过来&lt;/li&gt;
&lt;li&gt;继承父进程的执行上下文&lt;/li&gt;
&lt;li&gt;通知调度程序有新的进程可以运行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比较诡异的一点就是 fork 这个系统调用返回会返回两次：一个是返回给父亲进程，一个是返回给子进程。对于父进程，UNIX 返回子进程的 ID，对于子进程，返回 0 来表示成功。显然，当你克隆了你自己，你需要有某种方式来分辨谁是克隆者，谁是你本身。UNIX 就通过 fork 这个系统调用的返回值来区分这两个进程。Fork 的 sample code 如下图所示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int child_pid = fork();
if (child_pid == 0) { //我是子进程.
  printf(&amp;quot;I am process #   d\n&amp;quot;, getpid()); return 0;
} else { //我是父进程.
  printf(&amp;quot;I am the parent of process #   d\n&amp;quot;, child_pid); return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可能的输出有两种：&lt;br&gt;
&lt;strong&gt;I am the parent of process 495 I am process 495&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另一种概率小但仍可能的输出是:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I am process 456&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I am the parent of process 456&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Figure 3.5&lt;/strong&gt;: fork 一个进程的 UNIX 代码, 和运行这个代码的可能的输出。。getpid 是一个系统调用，用来获取当前进程的 ID.&lt;/p&gt;
&lt;p&gt;如果我们运行图 3.5 的程序会发生什么？UNIX fork 返回两次，一次是从子进程返回，结果是 0，一次从父进程返回， 结果是子进程的 ID。然而，我们不知道是父进程还是子进程先运行。父进程已经在运行了，看上去它更可能先打印输出。然而，一个时钟中断(timer interrupt)可能在父进程fork 了进程后出现，因此会出现进程切换。或者，我们在多核系统上运行，父进程和子进程是同时运行。无论哪种情况子进程都可能在父进程之前输出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UNIX 的exec 和wait&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;UNIX 的系统调用 exec 完成需要运行一个新成效的步骤。一旦子进程从 UNIX fork 返回并设置了新进程的执行环节后，子进程调用 UNIX exec. 在我们下一节讨论UNIX 管道的时候，我们会描述更多这个如何工作的.&lt;/p&gt;
&lt;p&gt;Exec 包含如下步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加载程序prog 到当前的地址空间&lt;/li&gt;
&lt;li&gt;拷贝参数 args 到地址空间中&lt;/li&gt;
&lt;li&gt;初始化硬件上下文来从开头开始执行  到此为止，exec 就创建了一个新的进程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另一方面，父进程常常需要暂停直到子进程完成运行为止，例如下一步骤是依赖于上一步骤的输出。所以 UNIX 还有一个系统调用，很自然地被叫做wait，它会暂停父进程知道子进程完成或者崩掉或者终止。由于父进程可能创建了许多的子进程，wait 需要设定子进程的 ID 作为参数，来确定要等待的子进程。然而，这个对wait 的调用在 UNIX 中是可选的。&lt;/p&gt;
&lt;h1 id=&#34;p-stylecolorred9-案例实现一个简单的-shellp&#34;&gt;&lt;p style=&#34;color:red&#34;&gt;9. 案例：实现一个简单的 Shell&lt;/p&gt;&lt;/h1&gt;
&lt;p&gt;图 3.7 列出的UNIX 系统调用已经足以构建一个灵活和强大的命令行 shell，该 shell 完全在用户级运行，不需要特殊权限.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main() {
  char *prog = NULL; char **args = NULL;
  // 一次读取输入的一行，并解析每一行为程序名字和程序参数
  while (readAndParseCmdLine(&amp;amp;prog, &amp;amp;args)) {
    // 创建一个子进程来运行命令. int child_pid = fork();
    if (child_pid == 0) {
      //我是子进程，用父进程的输入来运行程序exec(prog, args);
      // 这里不会到达。。
      } else {
        // 我是父进程，等待子进程完成. wait(child_pid);
        return 0;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Figure 3.8&lt;/strong&gt;: 一个简单的 UNIX shell 的代码.&lt;br&gt;
图 3.8 展示了一个shell 的基本操作的代码。这个 shell 从输入读取一个命令行, 然后它 fork 一个进程来执行指令.父进程(shell)在读取下一个要执行的命令行之前必须等待子进程完成。&lt;/p&gt;
">进程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/mian-shi-ti-xi-lie-mysql-shu-ju-ku/"" data-c="
          &lt;h1 id=&#34;存储引擎&#34;&gt;存储引擎&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;MySQL 默认的存储引擎是 InnoDB&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;myisam-和-innodb-的区别&#34;&gt;MyISAM 和 InnoDB 的区别&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;MyISAM&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;InnoDB&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;是否支持行级锁&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;只有&lt;strong&gt;表级锁&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;支持&lt;strong&gt;行级锁和表级锁&lt;/strong&gt;，默认为行级锁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;查询性能&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;强调的是性能，每次查询具有原子性，执行速度快&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;使用了聚簇索引、或需要访问的数据可以放入内存的应用下速度快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;是否支持事务&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不支持&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;是否支持崩溃后的安全恢复&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不支持&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;支持。事务、回滚、崩溃修复能力和事务安全型表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;是否支持外键&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不支持&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;是否支持 MVCC&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不支持&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;支持。应对高并发事务，MVCC比单纯的加锁更高效。MVCC只在READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作；MVCC 可以使用乐观锁和悲观锁来实现。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;其他功能&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;全文索引、压缩、空间函数&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;索引&#34;&gt;索引&lt;/h1&gt;
&lt;h2 id=&#34;聚簇索引与非聚簇索引&#34;&gt;聚簇索引与非聚簇索引&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;MyISAM：B+ 树叶子节点的 data 域存放的是&lt;strong&gt;数据记录的地址&lt;/strong&gt;。在索引检索的时候，首先按照 B+ 树搜索算法搜索索引，如果指定的 key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为 “&lt;strong&gt;非聚簇索引&lt;/strong&gt;”。&lt;/li&gt;
&lt;li&gt;InnoDB：其数据本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按照 B+ 树组织的一个索引结构。B+ 树叶子节点的 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 &lt;strong&gt;InnoDB 表数据文件本身就是主索引&lt;/strong&gt;。这被称为“&lt;strong&gt;聚簇索引&lt;/strong&gt;”（或“聚集索引”）。而其余的索引都作为辅助索引，&lt;strong&gt;辅助索引的 data 域存储相应记录主键的值&lt;/strong&gt;而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;hash-索引与-b-数索引&#34;&gt;Hash 索引与 B+ 数索引&lt;/h2&gt;
&lt;h3 id=&#34;hash-索引&#34;&gt;Hash 索引&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Hash 索引仅仅能满足 &amp;quot;=&amp;quot;、“IN” 的等值查询，不能使用范围查询。&lt;/li&gt;
&lt;li&gt;Hash 索引不能利用组合索引的部分索引键查询。&lt;/li&gt;
&lt;li&gt;Hash 索引遇到大量 Hash 值相等的情况后性能不一定就会比 B+ 树高。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;b-树索引&#34;&gt;B+ 树索引&lt;/h3&gt;
&lt;p&gt;B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，&lt;strong&gt;在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&#34;什么是事务&#34;&gt;什么是事务？&lt;/h1&gt;
&lt;p&gt;事务是逻辑上的一组操作，要么都执行，要么都不执行。&lt;/p&gt;
&lt;h1 id=&#34;事务的四大特征&#34;&gt;事务的四大特征&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;原子性（Atomicity）：事务被视为不可分割的最小单元。事务的所有操作要么全部成功提交，要么全部失败回滚。&lt;/li&gt;
&lt;li&gt;一致性（Consistency）：数据库在事务执行前后保持一致性状态，多个事务对同一个数据读取的结果是相同的。&lt;/li&gt;
&lt;li&gt;隔离性（Isolation）：一个事务所做的修改在最终提交以前，对其他事务是不可见的。&lt;/li&gt;
&lt;li&gt;持久性（Durability）：一旦事务提交，则其所做的修改将永远保存在数据库中。即使系统发生崩溃，事务执行的结果页不能丢失。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;只有满足一致性，事务的执行结果才是正确的。&lt;/li&gt;
&lt;li&gt;在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要满足原子性，就一定能满足一致性。&lt;/li&gt;
&lt;li&gt;在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还要满足隔离性，才能满足一致性。&lt;/li&gt;
&lt;li&gt;事务满足持久化是为了能应对数据库崩溃的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;AUTOCOMMIT&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MySQL 默认采用自动提交模式。也就是说，如果不显式使用 START TRASACTION 语句来开启一个事务，那么每个查询都会被当作一个事务自动提交。&lt;/p&gt;
&lt;h1 id=&#34;并发事务带来哪些问题&#34;&gt;并发事务带来哪些问题？&lt;/h1&gt;
&lt;h2 id=&#34;丢失修改&#34;&gt;丢失修改&lt;/h2&gt;
&lt;p&gt;T1 和 T2 两个事务都对一个数据进行修改， T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;读脏数据&#34;&gt;读脏数据&lt;/h2&gt;
&lt;p&gt;T1 修改一个数据，T2 随后读取这个数据，如果 T1 撤销了这次修改，那么 T2 读取到的数据是脏数据。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%84%8F%E8%AF%BB.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;不可重复读&#34;&gt;不可重复读&lt;/h2&gt;
&lt;p&gt;T2 读取一个数据，T1 对这个数据进行了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;幻影读&#34;&gt;幻影读&lt;/h2&gt;
&lt;p&gt;T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围内的数据，此时读取的结果和第一次读取的结果不同。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%B9%BB%E8%AF%BB.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;不可重复读和幻读的区别：&lt;br&gt;
不可重复读的重点是修改，比如多次读取一条记录发现其中的某些列的值被修改；幻读的重点在于新增或者删除，比如多次读取同一范围发现记录增多或减少了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;产生并发不一致问题主要原因是破坏了事务的隔离性，解决方法时通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。&lt;/p&gt;
&lt;h1 id=&#34;事务的隔离级别有哪些&#34;&gt;事务的隔离级别有哪些？&lt;/h1&gt;
&lt;h2 id=&#34;读未提交read-uncommitted&#34;&gt;读未提交（READ UNCOMMITTED）&lt;/h2&gt;
&lt;p&gt;事务中的修改，即使没有提交，对其他事务也是可见的。&lt;/p&gt;
&lt;h2 id=&#34;读已提交read-committed&#34;&gt;读已提交（READ COMMITTED）&lt;/h2&gt;
&lt;p&gt;一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。&lt;/p&gt;
&lt;h2 id=&#34;可重复读repeatable-read&#34;&gt;可重复读（REPEATABLE READ）&lt;/h2&gt;
&lt;p&gt;一个事务在第一次读取过某条记录后，即使其他事务修改了该记录的值并且提交，该&lt;strong&gt;事物之后再读该条记录时，读到的仍是第一次读到的值&lt;/strong&gt;。而不是每次都读到不同的数据，这就是可重复读。&lt;/p&gt;
&lt;h2 id=&#34;可串行化serializable&#34;&gt;可串行化（SERIALIZABLE）&lt;/h2&gt;
&lt;p&gt;强制事务串行执行。&lt;/p&gt;
&lt;p&gt;需要加锁实现，而其它隔离级别通常不需要。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;隔离级别&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;脏读&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;不可重复读&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;幻影读&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;读未提交&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;√&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;√&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;读已提交&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;×&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;√&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可重复读&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;×&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;×&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可串行化&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;×&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;×&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;MySQL InnoDB 存储引擎默认的隔离级别是&lt;strong&gt;可重复读&lt;/strong&gt;。InnoDB 存储引擎在可重读事务隔离级别下使用的是 Next-Key Lock 算法，因此可以避免幻读的产生。&lt;/p&gt;
&lt;h1 id=&#34;锁机制与-innodb-锁算法&#34;&gt;锁机制与 InnoDB 锁算法&lt;/h1&gt;
&lt;p&gt;MyISAM 和 InnoDB 存储引擎使用的锁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MyISAM 使用表级锁&lt;/li&gt;
&lt;li&gt;InnoDB 支持行级锁和表级锁，默认使用行级锁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;行级锁和表级锁的对比：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表级锁：MySQL 中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源耗费也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发率最低，MyISAM 和 InnoDB 引擎都支持表级锁。&lt;/li&gt;
&lt;li&gt;行级锁：MySQL 中锁定粒度最小的一种锁，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;InnoDB 存储引擎的锁的算法有三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Record Lock&lt;/strong&gt;：单个行记录上的锁&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Gap Lock&lt;/strong&gt;：间隙锁，锁定一个范围，不包括记录本身。GAP锁的⽬的，是为了防⽌同⼀事务的两次当前读，出现幻读的情况。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Next-key Lock&lt;/strong&gt;：Record + Gap 锁定一个范围，包含记录本身。对于⾏的查询，都是采⽤该方法，主要目的是解决幻读的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相关知识点：&lt;/p&gt;
&lt;p&gt;1.InnoDB 对于&lt;strong&gt;行的查询&lt;/strong&gt;使用 Next-key Lock&lt;/p&gt;
&lt;p&gt;2.Next-locking keying为了解决Phantom Problem幻读问题&lt;/p&gt;
&lt;p&gt;3.当查询的索引含有唯一属性时，将 next-key lock 降级为 record key&lt;/p&gt;
&lt;p&gt;4.Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生&lt;/p&gt;
&lt;p&gt;5.有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A.将事务隔离级别设置为RC&lt;/li&gt;
&lt;li&gt;B.将参数innodb_locks_unsafe_for_binlog设置为1&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;介绍一下两段锁协议&#34;&gt;介绍一下两段锁协议&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;阶段一：&lt;strong&gt;加锁阶段&lt;/strong&gt;。在这阶段，事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁。&lt;/li&gt;
&lt;li&gt;阶段二：&lt;strong&gt;解锁阶段&lt;/strong&gt;。在这阶段，事务可以释放任何数据项上的任何类型的琐，但是不能再申请任何锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：两段锁协议可能会导致死锁。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%B8%A4%E6%AE%B5%E9%94%81%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E9%94%81.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;介绍一下多版本并发控制mvcc&#34;&gt;介绍一下多版本并发控制（MVCC）&lt;/h1&gt;
&lt;p&gt;多版本并发控制（MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现读已提交和可重复读这两种隔离级别。而读未提交总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。&lt;/p&gt;
&lt;p&gt;对于使用 InnoDB 存储引擎的表来说，它的聚簇索引记录中都包三个隐藏列：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;strong&gt;列名&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;strong&gt;是否必须&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;strong&gt;占用空间&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;row_id&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;6字节&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;行ID，唯一标识一条记录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;transaction_id&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;6字节&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;事务ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;roll_pointer&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7字节&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;回滚指针&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;trx_id：每次对某条记录进行改动时，都会把对应的 &lt;strong&gt;事务 id&lt;/strong&gt; 赋值给 trx_id 列。&lt;/li&gt;
&lt;li&gt;roll_pointer：每次对某条记录进行改动时，这个隐藏列都会存一个指针，可以通过这个指针找到该记录修改前的信息（&lt;strong&gt;回滚指针&lt;/strong&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;readview&#34;&gt;ReadView&lt;/h2&gt;
&lt;p&gt;对于使用 &lt;code&gt;READ UNCOMMITTED&lt;/code&gt;隔离级别的事务来说，直接读取记录的最新版本就好了，对于使用 &lt;code&gt;SERIALIZABLE&lt;/code&gt; 隔离级别的事务来说，使用加锁的方式来访问记录。对于使用 &lt;code&gt;READ COMMITTED&lt;/code&gt; 和 &lt;code&gt;REPEATABLE READ&lt;/code&gt; 隔离级别的事务来说，就需要用到我们上边所说的版本链了，核心问题就是：&lt;strong&gt;需要判断一下版本链中的哪个版本是当前事务可见的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;ReadView 中主要包含4个比较重要的内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;m_ids：表示在生成 ReadView 时当前系统中&lt;strong&gt;活跃的（未提交的）读写事务的事务id列表&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;min_trx_id：表示在生成 ReadView 时当前系统中&lt;strong&gt;活跃的读写事务中最小的事务id&lt;/strong&gt;，也就是m_ids 中的最小值。&lt;/li&gt;
&lt;li&gt;max_trx_id：表示生成 ReadView 时系统中应该&lt;strong&gt;分配给下一个事务的 id值&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;creator_trx_id：表示&lt;strong&gt;生成该 ReadView 的事务的事务id&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;注意max_trx_id并不是m_ids中的最大值，事务 id 是递增分配的。比方说现在有 id 为1，2，3这三个事务，之后 id 为 3 的事务提交了。那么一个新的读事务在生成 ReadView 时，m_ids 就包括 1 和2，min_trx_id的值就是 1，max_trx_id的值就是 4 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;read-commited-实现方式&#34;&gt;READ COMMITED 实现方式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;每次读取数据前都生成一个ReadView&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4MVCC.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;repeatable-read-实现方式&#34;&gt;REPEATABLE READ 实现方式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;在第一次读取数据时生成一个ReadView，第二次读取数据时使用第一次生成的 ReadView。&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BBMVCC.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;mvcc总结&#34;&gt;MVCC总结&lt;/h2&gt;
&lt;p&gt;MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用 &lt;code&gt;READ COMMITTD&lt;/code&gt;、 &lt;code&gt;REPEATABLE READ&lt;/code&gt; 这两种隔离级别的事务在执行普通的 SEELCT 操作时访问记录的版本链的过程。可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。&lt;code&gt;READ COMMITTD&lt;/code&gt;、&lt;code&gt;REPEATABLE READ&lt;/code&gt; 这两个隔离级别的一个很大不同就是：&lt;strong&gt;生成ReadView 的时机不同&lt;/strong&gt;，&lt;code&gt;READ COMMITTD&lt;/code&gt; 在每一次进行普通 SELECT 操作前都会生成一个 ReadView，而 &lt;code&gt;REPEATABLE READ&lt;/code&gt; 只在第一次进行普通 SELECT 操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。&lt;/p&gt;
&lt;h1 id=&#34;next-key-locks&#34;&gt;Next-Key Locks&lt;/h1&gt;
&lt;p&gt;Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。&lt;/p&gt;
&lt;p&gt;MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（&lt;code&gt;REPEATABLE READ&lt;/code&gt;）隔离级别下，使用 &lt;code&gt;MVCC + Next-Key Locks&lt;/code&gt; 可以解决幻读问题。&lt;/p&gt;
&lt;h2 id=&#34;record-locks&#34;&gt;Record Locks&lt;/h2&gt;
&lt;p&gt;锁定一个记录上的索引，而不是记录本身。&lt;/p&gt;
&lt;p&gt;如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。&lt;/p&gt;
&lt;h2 id=&#34;gap-locks&#34;&gt;Gap Locks&lt;/h2&gt;
&lt;p&gt;锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;next-key-locks-2&#34;&gt;Next-Key Locks&lt;/h2&gt;
&lt;p&gt;它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +∞)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;大表优化&#34;&gt;大表优化&lt;/h1&gt;
&lt;p&gt;当 MySQL 单表记录数过大时，数据库的 CRUD 性能会明显下降，一些常见的优化措施如下：&lt;/p&gt;
&lt;h2 id=&#34;限定数据的范围&#34;&gt;限定数据的范围&lt;/h2&gt;
&lt;p&gt;务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询历史订单的时候，我们可以控制在一个月的范围内；&lt;/p&gt;
&lt;h2 id=&#34;读写分离&#34;&gt;读/写分离&lt;/h2&gt;
&lt;p&gt;经典的数据库拆分方案，主库负责写，从库负责读；&lt;/p&gt;
&lt;h2 id=&#34;垂直分区&#34;&gt;垂直分区&lt;/h2&gt;
&lt;p&gt;根据数据库里面数据表的相关性进行拆分。例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。&lt;/p&gt;
&lt;p&gt;简单来说垂直拆分是指数据表&lt;strong&gt;列的拆分&lt;/strong&gt;，把一张列比较多的表拆分为多张表。如下图所示，这样来说大家应该就更容易理解了。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%9E%82%E7%9B%B4%E5%88%86%E5%8C%BA.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;垂直拆分的优点：可以使得列数据变小，在查询时减少读取的 Block 数，&lt;strong&gt;减少 I/O 次数&lt;/strong&gt;。此外，垂直分区可以简化表的结构，易于维护。&lt;/li&gt;
&lt;li&gt;垂直拆分的缺点：&lt;strong&gt;主键会出现冗余&lt;/strong&gt;，需要管理冗余列，并会引起 join 操作，可以通过在应用层进行 join 来解决。此外，垂直分区会让事务变得更加复杂。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;水平分区&#34;&gt;水平分区&lt;/h2&gt;
&lt;p&gt;保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。水平拆分可以支撑非常大的数据量。&lt;/p&gt;
&lt;p&gt;水平拆分是指数据表&lt;strong&gt;行的拆分&lt;/strong&gt;，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%B0%B4%E5%B9%B3%E5%88%86%E5%8C%BA.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以水平拆分最好分库。&lt;/p&gt;
&lt;p&gt;水平拆分能够支持非常大的数据量存储，应用端改造也少，但分片事务难以解决，跨节点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。&lt;/p&gt;
&lt;p&gt;下面补充一下数据库分片的两种常见方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端代理：分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。当当网的Sharding-JDBC、阿里的TDDL是两种比较常用的实现。&lt;/li&gt;
&lt;li&gt;中间件代理：在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。我们现在谈的Mycat、360的Atlas、网易的DDB等等都是这种架构的实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详细内容可以参考：MySQL大表优化方案：&lt;a href=&#34;https://segmentfault.com/a/1190000006158186&#34;&gt;https://segmentfault.com/a/1190000006158186&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;分库分表之后id-主键如何处理&#34;&gt;分库分表之后，id 主键如何处理？&lt;/h1&gt;
&lt;p&gt;因为要分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来支持。&lt;/p&gt;
&lt;p&gt;生成全局 id 有一下这几种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;UUID&lt;/strong&gt;：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标识，比如文件的名字。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据库自增 id&lt;/strong&gt;：两台数据库分别设置不同步长，生成不重复 ID 的策略来实现高可用。这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;利用 redis 生成 id&lt;/strong&gt;：性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。&lt;/li&gt;
&lt;li&gt;......&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;查询语句不同元素where-join-limit-group-by-having等的先后执行顺序&#34;&gt;查询语句不同元素（where、join、limit、group by、having等）的先后执行顺序？&lt;/h1&gt;
&lt;p&gt;查询中使用到的关键字主要包含六个，并且它们的书写顺序依次为：&lt;/p&gt;
&lt;p&gt;select —— from —— where —— group by —— having  —— order by&lt;/p&gt;
&lt;p&gt;其中 select 和 from 是必须的，其他关键词是可选的，这六个关键词的执行顺序与 sql 语句的书写顺序并不是一样的，而是按照下面的顺序来执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;from：需要从哪个数据库表检索数据&lt;/li&gt;
&lt;li&gt;where：过滤表中的数据条件&lt;/li&gt;
&lt;li&gt;group by：如何将上面过滤出的数据进行分组&lt;/li&gt;
&lt;li&gt;having：对上面已经分组的数据进行过滤的条件&lt;/li&gt;
&lt;li&gt;select：查看结果集中的哪个列，或者列的计算结果&lt;/li&gt;
&lt;li&gt;order by：按照什么顺序来查看返回的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;from 后面的表关联，是自右向左解析，而 where 条件的解析顺序是自下向上的。&lt;/p&gt;
&lt;p&gt;也就是说，在写 SQL 的时候，尽量把数据量小的表放在最右边来进行关联（用小表去匹配大表），而把筛选出销量数据的条件尽量放在 where 语句的最左边（用小表去匹配大表）。&lt;/p&gt;
&lt;h1 id=&#34;关系型数据库与非关系型数据库&#34;&gt;关系型数据库与非关系型数据库&lt;/h1&gt;
&lt;p&gt;(1) 关系型数据库&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 SQL 语句方便的在一个表以及多个表之间做非常&lt;strong&gt;复杂的数据查询&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;支持事务，对于&lt;strong&gt;安全性能很高&lt;/strong&gt;的数据访问要求得以实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(2) 非关系型数据库&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NoSQL 基于键值对，不需要经过 SQL 层的解析，&lt;strong&gt;性能高&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;给予减会对，数据之间没有耦合性，&lt;strong&gt;容易水平扩展&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;b-树的数据结构&#34;&gt;B+ 树的数据结构？&lt;/h1&gt;
&lt;p&gt;B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。&lt;/p&gt;
&lt;p&gt;B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。&lt;/p&gt;
&lt;p&gt;在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/B+%E6%A0%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;为什么使用-b-树索引而不用红黑树&#34;&gt;为什么使用 B+ 树索引，而不用红黑树？&lt;/h1&gt;
&lt;p&gt;红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：&lt;/p&gt;
&lt;p&gt;（一）更少的查找次数&lt;/p&gt;
&lt;p&gt;平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。&lt;/p&gt;
&lt;p&gt;红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。&lt;/p&gt;
&lt;p&gt;（二）利用磁盘预读特性&lt;/p&gt;
&lt;p&gt;为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。&lt;/p&gt;
&lt;p&gt;操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/IZpRNTKs3EHiXO-vYphk1w&#34;&gt;为什么MySQL的索引要使用B+树而不是其它树形结构?比如B树？&lt;/a&gt;&lt;br&gt;
因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变（有些资料也称为扇出）&lt;br&gt;
指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;mysql-读写分离-主从复制&#34;&gt;MySQL 读写分离、主从复制&lt;/h1&gt;
&lt;h2 id=&#34;读写分离-2&#34;&gt;读写分离&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;MySQL 读写分离基本原理是让 &lt;strong&gt;master 数据库处理写操作，slave 数据库处理读操作&lt;/strong&gt;。master 将写操作的变更同步到各个 slave 节点。&lt;/p&gt;
&lt;h2 id=&#34;主从复制原理&#34;&gt;主从复制原理&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;master服务器将数据的改变记录二进制binlog日志，当master上的数据发生改变时，则将其改变写入二进制日志中；&lt;/li&gt;
&lt;li&gt;slave服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/OThread请求master二进制事件&lt;/li&gt;
&lt;li&gt;同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I/OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;分页&#34;&gt;分页&lt;/h1&gt;
&lt;p&gt;LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。&lt;br&gt;
如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//如果只给定一个参数，它表示返回最大的记录行数目：
mysql&amp;gt; SELECT * FROM table LIMIT 5; //检索前 5 个记录行
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;换句话说，LIMIT n 等价于 LIMIT 0,n。&lt;br&gt;
&lt;a href=&#34;https://segmentfault.com/a/1190000008859706&#34;&gt;https://segmentfault.com/a/1190000008859706&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;mybatis如何防止sql注入的&#34;&gt;MyBatis如何防止SQL注入的？&lt;/h1&gt;
&lt;p&gt;mybatis的#{}和&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;EOF&amp;#039;, got &amp;#039;#&amp;#039; at position 21: …以及order by注入问题
#̲{}：相当于 JDBC 中的 …&#39;&gt;{}的区别以及order by注入问题
#{}：相当于 JDBC 中的 PreparedStatement
&lt;/span&gt;{}：是输出变量的值&lt;br&gt;
简单说，#{}是经过预编译的，是安全的；${}是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入。&lt;/p&gt;
&lt;h1 id=&#34;参考链接&#34;&gt;参考链接：&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://cyc2018.github.io/CS-Notes/#/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86&#34;&gt;https://cyc2018.github.io/CS-Notes/#/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/MySQL.md&#34;&gt;https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/MySQL.md&lt;/a&gt;&lt;/p&gt;
">面试题系列 —— MySQL 数据库</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/mian-shi-ti-xi-lie-jvm/"" data-c="
          &lt;h1 id=&#34;比较-jvm-jre-jdk&#34;&gt;比较 JVM 、JRE、JDK&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/jre-jvm-jdk.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;JVM：Java Virtual Machine：Java 虚拟机&lt;/li&gt;
&lt;li&gt;JRE：Java Runtime Environment：Java 运行环境（JVM + 基础类库）&lt;/li&gt;
&lt;li&gt;JDK：JVM + 基础类库 + 编译工具（java、javac、javap）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;介绍下-java-内存区域-结构运行时数据区&#34;&gt;介绍下 Java 内存区域 / 结构（运行时数据区）&lt;/h1&gt;
&lt;h2 id=&#34;线程私有的&#34;&gt;线程私有的：&lt;/h2&gt;
&lt;h3 id=&#34;程序计数器&#34;&gt;程序计数器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;作用：记录正在执行的虚拟机&lt;strong&gt;字节码指令的地址&lt;/strong&gt;（如果正在执行的是本地方法则为空）&lt;/li&gt;
&lt;li&gt;唯一一个&lt;strong&gt;不会 OutOfMemory&lt;/strong&gt; 的内存区域&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;虚拟机栈线程栈&#34;&gt;虚拟机栈（线程栈）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;组成：&lt;strong&gt;栈帧&lt;/strong&gt;（每个方法有一个栈帧）
&lt;ul&gt;
&lt;li&gt;局部变量表&lt;/li&gt;
&lt;li&gt;操作数栈&lt;/li&gt;
&lt;li&gt;动态链接&lt;/li&gt;
&lt;li&gt;出口信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;ps：几个小问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;垃圾回收是否涉及栈内存？&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;栈内存放的是栈帧，每一次方法调用结束后（或抛出异常后）栈帧都会自动弹出栈，所以不需要垃圾回收来管理栈内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;栈内存分配越大越好吗&lt;/strong&gt;？
&lt;ul&gt;
&lt;li&gt;不，物理内存的大小是一定的，每个线程都有一个栈，如果栈内存过大，会让线程数变少。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法内的局部变量是否线程安全&lt;/strong&gt;？
&lt;ul&gt;
&lt;li&gt;如果方法内局部变量没有逃逸出方法，线程安全&lt;/li&gt;
&lt;li&gt;如果方法内局部变量逃逸出方法的作用范围，
&lt;ul&gt;
&lt;li&gt;基本数据类型存在&lt;strong&gt;栈帧&lt;/strong&gt;内，其他线程无法访问，线程安全。&lt;/li&gt;
&lt;li&gt;引用数据类型存在于&lt;strong&gt;堆&lt;/strong&gt;内，如果逃逸出方法（方法参数、返回值），其他线程拿到对象的引用，就可以通过引用找到堆内存中的对象进行修改，线程不安全。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;栈内存溢出：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;栈帧过多：递归调用中没有设置正确的结束条件。&lt;/li&gt;
&lt;li&gt;栈帧过大&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;本地方法栈&#34;&gt;本地方法栈&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;JVM 在调用本地方法（native 修饰的方法）时，需要为本地方法提供的内存空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程共有的&#34;&gt;线程共有的&lt;/h2&gt;
&lt;h3 id=&#34;堆&#34;&gt;堆&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;通过 &lt;strong&gt;new&lt;/strong&gt; 关键字创建出来的对象存放在堆内存中。&lt;/li&gt;
&lt;li&gt;有&lt;strong&gt;垃圾回收&lt;/strong&gt;机制。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;方法区方法区内有常量池&#34;&gt;方法区（方法区内有常量池）&lt;/h3&gt;
&lt;p&gt;存储&lt;strong&gt;类结构&lt;/strong&gt;相关的信息：成员变量、成员方法和构造器方法的代码部分、包括一些特殊方法。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%96%B9%E6%B3%95%E5%8C%BA1.6.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;HotSpot 1.6 虚拟机内存结构：&lt;br&gt;
方法区是一个概念，用一个&lt;strong&gt;永久代&lt;/strong&gt;作为方法区的实现。永久代包括：Class 类信息、类加载器、运行时常量池。StringTable 存在于运行时常量池中。&lt;br&gt;
方法区与永久代：方法区是一种&lt;strong&gt;概念&lt;/strong&gt;，永久代是 HotSpot 虚拟机对虚拟机规范中方法区的一种&lt;strong&gt;实现&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%96%B9%E6%B3%95%E5%8C%BA.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;HotSpot 1.8 虚拟机内存结构：&lt;br&gt;
方法区还是一个概念上的东西，方法区的实现使用&lt;strong&gt;元空间&lt;/strong&gt;。元空间内包含了：Class 类信息、类加载器、常量池，不过他已经不再占用堆内存了（不是由 JVM 管理它的内存结构），移出到本地内存（&lt;strong&gt;操作系统内存&lt;/strong&gt;）中。本地内存中还会放一些其他进程，有一块是元空间。StringTable 串被移动到了堆中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;介绍下-java-内存模型&#34;&gt;介绍下 Java 内存模型&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;JMM：Java Memory Mmodel&lt;/li&gt;
&lt;li&gt;Java 内存模型定义了一套在&lt;strong&gt;多线程&lt;/strong&gt;读写共享数据时，对数据的可见性、有序性和原子性的保障。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/jmm.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;如何判断对象是否死亡&#34;&gt;如何判断对象是否死亡？&lt;/h1&gt;
&lt;h2 id=&#34;引用计数法&#34;&gt;引用计数法&lt;/h2&gt;
&lt;p&gt;为每个对象添加一个&lt;strong&gt;引用计数器&lt;/strong&gt;，每当有一个引用指向这个对象，就把引用计数器的值 +1，当引用失效，计数器值 -1，直到引用计数器的值为 0，表示不再有引用指向这个对象，就可判定这个对象已死亡。&lt;/p&gt;
&lt;p&gt;因为无法解决对象间&lt;strong&gt;循环引用&lt;/strong&gt;的问题，所以主流的 Java 虚拟机中没有采用这种方法来管理内存。&lt;/p&gt;
&lt;h2 id=&#34;可达性分析法&#34;&gt;可达性分析法&lt;/h2&gt;
&lt;p&gt;以 GC Root 为起点向下搜索，搜索过的路径称为引用链，当一个对象到 GC Root 没有任何引用链相连时，则证明这个对象是不可用的。&lt;/p&gt;
&lt;h3 id=&#34;哪些对象可以作为-gc-root&#34;&gt;哪些对象可以作为 GC Root？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;虚拟机栈中局部变量引用的对象&lt;/li&gt;
&lt;li&gt;本地方法栈中 JNI 中引用的对象&lt;/li&gt;
&lt;li&gt;方法区静态属性引用的对象&lt;/li&gt;
&lt;li&gt;方法区中的常量引用的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;介绍一下-强引用-软引用-弱引用-虚引用&#34;&gt;介绍一下 强引用、软引用、弱引用、虚引用&lt;/h1&gt;
&lt;h2 id=&#34;强引用&#34;&gt;强引用&lt;/h2&gt;
&lt;p&gt;只要一个对象还有&lt;strong&gt;强引用&lt;/strong&gt;指向它，它就不会被回收。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;new&lt;/code&gt;一个对象的方式来创建强引用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object obj = new Object();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;软引用&#34;&gt;软引用&lt;/h2&gt;
&lt;p&gt;仅有软引用指向该对象时，在&lt;strong&gt;垃圾回收后，内存仍不足&lt;/strong&gt;就会再次触发垃圾回收，回收&lt;strong&gt;软引用对象&lt;/strong&gt;。可配合引用队列回收软引用本身。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;SoftReference&lt;/code&gt; 类来创建软引用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object obj = new Object();
SoftReference&amp;lt;Ojbect&amp;gt; sf = new SoftReference&amp;lt;Object&amp;gt;(obj);
obj = null; // 使对象只被软引用关联
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;弱引用&#34;&gt;弱引用&lt;/h2&gt;
&lt;p&gt;当仅有弱引用指向该对象时，在&lt;strong&gt;垃圾回收&lt;/strong&gt;时，无论内存是否充足，都会回收弱引用对象。可配合引用队列回收软引用本身。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;WeakReference&lt;/code&gt;类来创建弱引用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object obj = new Object();
WeakReference&amp;lt;Object&amp;gt; wf = new WeakReference&amp;lt;Object&amp;gt;(obj);
obj = null;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;虚引用&#34;&gt;虚引用&lt;/h2&gt;
&lt;p&gt;一个对象是否有虚引用的存在，不会对其生存时间造成影响，也&lt;strong&gt;无法通过虚引用得到一个对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为一个对象设置虚引用的唯一目的就是能&lt;strong&gt;在这个对象被回收时收到一个系统通知&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;使用 &lt;strong&gt;PhantomReference&lt;/strong&gt; 来创建虚引用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object obj = new Object();
PhantomReference &amp;lt;Object&amp;gt; wf = new PhantomReference &amp;lt;Object&amp;gt;(obj, null);
obj = null;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;垃圾收集有哪些算法各自的特点&#34;&gt;垃圾收集有哪些算法？各自的特点？&lt;/h1&gt;
&lt;h2 id=&#34;标记清除算法&#34;&gt;标记清除算法&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;标记&lt;/strong&gt;：从 GC Root 开始向下找，如果某个对象没有经过任意一条引用链，则把这个对象标记为垃圾对象&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;清除&lt;/strong&gt;：清除标记为垃圾的对象，并不是把内存中每个字节都清零，只是把这段内存的起始、结束地址放入一个空闲地址列表，下次分配内存时从空闲地址列表选择一块空闲内存进行分配。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;速度快&lt;/li&gt;
&lt;li&gt;易造成内碎片&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;标记整理算法&#34;&gt;标记整理算法&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;标记&lt;/strong&gt;：由 GC Root 向下找，经过的路径称为引用链，如果某个对象没有经过任何一条引用链，将其标记为垃圾对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;整理&lt;/strong&gt;：清理垃圾的过程中，将非垃圾对象依次向前移动，使内存更加紧凑。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;涉及到大量对象的移动，&lt;strong&gt;速度慢&lt;/strong&gt;。对象在整理的过程中，如果有其他引用指向这个对象，需要更改这些引用。&lt;/li&gt;
&lt;li&gt;没有内碎片&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;复制算法&#34;&gt;复制算法&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%A4%8D%E5%88%B61.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%A4%8D%E5%88%B62.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%A4%8D%E5%88%B63.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标记：将不经过引用链的对象标记垃圾对象。&lt;/li&gt;
&lt;li&gt;复制：将非垃圾对象从 FROM 区域复制到 TO 区域，在复制的过程中完成了整理，FROM 区域存在的都是垃圾对象，全部清除，交换 FROM 区域和 TO 区域。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不会有内碎片&lt;/li&gt;
&lt;li&gt;需要占用双倍空间&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分代收集算法&#34;&gt;分代收集算法&lt;/h2&gt;
&lt;p&gt;将堆划分为新生代和老年代&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新生代使用：复制算法&lt;/li&gt;
&lt;li&gt;老年代使用：标记-清除 算法 或 标记-整理 算法&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;hotspot-为什么要分为新生代和老年代&#34;&gt;HotSpot 为什么要分为新生代和老年代？&lt;/h1&gt;
&lt;p&gt;HotSpot 根据对象存活周期的不同将内存划分为新生代和老年代，&lt;strong&gt;新生代&lt;/strong&gt;在垃圾回收后，只有少部分对象会被保留，所以采用&lt;strong&gt;复制算法&lt;/strong&gt;；而&lt;strong&gt;老年代则&lt;/strong&gt;有大部分对象被保留，使用&lt;strong&gt;标记-清除&lt;/strong&gt; 或 &lt;strong&gt;标记-整理&lt;/strong&gt; 算法。&lt;/p&gt;
&lt;h1 id=&#34;方法区的回收&#34;&gt;方法区的回收&lt;/h1&gt;
&lt;p&gt;主要是对常量池的回收和类的回收。&lt;/p&gt;
&lt;p&gt;类的回收需要满足三个条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该类的所有实例已经被回收，此时堆中不存在该类的任何实例。&lt;/li&gt;
&lt;li&gt;该类的类加载器已经被回收。&lt;/li&gt;
&lt;li&gt;该类的类对象没有在任何地方被引用，且通过反射也无法获得该类方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;hotspot-gc-的触发条件&#34;&gt;HotSpot GC 的触发条件&lt;/h1&gt;
&lt;h2 id=&#34;minor-gc&#34;&gt;Minor GC&lt;/h2&gt;
&lt;p&gt;新生代中的 Eden 区域内存不足时触发 Minor GC。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Minor GC 会回收新生代，因为新生代对象存活时间较短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;full-gc&#34;&gt;Full GC&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;调用 System.gc() 建议虚拟机执行 Full GC&lt;/li&gt;
&lt;li&gt;老年代空间不足（大对象或长期存活的对象进入老年代导致老年代空间不足）时触发 Full GC&lt;/li&gt;
&lt;li&gt;空间分配担保失败&lt;/li&gt;
&lt;li&gt;JDK1.7 及以前的永久代空间不足&lt;/li&gt;
&lt;li&gt;Concurrent Mode Failure&lt;br&gt;
执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Full GC 回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;什么情况下新生代对象会晋升到老年代&#34;&gt;什么情况下新生代对象会晋升到老年代？&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;晋升年龄达到阈值的对象，会晋升到老年代。&lt;/li&gt;
&lt;li&gt;大对象直接进入老年代：避免在 Eden 和 Survior 之间来回进行大量复制。&lt;/li&gt;
&lt;li&gt;Minor GC 后，如果对象太大无法进入 Survior 区，则直接进入老年代。&lt;/li&gt;
&lt;li&gt;如果在 Survior 区中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄对象就可以直接进入老年代，无须等年龄达到晋升阈值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;常见的垃圾收集器有哪些&#34;&gt;常见的垃圾收集器有哪些？&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程。&lt;/li&gt;
&lt;li&gt;串行与并行：串行指的是垃圾收集器工作的时候必须停止用户线程；并行指的是垃圾收集器和用户线程同时工作。除了 CMS 和 G1之外，其他垃圾收集器都是以串行的方式执行的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;serial串行单线程收集器&#34;&gt;Serial（串行单线程）收集器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;工作在&lt;strong&gt;新生代&lt;/strong&gt;。&lt;strong&gt;复制&lt;/strong&gt;算法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;串行&lt;/strong&gt;方式执行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单线程&lt;/strong&gt;收集器，只使用一个线程进行垃圾手机工作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简单高效&lt;/strong&gt;，单个 CPU 没有进程切换的开销。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E4%B8%B2%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;四个 CPU 在运行，某时刻堆内存不足，触发垃圾回收。触发垃圾回收时，需要让这些线程到达一个安全点再停下，因为在垃圾回收的过程中，可能对象的地址发生改变，为了保证安全地使用这些对象地址，需要所有正在工作的用户线程到达这个安全点在停下。因为 Serial、SerialOld 都是单线程的垃圾回收器，因此在一个垃圾回收线程运行时，其他的用户线程都要阻塞，等到垃圾回收线程结束后，其他的用户线程再恢复运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。&lt;/p&gt;
&lt;h2 id=&#34;parnew串行多线程-收集器&#34;&gt;ParNew（串行多线程） 收集器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;串行&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多线程&lt;/strong&gt;垃圾收集器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。&lt;/p&gt;
&lt;h2 id=&#34;parallel-scavenge多线程吞吐量-收集器&#34;&gt;Parallel Scavenge（多线程吞吐量） 收集器&lt;/h2&gt;
&lt;p&gt;JDK 1.8 默认使用 Parallel Scavenge + Parallel Old 垃圾回收器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;多线程&lt;/strong&gt;垃圾收集器&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;吞吐量优先&lt;/strong&gt;。吞吐量：CPU 用于运行用户程序的时间与总时间的比值。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缩短停顿时间是以牺牲吞吐量和新生代空间来换取的&lt;/strong&gt;：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。&lt;/p&gt;
&lt;p&gt;可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。&lt;/p&gt;
&lt;h2 id=&#34;serial-old串行单线程老年代-收集器&#34;&gt;Serial Old（串行单线程老年代） 收集器&lt;/h2&gt;
&lt;p&gt;是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。&lt;/li&gt;
&lt;li&gt;作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;parallel-old多线程吞吐量老年代-收集器&#34;&gt;Parallel Old（多线程吞吐量老年代） 收集器&lt;/h2&gt;
&lt;p&gt;是 Parallel Scavenge 收集器的老年代版本。&lt;/p&gt;
&lt;p&gt;在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。&lt;/p&gt;
&lt;h2 id=&#34;cms-收集器&#34;&gt;CMS 收集器&lt;/h2&gt;
&lt;p&gt;CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
分为以下四个流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始标记：仅仅只是标记一下 &lt;strong&gt;GC Roots 能直接关联到的对象&lt;/strong&gt;，速度很快，需要停顿。&lt;/li&gt;
&lt;li&gt;并发标记：进行 &lt;strong&gt;GC Roots Tracing&lt;/strong&gt; 的过程，它在整个回收过程中耗时最长，不需要停顿。&lt;/li&gt;
&lt;li&gt;重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生&lt;strong&gt;变动&lt;/strong&gt;的那一部分对象的标记记录，需要停顿。&lt;/li&gt;
&lt;li&gt;并发清除：不需要停顿。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。&lt;/p&gt;
&lt;p&gt;具有以下缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;吞吐量低&lt;/strong&gt;：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。&lt;/li&gt;
&lt;li&gt;无法处理&lt;strong&gt;浮动垃圾&lt;/strong&gt;，可能出现 Concurrent Mode Failure。浮动垃圾是指&lt;strong&gt;并发清除&lt;/strong&gt;阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;标记 - 清除算法导致的空间碎片&lt;/strong&gt;，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;g1-收集器&#34;&gt;G1 收集器&lt;/h2&gt;
&lt;p&gt;G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。 HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。&lt;/p&gt;
&lt;p&gt;堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/heap.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/G1.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得&lt;strong&gt;每个小空间可以单独进行垃圾回收&lt;/strong&gt;。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。&lt;/p&gt;
&lt;p&gt;每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/G1_2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Card.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
新生代垃圾回收：找到根对象，沿着引用链找到存活对象，存活对象进行复制到幸存区。要找新生代对象的根对象，&lt;strong&gt;根对象有一部分来自于老年代&lt;/strong&gt;，老年代的存活对象非常多，如果遍历老年代找根对象效率低，因此把&lt;strong&gt;老年代区域再进行细分&lt;/strong&gt;，分成一个个 Card，每个 Card 是512KB，如果老年代其中有一个 &lt;strong&gt;Card 中的对象引用了新生代的某一个对象&lt;/strong&gt;，就把这个 &lt;strong&gt;Card 标记为脏&lt;/strong&gt;，这样以后，做 GC Root 遍历的时候就不用去找整个老年代了，只需要关注那些脏 Card 即可，减少搜索范围，提高扫描根对象的效率。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;卡表与 Remembered Set&lt;/li&gt;
&lt;li&gt;在引用变更时通过 post-write barrier + dirty card queue&lt;/li&gt;
&lt;li&gt;concurrent refinement threads 更新 Remembered Set&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/Card2.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
粉色的 Card 都是&lt;strong&gt;脏卡区&lt;/strong&gt;，Card 内有对象指向新生代区域的对象，新生代会记录 Remembered Set：从外部对我的引用，将来对新生代 Eden 进行垃圾回收时，就可以先通过 Remembered Set 知道它对应的哪些脏 Card，然后在到这些脏卡区遍历对象找到 GC Root。通过 post-write barrier：写屏障在每次&lt;strong&gt;对象的引用发生变更时，去更新脏 Card&lt;/strong&gt;，这个过程是异步操作，不会立刻完成脏卡的更新，会把更新指令放在 dirty card queue 脏卡队列中，将来由一个线程完成脏卡更新的操作。&lt;/p&gt;
&lt;p&gt;如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始标记：找到那些根对象，标记根对象。&lt;/li&gt;
&lt;li&gt;并发标记：从根对象出发，顺着引用链找到其他非垃圾对象，标记那些其他非垃圾对象。&lt;/li&gt;
&lt;li&gt;最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。&lt;/li&gt;
&lt;li&gt;筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具备如下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空间整合：整体来看是基于“&lt;strong&gt;标记 - 整理&lt;/strong&gt;”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“&lt;strong&gt;复制&lt;/strong&gt;”算法实现的，这意味着运行期间不会产生内存空间碎片。&lt;/li&gt;
&lt;li&gt;可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;12-类加载的过程&#34;&gt;12. 类加载的过程&lt;/h1&gt;
&lt;p&gt;包含了加载、验证、准备、解析和初始化这 5 个阶段。&lt;/p&gt;
&lt;h2 id=&#34;加载&#34;&gt;加载&lt;/h2&gt;
&lt;p&gt;加载是类加载的一个阶段，注意不要混淆。&lt;/p&gt;
&lt;p&gt;加载过程完成以下三件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过类的完全限定名称获取定义该类的二进制字节流。&lt;/li&gt;
&lt;li&gt;将该字节流表示的静态存储结构转换为方法区的运行时存储结构。&lt;/li&gt;
&lt;li&gt;在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中二进制字节流可以从以下方式中获取：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。&lt;/li&gt;
&lt;li&gt;从网络中获取，最典型的应用是 Applet。&lt;/li&gt;
&lt;li&gt;运行时计算生成，例如动态代理技术，在 java.lang.reflflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。&lt;/li&gt;
&lt;li&gt;由其他文件生成，例如由 JSP 文件生成对应的 Class 类。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;验证&#34;&gt;验证&lt;/h2&gt;
&lt;p&gt;确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。&lt;/p&gt;
&lt;h2 id=&#34;准备&#34;&gt;准备&lt;/h2&gt;
&lt;p&gt;类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。&lt;/p&gt;
&lt;p&gt;实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。&lt;/p&gt;
&lt;p&gt;初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static int value = 123; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static final int value = 123; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;解析&#34;&gt;解析&lt;/h2&gt;
&lt;p&gt;将常量池的符号引用替换为直接引用的过程。&lt;/p&gt;
&lt;p&gt;其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。&lt;/p&gt;
&lt;h2 id=&#34;初始化&#34;&gt;初始化&lt;/h2&gt;
&lt;p&gt;初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 &lt;clinit&gt;() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。&lt;/p&gt;
&lt;p&gt;&lt;clinit&gt;() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test { 
    static { 
        i = 0; // 给变量赋值可以正常编译通过 
        System.out.print(i); // 这句编译器会提示“非法向前引用” 
    }
    static int i = 1; 
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于父类的 &lt;clinit&gt;() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static class Parent { 
    public static int A = 1; 
    static { 
        A = 2; 
    } 
}
static class Sub extends Parent { 
    public static int B = A; 
}
public static void main(String[] args) { 
    System.out.println(Sub.B); // 2 
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 &lt;clinit&gt;() 方法。但接口与类不同的是，执行接口的 &lt;clinit&gt;() 方法不需要先执行父接口的 &lt;clinit&gt;() 方法。只有当父接口中定义的变量使&lt;br&gt;
用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 &lt;clinit&gt;() 方法。&lt;/p&gt;
&lt;p&gt;虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;clinit&gt;() 方法，其它线程都会阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕。如果在一 个类的 &lt;clinit&gt;() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。&lt;/p&gt;
&lt;h1 id=&#34;类初始化时机&#34;&gt;类初始化时机&lt;/h1&gt;
&lt;h2 id=&#34;主动引用&#34;&gt;主动引用&lt;/h2&gt;
&lt;p&gt;虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 fifinal 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。&lt;/li&gt;
&lt;li&gt;使用 java.lang.reflflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。&lt;/li&gt;
&lt;li&gt;当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。&lt;/li&gt;
&lt;li&gt;当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；&lt;/li&gt;
&lt;li&gt;当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;被动引用&#34;&gt;被动引用&lt;/h2&gt;
&lt;p&gt;以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引 用。被动引用的常见例子包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过子类引用父类的静态字段，不会导致子类初始化。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(SubClass.value); // value 字段在 SuperClass 中定义 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SuperClass[] sca = new SuperClass[10]; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(ConstClass.HELLOWORLD);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;java-虚拟机中有哪些类加载器&#34;&gt;Java 虚拟机中有哪些类加载器？&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;名称&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;加载哪的类&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Bootstrap ClassLoader（启动类加载器）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;JAVA_HOME/jre/lib&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无法直接访问&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Extension ClassLoader（扩展类加载器）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;JAVA_HOME/jre/lib/ext&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;上级为 Bootstrap，显示为 null&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Application ClassLoader（应用程序类加载器）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;classpath&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;上级为 Extension&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;自定义类加载器&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;自定义&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;上级为 Application&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;什么是双亲委派模型&#34;&gt;什么是双亲委派模型？&lt;/h1&gt;
&lt;p&gt;如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把类加载的请求委派给父类加载器去完成，每一层次的类加载器都是如此，因此所有的加载请求最终都会传送到顶层的启动类加载器中，只有当父类无法处理这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。&lt;/p&gt;
&lt;h1 id=&#34;使用双亲委派模型有什么好处&#34;&gt;使用双亲委派模型有什么好处？&lt;/h1&gt;
&lt;p&gt;双亲委派模型保证了 Java 程序的稳定运行，可以&lt;strong&gt;避免类的重复加载&lt;/strong&gt;（JVM 区分类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也&lt;strong&gt;保证了 Java 的核心 API 不被篡改&lt;/strong&gt;。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个 java.lang.Object 类的话，那么程序运行的时候，系统就会出现多个不同的 Object 类。&lt;/p&gt;
&lt;h1 id=&#34;内存分配策略&#34;&gt;内存分配策略&lt;/h1&gt;
&lt;h2 id=&#34;对象优先在-eden-分配&#34;&gt;对象优先在 Eden 分配&lt;/h2&gt;
&lt;p&gt;大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不足时，触发 Minor GC。&lt;/p&gt;
&lt;h2 id=&#34;大对象直接进入老年代&#34;&gt;大对象直接进入老年代&lt;/h2&gt;
&lt;p&gt;大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。&lt;br&gt;
经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。&lt;br&gt;
-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。&lt;/p&gt;
&lt;h2 id=&#34;长期存活的对象进入老年代&#34;&gt;长期存活的对象进入老年代&lt;/h2&gt;
&lt;p&gt;为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。&lt;br&gt;
-XX:MaxTenuringThreshold 用来定义年龄的阈值。&lt;/p&gt;
&lt;h2 id=&#34;动态对象年龄不判定&#34;&gt;动态对象年龄不判定&lt;/h2&gt;
&lt;p&gt;虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold 中要求的年龄。&lt;/p&gt;
&lt;h2 id=&#34;空间分配担保&#34;&gt;空间分配担保&lt;/h2&gt;
&lt;p&gt;在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。&lt;br&gt;
如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。&lt;/p&gt;
&lt;h1 id=&#34;说一下-java-对象的创建过程&#34;&gt;说一下 Java 对象的创建过程&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
① &lt;strong&gt;类加载检查&lt;/strong&gt;：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。&lt;br&gt;
② &lt;strong&gt;分配内存&lt;/strong&gt;：在类加载检查通过后，接下来虚拟机将为新生代对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;内存分配的两种方式：选择哪种空间分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由 GC 收集器的算法是 “标记-清除”，还是“标记-整理”/ &amp;quot;复制&amp;quot;。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
内存分配并发问题：在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CAS+失败重试：CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突重试就失败，直到成功为止。虚拟机采用 CAS 配上失败重试的方式来保证更新操作的原子性。&lt;/li&gt;
&lt;li&gt;TLAB：为每个线程预先在 Eden 区分配一块内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;③ &lt;strong&gt;初始化零值&lt;/strong&gt;：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。&lt;br&gt;
④ &lt;strong&gt;设置对象头&lt;/strong&gt;：初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在对象头中。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。&lt;br&gt;
⑤ &lt;strong&gt;执行 init 方法&lt;/strong&gt;：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚开始，&amp;lt; init &amp;gt;方法还没有执行，所有的字段都还为零。所以一般来说，执行new指令之后会接着执行&amp;lt; init &amp;gt;方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。&lt;/p&gt;
">面试题系列 —— JVM</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/mian-shi-ti-xi-lie-java-ji-he/"" data-c="
          &lt;h1 id=&#34;说一说-list-set-map-三者的区别&#34;&gt;说一说 List、Set、Map 三者的区别&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;List&lt;/code&gt; 是存储&lt;strong&gt;有序&lt;/strong&gt;的集合&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Set&lt;/code&gt; 集合元素&lt;strong&gt;不可重复&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Map&lt;/code&gt; 是存储&lt;strong&gt;键值对&lt;/strong&gt;的集合&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;arraylist-与-linkedlist-的区别&#34;&gt;ArrayList 与 LinkedList 的区别&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;底层存储数据结构：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ArrayList&lt;/code&gt; 初始容量时 10，底层是&lt;strong&gt;Object 数组&lt;/strong&gt;，所以具有数组的特性，可&lt;strong&gt;随机访问&lt;/strong&gt;，并且实现了&lt;code&gt;RandomAccess&lt;/code&gt; 接口标识支持随机访问。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LinkedList&lt;/code&gt; 底层是&lt;strong&gt;双向链表&lt;/strong&gt;，所以具有链表的特性，&lt;strong&gt;增删速度快&lt;/strong&gt;，但每个节点都有维护前后两个指针，占用&lt;strong&gt;存储空间较大&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;增删查效率：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ArrayList&lt;/code&gt; 如果添加到&lt;strong&gt;末尾&lt;/strong&gt;，时间复杂度&lt;strong&gt;O(1)&lt;/strong&gt;；如果添加&lt;strong&gt;中间&lt;/strong&gt;到指定 i 位置，需要把 i ~ n 位置的元素统一向后移动，时间复杂度 &lt;strong&gt;O(n-i)&lt;/strong&gt;。如果&lt;strong&gt;按下标查找&lt;/strong&gt;，时间复杂度&lt;strong&gt;O(1)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LinkedList&lt;/code&gt; 如果添加&lt;strong&gt;末尾&lt;/strong&gt;，时间复杂度 &lt;strong&gt;O(1)&lt;/strong&gt;，如果插入到&lt;strong&gt;中间&lt;/strong&gt;第 i 个位置，需要先查找到到 i 个位置的元素，查找效率 &lt;strong&gt;O(n)&lt;/strong&gt;，然后执行添加操作，修改指针指向，复杂度&lt;strong&gt;O(1)&lt;/strong&gt;。如果&lt;strong&gt;按下标查找&lt;/strong&gt;，需要判断下标是否小于当前 &lt;code&gt;size/2&lt;/code&gt; ，如果小于则从头向中间查找；否则从末尾向中间查找，时间复杂度&lt;strong&gt;O(n)&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;LinkedList 向第 index 位置插入元素 element&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;public void add(int index, E element) {
    // 检查 index 是否合理
    checkPositionIndex(index);
    // 插入到链表尾
    if (index == size)
        linkLast(element);
    // 插入到链表中间
    else
        linkBefore(element, node(index));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Node&amp;lt;E&amp;gt; node(int index) {
    // assert isElementIndex(index);
    // 如果插入位置下标 index &amp;lt; 整个链表长度的一半
    if (index &amp;lt; (size &amp;gt;&amp;gt; 1)) {
        // 从链表头向中间遍历，直到找到第 index 个位置
        Node&amp;lt;E&amp;gt; x = first;
        for (int i = 0; i &amp;lt; index; i++)
            x = x.next;
        return x;
    } else {
        // 从链表尾向中间遍历
        Node&amp;lt;E&amp;gt; x = last;
        // 直到找到第 index 个元素
        for (int i = size - 1; i &amp;gt; index; i--)
            x = x.prev;
        return x;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;arraylist-扩容机制&#34;&gt;ArrayList 扩容机制&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;public boolean add(E e) {
    // 确保数组容量能容纳下当前数组内实际的元素个数+1
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}

private void ensureCapacityInternal(int minCapacity) {
    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
}

private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    // overflow-conscious code
    // 如果当前数组需要的最小容量 &amp;gt; 数组的长度，则需要扩容
    if (minCapacity - elementData.length &amp;gt; 0)
        grow(minCapacity);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1);
    if (newCapacity - minCapacity &amp;lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;上述代码基于 JDK1.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;arraylist-和-vector-的区别&#34;&gt;ArrayList 和 Vector 的区别&lt;/h1&gt;
&lt;p&gt;线程安全&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ArrayList&lt;/code&gt; 线程不安全&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Vector&lt;/code&gt; 方法都使用 &lt;code&gt;synchronized&lt;/code&gt; 修饰，所以线程安全，同时效率也低。正因为 &lt;code&gt;Vector&lt;/code&gt; 效率低，所以一般不会使用，如果想实现同步，可以使用 &lt;code&gt;Collections.synchronizedList(new ArrayList&amp;lt;&amp;gt;());&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;扩容机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ArrayList&lt;/code&gt; 扩容后的容量为原来的 1.5 倍&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Vector&lt;/code&gt; 扩容后的容量 是原来的 2 倍&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;hashmap-和-hashtable的区别&#34;&gt;HashMap 和 Hashtable的区别&lt;/h1&gt;
&lt;p&gt;线程安全：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HashMap&lt;/code&gt; 线程不安全&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Hashtable&lt;/code&gt; 的方法使用 &lt;code&gt;synchronized&lt;/code&gt; 修饰，所以线程安全，也是正因为用 &lt;code&gt;synchronized&lt;/code&gt; 修饰，所以效率较低。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;初始大小扩容机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HashMap&lt;/code&gt; 的默认初始容量为 16（2 &amp;lt;&amp;lt; 4）；如果指定了初始容量，会把它扩充为 2 的幂次。扩容后容量为原来的 2n&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Hashtable&lt;/code&gt; 默认初始容量时 11，如果指定初始容量，使用初始容量。扩容后容量为原来的 2n+1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;是否允许 null 键值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HashMap&lt;/code&gt; 允许 null 键值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Hashtable&lt;/code&gt; 不允许 null 键值&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;hashmap-的-put-方法的具体流程&#34;&gt;HashMap 的 put 方法的具体流程&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Implements Map.put and related methods
 *
 * @param hash hash for key
 * @param key the key
 * @param value the value to put
 * @param onlyIfAbsent if true, don&#39;t change existing value
 * @param evict if false, the table is in creation mode.
 * @return previous value, or null if none
 */
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i;
    // 如果数组是空的
    if ((tab = table) == null || (n = tab.length) == 0)
        // 初始化集合
        n = (tab = resize()).length;
    // 如果数组中第 i 个位置为空，直接利用key-value创建节点并插入
    if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    // 如果数组中第 i 个位置不空
    else {
        Node&amp;lt;K,V&amp;gt; e; K k;
        // 如果存在 key 值相同，则先将此节点记录下来（覆盖 value）
        if (p.hash == hash &amp;amp;&amp;amp;
            ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
            e = p;
        // 如果是红黑树
        else if (p instanceof TreeNode)
            e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
        // 如果是链表
        else {
            for (int binCount = 0; ; ++binCount) {
                // 不断循环找到链表的最后一个节点，将新节点添加到这个节点后面
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    // 如果节点个数 &amp;gt;= 7，转成红黑树
                    if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &amp;amp;&amp;amp;
                    ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        // 如果 key 值相同，覆盖 value
        if (e != null) { // existing mapping for key
            // 暂存旧值
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            // 返回旧值
            return oldValue;
        }
    }
    ++modCount;
    if (++size &amp;gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/put.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;如果散列表为 null，&lt;code&gt;resize()&lt;/code&gt; 初始化散列表&lt;/li&gt;
&lt;li&gt;没有发生碰撞，直接添加元素到散列表中&lt;/li&gt;
&lt;li&gt;如果发生碰撞，判断时红黑树还是链表，然后调用相应的插入方法&lt;/li&gt;
&lt;li&gt;HashMap 的 resize() 扩容方法&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;hashmap-的-resize-扩容方法&#34;&gt;HashMap 的 resize() 扩容方法&lt;/h1&gt;
&lt;p&gt;如果当前size &amp;gt; 阈值（容量 * 装填因子），则扩容&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/resize.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;hashmap-容量为什么是-2-的幂次&#34;&gt;HashMap 容量为什么是 2 的幂次&lt;/h1&gt;
&lt;p&gt;减少 &lt;code&gt;hash&lt;/code&gt; 冲突，因为要用 &lt;code&gt;hash &amp;amp; (n-1)&lt;/code&gt; 确定元素存在数组中的下标位置，如果 n 是 2 的幂（1000），那么 n-1 得到的结果就全为 1 （10000 - 1 = 1111），这样 &lt;code&gt;(n-1) &amp;amp; hash&lt;/code&gt; 的值就是 hash。如果 n-1 中有某位为 0，那么 0 与任何数 &amp;amp; 结果都为0，增加了hash 冲突的概率。&lt;/p&gt;
&lt;h1 id=&#34;hashmap-17-18-对比&#34;&gt;HashMap 1.7 1.8 对比&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;JDK1.7&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据结构：数组+链表&lt;/p&gt;
&lt;p&gt;JDK1.7 hash 方法：9 次扰动（4 次位运算，5 次异或运算）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static int hash(int h) {
    // This function ensures that hashCodes that differ only by
    // constant multiples at each bit position have a bounded
    // number of collisions (approximately 8 at default load factor).
    h ^= (h &amp;gt;&amp;gt;&amp;gt; 20) ^ (h &amp;gt;&amp;gt;&amp;gt; 12);
    return h ^ (h &amp;gt;&amp;gt;&amp;gt; 7) ^ (h &amp;gt;&amp;gt;&amp;gt; 4);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;JDK 1.8&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据结构：数组 + 链表 + 红黑树&lt;/p&gt;
&lt;p&gt;JDK 1.8 hash 方法：2 次扰动（1 次位运算，1 次异或运算）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static final int hash(Object key) {
    int h;
    // key.hashCode()：返回散列值也就是hashcode
    // ^ ：按位异或
    // &amp;gt;&amp;gt;&amp;gt;:⽆符号右移，忽略符号位，空位都以0补⻬
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;贴一张比较详细的图：&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/hashmap.png&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;图片来源；&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;amp;mid=2247485685&amp;amp;idx=2&amp;amp;sn=b393e444487c88e8c204821faddff370&amp;amp;chksm=ebd749f4dca0c0e257e15c656f4504f224456495ad78e8aeb9ea370214ebd4b5c455b15e6045&amp;amp;token=1948873548&amp;amp;lang=zh_CN#rd&#34;&gt;https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;amp;mid=2247485685&amp;amp;idx=2&amp;amp;sn=b393e444487c88e8c204821faddff370&amp;amp;chksm=ebd749f4dca0c0e257e15c656f4504f224456495ad78e8aeb9ea370214ebd4b5c455b15e6045&amp;amp;token=1948873548&amp;amp;lang=zh_CN#rd&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;hashmap-是怎么解决哈希冲突的&#34;&gt;HashMap 是怎么解决哈希冲突的&lt;/h1&gt;
&lt;p&gt;什么是哈希冲突：两个不同的输入值，根据同一散列函数，计算出相同的散列值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;strong&gt;拉链法&lt;/strong&gt;来链接具有相同 hash 值的数据&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;两次扰动函数&lt;/strong&gt;（hash 函数）来降低哈希冲突的概率，使得&lt;strong&gt;数据分布更均匀&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;引入&lt;strong&gt;红黑树&lt;/strong&gt;降低查找的时间复杂度&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;hashmap-17-18多线程操作导致死循环问题&#34;&gt;HashMap 1.7 1.8多线程操作导致死循环问题&lt;/h1&gt;
&lt;p&gt;参考链接：&lt;a href=&#34;https://coolshell.cn/articles/9606.html&#34;&gt;https://coolshell.cn/articles/9606.html&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;hashmap-的-key-值要是为类对象则该类需要满足什么条件&#34;&gt;HashMap 的 key 值要是为类对象则该类需要满⾜什么条件？&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;重写 hashCode() 和 equals() 方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Hashmap&lt;/code&gt; 中放入相同的 &lt;code&gt;key&lt;/code&gt;，会覆盖 &lt;code&gt;value&lt;/code&gt; 值，而不是重新添加一个 &lt;code&gt;key-value&lt;/code&gt; 对，这就要求我们判断 &lt;code&gt;key&lt;/code&gt; 是否相同。&lt;/p&gt;
&lt;p&gt;以下为 &lt;code&gt;HashMap&lt;/code&gt; 的 &lt;code&gt;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (p.hash == hash &amp;amp;&amp;amp;
    ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从源码得知判断分为三个步骤：①判断 &lt;code&gt;key&lt;/code&gt; 的 &lt;code&gt;hash&lt;/code&gt; 值是否相同，这就要求我们重写 &lt;code&gt;hashCode()&lt;/code&gt; 方法；② 通过 &lt;code&gt;==&lt;/code&gt; 判断 &lt;code&gt;key&lt;/code&gt; 对象引用是否相等；③ 使用 &lt;code&gt;equals()&lt;/code&gt; 判断对象是否相等，这就要求我们重写 &lt;code&gt;equals()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;h1 id=&#34;concurrenthashmap-的底层实现方式&#34;&gt;ConcurrentHashMap 的底层实现方式&lt;/h1&gt;
&lt;p&gt;JDK1.7&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据结构：分段数组（&lt;code&gt;Segment&lt;/code&gt; 继承了 &lt;code&gt;ReentrantLock&lt;/code&gt;，每个段都有一个锁） + 链表（&lt;code&gt;HashEntry&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;线程安全：对整个桶数组进行了分割分段，每把锁只锁住一&lt;strong&gt;段&lt;/strong&gt;，多线程访问其他段的数据时不会产生冲突。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JDK1.8&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据结构：数组 + 链表 + 红黑树&lt;/li&gt;
&lt;li&gt;线程安全：部分锁定 + CAS。&lt;code&gt;synchronized&lt;/code&gt; 只锁定&lt;strong&gt;当前链表或红黑二叉树的首节点&lt;/strong&gt;，这样只要 hash 不冲突，就不会产生并发。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;concurrenthashmap-和-hashtable-的区别&#34;&gt;ConcurrentHashMap 和 Hashtable 的区别&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Hashtable&lt;br&gt;
数据结构：数组 + 链表&lt;br&gt;
实现线程安全：会锁住整个数组，某个线程在进行 put 操作时，其他线程只能阻塞。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JDK1.7 ConcurrentHashMap&lt;br&gt;
数据结构：分段数组+链表&lt;br&gt;
实现线程安全：分段锁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JDK1.8 ConcurrentHashMap&lt;br&gt;
数据结构：数组 + 链表 / 红黑树&lt;br&gt;
通过在部分加锁和利用CAS算法来实现同步。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;如何选用集合&#34;&gt;如何选用集合&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;如果存储键值对，选 &lt;code&gt;Map&lt;/code&gt; 接口下的集合
&lt;ul&gt;
&lt;li&gt;如果需要排序，选择 &lt;code&gt;TreeMap&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果不需要排序，优先选择 &lt;code&gt;HashMap&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果需要线程安全，选择 &lt;code&gt;ConcurrentHashMap&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;只需要存放元素值时，选择 &lt;code&gt;Collection&lt;/code&gt; 接口下的集合
&lt;ul&gt;
&lt;li&gt;如果需要顺序放取，选择 &lt;code&gt;ArrayList&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果需要频繁增删，选择 &lt;code&gt;LinkedList&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果需要元素不重复且排序，选择 &lt;code&gt;TreeSet&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果需要元素不重复但无需排序，优先选择 &lt;code&gt;HashSet&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/ZhongFuCheng3y/3y&#34;&gt;https://github.com/ZhongFuCheng3y/3y&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Snailclimb/JavaGuide&#34;&gt;https://github.com/Snailclimb/JavaGuide&lt;/a&gt;&lt;/p&gt;
">面试题系列 —— Java 集合</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/zookeeper-mian-shi-ti/"" data-c="
          &lt;h1 id=&#34;谈谈你对-zookeeper-的认识&#34;&gt;谈谈你对 Zookeeper 的认识&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Zookeeper&lt;/code&gt; 是一个&lt;strong&gt;分布式协调服务&lt;/strong&gt;的开源框架。主要用来解决分布式集群中应用系统的&lt;strong&gt;一致性&lt;/strong&gt;问题，例如怎样避免同时操作同一数据造成脏读的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;ZooKeeper&lt;/code&gt; 本质上是一个分布式的小文件存储系统&lt;/strong&gt;。提供基于类似于文件系统的目录树方式的数据存储，并且可以对树中的节点进行有效管理。从而用来维护和监控你存储的数据的状态变化。通过监控这些数据状态的变化，从而可以达到基于数据的集群管理。诸如：统一命名服务、分布式配置管理、分布式消息队列、分布式锁、分布式协调等功能。&lt;/p&gt;
&lt;h2 id=&#34;zookeeper-集群角色&#34;&gt;Zookeeper 集群角色&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/zk%E9%9B%86%E7%BE%A4%E8%A7%92%E8%89%B2.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;leader&#34;&gt;Leader:&lt;/h3&gt;
&lt;p&gt;Zookeeper 集群工作的核心&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事务请求&lt;/strong&gt;（写操作）的唯一调度和处理者，保证集群事务处理的顺序性；&lt;/p&gt;
&lt;p&gt;集群内部各个服务器的&lt;strong&gt;调度者&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于 create，setData，delete 等有写操作的请求，则需要统一转发给 leader 处理，leader 需要决定编号、执行操作，这个过程称为一个&lt;strong&gt;事务&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;follower&#34;&gt;Follower:&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;处理客户端非事务（读操作）请求，转发事务请求给 Leader；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参与集群 Leader 选举投票。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此外，针对访问量比较大的 zookeeper 集群，还可新增观察者角色。&lt;/p&gt;
&lt;h3 id=&#34;observer&#34;&gt;Observer:&lt;/h3&gt;
&lt;p&gt;观察者角色，观察 Zookeeper 集群的最新状态变化并将这些状态同步过来，其对于非事务请求可以进行独立处理，对于事务请求，则会转发给 Leader 服务器进行处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不会参与任何形式的投票&lt;/strong&gt;只提供非事务服务，通常用于在不影响集群事务处理能力的前提下提升集群的非事务处理能力。&lt;/p&gt;
&lt;h1 id=&#34;zookeeper-特性&#34;&gt;ZooKeeper 特性&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;全局数据一致&lt;/strong&gt;：集群中每个服务器保存一份相同的数据副本，&lt;code&gt;client&lt;/code&gt; 无论连接到哪个服务器，展示的数据都是一致的，这是最重要的特征；&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/zk%E5%85%A8%E5%B1%80%E4%B8%80%E8%87%B4%E6%80%A7.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可靠性&lt;/strong&gt;：如果消息【&lt;strong&gt;增、删、改、查&lt;/strong&gt;】被其中一台服务器接受，那么将被所有的服务器接受。&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/zk%E5%8F%AF%E9%9D%A0%E6%80%A7.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;顺序性&lt;/strong&gt;：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息 a 在消息 b 前发布，则在所有 &lt;code&gt;Server&lt;/code&gt; 上消息 a 都将在消息 b 前被发布；偏序是指如果一个消息 b 在消息 a 后被同一个发送者发布，a 必将排在 b 前面。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据更新原子性&lt;/strong&gt;：一次数据更新要么成功（半数以上节点成功），要么失败，不存在中间状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实时性&lt;/strong&gt;：&lt;code&gt;Zookeeper&lt;/code&gt; 保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;zookeeper-数据模型&#34;&gt;ZooKeeper 数据模型&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;ZooKeeper&lt;/code&gt; 的数据模型，在结构上和标准文件系统的非常相似，拥有一个层次的命名空间，都是采用&lt;strong&gt;树形层次结构&lt;/strong&gt;，&lt;code&gt;ZooKeeper&lt;/code&gt; 树中的每个节点被称为— &lt;strong&gt;&lt;code&gt;Znode&lt;/code&gt;&lt;/strong&gt;。和文件系统的目录树一样，&lt;code&gt;ZooKeeper&lt;/code&gt; 树中的每个节点可以拥有子节点。但也有不同之处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Znode&lt;/code&gt; 兼具文件和目录两种特点&lt;/strong&gt;。既像文件一样维护着数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分，并可以具有子 &lt;code&gt;Znode&lt;/code&gt;。用户对 &lt;code&gt;Znode&lt;/code&gt; 具有增、删、改、查等操作（权限允许的情况下）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Znode&lt;/code&gt; 具有原子性操作&lt;/strong&gt;，读操作将获取与节点相关的所有数据，写操作也将替换掉节点的所有数据。另外，每一个节点都拥有自己的 ACL(访问控制列表)，这个列表规定了用户的权限，即限定了特定用户对目标节点可以执行的操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Znode&lt;/code&gt; 存储数据大小有限制&lt;/strong&gt;。&lt;code&gt;ZooKeeper&lt;/code&gt; 虽然可以关联一些数据，但并没有被设计为常规的数据库或者大数据存储，相反的是，它用来管理调度数据，比如分布式应用中的配置文件信息、状态信息、汇集位置等等。这些数据的共同特性就是它们都是很小的数据，&lt;strong&gt;通常以 KB 为大小单位&lt;/strong&gt;。ZooKeeper 的服务器和客户端都被设计为严格检查并限制每个 Znode 的数据大小至多 1M，当时常规使用中应该远小于此值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Znode&lt;/code&gt; 通过路径引用&lt;/strong&gt;，如同 &lt;code&gt;Unix&lt;/code&gt; 中的文件路径。&lt;strong&gt;路径必须是绝对的&lt;/strong&gt;，因此他们必须&lt;strong&gt;由斜杠字符来开头&lt;/strong&gt;。除此以外，他们必须是唯一的，也就是说每一个路径只有一个表示，因此这些路径不能改变。在 &lt;code&gt;ZooKeeper&lt;/code&gt; 中，路径由 &lt;code&gt;Unicode&lt;/code&gt; 字符串组成，并且有一些限制。字符串&amp;quot;/zookeeper&amp;quot;用以保存管理信息，比如关键配额信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数据结构图&#34;&gt;数据结构图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/1584240732240.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
图中的每个节点称为一个 &lt;code&gt;Znode&lt;/code&gt;。 每个 &lt;code&gt;Znode&lt;/code&gt; 由 3 部分组成:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stat&lt;/code&gt;：此为状态信息, 描述该 &lt;code&gt;Znode&lt;/code&gt; 的版本, 权限等信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data&lt;/code&gt;：与该 &lt;code&gt;Znode&lt;/code&gt; 关联的数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;children&lt;/code&gt;：该 &lt;code&gt;Znode&lt;/code&gt; 下的子节点&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;节点类型&#34;&gt;节点类型&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Znode&lt;/code&gt; 有两种，分别为&lt;strong&gt;临时节点&lt;/strong&gt;和&lt;strong&gt;永久节点&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;节点的类型&lt;strong&gt;在创建时即被确定，并且不能改变。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;临时节点&lt;/strong&gt;：该节点的生命周期依赖于创建它们的会话。一旦&lt;strong&gt;会话结束，临时节点将被自动删除&lt;/strong&gt;，当然可以也可以手动删除。&lt;strong&gt;临时节点不允许拥有子节点&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;永久节点&lt;/strong&gt;：该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，他们才能被删除。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Znode&lt;/code&gt; 还有一个&lt;strong&gt;序列化&lt;/strong&gt;的特性，如果创建的时候指定的话，该 &lt;code&gt;Znode&lt;/code&gt; 的名字后面会&lt;strong&gt;自动追加一个不断增加的序列号&lt;/strong&gt;。序列号对于此节点的父节点来说是唯一的，这样便会&lt;strong&gt;记录每个子节点创建的先后顺序&lt;/strong&gt;。它的格式为“%10d”(10 位数字，没有数值的数位用 0 补充，例如“0000000001”)。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/1584240804281.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这样便会存在四种类型的 &lt;code&gt;Znode&lt;/code&gt; 节点，分别对应：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PERSISTENT&lt;/code&gt;：永久节点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EPHEMERAL&lt;/code&gt;：临时节点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PERSISTENT_SEQUENTIAL&lt;/code&gt;：永久节点、序列化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EPHEMERAL_SEQUENTIAL&lt;/code&gt;：临时节点、序列化&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;zookeeper-watcher&#34;&gt;ZooKeeper Watcher&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;ZooKeeper&lt;/code&gt; 提供了分布式数据&lt;strong&gt;发布/订阅功能&lt;/strong&gt;，一个典型的发布/订阅模型系统定义了一种一对多的订阅关系，能让多个订阅者同时监听某一个主题对象，当这个主题对象自身状态变化时，会通知所有订阅者，使他们能够做出相应的处理。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ZooKeeper&lt;/code&gt; 中，引入了 &lt;strong&gt;Watcher 机制来实现这种分布式的通知功能&lt;/strong&gt; 。 &lt;code&gt;ZooKeeper&lt;/code&gt; 允许客户端向服务端注册一个 &lt;code&gt;Watcher&lt;/code&gt; 监听，当服务端的一些事件触发了这个 &lt;code&gt;Watcher&lt;/code&gt;，那么就会向指定客户端发送一个事件通知来实现分布式的通知功能。&lt;/p&gt;
&lt;p&gt;触发事件种类很多，如：节点创建，节点删除，节点改变，子节点改变等。&lt;/p&gt;
&lt;p&gt;总的来说可以概括 &lt;code&gt;Watcher&lt;/code&gt; 为以下三个过程：&lt;strong&gt;客户端向服务端注册 &lt;code&gt;Watcher&lt;/code&gt;、服务端事件发生触发 &lt;code&gt;Watcher&lt;/code&gt;、客户端回调 &lt;code&gt;Watcher&lt;/code&gt; 得到触发事件情况&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;watch-机制特点&#34;&gt;Watch 机制特点&lt;/h2&gt;
&lt;h3 id=&#34;一次性触发&#34;&gt;一次性触发&lt;/h3&gt;
&lt;p&gt;事件发生触发监听，一个 &lt;code&gt;watcher event&lt;/code&gt; 就会被发送到设置监听的客户端，这种效果是一次性的，后续再次发生同样的事件，不会再次触发。&lt;/p&gt;
&lt;h3 id=&#34;事件封装&#34;&gt;事件封装&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ZooKeeper&lt;/code&gt; 使用 &lt;code&gt;WatchedEvent&lt;/code&gt; 对象来封装服务端事件并传递。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WatchedEvent&lt;/code&gt; 包含了每一个事件的三个基本属性：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通知状态（&lt;code&gt;keeperState&lt;/code&gt;），事件类型（&lt;code&gt;EventType&lt;/code&gt;）和节点路径（&lt;code&gt;path&lt;/code&gt;）&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;event-异步发送&#34;&gt;event 异步发送&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;watcher&lt;/code&gt; 的通知事件从服务端发送到客户端是异步的。&lt;/p&gt;
&lt;h3 id=&#34;先注册再触发&#34;&gt;先注册再触发&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Zookeeper&lt;/code&gt; 中的 &lt;code&gt;watch&lt;/code&gt; 机制，必须客户端先去服务端注册监听，这样事件发送才会触发监听，通知给客户端。&lt;/p&gt;
&lt;h1 id=&#34;zookeeper-选举机制&#34;&gt;ZooKeeper 选举机制&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;zookeeper&lt;/code&gt; 默认的算法是 &lt;code&gt;FastLeaderElection&lt;/code&gt;，采用投票数大于半数则胜出的逻辑。&lt;/p&gt;
&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;
&lt;h3 id=&#34;服务器-id&#34;&gt;服务器 ID&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;比如有三台服务器，编号分别是 1,2,3。&lt;/li&gt;
&lt;li&gt;编号越大在选择算法中的权重越大。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;选举状态&#34;&gt;选举状态&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LOOKING&lt;/code&gt;，竞选状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FOLLOWING&lt;/code&gt;，随从状态，同步 &lt;code&gt;leader&lt;/code&gt; 状态，参与投票。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OBSERVING&lt;/code&gt;，观察状态,同步 &lt;code&gt;leader&lt;/code&gt; 状态，不参与投票。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LEADING&lt;/code&gt;，领导者状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据-id&#34;&gt;数据 ID&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;服务器中存放的最新数据 &lt;code&gt;version&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;值越大说明数据越新，在选举算法中数据越新权重越大。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;逻辑时钟&#34;&gt;逻辑时钟&lt;/h3&gt;
&lt;p&gt;也叫投票的次数，同一轮投票过程中的逻辑时钟值是相同的。每投完一次票这个数据就会增加，然后与接收到的其它服务器返回的投票信息中的数值相比，根据不同的值做出不同的判断。&lt;/p&gt;
&lt;h2 id=&#34;全新集群选举&#34;&gt;全新集群选举&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/1584240883089.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;假设目前有 5 台服务器，&lt;strong&gt;每台服务器均没有数据&lt;/strong&gt;，它们的编号分别是1,2,3,4,5,&lt;strong&gt;按编号依次启动&lt;/strong&gt;，它们的选择举过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器 1 启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器 1 的状态一直属于 &lt;code&gt;Looking&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;服务器 2 启动，给自己投票，同时与之前启动的服务器 1 交换结果，由于服务器 2 的编号大所以服务器 2 胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是 &lt;code&gt;LOOKING&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;服务器 3 启动，给自己投票，同时与之前启动的服务器 1,2 交换信息，由于服务器 3 的编号最大所以服务器 3 胜出，此时投票数正好大于半数，所以服务器 3 成为领导者，服务器 1,2 成为小弟。&lt;/li&gt;
&lt;li&gt;服务器 4 启动，给自己投票，同时与之前启动的服务器 1,2,3 交换信息，尽管服务器 4 的编号大，但之前服务器 3 已经胜出，所以服务器 4 只能成为小弟。&lt;/li&gt;
&lt;li&gt;服务器 5 启动，后面的逻辑同服务器 4 成为小弟。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;非全新集群选举&#34;&gt;非全新集群选举&lt;/h2&gt;
&lt;p&gt;对于运行正常的 &lt;code&gt;zookeeper&lt;/code&gt; 集群，中途有机器 &lt;code&gt;down&lt;/code&gt; 掉，需要重新选举时，选举过程就需要加入&lt;strong&gt;数据 ID&lt;/strong&gt;、&lt;strong&gt;服务器 ID&lt;/strong&gt; 和&lt;strong&gt;逻辑时钟&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;数据 ID：数据新的 &lt;code&gt;version&lt;/code&gt; 就大，数据每次更新都会更新 &lt;code&gt;version&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;服务器 ID：就是我们配置的 &lt;code&gt;myid&lt;/code&gt; 中的值，每个机器一个。&lt;/p&gt;
&lt;p&gt;逻辑时钟：这个值从 0 开始递增,每次选举对应一个值。 如果在同一次选举中,这个值是一致的。&lt;/p&gt;
&lt;p&gt;这样选举的标准就变成：&lt;/p&gt;
&lt;p&gt;1、逻辑时钟小的选举结果被忽略，重新投票；&lt;/p&gt;
&lt;p&gt;2、统一逻辑时钟后，数据 id 大的胜出；&lt;/p&gt;
&lt;p&gt;3、数据 id 相同的情况下，服务器 id 大的胜出；根据这个规则选出 &lt;code&gt;leader&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&#34;zookeeper-典型应用&#34;&gt;ZooKeeper 典型应用&lt;/h1&gt;
&lt;h2 id=&#34;数据发布与订阅配置中心&#34;&gt;数据发布与订阅（配置中心）&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/1584241030128.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;发布与订阅模型，即所谓的配置中心，顾名思义就是&lt;strong&gt;发布者将数据发布到 ZK节点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;应用在启动的时候会主动来获取一次配置，同时，在节点上注册一个 &lt;code&gt;Watcher&lt;/code&gt;，这样一来，以后每次配置有更新的时候，都会实时通知到订阅的客户端，从来达到获取最新配置信息的目的。比如：&lt;/p&gt;
&lt;p&gt;分布式搜索服务中，索引的元信息和服务器集群机器的节点状态存放在 ZK 的一些指定节点，供各个客户端订阅使用。&lt;/p&gt;
&lt;p&gt;注意：适合&lt;strong&gt;数据量很小的场景&lt;/strong&gt;，这样数据更新可能会比较快。&lt;/p&gt;
&lt;h2 id=&#34;命名服务naming-service&#34;&gt;命名服务(Naming Service)&lt;/h2&gt;
&lt;p&gt;在分布式系统中，&lt;strong&gt;通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息&lt;/strong&gt;。被命名的实体通常可以是集群中的机器，提供的服务地址，远程对象等等——这些我们都可以统称他们为名字（Name）。其中较为常见的就是一些分布式服务框架中的服务地址列表。通过&lt;strong&gt;调用 ZK 提供的创建节点的 API&lt;/strong&gt;，能够很容易创建一个&lt;strong&gt;全局唯一的 path&lt;/strong&gt;，这个 path 就可以作为一个名称。&lt;/p&gt;
&lt;p&gt;阿里巴巴集团开源的分布式服务框架 &lt;strong&gt;Dubbo 中使用 ZooKeeper 来作为其命名服务&lt;/strong&gt;，维护全局的服务地址列表。&lt;/p&gt;
&lt;h2 id=&#34;分布式锁&#34;&gt;分布式锁&lt;/h2&gt;
&lt;p&gt;分布式锁，这个主要得益于 &lt;code&gt;ZooKeeper&lt;/code&gt; 保证了数据的强一致性。锁服务可以分为两类，一个是&lt;strong&gt;保持独占&lt;/strong&gt;，另一个是&lt;strong&gt;控制时序&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/1584241059824.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;所谓&lt;strong&gt;保持独占&lt;/strong&gt;，就是所有试图来获取这个锁的客户端，最终只有一个可以成功获得这把锁。通常的做法是把 zk 上的一个 &lt;code&gt;znode&lt;/code&gt; 看作是一把锁，通过 &lt;code&gt;create znode&lt;/code&gt; 的方式来实现。所有客户端都去创建 &lt;code&gt;/distribute_lock&lt;/code&gt; &lt;strong&gt;临时非序列化&lt;/strong&gt;节点，最终成功创建的那个客户端也即拥有了这把锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;控制时序&lt;/strong&gt;，就是所有试图来获取这个锁的客户端，最终都是会被安排执行，只是有个全局时序了。做法和上面基本类似，只是这里&lt;code&gt;/distribute_lock&lt;/code&gt; 已经预先存在，客户端在它下面创建&lt;strong&gt;临时有序&lt;/strong&gt;节点（这个可以通过节点的属性控制：&lt;code&gt;CreateMode.EPHEMERAL_SEQUENTIAL&lt;/code&gt; 来指定）。Zk 的父节点（&lt;code&gt;/distribute_lock&lt;/code&gt;）维持一份 &lt;code&gt;sequence&lt;/code&gt;,保证子节点创建的时序性，从而也形成了每个客户端的全局时序。&lt;/p&gt;
&lt;h1 id=&#34;zab-协议&#34;&gt;ZAB 协议？&lt;/h1&gt;
&lt;p&gt;ZAB 协议是为分布式协调服务 Zookeeper 专门设计的一种支持崩溃恢复的原子广播协议。&lt;br&gt;
ZAB 协议包括两种基本的模式：&lt;strong&gt;崩溃恢复&lt;/strong&gt;和&lt;strong&gt;消息广播&lt;/strong&gt;。&lt;br&gt;
当整个 zookeeper 集群刚刚启动或者 Leader 服务器宕机、重启或者网络故障导致不存在过半的服务器与 Leader 服务器保持正常通信时，所有进程（服务器）进入崩溃恢复模式，首先选举产生新的 Leader 服务器，然后集群中 Follower 服务器开始与新的 Leader 服务器进行数据同步，当集群中超过半数机器与该 Leader服务器完成数据同步之后，退出恢复模式进入消息广播模式，Leader 服务器开始接收客户端的事务请求生成事物提案来进行事务请求处理。&lt;/p&gt;
&lt;h1 id=&#34;cap-定理&#34;&gt;CAP 定理？&lt;/h1&gt;
&lt;p&gt;一个分布式系统不可能同时满足以下三种,&lt;strong&gt;一致性&lt;/strong&gt;（C:Consistency）,&lt;strong&gt;可用性&lt;/strong&gt;（A:Available）,&lt;strong&gt;分区容错性&lt;/strong&gt;（P:Partition Tolerance）.在此ZooKeeper保证的是CP，ZooKeeper不能保证每次服务请求的可用性，在极端环境下，ZooKeeper可能会丢弃一些请求，消费者程序需要重新请求才能获得结果。另外在进行leader选举时集群都是不可用，所以说，ZooKeeper不能保证服务可用性。（Base理论CA强一致性和最终一致性）&lt;/p&gt;
">面试题系列 —— Zookeeper</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/gridea-jian-ce-yuan-cheng-lian-jie-shi-bai/"" data-c="
          &lt;h1 id=&#34;问题一&#34;&gt;问题一&lt;/h1&gt;
&lt;h3 id=&#34;我的环境&#34;&gt;我的环境&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;操作系统&lt;/td&gt;
&lt;td&gt;Windows10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;软件版本&lt;/td&gt;
&lt;td&gt;0.9.1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主题名称&lt;/td&gt;
&lt;td&gt;Notes&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;问题描述&#34;&gt;问题描述&lt;/h2&gt;
&lt;p&gt;根据教程设置好一系列信息，经测试域名可访问，并且确保其他信息均正确&lt;/p&gt;
&lt;p&gt;检查远程连接错误：&lt;strong&gt;远程连接失败,请检查仓库、用户名和 token 设置&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;问题分析&#34;&gt;问题分析&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;先查看 &lt;code&gt;Gridea&lt;/code&gt; 文件存储目录：C:\Users\Only\Documents\Gridea\output.git 下的 config 文件，看是否有 [remote &amp;quot;origin&amp;quot;] 信息，如果没有自行添加&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;[remote &amp;quot;origin&amp;quot;]
	url = https://你的github用户名:Token@github.com/你的github用户/仓库名
	fetch = +refs/heads/*:refs/remotes/origin/*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;附：查看&lt;code&gt;Gridea&lt;/code&gt;文件存储目录&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/1582604204611.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;检查错误信息：&lt;br&gt;
&lt;img src=&#34;https://epitomm.github.io/post-images/1582041933549.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;[&lt;em&gt;&amp;quot;fatal: unable to access &#39;https://github.com/Epitom…led to connect to github.com port 443: Timed out↵&amp;quot;&lt;/em&gt;]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;问题解决&#34;&gt;问题解决&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;谷歌 433 错误，得知是&lt;strong&gt;没有设置代理服务器&lt;/strong&gt;的原因。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以下为网上一高赞解决方式，可自行尝试，（不过对我的问题无效果）&lt;br&gt;
参考链接：&lt;a href=&#34;https://blog.csdn.net/runningman2012/article/details/54633677&#34;&gt;https://blog.csdn.net/runningman2012/article/details/54633677&lt;/a&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/1582604339501.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;再次谷歌 git 如何设置代理服务器&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git config --global http.proxy &#39;socks5://127.0.0.1:1080&#39;

git config --global https.proxy &#39;socks5://127.0.0.1:1080&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考：&lt;a href=&#34;https://blog.csdn.net/isea533/article/details/84748009&#34;&gt;https://blog.csdn.net/isea533/article/details/84748009&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;再次尝试检测远程连接成功&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来同步查看效果完成后就可以开启开心的写作之旅啦~&lt;/p&gt;
&lt;h1 id=&#34;问题二&#34;&gt;问题二&lt;/h1&gt;
&lt;h3 id=&#34;我的环境-2&#34;&gt;我的环境&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;操作系统&lt;/td&gt;
&lt;td&gt;Windows10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;软件版本&lt;/td&gt;
&lt;td&gt;0.9.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主题名称&lt;/td&gt;
&lt;td&gt;Notes&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;问题描述-2&#34;&gt;问题描述&lt;/h2&gt;
&lt;p&gt;版本更新到 0.9.2 后重新安装了 Gridea ，再次检测远程连接失败&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/1582604400732.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;错误信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;connect ETIMEDOUT 140.82.114.4:443
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;问题分析-2&#34;&gt;问题分析&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;cmd 命令行 ping github.com 失败。代理问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;问题解决-2&#34;&gt;问题解决&lt;/h2&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;使用 ping 检测工具找一个能够 ping 通 github.com 的 IP，检测工具网址如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://ping.chinaz.com/github.com&#34;&gt;http://ping.chinaz.com/github.com&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/1582041969896.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;选择一个响应较快的 IP，添加到 C:\Windows\System32\drivers\etc\host 文件末尾：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://epitomm.github.io/post-images/1582041983918.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;140.82.113.3 github.com
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;再次检测远程连接，成功。&lt;/li&gt;
&lt;/ol&gt;
">Gridea 检测远程连接失败</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://epitomm.github.io/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;p&gt;本站是使用 &lt;code&gt;Gridea&lt;/code&gt; 搭建的博客。&lt;/p&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;p&gt;博主是一个&lt;strong&gt;热情耐心&lt;/strong&gt;，目前正准备找工作的老学姐呀，如果有志同道合想要一起学习的小伙伴，欢迎联系我一起学习进步呀；如果有对前路迷茫不知所措的学弟学妹，也欢迎联系我把我学习的经验传授给你们，不敢说做你们的指路明灯，但至少会让你们坚定信心、不再不知所措；如果有问题想向我请教，也欢迎随时来找我呀，我是真的帮助很多人解决过各种&lt;code&gt;bug&lt;/code&gt; 的。&lt;/p&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;tencent://AddContact/?fromId=45&amp;amp;fromSubId=1&amp;amp;subcmd=all&amp;amp;uin=985317010&amp;amp;website=www.oicqzone.com&#34;&gt;QQ&lt;/a&gt;&lt;br&gt;
邮箱：985317010@qq.com&lt;/p&gt;
">关于</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        console.log('复制操作频率过高');
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>


<script src="/media/js/mouse/love.js"></script>


</html>