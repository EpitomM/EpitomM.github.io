<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>dubbo | SSM</title>
<link rel="shortcut icon" href="https://epitomm.github.io/favicon.ico?v=1588651782671">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://epitomm.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="dubbo | SSM - Atom Feed" href="https://epitomm.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="一、基础知识
1、分布式基础理论
1.1）、什么是分布式系统？
《分布式系统原理与范型》定义：
“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”
分布式系统（distributed system）是建立在网络之上..." />
    <meta name="keywords" content="dubbo" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://epitomm.github.io">
  <img class="avatar" src="https://epitomm.github.io/images/avatar.png?v=1588651782671" alt="">
  </a>
  <h1 class="site-title">
    SSM
  </h1>
  <p class="site-description">
    热心善良的老学姐
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              dubbo
            </h2>
            <div class="post-info">
              <span>
                2020-04-10
              </span>
              <span>
                59 min read
              </span>
              
                <a href="https://epitomm.github.io/tag/AivfZDvn2/" class="post-tag">
                  # dubbo
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://epitomm.github.io/post-images/dubbo.png" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="一-基础知识">一、基础知识</h1>
<h2 id="1-分布式基础理论">1、分布式基础理论</h2>
<h3 id="11-什么是分布式系统">1.1）、什么是分布式系统？</h3>
<p>《分布式系统原理与范型》定义：</p>
<p>“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”</p>
<p>分布式系统（distributed system）是建立在网络之上的软件系统。</p>
<p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需<strong>一个治理系统</strong>确保架构有条不紊的演进。</p>
<h3 id="12-发展演变">1.2）、发展演变</h3>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E6%BC%94%E5%8F%98.png" alt="图片" loading="lazy"></figure>
<p><em>单一应用架构</em></p>
<p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。<br>
<img src="https://epitomm.github.io/post-images/%E5%8D%95%E4%B8%80%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84.png" alt="图片" loading="lazy"></p>
<pre><code>适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。

缺点： 1、性能扩展比较难 （如果修改或添加某个功能，都需要把整个应用重新打包，重新放部署到 服务器）

       2、协同开发问题（所有人都去修改一个应用，容易乱）

       3、不利于升级维护
</code></pre>
<blockquote>
<p>将多个功能放到一个应用内，打包后放到服务器上即可。访问量增大，一个服务器无法承受时，再添加一个服务器同时跑这个应用。</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E5%8D%95%E4%B8%80%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%842.png" alt="图片" loading="lazy"></figure>
<p><em>垂直应用架构</em></p>
<p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E5%9E%82%E7%9B%B4%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84.png" alt="图片" loading="lazy"></figure>
<pre><code>通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。

缺点： 公用模块无法重复利用，开发性的浪费
</code></pre>
<blockquote>
<p>将一个大应用拆分成几个独立的小应用，每一个应用都是从头到尾完成的（从页面到业务逻辑程序到数据库）。</p>
</blockquote>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E5%9E%82%E7%9B%B4%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%842.png" alt="图片" loading="lazy"></figure>
<p>垂直应用架构</p>
<blockquote>
<p>当某一块应用的访问量比较大时，将这个应用多扩展几个服务器。</p>
</blockquote>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/%E5%9E%82%E7%9B%B4%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%843.png" alt="图片" loading="lazy"></figure>
<p>扩展某个小应用即可</p>
<blockquote>
<p>好处：1）分工合作容易，每个人负责开发维护不同的应用，互不干扰。<br>
2）性能扩展容易，比如“用户”应用的访问量增大， 就把它多放几台服务器，扩展的是某个小应用，其他小应用无需变动。<br>
缺点：1）由于每个小应用都是完整的（界面+业务逻辑+数据库），但是界面要求经常变化，每个界面的变化都会导致应用的重新部署。无法做到页面 和 业务逻辑 的分离<br>
2） 随着应用的逐步增多，垂直应用会越来越多，这样的情况下，不可能理想的应用和应用之间互相独立，订单模块需要用户模块和商品模块信息，应用之间交互，不可能完全独立。</p>
</blockquote>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E5%9E%82%E7%9B%B4%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%844.png" alt="图片" loading="lazy"></figure>
<p>界面与业务逻辑无法分离，各个应用间需要交互</p>
<p><em>分布式服务架构</em></p>
<p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的<strong>分布式服务框架(RPC)是关键</strong>。</p>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%841.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>将用户抽取成“用户界面” 和 “用户业务”，订单抽取成 “订单界面” 和 “订单业务” 等。<br>
当业务逻辑不变的情况下，如果只想修改界面，重启界面服务器即可，核心业务逻辑还在其他服务器上，无需变动。<br>
<img src="https://epitomm.github.io/post-images/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%842.png" alt="图片" loading="lazy"></p>
</blockquote>
<blockquote>
<p>用户界面放在 A 服务器上，用户业务放在 B 服务器上，订单业务放在 C 服务器上，如果 A 服务器（用户界面）需要调用 B 服务器（用户业务）的功能。如果写在一个应用内，A 调用 B，直接“方法 A . 方法 B” 即可，直接调用，进程类通讯，都在一个服务器上，都是同一个 tomcat，同一个进程类通讯。但如果是分布式服务架构，A 和 B 在两台服务器上，这样的不同服务器间的互相调用称为 RPC（远程过程调用）。分布式服务架构的难点：如何进行远程过程调用，如果拆分应用，提升业务的复用程度。<br>
随着业务的不断增多，分拆的业务越来越多，成千上万的服务器在跑不同的服务，出现的资源浪费问题愈加严重，比如用户业务访问量较小，但却有 100 台服务器在跑，就造成了浪费；而 商品业务 访问量很大，但却只有 10 台服务器在跑。应该有一个基于访问压力的调度中心能够实时监控数据动态调度，提高资源利用率，让更多的服务器去跑业务量更大的业务。</p>
</blockquote>
<p><em>流动计算架构</em></p>
<p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于<strong>提高机器利用率的资源调度和治理中心(SOA)[ Service Oriented Architecture]是关键</strong>。</p>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/%E6%B5%81%E5%8A%A8%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>采用流动计算架构，引入调度中心，负责维护服务间的复杂关系，实时管理集群，比如 A 服务器访问量大了，给 A 多增加几台服务器，假设 第一台 有 100 个请求，第二台 有 2 个请求，第三台有 10000 个请求，那么下次请求进来，就应该找比较闲的第二台服务器来处理请求，以此提高整个集群利用率。</p>
</blockquote>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/%E6%B5%81%E5%8A%A8%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%842.png" alt="图片" loading="lazy"></figure>
<p>流动计算架构</p>
<h3 id="13-rpc">1.3）、RPC</h3>
<p><em>什么叫RPC</em></p>
<p>RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</p>
<p><em>RPC基本原理</em></p>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/RPC%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>需求：A 服务器客户端（client）有一个小功能，想要调用 B 服务器的一个小功能。<br>
实现：A 服务器客户端（client）先找一个小助手（client stub），这个小助手一看，A 服务器想要调用 B 服务器上的功能，先跟 B 服务器在网络上建立一个 sockets 连接，将要调用 B 的一些信息（比如要调用 B 的某个方法的方法名、参数）传递给 B 模型，B 服务器上的小助手（server stub）收到这些信息，知道了 A 服务器想要调用 我的一个方法，执行这个方法后，将返回值依次传回 A 客户端。</p>
</blockquote>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/RPC%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%862.png" alt="图片" loading="lazy"></figure>
<p>RPC两个核心模块：通讯，序列化。</p>
<p>RPC 框架有很多如：dubbo、gRPC、Thrift、HSF(High Speed Service Framework)</p>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/RPC%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%863.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>A 服务器上有一个 hello()方法，想要调用 B 服务器上的 hi() 方法，同时传入一个 User  对象，B 服务器上的 hi() 方法执行完了以后，返回一个 String 给 A 服务器，A服务器调完 B服务器的方法后，收到 B 服务器的返回值并在控制台打印。<br>
调用过程：A 服务器客户端（Client） 想要 调用 B 服务器的代码，A 服务器上有一个小助手（Client Stub）这个小助手一看 A 服务器 要调用 B 服务器，先与 B 服务器建议连接，建立连接后，由于调用方法要传递参数，这个参数要发给 B 服务器，参数对象要在网络间传递需要先序列化 ，序列化后将要调用的信息传递给 B 服务器的小助手（Server Stub），B 服务器的小助手收到信息，一看有来自外界的 A 服务器想要调用我的 hi() 方法，同时还传递来了一个参数值，由于是序列化传递过来的，如果使用则需反序列化成对象，B服务器上的小助手调用 B 服务器上的方法，拿到反序列化的对象、一些属性值，方法调用完就会有一个返回值，返回值过来要在网络间传递数据，将返回的 String 对象序列化传递给 A 服务器的小助手，Client Stub 收到后再反序列化，输出。<br>
整个过程两个核心：建立连接、传递数据（序列化和反序列化）。所以，影响一个 RPC 框架性能的重要两点：能否快速地在各个服务器间建立连接；序列化/反序列化机制的速度。</p>
</blockquote>
<h2 id="2-dubbo核心概念">2、dubbo核心概念</h2>
<h3 id="21-简介">2.1）、简介</h3>
<p>Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p>
<p>官网：</p>
<p><a href="http://dubbo.apache.org/zh-cn/">http://dubbo.apache.org/zh-cn/</a></p>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/dubbo%E7%89%B9%E6%80%A7.png" alt="图片" loading="lazy"></figure>
<ol>
<li><strong>面向接口代理的高性能 RPC 调用</strong></li>
</ol>
<p>使用 dubbo 时，A 服务器 要调用 B 服务器上的代码，只需将 B 功能方法的接口 InterfaceB拿过来，调用接口所在的方法 InterfaceB.fun()，就会自动去找服务器 B 上的代码代码调用，屏蔽了远程的调用细节。类似在用 Mybatis ，操作数据库时，只需要写一个 mapper 接口，调用接口的方法即可。</p>
<ol start="2">
<li><strong>智能负载均衡</strong></li>
</ol>
<p>比如用户业务访问量很大，就需要多放几台服务器，“用户界面” 想要调用 “用户业务” 的功能，调用 “用户业务” 的哪一台服务器都可以，假设 第一台用户业务服务器当前有 100 个请求， 第二台用户业务服务器当前有 2 个请求， 第三台用户业务服务器当前有 1000 个请求， 第四台用户业务服务器当前有 10 个请求，就应该找一个非常空闲的服务器快速处理这次响应，这个机制就叫做<strong>负载均衡</strong>，让每个服务器都有一个很均衡的负载，不要让某一台服务器做太多的响应，把它压垮，也不要让某一台服务器太闲，资源浪费。</p>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/%E6%99%BA%E8%83%BD%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png" alt="图片" loading="lazy"></figure>
<ol start="3">
<li><strong>服务自动注册与发现</strong></li>
</ol>
<p>想象这样一个场景：业务非常多，每一块的访问量都特别大，比如用户业务在 1、2、3、4 号服务器都有，支付业务在 9、11、13 号服务器都有，那么 订单web 想要调用支付业务，RPC 框架爱如何知道支付业务都在哪些服务器上呢？如果 11 号服务器出问题了，框架如何自动地知道这个事呢？引入<strong>注册中心</strong>机制。</p>
<p>为了能动态感知到每一个服务，可以将所有的服务都注册到注册中心，包括前端程序也可以都注册到注册中心内，注册中心相当于维护了一个 “业务 - 服务器” 清单，比如：用户业务：1、2、3、4 号服务器，如果 2 号服务器出问题了，就把它从清单中删掉。如果 订单web 要调用支付业务，先到注册中心的清单内找支付业务都在哪一台服务器上，然后随机选择或者选择请求量最少的一台服务器进行访问。</p>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.png" alt="图片" loading="lazy"></figure>
<ol start="4">
<li><strong>高度可扩展</strong></li>
</ol>
<p>微内核 + 插件</p>
<ol start="5">
<li><strong>运行期流量调度</strong></li>
</ol>
<p>内置条件、脚本等路由策略，通过配置不同的路由规则，轻松实现<strong>灰度发布</strong>，同机房优先等功能。</p>
<p>灰度发布：一个用户服务在 100 台服务器上跑，用户服务做了开发升级，先选定 20 台服务器，让它们先用新版本的服务，剩下的 80 台使用旧版本的服务，等这 20 台用着都没问题了，再选 20 台，这样逐步过渡，直到 100 台全用到新的用户服务。配置不同的路由规则，请求进来后，让一部分请求用新升级的服务，剩下的来用旧的服务，通过这种方式从旧服务转化成新服务的过程就叫做<strong>灰度发布</strong>。</p>
<ol start="6">
<li><strong>可视化的服务治理和运维</strong></li>
</ol>
<p>通过可视化的 WEB 界面动态查询服务的信息、调整一些参数。</p>
<h3 id="22-基本概念">2.2）、基本概念</h3>
<figure data-type="image" tabindex="16"><img src="https://epitomm.github.io/post-images/dubbo%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.png" alt="图片" loading="lazy"></figure>
<p><strong>服务提供者（Provider）</strong>：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</p>
<p><strong>服务消费者（Consumer）</strong>: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>
<p><strong>注册中心（Registry）</strong>：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</p>
<p><strong>监控中心（Monitor）</strong>：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p>
<p><strong>框架容器（Container</strong>）</p>
<ul>
<li>调用关系说明
<ul>
<li>服务容器负责启动，加载，运行服务提供者。</li>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。<br>
<img src="https://epitomm.github.io/post-images/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.png" alt="图片" loading="lazy"></li>
</ul>
</li>
</ul>
<p>用户业务是实际的业务功能，web 界面要去调用这些业务功能，所以，用户业务是一个服务提供者（Provider），而 web 界面是服务消费者（Consumer）</p>
<blockquote>
<p>运行流程：容器 Container 启动，初始化 init ，服务提供者 Provider 将自己提供的信息注册 register 到注册中心 Registry ，注册中心就知道有哪些服务上线了，当服务消费者 Consumer 启动，从注册中心订阅 subscribe 自己所需要的服务，如果服务提供者发生变更（3 号服务器下线了），注册中心将这次变更推送 notify 给消费者，消费者拿到所有它能调用的服务，调用的时候可以同步调用 invoke 服务提供者提供的服务，如果消费者要调用的服务有多台服务器在提供，消费者根据负载均衡算法选择一个进行调用。每次的调用信息会定时地每隔一分钟将信息发送到监控中心 Monitor，监控中心就能监控到服务的状态。<br>
0、1、2 这三步是在初始化、启动应用时完成的。<br>
3、5 是异步过程，<br>
4 服务消费者调用服务提供者提供的功能是一个同步的调用。<br>
了解了 dubbo 框架，在编写 dubbo 应用时：</p>
<ol>
<li>先写一个服务提供者，将服务提供者提供的服务注册到注册中心；</li>
<li>编写一个服务消费者，消费者从注册中心订阅提供者提供的服务；</li>
<li>测试消费者如何调用提供者提供的功能。</li>
</ol>
</blockquote>
<h2 id="3-dubbo环境搭建">3、dubbo环境搭建</h2>
<h3 id="31-windows-安装zookeeper">3.1）、【windows】-安装zookeeper</h3>
<table>
<thead>
<tr>
<th style="text-align:center">1、下载zookeeper网址 <a href="https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/">https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/</a></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2、解压zookeeper解压运行zkServer.cmd ，初次运行会报错，没有zoo.cfg配置文件</td>
</tr>
<tr>
<td style="text-align:center">3、修改zoo.cfg配置文件将conf下的zoo_sample.cfg复制一份改名为zoo.cfg即可。注意几个重要位置：dataDir=./   临时数据存储的目录（可写相对路径）clientPort=2181   zookeeper的端口号修改完成后再次启动zookeeper</td>
</tr>
<tr>
<td style="text-align:center">4、使用zkCli.cmd测试ls /：列出zookeeper根下保存的所有节点create –e /atguigu 123：创建一个atguigu节点，值为123get /atguigu：获取/atguigu节点的值</td>
</tr>
</tbody>
</table>
<p>注：记录一个小 bug</p>
<p>问题：【zookeeper】报错-Dzookeeper.log.dir=xxx&quot;' 不是内部或外部命令，也不是可运行的程序 或批处理文件的解决</p>
<p>解决：修改zkServer.cmd文件。将 call %JAVA% 改成 java</p>
<pre><code>java &quot;-Dzookeeper.log.dir=%ZOO_LOG_DIR%&quot; &quot;-Dzookeeper.root.logger=%ZOO_LOG4J_PROP%&quot; -cp &quot;%CLASSPATH%&quot; %ZOOMAIN% &quot;%ZOOCFG%&quot; %*
</code></pre>
<p>参考博客：<a href="https://blog.csdn.net/pangdongh/article/details/90208230">https://blog.csdn.net/pangdongh/article/details/90208230</a></p>
<h3 id="32-windows-安装dubbo-admin管理控制台">3.2）、【windows】-安装dubbo-admin管理控制台</h3>
<p>dubbo本身并不是一个服务软件。它其实就是一个jar包能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。所以你不用在Linux上启动什么dubbo服务。</p>
<p>但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序，不过这个监控即使不装也不影响使用。</p>
<p>1、下载dubbo-admin</p>
<p><a href="https://github.com/apache/incubator-dubbo-ops">https://github.com/apache/incubator-dubbo-ops</a></p>
<figure data-type="image" tabindex="17"><img src="https://epitomm.github.io/post-images/dubbo-admin%E4%B8%8B%E8%BD%BD.png" alt="图片" loading="lazy"></figure>
<p>2、进入目录，修改dubbo-admin配置</p>
<p>修改 src\main\resources\application.properties 指定zookeeper地址</p>
<figure data-type="image" tabindex="18"><img src="https://epitomm.github.io/post-images/dubbo-admin%E9%85%8D%E7%BD%AE.png" alt="图片" loading="lazy"></figure>
<p>3、打包dubbo-admin</p>
<pre><code>mvn clean package -Dmaven.test.skip=true 
</code></pre>
<p>4、运行dubbo-admin</p>
<pre><code>java -jar dubbo-admin-0.0.1-SNAPSHOT.jar
</code></pre>
<p><strong>注意：【有可能控制台看着启动了，但是网页打不开，需要在控制台按下ctrl+c即可】</strong></p>
<p>默认使用root/root 登陆</p>
<figure data-type="image" tabindex="19"><img src="https://epitomm.github.io/post-images/%E8%BF%90%E8%A1%8Cdubbo-admin.png" alt="图片" loading="lazy"></figure>
<h3 id="33-linux-安装zookeeper">3.3）、【linux】-安装zookeeper</h3>
<p><em>1、安装jdk</em></p>
<p>1、下载jdk</p>
<p><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p>
<figure data-type="image" tabindex="20"><img src="https://epitomm.github.io/post-images/%E4%B8%8B%E8%BD%BDjdk.png" alt="图片" loading="lazy"></figure>
<p>不要使用wget命令获取jdk链接，这是默认不同意，导致下载来的jdk压缩内容错误</p>
<p>2、上传到服务器并解压</p>
<figure data-type="image" tabindex="21"><img src="https://epitomm.github.io/post-images/jdk%E8%A7%A3%E5%8E%8B.png" alt="图片" loading="lazy"></figure>
<p>3、设置环境变量</p>
<pre><code>/usr/local/java/jdk1.8.0_171
</code></pre>
<figure data-type="image" tabindex="22"><img src="https://epitomm.github.io/post-images/%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" alt="图片" loading="lazy"></figure>
<p>文件末尾加入下面配置</p>
<pre><code>export JAVA_HOME=/usr/local/java/jdk1.8.0_171

export JRE_HOME=${JAVA_HOME}/jre

export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib

export PATH=${JAVA_HOME}/bin:$PATH
</code></pre>
<figure data-type="image" tabindex="23"><img src="https://epitomm.github.io/post-images/jdk%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F2.png" alt="图片" loading="lazy"></figure>
<p>4、使环境变量生效&amp;测试JDK</p>
<figure data-type="image" tabindex="24"><img src="https://epitomm.github.io/post-images/jdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%94%9F%E6%95%88.png" alt="图片" loading="lazy"></figure>
<p><em>2、安装zookeeper</em></p>
<p>1、下载zookeeper</p>
<p>网址 <a href="https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/">https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/</a></p>
<p>wget <a href="https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/zookeeper-3.4.11.tar.gz">https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/zookeeper-3.4.11.tar.gz</a></p>
<p>2、解压</p>
<figure data-type="image" tabindex="25"><img src="https://epitomm.github.io/post-images/%E8%A7%A3%E5%8E%8Bzk.png" alt="图片" loading="lazy"></figure>
<p>3、移动到指定位置并改名为zookeeper</p>
<figure data-type="image" tabindex="26"><img src="https://epitomm.github.io/post-images/zk%E7%A7%BB%E5%8A%A8%E5%91%BD%E5%90%8D.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="27"><img src="https://epitomm.github.io/post-images/zk%E6%9F%A5%E7%9C%8B%E7%9B%AE%E5%BD%95.png" alt="图片" loading="lazy"></figure>
<p><em>3、开机启动zookeeper</em></p>
<p>1）-复制如下脚本</p>
<pre><code>#!/bin/bash

#chkconfig:2345 20 90

#description:zookeeper

#processname:zookeeper

ZK_PATH=/usr/local/zookeeper

export JAVA_HOME=/usr/local/java/jdk1.8.0_171

case $1 in

         start) sh  $ZK_PATH/bin/zkServer.sh start;;

         stop)  sh  $ZK_PATH/bin/zkServer.sh stop;;

         status) sh  $ZK_PATH/bin/zkServer.sh status;;

         restart) sh $ZK_PATH/bin/zkServer.sh restart;;

         *)  echo &quot;require start|stop|status|restart&quot;  ;;

esac
</code></pre>
<figure data-type="image" tabindex="28"><img src="https://epitomm.github.io/post-images/%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8zk.png" alt="图片" loading="lazy"></figure>
<p>2）-把脚本注册为Service</p>
<figure data-type="image" tabindex="29"><img src="https://epitomm.github.io/post-images/%E8%84%9A%E6%9C%AC%E6%B3%A8%E5%86%8C%E4%B8%BAservice.png" alt="图片" loading="lazy"></figure>
<p>3）-增加权限</p>
<figure data-type="image" tabindex="30"><img src="https://epitomm.github.io/post-images/%E5%A2%9E%E5%8A%A0%E6%9D%83%E9%99%90.png" alt="图片" loading="lazy"></figure>
<p><em>4、配置zookeeper</em></p>
<p>1、初始化zookeeper配置文件</p>
<p>拷贝/usr/local/zookeeper/conf/zoo_sample.cfg</p>
<p>到同一个目录下改个名字叫zoo.cfg</p>
<figure data-type="image" tabindex="31"><img src="https://epitomm.github.io/post-images/%E5%88%9D%E5%A7%8B%E5%8C%96zk%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt="图片" loading="lazy"></figure>
<p>2、启动zookeeper</p>
<figure data-type="image" tabindex="32"><img src="https://epitomm.github.io/post-images/%E5%90%AF%E5%8A%A8zk.png" alt="图片" loading="lazy"></figure>
<h3 id="34-linux-安装dubbo-admin管理控制台">3.4）、【linux】-安装dubbo-admin管理控制台</h3>
<p><em>1、安装Tomcat8（旧版dubbo-admin是war，新版是jar不需要安装Tomcat）</em></p>
<p>1、下载Tomcat8并解压</p>
<p><a href="https://tomcat.apache.org/download-80.cgi">https://tomcat.apache.org/download-80.cgi</a></p>
<p>wget <a href="http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v8.5.32/bin/apache-tomcat-8.5.32.tar.gz">http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v8.5.32/bin/apache-tomcat-8.5.32.tar.gz</a></p>
<p>2、解压移动到指定位置</p>
<figure data-type="image" tabindex="33"><img src="https://epitomm.github.io/post-images/%E8%A7%A3%E5%8E%8Btomcat.png" alt="图片" loading="lazy"></figure>
<p>3、开机启动tomcat8</p>
<figure data-type="image" tabindex="34"><img src="https://epitomm.github.io/post-images/%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8tomcat.png" alt="图片" loading="lazy"></figure>
<p>复制如下脚本</p>
<pre><code>#!/bin/bash

#chkconfig:2345 21 90

#description:apache-tomcat-8

#processname:apache-tomcat-8

CATALANA_HOME=/opt/apache-tomcat-8.5.32

export JAVA_HOME=/opt/java/jdk1.8.0_171

case $1 in

start)

    echo &quot;Starting Tomcat...&quot;  

    $CATALANA_HOME/bin/startup.sh

    ;;

stop)

    echo &quot;Stopping Tomcat...&quot;  

    $CATALANA_HOME/bin/shutdown.sh

    ;;

restart)

    echo &quot;Stopping Tomcat...&quot;  

    $CATALANA_HOME/bin/shutdown.sh

    sleep 2

    echo  

    echo &quot;Starting Tomcat...&quot;  

    $CATALANA_HOME/bin/startup.sh

    ;;

*)

    echo &quot;Usage: tomcat {start|stop|restart}&quot;  

    ;; esac
</code></pre>
<p>4、注册服务&amp;添加权限</p>
<figure data-type="image" tabindex="35"><img src="https://uploader.shimo.im/f/sgrlw1jLRksvtDuA.png!thumbnail" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="36"><img src="https://uploader.shimo.im/f/yFBPAQA9wQcuLiLK.png!thumbnail" alt="图片" loading="lazy"></figure>
<p>5、启动服务&amp;访问tomcat测试</p>
<figure data-type="image" tabindex="37"><img src="https://uploader.shimo.im/f/PCItXvgg0c8lpyxk.png!thumbnail" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="38"><img src="https://uploader.shimo.im/f/UkCJSOTip08WixDn.png!thumbnail" alt="图片" loading="lazy"></figure>
<p><em>2、安装dubbo-admin</em></p>
<p>dubbo本身并不是一个服务软件。它其实就是一个jar包能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。所以你不用在Linux上启动什么dubbo服务。</p>
<p>但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序，不过这个监控即使不装也不影响使用。</p>
<p>1、下载dubbo-admin</p>
<p><a href="https://github.com/apache/incubator-dubbo-ops">https://github.com/apache/incubator-dubbo-ops</a></p>
<figure data-type="image" tabindex="39"><img src="https://uploader.shimo.im/f/NB3VdgOwTJUVLKd7.png!thumbnail" alt="图片" loading="lazy"></figure>
<p>2、进入目录，修改dubbo-admin配置</p>
<p>修改 src\main\resources\application.properties 指定zookeeper地址</p>
<figure data-type="image" tabindex="40"><img src="https://uploader.shimo.im/f/Ky405QqumK4BCVLb.png!thumbnail" alt="图片" loading="lazy"></figure>
<p>3、打包dubbo-admin</p>
<pre><code>mvn clean package -Dmaven.test.skip=true 
</code></pre>
<p>4、运行dubbo-admin</p>
<pre><code>java -jar dubbo-admin-0.0.1-SNAPSHOT.jar
</code></pre>
<p>默认使用root/root 登陆</p>
<figure data-type="image" tabindex="41"><img src="https://uploader.shimo.im/f/QwVB9l4fvmYkh6a2.png!thumbnail" alt="图片" loading="lazy"></figure>
<h2 id="4-dubbo-helloworld">4、dubbo-helloworld</h2>
<h3 id="41-提出需求">4.1）、提出需求</h3>
<p>某个电商系统，订单服务需要调用用户服务获取某个用户的所有地址；</p>
<p>我们现在 需要创建两个服务模块进行测试</p>
<table>
<thead>
<tr>
<th style="text-align:center">模块</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">订单服务web模块</td>
<td style="text-align:center">创建订单等</td>
</tr>
<tr>
<td style="text-align:center">用户服务service模块</td>
<td style="text-align:center">查询用户地址等</td>
</tr>
</tbody>
</table>
<p>测试预期结果：</p>
<p>订单服务web模块在A服务器，用户服务模块在B服务器，A可以远程调用B的功能。</p>
<figure data-type="image" tabindex="42"><img src="https://uploader.shimo.im/f/zu5t5nNfM7A5kcbM.png!thumbnail" alt="图片" loading="lazy"></figure>
<h3 id="42-工程架构">4.2）、工程架构</h3>
<p>根据 dubbo《服务化最佳实践》</p>
<p><em>1、分包</em></p>
<p>建议将服务接口，服务模型，服务异常等均放在 API 包中，因为服务模型及异常也是 API 的一部分，同时，这样做也符合分包原则：重用发布等价原则(REP)，共同重用原则(CRP)。</p>
<p>如果需要，也可以考虑在 API 包中放置一份 spring 的引用配置，这样使用方，只需在 spring 加载过程中引用此配置即可，配置建议放在模块的包目录下，以免冲突，如：com/alibaba/china/xxx/dubbo-reference.xml。</p>
<p><em>2、粒度</em></p>
<p>服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将面临分布式事务问题，Dubbo 暂未提供分布式事务支持。</p>
<p>服务接口建议以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。</p>
<p>不建议使用过于抽象的通用接口，如：Map query(Map)，这样的接口没有明确语义，会给后期维护带来不便。</p>
<figure data-type="image" tabindex="43"><img src="https://uploader.shimo.im/f/JGqDnycGLrAYNogH.png!thumbnail" alt="图片" loading="lazy"></figure>
<h3 id="43-创建模块">4.3）、创建模块</h3>
<p><em>1、gmall-interface：公共接口层（model，service，exception…）</em></p>
<p>作用：定义公共接口，也可以导入公共依赖</p>
<p>1、Bean模型</p>
<pre><code>public class UserAddress implements Serializable{
    private Integer id;
    private String userAddress;
    private String userId;
    private String consignee;
    private String phoneNum;
    private String isDefault;
    // getter、setter、Constructure、toString
}
</code></pre>
<p>2、Service接口<br>
UserService</p>
<pre><code>package com.atguigu.gmall.service;

import com.atguigu.gmall.bean.UserAddress;
import java.util.List;
// 用户服务
public interface UserService {
   /**
    * 按照用户id返回所有的收货地址
    * @param userId
    * @return
    */
   public List&lt;UserAddress&gt; getUserAddressList(String userId);
}
</code></pre>
<p>OrderService</p>
<pre><code>// 订单服务
public interface OrderService {
   /**
    * 初始化订单
    * @param userId
    */
   public void initOrder(String userId);
}
</code></pre>
<figure data-type="image" tabindex="44"><img src="https://uploader.shimo.im/f/wyNzvleAZIggOiT2.png!thumbnail" alt="图片" loading="lazy"></figure>
<p><em>2、gmall-user：用户模块（对用户接口的实现）</em></p>
<p>1、pom.xml</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.atguigu.gmall&lt;/groupId&gt;
        &lt;artifactId&gt;gmall-interface&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>2、Service</p>
<pre><code>public class UserServiceImpl implements UserService {
		
	@Override
	public List&lt;UserAddress&gt; getUserAddressList(String userId) {
		// TODO Auto-generated method stub
		return userAddressDao.getUserAddressById(userId);
	}
}
</code></pre>
<p><em>4、gmall-order-web：订单模块（调用用户模块）</em><br>
1、pom.xml</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.atguigu.gmall&lt;/groupId&gt;
        &lt;artifactId&gt;gmall-interface&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>2、测试</p>
<pre><code>public class OrderService {	
	UserService userService;	
	/**
	 * 初始化订单，查询用户的所有地址并返回
	 * @param userId
	 * @return
	 */
	public List&lt;UserAddress&gt; initOrder(String userId){
		return userService.getUserAddressList(userId);
	}
}
</code></pre>
<p>现在这样是无法进行调用的。我们gmall-order-web引入了gmall-interface，但是interface的实现是gmall-user，我们并没有引入，而且实际他可能还在别的服务器中。</p>
<h3 id="44-使用dubbo改造">4.4）、使用dubbo改造</h3>
<p><em>1、改造gmall-user作为服务提供者</em></p>
<p>1）导入 dubbo 依赖（2.6.2）、导入操作 zookeeper 的客户端（curator）</p>
<pre><code>		&lt;!-- 引入dubbo --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;com.alibaba&lt;/groupId&gt;
			&lt;artifactId&gt;dubbo&lt;/artifactId&gt;
			&lt;version&gt;2.6.2&lt;/version&gt;
		&lt;/dependency&gt;
	&lt;!-- 由于我们使用zookeeper作为注册中心，所以需要操作zookeeper
	dubbo 2.6以前的版本引入zkclient操作zookeeper 
	dubbo 2.6及以后的版本引入curator操作zookeeper
	下面两个zk客户端根据dubbo版本2选1即可
		&lt;dependency&gt;
			&lt;groupId&gt;com.101tec&lt;/groupId&gt;
			&lt;artifactId&gt;zkclient&lt;/artifactId&gt;
			&lt;version&gt;0.10&lt;/version&gt;
		&lt;/dependency&gt;
    --&gt;
		&lt;!-- curator-framework --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
			&lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
			&lt;version&gt;2.12.0&lt;/version&gt;
		&lt;/dependency&gt;
</code></pre>
<p>2）配置提供者</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd        http://dubbo.apache.org/schema/dubbo        http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;&gt;

    &lt;!-- 1.指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名） --&gt;
    &lt;dubbo:application name=&quot;user-service-provider&quot;  /&gt;

    &lt;!-- 2.指定注册中心的位置 --&gt;
    &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; /&gt;

    &lt;!-- 3.指定通信规则（通信协议、通信端口） --&gt;
    &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;

    &lt;!-- 4.暴露服务 ref：指向服务的真正实现对象--&gt;
    &lt;dubbo:service interface=&quot;com.atguigu.gmall.service.UserService&quot; ref=&quot;userServiceImpl&quot; /&gt;

    &lt;!-- 服务的实现  --&gt;
    &lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.atguigu.gmall.service.impl.UserServiceImpl&quot; /&gt;
&lt;/beans&gt;
</code></pre>
<p>3）启动服务</p>
<pre><code>package com.atguigu.gmall;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import java.io.IOException;
public class MainApplication {
    public static void main(String[] args) throws IOException {
        ClassPathXmlApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;provider.xml&quot;);
        ioc.start();
        System.in.read();
    }
}
</code></pre>
<figure data-type="image" tabindex="45"><img src="https://uploader.shimo.im/f/STJJRpsgwTkLRkmY.png!thumbnail" alt="图片" loading="lazy"></figure>
<p>4）测试</p>
<figure data-type="image" tabindex="46"><img src="https://uploader.shimo.im/f/reVohj16x2sHjsEN.png!thumbnail" alt="图片" loading="lazy"></figure>
<p><em>2、改造gmall-order-web作为服务消费者</em></p>
<p>1）引入dubbo</p>
<pre><code>		&lt;!-- 引入dubbo --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;com.alibaba&lt;/groupId&gt;
			&lt;artifactId&gt;dubbo&lt;/artifactId&gt;
			&lt;version&gt;2.6.2&lt;/version&gt;
		&lt;/dependency&gt;
	&lt;!-- 由于我们使用zookeeper作为注册中心，所以需要引入zkclient或curator操作zookeeper --&gt;
		&lt;!-- curator-framework --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
			&lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
			&lt;version&gt;2.12.0&lt;/version&gt;
		&lt;/dependency&gt;
</code></pre>
<p>2）配置消费者信息</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-4.3.xsd
       http://dubbo.apache.org/schema/dubbo
       http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!-- 1.指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名 --&gt;
    &lt;dubbo:application name=&quot;order-service-consumer&quot;  /&gt;

    &lt;!-- 2.注册中心地址 --&gt;
    &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; /&gt;

    &lt;!-- 3.声明需要调用的远程服务的接口 --&gt;
    &lt;dubbo:reference interface=&quot;com.atguigu.gmall.service.UserService&quot; id=&quot;userService&quot; /&gt;
    &lt;!-- 包扫描 --&gt;
    &lt;context:component-scan base-package=&quot;com.atguigu.gmall.service.impl&quot;&gt;&lt;/context:component-scan&gt;
&lt;/beans&gt;
</code></pre>
<p>3）Service 注解</p>
<pre><code>package com.atguigu.gmall.service.impl;

import com.atguigu.gmall.bean.UserAddress;
import com.atguigu.gmall.service.OrderService;
import com.atguigu.gmall.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * 1.让服务提供者注册到注册中心（暴露服务）
 *  1）导入 dubbo 依赖（2.6.2）、导入操作 zookeeper 的客户端（curator）
 *  2）配置服务提供者
 * 2.让消费者去注册中心订阅服务提供者的地址
 */
@Service
public class OrderServiceImpl implements OrderService {
    @Autowired
    UserService userService;
    @Override
    public void initOrder(String userId) {
        // 1. 查询用户收货地址
        List&lt;UserAddress&gt; list = userService.getUserAddressList(userId);
        System.out.println(list);
    }
}
</code></pre>
<p>4）main方法测试</p>
<pre><code>package com.atguigu.gmall;

import com.atguigu.gmall.service.OrderService;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import java.io.IOException;

public class MainApplication {
    public static void main(String[] args) throws IOException {
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;consumer.xml&quot;);
        OrderService orderService = applicationContext.getBean(OrderService.class);
        orderService.initOrder(&quot;1&quot;);
        System.out.println(&quot;调用结束...&quot;);

        System.in.read();
    }
}
</code></pre>
<p><em>3、测试调用</em><br>
访问gmall-order-web的initOrder请求，会调用UserService获取用户地址；</p>
<p>调用成功。说明我们order已经可以调用远程的UserService了；</p>
<p>运行结果：</p>
<pre><code>用户 id ：1
北京市昌平区宏福科技园综合楼3层
深圳市宝安区西部硅谷大厦B座3层（深圳分校）
调用结束...
</code></pre>
<figure data-type="image" tabindex="47"><img src="https://uploader.shimo.im/f/60BuhhwD1HUmxziW.png!thumbnail" alt="图片" loading="lazy"></figure>
<p><em>4、注解版</em></p>
<p>1、服务提供方</p>
<pre><code>&lt;dubbo:application name=&quot;gmall-user&quot;&gt;&lt;/dubbo:application&gt;  
&lt;dubbo:registry address=&quot;zookeeper://118.24.44.169:2181&quot; /&gt;  
&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;
&lt;dubbo:annotation package=*&quot;com.atguigu.gmall.user.impl&quot;/&gt;  

import com.alibaba.dubbo.config.annotation.Service;
import com.atguigu.gmall.bean.UserAddress;  
import com.atguigu.gmall.service.UserService;  
import com.atguigu.gmall.user.mapper.UserAddressMapper;

@Service //使用dubbo提供的service注解，注册暴露服务
public class UserServiceImpl implements UserService {	
     @Autowired		
    UserAddressMapper userAddressMapper; 
</code></pre>
<p>2、服务消费方</p>
<pre><code>&lt;dubbo:application name=&quot;gmall-order-web&quot;&gt;&lt;/dubbo:application&gt;  
&lt;dubbo:registry address=&quot;zookeeper://118.24.44.169:2181&quot; /&gt;  
&lt;dubbo:annotation package=&quot;com.atguigu.gmall.order.controller&quot;/&gt;

@Controller  
public class OrderController {  	  	
    @Reference  //使用dubbo提供的reference注解引用远程服务  	
    UserService userService; 
</code></pre>
<h2 id="5-监控中心">5、监控中心</h2>
<h3 id="51-dubbo-admin">5.1）、dubbo-admin</h3>
<p>图形化的服务管理页面；安装时需要指定注册中心地址，即可从注册中心中获取到所有的提供者/消费者进行配置管理</p>
<h3 id="52-dubbo-monitor-simple">5.2）、dubbo-monitor-simple</h3>
<p>简单的监控中心；</p>
<p><em>1、安装</em></p>
<table>
<thead>
<tr>
<th style="text-align:center">1、下载 dubbo-ops  <a href="https://github.com/apache/incubator-dubbo-ops">https://github.com/apache/incubator-dubbo-ops</a></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2、修改配置指定注册中心地址进入 dubbo-monitor-simple\src\main\resources\conf修改 dubbo.properties文件</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="48"><img src="https://uploader.shimo.im/f/hiBXL60A0HIHytCX.png!thumbnail" alt="图片" loading="lazy"></figure>
<table>
<thead>
<tr>
<th style="text-align:left">3、打包dubbo-monitor-simplemvn clean package -Dmaven.test.skip=true</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">4、解压 tar.gz 文件，并运行start.bat</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="49"><img src="https://uploader.shimo.im/f/3VuJjpqB1NQs3dTZ.png!thumbnail" alt="图片" loading="lazy"></figure>
<table>
<thead>
<tr>
<th style="text-align:left">如果缺少servlet-api，自行导入servlet-api再访问监控中心</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">5、启动访问8080</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="50"><img src="https://uploader.shimo.im/f/8yKt4JScy58YqdVP.png!thumbnail" alt="图片" loading="lazy"></figure>
<p><em>2、监控中心配置</em></p>
<table>
<thead>
<tr>
<th>所有服务配置连接监控中心，进行监控统计    <!-- 监控中心协议，如果为protocol="registry"，表示从注册中心发现监控中心地址，否则直连监控中心 -->  	<a href="dubbo:monitor%C2%A0protocol=%22registry%22">dubbo:monitor protocol=&quot;registry&quot;</a>&lt;/dubbo:monitor&gt;</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Simple Monitor 挂掉不会影响到 Consumer 和 Provider 之间的调用，所以用于生产环境不会有风险。</p>
<p>Simple Monitor 采用磁盘存储统计信息，请注意安装机器的磁盘限制，如果要集群，建议用mount共享磁盘。</p>
<h2 id="6-整合springboot">6、整合SpringBoot</h2>
<p>1）引入<strong>spring-boot-starter以及dubbo和curator的依赖</strong></p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt;
    &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;0.2.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>注意starter版本适配：<br>
<img src="https://uploader.shimo.im/f/d2JLjRxIZZsumBaC.png!thumbnail" alt="图片" loading="lazy"></p>
<p>2）配置application.properties</p>
<p><em>提供者配置：</em></p>
<pre><code>dubbo.application.name=gmall-user
dubbo.registry.protocol=zookeeper
dubbo.registry.address=192.168.67.159:2181
dubbo.scan.base-package=com.atguigu.gmall
dubbo.protocol.name=dubbo
dubbo.protocol.port=20880
dubbo.monitor.protocol=registry
## application.name就是服务名，不能跟别的dubbo提供端重复
## registry.protocol  是指定注册中心协议
## registry.address 是注册中心的地址加端口号
## protocol.name 是分布式固定是dubbo,不要改。
## base-package  注解方式要扫描的包
</code></pre>
<p><em>消费者配置：</em></p>
<pre><code>server.port=8081

dubbo.application.name=gmall-order-web
dubbo.registry.protocol=zookeeper
dubbo.registry.address=192.168.67.159:2181
dubbo.scan.base-package=com.atguigu.gmall
dubbo.protocol.name=dubbo
dubbo.monitor.protocol=registry
</code></pre>
<p>3、dubbo注解<br>
@Service、@Reference</p>
<p><strong>【如果没有在配置中写dubbo.scan.base-package,还需要在启动类使用@EnableDubbo注解】</strong></p>
<p>消费者：</p>
<pre><code>@Reference
UserService userService;
</code></pre>
<p>服务提供者：</p>
<pre><code>@com.alibaba.dubbo.config.annotation.Service // 暴露服务
@Service
public class UserServiceImpl implements UserService {
</code></pre>
<h1 id="二-dubbo配置">二、dubbo配置</h1>
<h2 id="1-配置原则">1、配置原则</h2>
<figure data-type="image" tabindex="51"><img src="https://uploader.shimo.im/f/B1hW7n2x1bYU1d7w.png!thumbnail" alt="图片" loading="lazy"></figure>
<p>JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。</p>
<p>XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。</p>
<p>Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。</p>
<h2 id="2-重试次数">2、重试次数</h2>
<p>失败自动切换，当出现失败，重试其它服务器，但重试会带来更长延迟。可通过 retries=&quot;2&quot; 来设置重试次数(不含第一次)。</p>
<p>重试次数配置如下：</p>
<pre><code>&lt;dubbo:service retries=&quot;2&quot; /&gt;
</code></pre>
<p>或</p>
<pre><code>&lt;dubbo:reference retries=&quot;2&quot; /&gt;
</code></pre>
<p>或</p>
<pre><code>&lt;dubbo:reference&gt;
    &lt;dubbo:method name=&quot;findFoo&quot; retries=&quot;2&quot; /&gt;
&lt;/dubbo:reference&gt;
</code></pre>
<blockquote>
<p>幂等操作（执行多次和执行一次效果相同：查询、删除、修改）可设置重试次数，非幂等操作（执行多次和执行一次效果不同：新增）不宜设置重试次数</p>
</blockquote>
<h2 id="3-超时时间">3、超时时间</h2>
<p>由于网络或服务端不可靠，会导致调用出现一种不确定的中间状态（超时）。为了避免超时导致客户端资源（线程）挂起耗尽，必须设置超时时间。</p>
<blockquote>
<p>服务消费方引用服务提供方时，可能有雨网络等原因，服务提供方要执行一个方法可能有很长时间，如果很长时间都没有返回，导致大量线程阻塞，可能会引起性能下降，为了解决这个问题，可以指定超时时间，只要这个方法在指定时间内没有返回，就立即终止，不让大量线程阻塞。设置单位 ms</p>
</blockquote>
<h3 id="1-dubbo消费端">1、Dubbo消费端</h3>
<p>全局超时配置</p>
<pre><code>&lt;dubbo:consumer timeout=&quot;5000&quot; /&gt;
</code></pre>
<p>指定接口以及特定方法超时配置</p>
<pre><code>&lt;dubbo:reference interface=&quot;com.foo.BarService&quot; timeout=&quot;2000&quot;&gt;
    &lt;dubbo:method name=&quot;sayHello&quot; timeout=&quot;3000&quot; /&gt;
&lt;/dubbo:reference&gt;
</code></pre>
<h3 id="2-dubbo服务端">2、Dubbo服务端</h3>
<p>全局超时配置</p>
<pre><code>&lt;dubbo:provider timeout=&quot;5000&quot; /&gt;
</code></pre>
<p>指定接口以及特定方法超时配置</p>
<pre><code>&lt;dubbo:provider interface=&quot;com.foo.BarService&quot; timeout=&quot;2000&quot;&gt;
    &lt;dubbo:method name=&quot;sayHello&quot; timeout=&quot;3000&quot; /&gt;
&lt;/dubbo:provider&gt;
</code></pre>
<h3 id="3-配置原则">3、配置原则</h3>
<p>dubbo推荐在Provider上尽量多配置Consumer端属性：</p>
<p>1、作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等</p>
<p>2、在Provider配置后，Consumer不配置则会使用Provider的配置值，即Provider配置可以作为Consumer的缺省值。否则，Consumer会使用Consumer端的全局设置，这对于Provider不可控的，并且往往是不合理的</p>
<p>配置的覆盖规则：</p>
<ol>
<li>
<p>方法级别配置优于接口级别，即小Scope优先</p>
</li>
<li>
<p>Consumer端配置 优于 Provider配置 优于 全局配置，</p>
</li>
</ol>
<p>3) 最后是Dubbo Hard Code的配置值（见配置文档）</p>
<figure data-type="image" tabindex="52"><img src="https://uploader.shimo.im/f/5xoy9sunaRc44qdE.png!thumbnail" alt="图片" loading="lazy"></figure>
<h2 id="4-版本号">4、版本号</h2>
<p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。</p>
<p>可以按照以下的步骤进行版本迁移：</p>
<p>在低压力时间段，先升级一半提供者为新版本</p>
<p>再将所有消费者升级为新版本</p>
<p>然后将剩下的一半提供者升级为新版本</p>
<p>老版本服务提供者配置：</p>
<pre><code>&lt;dubbo:service interface=&quot;com.foo.BarService&quot; version=&quot;1.0.0&quot; /&gt;
</code></pre>
<p>新版本服务提供者配置：</p>
<pre><code>&lt;dubbo:service interface=&quot;com.foo.BarService&quot; version=&quot;2.0.0&quot; /&gt;
</code></pre>
<p>老版本服务消费者配置：</p>
<pre><code>&lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;1.0.0&quot; /&gt;
</code></pre>
<p>新版本服务消费者配置：</p>
<pre><code>&lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;2.0.0&quot; /&gt;
</code></pre>
<p>如果不需要区分版本，可以按照以下的方式配置：</p>
<pre><code>&lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;*&quot; /&gt;
</code></pre>
<h2 id="5-启动时检查">5、启动时检查</h2>
<p>Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 check=&quot;true&quot;。</p>
<p>可以通过 check=&quot;false&quot; 关闭检查，比如，测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。</p>
<p>另外，如果你的 Spring 容器是懒加载的，或者通过 API 编程延迟引用服务，请关闭 check，否则服务临时不可用时，会抛出异常，拿到 null 引用，如果 check=&quot;false&quot;，总是会返回引用，当服务恢复时，能自动连上。</p>
<h3 id="示例">示例</h3>
<p><strong>通过 spring 配置文件</strong></p>
<p>关闭某个服务的启动时检查 (没有提供者时报错)：如果启动时没有提供者可以成功启动，但调用时因没有提供者调用失败会抛出异常</p>
<pre><code>&lt;dubbo:reference interface=&quot;com.foo.BarService&quot; check=&quot;false&quot; /&gt;
</code></pre>
<p>配置当前消费者的统一规则，所有的服务启动时都不检查：</p>
<pre><code>&lt;dubbo:consumer check=&quot;false&quot; /&gt;
</code></pre>
<p>关闭注册中心启动时检查 (注册订阅失败时报错)：</p>
<pre><code>&lt;dubbo:registry check=&quot;false&quot; /&gt;
</code></pre>
<p><strong>通过 dubbo.properties</strong></p>
<pre><code>dubbo.reference.com.foo.BarService.check=false
dubbo.reference.check=false
dubbo.consumer.check=false
dubbo.registry.check=false
</code></pre>
<h2 id="6-多版本">6、多版本</h2>
<p><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/multi-versions.html">http://dubbo.apache.org/zh-cn/docs/user/demos/multi-versions.html</a></p>
<blockquote>
<p>使用场景：某一个接口功能出现了不兼容的升级，先让一部分人使用新功能，另外一部分人还是先用旧版本，如果新功能版本都稳定了，再把所有老版本替换成新版本。</p>
</blockquote>
<p>服务提供方提供新旧两个版本供消费者使用</p>
<pre><code>&lt;!-- 4.暴露服务 ref：指向服务的真正实现对象--&gt;
&lt;dubbo:service interface=&quot;com.atguigu.gmall.service.UserService&quot; ref=&quot;userServiceImpl01&quot; version=&quot;1.0.0&quot;/&gt;
&lt;!-- 服务的实现  --&gt;
&lt;bean id=&quot;userServiceImpl01&quot; class=&quot;com.atguigu.gmall.service.impl.UserServiceImpl&quot; /&gt;
&lt;!-- 连接监控中心 --&gt;
&lt;dubbo:monitor protocol=&quot;registry&quot;&gt;&lt;/dubbo:monitor&gt;
&lt;!-- 检测多版本 --&gt;
&lt;dubbo:service interface=&quot;com.atguigu.gmall.service.UserService&quot; ref=&quot;userServiceImpl02&quot; version=&quot;2.0.0&quot;/&gt;
&lt;bean id=&quot;userServiceImpl02&quot; class=&quot;com.atguigu.gmall.service.impl.UserServiceImpl2&quot; /&gt;
</code></pre>
<p>服务消费方可选择哪一个版本</p>
<pre><code>&lt;!-- 3.声明需要调用的远程服务的接口 --&gt;
&lt;dubbo:reference interface=&quot;com.atguigu.gmall.service.UserService&quot; id=&quot;userService&quot; check=&quot;false&quot; version=&quot;2.0.0&quot;/&gt;
</code></pre>
<blockquote>
<p>由此实现灰度发布。</p>
</blockquote>
<h2 id="7-本地存根">7、本地存根</h2>
<p><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html">http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html</a></p>
<p>远程服务后，客户端通常只剩下接口，而实现全在服务器端，但提供方有些时候想在客户端也执行部分逻辑，比如：做 ThreadLocal 缓存，提前验证参数，调用失败后伪造容错数据等等，此时就需要在 API 中带上 Stub，客户端生成 Proxy 实例，会把 Proxy 通过构造函数传给 Stub <a href="http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html#fn1">[1]</a>，然后把 Stub 暴露给用户，Stub 可以决定要不要去调 Proxy。</p>
<figure data-type="image" tabindex="53"><img src="https://uploader.shimo.im/f/fCMOKYxIU74ZSiof.png!thumbnail" alt="图片" loading="lazy"></figure>
<p>在 spring 配置文件中按以下方式配置：</p>
<pre><code>&lt;dubbo:service interface=&quot;com.foo.BarService&quot; stub=&quot;true&quot; /&gt;
</code></pre>
<p>或</p>
<pre><code>&lt;dubbo:service interface=&quot;com.foo.BarService&quot; stub=&quot;com.foo.BarServiceStub&quot; /&gt;
</code></pre>
<p>提供 Stub 的实现 <a href="http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html#fn2">[2]</a>：</p>
<pre><code>package com.foo;
public class BarServiceStub implements BarService {
    private final BarService barService;
    
    // 构造函数传入真正的远程代理对象
    public BarServiceStub(BarService barService){
        this.barService = barService;
    }
 
    public String sayHello(String name) {
        // 此代码在客户端执行, 你可以在客户端做ThreadLocal本地缓存，或预先验证参数是否合法，等等
        try {
            return barService.sayHello(name);
        } catch (Exception e) {
            // 你可以容错，可以做任何AOP拦截事项
            return &quot;容错数据&quot;;
        }
    }
}
</code></pre>
<p>Stub 必须有可传入 Proxy 的构造函数。 <a href="http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html#fnref1">↩︎</a></p>
<ol>
<li>在 interface 旁边放一个 Stub 实现，它实现 BarService 接口，并有一个传入远程 BarService 实例的构造函数 <a href="http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html#fnref2">↩︎</a></li>
</ol>
<h2 id="8-springboot-与-dubbo-整合的三种方式">8、Springboot 与 dubbo 整合的三种方式</h2>
<p><strong>（1） application.properties</strong></p>
<p>导入 dubb-starter，在 application.properties 中配置属性，使用 @Service 暴露服务；使用 @Reference 引用服务</p>
<p>（注意 @EnableDubbo 开启基于注解的 dubbo 或在 properties 文件中包扫描）</p>
<p><strong>（2）保留 dubbo xml配置文件</strong></p>
<p>导入 dubb-starter，使用 @ImportResource 导入配置文件即可（不再使用 @EnableDubbo 注解，转而使用 @ImportResource(locations=&quot;classpath:provider.xml&quot;)</p>
<p>暴露 Service 也不再使用 @Service 了，因为 xml 中已经设置了暴露服务）</p>
<p><strong>（3）使用注解 API 方式</strong></p>
<p>将每一个组件手动创建到容器中，让 dubbo 来扫描其他的组件</p>
<pre><code>  @EnableDubbo(scanBasePackages=&quot;com.atguigu.gmall&quot;)
</code></pre>
<pre><code>package com.atguigu.gmall.config;

import com.alibaba.dubbo.config.*;
import com.atguigu.gmall.service.UserService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.ArrayList;
import java.util.List;

@Configuration
public class MyDubboConfig {

//        &lt;dubbo:application name=&quot;boot-user-service-provider&quot;  /&gt;
    @Bean
    public ApplicationConfig applicationConfig(){
        ApplicationConfig config = new ApplicationConfig();
        config.setName(&quot;boot-user-service-provider&quot;);
        return config;
    }

    // &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; /&gt;
    @Bean
    public RegistryConfig registryConfig(){
        System.out.println(&quot;--------&quot;);
        RegistryConfig registryConfig = new RegistryConfig();
        registryConfig.setProtocol(&quot;zookeeper&quot;);
        registryConfig.setAddress(&quot;127.0.0.1:2181&quot;);
        return registryConfig;
    }

    //&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20882&quot; /&gt;
    @Bean
    public ProtocolConfig protocolConfig(){
        ProtocolConfig config = new ProtocolConfig();
        config.setName(&quot;dubbo&quot;);
        config.setPort(20882);
        return config;
    }

    //    &lt;dubbo:service interface=&quot;com.atguigu.gmall.service.UserService&quot; ref=&quot;userServiceImpl01&quot;&gt;
    //        &lt;dubbo:method name=&quot;getUserAddressList&quot; timeout=&quot;1000&quot;&gt;&lt;/dubbo:method&gt;
    //    &lt;/dubbo:service&gt;
    @Bean
    public ServiceConfig&lt;UserService&gt; serviceConfig(UserService userService){
        ServiceConfig&lt;UserService&gt; config = new ServiceConfig&lt;&gt;();
        config.setInterface(UserService.class);
        config.setRef(userService);

        // 配置每一个 method 信息
        MethodConfig methodConfig = new MethodConfig();
        methodConfig.setName(&quot;getUserAddressList&quot;);
        methodConfig.setTimeout(1000);

        // 将 method 的设置关联到 servie 中
        List&lt;MethodConfig&gt; methods = new ArrayList&lt;&gt;();
        methods.add(methodConfig);
        config.setMethods(methods);

        return config;
    }

}
</code></pre>
<h1 id="三-高可用">三、高可用</h1>
<h2 id="1-zookeeper宕机与dubbo直连">1、zookeeper宕机与dubbo直连</h2>
<p>现象：zookeeper注册中心（zkServer.cmd）宕机，还可以消费dubbo暴露的服务。</p>
<p>原因：</p>
<p>健壮性</p>
<ul>
<li>监控中心宕掉不影响使用，只是丢失部分采样数据</li>
<li>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</li>
<li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li>
<li><strong>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</strong></li>
<li>服务提供者无状态，任意一台宕掉后，不影响使用</li>
<li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</li>
</ul>
<p><strong>高可用：通过设计，减少系统不能提供服务的时间；</strong></p>
<p><strong>dubbo 直连（绕过注册中心）</strong></p>
<pre><code>@Reference(url = &quot;127.0.0.1:20882&quot;)
UserService userService;
</code></pre>
<h2 id="2-集群下dubbo负载均衡配置">2、集群下dubbo负载均衡配置</h2>
<p><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/loadbalance.html">http://dubbo.apache.org/zh-cn/docs/user/demos/loadbalance.html</a></p>
<p>在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。</p>
<h3 id="负载均衡策略">负载均衡策略</h3>
<p><strong>Random LoadBalance</strong></p>
<p>随机，按权重设置随机概率。</p>
<p>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</p>
<figure data-type="image" tabindex="54"><img src="https://uploader.shimo.im/f/t9CCH4EHEeoW2iry.png!thumbnail" alt="图片" loading="lazy"></figure>
<blockquote>
<p>基于权重的随机负载均衡机制：orderService 想要调用 userService，userService 分别在 1、2、3 台机器内，分别为每一台机器的服务设置权重为 100、200、50，总权重 350，那么对于 1 号机器来说，它的概率就是 100/350 = 2/7，在负载均衡的情况下，大量请求过来，大约有 2/7 的请求会来到 1 号机器。第一次请求来调用的是 1 号机器，第二次来有可能还调用 1 号机器，但总体上，按照大量请求概率分布来看，1 号机器会占 2/7 的概率。</p>
</blockquote>
<p><strong>RoundRobin LoadBalance</strong></p>
<p>轮循，按公约后的权重设置轮循比率。</p>
<p>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</p>
<figure data-type="image" tabindex="55"><img src="https://uploader.shimo.im/f/fnw0VbVMqhIoKq6S.png!thumbnail" alt="图片" loading="lazy"></figure>
<blockquote>
<p>轮询负载均衡机制：orderService 想要调用 userService，第一个请求过来先用 1 号 userService 服务，第二个请求过来使用 2 号 userService 服务，下一个请求过来使用 3 号userService 服务，再下一次 1 号，再下一次 2 号...... 依次轮询。<br>
基于权重的轮询负载均衡机制：为每个服务设置权重，3 台服务器的权重分别为 2/7、4/7、1/7，按照轮询机制，第一个请求到来使用 1 号服务器，第二个请求使用 2 号服务器，第三个请求使用 3 号服务器，第四个请求使用 1 号服务器，第五个请求使用 2 号服务器，第六个请求本应使用 3 号服务器，<strong>但是</strong>，由于 3 号服务器的权重是 1/7（如果有 7 个请求，则 7 个之中的 1 个使用 3 号服务器），已经有第三个请求使用了 3 号服务器，第一个、第四个请求已经使用了 两次 1 号服务器，所以第六个请求只能使用 2 号服务器，同理，第七个请求也使用 2 号服务器。<br>
<strong>LeastActive LoadBalance</strong></p>
</blockquote>
<p>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</p>
<p>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</p>
<figure data-type="image" tabindex="56"><img src="https://uploader.shimo.im/f/S8G9zCwCrP81SVr3.png!thumbnail" alt="图片" loading="lazy"></figure>
<blockquote>
<p>最少活跃数：orderService 要调用 userService，在确定要使用几号 userService前，根据 “每一个服务器统计的上一次的调用时间”：三台服务器上一次请求的处理时间分别为 100ms、1000ms、300ms，说明 1 号服务器处理最快，于是此次请求会来到 1 号服务器。</p>
</blockquote>
<p><strong>ConsistentHash LoadBalance</strong></p>
<p>一致性 Hash，相同参数的请求总是发到同一提供者。</p>
<p>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：<a href="http://en.wikipedia.org/wiki/Consistent_hashing">http://en.wikipedia.org/wiki/Consistent_hashing</a></p>
<p>缺省只对第一个参数 Hash，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</p>
<p>缺省用 160 份虚拟节点，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</p>
<figure data-type="image" tabindex="57"><img src="https://uploader.shimo.im/f/TKBZTSuulaQxa01m.png!thumbnail" alt="图片" loading="lazy"></figure>
<blockquote>
<p>一致性 hash：orderService 想要调用 userService，都是调用的同一个 getUser 方法，将参数 hash 后的不同值分不到不同的服务器上。</p>
</blockquote>
<h3 id="负载均衡配置">负载均衡配置</h3>
<p>服务端服务级别，暴露服务时</p>
<pre><code>&lt;dubbo:service interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;
</code></pre>
<p>客户端服务级别，消费时</p>
<pre><code>&lt;dubbo:reference interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;
</code></pre>
<p>服务端方法级别</p>
<pre><code>&lt;dubbo:service interface=&quot;...&quot;&gt;
    &lt;dubbo:method name=&quot;...&quot; loadbalance=&quot;roundrobin&quot;/&gt;
&lt;/dubbo:service&gt;
</code></pre>
<p>客户端方法级别</p>
<pre><code>&lt;dubbo:reference interface=&quot;...&quot;&gt;
    &lt;dubbo:method name=&quot;...&quot; loadbalance=&quot;roundrobin&quot;/&gt;
&lt;/dubbo:reference&gt;
</code></pre>
<h2 id="3-整合hystrix服务熔断与降级处理">3、整合hystrix，服务熔断与降级处理</h2>
<h3 id="1-服务降级">1、服务降级</h3>
<p><strong>什么是服务降级？</strong></p>
<p><strong>当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。</strong></p>
<p>可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。</p>
<p>向注册中心写入动态配置覆盖规则：</p>
<pre><code>RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();
Registry registry = registryFactory.getRegistry(URL.valueOf(&quot;zookeeper://10.20.153.10:2181&quot;));
registry.register(URL.valueOf(&quot;override://0.0.0.0/com.foo.BarService?category=configurators&amp;dynamic=false&amp;application=foo&amp;mock=force:return+null&quot;));
</code></pre>
<p>其中：</p>
<ul>
<li>mock=force:return+null 表示消费方对该服务的方法调用都<strong>直接返回 null 值，不发起远程调用</strong>。用来屏蔽不重要服务不可用时对调用方的影响。</li>
<li>还可以改为 mock=fail:return+null 表示消费方对该服务的方法<strong>调用在失败后，再返回 null 值</strong>，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。</li>
</ul>
<h3 id="2-集群容错">2、集群容错</h3>
<p>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p>
<p><strong>集群容错模式</strong></p>
<p><strong>Failover Cluster</strong></p>
<p>失败自动切换，当<strong>出现失败，重试其它服务器</strong>。通常用于读操作，但重试会带来更长延迟。可通过 retries=&quot;2&quot; 来设置重试次数(不含第一次)。</p>
<blockquote>
<p>A 服务调用 B 服务，B 服务超时后，配置一个重试次数，可以重新切换到能提供 B服务的其他机器。</p>
</blockquote>
<p>重试次数配置如下：</p>
<pre><code>&lt;dubbo:service retries=&quot;2&quot; /&gt;
</code></pre>
<p>或</p>
<pre><code>&lt;dubbo:reference retries=&quot;2&quot; /&gt;
</code></pre>
<p>或</p>
<pre><code>&lt;dubbo:reference&gt;
    &lt;dubbo:method name=&quot;findFoo&quot; retries=&quot;2&quot; /&gt;
&lt;/dubbo:reference&gt;
</code></pre>
<p><strong>Failfast Cluster</strong></p>
<p>快速失败，只发起一次调用，<strong>失败立即报错</strong>。通常用于非幂等性的写操作，比如新增记录。</p>
<blockquote>
<p>A 服务调用 B服务，只发起一次调用，失败立即报错。</p>
</blockquote>
<p><strong>Failsafe Cluster</strong></p>
<p>失败安全，出现异常时，直接<strong>忽略</strong>。通常用于写入审计日志等操作。</p>
<p><strong>Failback Cluster</strong></p>
<p><strong>失败自动恢复，后台记录失败请求，定时重发</strong>。通常用于消息通知操作。</p>
<blockquote>
<p>A 服务调用 B 服务，失败后可以后台记录一下，隔一段时间定时再调用一次。适用于：一定要成功的服务调用</p>
</blockquote>
<p><strong>Forking Cluster</strong></p>
<p>并行调用多个服务器，只要一个成功即返回。通常用于<strong>实时性要求较高</strong>的读操作，但需要浪费更多服务资源。可通过 forks=&quot;2&quot; 来设置最大并行数。</p>
<blockquote>
<p>A 服务调用 B服务，有可能会失败，能提供 B 服务的在三台服务器上，同时给这三台服务器都发起请求，只要其中一个服务器响应成功就可以使用。</p>
</blockquote>
<p><strong>Broadcast Cluster</strong></p>
<p>广播调用所有提供者，逐个调用，任意一台报错则报错 [2]。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p>
<blockquote>
<p>A 服务调用 B服务，B 服务的提供者有四台机器，每一台机器都调用一遍，只要有任意一台出现错误，都认为这次调用是失败的。</p>
</blockquote>
<p><strong>集群模式配置</strong></p>
<p>按照以下示例在服务提供方和消费方配置集群模式</p>
<pre><code>&lt;dubbo:service cluster=&quot;failsafe&quot; /&gt;
</code></pre>
<p>或</p>
<pre><code>&lt;dubbo:reference cluster=&quot;failsafe&quot; /&gt;
</code></pre>
<h3 id="3-整合hystrix">3、整合hystrix</h3>
<p>Hystrix 旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能</p>
<p><em>1、配置spring-cloud-starter-netflix-hystrix</em></p>
<p>spring boot官方提供了对hystrix的集成，直接在pom.xml里加入依赖：</p>
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
  &lt;version&gt;1.4.4.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>然后在Application类上增加@EnableHystrix来启用hystrix starter：</p>
<pre><code>@SpringBootApplication
@EnableHystrix
public class ProviderApplication {
</code></pre>
<p><em>2、配置Provider端</em></p>
<p>在Dubbo的Provider上增加@HystrixCommand配置，这样子调用就会经过Hystrix代理。</p>
<pre><code>@Service(version = &quot;1.0.0&quot;)
public class HelloServiceImpl implements HelloService {
    @HystrixCommand(commandProperties = {
     @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;10&quot;),
     @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;2000&quot;) })
    @Override
    public String sayHello(String name) {
        // System.out.println(&quot;async provider received: &quot; + name);
        // return &quot;annotation: hello, &quot; + name;
        throw new RuntimeException(&quot;Exception to show hystrix enabled.&quot;);
    }
}
</code></pre>
<p><em>3、配置Consumer端</em></p>
<p>对于Consumer端，则可以增加一层method调用，并在method上配置@HystrixCommand。当调用出错时，会走到fallbackMethod = &quot;reliable&quot;的调用里。</p>
<pre><code>    @Reference(version = &quot;1.0.0&quot;)
    private HelloService demoService;
    @HystrixCommand(fallbackMethod = &quot;reliable&quot;)
    public String doSayHello(String name) {
        return demoService.sayHello(name);
    }
    public String reliable(String name) {
        return &quot;hystrix fallback value&quot;;
    }
</code></pre>
<h1 id="四-dubbo原理">四、dubbo原理</h1>
<h2 id="1-rpc原理">1、RPC原理</h2>
<figure data-type="image" tabindex="58"><img src="https://uploader.shimo.im/f/VT5w26Fy18AWw61q.png!thumbnail" alt="图片" loading="lazy"></figure>
<p>一次完整的RPC调用流程（同步调用，异步另说）如下：</p>
<p>**1）服务消费方（client）调用以本地调用方式调用服务； **</p>
<p>2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</p>
<p>3）client stub找到服务地址，并将消息发送到服务端；</p>
<p>4）server stub收到消息后进行解码；</p>
<p>5）server stub根据解码结果调用本地的服务；</p>
<p>6）本地服务执行并将结果返回给server stub；</p>
<p>7）server stub将返回结果打包成消息并发送至消费方；</p>
<p>8）client stub接收到消息，并进行解码；</p>
<p><strong>9）服务消费方得到最终结果。</strong></p>
<p>RPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明的，不可见的。</p>
<h2 id="2-netty通信原理">2、netty通信原理</h2>
<p>Netty是一个异步事件驱动的网络应用程序框架， 用于快速开发可维护的高性能协议服务器和客户端。它极大地简化并简化了TCP和UDP套接字服务器等网络编程。</p>
<p>BIO：(Blocking IO)</p>
<figure data-type="image" tabindex="59"><img src="https://uploader.shimo.im/f/2W5W02pWhRc1tfWH.png!thumbnail" alt="图片" loading="lazy"></figure>
<blockquote>
<p>BIO：阻塞式 IO。每一个请求进来，开一个 Socket 开一个线程来处理数据，读取到数据后业务逻辑操作完成后返回。服务器收到很多请求，同时操作，在这个业务逻辑完成前这个线程不能得到释放，服务器就不能同时处理大量请求，因为有大量线程在阻塞，等待业务逻辑的完成。</p>
</blockquote>
<p>NIO (Non-Blocking IO)</p>
<figure data-type="image" tabindex="60"><img src="https://uploader.shimo.im/f/i2Hhf1AEfLE0e9rK.png!thumbnail" alt="图片" loading="lazy"></figure>
<blockquote>
<p>Channel：通道，通道里面有 Buffer 用来进行数据传输。<br>
一个 Selector 注册进了很多通道，每个请求使用通道进行数据传递通信，Selector 通过监听多个通道，当发现某一个通道里的数据准备好了，Selector 执行相应操作。</p>
</blockquote>
<p>Selector 一般称 为<strong>选择器</strong> ，也可以翻译为 <strong>多路复用器，</strong></p>
<p>Connect（连接就绪）、Accept（接受就绪）、Read（读就绪）、Write（写就绪）</p>
<p>Netty基本原理：</p>
<figure data-type="image" tabindex="61"><img src="https://uploader.shimo.im/f/M16PnkZ6fGY7YG8J.png!thumbnail" alt="图片" loading="lazy"></figure>
<blockquote>
<p>Netty 服务器启动（ServerBootstrap.bind），绑定监听某一个端口，比如 dubbo 的20880端口，这样所有给这个端口发的数据 netty 就能收到，启动后初始化服务器的通道（NioServerSockerChannel），注册到 selector，selector 负责监听 accept 事件（当通道接收准备就绪后，处理通道里的信息），netty 与客户端建立连接， 生成 NioSocketChannel，把这个  通道注册到 Selector 里面，这个 selector 监听 read、write 事件（通道中数据读、写准备就绪），读写准备就绪后来处理这个事件，抛给用户队列，netty 把这个任务队列执行完</p>
</blockquote>
<h2 id="3-dubbo原理">3、dubbo原理</h2>
<h3 id="1-dubbo原理-框架设计">1、dubbo原理	-框架设计</h3>
<figure data-type="image" tabindex="62"><img src="https://uploader.shimo.im/f/mktdQ0QVP0s1eieu.png!thumbnail" alt="图片" loading="lazy"></figure>
<blockquote>
<p>dubbo 框架整体分层：</p>
<ol>
<li>Business 业务逻辑层：<br>
1.1 Service服务层：面向接口编程。接口、实现。想要远程调用只需要调用接口的方法，就自动调实现了。 对于用户编程，只需要关心这一层就结束了。<br>
2.RPC层：完成远程过程调用：<br>
2.1 Config 配置层，封装配置文件里解析出来的信息 ReferenceConfig、ServiceConfig；<br>
2.2 Proxy 服务代理层：利用代理的方式，生成客户端代理对象、服务端代理对象，代理对象互相调用方法；<br>
2.2 Registry 注册中心层：完成服务的发现和注册；很多服务要注册到注册中心，消费者要从注册中心订阅所需要的服务来调用；<br>
2.3 Cluster 路由层：负载均衡。invoker 调用者要调用很多的服务，服务在很多机器上跑，需要负载均衡；<br>
2.4 Monitor 监控层：每一次的调用信息都会向监控层发送一些数据；<br>
2.5 Protocol 远程调用层：封装 RPC 调用，RPC 调用核心的三个：Invoker、Protocol、Exporter；</li>
<li>Remoting 层：远程要调用就要跟 A、B两个服务器架起通信管道，通信以及在通信间传递数据<br>
3.1 Exchange 信息交换层：创建一个客户端 ExchangeClient、服务端 ExchangeServer<br>
两端架起网架进行数据的互联互通；<br>
3.2 Transport 传输层：真正传输数据用 Transporter 来封装传输的，Transporter 底层就是 netty 框架，netty 框架就是在这一层封装；<br>
3.3 Serialize 序列化层：序列化</li>
</ol>
</blockquote>
<ul>
<li>config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li>
<li>proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory</li>
<li>registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService</li>
<li>cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance</li>
<li>monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService</li>
<li>protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter</li>
<li>exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer</li>
<li>transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec</li>
<li>serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool</li>
</ul>
<h3 id="2-dubbo原理-启动解析-加载配置信息">2、dubbo原理	-启动解析、加载配置信息</h3>
<figure data-type="image" tabindex="63"><img src="https://uploader.shimo.im/f/iFVXso8DLkEuO0r6.png!thumbnail" alt="图片" loading="lazy"></figure>
<h3 id="3-dubbo原理-服务暴露">3、dubbo原理	-服务暴露</h3>
<figure data-type="image" tabindex="64"><img src="https://uploader.shimo.im/f/2ocFX7K06DopwxGs.png!thumbnail" alt="图片" loading="lazy"></figure>
<h3 id="4-dubbo原理-服务引用">4、dubbo原理	-服务引用</h3>
<figure data-type="image" tabindex="65"><img src="https://uploader.shimo.im/f/DxTlKd889QMR0jp1.png!thumbnail" alt="图片" loading="lazy"></figure>
<h3 id="5-dubbo原理-服务调用">5、dubbo原理	-服务调用</h3>
<figure data-type="image" tabindex="66"><img src="https://uploader.shimo.im/f/rugf4MklrfIiNoOW.png!thumbnail" alt="图片" loading="lazy"></figure>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E4%B8%80-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">一、基础知识</a>
<ul>
<li><a href="#1-%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA">1、分布式基础理论</a>
<ul>
<li><a href="#11-%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F">1.1）、什么是分布式系统？</a></li>
<li><a href="#12-%E5%8F%91%E5%B1%95%E6%BC%94%E5%8F%98">1.2）、发展演变</a></li>
<li><a href="#13-rpc">1.3）、RPC</a></li>
</ul>
</li>
<li><a href="#2-dubbo%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5">2、dubbo核心概念</a>
<ul>
<li><a href="#21-%E7%AE%80%E4%BB%8B">2.1）、简介</a></li>
<li><a href="#22-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">2.2）、基本概念</a></li>
</ul>
</li>
<li><a href="#3-dubbo%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">3、dubbo环境搭建</a>
<ul>
<li><a href="#31-windows-%E5%AE%89%E8%A3%85zookeeper">3.1）、【windows】-安装zookeeper</a></li>
<li><a href="#32-windows-%E5%AE%89%E8%A3%85dubbo-admin%E7%AE%A1%E7%90%86%E6%8E%A7%E5%88%B6%E5%8F%B0">3.2）、【windows】-安装dubbo-admin管理控制台</a></li>
<li><a href="#33-linux-%E5%AE%89%E8%A3%85zookeeper">3.3）、【linux】-安装zookeeper</a></li>
<li><a href="#34-linux-%E5%AE%89%E8%A3%85dubbo-admin%E7%AE%A1%E7%90%86%E6%8E%A7%E5%88%B6%E5%8F%B0">3.4）、【linux】-安装dubbo-admin管理控制台</a></li>
</ul>
</li>
<li><a href="#4-dubbo-helloworld">4、dubbo-helloworld</a>
<ul>
<li><a href="#41-%E6%8F%90%E5%87%BA%E9%9C%80%E6%B1%82">4.1）、提出需求</a></li>
<li><a href="#42-%E5%B7%A5%E7%A8%8B%E6%9E%B6%E6%9E%84">4.2）、工程架构</a></li>
<li><a href="#43-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97">4.3）、创建模块</a></li>
<li><a href="#44-%E4%BD%BF%E7%94%A8dubbo%E6%94%B9%E9%80%A0">4.4）、使用dubbo改造</a></li>
</ul>
</li>
<li><a href="#5-%E7%9B%91%E6%8E%A7%E4%B8%AD%E5%BF%83">5、监控中心</a>
<ul>
<li><a href="#51-dubbo-admin">5.1）、dubbo-admin</a></li>
<li><a href="#52-dubbo-monitor-simple">5.2）、dubbo-monitor-simple</a></li>
</ul>
</li>
<li><a href="#6-%E6%95%B4%E5%90%88springboot">6、整合SpringBoot</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-dubbo%E9%85%8D%E7%BD%AE">二、dubbo配置</a>
<ul>
<li><a href="#1-%E9%85%8D%E7%BD%AE%E5%8E%9F%E5%88%99">1、配置原则</a></li>
<li><a href="#2-%E9%87%8D%E8%AF%95%E6%AC%A1%E6%95%B0">2、重试次数</a></li>
<li><a href="#3-%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4">3、超时时间</a>
<ul>
<li><a href="#1-dubbo%E6%B6%88%E8%B4%B9%E7%AB%AF">1、Dubbo消费端</a></li>
<li><a href="#2-dubbo%E6%9C%8D%E5%8A%A1%E7%AB%AF">2、Dubbo服务端</a></li>
<li><a href="#3-%E9%85%8D%E7%BD%AE%E5%8E%9F%E5%88%99">3、配置原则</a></li>
</ul>
</li>
<li><a href="#4-%E7%89%88%E6%9C%AC%E5%8F%B7">4、版本号</a></li>
<li><a href="#5-%E5%90%AF%E5%8A%A8%E6%97%B6%E6%A3%80%E6%9F%A5">5、启动时检查</a>
<ul>
<li><a href="#%E7%A4%BA%E4%BE%8B">示例</a></li>
</ul>
</li>
<li><a href="#6-%E5%A4%9A%E7%89%88%E6%9C%AC">6、多版本</a></li>
<li><a href="#7-%E6%9C%AC%E5%9C%B0%E5%AD%98%E6%A0%B9">7、本地存根</a></li>
<li><a href="#8-springboot-%E4%B8%8E-dubbo-%E6%95%B4%E5%90%88%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F">8、Springboot 与 dubbo 整合的三种方式</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E9%AB%98%E5%8F%AF%E7%94%A8">三、高可用</a>
<ul>
<li><a href="#1-zookeeper%E5%AE%95%E6%9C%BA%E4%B8%8Edubbo%E7%9B%B4%E8%BF%9E">1、zookeeper宕机与dubbo直连</a></li>
<li><a href="#2-%E9%9B%86%E7%BE%A4%E4%B8%8Bdubbo%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE">2、集群下dubbo负载均衡配置</a>
<ul>
<li><a href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5">负载均衡策略</a></li>
<li><a href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE">负载均衡配置</a></li>
</ul>
</li>
<li><a href="#3-%E6%95%B4%E5%90%88hystrix%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%E4%B8%8E%E9%99%8D%E7%BA%A7%E5%A4%84%E7%90%86">3、整合hystrix，服务熔断与降级处理</a>
<ul>
<li><a href="#1-%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7">1、服务降级</a></li>
<li><a href="#2-%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99">2、集群容错</a></li>
<li><a href="#3-%E6%95%B4%E5%90%88hystrix">3、整合hystrix</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%9B%9B-dubbo%E5%8E%9F%E7%90%86">四、dubbo原理</a>
<ul>
<li><a href="#1-rpc%E5%8E%9F%E7%90%86">1、RPC原理</a></li>
<li><a href="#2-netty%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86">2、netty通信原理</a></li>
<li><a href="#3-dubbo%E5%8E%9F%E7%90%86">3、dubbo原理</a>
<ul>
<li><a href="#1-dubbo%E5%8E%9F%E7%90%86-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1">1、dubbo原理	-框架设计</a></li>
<li><a href="#2-dubbo%E5%8E%9F%E7%90%86-%E5%90%AF%E5%8A%A8%E8%A7%A3%E6%9E%90-%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF">2、dubbo原理	-启动解析、加载配置信息</a></li>
<li><a href="#3-dubbo%E5%8E%9F%E7%90%86-%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2">3、dubbo原理	-服务暴露</a></li>
<li><a href="#4-dubbo%E5%8E%9F%E7%90%86-%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8">4、dubbo原理	-服务引用</a></li>
<li><a href="#5-dubbo%E5%8E%9F%E7%90%86-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8">5、dubbo原理	-服务调用</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://epitomm.github.io/post/ji-yi-ge-mian-shi-ti-shi-xian-yi-ge-du-xie-suo/">
              <h3 class="post-title">
                记一个面试题 —— 实现一个读写锁
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '974bd77fbbd52c2a0647',
    clientSecret: '6344370ca1314dbd553f45e75a2121a160ef1c44',
    repo: 'EpitomM.github.io',
    owner: 'EpitomM',
    admin: ['EpitomM'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/EpitomM/EpitomM.github.io" target="_blank">EpitomM</a>
  <a class="rss" href="https://epitomm.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
