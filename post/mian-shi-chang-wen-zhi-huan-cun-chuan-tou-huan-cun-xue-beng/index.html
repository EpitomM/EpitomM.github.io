<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>面试常问之缓存预热、缓存雪崩、缓存击穿、缓存穿透 | SSM</title>
<link rel="shortcut icon" href="https://epitomm.github.io/favicon.ico?v=1586619209739">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://epitomm.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="面试常问之缓存预热、缓存雪崩、缓存击穿、缓存穿透 | SSM - Atom Feed" href="https://epitomm.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="缓存预热
“宕机”
服务器启动后迅速宕机
问题排查


请求数量较高


主从之间数据吞吐量较大（不停地加载数据），数据同步操作频度较高



数据库读的频度高：服务器一启动，缓存中没有数据，自然就会给服务器带来压力，这时候如果请求比较多的..." />
    <meta name="keywords" content="缓存,面试题" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://epitomm.github.io">
  <img class="avatar" src="https://epitomm.github.io/images/avatar.png?v=1586619209739" alt="">
  </a>
  <h1 class="site-title">
    SSM
  </h1>
  <p class="site-description">
    热心善良的老学姐
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              面试常问之缓存预热、缓存雪崩、缓存击穿、缓存穿透
            </h2>
            <div class="post-info">
              <span>
                2020-03-30
              </span>
              <span>
                10 min read
              </span>
              
                <a href="https://epitomm.github.io/tag/CCBVjJbJH/" class="post-tag">
                  # 缓存
                </a>
              
                <a href="https://epitomm.github.io/tag/1hfOEuf6o1/" class="post-tag">
                  # 面试题
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="缓存预热">缓存预热</h1>
<h2 id="宕机">“宕机”</h2>
<p>服务器<strong>启动后迅速宕机</strong></p>
<h2 id="问题排查">问题排查</h2>
<ol>
<li>
<p>请求数量较高</p>
</li>
<li>
<p>主从之间数据吞吐量较大（不停地加载数据），数据同步操作频度较高</p>
</li>
</ol>
<blockquote>
<p>数据库读的频度高：服务器一启动，缓存中没有数据，自然就会给服务器带来压力，这时候如果请求比较多的话，redis 服务器就会宕机。</p>
</blockquote>
<h2 id="解决方案">解决方案</h2>
<p>前置准备工作：</p>
<ol>
<li>日常例行统计数据访问记录，统计访问频度较高的热点数据</li>
<li>利用LRU数据删除策略，构建数据留存队列
<ul>
<li>例如：storm与kafka配合</li>
</ul>
</li>
</ol>
<p>准备工作：</p>
<ol start="3">
<li>将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据</li>
<li>利用分布式多服务器同时进行数据读取，提速数据加载过程</li>
</ol>
<p>实施：</p>
<ol>
<li>使用脚本程序固定触发数据预热过程</li>
<li>如果条件允许，使用了CDN（内容分发网络），效果会更好</li>
</ol>
<h2 id="总结">总结</h2>
<p>缓存预热就是系统启动前，<strong>提前将相关的缓存数据直接加载到缓存系统</strong>。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<h1 id="缓存雪崩">缓存雪崩</h1>
<h2 id="数据库服务器崩溃1">数据库服务器崩溃（1）</h2>
<ol>
<li>系统平稳运行过程中，忽然数据库连接量激增</li>
<li>应用服务器无法及时处理请求</li>
<li>大量408，500错误页面出现</li>
<li>客户反复刷新页面获取数据</li>
<li>数据库崩溃</li>
<li>应用服务器崩溃</li>
<li>重启应用服务器无效</li>
<li>Redis服务器崩溃</li>
<li>Redis集群崩溃</li>
<li>重启数据库后再次被瞬间流量放倒</li>
</ol>
<h2 id="问题排查-2">问题排查</h2>
<ol>
<li>在一个<span style="color:red">较短</span>的时间内，缓存中较多的<span style="color:red">key集中过期 </span></li>
<li>此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据</li>
<li>数据库同时接收到大量的请求无法及时处理</li>
<li>Redis大量请求被积压，开始出现超时现象</li>
<li>数据库流量激增，数据库崩溃</li>
<li>重启后仍然面对缓存中无数据可用</li>
<li>Redis服务器资源被严重占用，Redis服务器崩溃</li>
<li>Redis集群呈现崩塌，集群瓦解</li>
<li>应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃</li>
<li>应用服务器，redis，数据库全部重启，效果不理想</li>
</ol>
<h2 id="问题分析">问题分析</h2>
<ul>
<li>短时间范围内</li>
<li>大量key集中过期</li>
</ul>
<h2 id="解决方案道">解决方案（道）</h2>
<ol>
<li>更多的页面静态化处理</li>
<li>构建多级缓存架构</li>
</ol>
<ul>
<li>Nginx缓存+redis缓存+ehcache缓存</li>
</ul>
<ol start="3">
<li>检测Mysql严重耗时业务进行优化</li>
</ol>
<ul>
<li>对数据库的瓶颈排查：例如超时查询、耗时较高事务等</li>
</ul>
<ol start="4">
<li>灾难预警机制</li>
</ol>
<ul>
<li>监控redis服务器性能指标
<ul>
<li>CPU占用、CPU使用率</li>
<li>内存容量</li>
<li>查询平均响应时间</li>
<li>线程数</li>
</ul>
</li>
</ul>
<ol start="5">
<li>限流、降级</li>
</ol>
<ul>
<li>短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问</li>
</ul>
<h2 id="解决方案术">解决方案（术）</h2>
<ol>
<li>LRU与LFU切换</li>
<li>数据有效期策略调整</li>
</ol>
<ul>
<li>根据业务数据有效期进行分类错峰，A类90分钟，B类80分钟，C类70分钟</li>
<li>过期时间使用固定时间+随机值的形式，稀释集中到期的key的数量</li>
</ul>
<ol start="3">
<li>超热数据使用永久key</li>
<li>定期维护（自动+人工）</li>
</ol>
<ul>
<li>对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时</li>
</ul>
<ol start="5">
<li>加锁</li>
</ol>
<ul>
<li>慎用！</li>
</ul>
<h2 id="总结-2">总结</h2>
<p>缓存雪崩就是<strong>瞬间过期数据量太大</strong>，导致对数据库服务器造成压力。如能够有<strong>效避免过期时间集中</strong>，可以有效解决雪崩现象的出现 （约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9-1.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>大量 key 集中过期，更多向 mysql 发起请求</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9-2.png" alt="图片" loading="lazy"></figure>
<h1 id="缓存击穿">缓存击穿</h1>
<h2 id="数据库服务器崩溃2">数据库服务器崩溃（2）</h2>
<ol>
<li>系统平稳运行过程中</li>
<li>数据库连接量瞬间激增</li>
<li>Redis服务器无大量key过期</li>
<li>Redis内存平稳，无波动</li>
<li>Redis服务器CPU正常</li>
<li>数据库崩溃</li>
</ol>
<h2 id="问题排查-3">问题排查</h2>
<ol>
<li>Redis中<strong>某个key过期，该key访问量巨大</strong></li>
<li>多个数据请求从服务器直接压到Redis后，均未命中</li>
<li>Redis在短时间内发起了大量对数据库中同一数据的访问</li>
</ol>
<h2 id="问题分析-2">问题分析</h2>
<ul>
<li>单个key高热数据</li>
<li>key过期</li>
</ul>
<h2 id="解决方案术-2">解决方案（术）</h2>
<ol>
<li>预先设定</li>
</ol>
<ul>
<li>以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时长</li>
<li>注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</li>
</ul>
<ol start="2">
<li>现场调整</li>
</ol>
<ul>
<li>监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key</li>
</ul>
<ol start="3">
<li>后台刷新数据</li>
</ol>
<ul>
<li>启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失</li>
</ul>
<ol start="4">
<li>二级缓存</li>
</ol>
<ul>
<li>设置不同的失效时间，保障不会被同时淘汰就行</li>
</ul>
<ol start="5">
<li>加锁</li>
</ol>
<ul>
<li>分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重！</li>
</ul>
<h2 id="总结-3">总结</h2>
<p>缓存击穿就是<strong>单个高热数据过期的瞬间，数据访问量较大</strong>，未命中redis后，发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度较高，配合雪崩处理策略即可。</p>
<h1 id="缓存穿透">缓存穿透</h1>
<h2 id="数据库服务器崩溃3">数据库服务器崩溃（3）</h2>
<ol>
<li>系统平稳运行过程中</li>
<li>应用服务器流量随时间增量较大</li>
<li>Redis服务器命中率随时间逐步降低</li>
<li>Redis内存平稳，内存无压力</li>
<li>Redis服务器CPU占用激增</li>
<li>数据库服务器压力激增</li>
<li>数据库崩溃</li>
</ol>
<h2 id="问题排查-4">问题排查</h2>
<ol>
<li>Redis中大面积出现未命中</li>
<li>出现非正常URL访问</li>
</ol>
<h2 id="问题分析-3">问题分析</h2>
<ul>
<li>获取的数据在数据库中也不存在，数据库查询未得到对应数据</li>
<li>Redis获取到null数据未进行持久化，直接返回</li>
<li>下次此类数据到达重复上述过程</li>
<li>出现黑客攻击服务器</li>
</ul>
<p><strong>解决方案（术）</strong></p>
<ol>
<li>缓存null</li>
</ol>
<ul>
<li>对查询结果为null的数据进行缓存（长期使用，定期清理），设定短时限，例如30-60秒，最高5分钟</li>
</ul>
<ol start="2">
<li>白名单策略</li>
</ol>
<ul>
<li>提前预热各种分类数据id对应的bitmaps，id作为bitmaps的offset，相当于设置了数据白名单。当加载正常数据时，放行，加载异常数据时直接拦截（效率偏低）</li>
<li>使用布隆过滤器（有关布隆过滤器的命中问题对当前状况可以忽略）</li>
</ul>
<ol start="3">
<li>实施监控</li>
</ol>
<ul>
<li>实时监控redis命中率（业务正常范围时，通常会有一个波动值）与null数据的占比
<ul>
<li>非活动时段波动：通常检测3-5倍，超过5倍纳入重点排查对象</li>
<li>活动时段波动：通常检测10-50倍，超过50倍纳入重点排查对象</li>
</ul>
</li>
<li>根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控（运营）</li>
</ul>
<ol start="4">
<li>key加密</li>
</ol>
<ul>
<li>问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验</li>
<li>例如每天随机分配60个加密串，挑选2到3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问</li>
</ul>
<h2 id="总结-4">总结</h2>
<p>缓存击穿<strong>访问了不存在的数据</strong>，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时报警。应对策略应该在临时预案防范方面多做文章。</p>
<p>无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除。</p>
<h1 id="性能指标监控">性能指标监控</h1>
<h2 id="监控指标">监控指标</h2>
<ul>
<li>性能指标：Performance</li>
<li>内存指标：Memory</li>
<li>基本活动指标：Basic activity</li>
<li>持久性指标：Persistence</li>
<li>错误指标：Error</li>
</ul>
<h3 id="性能指标performance">性能指标：Performance</h3>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Name</strong></th>
<th style="text-align:left"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">latency</td>
<td style="text-align:left">Redis响应一个请求的时间</td>
</tr>
<tr>
<td style="text-align:left">instantaneous_ops_per_sec</td>
<td style="text-align:left">平均每秒处理总数</td>
</tr>
<tr>
<td style="text-align:left">hit rate(calculate)</td>
<td style="text-align:left">缓存命中率（计算出来的）</td>
</tr>
</tbody>
</table>
<h3 id="内存指标memory">内存指标：Memory</h3>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Name</strong></th>
<th style="text-align:left"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">used_memory</td>
<td style="text-align:left">已使用内存</td>
</tr>
<tr>
<td style="text-align:left">mem_fragmentation_ratio</td>
<td style="text-align:left">内存碎片化</td>
</tr>
<tr>
<td style="text-align:left">evicted_keys</td>
<td style="text-align:left">由于最大内存限制被移除的 key 的数量</td>
</tr>
<tr>
<td style="text-align:left">blocked_clients</td>
<td style="text-align:left">由于 BLPOP、BRPOP、or BRPOPLPUSH 而备受阻塞的客户端</td>
</tr>
</tbody>
</table>
<h3 id="基本活动指标basic-activity">基本活动指标：Basic activity</h3>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Name</strong></th>
<th style="text-align:left"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">connected_clients</td>
<td style="text-align:left">客户端连接数</td>
</tr>
<tr>
<td style="text-align:left">connected_slaves</td>
<td style="text-align:left">Slave 数量</td>
</tr>
<tr>
<td style="text-align:left">master_last_io_seconds_ago</td>
<td style="text-align:left">最近一次主从交互之后的秒数</td>
</tr>
<tr>
<td style="text-align:left">keyspace</td>
<td style="text-align:left">数据库中的 key 值总数</td>
</tr>
</tbody>
</table>
<h3 id="持久性指标persistence">持久性指标：Persistence</h3>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Name</strong></th>
<th style="text-align:left"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">rdb_last_save_time</td>
<td style="text-align:left">最后一次持久化保存到磁盘的时间戳</td>
</tr>
<tr>
<td style="text-align:left">rdb_changes_since_last_save</td>
<td style="text-align:left">自最后一次持久化依赖数据库的更改数</td>
</tr>
</tbody>
</table>
<h3 id="错误指标error">错误指标：Error</h3>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Name</strong></th>
<th style="text-align:left"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">rejected_connections</td>
<td style="text-align:left">由于达到 maxclient 限制而被拒绝的连接数</td>
</tr>
<tr>
<td style="text-align:left">keyspace_misses</td>
<td style="text-align:left">key 值查找失败（没有命中）次数</td>
</tr>
<tr>
<td style="text-align:left">master_link_down_since_seconds</td>
<td style="text-align:left">主从断开的持续时间（以秒为单位）</td>
</tr>
</tbody>
</table>
<h2 id="监控方式">监控方式</h2>
<ul>
<li>工具
<ul>
<li>Cloud Insight Redis</li>
<li>Prometheus</li>
<li>Redis-stat</li>
<li>Redis-faina</li>
<li>RedisLive</li>
<li>zabbix</li>
</ul>
</li>
<li>命令
<ul>
<li>benchmark</li>
<li>redis cli
<ul>
<li>monitor</li>
<li>showlog</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="benchmark">benchmark</h2>
<ul>
<li>命令</li>
</ul>
<pre><code>redis-benchmark [-h ] [-p ] [-c ] [-n &lt;requests]&gt; [-k ] 
</code></pre>
<ul>
<li>范例1</li>
</ul>
<pre><code>[root@iZ2ze4u2bufi0915gyi843Z ~]# redis-benchmark 
</code></pre>
<p>说明：50个连接，10000次请求对应的性能</p>
<ul>
<li>范例2</li>
</ul>
<pre><code>redis-benchmark -c 100 -n 5000 
</code></pre>
<p>说明：100个连接，5000次请求对应的性能</p>
<h2 id="benchmark-2"><strong>benchmark</strong></h2>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/benchmark.png" alt="图片" loading="lazy"></figure>
<h2 id="monitor">monitor</h2>
<ul>
<li>命令</li>
</ul>
<pre><code>monitor 
</code></pre>
<p>打印服务器调试信息</p>
<h2 id="slowlog">slowlog</h2>
<ul>
<li>命令</li>
</ul>
<pre><code>slowlog [operator] 
</code></pre>
<ul>
<li>get ：获取慢查询日志</li>
<li>len ：获取慢查询日志条目数</li>
<li>reset ：重置慢查询日志</li>
<li>相关配置</li>
</ul>
<pre><code>slowlog-log-slower-than 1000 #设置慢查询的时间下线，单位：微妙 
slowlog-max-len 100 #设置慢查询命令对应的日志显示长度，单位：命令数
</code></pre>
<h1 id="总结-5">总结</h1>
<p>企业级解决方案</p>
<ul>
<li>缓存预热</li>
<li>缓存雪崩</li>
<li>缓存击穿</li>
<li>缓存穿透</li>
<li>性能指标监控
<ul>
<li>工具</li>
<li>命令</li>
</ul>
</li>
</ul>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD">缓存预热</a>
<ul>
<li><a href="#%E5%AE%95%E6%9C%BA">“宕机”</a></li>
<li><a href="#%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5">问题排查</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">解决方案</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
<li><a href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9">缓存雪崩</a>
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B4%A9%E6%BA%831">数据库服务器崩溃（1）</a></li>
<li><a href="#%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5-2">问题排查</a></li>
<li><a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90">问题分析</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E9%81%93">解决方案（道）</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%9C%AF">解决方案（术）</a></li>
<li><a href="#%E6%80%BB%E7%BB%93-2">总结</a></li>
</ul>
</li>
<li><a href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF">缓存击穿</a>
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B4%A9%E6%BA%832">数据库服务器崩溃（2）</a></li>
<li><a href="#%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5-3">问题排查</a></li>
<li><a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-2">问题分析</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%9C%AF-2">解决方案（术）</a></li>
<li><a href="#%E6%80%BB%E7%BB%93-3">总结</a></li>
</ul>
</li>
<li><a href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F">缓存穿透</a>
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B4%A9%E6%BA%833">数据库服务器崩溃（3）</a></li>
<li><a href="#%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5-4">问题排查</a></li>
<li><a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-3">问题分析</a></li>
<li><a href="#%E6%80%BB%E7%BB%93-4">总结</a></li>
</ul>
</li>
<li><a href="#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E7%9B%91%E6%8E%A7">性能指标监控</a>
<ul>
<li><a href="#%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87">监控指标</a>
<ul>
<li><a href="#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87performance">性能指标：Performance</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E6%8C%87%E6%A0%87memory">内存指标：Memory</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BB%E5%8A%A8%E6%8C%87%E6%A0%87basic-activity">基本活动指标：Basic activity</a></li>
<li><a href="#%E6%8C%81%E4%B9%85%E6%80%A7%E6%8C%87%E6%A0%87persistence">持久性指标：Persistence</a></li>
<li><a href="#%E9%94%99%E8%AF%AF%E6%8C%87%E6%A0%87error">错误指标：Error</a></li>
</ul>
</li>
<li><a href="#%E7%9B%91%E6%8E%A7%E6%96%B9%E5%BC%8F">监控方式</a></li>
<li><a href="#benchmark">benchmark</a></li>
<li><a href="#benchmark-2"><strong>benchmark</strong></a></li>
<li><a href="#monitor">monitor</a></li>
<li><a href="#slowlog">slowlog</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93-5">总结</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://epitomm.github.io/post/xian-cheng/">
              <h3 class="post-title">
                线程
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '974bd77fbbd52c2a0647',
    clientSecret: '6344370ca1314dbd553f45e75a2121a160ef1c44',
    repo: 'EpitomM.github.io',
    owner: 'EpitomM',
    admin: ['EpitomM'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/EpitomM/EpitomM.github.io" target="_blank">EpitomM</a>
  <a class="rss" href="https://epitomm.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
