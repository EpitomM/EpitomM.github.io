<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Spring系列（八）Spring源码解析 | SSM</title>
<link rel="shortcut icon" href="https://epitomm.github.io/favicon.ico?v=1589116480714">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://epitomm.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Spring系列（八）Spring源码解析 | SSM - Atom Feed" href="https://epitomm.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="public class Test {
   public static void main(String[] args) {
      // 初始化 Spring 环境
      // 1.准备工厂=DefaultListableBe..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://epitomm.github.io">
  <img class="avatar" src="https://epitomm.github.io/images/avatar.png?v=1589116480714" alt="">
  </a>
  <h1 class="site-title">
    SSM
  </h1>
  <p class="site-description">
    热心善良的老学姐
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Spring系列（八）Spring源码解析
            </h2>
            <div class="post-info">
              <span>
                2020-05-09
              </span>
              <span>
                34 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      // 初始化 Spring 环境
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // 注册 AppConfig.class
      context.register(AppConfig.class);
      // 解析 AppConfig.class
      context.refresh();
      IndexDao indexDao = context.getBean(IndexDaoImpl.class);
      indexDao.query();
   }
}
</code></pre>
<h1 id="1new-annotationconfigapplicationcontext">1.new AnnotationConfigApplicationContext();</h1>
<p>第 6-7 行代码：由于 AnnotationConfigApplicationContext 有父类，所以会先调用父类构造方法。</p>
<pre><code class="language-java">public class AnnotationConfigApplicationContext extends GenericApplicationContext implements AnnotationConfigRegistry {
</code></pre>
<p>父类构造方法 GenericApplicationContext() 中创建一个 DefaultListableBeanFactory 工厂：</p>
<pre><code class="language-java">public GenericApplicationContext() {
   this.beanFactory = new DefaultListableBeanFactory();
}
</code></pre>
<p>父类构造方法调用完成后，调用本类构造方法，初始化读取器 AnnotatedBeanDefinitionReader 和扫描器 ClassPathBeanDefinitionScanner：</p>
<pre><code class="language-java">public AnnotationConfigApplicationContext() {
   /**
    * 父类的构造方法 super()
    *创建一个读取注解的 Bean 定义读取器：reader 能读取被加了注解的类
    * 什么是 bean 定义？BeanDefinition
    */
   this.reader = new AnnotatedBeanDefinitionReader(this);
   // 定义扫描器
   // 可以用来扫描包，继而转换成 bd
   // 但是实际上我们扫描包工作不是 scanner 这个对象
   // 是 Spring 自己 new 的一个 ClasspathBeanDefinitionScanner
   // 这里的 scanner 仅仅是为了程序员能够在外部调用 AnnotationConfigApplicationContext 对象的 scan 方法用的。
   this.scanner = new ClassPathBeanDefinitionScanner(this);
}
</code></pre>
<h2 id="11-new-annotatedbeandefinitionreaderthis">1.1 new AnnotatedBeanDefinitionReader(this)</h2>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/7%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B.png" alt="图片" loading="lazy"></figure>
<h1 id="2contextrefresh">2.context.refresh();</h1>
<p>Test 类第 12 行代码：</p>
<pre><code class="language-java">context.refresh();
</code></pre>
<p>点进去如下：</p>
<pre><code class="language-java">public void refresh() throws BeansException, IllegalStateException {
   synchronized (this.startupShutdownMonitor) {
      // Prepare this context for refreshing.
      // 准备工作包括设置启动时间、是否激活标识位，初始化属性源（property source）配置
      prepareRefresh();
      // Tell the subclass to refresh the internal bean factory.
      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
      // Prepare the bean factory for use in this context.
      // 准备 Bean 工厂
      prepareBeanFactory(beanFactory);
      try {
         // Allows post-processing of the bean factory in context subclasses.
         // 这个方法在当前版本的 spring 是没有任何代码的
         // 可能 Spring 期待在后面的版本中去扩展吧
         postProcessBeanFactory(beanFactory);
         // Invoke factory processors registered as beans in the context.
         // 在 Spring 的环境中执行已经被注册的 factory processors
         // 设置执行自定义的 ProcessBeanFactory 和 Spring 内部自己定义的，比如 ConfigurationClassPostProcessor
         invokeBeanFactoryPostProcessors(beanFactory);
         // Register bean processors that intercept bean creation.
         registerBeanPostProcessors(beanFactory);
         // Initialize message source for this context.
         initMessageSource();
         // Initialize event multicaster for this context.
         initApplicationEventMulticaster();
         // Initialize other special beans in specific context subclasses.
         onRefresh();
         // Check for listener beans and register them.
         registerListeners();
         // Instantiate all remaining (non-lazy-init) singletons.
         finishBeanFactoryInitialization(beanFactory);
         // Last step: publish corresponding event.
         finishRefresh();
      }
      catch (BeansException ex) {
         if (logger.isWarnEnabled()) {
            logger.warn(&quot;Exception encountered during context initialization - &quot; +
                  &quot;cancelling refresh attempt: &quot; + ex);
         }
         // Destroy already created singletons to avoid dangling resources.
         destroyBeans();
         // Reset 'active' flag.
         cancelRefresh(ex);
         // Propagate exception to caller.
         throw ex;
      }
      finally {
         // Reset common introspection caches in Spring's core, since we
         // might not ever need metadata for singleton beans anymore...
         resetCommonCaches();
      }
   }
}
</code></pre>
<h2 id="21-preparebeanfactory">2.1 prepareBeanFactory</h2>
<p>上述代码第 12 行准备 Bean 工厂：</p>
<pre><code class="language-java">/**
 * 配置工厂标准的特征，比如上下文的加载器 ClassLoader 和 post-processors 回调
 * Configure the factory's standard context characteristics,
 * such as the context's ClassLoader and post-processors.
 * @param beanFactory the BeanFactory to configure
 */
protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
   // Tell the internal bean factory to use the context's class loader etc.
   beanFactory.setBeanClassLoader(getClassLoader());
   // bean 表达式解析器，能够在前台页面获取 bean 当中的属性
   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
   // 对象与 string 类型的转换 &lt;property ref=&quot;dao&quot;&gt; 将dao转为对象
   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));
   // Configure the bean factory with context callbacks.
   // 添加一个后置管理器：ApplicationContextAwareProcessor 实现了 BeanPostProcessor接口：插手 Bean 的创建过程
   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
   // 忽略接口
   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);
   // BeanFactory interface not registered as resolvable type in a plain factory.
   // MessageSource registered (and found for autowiring) as a bean.
   // 依赖替换：如果注入的是 BeanFactory，就用 beanFactory 替代
   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
   beanFactory.registerResolvableDependency(ResourceLoader.class, this);
   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
   beanFactory.registerResolvableDependency(ApplicationContext.class, this);
   // Register early post-processor for detecting inner beans as ApplicationListeners.
   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));
   // Detect a LoadTimeWeaver and prepare for weaving, if found.
   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
      // Set a temporary ClassLoader for type matching.
      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
   }
   // 意思是如果自定义的 Bean 中没有名为 &quot;systemProperties&quot; 和 &quot;systemEnvironment&quot; 的 Bean
   // 则注册两个 Bean，key 为 &quot;systemProperties&quot; 和 &quot;systemEnvironment&quot;, value 为 map
   // 这两个 Bean 就是一些系统配置和系统环境信息
   // Register default environment beans.
   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
   }
   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
   }
   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
   }
}
</code></pre>
<h2 id="22-invokebeanfactorypostprocessors">2.2 invokeBeanFactoryPostProcessors</h2>
<p>看 refresh 方法的第 23 行 ：</p>
<pre><code class="language-java">invokeBeanFactoryPostProcessors(beanFactory);
</code></pre>
<p>点进去这个方法：</p>
<pre><code class="language-java">protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
   // 这个地方需要注意 getBeanFactoryPostProcessors() 是获取手动给 Spring 的 BeanFactoryPostProcessor
   // 自定义的并不仅仅是程序员自己写的
   // 自己写的可以加 @Component,也可以不加，
   // 如果加了@Component这个getBeanFactoryPostProcessors()方法得不到，应该是 Spring 自己扫描的
   // 为什么得不到？因为 getBeanFactoryPostProcessors() 这个方法是直接获取一个 list，
   // 这个 list 是在 AnnotationConfigApplicationContext被定义
   // 所谓的自定义的就是你手动调用 AnnotationConfigApplicationContext.addBeanFactoryPostProcessor(new XxxBeanFactoryPostProcessor());
   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
   // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
   // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
   if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
   }
}
</code></pre>
<h3 id="221-getbeanfactorypostprocessors">2.2.1 getBeanFactoryPostProcessors</h3>
<p>上述代码第 9 行中的 getBeanFactoryPostProcessors()：</p>
<pre><code class="language-java">public List&lt;BeanFactoryPostProcessor&gt; getBeanFactoryPostProcessors() {
   return this.beanFactoryPostProcessors;
}
</code></pre>
<p>beanFactoryPostProcessors 变量的定义如下：</p>
<pre><code class="language-java">private final List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors = new ArrayList&lt;&gt;();
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E8%87%AA%E5%AE%9A%E4%B9%89beanFactoryPostProcessor.png" alt="图片" loading="lazy"></figure>
<h3 id="222-invokebeanfactorypostprocessors">2.2.2 invokeBeanFactoryPostProcessors</h3>
<p>同样的 invokeBeanFactoryPostProcessors 方法的第 9 行：</p>
<pre><code class="language-java">public static void invokeBeanFactoryPostProcessors(
      ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) {
   // Invoke BeanDefinitionRegistryPostProcessors first, if any.
   Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;();
   if (beanFactory instanceof BeanDefinitionRegistry) {
      BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
      // 定义两个 list， BeanDefinitionRegistryPostProcessor 实现了 BeanFactoryPostProcessor 接口
      // 因为 bdrp 是子类，子类扩展了父类中的功能。
      List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;();
      List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;(); 
      // 自定义的 beanFactoryPostProcessors
      // 因为传参，所以 beanFactoryPostProcessors 是 BeanFactoryPostProcessor 类型
      // 这里因为 beanFactoryPostProcessors长度为0，所以不会进入 for 循环 
      for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
         // 判断 postProcessor 是否是 BeanFactoryPostProcessor 的子类 BeanDefinitionRegistryPostProcessor
         if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
            BeanDefinitionRegistryPostProcessor registryProcessor =
                  (BeanDefinitionRegistryPostProcessor) postProcessor;
            registryProcessor.postProcessBeanDefinitionRegistry(registry);
            registryProcessors.add(registryProcessor);
         }
         else {
         // 如果 postProcessor 不是 BeanFactoryPostProcessor 的子类 BeanDefinitionRegistryPostProcessor，那 postProcessor 就一定是 BeanFactoryPostProcessor 类型，添加到 List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors 中
            regularPostProcessors.add(postProcessor);
         }
      }
      
      // 这个 currentRegistryProcessors 放的是 Spring 内部自己实现了 BeanDefinitionRegistryPostProcessor 接口的对象
      List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;();
      // BeanDefinitionRegistryPostProcessor 等于 BeanFactoryPostProcessor
      String[] postProcessorNames =
            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
      // 这个地方可以得到一个 BeanFactoryPostProcessor，因为是 Spring 默认在最开始自己注册的
      // 为什么要在最开始注册这个呢？
      // 因为 Spring 的工厂需要注解去扫描等等功能
      // 而这些功能都是需要在 Spring 工厂初始化完成之前就执行
      // 要么在工厂最开始的时候，要么在工厂初始化之中，反正不能在之后
      // 因为如果在之后就没有意义，因为那个时候已经需要使用工厂了
      // 所以这里 Spring 在一开始就注册了一个 BeanFactoryPostProcessor，用来插手 springFactory 的实例化过程
      // 在这个地方断点可以知道这个类叫做 ConfigurationClassPostProcessor
      // ConfigurationClassPostProcessor 那么这个类能干嘛呢？可以参考源码
      // 下面对这个“插手 Spring 工厂实例化过程”的类重点解释
      for (String ppName : postProcessorNames) {
         if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
         }
      }
      // 排序不重要，况且 currentRegistryProcessor 这里也只有一个数据
      sortPostProcessors(currentRegistryProcessors, beanFactory);
      // 合并 List，不重要（为什么要合并，因为有自定义的Spring自己的）
      registryProcessors.addAll(currentRegistryProcessors);
      // 最重要。注意这里是方法调用
      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
      currentRegistryProcessors.clear();
      // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
      for (String ppName : postProcessorNames) {
         if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
         }
      }
      sortPostProcessors(currentRegistryProcessors, beanFactory);
      registryProcessors.addAll(currentRegistryProcessors);
      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
      currentRegistryProcessors.clear();
      // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
      boolean reiterate = true;
      while (reiterate) {
         reiterate = false;
         postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
         for (String ppName : postProcessorNames) {
            if (!processedBeans.contains(ppName)) {
               currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
               processedBeans.add(ppName);
               reiterate = true;
            }
         }
         sortPostProcessors(currentRegistryProcessors, beanFactory);
         registryProcessors.addAll(currentRegistryProcessors);
         invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
         currentRegistryProcessors.clear();
      }
      // Now, invoke the postProcessBeanFactory callback of all processors handled so far.
      invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
      invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
   }
   else {
      // Invoke factory processors registered with the context instance.
      invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
   }
   // Do not initialize FactoryBeans here: We need to leave all regular beans
   // uninitialized to let the bean factory post-processors apply to them!
   String[] postProcessorNames =
         beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);
   // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
   // Ordered, and the rest.
   List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();
   List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();
   List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();
   for (String ppName : postProcessorNames) {
      if (processedBeans.contains(ppName)) {
         // skip - already processed in first phase above
      }
      else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
         priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
      }
      else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
         orderedPostProcessorNames.add(ppName);
      }
      else {
         nonOrderedPostProcessorNames.add(ppName);
      }
   }
   // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
   invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);
   // Next, invoke the BeanFactoryPostProcessors that implement Ordered.
   List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();
   for (String postProcessorName : orderedPostProcessorNames) {
      orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
   }
   sortPostProcessors(orderedPostProcessors, beanFactory);
   invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);
   // Finally, invoke all other BeanFactoryPostProcessors.
   List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();
   for (String postProcessorName : nonOrderedPostProcessorNames) {
      nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
   }
   invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);
   // Clear cached merged bean definitions since the post-processors might have
   // modified the original metadata, e.g. replacing placeholders in values...
   beanFactory.clearMetadataCache();
}
</code></pre>
<p>上述第 11、12、31 行分别定义了一个 List：</p>
<ul>
<li>List<BeanFactoryPostProcessor> regularPostProcessors：放程序员手动添加的 BeanFactoryPostProcessor</li>
<li>List<BeanDefinitionRegistryPostProcessor> registryProcessors：放程序员手动添加的 BeanDefinitionRegistryPostProcessor</li>
<li>List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors：放 Spring 内部自己的 BeanDefinitionRegistryPostProcessor</li>
</ul>
<p>上述第 35-36 行代码：</p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/currentRegistryProcessors.png" alt="图片" loading="lazy"></figure>
<p>上述第 47-51 行代码：</p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/postProcessorNames.png" alt="图片" loading="lazy"></figure>
<p>上述代码第 58 行：</p>
<pre><code class="language-java">private static void invokeBeanDefinitionRegistryPostProcessors(
      Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry) {
   for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
      postProcessor.postProcessBeanDefinitionRegistry(registry);
   }
}
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/postProcessors.png" alt="图片" loading="lazy"></figure>
<p>点进去上述第  5 行代码：</p>
<pre><code class="language-java">@Override
public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
   int registryId = System.identityHashCode(registry);
   if (this.registriesPostProcessed.contains(registryId)) {
      throw new IllegalStateException(
            &quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot; + registry);
   }
   if (this.factoriesPostProcessed.contains(registryId)) {
      throw new IllegalStateException(
            &quot;postProcessBeanFactory already called on this post-processor against &quot; + registry);
   }
   this.registriesPostProcessed.add(registryId);
   processConfigBeanDefinitions(registry);
}
</code></pre>
<h4 id="2221-processconfigbeandefinitions">2.2.2.1 processConfigBeanDefinitions</h4>
<p>点进上述第 14 行代码：</p>
<pre><code class="language-java">public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
   // app 提供的 bean：每扫描到添加了 @Configuraion 注解的类就添加到这个 set 集合中
   List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;();
   // 获取容器中注册的所有 bean 名字
   String[] candidateNames = registry.getBeanDefinitionNames();
   // 依次取出每个&lt;beanName,beanDefinition&gt;
   for (String beanName : candidateNames) {
      BeanDefinition beanDef = registry.getBeanDefinition(beanName);
      // 判断当前 bean 是否被处理过：使用 isFullConfigurationClass 来标识
      if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
            ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {
         // 如果 BeanDefinition 中的 configurationClass 属性为 full 或者 lite，则意味着已经处理过了，直接跳过
         // 这里需要结合下面的代码才能理解
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Bean definition has already been processed as a configuration class: &quot; + beanDef);
         }
      }
      // 判断这个 BeanDefinition 是否是 Configuration类，这其实主要是看是否有
      else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
         configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
      }
   }
   // Return immediately if no @Configuration classes were found
   if (configCandidates.isEmpty()) {
      return;
   }
   // 排序，根据 order，不重要
   // Sort by previously determined @Order value, if applicable
   configCandidates.sort((bd1, bd2) -&gt; {
      int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
      int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
      return Integer.compare(i1, i2);
   });
   // Detect any custom bean name generation strategy supplied through the enclosing application context
   SingletonBeanRegistry sbr = null;
   // 如果 BeanDefinitionRegistry 是 SingletonBeanRegistry 子类的话
   // 由于会将 registry 强转为 SingletonBeanRegistry
   if (registry instanceof SingletonBeanRegistry) {
      sbr = (SingletonBeanRegistry) registry;
      if (!this.localBeanNameGeneratorSet) {//是否有自定义的
         BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);
         // SingletonBeanRegistry 中有 id 为 org.springframework.context.annotation.internalConfigurationBeanNameGenerator
         // 如果有则利用它的，否则则使用 Spring 默认的
         if (generator != null) {
            this.componentScanBeanNameGenerator = generator;
            this.importBeanNameGenerator = generator;
         }
      }
   }
   if (this.environment == null) {
      this.environment = new StandardEnvironment();
   }
   // Parse each @Configuration class
   // 实例化 ConfigurationClassParser 为了解析各个配置类
   ConfigurationClassParser parser = new ConfigurationClassParser(
         this.metadataReaderFactory, this.problemReporter, this.environment,
         this.resourceLoader, this.componentScanBeanNameGenerator, registry);
   // 实例化 2 个 set，candidates 用于将之前加入的 configCandidates 进行去重
   // 因为可能有多个配置类重复了
   // alreadyParsed 用户判断是否处理过
   Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates);
   Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size());
   do {
      parser.parse(candidates);
      parser.validate();
      Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());
      configClasses.removeAll(alreadyParsed);
      // Read the model and create bean definitions based on its content
      if (this.reader == null) {
         this.reader = new ConfigurationClassBeanDefinitionReader(
               registry, this.sourceExtractor, this.resourceLoader, this.environment,
               this.importBeanNameGenerator, parser.getImportRegistry());
      }
      // 把扫描出来的 bean 对应的 beanDefinitions 添加到 factory 的 map 当中
      this.reader.loadBeanDefinitions(configClasses);
      alreadyParsed.addAll(configClasses);
      candidates.clear();
      if (registry.getBeanDefinitionCount() &gt; candidateNames.length) {
         String[] newCandidateNames = registry.getBeanDefinitionNames();
         Set&lt;String&gt; oldCandidateNames = new HashSet&lt;&gt;(Arrays.asList(candidateNames));
         Set&lt;String&gt; alreadyParsedClasses = new HashSet&lt;&gt;();
         for (ConfigurationClass configurationClass : alreadyParsed) {
            alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
         }
         for (String candidateName : newCandidateNames) {
            if (!oldCandidateNames.contains(candidateName)) {
               BeanDefinition bd = registry.getBeanDefinition(candidateName);
               if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp;
                     !alreadyParsedClasses.contains(bd.getBeanClassName())) {
                  candidates.add(new BeanDefinitionHolder(bd, candidateName));
               }
            }
         }
         candidateNames = newCandidateNames;
      }
   }
   while (!candidates.isEmpty());
   // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes
   if (sbr != null &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {
      sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
   }
   if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {
      // Clear cache in externally provided MetadataReaderFactory; this is a no-op
      // for a shared cache since it'll be cleared by the ApplicationContext.
      ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();
   }
}
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/getBeanDefinitionNames.png" alt="图片" loading="lazy"></figure>
<h5 id="22211-checkconfigurationclasscandidate">2.2.2.1.1 checkConfigurationClassCandidate</h5>
<p>上述代码第 19 行：</p>
<pre><code class="language-java">else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
</code></pre>
<p>refresh() 的主要功能是要解析类：Spring 认为添加了@Configuration、@Component、@Import...注解的类都是需要解析的类。<br>
如何将一个 User 类变成 BeanDefinition：XxxBeanDefinition bd = new XxxBeanDefinition(user);</p>
<p>Spring 如何判断一个类是否是应该解析的类？</p>
<p>①判断一个 bd 是否被加了注解（AnnotatedBeanDefinition abd = new AnnotatedBeanDefinition(AppConfig.class); register.regisyBD(abd); ）；②把信息（元数据）拿出来；③根据信息判断加了什么注解</p>
<pre><code class="language-java">public static boolean checkConfigurationClassCandidate(BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) {
   String className = beanDef.getBeanClassName();
   if (className == null || beanDef.getFactoryMethodName() != null) {
      return false;
   }
   AnnotationMetadata metadata;
   // 判断这个 bd 是否被加了注解
   if (beanDef instanceof AnnotatedBeanDefinition &amp;&amp;
         className.equals(((AnnotatedBeanDefinition) beanDef).getMetadata().getClassName())) {
      // Can reuse the pre-parsed metadata from the given BeanDefinition...
      // 如果 BeanDefinition 是 AnnotatedBeanDefinition 的实例，并且 className 和 BeanDefinition 中的元数据的类名相同
      // 则直接从 BeanDefinition 获得元数据Metadata
      metadata = ((AnnotatedBeanDefinition) beanDef).getMetadata();
   }
   else if (beanDef instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) beanDef).hasBeanClass()) {
      // Check already loaded Class if present...
      // since we possibly can't even load the class file for this Class.
      // 如果 BeanDefinition 是 AbstractBeanDefinition 的实例，并且 beanDef 有 beanClass 属性存在
      // 则实例化 StandardAnnotationMetadata
      Class&lt;?&gt; beanClass = ((AbstractBeanDefinition) beanDef).getBeanClass();
      metadata = new StandardAnnotationMetadata(beanClass, true);
   }
   else {
      try {
         MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);
         metadata = metadataReader.getAnnotationMetadata();
      }
      catch (IOException ex) {
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Could not find class file for introspecting configuration annotations: &quot; + className, ex);
         }
         return false;
      }
   }
   // 判断当前这个 bd 中存在的类是不是加了 @Configuration 注解，但是如果加了 @Configuration，下面的这几个注解就不再判断，因为这是一个 if-else if 分支
   // 只有满足了 &quot;没有加 @Configuration注解&quot;，才会走 else 分支去判断是否添加了其他注解
   if (isFullConfigurationCandidate(metadata)) {
      // 如果存在 Configuration 注解，则为 BeanDefinition 设置 configurationClass 属性为 FULL
      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);
   }
   // 判断是否加了以下注解，摘录 isLiteConfigurationCandidate 的源码
   // candidateIndicators.add(Component.class.getName());
   // candidateIndicators.add(ComponentScan.class.getName());
   // candidateIndicators.add(Import.class.getName());
   // candidateIndicators.add(ImportResource.class.getName());
   else if (isLiteConfigurationCandidate(metadata)) {
      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
   }
   else {
      return false;
   }
   // It's a full or lite configuration candidate... Let's determine the order value, if any.
   Integer order = getOrder(metadata);
   if (order != null) {
      beanDef.setAttribute(ORDER_ATTRIBUTE, order);
   }
   return true;
}
</code></pre>
<p>上述代码第 39 行，判断是否加了 @Configuration 注解</p>
<pre><code class="language-java">public static boolean isFullConfigurationCandidate(AnnotationMetadata metadata) {
   return metadata.isAnnotated(Configuration.class.getName());
}
</code></pre>
<p>上述代码第 48 行，判断是否加了其他注解：</p>
<pre><code class="language-java">public static boolean isLiteConfigurationCandidate(AnnotationMetadata metadata) {
   // Do not consider an interface or an annotation...
   if (metadata.isInterface()) {
      return false;
   }
   // Any of the typical annotations found?
   for (String indicator : candidateIndicators) {
      if (metadata.isAnnotated(indicator)) {
         return true;
      }
   }
   // Finally, let's look for @Bean methods...
   try {
      return metadata.hasAnnotatedMethods(Bean.class.getName());
   }
   catch (Throwable ex) {
      if (logger.isDebugEnabled()) {
         logger.debug(&quot;Failed to introspect @Bean methods on class [&quot; + metadata.getClassName() + &quot;]: &quot; + ex);
      }
      return false;
   }
}
</code></pre>
<p>上述代码第 8 行中提到的 candidateIndicators</p>
<pre><code class="language-java">private static final Set&lt;String&gt; candidateIndicators = new HashSet&lt;&gt;(8);
static {
   candidateIndicators.add(Component.class.getName());
   candidateIndicators.add(ComponentScan.class.getName());
   candidateIndicators.add(Import.class.getName());
   candidateIndicators.add(ImportResource.class.getName());
}
</code></pre>
<p>关于 39-48 行的 if-else if 判断是否添加注解，其中 &quot;eles if&quot; 分支的作用，补充说明：</p>
<ul>
<li>如果一个类添加了 @Configuration，Spring 把它扫描出来，知道它是一个配置类，然后再去解析这个类，就可以依次扫描到其他注解：@ComponentScan、@Import</li>
<li>但是如果一个类没有添加 @Configuration 注解，只加入了 @ImportResource(&quot;spring.xml&quot;) 注解，这时候就需要使用到上述的 eles if 分支单独进行处理。</li>
</ul>
<p>上述 processConfigBeanDefinitions 方法的第 79 行：</p>
<pre><code class="language-java">parser.parse(candidates);
</code></pre>
<p>点进这个方法：</p>
<pre><code class="language-java">public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) {
   this.deferredImportSelectors = new LinkedList&lt;&gt;();
   // 根据 BeanDefinition 的类型做不同的处理，一般都会调用 ConfigurationClassParse#parse 进行解析
   for (BeanDefinitionHolder holder : configCandidates) {
      BeanDefinition bd = holder.getBeanDefinition();
      try {
         // 判断这个 bd 是否被加了注解
         if (bd instanceof AnnotatedBeanDefinition) {
            parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
         }
         else if (bd instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) {
            parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
         }
         else {
            parse(bd.getBeanClassName(), holder.getBeanName());
         }
      }
      catch (BeanDefinitionStoreException ex) {
         throw ex;
      }
      catch (Throwable ex) {
         throw new BeanDefinitionStoreException(
               &quot;Failed to parse configuration class [&quot; + bd.getBeanClassName() + &quot;]&quot;, ex);
      }
   }
   processDeferredImportSelectors();
}
</code></pre>
<p>上述代码第 9 行：</p>
<pre><code class="language-java">parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
</code></pre>
<p>点进这个方法：</p>
<pre><code class="language-java">protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {
   processConfigurationClass(new ConfigurationClass(metadata, beanName));
}
</code></pre>
<p>点进第 2 行这个方法：</p>
<pre><code class="language-java">protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
   // 判断是否应该跳过解析
   if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
      return;
   }
   // 处理 Imported 的情况
   ConfigurationClass existingClass = this.configurationClasses.get(configClass);
   if (existingClass != null) {
      if (configClass.isImported()) {
         if (existingClass.isImported()) {
            existingClass.mergeImportedBy(configClass);
         }
         // Otherwise ignore new imported config class; existing non-imported class overrides it.
         return;
      }
      else {
         // Explicit bean definition found, probably replacing an import.
         // Let's remove the old one and go with the new one.
         this.configurationClasses.remove(configClass);
         this.knownSuperclasses.values().removeIf(configClass::equals);
      }
   }
   // Recursively process the configuration class and its superclass hierarchy.
   SourceClass sourceClass = asSourceClass(configClass);
   do {
      sourceClass = doProcessConfigurationClass(configClass, sourceClass);
   }
   while (sourceClass != null);
   // 一个 map，用来存放扫描出来的 bean（注意这里的 bean 不是对象，仅仅是 bean 的信息，因为还没到实例化）
   this.configurationClasses.put(configClass, configClass);
}
</code></pre>
<p>上述代码第 28 行：</p>
<pre><code class="language-java">@Nullable
protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)
      throws IOException {
   // Recursively process any member (nested) classes first
   // 处理内部类
   processMemberClasses(configClass, sourceClass);
   // Process any @PropertySource annotations
   for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
         sourceClass.getMetadata(), PropertySources.class,
         org.springframework.context.annotation.PropertySource.class)) {
      if (this.environment instanceof ConfigurableEnvironment) {
         processPropertySource(propertySource);
      }
      else {
         logger.warn(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() +
               &quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;);
      }
   }
   // Process any @ComponentScan annotations
   Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(
         sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
   if (!componentScans.isEmpty() &amp;&amp;
         !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
      for (AnnotationAttributes componentScan : componentScans) {
         // The config class is annotated with @ComponentScan -&gt; perform the scan immediately
         Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =
               this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
         // Check the set of scanned definitions for any further config classes and parse recursively if needed
         // 检查扫描出来的类当中是否还有 Configuration
         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
            BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
            if (bdCand == null) {
               bdCand = holder.getBeanDefinition();
            }
            if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
               parse(bdCand.getBeanClassName(), holder.getBeanName());
            }
         }
      }
   }
   // Process any @Import annotations
   // 处理 @Import
   processImports(configClass, sourceClass, getImports(sourceClass), true);
   // Process any @ImportResource annotations
   AnnotationAttributes importResource =
         AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
   if (importResource != null) {
      String[] resources = importResource.getStringArray(&quot;locations&quot;);
      Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;);
      for (String resource : resources) {
         String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
         configClass.addImportedResource(resolvedResource, readerClass);
      }
   }
   // Process individual @Bean methods
   Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
   for (MethodMetadata methodMetadata : beanMethods) {
      configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
   }
   // Process default methods on interfaces
   processInterfaces(configClass, sourceClass);
   // Process superclass, if any
   if (sourceClass.getMetadata().hasSuperClass()) {
      String superclass = sourceClass.getMetadata().getSuperClassName();
      if (superclass != null &amp;&amp; !superclass.startsWith(&quot;java&quot;) &amp;&amp;
            !this.knownSuperclasses.containsKey(superclass)) {
         this.knownSuperclasses.put(superclass, configClass);
         // Superclass found, return its annotation metadata and recurse
         return sourceClass.getSuperClass();
      }
   }
   // No superclass -&gt; processing is complete
   return null;
}
</code></pre>
<p>上述代码第 47 行，判断有没有加 Import 标签</p>
<pre><code class="language-java">private Set&lt;SourceClass&gt; getImports(SourceClass sourceClass) throws IOException {
   Set&lt;SourceClass&gt; imports = new LinkedHashSet&lt;&gt;();
   Set&lt;SourceClass&gt; visited = new LinkedHashSet&lt;&gt;();
   collectImports(sourceClass, imports, visited);
   return imports;
}
</code></pre>
<p>@Import 注解：</p>
<ul>
<li>@Import(IndexDao.class)、</li>
<li>@Import(ImportSelector)、</li>
<li>@Import(ImportBeanDefinitionRegistrar)</li>
</ul>
<p>同样的上述代码第 47 行：</p>
<pre><code class="language-java">private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,
      Collection&lt;SourceClass&gt; importCandidates, boolean checkForCircularImports) {
   // 如果没有加@Import，直接返回
   if (importCandidates.isEmpty()) {
      return;
   }
   if (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) {
      this.problemReporter.error(new CircularImportProblem(configClass, this.importStack));
   }
   else {
      this.importStack.push(configClass);
      try {
         for (SourceClass candidate : importCandidates) {
            // @Import(IndexDao.class)、@Import(ImportSelector)、@Import(ImportBeanDefinitionRegistrar)
            // 判断是不是 ImportSelector
            if (candidate.isAssignable(ImportSelector.class)) {
               // Candidate class is an ImportSelector -&gt; delegate to it to determine imports
               Class&lt;?&gt; candidateClass = candidate.loadClass();
               ImportSelector selector = BeanUtils.instantiateClass(candidateClass, ImportSelector.class);
               ParserStrategyUtils.invokeAwareMethods(
                     selector, this.environment, this.resourceLoader, this.registry);
               if (this.deferredImportSelectors != null &amp;&amp; selector instanceof DeferredImportSelector) {
                  this.deferredImportSelectors.add(
                        new DeferredImportSelectorHolder(configClass, (DeferredImportSelector) selector));
               }
               else {
                  String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
                  Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames);
                  processImports(configClass, currentSourceClass, importSourceClasses, false);
               }
            }
            // 判断是不是 ImportBeanDefinitionRegistrar
            else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
               // Candidate class is an ImportBeanDefinitionRegistrar -&gt;
               // delegate to it to register additional bean definitions
               Class&lt;?&gt; candidateClass = candidate.loadClass();
               ImportBeanDefinitionRegistrar registrar =
                     BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);
               ParserStrategyUtils.invokeAwareMethods(
                     registrar, this.environment, this.resourceLoader, this.registry);
               configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
            }
            // 普通类：@Import(IndexDao.class)
            else {
               // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt;
               // process it as an @Configuration class
               this.importStack.registerImport(
                     currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
               processConfigurationClass(candidate.asConfigClass(configClass));
            }
         }
      }
      catch (BeanDefinitionStoreException ex) {
         throw ex;
      }
      catch (Throwable ex) {
         throw new BeanDefinitionStoreException(
               &quot;Failed to process import candidates for configuration class [&quot; +
               configClass.getMetadata().getClassName() + &quot;]&quot;, ex);
      }
      finally {
         this.importStack.pop();
      }
   }
}
</code></pre>
<p>插手 Spring 中 Bean 工厂的建设：<br>
BeanFactoryPostProcessor：把它设置为一个 Bean 的属性。</p>
<p>ImportBeanDefinitionRegistrar：把 map 暴露出来，用户就可以向 map 中动态添加 bean 了。</p>
<h1 id="注册-bean-的方法">注册 Bean 的方法</h1>
<h2 id="registerindexdaoimplclass">register(IndexDaoImpl.class);</h2>
<ul>
<li>bdmap.put()</li>
<li>需要的是一个类，一个类变成 BeanDefinition 的过程是没办法参与的</li>
</ul>
<h2 id="scancomssm">scan(&quot;com.ssm&quot;)</h2>
<ul>
<li>需要的是一个类，一个类变成 BeanDefinition 的过程是没办法参与的</li>
</ul>
<h2 id="importbeandefinitionregistrar">ImportBeanDefinitionRegistrar</h2>
<ul>
<li>向 map 中添加一个 bd</li>
<li>好处：可以参与一个类变成 BeanDefinition 的过程</li>
</ul>
<p>@MapperScan() 的作用：扫描 mapper</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
@MapperScan(&quot;com.ssm.dao&quot;)
public class AppConfig{
    @Bean
    public DataSource dataSource(){
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
        dataSource.setUsername(&quot;root&quot;);
        dataSource.setPassword(&quot;123456&quot;);
        dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/card&quot;);
        return dataSource;
    }
    @Bean
    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){
        SqlSessionFactoryBean sqlSessionFactoryBean =  new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource);
        return sqlSessionFactoryBean;
    }
}
</code></pre>
<pre><code class="language-java">@Component
public class CardService{
  @Autowired
  CardDao cardDao;
  public void list(){
    System.out.println(cardDao.list(&quot;xxx&quot;));
  }
}
</code></pre>
<pre><code class="language-java">public interface CardDao{
  @Select(&quot;select * from card where card_number like '%s{number}%'&quot;)
  public List&lt;Map&lt;Integer,String&gt;&gt; list(@Param(&quot;number&quot;) String number);
}
</code></pre>
<p>CardDao 是一个接口，一个接口如何变成一个对象？</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        context.getBean(CardService.class).list();
    }
}
</code></pre>
<p>@MapperScan() ：将一个接口变成一个对象，且把变成的这个对象放到 Spring 容器中。</p>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Import(MapperScannerRegistrar.class)
public @interface MapperScan {
</code></pre>
<p>Spring 在解析到 @MapperScan 后，又会去解析 @Import，然后再解析 MapperScannerRegistrar<br>
MapperScannerRegistrar 类中有一个 registerBeanDefinitions 方法，此方法有一个参数是 BeanDefinitionRegistry，即把注册器暴露出来，就可以向容器中添加 Bean 了，这个方法是在所有 Bean 执行之前执行的：</p>
<pre><code class="language-java">public class MapperScannerRegistrar implements ImportBeanDefinitionRegistrar, ResourceLoaderAware {
  private ResourceLoader resourceLoader;
  /**
   * {@inheritDoc}
   */
  @Override
  public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
</code></pre>
<p>@Autowired<br>
CardDao cardDao;</p>
<p>如果有一个类 A extends CardService，不会将类 A 自动注入给 CardDao。如果有一个类 A implements CardDao，会将类 A 注入给 CardDao。</p>
<p>模拟 Mybatis：在现在的基础上完成：① 创建一个对象；② 对象实现 CardDao 接口； ③这个对象在 Spring 容器中。</p>
<h3 id="让一个接口变成对象代理">让一个接口变成对象：代理</h3>
<p>1.测试类</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        CardDao cardDao = (CardDao) Proxy.newProxyInstance(Test.class.getClassLoader(), new Class[]{CardDao.class}, new MyInvocationHandler());
        cardDao.list(&quot;1&quot;);
    }
}
</code></pre>
<p>2.MyInvocationHandler</p>
<pre><code class="language-java">public class MyInvocationHandler implements InvocationHandler {
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;handler...&quot;);
        return null;
    }
}
</code></pre>
<p>3.输出结果：</p>
<pre><code>handler...
</code></pre>
<p>4.分析：<br>
通过 JDK 动态代理生成一个对象，执行代理方法时打印了 handler...</p>
<p>上述步骤 1、2、3、4 已经实现了① 创建一个对象；② 对象实现 CardDao 接口，接下来实现步骤 ③将这个对象放到 Spring 容器中</p>
<h3 id="将对象放到-spring-容器中">将对象放到 Spring 容器中</h3>
<h4 id="方法一实现-beanfactorypostprocessor-接口">方法一：实现 BeanFactoryPostProcessor 接口</h4>
<pre><code class="language-java">// 对 Bean 工厂进行插手，只能对 Bean 工厂进行初始化，不能将对象放入到 map 中，没有对应API
public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
    }
}
</code></pre>
<h4 id="方法二实现-importselector-接口">方法二：实现 ImportSelector  接口</h4>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
@MapperScan(&quot;com.ssm&quot;)
// Spring 把 MyImportSelect 类中 invoke 方法返回的字符串数组类名 new 出对象放到 Spring 工厂中
@Import(MyImportSelect.class) 
public class AppConfig{
</code></pre>
<pre><code class="language-java">public class MyImportSelect implements ImportSelector {
    @Override
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        // 因为是要将代理对象放到Spring工厂中，但是这里得不到代理对象的类名
        return new String[]{CardDaoProxy.class.getSimpleName()};
    }
}
</code></pre>
<p>必须先产生代理对象出来，然后再来执行：Spring 扫描 @Import 注解，将 MyImportSelect 类中 invoke 方法返回的字符串数组类名 new 出对象放到 Spring 工厂中。</p>
<h4 id="方法三实现-importbeandefinitionregistrar-接口">方法三：实现 ImportBeanDefinitionRegistrar  接口</h4>
<p>1、实现 ImportBeanDefinitionRegistrar  接口：创建代理对象，并添加到 Spring 容器中</p>
<pre><code class="language-java">public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        // 1.得到 BeanDefinition
            // 扫描所有接口：扫描 com.ssm.dao 下所有接口。这里为了方便写死，不模拟动态了
        // carDao：代理对象
        CardDao cardDao = (CardDao) Proxy.newProxyInstance(Test.class.getClassLoader(), new Class[]{CardDao.class}, new MyInvocationHandler());
        cardDao.list(&quot;2&quot;);
        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(cardDao.getClass());
        GenericBeanDefinition beanDefinition = (GenericBeanDefinition) builder.getBeanDefinition();
        registry.registerBeanDefinition(&quot;cardDao&quot;,beanDefinition);
    }
}
</code></pre>
<p>2、配置类扫描 MyImportBeanDefinitionRegistrar</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
@MapperScan(&quot;com.ssm&quot;)
@Import(MyImportBeanDefinitionRegistrar.class)
public class AppConfig{
</code></pre>
<p>3、测试类：初始化 Spring 容器</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
    }
}
</code></pre>
<p>5、测试结果：</p>
<pre><code>handler...
Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'cardDao': Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'java.lang.reflect.InvocationHandler' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {}
</code></pre>
<p>6、分析<br>
代理对象的代理方法执行了（证明 cardDao.list(&quot;2&quot;) 执行到了），但是代理对象注入不进来，因为 Spring 没有办法这样处理一个类，这个 dao 中的某些属性 Spring 没有注入进来。</p>
<pre><code class="language-java">public class MyInvocationHandler implements InvocationHandler {
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;proxy...&quot;);
        return null;
    }
}
</code></pre>
<p>7、接口不能实例化</p>
<pre><code class="language-java">public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        // 得到 BeanDefinition(扫描所有接口：扫描 com.ssm.dao 下所有接口。这里为了方便写死，不模拟动态了)
        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(CardDao.class);
        // 得到 BeanDefinition，BeanDefinition 有一个属性 beanClass 表示类型 CardDao.class
        GenericBeanDefinition beanDefinition = (GenericBeanDefinition) builder.getBeanDefinition();
        registry.registerBeanDefinition(&quot;cardDao&quot;,beanDefinition);
    }
}
</code></pre>
<pre><code>Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.ssm.dao.CardDao]: Specified class is an interface
</code></pre>
<p>根据 beanName=&quot;cardDao&quot; 取出 BeanDefinition，当执行完上述第 5 行代码后，取出的 BeanDefinition 类型为 CardDao 接口，接口不能实例化。<br>
所以需要将一个代理对象放入 map 中，{ beanName=&quot;dao&quot;, BeanDefinition={beanClass=$Proxy01.class; ...} }</p>
<p>8、引入 FactoryBean</p>
<pre><code class="language-java">public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        // 得到 BeanDefinition(扫描所有接口：扫描 com.ssm.dao 下所有接口。这里为了方便写死，不模拟动态了)
        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(CardDao.class);
        // 得到 BeanDefinition，BeanDefinition 有一个属性 beanClass 表示类型 CardDao
        GenericBeanDefinition beanDefinition = (GenericBeanDefinition) builder.getBeanDefinition();
        // 给 BeanDefinition 添加构造方法，因为 public MyFactoryBean(Class clazz) { 构造方法有参数
        beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(&quot;com.ssm.dao.CardDao&quot;);
        // 设置 BeanDefinition 的 beanClass 为代理对象
        beanDefinition.setBeanClass(MyFactoryBean.class);
        registry.registerBeanDefinition(&quot;cardDao&quot;,beanDefinition);
    }
}
</code></pre>
<p>如果类实现了 FactoryBean，那么 Spring 容器当中存在两个对象，一个是 getObject() 方法返回的代理对象（name=&quot;myFactoryBean &quot;）；还有一个是当前对象 MyFactoryBean（name=&amp;myFactoryBean ） 。</p>
<pre><code class="language-java">public class MyFactoryBean implements FactoryBean, InvocationHandler {
    Class clazz;
    public MyFactoryBean(Class clazz) {
        this.clazz = clazz;
    }
    @Override
    public Object getObject() throws Exception {
        Class[] clazzs = new Class[]{clazz};
        Object proxy = Proxy.newProxyInstance(this.getClass().getClassLoader(),clazzs,this);
        return proxy;
    }
    @Override
    public Class&lt;?&gt; getObjectType() {
        return clazz;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 得到代理对象的接口，通过名字去拿方法
        Method method1 = proxy.getClass().getInterfaces()[0].getMethod(method.getName(), String.class);
        // 拿到这个方法的注解
        Select select = method1.getDeclaredAnnotation(Select.class);
        System.out.println(String.valueOf(select.value()[0]));
        System.out.println(&quot;proxy&quot;);
        return null;
    }
}
</code></pre>
<p>自定义注解：</p>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
@Import(MyImportBeanDefinitionRegistrar.class)
public @interface LuBanScan {
    String value();
}
</code></pre>
<p>配置类：</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
@LuBanScan(&quot;com.ssm&quot;)
@Import(MyImportBeanDefinitionRegistrar.class)
public class AppConfig{
</code></pre>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        CardDao cardDao = (CardDao) context.getBean(&quot;cardDao&quot;);
        cardDao.list(&quot;2&quot;);
    }
}
</code></pre>
<p>测试结果：</p>
<pre><code>select * from t1 where a=#{number}
proxy
</code></pre>
<h1 id="mybatis">MyBatis</h1>
<pre><code class="language-xml">&lt;bean id=&quot;userMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;
  &lt;property name=&quot;mapperInterface&quot; value=&quot;org.mybatis.spring.sample.mapper.UserMapper&quot; /&gt;
  &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p>如果不想使用 @MapperScan，采用上述代码同样可以完成扫描 mapper 的功能。上述代码不是将 UserMapper 注册给 MapperFactoryBean。<br>
正确含义：MapperFactoryBean 就是前面手动模拟的 MyFactoryBean：</p>
<pre><code class="language-java">public class MyFactoryBean implements FactoryBean, InvocationHandler {
    Class clazz;
    public MyFactoryBean(Class clazz) {
        this.clazz = clazz;
    }
</code></pre>
<p>上述的 xml 代码含义：将 UserMapper 作为 Class 参数传递给 MapperFactoryBean，MapperFactoryBean 得到接口后，内部动态生成代理对象。<br>
Mybatis 源码：MapperFactoryBean 内部同样有一个 Class，构造方法 MapperFactoryBean(Class<T> mapperInterface)，是不是与我们模拟的 MyFactoryBean 几乎一样呢？</p>
<pre><code class="language-java">public class MapperFactoryBean&lt;T&gt; extends SqlSessionDaoSupport implements FactoryBean&lt;T&gt; {
  private Class&lt;T&gt; mapperInterface;
  private boolean addToConfig = true;
  public MapperFactoryBean() {
    //intentionally empty 
  }
  
  public MapperFactoryBean(Class&lt;T&gt; mapperInterface) {
    this.mapperInterface = mapperInterface;
  }
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#1new-annotationconfigapplicationcontext">1.new AnnotationConfigApplicationContext();</a>
<ul>
<li><a href="#11-new-annotatedbeandefinitionreaderthis">1.1 new AnnotatedBeanDefinitionReader(this)</a></li>
</ul>
</li>
<li><a href="#2contextrefresh">2.context.refresh();</a>
<ul>
<li><a href="#21-preparebeanfactory">2.1 prepareBeanFactory</a></li>
<li><a href="#22-invokebeanfactorypostprocessors">2.2 invokeBeanFactoryPostProcessors</a>
<ul>
<li><a href="#221-getbeanfactorypostprocessors">2.2.1 getBeanFactoryPostProcessors</a></li>
<li><a href="#222-invokebeanfactorypostprocessors">2.2.2 invokeBeanFactoryPostProcessors</a>
<ul>
<li><a href="#2221-processconfigbeandefinitions">2.2.2.1 processConfigBeanDefinitions</a>
<ul>
<li><a href="#22211-checkconfigurationclasscandidate">2.2.2.1.1 checkConfigurationClassCandidate</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%B3%A8%E5%86%8C-bean-%E7%9A%84%E6%96%B9%E6%B3%95">注册 Bean 的方法</a>
<ul>
<li><a href="#registerindexdaoimplclass">register(IndexDaoImpl.class);</a></li>
<li><a href="#scancomssm">scan(&quot;com.ssm&quot;)</a></li>
<li><a href="#importbeandefinitionregistrar">ImportBeanDefinitionRegistrar</a>
<ul>
<li><a href="#%E8%AE%A9%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3%E5%8F%98%E6%88%90%E5%AF%B9%E8%B1%A1%E4%BB%A3%E7%90%86">让一个接口变成对象：代理</a></li>
<li><a href="#%E5%B0%86%E5%AF%B9%E8%B1%A1%E6%94%BE%E5%88%B0-spring-%E5%AE%B9%E5%99%A8%E4%B8%AD">将对象放到 Spring 容器中</a>
<ul>
<li><a href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%AE%9E%E7%8E%B0-beanfactorypostprocessor-%E6%8E%A5%E5%8F%A3">方法一：实现 BeanFactoryPostProcessor 接口</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%AE%9E%E7%8E%B0-importselector-%E6%8E%A5%E5%8F%A3">方法二：实现 ImportSelector  接口</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E4%B8%89%E5%AE%9E%E7%8E%B0-importbeandefinitionregistrar-%E6%8E%A5%E5%8F%A3">方法三：实现 ImportBeanDefinitionRegistrar  接口</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#mybatis">MyBatis</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://epitomm.github.io/post/spring-xi-lie-qi-spring-yuan-ma-jie-xi/">
              <h3 class="post-title">
                Spring系列（七）Spring源码解析
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '974bd77fbbd52c2a0647',
    clientSecret: '6344370ca1314dbd553f45e75a2121a160ef1c44',
    repo: 'EpitomM.github.io',
    owner: 'EpitomM',
    admin: ['EpitomM'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/EpitomM/EpitomM.github.io" target="_blank">EpitomM</a>
  <a class="rss" href="https://epitomm.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
