<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://epitomm.github.io</id>
    <title>SSM</title>
    <updated>2020-05-03T15:05:50.583Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://epitomm.github.io"/>
    <link rel="self" href="https://epitomm.github.io/atom.xml"/>
    <subtitle>热心善良的老学姐</subtitle>
    <logo>https://epitomm.github.io/images/avatar.png</logo>
    <icon>https://epitomm.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, SSM</rights>
    <entry>
        <title type="html"><![CDATA[一篇文章学会 JDK 动态代理并手动模拟一个动态代理]]></title>
        <id>https://epitomm.github.io/post/yi-pian-wen-zhang-xue-hui-jdk-dong-tai-dai-li-bing-shou-dong-mo-ni-yi-ge-dong-tai-dai-li/</id>
        <link href="https://epitomm.github.io/post/yi-pian-wen-zhang-xue-hui-jdk-dong-tai-dai-li-bing-shou-dong-mo-ni-yi-ge-dong-tai-dai-li/">
        </link>
        <updated>2020-05-03T14:34:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="什么是代理"><strong>什么是代理</strong></h1>
<p>增强一个对象的功能</p>
<p>买火车票，app就是一个代理，他代理了火车站；小区当中的代售窗口也是一个代理，代理了火车站。</p>
<h1 id="代理模式的引入">代理模式的引入</h1>
<p>1、UserDaoImpl 有一个查询数据库的方法：</p>
<pre><code class="language-java">public class UserDaoImpl{
    public void query(){
        System.out.println(&quot;假装查询数据库&quot;);
    }
}
</code></pre>
<p>2、测试类中调用这个方法</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        UserDaoImpl userDao = new UserDaoImpl();
        LogUtil.log();
        userDao.query();
    }
}
</code></pre>
<p>3、现在有一个这样的需求：想要在每次执行 query() 时记录当前操作写到日志里面。写一个公共的日志方法 log()，那么把 LogUtil.log() 代码写到哪里呢？</p>
<p>3.1 写到 query() 方法中：</p>
<p>3.1.1 缺点：可能 UserDoImpl 是一个 jar，根本没有它的源码，无法进行修改。</p>
<p>3.1.2 即使有源码，将 query() 改写成如下：破坏了单一职责。</p>
<pre><code class="language-java">public void query(){
  LogUtil.log();
  // 进行数据库查询操作...
  System.out.println(&quot;假装查询数据库&quot;); 
}
</code></pre>
<p>单一职责：只做一件事。将日志操作写到 query() 里面破坏了类的封装性，职责就不单一了 。</p>
<p>3.2 写到 Test 类中：  每次调用查询操作前记录当前时间。</p>
<p>缺点：会调用很多次 query 方法，也就要写很多次 Logutil.log() 大量重复代码。</p>
<p>3.3 引入代理模式</p>
<h1 id="java实现的代理的两种办法"><strong>java实现的代理的两种办法</strong></h1>
<h1 id="代理的名词">代理的名词</h1>
<p>代理对象——增强后的对象</p>
<p>目标对象——被增强的对象</p>
<p>他们不是绝对的，会根据情况发生变化</p>
<h1 id="静态代理">静态代理</h1>
<h2 id="继承">继承</h2>
<ul>
<li>代理对象继承目标对象，重写需要增强的方法</li>
<li>缺点：会代理类过多，非常复杂</li>
</ul>
<p>回到上襦代理模式引入的例子中：</p>
<p>3.3 继承：自定义一个类<strong>继承</strong>原来需要添加日志的类 UserDaoImpl，在执行业务操作前添加日志打印语句。既解决了 jar 包无法修改源码的问题，又没有破坏单一职责原则。</p>
<pre><code class="language-java">public class UserDaoLogImpl extends UserDaoImpl {
    @Override
    public void query() {
        LogUtil.log();
        super.query();
    }
}
</code></pre>
<p>测试类：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        UserDao userDao = new UserDaoLogImpl();
        userDao.query();
    }
}
</code></pre>
<p>分析：如此得到了被增强后的 UserDaoImpl，可实现在 query() 前进行日志打印。</p>
<p>UserDaoImpl：目标对象</p>
<p>UserDaoLogImpl ：代理对象。</p>
<p>代理对象和目标对象是相对而言的。UserDaoLogImpl 是代理对象，但是有一天它也有可能成为目标对象。</p>
<p>4、有一个新需求：在 query 方法前添加一个权限验证。</p>
<pre><code class="language-java">public class UserDaoPowerImpl extends UserDaoImpl {
    @Override
    public void query() {
        LogUtil.log(&quot;power...&quot;);
        super.query();
    }
}
</code></pre>
<p>5、有一个新需求：在 query 方法前添加一个时间记录。</p>
<pre><code class="language-java">public class UserDaoTimerImpl extends UserDaoImpl {
    @Override
    public void query() {
        LogUtil.log(&quot;timer...&quot;);
        super.query();
    }
}
</code></pre>
<p>6、有一个新需求：在 query() 方法被调用前既实现日志打印、又实现记录当前时间的功能</p>
<pre><code class="language-java">public class UserDaoTimeAndLogImpl extends UserDaoLogImpl {
    @Override
    public void query() {
        // timer
        LogUtil.log(&quot;timer...&quot;);
        // logger &amp; query
        super.query();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>timer...
logger...
假装查询数据库
</code></pre>
<p>7、新需求：在 query() 前先打印日志，然后再记录时间</p>
<pre><code class="language-java">public class UserDaoLogAndTimeImpl extends UserDaoTimerImpl {
    @Override
    public void query() {
        LogUtil.log(&quot;logger...&quot;);
        // logger
        super.query();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>logger...
timer...
假装查询数据库
</code></pre>
<p>只是改变了以一下日志记录顺序，就会增加一个新的类，不同的排列组合会造成代理类过多。</p>
<h2 id="聚合">聚合</h2>
<ul>
<li>目标对象和代理对象实现同一个接口，代理对象当中要包含目标对象。</li>
<li>缺点：也会产生类爆炸（UserDaoLog implements UserDao、OrderDaoLog implements OrderDao......），只不过比继承少一点点</li>
<li>总结:如果在不确定的情况下，尽量不要去使用静态代理。因为一旦你写代码，就会产生类，一旦产生类就爆炸。</li>
</ul>
<p>1、声明一个接口：</p>
<pre><code class="language-java">public interface UserDao {
    void query();
}
</code></pre>
<p>2、目标对象 UserDaoImpl 实现 UserDao 接口</p>
<pre><code class="language-java">public class UserDaoImpl implements UserDao {
    public void query(){
        System.out.println(&quot;假装查询数据库&quot;);
    }
}
</code></pre>
<p>3、代理对象实现 UserDao 接口，代理对象 UserDaoLog 中包含目标对象 UserDaoImpl（测试类传参为目标对象类）</p>
<pre><code class="language-java">public class UserDaoLog implements UserDao {
    // 装饰者模式：写一个构造方法，通过传入一个目标对象指定代理/ 装饰具体的对象
    UserDao dao;
    public UserDaoLog(UserDao userDao){
        this.dao = userDao;
    }
    @Override
    public void query() {
        LogUtil.log(&quot;logger...&quot;);
        dao.query();
        // 代理模式：new UserDaoImpl().query();UserDao不是传递进来的，是写死的。
    }
}
</code></pre>
<p>4、测试类</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        UserDao target = new UserDaoImpl();
        UserDao proxy = new UserDaoLog(target);
        proxy.query();
    }
}
</code></pre>
<p>测试结果：</p>
<pre><code>logger...
假装查询数据库 
</code></pre>
<p>5、新需求：记录时间</p>
<pre><code class="language-java">public class UserDaoTime implements UserDao {
    UserDao dao;
    public UserDaoTime(UserDao userDao){
        this.dao = userDao;
    }
    @Override
    public void query() {
        LogUtil.log(&quot;timer...&quot;);
        dao.query();
    }
}
</code></pre>
<p>测试类：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        UserDao target = new UserDaoImpl();
        UserDao proxy = new UserDaoTime(target);
        proxy.query();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>timer...
假装查询数据库
</code></pre>
<p>6、新需求：完成对日志和时间的代理，无需新增一个类。只需将时间的代理对象作为目标对象，传递给日志代理对象即可。</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // time + logic(业务逻辑)
        UserDao target = new UserDaoTime(new UserDaoImpl());
        // log + time + logic
        UserDao proxy = new UserDaoLog(target);
        proxy.query();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>logger...
timer...
假装查询数据库
</code></pre>
<p>6、新需求：完成先打印时间，再记录日志的操作。无需新增类，只需修改测试类即可。</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        UserDao target = new UserDaoLog(new UserDaoImpl());
        UserDao proxy = new UserDaoTime(target);
        proxy.query();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>timer...
logger...
假装查询数据库动态代理
</code></pre>
<h2 id="自己模拟的动态代理">自己模拟的动态代理</h2>
<p>如何拿到一个对象？</p>
<p>不需要手动 new 创 建类文件（因为一旦手动创建类文件，就会产生类爆炸），通过接口反射生成一个类文件，然后调用第三方的编译技术，动态编译这个产生的类文件成class文件，继而利用UrlclassLoader(因为这个动态产生的class不在工程当中所以需要使用UrlclassLoader)把这个动态编译的类加载到jvm当中，最后通过反射把这个类实例化。</p>
<p>缺点：首先要生成文件</p>
<p>缺点：动态编译文件 class</p>
<p>缺点：需要一个URLclassloader</p>
<p>软件性能的最终体现在IO操作</p>
<p>file(.java) ---&gt; .class ---&gt; byte[] ---&gt; object(Class 类对象)  ---&gt; object.newInstance()</p>
<h3 id="1准备一个接口">1.准备一个接口：</h3>
<pre><code class="language-java">public interface TestDao {
    String query(String s1, String s2);
}
</code></pre>
<h3 id="2准备一个接口实现类">2.准备一个接口实现类：</h3>
<pre><code class="language-java">public class TestDaoImpl implements TestDao {
    @Override
    public String query(String s1, String s2) {
        System.out.println(&quot;查询数据库&quot;);
        System.out.println(&quot;daoImpl...&quot; + s1 + &quot; &quot; + s2);
        return s1 + &quot; &quot; + s2;
    }
}
</code></pre>
<h3 id="3模拟动态代理">3.模拟动态代理：</h3>
<pre><code class="language-java">package com.ssm.util;

import javax.tools.JavaCompiler;
import javax.tools.StandardJavaFileManager;
import javax.tools.ToolProvider;
import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLClassLoader;
import com.sun.jndi.toolkit.url.UrlUtil;

public class ProxyUtil {

    /**
     * 如何产生一个对象？
     *  content ---&gt; String
     *  .java
     *  .class
     *  .new
     * @param target：目标对象
     * @return
     */
    public static Object newInstance(Object target) throws IOException, IllegalAccessException, InstantiationException, NoSuchMethodException, ClassNotFoundException, InvocationTargetException {
        // targetInterface：目标对象的接口
        Class targetInterface = target.getClass().getInterfaces()[0];

        // 声明最终要返回的代理对象
        Object proxy=null;
        /**
         * package com.ssm.proxyInter;
         *
         * import com.ssm.dao.UserDao;
         *
         * public class UserDaoLog implements UserDao {
         *
         *     private UserDao target;
         *     public UserDaoLog(UserDao target){
         *         this.target = target;
         *     }
         *     @Override
         *     public void query(String p0, String p1) {
         *         System.out.println(&quot;log...&quot;);
         *         target.query(p0,p1);
         *     }
         * }
         * 将上述代码逐行变成字符串
         */
        // 换行
        String line = &quot;\n&quot;;
        // 缩进
        String tab = &quot;\t&quot;;
        // 得到接口名 UserDao
        String interfaceName = targetInterface.getSimpleName();
        // 得到接口中的所有方法 query()
        Method[] methods = targetInterface.getDeclaredMethods();
        String content = &quot;&quot;;
        String packageContent = &quot;package com.ssm;&quot; + line;
        String importContent = &quot;import &quot; + targetInterface.getName() + &quot;;&quot; + line;
        String classFirstLineContent = &quot;public class $Proxy implements &quot; +interfaceName+ &quot;{&quot; + line;
        String fieldContent = tab + &quot;private &quot; + interfaceName + &quot; target;&quot; + line;
        String constructorContent = tab + &quot;public $Proxy (&quot; + interfaceName + &quot; target){&quot; + line
                + tab + tab + &quot;this.target = target; &quot;+ line
                + tab +&quot;}&quot; + line;

        // 参数内容：target.query(p0,p1);
        String paramsContent = &quot;&quot;;
        String methodContent = &quot;&quot;;
        for (Method method : methods){
            // 得到当前方法的返回类型
            String returnType = method.getReturnType().getSimpleName();
            // 得到当前方法的方法名
            String methodName = method.getName();
            // 得到方法的参数类型：如 String.class
            Class[] args = method.getParameterTypes();
            String argsContent = &quot;&quot;;
            for (int i = 0 ; i &lt; args.length ; i++){
                // 得到的是参数类型：如 String
                String temp = args[i].getSimpleName();
                // 最终构造成这个形式：String p0,String p1
                argsContent += temp + &quot; p&quot; + i + &quot;,&quot;;
                paramsContent += &quot;p&quot; + i + &quot;,&quot;;
            }
            // 截取掉最后一个多余的 ','
            if(argsContent.length() &gt; 0){
                argsContent = argsContent.substring(0,argsContent.lastIndexOf(&quot;,&quot;));
                paramsContent = paramsContent.substring(0,paramsContent.lastIndexOf(&quot;,&quot;));
            }
            methodContent += tab + &quot;public &quot; + returnType + &quot; &quot; + methodName + &quot;(&quot; + argsContent + &quot;) {&quot; + line
                    + tab + tab + &quot;System.out.println(\&quot;log\&quot;);&quot; + line;
            // 判断是否有返回值
            if(&quot;void&quot;.equals(returnType)){
                methodContent += tab + tab + &quot;target.&quot; + methodName + &quot;(&quot; + paramsContent + &quot;);&quot; + line
                        + tab + &quot;}&quot; + line;
            }else {
                methodContent += tab + tab + &quot; return target.&quot; + methodName + &quot;(&quot; + paramsContent + &quot;);&quot; + line
                        + tab + &quot;}&quot; + line;
            }

        }

        content = packageContent + importContent + classFirstLineContent + fieldContent + constructorContent + methodContent + &quot;}&quot;;

        File file = new File(&quot;C:\\Users\\Only\\com\\ssm\\$Proxy.java&quot;);
        if(!file.exists()){
            file.createNewFile();
        }
        FileWriter fw = new FileWriter(file);
        fw.write(content);
        fw.flush();
        fw.close();

        // .java ---&gt; .class
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null);
        Iterable units = fileMgr.getJavaFileObjects(file);
        JavaCompiler.CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units);
        t.call();
        fileMgr.close();

        // 通过反射得到构造函数 new 一个对象出来
        URL[] urls = new URL[]{new URL(&quot;file:C:\\Users\\Only\\\\&quot;)};
        URLClassLoader urlClassLoader = new URLClassLoader(urls);
        Class clazz = urlClassLoader.loadClass(&quot;com.ssm.$Proxy&quot;);
        Constructor constructor = clazz.getConstructor(targetInterface);
        proxy = constructor.newInstance(target);

        return proxy;
    }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E6%A8%A1%E6%8B%9F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.png" alt="图片" loading="lazy"></figure>
<h3 id="4测试类">4.测试类</h3>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws IOException, InvocationTargetException, NoSuchMethodException, ClassNotFoundException, InstantiationException, IllegalAccessException {
        TestDao proxy = (TestDao) ProxyUtil.newInstance(new TestDaoImpl());
        String res = proxy.query(&quot;hello&quot;, &quot;world&quot;);
        System.out.println(&quot;res = &quot; + res);
    }
}
</code></pre>
<p>最终运行效果：</p>
<pre><code class="language-java">log
查询数据库
daoImpl...hello world
res = hello world
</code></pre>
<h2 id="代理逻辑动态实现而不是写死的-sout">代理逻辑动态实现，而不是写死的 sout</h2>
<h3 id="1要代理的接口">1.要代理的接口</h3>
<pre><code class="language-java">public interface TestDao {
    String delete() throws Exception;
}
</code></pre>
<h3 id="2目标对象">2.目标对象</h3>
<pre><code class="language-java">public class TestDaoImpl implements TestDao {
    @Override
    public String delete() {
        System.out.println(&quot;dao...delete&quot;);
        return null;
    }
}
</code></pre>
<h3 id="3代理逻辑接口">3.代理逻辑接口</h3>
<pre><code class="language-java">public interface CustomInvocationHandler {
    Object invoke(Method method);
}
</code></pre>
<h3 id="4代理逻辑具体实现">4.代理逻辑具体实现</h3>
<pre><code class="language-java">package com.ssm.test;
import com.ssm.dao.CustomInvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
public class TestCustomHandler implements CustomInvocationHandler {
    private Object target;
    public TestCustomHandler(Object target){
        this.target = target;
    }
    @Override
    public Object invoke(Method method) {
        System.out.println(&quot;TestCustomHandler...&quot;);
        try {
            return method.invoke(target);
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
        return null;
    }
}
</code></pre>
<p>4.自定义动态代理</p>
<pre><code class="language-java">package com.ssm.util;

import javax.tools.JavaCompiler;
import javax.tools.StandardJavaFileManager;
import javax.tools.ToolProvider;
import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLClassLoader;
import com.ssm.dao.CustomInvocationHandler;
import com.sun.jndi.toolkit.url.UrlUtil;
public class ProxyUtil {
    /**
     * 如何产生一个对象？
     *  content ---&gt; String
     *  .java
     *  .class
     *  .new
     * @return
     */
    public static Object newInstance(Class targetInterface, CustomInvocationHandler h) throws IOException, IllegalAccessException, InstantiationException, NoSuchMethodException, ClassNotFoundException, InvocationTargetException {
        // targetInterface：目标对象的接口
//        Class targetInterface = target.getClass().getInterfaces()[0];

        // 声明最终要返回的代理对象
        Object proxy=null;
        /**
         * package com.ssm.proxyInter;
         *
         * import com.ssm.dao.UserDao;
         *
         * public class UserDaoLog implements UserDao {
         *
         *     private UserDao target;
         *     public UserDaoLog(UserDao target){
         *         this.target = target;
         *     }
         *     @Override
         *     public void query(String p0, String p1) {
         *         System.out.println(&quot;log...&quot;);
         *         target.query(p0,p1);
         *     }
         * }
         * 将上述代码逐行变成字符串
         */
        // 换行
        String line = &quot;\n&quot;;
        // 缩进
        String tab = &quot;\t&quot;;
        // 得到接口名 UserDao
        String interfaceName = targetInterface.getSimpleName();
        // 得到接口中的所有方法 query()
        Method[] methods = targetInterface.getDeclaredMethods();
        String content = &quot;&quot;;
        String packageContent = &quot;package com.ssm;&quot; + line;
        String importContent = &quot;import &quot; + targetInterface.getName() + &quot;;&quot; + line
                + &quot;import com.ssm.dao.CustomInvocationHandler;&quot; + line
                + &quot;import java.lang.reflect.Method;&quot; + line;
        String classFirstLineContent = &quot;public class $Proxy implements &quot; +interfaceName+ &quot;{&quot; + line;
        String fieldContent = tab + &quot;private  CustomInvocationHandler h;&quot; + line;
        String constructorContent = tab + &quot;public $Proxy (CustomInvocationHandler h){&quot; + line
                + tab + tab + &quot;this.h = h; &quot;+ line
                + tab +&quot;}&quot; + line;
                
        // 参数内容：target.query(p0,p1);
        String paramsContent = &quot;&quot;;
        String methodContent = &quot;&quot;;
        for (Method method : methods){
            // 得到当前方法的返回类型
            String returnType = method.getReturnType().getSimpleName();
            // 得到当前方法的方法名
            String methodName = method.getName();
            // 得到方法的参数类型：如 String.class
            Class[] args = method.getParameterTypes();
            String argsContent = &quot;&quot;;
            for (int i = 0 ; i &lt; args.length ; i++){
                // 得到的是参数类型：如 String
                String temp = args[i].getSimpleName();
                // 最终构造成这个形式：String p0,String p1
                argsContent += temp + &quot; p&quot; + i + &quot;,&quot;;
                paramsContent += &quot;p&quot; + i + &quot;,&quot;;
            }
            // 截取掉最后一个多余的 ','
            if(argsContent.length() &gt; 0){
                argsContent = argsContent.substring(0,argsContent.lastIndexOf(&quot;,&quot;));
                paramsContent = paramsContent.substring(0,paramsContent.lastIndexOf(&quot;,&quot;));
            }
            methodContent += tab + &quot;public &quot; + returnType + &quot; &quot; + methodName + &quot;(&quot; + argsContent + &quot;) throws Exception {&quot; + line
                    + tab + tab + &quot;Method method = Class.forName(\&quot;&quot; + targetInterface.getName() + &quot;\&quot;).getDeclaredMethod(\&quot;&quot; + methodName + &quot;\&quot;);&quot; + line
                    + tab + tab + &quot;return (&quot;+ returnType +&quot;)h.invoke(method);&quot; + line
                    + tab + &quot;}&quot; + line;
        }

        content = packageContent + importContent + classFirstLineContent + fieldContent + constructorContent + methodContent + &quot;}&quot;;

        File file = new File(&quot;C:\\Users\\Only\\com\\ssm\\$Proxy.java&quot;);
        if(!file.exists()){
            file.createNewFile();
        }
        FileWriter fw = new FileWriter(file);
        fw.write(content);
        fw.flush();
        fw.close();

        // .java ---&gt; .class
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null);
        Iterable units = fileMgr.getJavaFileObjects(file);
        JavaCompiler.CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units);
        t.call();
        fileMgr.close();

        // 通过反射得到构造函数 new 一个对象出来
        URL[] urls = new URL[]{new URL(&quot;file:C:\\Users\\Only\\\\&quot;)};
        URLClassLoader urlClassLoader = new URLClassLoader(urls);
        Class clazz = urlClassLoader.loadClass(&quot;com.ssm.$Proxy&quot;);
        Constructor constructor = clazz.getConstructor(CustomInvocationHandler.class);
        proxy = constructor.newInstance(h);

        return proxy;
    }
}
</code></pre>
<h3 id="5测试类">5.测试类</h3>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws Exception {
//         自定义动态代理
        TestDao proxy = (TestDao) ProxyUtil.newInstance(TestDao.class, new TestCustomHandler(new TestDaoImpl()));
        proxy.delete();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-java">TestCustomHandler...
dao...delete
</code></pre>
<h2 id="jdk动态代理">JDK动态代理</h2>
<p>通过接口反射得到字节码 byte[] ，然后把字节码转成 class：native方法  openJDK  c++</p>
<h3 id="1要代理的接口-2">1.要代理的接口</h3>
<pre><code class="language-java">public interface TestDao {
    String query(String s1, String s2) throws Exception;
}
</code></pre>
<h3 id="2目标对象-2">2.目标对象</h3>
<pre><code class="language-java">public class TestDaoImpl implements TestDao {
    @Override
    public String query(String s1, String s2) {
        System.out.println(&quot;查询数据库&quot;);
        System.out.println(&quot;daoImpl...&quot; + s1 + &quot; &quot; + s2);
        return s1 + &quot; &quot; + s2;
    } 
}
</code></pre>
<h3 id="3代理的逻辑">3.代理的逻辑</h3>
<pre><code class="language-java">package com.ssm.util;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class TestInvocationHandler implements InvocationHandler {
    Object target;

    /**
     *
     * @param target 目标对象
     */
    public TestInvocationHandler(Object target){
        this.target = target;
    }
    /**
     *
     * @param proxy 代理对象 $Proxy
     * @param method 目标对象 TestDao
     * @param args 目标方法的参数
     * @return
     * @throws Throwable
     *
     * 根据代理的逻辑执行：即打印 TestInvocationHandler...proxy
     * 执行目标对象的方法 ，即 TestDao 的 query()
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;TestInvocationHandler...proxy&quot;);
        return method.invoke(target,args);
    }
}
</code></pre>
<h3 id="4测试类-2">4.测试类</h3>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws Exception {

        /**
         * JDK 动态代理
         * 参数：要代理哪些接口；new Class[]{TestDao.class}：TestDao 下所有方法的代理。
         *       代理的逻辑：new TestInvocationHandler(new TestDaoImpl())：在每个方法前打印 TestInvocationHandler...proxy
         */
        TestDao jdkProxy = (TestDao) Proxy.newProxyInstance(Test.class.getClassLoader(),
                new Class[]{TestDao.class},
                new TestInvocationHandler(new TestDaoImpl()));
        String result = jdkProxy.query(&quot;hello&quot;, &quot;world&quot;);
        System.out.println(&quot;result = &quot; + result);

    }
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-java">TestInvocationHandler...proxy
查询数据库
daoImpl...hello world
result = hello world
</code></pre>
<h3 id="jdk-动态代理分析">JDK 动态代理分析</h3>
<p>JDK 动态代理：</p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1.png" alt="图片" loading="lazy"></figure>
<p>自定义动态代理：</p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1.png" alt="图片" loading="lazy"></figure>
<h4 id="代理类">代理类</h4>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E4%BB%A3%E7%90%86%E7%B1%BB.png" alt="图片" loading="lazy"></figure>
<h4 id="得到代理类的构造方法">得到代理类的构造方法</h4>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/%E5%BE%97%E5%88%B0%E4%BB%A3%E7%90%86%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png" alt="图片" loading="lazy"></figure>
<h4 id="使用代理类的构造方法-new-一个对象出来">使用代理类的构造方法 new 一个对象出来</h4>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95new%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%87%BA%E6%9D%A5.png" alt="图片" loading="lazy"></figure>
<h4 id="class-cl-getproxyclass0loader-intfs">Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</h4>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/getProxyClass0.png" alt="图片" loading="lazy"></figure>
<h4 id="public-v-getk-key-p-parameter">public V get(K key, P parameter) {</h4>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/get.png" alt="图片" loading="lazy"></figure>
<h4 id="debugger">debugger</h4>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/debugger.png" alt="图片" loading="lazy"></figure>
<h4 id="v-value-supplierget">V value = supplier.get();</h4>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/suppiler.get.png" alt="图片" loading="lazy"></figure>
<h4 id="public-synchronized-v-get">public synchronized V get() {</h4>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/%E8%BF%94%E5%9B%9Evalue.png" alt="图片" loading="lazy"></figure>
<h4 id="value-objectsrequirenonnullvaluefactoryapplykey-parameter">value = Objects.requireNonNull(valueFactory.apply(key, parameter))</h4>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/requireNonNull.png" alt="图片" loading="lazy"></figure>
<h4 id="public-class-applyclassloader-loader-class-interfaces">public Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {</h4>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/apply.png" alt="图片" loading="lazy"></figure>
<h4 id="使用类加载器判断是否是同一个对象">使用类加载器判断是否是同一个对象</h4>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1.png" alt="图片" loading="lazy"></figure>
<h4 id="判断接口的权限修饰符">判断接口的权限修饰符</h4>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/%E5%88%A4%E6%96%AD%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6.png" alt="图片" loading="lazy"></figure>
<h4 id="string-proxyname-proxypkg-proxyclassnameprefix-num">String proxyName = proxyPkg + proxyClassNamePrefix + num;</h4>
<figure data-type="image" tabindex="16"><img src="https://epitomm.github.io/post-images/proxyName.png" alt="图片" loading="lazy"></figure>
<p>类名加上标识0，是为了防止并发情况下产生问题。</p>
<h4 id="byte-proxyclassfile-proxygeneratorgenerateproxyclassproxyname-interfaces-accessflags">byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</h4>
<figure data-type="image" tabindex="17"><img src="https://epitomm.github.io/post-images/generateProxyClass.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="18"><img src="https://epitomm.github.io/post-images/JDK%E4%BB%A3%E7%90%86%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringAOP 应用]]></title>
        <id>https://epitomm.github.io/post/springaop-ying-yong/</id>
        <link href="https://epitomm.github.io/post/springaop-ying-yong/">
        </link>
        <updated>2020-05-03T07:55:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="自定义注解">自定义注解</h1>
<h2 id="xml-的作用">xml 的作用？</h2>
<p>答：<strong>描述数据</strong>。<br>
举例：数据库中有一张 user 表，项目中有一个 User 类，如何将 User 类与 user 表<strong>关联</strong>？<br>
答：使用 xml 来描述元数据。<br>
那为什么还要有自定义注解呢？因为xml 开发过程过于复杂。</p>
<h2 id="自定义注解-2">自定义注解</h2>
<h3 id="一-准备阶段">一、准备阶段</h3>
<h4 id="1定义实体类">1.定义实体类</h4>
<pre><code class="language-java">package com.ssm.entity;

import com.ssm.anno.Entity;

public class CityEntity {

    private Integer id;
    private String name;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
</code></pre>
<h4 id="2定义工具类">2.定义工具类</h4>
<pre><code class="language-java">package com.ssm.util;

public class CommonUtil {
    /**
     * 通过一个对象构建一条查询的 sql 语句
     * @param obj
     */
    public static String buildQuerySqlForEntity(Object obj){

        // 表名、字段应该根据传入的值动态变化，不应该写死
        // 办法：在实体类 CityEntity 中加入注解 @Table（需要导入JPA），我们使用自定义注解来实现
        String sql = &quot;select * from ? where id=? and name=?&quot;;

        return null;
    }
}
</code></pre>
<h4 id="3测试方法">3.测试方法</h4>
<pre><code class="language-java">package com.ssm.util;

public class CommonUtil {
    /**
     * 通过一个对象构建一条查询的 sql 语句
     * @param obj
     */
    public static String buildQuerySqlForEntity(Object obj){

        // 表名、字段应该根据传入的值动态变化，不应该写死
        // 办法：在实体类 CityEntity 中加入注解 @Table（需要导入JPA），我们使用自定义注解来实现
        String sql = &quot;select * from ? where id=? and name=?&quot;;

        return null;
    }
}
</code></pre>
<h3 id="二-自定义注解基本功能">二、自定义注解——基本功能</h3>
<h4 id="1自定义注解">1.自定义注解</h4>
<pre><code class="language-java">public @interface Entity {
    public String value();
}
</code></pre>
<h4 id="2实体类添加注解">2.实体类添加注解</h4>
<pre><code class="language-java">// 注解里面的 value 方法，返回值是 String 类型
@Entity(value = &quot;city&quot;)
public class CityEntity {
</code></pre>
<h3 id="三-自定义注解元注解">三、自定义注解——元注解</h3>
<h4 id="1实体类体会元注解">1.实体类体会元注解</h4>
<pre><code class="language-java">//@Override   
// @Override' not applicable to type：@Override 不适用修饰类
public class CityEntity {

// @Override   
// Method does not override method from its superclass：没有父类重写的方法。表名 @Override 注解可用于修饰方法
    public void setId(Integer id) {
        this.id = id;
    }    
</code></pre>
<p>分析得知：@Override 注解可用于修饰方法，不可用于修饰类。<br>
于是我们来改动一下我们的自定义注解 @Entity，让它只能用于修饰类，不能用于修饰方法。</p>
<h4 id="2修改自定义注解类">2.修改自定义注解类</h4>
<pre><code class="language-java">// @Entity 注解能够出现的目标位置：TYPE：类
@Target(ElementType.TYPE)
// @Target({ElementType.TYPE, ElementType.FIELD})：指定多个可以出现的位置：类、
public @interface Entity {
    public String value();
}
</code></pre>
<h3 id="四-获得注解内的值">四、获得注解内的值</h3>
<pre><code class="language-java">package com.ssm.util;

import com.ssm.anno.Entity;

import java.lang.annotation.Annotation;

public class CommonUtil {
    public static String buildQuerySqlForEntity(Object obj){
        // 得到类的类对象
        Class clazz = obj.getClass();
        // setup1 判断是否加了这个注解
        if(clazz.isAnnotationPresent(Entity.class)){
            // setup2 得到注解
            Entity entity = (Entity) clazz.getDeclaredAnnotation(Entity.class);
            // setup3 调用方法
            String value = entity.value();
            System.out.println(value);  // city
        }

        // 表名、字段应该根据传入的值动态变化，不应该写死
        // 办法：在实体类 CityEntity 中加入注解 @Table（需要导入JPA），我们使用自定义注解来实现
        String sql = &quot;select * from ? where id=? and name=?&quot;;

        return null;
    }
}
</code></pre>
<h2 id="注解生命周期">注解生命周期</h2>
<h3 id="retentionretentionpolicysource">@Retention(RetentionPolicy.SOURCE)</h3>
<p>注解的生命周期：默认情况下仅仅存在于 Java 源码中，即@Retention(RetentionPolicy.SOURCE)，当 JVM 一旦把它编译成字节码，注解会自动丢失。<br>
<img src="https://epitomm.github.io/post-images/%E6%B3%A8%E8%A7%A3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9FSOURCE.png" alt="图片" loading="lazy"></p>
<h3 id="retentionretentionpolicyclass">@Retention(RetentionPolicy.CLASS)</h3>
<p>会存在于 .class 文件中，但是在代码被运行时还是会被 JVM 忽略。<br>
<img src="https://epitomm.github.io/post-images/%E6%B3%A8%E8%A7%A3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9FCLASS.png" alt="图片" loading="lazy"><br>
测试：</p>
<pre><code class="language-java">package com.ssm.util;

import com.ssm.anno.Entity;

public class CommonUtil {

    public static String buildQuerySqlForEntity(Object obj){
        // 得到类的类对象
        Class clazz = obj.getClass();
        // setup1 判断是否加了这个注解
        boolean b = clazz.isAnnotationPresent(Entity.class); // false
        System.out.println(b);

        return null;
    }
}
</code></pre>
<h3 id="retentionretentionpolicyruntime">@Retention(RetentionPolicy.RUNTIME)</h3>
<p>只有当注解的生命周期声明为 RUNTIME 时，在执行时才会被 JVM 发觉到。<br>
boolean b = clazz.isAnnotationPresent(Entity.class);//true</p>
<h1 id="aop-是什么">AOP 是什么</h1>
<p>与OOP对比，面向切面，传统的OOP开发中的代码逻辑是自上而下的，而这些过程会产生一些横切性问题，这些横切性的问题和我们的主业务逻辑关系不大，这些横切性问题不会影响到主逻辑实现的，但是会散落到代码的各个部分，难以维护。AOP是处理一些横切性问题，AOP的编程思想就是把这些问题和主业务逻辑分开，达到与主业务逻辑解耦的目的。使代码的重用性和开发效率更高。<br>
<img src="https://epitomm.github.io/post-images/AOP%E6%98%AF%E4%BB%80%E4%B9%88.png" alt="图片" loading="lazy"></p>
<h2 id="aop-的应用场景">AOP 的应用场景</h2>
<ol>
<li>日志记录</li>
<li>权限验证</li>
<li>效率检查</li>
<li>事务管理</li>
<li>exception</li>
</ol>
<h2 id="springaop-的底层技术">SpringAOP 的底层技术</h2>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">JDK动态代理</th>
<th style="text-align:center">CGLIB代理</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">编译时期的织入还是运行时期的织入?</td>
<td style="text-align:center">运行时期织入</td>
<td style="text-align:center">运行时期织入</td>
</tr>
<tr>
<td style="text-align:center">初始化时期织入还是获取对象时期织入？</td>
<td style="text-align:center">初始化时期织入</td>
<td style="text-align:center">初始化时期织入</td>
</tr>
</tbody>
</table>
<h2 id="springaop-和-aspectj-的关系">SpringAOP 和 AspectJ 的关系</h2>
<p>AOP 是一种概念<br>
SpringAOP、AspectJ 都是 AOP 的实现，SpringAOP 有自己的语法，但是语法复杂，所以SpringAOP 借助了AspectJ 的注解，但是底层实现还是自己的<br>
AspectJ 是静态注入：编译（.java -&gt; .class）时就完成了注入，SpringAOP是动态注入：运行时才注入</p>
<pre><code>spring AOP提供两种编程风格
@AspectJ support         ------------&gt;利用aspectj的注解
Schema-based AOP support -----------&gt;xml aop:config 命名空间

证明:spring,通过源  码分析了,我们可以知道spring底层使用的是JDK或者CGLIB来完成的代理,并且在官网上spring给出了aspectj的文档,和springAOP是不同的
</code></pre>
<p>如果您只需要建议在Spring bean上执行操作，那么Spring AOP是正确的选择。如果需要通知Spring容器没有管理的对象(通常是域对象)，则需要使用AspectJ。<br>
Spring AOP的概念<br>
参考链接：<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-introduction-defn">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-introduction-defn</a></p>
<ul>
<li>aspect:一定要给spring去管理  抽象  aspectj-&gt;类</li>
<li>pointcut:切点表示连接点的集合  -----------------&gt;   表 （我的理解：PointCut是JoinPoint的谓语，这是一个动作，主要是告诉通知连接点在哪里，切点表达式决定 JoinPoint 的数量）</li>
<li>Joinpoint:连接点   目标对象中的方法 ----------------&gt;    记录（我的理解：JoinPoint是要关注和增强的方法，也就是我们要作用的点）</li>
<li>Weaving :把代理逻辑加入到目标对象上的过程叫做织入</li>
<li>target 目标对象 原始对象</li>
<li>aop Proxy 代理对象  包含了原始对象的代码和增加后的代码的那个对象</li>
<li>advice:通知    (位置 + logic)</li>
</ul>
<h2 id="aspect-切面">Aspect 切面</h2>
<blockquote>
<p>Aspect: A modularization of a concern that cuts across multiple classes. Transaction management is a good example of a crosscutting concern in enterprise Java applications. In Spring AOP, aspects are implemented by using regular classes (the schema-based approach) or regular classes annotated with the @Aspect annotation (the @AspectJ style).<br>
切面是：通知、切点、连接点的载体。通知、连接点要放到哪里去，好比 Java 中的属性、方法、构造方法，这些东西要放到哪里去？放到一个类里面，这个类就是方法以及参数属性的载体。切面就是连接点、切点、通知的载体，把这些连接点、切点、通知所在的位置称之为一个切面。</p>
</blockquote>
<h2 id="join-point-连接点">Join point 连接点</h2>
<blockquote>
<p>Join point: A point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution.<br>
连接点：程序执行过程中的一个点，如方法的执行或异常的处理。在Spring AOP中，连接点总是表示方法执行。<br>
<img src="https://epitomm.github.io/post-images/AOP%E8%BF%9E%E6%8E%A5%E7%82%B9.png" alt="图片" loading="lazy"><br>
ProceedingJoinPoint 和 JoinPoint 的区别:<br>
ProceedingJoinPoint  继承了JoinPoint ,proceed()这个是aop代理链执行的方法。并扩充实现了proceed()方法，用于继续执行连接点。JoinPoint 仅能获取相关参数，无法执行连接点。<br>
JoinPoint 的方法：</p>
</blockquote>
<ol>
<li>java.lang.Object[] getArgs()：获取连接点方法运行时的入参列表；</li>
<li>Signature getSignature() ：获取连接点的方法签名对象；</li>
<li>java.lang.Object getTarget() ：获取连接点所在的目标对象；</li>
<li>java.lang.Object getThis() ：获取代理对象本身；<br>
proceed()有重载,有个带参数的方法,可以修改目标方法的的参数</li>
</ol>
<p>Advice 通知<br>
Advice: Action taken by an aspect at a particular join point. Different types of advice include “around”, “before” and “after” advice. (Advice types are discussed later.) Many AOP frameworks, including Spring, model an advice as an interceptor and maintain a chain of interceptors around the join point.<br>
<img src="https://epitomm.github.io/post-images/AOP%E9%80%9A%E7%9F%A5.png" alt="图片" loading="lazy"></p>
<ul>
<li>advice通知类型:</li>
<li>Before 连接点执行之前，但是无法阻止连接点的正常执行，除非该段执行抛出异常</li>
<li>After  连接点正常执行之后，执行过程中正常执行返回退出，非异常退出</li>
<li>After throwing  执行抛出异常的时候</li>
<li>After (finally)  无论连接点是正常退出还是异常退出，都会执行</li>
<li>Around advice: 围绕连接点执行，例如方法调用。这是最有用的切面方式。around通知可以在方法调用之前和之后执行自定义行为。它还负责选择是继续加入点还是通过返回自己的返回值或抛出异常来快速建议的方法执行。</li>
</ul>
<h3 id="after">After</h3>
<pre><code class="language-java">@After(&quot;pointCutTarget()&quot;)
public void after(){
    System.out.println(&quot;after&quot;);
}
</code></pre>
<h3 id="before">Before</h3>
<pre><code class="language-java">@Before(&quot;pointCut()&quot;)
public void before(JoinPoint joinPoint){
    System.out.println(&quot;before&quot;);
    System.out.println(joinPoint.getThis());
    System.out.println(joinPoint.getTarget());
}
</code></pre>
<p>断点调试：<br>
1、joinPoint.getThis()<br>
<img src="https://epitomm.github.io/post-images/%E8%BF%9E%E6%8E%A5%E7%82%B9%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_1.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/%E8%BF%9E%E6%8E%A5%E7%82%B9%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_2.png" alt="图片" loading="lazy"><br>
2、joinPoint.getTarget()<br>
<img src="https://epitomm.github.io/post-images/%E8%BF%9E%E6%8E%A5%E7%82%B9%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_3.png" alt="图片" loading="lazy"></p>
<h3 id="around">Around</h3>
<p>在通知中拿到连接点，然后执行连接点。</p>
<pre><code class="language-java">@Around(&quot;pointCut()&quot;)
// ProceedingJoinPoint：正在进行的 JointPoint：正在增强的方法
public void around(ProceedingJoinPoint pjp) throws Throwable {
    System.out.println(&quot;around...before&quot;);
    // 拿到方法并执行它
    pjp.proceed();
    System.out.println(&quot;around...after&quot;);
}
</code></pre>
<p>测试结果：</p>
<pre><code>around...before
query
around...after
</code></pre>
<h3 id="xml-通知">XML 通知</h3>
<p>1、编写 xml，定义切面、连接点、通知</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                         http://www.springframework.org/schema/beans/spring-beans.xsd
                         http://www.springframework.org/schema/aop
                         http://www.springframework.org/schema/aop/spring-aop.xsd
                         http://www.springframework.org/schema/context
                         http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:component-scan base-package=&quot;com.ssm&quot;/&gt;
    &lt;!-- 定义一个切面 --&gt;
    &lt;aop:config&gt;
        &lt;!-- 定义一个连接点 --&gt;
        &lt;aop:pointcut id=&quot;allDao&quot; expression=&quot;execution(* com.ssm.dao.*.*(..))&quot;/&gt;
        &lt;!-- 通知包含两部分：位置 pointcut-ref 、逻辑 ref --&gt;
        &lt;aop:aspect id=&quot;aspect&quot; ref=&quot;xmlBean&quot;&gt;
            &lt;aop:before pointcut-ref=&quot;allDao&quot;
                    method=&quot;before&quot;/&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;

    &lt;bean id=&quot;xmlBean&quot; class=&quot;com.ssm.app.XMLAopBean&quot;/&gt;
    &lt;bean id=&quot;indexDao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p>2、编写通知的逻辑</p>
<pre><code class="language-java">public class XMLAopBean {
    public void before(){
        System.out.println(&quot;xml before...&quot;);
    }
}
</code></pre>
<p>3、测试</p>
<pre><code class="language-java">public class TestXML {
    public static void main(String[] args) throws IOException {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
        IndexDao dao = (IndexDao) context.getBean(&quot;indexDao&quot;);
        dao.query(&quot;hello&quot;);
    }
}
</code></pre>
<p>4、运行结果</p>
<pre><code>xml before...
query
hello
</code></pre>
<h4 id="环绕通知中改变参数值">环绕通知中改变参数值</h4>
<p>1、传递进来的参数为 &quot;hello&quot;</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws IOException {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        IndexDao dao = (IndexDao) context.getBean(&quot;indexDao&quot;);
        dao.query(&quot;hello&quot;);
    }
}
</code></pre>
<p>2、在环绕通知内将参数修改为  hello  world</p>
<pre><code class="language-java">@Around(&quot;pointCut()&quot;)
// ProceedingJoinPoint：正在进行的 JointPoint：正在增强的方法 
public void around(ProceedingJoinPoint pjp) throws Throwable {
    Object[] args = pjp.getArgs();
    if(args != null &amp;&amp; args.length &gt; 0){
        for (int i = 0; i &lt; args.length; i++) {
            args[i] += &quot; world&quot;;
        }
    }
    System.out.println(&quot;around...before&quot;);
    // 拿到方法并执行它
    pjp.proceed(args);
    System.out.println(&quot;around...after&quot;);
}
</code></pre>
<p>3、输出参数值</p>
<pre><code class="language-java">@Repository(&quot;indexDao&quot;)
public class IndexDaoImpl implements IndexDao {
    @Override
    public void query(String str){
        System.out.println(&quot;query&quot;);
        System.out.println(str);
    }
}
</code></pre>
<p>4、输出结果：</p>
<pre><code>around...before
query
hello world
around...after
</code></pre>
<h2 id="pointcut-切点">Pointcut 切点</h2>
<blockquote>
<p>Pointcut: A predicate that matches join points. Advice is associated with a pointcut expression and runs at any join point matched by the pointcut (for example, the execution of a method with a certain name). The concept of join points as matched by pointcut expressions is central to AOP, and Spring uses the AspectJ pointcut expression language by default.<br>
切点：连接点的集合。<br>
<img src="https://epitomm.github.io/post-images/AOP%E5%88%87%E7%82%B9.png" alt="图片" loading="lazy"></p>
</blockquote>
<h2 id="introduction">Introduction</h2>
<blockquote>
<p>Introduction: Declaring additional methods or fields on behalf of a type. Spring AOP lets you introduce new interfaces (and a corresponding implementation) to any advised object. For example, you could use an introduction to make a bean implement an IsModified interface, to simplify caching. (An introduction is known as an inter-type declaration in the AspectJ community.)</p>
</blockquote>
<h3 id="实例">实例</h3>
<p>1、准备一个 IndexDao 接口</p>
<pre><code class="language-java">public interface IndexDao {
    void query(String str);
}
</code></pre>
<p>2、准备一个 IndexDao 接口的实现类</p>
<pre><code class="language-java">@Repository(&quot;indexDao&quot;)
public class IndexDaoImpl implements IndexDao {
    @Override
    public void query(String str){
        System.out.println(&quot;query&quot;);
        System.out.println(str);
    }
}
</code></pre>
<p>3、再准备一个接口 OrderDAO，并把它注入到 Spring 容器中</p>
<pre><code class="language-java">@Repository(&quot;orderDao&quot;)
public class OrderDao {
}
</code></pre>
<p>4、引入</p>
<pre><code class="language-java">@Component
// 切面
@Aspect
public class NotVeryUsefulAspect {
     // 找到 com.ssm.dao 下的所有类，让它引入 IndexDao 接口的 IndexDaoImpl 实现，
    // 即让 class OrderDao implements IndexDao，并且方法的具体实现与 IndexDaoImpl 相同
    @DeclareParents(value=&quot;com.ssm.dao.*&quot;, defaultImpl= IndexDaoImpl.class)
    public static IndexDao indexDao;
}
</code></pre>
<p>5、测试</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws IOException {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        IndexDao dao = (IndexDao) context.getBean(&quot;orderDao&quot;);
        dao.query(&quot;hello&quot;);
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>query
hello
</code></pre>
<p>6、分析：orderDao 内并没有方法，但是获得容器内的 OrderDao 对象后却可以正常调用  query() 方法，原因就是使用了 Introduction。</p>
<h2 id="aspect-instantiation-models">Aspect Instantiation Models</h2>
<p>使用方式如下：<br>
@Aspect(&quot;perthis(this(com.chenss.dao.IndexDaoImpl))&quot;)<br>
要求：</p>
<ol>
<li>AspectJ对象的注入类型为prototype</li>
<li>目标对象也必须是prototype的<br>
原因为：只有目标对象是原型模式的，每次getBean得到的对象才是不一样的，由此针对每个对象就会产生新的切面对象，才能产生不同的切面结果。</li>
</ol>
<h3 id="示例">示例</h3>
<p>1、多例的 IndexDaoImpl</p>
<pre><code class="language-java">@Repository(&quot;indexDao&quot;)
@Scope(&quot;prototype&quot;)
public class IndexDaoImpl implements IndexDao {
</code></pre>
<p>2、单例的切面</p>
<pre><code class="language-java">@Component
@Aspect
public class NotVeryUsefulAspect {
    // 切点 com.ssm.dao 下的子包下的任意类的任意方法 任意返回值 任意修饰符
    @Pointcut(&quot;execution(* com.ssm.dao.*.*(..))&quot;)
    public void pointCut(){
    }

    @Around(&quot;pointCut()&quot;)
    // ProceedingJoinPoint：正在进行的 JointPoint：正在增强的方法
    public void around(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println(&quot;this.hashCode = &quot; + this.hashCode());
        Object[] args = pjp.getArgs();
        if(args != null &amp;&amp; args.length &gt; 0){
            for (int i = 0; i &lt; args.length; i++) {
                args[i] += &quot; world&quot;;
            }
        }
        System.out.println(&quot;around...before&quot;);
        // 拿到方法并执行它
        pjp.proceed(args);
        System.out.println(&quot;around...after&quot;);
    }
}
</code></pre>
<p>3、测试类</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws IOException {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        IndexDao dao = (IndexDao) context.getBean(&quot;indexDao&quot;);
        IndexDao dao1 = (IndexDao) context.getBean(&quot;indexDao&quot;);
        // com.ssm.dao.impl.IndexDaoImpl@24aed80c : com.ssm.dao.impl.IndexDaoImpl@3a52dba3
        System.out.println(dao+&quot; : &quot;+dao1);
        dao.query(&quot;hello&quot;);
        System.out.println(&quot; - - - - - - - - - - - &quot;);
        dao1.query(&quot;hi&quot;);
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>com.ssm.dao.impl.IndexDaoImpl@24aed80c : com.ssm.dao.impl.IndexDaoImpl@3a52dba3
this.hashCode = 1792550665
around...before
query
hello world
around...after
 - - - - - - - - - - - 
this.hashCode = 1792550665
around...before
query
hi world
around...after
</code></pre>
<p>4、分析：<br>
当 IndexDaoImpl 设置为原型时，两次 context.getBean(&quot;indexDaoImpl&quot;) 得到的 IndexDaoImpl 是不同的对象。但是不同的 bean 对象得到的切面却是完全相同的。</p>
<p>更改：AspectJ 对象的注入类型为 prototype，为所有代理对象是 IndexDaoImpl 的单独创建一个切点出来</p>
<pre><code class="language-java">@Component
// 为所有代理对象是 IndexDaoImpl 的单独创建一个切点出来
@Aspect(&quot;perthis(this(com.ssm.dao.impl.IndexDaoImpl))&quot;)
@Scope(&quot;prototype&quot;)
public class NotVeryUsefulAspect {
</code></pre>
<p>CJLIB 动态代理</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
// 开启 AspectJ 语法支持
@EnableAspectJAutoProxy(proxyTargetClass=true)
public class AppConfig {
}
</code></pre>
<p>运行结果：</p>
<pre><code>com.ssm.dao.impl.IndexDaoImpl@672872e1 : com.ssm.dao.impl.IndexDaoImpl@32910148
this.hashCode = 254801937
around...before
query
hello world
around...after
 - - - - - - - - - - - 
this.hashCode = 90767234
around...before
query
hi world
around...after
</code></pre>
<h2 id="target-object目标对象">Target object：目标对象</h2>
<blockquote>
<p>Target object: An object being advised by one or more aspects. Also referred to as the “advised object”. Since Spring AOP is implemented by using runtime proxies, this object is always a proxied object.<br>
<img src="https://epitomm.github.io/post-images/AOP%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1.png" alt="图片" loading="lazy"></p>
</blockquote>
<h2 id="aop-proxy-代理对象">AOP proxy 代理对象</h2>
<blockquote>
<p>AOP proxy: An object created by the AOP framework in order to implement the aspect contracts (advise method executions and so on). In the Spring Framework, an AOP proxy is a JDK dynamic proxy or a CGLIB proxy.</p>
</blockquote>
<h2 id="weaving">Weaving</h2>
<blockquote>
<p>Weaving: linking aspects with other application types or objects to create an advised object. This can be done at compile time (using the AspectJ compiler, for example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks, performs weaving at runtime.<br>
<img src="https://epitomm.github.io/post-images/AOP%E7%BB%87%E5%85%A5.png" alt="图片" loading="lazy"></p>
</blockquote>
<h1 id="springaop-支持-aspectj">SpringAOP 支持 AspectJ</h1>
<p>AOP 和 SpringAOP 的 关系？SpringAOP 是 AOP 的一种实现。<br>
实现 AOP 的技术：AspectJ、SpringAOP<br>
SpringAOP 和 AspectJ 的关系？Spring 原先版本的 AOP 语法过于繁琐，于是 Spring 借助了 AspectJ 的语法，底层技术还是用的 Spring 底层的技术。<br>
参考资料：<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-ataspectj">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-ataspectj</a></p>
<h2 id="0-导入-spring-依赖">0、导入 Spring 依赖</h2>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
  &lt;version&gt;5.0.9.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>准备一个 IndexDao：</p>
<pre><code class="language-java">@Repository
public class IndexDao {
    public void query(){
        System.out.println(&quot;query&quot;);
    }
}
</code></pre>
<h2 id="1-启用aspectj支持">1、启用@AspectJ支持</h2>
<p>使用Java Configuration启用@AspectJ支持<br>
要使用Java @Configuration启用@AspectJ支持，请添加@EnableAspectJAutoProxy注释</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
@EnableAspectJAutoProxy
public class AppConfig {

}
</code></pre>
<p>使用XML配置启用@AspectJ支持<br>
要使用基于xml的配置启用@AspectJ支持，可以使用aop:aspectj-autoproxy元素</p>
<pre><code class="language-xml">&lt;aop:aspectj-autoproxy/&gt;
</code></pre>
<h2 id="2-声明一个aspect">2、声明一个Aspect</h2>
<p>引入 Aspect 依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
  &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
  &lt;version&gt;1.9.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>声明一个@Aspect注释类，并且定义成一个bean交给Spring管理。</p>
<pre><code class="language-java">@Component
@Aspect
public class UserAspect {
}
</code></pre>
<h2 id="3-声明一个pointcut">3、声明一个PointCut</h2>
<p>切入点表达式由@Pointcut注释表示。切入点声明由两部分组成:一个签名包含名称和任何参数，以及一个切入点表达式，该表达式确定我们对哪个方法执行感兴趣。</p>
<pre><code class="language-java">@Pointcut(&quot;execution(* transfer(..))&quot;)// 切入点表达式
private void anyOldTransfer() {}// 切入点签名
</code></pre>
<p>切入点确定感兴趣的 join points（连接点），从而使我们能够控制何时执行通知。Spring AOP只支持Spring bean的方法执行 join points（连接点），所以您可以将切入点看作是匹配Spring bean上方法的执行。</p>
<pre><code class="language-java">/**
 * 申明Aspect，并且交给spring容器管理
 */
@Component
@Aspect
public class UserAspect {
    /**
     * 申明切入点，匹配UserDao所有方法调用
     * execution匹配方法执行连接点
     * within:将匹配限制为特定类型中的连接点
     * args：参数
     * target：目标对象
     * this：代理对象
     */
    @Pointcut(&quot;execution(* com.yao.dao.UserDao.*(..))&quot;)
    public void pintCut(){
        System.out.println(&quot;point cut&quot;);
    }
</code></pre>
<h2 id="4-声明一个advice通知">4、声明一个Advice通知</h2>
<p>advice通知与pointcut切入点表达式相关联，并在切入点匹配的方法执行@Before之前、@After之后或前后运行。</p>
<pre><code class="language-java">/**
 * 申明Aspect，并且交给spring容器管理
 */
@Component
@Aspect
public class UserAspect {
    /**
     * 申明切入点，匹配UserDao所有方法调用
     * execution匹配方法执行连接点
     * within:将匹配限制为特定类型中的连接点
     * args：参数
     * target：目标对象
     * this：代理对象
     */
    @Pointcut(&quot;execution(* com.yao.dao.UserDao.*(..))&quot;)
    public void pintCut(){
        System.out.println(&quot;point cut&quot;);
    }
    /**
     * 申明before通知,在pintCut切入点前执行
     * 通知与切入点表达式相关联，
     * 并在切入点匹配的方法执行之前、之后或前后运行。
     * 切入点表达式可以是对指定切入点的简单引用，也可以是在适当位置声明的切入点表达式。
     */
    @Before(&quot;com.yao.aop.UserAspect.pintCut()&quot;)
    public void beforeAdvice(){
        System.out.println(&quot;before&quot;);
    }
}
</code></pre>
<p>测试类：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        IndexDao dao = context.getBean(IndexDao.class);
        dao.query();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>before
query
</code></pre>
<h1 id="各种连接点-joinpoint-的意义">各种连接点 JoinPoint 的意义:</h1>
<h2 id="execution">execution</h2>
<p>用于匹配方法执行连接点，最小粒度方法，在aop中主要使用。</p>
<pre><code class="language-java">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern)
          throws-pattern?)
</code></pre>
<p>这里问号表示当前项可以有也可以没有，其中各项的语义如下：<br>
modifiers-pattern：方法的可见性，如public，protected；<br>
ret-type-pattern：方法的返回值类型，如int，void等；<br>
declaring-type-pattern：方法所在类的全路径名，如com.spring.Aspect；<br>
name-pattern：方法名类型，如 buisinessService()；<br>
param-pattern：方法的参数类型，如java.lang.String；<br>
throws-pattern：方法抛出的异常类型，如java.lang.Exception；</p>
<h3 id="examples">Examples</h3>
<p>@Pointcut(&quot;execution(* com.chenss.dao.<em>.</em>(..))&quot;)//匹配com.chenss.dao包下的任意接口和类的任意方法【方法返回值类型任意，方法所在类的全路径名：com.chenss.dao，方法名类型任意，方法的参数类型任意】<br>
@Pointcut(&quot;execution(public * com.chenss.dao.<em>.</em>(..))&quot;)//匹配com.chenss.dao包下的任意接口和类的public方法<br>
@Pointcut(&quot;execution(public * com.chenss.dao.<em>.</em>())&quot;)//匹配com.chenss.dao包下的任意接口和类的public 无方法参数的方法<br>
@Pointcut(&quot;execution(* com.chenss.dao.<em>.</em>(java.lang.String, ..))&quot;)//匹配com.chenss.dao包下的任意接口和类的第一个参数为String类型的方法<br>
@Pointcut(&quot;execution(* com.chenss.dao.<em>.</em>(java.lang.String))&quot;)//匹配com.chenss.dao包下的任意接口和类的只有一个参数，且参数为String类型的方法<br>
@Pointcut(&quot;execution(* com.chenss.dao.<em>.</em>(java.lang.String))&quot;)//匹配com.chenss.dao包下的任意接口和类的只有一个参数，且参数为String类型的方法<br>
@Pointcut(&quot;execution(public * <em>(..))&quot;)//匹配任意的public方法<br>
@Pointcut(&quot;execution(</em> te*(..))&quot;)//匹配任意的以te开头的方法<br>
@Pointcut(&quot;execution(* com.chenss.dao.IndexDao.<em>(..))&quot;)//匹配com.chenss.dao.IndexDao接口中任意的方法<br>
@Pointcut(&quot;execution(</em> com.chenss.dao..<em>.</em>(..))&quot;)//匹配com.chenss.dao包及其子包中任意的方法</p>
<p>关于这个表达式的详细写法,可以脑补也可以参考官网很容易的,可以作为一个看spring官网文档的入门,打破你害怕看官方文档的心理,其实你会发觉官方文档也是很容易的<br>
<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-pointcuts-examples">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-pointcuts-examples</a></p>
<p>由于Spring切面粒度最小是达到方法级别，而execution表达式可以用于明确指定方法返回类型，类名，方法名和参数名等与方法相关的信息，并且在Spring中，大部分需要使用AOP的业务场景也只需要达到方法级别即可，因而execution表达式的使用是最为广泛的。</p>
<h2 id="within">within</h2>
<p>表达式的最小粒度为类<br>
within与execution相比，粒度更大，仅能实现到包和接口、类级别。而execution可以精确到方法的返回值，参数个数、修饰符、参数类型等</p>
<pre><code class="language-java">@Pointcut(&quot;within(com.chenss.dao.*)&quot;)//匹配com.chenss.dao包中的任意方法
@Pointcut(&quot;within(com.chenss.dao..*)&quot;)//匹配com.chenss.dao包及其子包中的任意方法
</code></pre>
<h2 id="args">args</h2>
<blockquote>
<p>args: Limits matching to join points (the execution of methods when using Spring AOP) where the arguments are instances of the given types.<br>
限制连接点的匹配(使用Spring AOP时方法的执行)，其中的参数是给定类型的实例。<br>
args表达式的作用是匹配指定参数类型和指定参数数量的方法,与包名和类名无关</p>
</blockquote>
<pre><code class="language-java">/**
 * args同execution不同的地方在于：
 * args匹配的是运行时传递给方法的参数类型
 * execution(* *(java.io.Serializable))匹配的是方法在声明时指定的方法参数类型。
 */
@Pointcut(&quot;args(java.io.Serializable)&quot;)//匹配运行时传递的参数类型为指定类型的、且参数个数和顺序匹配
@Pointcut(&quot;@args(com.chenss.anno.Chenss)&quot;)//接受一个参数，并且传递的参数的运行时类型具有@Classified
</code></pre>
<h2 id="this">this</h2>
<blockquote>
<p>this: Limits matching to join points (the execution of methods when using Spring AOP) where the bean reference (Spring AOP proxy) is an instance of the given type.<br>
限制连接点(使用Spring AOP时方法的执行)的匹配，其中bean引用(Spring AOP代理)是给定类型的实例。<br>
<strong>this JDK代理时，指向接口和代理类proxy，cglib代理时 指向接口和子类(不使用proxy)</strong></p>
</blockquote>
<h2 id="target">target</h2>
<p>target: Limits matching to join points (the execution of methods when using Spring AOP) where the target object (application object being proxied) is an instance of the given type.<br>
限制对连接点(使用Spring AOP时方法的执行)的匹配，其中目标对象(代理的应用程序对象)是给定类型的实例。<br>
<strong>target  指向接口和子类</strong>。</p>
<pre><code class="language-java">/**
 * 此处需要注意的是，如果配置设置proxyTargetClass=false，或默认为false，则是用JDK代理，否则使用的是CGLIB代理
 * JDK代理的实现方式是基于接口实现，代理类继承Proxy，实现接口。
 * 而CGLIB继承被代理的类来实现。
 * 所以使用target会保证目标不变，关联对象不会受到这个设置的影响。
 * 但是使用this对象时，会根据该选项的设置，判断是否能找到对象。
 */
@Pointcut(&quot;target(com.chenss.dao.IndexDaoImpl)&quot;)//目标对象，也就是被代理的对象。限制目标对象为com.chenss.dao.IndexDaoImpl类
@Pointcut(&quot;this(com.chenss.dao.IndexDaoImpl)&quot;)//当前对象，也就是代理对象，代理对象时通过代理目标对象的方式获取新的对象，与原值并非一个
@Pointcut(&quot;@target(com.chenss.anno.Chenss)&quot;)//具有@Chenss的目标对象中的任意方法
@Pointcut(&quot;@within(com.chenss.anno.Chenss)&quot;)//等同于@targ
</code></pre>
<p>这个比较难.......<br>
proxy模式里面有两个重要的术语<br>
proxy Class<br>
target Class<br>
CGLIB和JDK有区别    JDK是基于接口   cglib是基于继承，所有this可以在cglib作用</p>
<h2 id="annotation">@annotation</h2>
<p>这个很简单........<br>
作用<strong>方法</strong>级别<br>
上述所有表达式都有@ 比如@Target(里面是一个注解类xx,表示所有加了xx注解的类,和包名无关)<br>
注意:上述所有的表达式可以混合使用,|| &amp;&amp; !</p>
<pre><code class="language-java">@Before(&quot;pointCutWithin()&amp;&amp;!pointCutArgs()&quot;)
</code></pre>
<pre><code class="language-java">@Pointcut(&quot;@annotation(com.chenss.anno.Chenss)&quot;)//匹配带有com.chenss.anno.Chenss注解的方法
</code></pre>
<p>如下面这个方法：</p>
<pre><code class="language-java">@Chenss
public void query(String str){
</code></pre>
<h2 id="bean">bean</h2>
<pre><code class="language-java">@Pointcut(&quot;bean(dao1)&quot;)//名称为dao1的bean上的任意方法
@Pointcut(&quot;bean(dao*)&quot;)
</code></pre>
<h1 id="aop-proxies">AOP Proxies</h1>
<p>参考链接：<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-introduction-proxies">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-introduction-proxies</a></p>
<blockquote>
<p>Spring AOP defaults to using standard JDK dynamic proxies for AOP proxies. This enables any interface (or set of interfaces) to be proxied.<br>
Spring AOP 默认使用标准 JDK 动态代理来完成 AOP 代理。这允许代理任何接口(或一组接口)。</p>
</blockquote>
<h2 id="问题引入">问题引入</h2>
<p>1、定义一个接口</p>
<pre><code class="language-java">public interface IndexDao {
    void query(String str);
}
</code></pre>
<p>2、自定义一个注解</p>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
public @interface Luban {
}
</code></pre>
<p>3、定义切面，@annotation 连接点</p>
<pre><code class="language-java">@Component
// 切面
@Aspect
public class NotVeryUsefulAspect {
    @Pointcut(&quot;@annotation(com.ssm.anno.Luban)&quot;)
    public void pointCutAnno(){
    }
    /**
     * 通知
     *  通知位置：pointCut() 的前面
     *  通知内容
     */
    @Before(&quot;pointCutAnno()&quot;)
    public void before(){
        System.out.println(&quot;before&quot;);
    }
}
</code></pre>
<p>4、接口实现类，使用注解增强 query 方法</p>
<pre><code class="language-java">@Repository(&quot;indexDao&quot;)
public class IndexDaoImpl implements IndexDao {
    @Override
    @Luban
    public void query(String str){
        System.out.println(&quot;query&quot;);
    }
}
</code></pre>
<p>5、配置文件类</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
// 开启 AspectJ 语法支持
@EnableAspectJAutoProxy
public class AppConfig {
}
</code></pre>
<p>6、测试类</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        IndexDao dao = (IndexDao) context.getBean(&quot;indexDao&quot;);
        System.out.println(dao instanceof IndexDaoImpl);
        dao.query(&quot;111&quot;);
    }
}
</code></pre>
<p>7、运行结果：</p>
<pre><code>false
before
query
</code></pre>
<p>8、分析：为什么我们将一个 IndexDaoImpl 放入 Spring 容器（@Repository），然后再从 Spring 容器内取出来（context.getBean(&quot;indexDao&quot;)）类型却不是 IndexDaoImpl 了呢？<br>
9、在配置类中加上：@EnableAspectJAutoProxy(proxyTargetClass = true) 后，设置代理方式为 cglib 代理：</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
// 开启 AspectJ 语法支持
@EnableAspectJAutoProxy(proxyTargetClass = true)
public class AppConfig {
}
</code></pre>
<p>System.out.println(dao instanceof IndexDaoImpl); 返回 true 了。<br>
注：proxyTargetClass 默认是 false，所以 dao instanceof IndexDaoImpl 返回 false。</p>
<pre><code class="language-java">boolean proxyTargetClass() default false;
</code></pre>
<h2 id="spring-aop-默认使用标准-jdk-动态代理来完成-aop-代理">Spring AOP 默认使用标准 JDK 动态代理来完成 AOP 代理</h2>
<p>当我们使用 JDK 动态代理时，即 @EnableAspectJAutoProxy(proxyTargetClass = false)，从 Spring 容器中取出来的对象与放进去的对象不一致：context.getBean(&quot;indexDao&quot;) instanceof IndexDaoImpl 返回 false。<br>
但是 context.getBean(&quot;indexDao&quot;) instanceof indexDao 返回 true，因为 JDK 动态代理底层用的是接口。<br>
context.getBean(&quot;indexDao&quot;) instanceof Proxy 也返回 true。<br>
实现代理的办法</p>
<ul>
<li>继承</li>
<li>聚合接口（JDK 动态代理基于聚合）</li>
<li>动态代理</li>
</ul>
<h3 id="jdk-动态代理为什么只能是基于接口不能用继承">JDK 动态代理为什么只能是基于接口，不能用继承？</h3>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws IOException {
        Class&lt;?&gt;[] interfaces = new Class[]{IndexDao.class};
        byte[] bytes = ProxyGenerator.generateProxyClass(&quot;SSM&quot;,interfaces);
        File file = new File(&quot;C:\\Users\\Only\\Test.class&quot;);
        FileOutputStream fw = new FileOutputStream(file);
        fw.write(bytes);
        fw.flush();
        fw.close();
    }
}
</code></pre>
<p>注意：ProxyGenerator 的使用是基于 JDK8 的，如果使用 JDK10 会报 “找不到符号” 错误，参考：<a href="https://blog.csdn.net/weixin_46034990/article/details/105892718">https://blog.csdn.net/weixin_46034990/article/details/105892718</a><br>
JDK 底层源码已经帮这个对象自动继承了一个 Proxy 对象了，由于 Java 是单继承，所以不可能再去继承目标对象，所以只能实现目标对象的接口。<br>
<img src="https://epitomm.github.io/post-images/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.png" alt="图片" loading="lazy"><br>
基于上图可以看出，这个代理对象等于 IndexDao、也等于 Proxy，但是不等于 IndexDaoImpl，这也就解释了上述 【context.getBean(&quot;indexDao&quot;) instanceof IndexDaoImpl 返回 false。context.getBean(&quot;indexDao&quot;) instanceof indexDao 返回 true、context.getBean(&quot;indexDao&quot;) instanceof Proxy 也返回 true。】的原因。</p>
<h2 id="this-切点">this 切点</h2>
<p>this 表示<strong>代理对象</strong>的匹配类型<br>
前提：使用 JDK 动态代理，即 @EnableAspectJAutoProxy(proxyTargetClass = false)</p>
<pre><code class="language-java">@Component
// 切面
@Aspect
public class NotVeryUsefulAspect {
    // this 表示代理对象的匹配类型，使用 JDK 动态代理后，代理对象的类型是：Proxy、IndexDao，但不是 IndexDaoImpl
    @Pointcut(&quot;this(com.ssm.dao.IndexDao)&quot;)
    public void pointCutThis(){
        System.out.println(&quot;point cut&quot;);
    }
    /**
     * 通知
     *  通知位置：pointCut() 的前面
     *  通知内容
     */
    @Before(&quot;pointCutThis()&quot;)
    public void before(){
        System.out.println(&quot;before&quot;);
    }
}
</code></pre>
<p>增强成功：</p>
<pre><code>before
query
</code></pre>
<pre><code class="language-java">// this 表示代理对象的匹配类型，使用 JDK 动态代理后，代理对象的类型是：Proxy、IndexDao，但不是 IndexDaoImpl
@Pointcut(&quot;this(com.ssm.dao.impl.IndexDaoImpl)&quot;)
public void pointCutThis(){
    System.out.println(&quot;point cut&quot;);
}

@Before(&quot;pointCutThis()&quot;)
public void before(){
    System.out.println(&quot;before&quot;);
}
</code></pre>
<p>增强失败：</p>
<pre><code>query
</code></pre>
<h1 id="spring-aop-xml实现方式的注意事项">Spring AOP XML实现方式的注意事项:</h1>
<ol>
<li>在aop:config中定义切面逻辑，允许重复出现，重复多次，以最后出现的逻辑为准，但是次数以出现的次数为准</li>
<li>aop:aspect ID重复不影响正常运行，依然能够有正确结果</li>
<li>aop:pointcut ID重复会出现覆盖，以最后出现的为准。不同aop:aspect内出现的pointcut配置，可以相互引用</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/aop
                           http://www.springframework.org/schema/aop/spring-aop.xsd
                           http://www.springframework.org/schema/context
                           http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!-- 定义开始进行注解扫描 --&gt;
    &lt;context:component-scan base-package=&quot;com.chenss&quot;&gt;&lt;/context:component-scan&gt;

    &lt;!-- 定义AspectJ对象使用的逻辑类，类中提供切面之后执行的逻辑方法 --&gt;
    &lt;bean id=&quot;aspectAop&quot; class=&quot;com.chenss.aspectj.Aspect&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;aspectAop2&quot; class=&quot;com.chenss.aspectj.Aspect2&quot;&gt;&lt;/bean&gt;

    &lt;bean id=&quot;indexDao&quot; class=&quot;com.chenss.entity.IndexDao&quot;&gt;&lt;/bean&gt;

    &lt;!--在Config中定义切面逻辑，允许重复出现，重复多次，以最后出现的逻辑为准，但是次数以出现的次数为准--&gt;
    &lt;aop:config&gt;
        &lt;!-- aop:aspect ID重复不影响正常运行，依然能够有正确结果 --&gt;
        &lt;!-- aop:pointcut ID重复会出现覆盖，以最后出现的为准。不同aop:aspect内出现的pointcut配置，可以相互引用 --&gt;
        &lt;aop:aspect id=&quot;aspect&quot; ref=&quot;aspectAop&quot;&gt;
            &lt;aop:pointcut id=&quot;aspectCut&quot; expression=&quot;execution(* com.chenss.entity.*.*())&quot;/&gt;
            &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;aspectCut&quot;&gt;&lt;/aop:before&gt;
      
            &lt;aop:pointcut id=&quot;aspectNameCut&quot; expression=&quot;execution(* com.chenss.entity.*.*(java.lang.String, ..))&quot;/&gt;
            &lt;aop:before method=&quot;before2&quot; pointcut-ref=&quot;aspectNameCut&quot;&gt;&lt;/aop:before&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[spring-ioc 应用]]></title>
        <id>https://epitomm.github.io/post/spring-ioc/</id>
        <link href="https://epitomm.github.io/post/spring-ioc/">
        </link>
        <updated>2020-04-30T15:17:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="what-is-ioc">what is IOC</h1>
<p><strong>控制反转</strong>（Inversion of Control，缩写为<strong>IOC</strong>），是面向对象编程中的一种<strong>设计原则</strong>，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称<strong>DI</strong>），还有一种方式叫“依赖查找”（Dependency Lookup）</p>
<h2 id="ioc-和-di-的关系">IOC 和 DI 的关系</h2>
<p>IOC 是一种<strong>目标</strong>，DI 是实现 IOC 的<strong>技术手段</strong>。IOC 与 DI 的关系好似 ORM（对象关系映射） 和 Mybatis 的关系一样。</p>
<h2 id="dependency-injection">Dependency Injection</h2>
<ul>
<li>依赖注入</li>
</ul>
<h3 id="关于什么是依赖">关于什么是依赖</h3>
<pre><code class="language-java">// IndexService 依赖了 IndexDao 对象
public class IndexServiceImpl implements IndexService{
  private IndexDao indexDao;
}
</code></pre>
<p><strong>当一个类中拥有一个类的属性，或者构造方法中传了一个值，就可以说：当前这个类依赖于这个属性，或者依赖于构造方法里传入的对象</strong>。</p>
<p>Student 类中有一个 Address 类的属性，Student 类依赖于 Address 属性。</p>
<p>Student 类的构造方法的参数中有一个 Address 类，Student 类依赖于构造方法里传入的 Address 对象。</p>
<pre><code class="language-java">public class Student{
  private String name;
  private Integer age;
  private Address address;
  publci Student(String name,Integer age,Address address){
    this.name = name;
    this.age = age;
    this.address = address;
  }
}

public class Address{
  private String province;
  private String city;
}
</code></pre>
<h1 id="为什么要使用-spring-ioc">为什么要使用 Spring IOC</h1>
<h2 id="面向抽象编程">面向抽象编程</h2>
<pre><code class="language-java">public class IndexServiceImpl implements IndexService{
  public void test(){
     // 这样的写法会造成高耦合
     IndexDao indexDao = new IndexDaoImpl();
  }
}
</code></pre>
<p>假设有一天要对这个 IndexDao 进行一个代理，就不能通过 new 了，而是通过 Proxy.newXXX(); 就需要<strong>更改代码</strong>为：IndexDao indexDao = Proxy.newXXX(); <strong>一个类的产生不应该由程序员自己 new 出来</strong>。</p>
<p>面向抽象编程正确写法：</p>
<pre><code class="language-java">public class IndexServiceImpl implements IndexService{
  private IndexDao indexDao;
    public void test(){
     indexDao.call();
  }
}
</code></pre>
<p>无论 IndexDao 是代理还是本身实现，它都叫做 IndexDao，如果有一天需要一个代理类的话，只需要产生一个代理类，并且把这个代理类的代理对象<strong>传递过来就可以了</strong>。如果有一天不需要这个代理对象了，只需要把这个对象 new 出来传过来就可以了。</p>
<h2 id="如何传递过来呢">如何传递过来呢？</h2>
<p>提供一个 <strong>setter</strong> 或<strong>构造方法</strong>把这个类传递过来。</p>
<pre><code class="language-java">public class IndexServiceImpl implements IndexService{
  // 1.setter 方法
  // 2.构造方法，别人在 new 这个ServiceImpl 时就需要把具体的实现传进来
    public IndexServiceImpl(IndexDao dao){
  }
}
</code></pre>
<h2 id="spring体系结构-ioc的位置">spring体系结构----IOC的位置</h2>
<blockquote>
<p><a href="https://spring.io/projects">https://spring.io/projects</a><br>
Spring Framework<br>
Provides core support for dependency injection, transaction management, web apps, data access, messaging and more.<br>
提供了 DI、事务管理、web 开发和更多的核心支持<br>
<a href="https://spring.io/projects/spring-framework">https://spring.io/projects/spring-framework</a><br>
Features（特点）<br>
Core technologies（核心技术）: dependency injection（DI）, events, resources, i18n, validation, data binding, type conversion, SpEL, AOP.<br>
Testing: mock objects, TestContext framework, Spring MVC Test, WebTestClient.<br>
Data Access: transactions, DAO support, JDBC, ORM, Marshalling XML.<br>
Spring MVC and Spring WebFlux web frameworks.<br>
Integration: remoting, JMS, JCA, JMX, email, tasks, scheduling, cache.<br>
Languages: Kotlin, Groovy, dynamic languages.</p>
</blockquote>
<h2 id="容器">容器</h2>
<p>在日常程序开发过程当中，我们推荐<strong>面向抽象</strong>编程，面向抽象编程会产生<strong>类的依赖</strong>，当然如果你够强大可以自己写一个<strong>管理的容器</strong>，但是既然spring以及实现了，并且spring如此优秀，我们仅仅需要学习spring框架便可。</p>
<p>当我们有了一个管理对象的容器之后，<strong>类的产生过程交给了容器</strong>，至于我们自己的app则可以不需要去关系这些对象的产生了。</p>
<h1 id="spring-实现-ioc-的思路和方法">Spring 实现 IOC 的思路和方法</h1>
<p>Spring 实现 IOC 的思路是<strong>提供一些配置信息用来描述类之间的依赖关系，然后由容器去解析这些配置信息，继而维护好对象之间的依赖关系</strong>，前提是对象之间的依赖关系必须在类中定义好，比如 A.class 中有一个 B.class 的属性，那么我们可以理解为 A 依赖了 B。既然我们在类中已经定义了他们之间的依赖关系那么为什么还需要在配置文件中去描述和定义呢？</p>
<h2 id="spring-实现-ioc-的思路大致可以拆分成-3-点">Spring 实现 IOC 的思路大致可以拆分成 3 点</h2>
<ol>
<li>应用程序中提供类，提供依赖关系（属性或者构造方法）</li>
<li>把需要交给容器管理的<strong>对象</strong>通过配置信息告诉容器（xml、Annotation，JavaConfig）</li>
<li>把各个类之间的<strong>依赖关系</strong>通过配置信息告诉容器</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/springIOC.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>1、定义一个类 A，把类 A 和 类 B 的关系通过应用程序描述出来：类 A 中有一个类 B 的属性<br>
2、将类 A、类 B 交给 Spring 容器进行管理：使用 <bean><br>
3、在 xml 定义中描述类 A、类 B 之间的依赖关系</p>
</blockquote>
<h2 id="既然我们在类中已经定义了他们之间的依赖关系那么为什么还需要在配置文件中去描述和定义呢">既然我们在类中已经定义了他们之间的依赖关系那么为什么还需要在配置文件中去描述和定义呢？</h2>
<p>类中定义了但是 Spring 感知不到你是否需要依赖注入</p>
<p>配置这些信息的方法有三种分别是 xml，Annotation 和 JavaConfig</p>
<p>维护的过程称为<strong>自动注入</strong>，自动注入的方法有两种：**构造方法 **和 <strong>setter</strong></p>
<p>自动注入的值可以是对象，数组，map，list和常量比如字符串整形等</p>
<h1 id="spring编程的风格">spring编程的风格</h1>
<h2 id="schemal-based-xml">schemal-based-------xml</h2>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-schema-declaring-an-aspect">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-schema-declaring-an-aspect</a></p>
<pre><code class="language-xml">&lt;aop:config&gt;
    &lt;aop:aspect id=&quot;myAspect&quot; ref=&quot;aBean&quot;&gt;
        ...
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;

&lt;bean id=&quot;aBean&quot; class=&quot;...&quot;&gt;
    ...
&lt;/bean&gt;
</code></pre>
<h2 id="annotation-based-annotation">annotation-based-----annotation</h2>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-advice-before">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-advice-before</a></p>
<pre><code class="language-java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect
public class BeforeExample {

    @Before(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;)
    public void doAccessCheck() {
        // ...
    }

}
</code></pre>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-required-annotation">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-required-annotation</a></p>
<pre><code class="language-java">public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Required
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
</code></pre>
<h2 id="java-based-java-configuration">java-based----java Configuration</h2>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-java-basic-concepts">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-java-basic-concepts</a></p>
<pre><code class="language-java">@Configuration
public class AppConfig {

    @Bean
    public MyService myService() {
        return new MyServiceImpl();
    }
}
</code></pre>
<h1 id="注入">注入</h1>
<p>想看一部电影，可以有如下两种方法：</p>
<p>① 输入 url 到迅雷，然后下载下来：<strong>依赖查找</strong>：输入一个 url 找到一个资源。</p>
<p>② 下载一个播放器，输入我想要看的类型，就会自动推送这个类型的电影列表。</p>
<p>IOC 也是如此，仅仅需要在代码中提供依赖关系，由容器维护好，自动把对象提供给我们使用，给的过程称之为<strong>注入</strong>。</p>
<p>注入：提供一个 setter 方法或构造方法，Spring 就会把对象给我们。给我们的过程称为注入。</p>
<blockquote>
<p>Spring3 有接口注入，但是从 Spring4 开始就已经取消了。</p>
</blockquote>
<h2 id="spring注入详细配置字符串-数组等">spring注入详细配置（字符串、数组等）</h2>
<p>参考文档：</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-properties-detailed">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-properties-detailed</a></p>
<h3 id="字符串属性注入"><strong>字符串属性注入</strong></h3>
<p>使用 value：<property name="str" value=""/></p>
<pre><code class="language-java">package com.ssm.dao.impl;
import com.ssm.dao.IndexDao;
public class IndexDaoImpl implements IndexDao {
    private String str=&quot;&quot;;
    public void setStr(String str) {
        this.str = str;
    }
    public String getStr() {
        return str;
    }
    @Override
    public void test() {
        System.out.println(&quot;IndexDaoImpl...&quot;);
    }
}
</code></pre>
<pre><code class="language-xml">&lt;bean id=&quot;dao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot;&gt;
    &lt;property name=&quot;str&quot; value=&quot;Hello world&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="language-xml">&lt;bean id=&quot;myDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;
    &lt;!-- results in a setDriverClassName (String) call --&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mydb&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;masterkaoli&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="内部-bean">内部 bean</h3>
<p>原来是通过在 <property ref="xxx"/>，ref 引入外部 bean</p>
<p>内部 bean 是 <property><bean>  ... </bean></property>，在 property 标签内部注入 bean</p>
<pre><code class="language-xml">&lt;bean id=&quot;outer&quot; class=&quot;...&quot;&gt;
    &lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;
    &lt;property name=&quot;target&quot;&gt;
        &lt;bean class=&quot;com.example.Person&quot;&gt; &lt;!-- this is the inner bean --&gt;
            &lt;property name=&quot;name&quot; value=&quot;Fiona Apple&quot;/&gt;
            &lt;property name=&quot;age&quot; value=&quot;25&quot;/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="collections">Collections</h3>
<pre><code class="language-xml">&lt;bean id=&quot;moreComplexObject&quot; class=&quot;example.ComplexObject&quot;&gt;
    &lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;
    &lt;property name=&quot;adminEmails&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;administrator&quot;&gt;administrator@example.org&lt;/prop&gt;
            &lt;prop key=&quot;support&quot;&gt;support@example.org&lt;/prop&gt;
            &lt;prop key=&quot;development&quot;&gt;development@example.org&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeList(java.util.List) call --&gt;
    &lt;property name=&quot;someList&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;a list element followed by a reference&lt;/value&gt;
            &lt;ref bean=&quot;myDataSource&quot; /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeMap(java.util.Map) call --&gt;
    &lt;property name=&quot;someMap&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;an entry&quot; value=&quot;just some string&quot;/&gt;
            &lt;entry key =&quot;a ref&quot; value-ref=&quot;myDataSource&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeSet(java.util.Set) call --&gt;
    &lt;property name=&quot;someSet&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;just some string&lt;/value&gt;
            &lt;ref bean=&quot;myDataSource&quot; /&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="xml-shortcut-with-the-p-namespace">XML Shortcut with the p-namespace</h3>
<blockquote>
<p>Spring supports extensible configuration formats with namespaces, which are based on an XML Schema definition. The beans configuration format discussed in this chapter is defined in an XML Schema document. However, the p-namespace is not defined in an XSD file and exists only in the core of Spring.</p>
<p>Spring 支持带有名称空间的可扩展配置格式，这些名称空间基于XML模式定义。本章讨论的 bean 配置格式是在 XML 模式文档中定义的。但是，p-namespace 并没有在 XSD 文件中定义，它只存在于Spring 的核心中。</p>
</blockquote>
<p>1、在原有的基础上添加 xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 命名空间</p>
<p>2、<bean id="dao" class="com.ssm.dao.impl.IndexDaoImpl" p:str="Hello world"> 注入 等价于 原有的 <property name="str" value="Hello world"/>  注入。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;dao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot; p:str=&quot;Hello world&quot;&gt;
&lt;!--        &lt;property name=&quot;str&quot; value=&quot;Hello world&quot;&gt;&lt;/property&gt;--&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="xml-shortcut-with-the-c-namespace">XML Shortcut with the c-namespace</h3>
<p>如果类中定义了构造函数注入，但 bean 标签内没有声明 <constructor-arg> 就会产生 Caused by: java.lang.NoSuchMethodException: com.ssm.service.IndexService.<init>() 异常</p>
<pre><code>&lt;bean id=&quot;service&quot; class=&quot;com.ssm.service.IndexService&quot;&gt;&lt;!--        &lt;constructor-arg ref=&quot;dao&quot;&gt;&lt;/constructor-arg&gt;--&gt;&lt;/bean&gt;
</code></pre>
<p>使用 c-namespace 注入：<br>
1、添加 xmlns:c=&quot;http://www.springframework.org/schema/c&quot; 命名空间</p>
<p>2、<bean id="service" class="com.ssm.service.IndexService" c:indexDao-ref="dao"> 注入 等价于 原来的     <bean id="service" class="com.ssm.service.IndexService">  <constructor-arg ref="dao"></constructor-arg>  </bean></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;dao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot; p:str=&quot;Hello world&quot;&gt; 
&lt;!--        &lt;property name=&quot;str&quot; value=&quot;Hello world&quot;&gt;&lt;/property&gt;--&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;service&quot; class=&quot;com.ssm.service.IndexService&quot; c:indexDao-ref=&quot;dao&quot;&gt;
&lt;!--        &lt;constructor-arg ref=&quot;dao&quot;&gt;&lt;/constructor-arg&gt;--&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<h2 id="spring-通过-setter-注入的应用实例">Spring 通过 setter 注入的应用实例</h2>
<p>1、pom.xml 导入 spring 依赖</p>
<pre><code class="language-xml">&lt;!-- ioc 90% 以上的内容 --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
  &lt;version&gt;5.0.9.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、应用程序中提供类，提供依赖关系（属性或者构造方法）</p>
<p>IndexDao 类：</p>
<pre><code class="language-java">package com.ssm.dao;

public interface IndexDao {
    void test();
}
</code></pre>
<p>IndexDaoImpl 类：</p>
<pre><code class="language-java">package com.ssm.dao.impl;

import com.ssm.dao.IndexDao;

public class IndexDaoImpl implements IndexDao {

    @Override
    public void test() {
        System.out.println(&quot;IndexDaoImpl...&quot;);
    }
}
</code></pre>
<p>IndexService 依赖 Index：</p>
<p><strong>提供 setter 方法：</strong></p>
<pre><code class="language-java">package com.ssm.service;

import com.ssm.dao.IndexDao;

public class IndexService {

    private IndexDao indexDao;

    public void service(){
        indexDao.test();
    }

    // 提供 setter 方法
    public void setIndexDao(IndexDao indexDao) {
        this.indexDao = indexDao;
    }
}
</code></pre>
<p>3、把需要交给容器管理的对象通过配置信息告诉容器（xml、Annotation，JavaConfig）</p>
<p>4、把各个类之间的依赖关系通过配置信息告诉容器</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;dao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot;&gt;&lt;/bean&gt;

    &lt;bean id=&quot;service&quot; class=&quot;com.ssm.service.IndexService&quot;&gt;
        &lt;property name=&quot;indexDao&quot; ref=&quot;dao&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>5、测试</p>
<pre><code class="language-java">package com.ssm.test;

import com.ssm.service.IndexService;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test {
    public static void main(String[] args) {
        // ClassPathXmlApplicationContext：通过 ClassPath 下的 xml 初始化 Spring 应用环境
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
        IndexService service = (IndexService) context.getBean(&quot;service&quot;);
        service.service();
    }
}
</code></pre>
<p>6、运行结果</p>
<pre><code>IndexDaoImpl...注入的两种方法
</code></pre>
<h3 id="constructor-based-dependency-injection">Constructor-based Dependency Injection</h3>
<p>构造方法注入参考文档：</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-constructor-injection">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-constructor-injection</a></p>
<h4 id="构造方法注入实例">构造方法注入实例</h4>
<pre><code class="language-java">public class IndexService {
    private IndexDao indexDao;
    public IndexService(IndexDao indexDao){
        this.indexDao = indexDao;
    }
    public void service(){
        indexDao.test();
    }
}
</code></pre>
<p>xml 文件：</p>
<pre><code class="language-xml">&lt;bean id=&quot;dao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;service&quot; class=&quot;com.ssm.service.IndexService&quot;&gt;
  &lt;constructor-arg ref=&quot;dao&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5.png" alt="图片" loading="lazy"></figure>
<h3 id="setter-based-dependency-injection">Setter-based Dependency Injection</h3>
<p>setter参考文档：</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-setter-injection">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-setter-injection</a></p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/setter%E6%B3%A8%E5%85%A5.png" alt="图片" loading="lazy"></figure>
<h2 id="注解-xml-混合使用">注解 + xml 混合使用</h2>
<p>1、xml 内 的ref 引用 dao</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;service&quot; class=&quot;com.ssm.service.IndexService&quot; c:indexDao-ref=&quot;dao&quot;&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>2、使用注解声明 dao：</p>
<pre><code class="language-java">@Component(&quot;dao&quot;)
public class IndexDaoImpl implements IndexDao {
</code></pre>
<p>3、报错：找不到 dao</p>
<p>Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named 'dao' available</p>
<p>4、分析：没有开启注解、没有注解扫描</p>
<h3 id="开启注解">开启注解：</h3>
<p>1、xml 中添加 context 相关内容</p>
<pre><code class="language-xml">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
 xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;
</code></pre>
<p>2、开启注解（现在 Spring 版本不写开启注解、只写注解扫描，也能实现功能）</p>
<pre><code class="language-xml">&lt;context:annotation-config /&gt;
</code></pre>
<p>3、开启注解扫描</p>
<pre><code class="language-xml">&lt;context:component-scan base-package=&quot;com.ssm&quot;/&gt;
</code></pre>
<p>将 service 的 bean 声明也使用注解，于是就可以删除 xml 中的 id 为 service 的 bean 标签了。</p>
<pre><code class="language-java">@Service(value = &quot;service&quot;)
public class IndexService {
</code></pre>
<p>完整代码：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!-- 开启注解 --&gt;
    &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt;
    &lt;!-- 开启注解扫描 --&gt;
    &lt;context:component-scan base-package=&quot;com.ssm&quot;&gt;&lt;/context:component-scan&gt;
&lt;/beans&gt;
</code></pre>
<p>4、测试，运行结果：</p>
<pre><code>IndexDaoImpl...
</code></pre>
<p>总结：以上这种注解方式一定需要 xml，因为需要在 xml 内<strong>开启注解扫描</strong>。</p>
<p>有没有办法删掉 xml 呢？答：JavaConfig 配置方式</p>
<h2 id="javaconfig-配置方式">JavaConfig 配置方式</h2>
<p>1、编写配置类</p>
<pre><code class="language-java">package com.ssm.config;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.stereotype.Component;
// 表明这是一个 xml 文件
@Configuration
// 扫描包
@ComponentScan(&quot;com.ssm&quot;)      
public class SpringConfig {
}
</code></pre>
<p>2、修改测试类 Test</p>
<pre><code class="language-java">package com.ssm.test;
import com.ssm.config.SpringConfig;
import com.ssm.service.IndexService;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        IndexService service = (IndexService) context.getBean(&quot;service&quot;);
        service.service();
    }
}
</code></pre>
<p>3、测试，运行结果：</p>
<pre><code>IndexDaoImpl...
</code></pre>
<h2 id="javaconfig-xml-注解配置">JavaConfig + xml +注解配置</h2>
<p>1、Sservice 的注入使用注解方式</p>
<pre><code>@Service(&quot;service&quot;)
public class IndexService {
</code></pre>
<p>2、Dao 的注入使用 xml 方式</p>
<pre><code class="language-java">public class IndexDaoImpl implements IndexDao {
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!-- 开启注解 --&gt;
    &lt;context:annotation-config/&gt;
    &lt;!-- 开启注解扫描 --&gt;
    &lt;context:component-scan base-package=&quot;com.ssm&quot;/&gt;
    &lt;bean id=&quot;dao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot; p:str=&quot;Hello world&quot;&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>3、JavaConfig 配置类引入 xml 文件</p>
<pre><code class="language-java">// 表明这是一个 xml 文件
@Configuration
// 扫描包
@ComponentScan(&quot;com.ssm&quot;)
// 引入 xml 配置文件
@ImportResource(&quot;classpath:spring.xml&quot;)
public class SpringConfig {
}
</code></pre>
<p>4、测试类</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        IndexService service = (IndexService) context.getBean(&quot;service&quot;);
        service.service();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>IndexDaoImpl...
</code></pre>
<h1 id="自动装配">自动装配</h1>
<p>上面说过，IOC 的注入有两个地方需要提供依赖关系，一是类的定义中，二是在spring的配置中需要去描述。自动装配则把第二个取消了，即我们仅仅需要在类中提供依赖，继而把对象交给容器管理即可完成注入。</p>
<p>在实际开发中，描述类之间的依赖关系通常是大篇幅的，如果使用自动装配则省去了很多配置，并且如果对象的依赖发生更新我们可以不需要去更新配置，但是也带来了一定的缺点</p>
<h2 id="自动装配的优点">自动装配的优点</h2>
<p>参考文档：</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire</a></p>
<blockquote>
<p>The Spring container can autowire relationships between collaborating beans. You can let Spring resolve collaborators (other beans) automatically for your bean by inspecting the contents of the ApplicationContext. Autowiring has the following advantages:</p>
</blockquote>
<p>Spring容器可以自动创建协作 bean 之间的关系。通过检查 ApplicationContext 的内容，您可以让 Spring 为您的 bean 自动解析协作者(其他bean)。自动装配有以下优点:</p>
<blockquote>
<p>Autowiring can significantly reduce the need to specify properties or constructor arguments. (Other mechanisms such as a bean template discussed elsewhere in this chapter are also valuable in this regard.)</p>
</blockquote>
<p>自动装配可以大大减少指定属性或构造函数参数的需要。(本章其他地方讨论的其他机制，如bean模板，在这方面也很有价值。)</p>
<blockquote>
<p>Autowiring can update a configuration as your objects evolve. For example, if you need to add a dependency to a class, that dependency can be satisfied automatically without you needing to modify the configuration. Thus autowiring can be especially useful during development, without negating the option of switching to explicit wiring when the code base becomes more stable.</p>
</blockquote>
<p>自动装配可以随着对象的演化更新配置。例如，如果需要向类添加依赖，则可以自动更新该依赖，而不需要修改配置。因此，自动装配在开发过程中特别有用，当代码库变得更加稳定时，自动装配可以避免切换到显式连接的选项。</p>
<pre><code class="language-xml">&lt;bean id=&quot;indexService&quot; class=&quot;com.ssm.service.IndexService&quot;&gt;
    &lt;property name=&quot;indexDao&quot; ref=&quot;dao&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>分析：上述配置需要手动添加依赖，比如现在 IndexService 新增了依赖 helloDao：</p>
<pre><code class="language-java">public class IndexService{
  private IndexDao indexDao;
  private HelloDao helloDao;
}
</code></pre>
<p>就需要在 xml 的 <bean> 内增加 <property name="hello" ref="hello"/></p>
<pre><code class="language-xml">&lt;bean id=&quot;indexService&quot; class=&quot;com.ssm.service.IndexService&quot;&gt;
    &lt;property name=&quot;indexDao&quot; ref=&quot;dao&quot;/&gt;
     &lt;property name=&quot;hello&quot; ref=&quot;hello&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>使用了自动装配后，就无须手动在 xml 中增加依赖进行维护了，<strong>自动装配可以自动更新该依赖，而不需要修改配置</strong>。</p>
<h2 id="自动装配的缺点">自动装配的缺点</h2>
<p>参考文档：</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-autowired-exceptions">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-autowired-exceptions</a></p>
<p>作为我来讲，我觉得以上缺点都不是缺点</p>
<h2 id="自动装配的方法">自动装配的方法</h2>
<p>自动装配的方式参考文档：</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire</a></p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Mode</strong></th>
<th style="text-align:left"><strong>Explanation</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">no ( 不使用自动装配 )</td>
<td style="text-align:left">(默认)没有自动装配。Bean 引用必须由 ref 元素定义。对于较大的部署，不建议更改默认设置，因为显式地指定协作者可以提供更好的控制和清晰度。在某种程度上，它记录了一个系统的结构。</td>
</tr>
<tr>
<td style="text-align:left">byName</td>
<td style="text-align:left">通过属性名自动装配。Spring 寻找与需要自动装配的属性同名的 bean。例如，如果一个 bean 定义被按名称设置为自动装配，并且它包含一个主属性(也就是说，它有一个setMaster(..)方法)，Spring 会查找一个名为master 的 bean 定义并使用它来设置属性。</td>
</tr>
<tr>
<td style="text-align:left">byType</td>
<td style="text-align:left">如果容器中恰好存在该属性类型的一个 bean，则允许自动获取该属性。如果存在多个异常，则抛出一个致命异常，这表明您不能为该 bean 使用byType 自动装配。如果没有匹配的 bean，则什么也不会发生(属性没有设置)。</td>
</tr>
<tr>
<td style="text-align:left">constructor</td>
<td style="text-align:left">类似于 byType，但适用于构造函数参数。如果容器中没有一个构造函数参数类型的 bean，则会引发致命错误。</td>
</tr>
</tbody>
</table>
<h3 id="bytype-自动装配实例">byType 自动装配实例</h3>
<p>1、IndexService 依赖 IndexDao</p>
<pre><code class="language-java">public class IndexService {
    private IndexDao indexDao;
    public void service(){
        indexDao.test();
    }
    public void setIndexDao(IndexDao indexDao) {
        this.indexDao = indexDao;
    }
}
</code></pre>
<p>2、使用自动装配：beans 标签内导入 default-autowire=&quot;byType&quot;</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;
        default-autowire=&quot;byType&quot;&gt;

    &lt;!-- 开启注解 --&gt;
    &lt;context:annotation-config/&gt;
    &lt;!-- 开启注解扫描 --&gt;
    &lt;context:component-scan base-package=&quot;com.ssm&quot;/&gt;

    &lt;bean id=&quot;dao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot;&gt;
    &lt;/bean&gt;

    &lt;!-- IndexService 内应该注入 IndexDao，但因为指定了自动装配，所以可以不显式通过 property 标签注入 IndexDao --&gt;
    &lt;bean id=&quot;indexService&quot; class=&quot;com.ssm.service.IndexService&quot;&gt;
&lt;!--        &lt;property name=&quot;indexDao&quot; ref=&quot;dao&quot;/&gt;--&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>分析：IndexService 内应该注入 IndexDao，但因为通过 default-autowire=&quot;byType&quot; 指定了自动装配，所以可以不显式通过 property 标签注入 IndexDao。</p>
<p>在扫描到 IndexService 类时，发现该类依赖了 IndexDao，发现它的类型是 IndexDao，到 Spring 容器中找类型或父类类型为 IndexDao 的，如果有，就把这个对象直接赋给 IndexService 中的 IndexDao。</p>
<blockquote>
<p>自动装配并不是完全不需要配置了，自动装配仍需要配置 bean，将类交给 Spring 容器管理，自动装配省略了类与类之间依赖的管理，比如类 A 依赖类 B，无需配置依赖关系了，Spring 会自动到容器中找到类 B 然后把它赋给类 A 的成员变量。</p>
</blockquote>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D.png" alt="图片" loading="lazy"></figure>
<h4 id="bytype-自动装配多个相同类型的问题">byType 自动装配多个相同类型的问题</h4>
<p>当有多个相同类型时，会报错</p>
<p>1、添加一个 IndexDaoImpl2 类</p>
<pre><code class="language-java">public class IndexDaoImpl2 implements IndexDao {
    @Override
    public void test() {
        System.out.println(&quot;IndexDaoImpl...2&quot;);
    }
}
</code></pre>
<p>2、把 IndexDaoImpl2 交给 Spring 容器管理，现在 Spring 容器内有两个 type = IndexDao 的类：IndexDaoImp、IndexDaoImpl2</p>
<pre><code class="language-xml">&lt;bean id=&quot;dao2&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl2&quot;/&gt;
</code></pre>
<p>3、测试结果：</p>
<p>Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'com.ssm.dao.IndexDao' available: expected single matching bean but found 2: dao,dao2</p>
<p>需要单个匹配，但是发现了两个：dao、dao2</p>
<h3 id="byname-自动装配实例">byName 自动装配实例</h3>
<p>1、beans 标签内指定 byName 自动装配：</p>
<pre><code>default-autowire=&quot;byName&quot;
</code></pre>
<p>2、如果没有指定 <bean> 标签的 name 属性，name 默认为将 setIndexDao 的 set 去掉、第一个字母小写，即 name=indexDao</p>
<pre><code class="language-java">public class IndexService {
    private IndexDao indexDao;
    public void service(){
        indexDao.test();
    }
    public void setIndexDao(IndexDao indexDao) {
        this.indexDao = indexDao;
    }
}
</code></pre>
<p>3、于是到 Spring 容器内找 name=indexDao 的，没有找到，报错 Exception in thread &quot;main&quot; java.lang.NullPointerException</p>
<pre><code class="language-xml">&lt;bean id=&quot;dao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot;/&gt;
&lt;bean id=&quot;dao2&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl2&quot;/&gt;
</code></pre>
<p>解决办法一：</p>
<p>1、改变 set 方法的方法名：</p>
<pre><code class="language-java">public void setDao(IndexDao indexDao) {
    this.indexDao = indexDao;
}
</code></pre>
<p>2、测试成功：</p>
<pre><code>IndexDaoImpl...
</code></pre>
<p>解决方法二：</p>
<p>1、set 方法不变</p>
<pre><code>public void setIndexDao(IndexDao indexDao) {
    this.indexDao = indexDao;
 }
</code></pre>
<p>2、给 bean 标签添加 name 属性</p>
<pre><code>&lt;bean id=&quot;dao2&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl2&quot; name=&quot;indexDao&quot;&gt;&lt;/bean&gt;
</code></pre>
<p>3、测试成功</p>
<pre><code>IndexDaoImpl...2
</code></pre>
<h3 id="default-no-不使用自动装配">default = no 不使用自动装配</h3>
<p>beans 标签内部增加如下说明：</p>
<p>default-autowire=&quot;default&quot;</p>
<p>default=autowire=&quot;no&quot;</p>
<p>异常信息：Exception in thread &quot;main&quot; java.lang.NullPointerException</p>
<p>其他都想手动装配，唯独 IndexService 想自动装配，就不能在 beans 标签内添加 default-autowire 了，可以<strong>为每一个属性单独指定一个 autowire</strong></p>
<pre><code class="language-xml">&lt;bean id=&quot;indexService&quot; class=&quot;com.ssm.service.IndexService&quot; autowire=&quot;byType&quot;/&gt;
</code></pre>
<p>参考资料：<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-stereotype-annotations">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-stereotype-annotations</a></p>
<blockquote>
<p>Spring provides further stereotype annotations: @Component, @Service, and @Controller. @Component is a generic stereotype for any Spring-managed component. @Repository, @Service, and @Controller are specializations of @Component for more specific use cases (in the persistence, service, and presentation layers, respectively). Therefore, you can annotate your component classes with @Component, but, by annotating them with @Repository, @Service, or @Controller instead, your classes are more properly suited for processing by tools or associating with aspects. For example, these stereotype annotations make ideal targets for pointcuts. @Repository, @Service, and @Controller can also carry additional semantics in future releases of the Spring Framework. Thus, if you are choosing between using @Component or @Service for your service layer, @Service is clearly the better choice. Similarly, as stated earlier, @Repository is already supported as a marker for automatic exception translation in your persistence layer.</p>
</blockquote>
<p>Spring提供了更多的的构造型注解:@Component， @Service，和@Controller。@Component 是任何spring管理组件的通用注解。@Repository、@Service和@Controller是@Component对更具体用例(分别在持久性、服务和表示层)的专门化。因此，您可以使用@Component来注释您的组件类，但是，通过使用@Repository、@Service或@Controller来注释它们，您的类更适合通过工具进行处理或与方面相关联。例如，这些构造型注释是切入点的理想目标。在Spring框架的未来版本中，@Repository、@Service和 @Controller 也可以包含额外的语义。因此，如果您在使用@Component或@Service作为服务层之间进行选择，那么@Service显然是更好的选择。类似地，如前所述，@Repository已经被支持作为持久层中自动异常转换的标记。</p>
<h2 id="autowired-默认采用-bytype-注入">@Autowired 默认采用 byType 注入</h2>
<p>1、JavaConfig 配置类</p>
<ul>
<li>声明这是一个注解类</li>
<li>扫描包</li>
</ul>
<pre><code class="language-java">// 表明这是一个 xml 文件
@Configuration
// 注解扫描包
@ComponentScan(&quot;com.ssm&quot;)
public class SpringConfig {
}
</code></pre>
<p>2、@Service 注解</p>
<ul>
<li>@Autowired注入 IndexDao</li>
<li>setIndexDao 方法</li>
</ul>
<pre><code class="language-java">@Service
public class IndexService {
    @Autowired
    private IndexDao indexDao;
    public void service(){
        indexDao.test();
    }
    public void setIndexDao(IndexDao indexDao) {
        this.indexDao = indexDao;
    }
}
</code></pre>
<p>3、IndexDao 类型的 IndexDaoImpl 类</p>
<pre><code class="language-java">@Repository
public class IndexDaoImpl implements IndexDao {
    @Override
    public void test() {
        System.out.println(&quot;IndexDaoImpl...&quot;);
    }
}
</code></pre>
<p>4、相同 IndexDao 类型的 IndexDaoImpl2</p>
<pre><code class="language-java">@Repository
public class IndexDaoImpl2 implements IndexDao {
    @Override
    public void test() {
        System.out.println(&quot;IndexDaoImpl...2&quot;);
    }
}
</code></pre>
<p>5、测试类</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        IndexService service = (IndexService) context.getBean(&quot;indexService&quot;);
        service.service();
    }
}
</code></pre>
<p>6、运行结果：</p>
<p>Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'com.ssm.dao.IndexDao' available: expected single matching bean but found 2: indexDaoImpl,indexDaoImpl2</p>
<p>期望一个匹配的 IndexDao 类型的 bean，却发现了两个：indexDaoImpl、indexDaoImpl2</p>
<p>7、分析</p>
<p>@Autowired 注解默认使用的是 byType 自动装配方式。</p>
<p>当执行 @Autowired 注入时，到 Spring 容器中找 IndexDao 类型或父类为 IndexDao 类型的，结果找到了 IndexDaoImpl、IndexDaoImpl2，注入失败。此时根据 byType 找到多个类，则根据 byName 注入（private IndexDao indexDao;）因为没有名为 indexDao 的组件，所以注入失败。</p>
<p><strong>@Autowired 默认采用 byType 注入，如果 byType 找到多个，则根据 byName 注入</strong>，name 为属性名 indexDaoImpl2（private IndexDao indexDaoImpl2）。当根据 name 值注入时，仅与属性值有关，与 set 方法的方法名无关。</p>
<pre><code class="language-java">@Service
public class IndexService {
    @Autowired
    private IndexDao indexDaoImpl2;
    public void service(){
        indexDaoImpl2.test();
    }
    public void setIndexDao(IndexDao indexDao) {
        this.indexDaoImpl2 = indexDao;
    }
}
</code></pre>
<p>Spring 容器中找到 name 为 indexDaoImpl2 的组件，注入成功</p>
<pre><code class="language-java">@Repositorypublic class IndexDaoImpl2 implements IndexDao {
</code></pre>
<p>运行结果：</p>
<pre><code>IndexDaoImpl...2
</code></pre>
<h2 id="resource-默认采用-byname-注入">@Resource 默认采用 byName 注入</h2>
<pre><code class="language-java">@Resource
private IndexDao indexDaoImpl2;
</code></pre>
<p>@Resource 模式采用 byName 注入，并且 name 的值为属性值 indexDaoImpl2，与 set 方法的名字无关。</p>
<h2 id="spring-默认-bean-名称的生成策略">Spring 默认 bean 名称的生成策略</h2>
<pre><code class="language-java">@Repository
public class IndexDaoImpl implements IndexDao {
</code></pre>
<p>Spring 中如果不显式指定 bean 的名字，默认 bean 的名称为类名首字母变小写，即：indexDaoImpl</p>
<p>参考资料：<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-scanning-name-generator">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-scanning-name-generator</a></p>
<blockquote>
<p>When a component is autodetected as part of the scanning process, its bean name is generated by the BeanNameGenerator strategy known to that scanner. By default, any Spring stereotype annotation (@Component, @Repository, @Service, and @Controller) that contains a name value thereby provides that name to the corresponding bean definition.</p>
</blockquote>
<p>当一个组件作为扫描过程的一部分被自动检测时，它的bean名称由该扫描程序所知道的BeanNameGenerator策略生成。默认情况下，任何包含名称值的Spring构造型注释(@Component、@Repository、@Service和@Controller)都将该名称提供给相应的bean定义。</p>
<blockquote>
<p>If such an annotation contains no name value or for any other detected component (such as those discovered by custom filters), the default bean name generator returns the uncapitalized non-qualified class name. For example, if the following component classes were detected, the names would be myMovieLister and movieFinderImpl:</p>
</blockquote>
<p>如果这样的注释不包含名称值或任何其他检测到的组件(例如由自定义过滤器发现的组件)，则默认bean名称生成器将返回未大写的非限定类名。例如，如果检测到以下组件类，其名称将是myMovieLister和movieFinderImpl:</p>
<pre><code class="language-java">@Service(&quot;myMovieLister&quot;)
public class SimpleMovieLister {
    // ...
}
</code></pre>
<pre><code>@Repository
public class MovieFinderImpl implements MovieFinder {
    // ...
}
</code></pre>
<blockquote>
<p>If you do not want to rely on the default bean-naming strategy, you can provide a custom bean-naming strategy. First, implement the BeanNameGenerator interface, and be sure to include a default no-arg constructor. Then, provide the fully qualified class name when configuring the scanner, as the following example annotation and bean definition show.</p>
</blockquote>
<p>如果不希望依赖默认的 bean 命名策略，可以提供自定义 bean 命名策略。首先，实现BeanNameGenerator 接口，并确保包含一个默认的无参数构造函数。然后，在配置扫描程序时提供完全限定的类名，如下面的注释和 bean 定义示例所示。</p>
<p>如果由于多个自动检测到的组件具有相同的非限定类名(即您可能需要配置一个BeanNameGenerator，该生成器默认为生成的bean名称的完全限定类名。从Spring Framework 5.2.3开始，FullyQualifiedAnnotationBeanNameGenerator位于包org.springframework.context中。注释可以用于这些目的。</p>
<pre><code class="language-java">@Configuration
@ComponentScan(basePackages = &quot;org.example&quot;, nameGenerator = MyNameGenerator.class)
public class AppConfig {
    // ...
}
</code></pre>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;context:component-scan base-package=&quot;org.example&quot;
        name-generator=&quot;org.example.MyNameGenerator&quot; /&gt;
&lt;/beans&gt;
</code></pre>
<h1 id="spring懒加载">spring懒加载</h1>
<p>官网已经解释的非常清楚了：</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lazy-init">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lazy-init</a></p>
<blockquote>
<p>By default, ApplicationContext implementations eagerly create and configure all singleton beans as part of the initialization process. Generally, this pre-instantiation is desirable, because errors in the configuration or surrounding environment are discovered immediately, as opposed to hours or even days later. When this behavior is not desirable, you can prevent pre-instantiation of a singleton bean by marking the bean definition as being lazy-initialized. A lazy-initialized bean tells the IoC container to create a bean instance when it is first requested, rather than at startup.</p>
</blockquote>
<p>默认情况下，ApplicationContext实现将创建和配置所有的单例 bean 作为初始化过程的一部分。通常，这种预实例化是可取的，因为配置或周围环境中的错误会立即被发现，而不是几小时甚至几天之后。当此行为不可取时，您可以通过将 bean 定义标记为延迟初始化来防止单例 bean 的预实例化。延迟初始化的bean 告诉 IoC 容器在第一次请求时创建 bean 实例，而不是在启动时。</p>
<pre><code class="language-xml">&lt;bean id=&quot;lazy&quot; class=&quot;com.something.ExpensiveToCreateBean&quot; lazy-init=&quot;true&quot;/&gt;
&lt;bean name=&quot;not.lazy&quot; class=&quot;com.something.AnotherBean&quot;/&gt;
</code></pre>
<p>您还可以使用 <beans/> 元素上的 default-lazy-init 属性来控制容器级别的延迟初始化，如下面的示例所示：</p>
<figure data-type="image" tabindex="5"><img src="https://images-cdn.shimo.im/AL7NwUqEre0woKxB/image.png!thumbnail" alt="图片" loading="lazy"></figure>
<h1 id="springbean的作用域">springbean的作用域</h1>
<p>文档参考：</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes</a></p>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/SpringBean%E4%BD%9C%E7%94%A8%E5%9F%9F.png" alt="图片" loading="lazy"></figure>
<h2 id="singleton">singleton</h2>
<pre><code class="language-java">@Service@Scope(&quot;singleton&quot;)
public class IndexService {
</code></pre>
<p>测试结果：</p>
<pre><code>com.ssm.service.IndexService@5884a914
IndexDaoImpl...2
com.ssm.service.IndexService@5884a914
</code></pre>
<p>两次获得到的 Service 对象是同一个实例：单例。</p>
<h2 id="prototype">prototype</h2>
<pre><code class="language-java">@Service
@Scope(&quot;prototype&quot;)
public class IndexService {
    @Autowired
    private IndexDao indexDaoImpl2;
    public void service(){
        indexDaoImpl2.test();
    }
}
</code></pre>
<p>测试</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        IndexService service = (IndexService) context.getBean(&quot;indexService&quot;);
        System.out.println(service);
        service.service();
        service = (IndexService) context.getBean(&quot;indexService&quot;);
        System.out.println(service);
    }
}
</code></pre>
<p>结果：</p>
<pre><code>com.ssm.service.IndexService@5884a914
IndexDaoImpl...2
com.ssm.service.IndexService@50378a4
</code></pre>
<p>两次得到的 Service 对象是两个对象：多例。</p>
<h3 id="xml定义方式">xml定义方式</h3>
<pre><code>&lt;bean id=&quot;accountService&quot; class=&quot;com.something.DefaultAccountService&quot; scope=&quot;singleton&quot;/&gt;
</code></pre>
<h3 id="annotation的定义方式">annotation的定义方式</h3>
<pre><code class="language-java">@Service
@Scope(&quot;prototype&quot;)
public class IndexService {
</code></pre>
<h2 id="singleton-beans-with-prototype-bean-dependencies">Singleton Beans with Prototype-bean Dependencies</h2>
<p>意思是在 Singleton 当中引用了一个 Prototype 的 bean 的时候引发的问题：</p>
<p>在单例对象中引用多例 bean，这个多例 bean 就失去了意义。</p>
<p>1、IndexService 单例</p>
<pre><code class="language-java">@Service
@Scope(&quot;singleton&quot;)
public class IndexService {
    @Autowired
    private IndexDao indexDao;
    public void service(){
        System.out.println(this);
        System.out.println(indexDao);
    }
}
</code></pre>
<p>2、IndexDao 多例</p>
<pre><code class="language-java">@Repository
@Scope(&quot;prototype&quot;)
public class IndexDaoImpl implements IndexDao {
</code></pre>
<p>3、测试</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        IndexService service = (IndexService) context.getBean(&quot;indexService&quot;);
        service.service();
        System.out.println(&quot; - - - - - - - - - &quot;);
        service = (IndexService) context.getBean(&quot;indexService&quot;);
        service.service();
        System.out.println(&quot; - - - - - - - - - &quot;);
        service = (IndexService) context.getBean(&quot;indexService&quot;);
        service.service();
    }
}
</code></pre>
<p>4、结果：</p>
<pre><code>com.ssm.service.IndexService@4d14b6c2
com.ssm.dao.impl.IndexDaoImpl@7e990ed7
 - - - - - - - - - 
com.ssm.service.IndexService@4d14b6c2
com.ssm.dao.impl.IndexDaoImpl@7e990ed7
 - - - - - - - - - 
com.ssm.service.IndexService@4d14b6c2
com.ssm.dao.impl.IndexDaoImpl@7e990ed7
</code></pre>
<p>5、分析：</p>
<p>虽然 IndexDaoImpl 是多例的，但是 IndexDaoImpl 是 IndexService 的一个属性，而 IndexService 是单例的，就造成了每次打印的 IndexDaoImpl 都是一样的。</p>
<p>解决方案一：</p>
<p>1、通过实现 applicationcontext - ware 接口，并在每次 bean A 需要时调用容器的 getBean(“B”) 来请求(通常是一个新的)bean B实例，从而使 bean A 知道容器。</p>
<pre><code class="language-java">@Service
@Scope(&quot;singleton&quot;)
public class IndexService implements ApplicationContextAware {
    @Autowired
    private IndexDao indexDao;
    private ApplicationContext applicationContext;
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
    public void service(){
        System.out.println(this);
       System.out.println(applicationContext.getBean(&quot;indexDaoImpl&quot;));
    }
}
</code></pre>
<p>2、测试结果</p>
<pre><code>com.ssm.service.IndexService@50378a4
com.ssm.dao.impl.IndexDaoImpl@60f00693
 - - - - - - - - - 
com.ssm.service.IndexService@50378a4
com.ssm.dao.impl.IndexDaoImpl@79207381
 - - - - - - - - - 
com.ssm.service.IndexService@50378a4
com.ssm.dao.impl.IndexDaoImpl@491b9b8
</code></pre>
<p>3、分析：单例 IndexService 内引用多例的 IndexDaoImpl，多次获取 IndexDaoImpl，打印的是不同值。</p>
<p>解决方案二：Lookup Method Injection</p>
<p>1、使用 @Lookup 注解</p>
<pre><code class="language-java">@Service
@Scope(&quot;singleton&quot;)
public abstract class IndexService {
    @Lookup
    public abstract IndexDao getIndexDao() ;
    public void service(){
        System.out.println(this);
        System.out.println(getIndexDao());
    }
}
</code></pre>
<p>2、测试结果</p>
<pre><code>com.ssm.service.IndexService$$EnhancerBySpringCGLIB$$8432b830@6b09fb41
com.ssm.dao.impl.IndexDaoImpl@6f43c82
 - - - - - - - - - 
com.ssm.service.IndexService$$EnhancerBySpringCGLIB$$8432b830@6b09fb41
com.ssm.dao.impl.IndexDaoImpl@5db6b9cd
 - - - - - - - - - 
com.ssm.service.IndexService$$EnhancerBySpringCGLIB$$8432b830@6b09fb41
com.ssm.dao.impl.IndexDaoImpl@210ab13f
</code></pre>
<p>3、分析：单例 IndexService 内引用多例的 IndexDaoImpl，多次获取 IndexDaoImpl，打印的是不同值。</p>
<p>官网引导我们参考<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-method-injection">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-method-injection</a></p>
<blockquote>
<p>In most application scenarios, most beans in the container are singletons. When a singleton bean needs to collaborate with another singleton bean or a non-singleton bean needs to collaborate with another non-singleton bean, you typically handle the dependency by defining one bean as a property of the other. A problem arises when the bean lifecycles are different. Suppose singleton bean A needs to use non-singleton (prototype) bean B, perhaps on each method invocation on A. The container creates the singleton bean A only once, and thus only gets one opportunity to set the properties. The container cannot provide bean A with a new instance of bean B every time one is needed.</p>
</blockquote>
<p>在大多数应用程序场景中，容器中的大多数 bean 都是单例的。当一个单例 bean 需要与另一个单例 bean 协作，或者 一个非单例 bean 需要与另一个非单例 bean 协作时，通常通过将一个bean 定义为另一个 bean 的属性来处理依赖性。当 bean 的生命周期不同时，就会出现问题。假设单例 bean A 需要使用非单例(原型) bean B，可能是在 A 的每个方法调用上。<strong>容器只创建一次单例bean A</strong>，因此只有一次机会来设置属性。容器不能每次需要 bean B 的新实例时都向 bean A 提供一个。</p>
<blockquote>
<p>A solution is to forego some inversion of control. You can make bean A aware of the container by implementing the ApplicationContextAware interface, and by making a getBean(&quot;B&quot;) call to the container ask for (a typically new) bean B instance every time bean A needs it. The following example shows this approach:</p>
</blockquote>
<p>解决的办法是放弃一些控制反转。您可以通过实现 applicationcontext - ware 接口，并在每次 bean A 需要时调用容器的 getBean(“B”) 来请求(通常是一个新的)bean B实例，从而使 bean A 知道容器。下面的例子展示了这种方法:</p>
<pre><code class="language-java">// a class that uses a stateful Command-style class to perform some processing
package fiona.apple;

// Spring-API imports
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class CommandManager implements ApplicationContextAware {

    private ApplicationContext applicationContext;

    public Object process(Map commandState) {
        // grab a new instance of the appropriate Command
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    protected Command createCommand() {
        // notice the Spring API dependency!
        return this.applicationContext.getBean(&quot;command&quot;, Command.class);
    }

    public void setApplicationContext(
            ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
}
</code></pre>
<h1 id="spring-生命周期的回调">Spring 生命周期的回调</h1>
<h2 id="spring-生命周期的回调的实现方法">Spring 生命周期的回调的实现方法：</h2>
<blockquote>
<p>Initialization Callbacks AND Destruction Callbacks<br>
The org.springframework.beans.factory.InitializingBean interface lets a bean perform initialization work after the container has set all necessary properties on the bean. The InitializingBean interface specifies a single method:</p>
</blockquote>
<p>org.springframework.beans.factory.InitializingBean 接口允许 bean 在容器设置了 bean 上所有必需的属性之后执行初始化工作。InitializingBean 接口指定了一个方法:</p>
<pre><code class="language-java">void afterPropertiesSet() throws Exception;
</code></pre>
<p>1、创建一个 Dao 接口</p>
<pre><code class="language-java">public interface IndexDao {
    void test();
}
</code></pre>
<p>2、接口实现类，实现 InitializingBean 接口，在调用构造方法后回调 afterPropertiesSet</p>
<pre><code class="language-java">@Repository
public class IndexDaoImpl implements IndexDao, InitializingBean {
    public IndexDaoImpl(){
        System.out.println(&quot;IndexDaoImpl...Constructor&quot;);
    }
    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println(&quot;IndexDaoImpl...init&quot;);
    }
}
</code></pre>
<p>3、测试</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
    }
}
</code></pre>
<p>4、测试结果</p>
<pre><code>IndexDaoImpl...Constructor
IndexDaoImpl...init
</code></pre>
<p>5、分析<br>
在调用构造方法初始化时回调 afterPropertiesSet 方法。</p>
<blockquote>
<p>Implementing the org.springframework.beans.factory.DisposableBean interface lets a bean get a callback when the container that contains it is destroyed. The DisposableBean interface specifies a single method:</p>
</blockquote>
<p>实现 org.springframework.beans.factory.DisposableBean 接口，当包含它的容器被销毁时，可处置bean 接口让 bean 获得一个回调。可处置 bean 接口指定了一个方法:</p>
<pre><code class="language-java">void destroy() throws Exception;
</code></pre>
<pre><code class="language-java">@Repository
public class IndexDaoImpl implements IndexDao, DisposableBean {
    @Override
    public void destroy() throws Exception {
        System.out.println(&quot;IndexDaoImpl...destory&quot;);
    }
}
</code></pre>
<h3 id="default-initialization-and-destroy-methods">Default Initialization and Destroy Methods</h3>
<blockquote>
<p>When you write initialization and destroy method callbacks that do not use the Spring-specific InitializingBean and DisposableBean callback interfaces, you typically write methods with names such as init(), initialize(), dispose(), and so on. Ideally, the names of such lifecycle callback methods are standardized across a project so that all developers use the same method names and ensure consistency.</p>
</blockquote>
<p>当您编写不使用特定于 spring 的 InitializingBean 和 DisposableBean 回调接口的初始化和销毁方法回调时，您通常会编写具有 init()、initialize()、dispose() 等名称的方法。理想情况下，这样的生命周期回调方法的名称在整个项目中是标准化的，这样所有开发人员都可以使用相同的方法名称并确保一致性。</p>
<blockquote>
<p>You can configure the Spring container to “look” for named initialization and destroy callback method names on every bean. This means that you, as an application developer, can write your application classes and use an initialization callback called init(), without having to configure an init-method=&quot;init&quot; attribute with each bean definition. The Spring IoC container calls that method when the bean is created (and in accordance with the standard lifecycle callback contract described previously). This feature also enforces a consistent naming convention for initialization and destroy method callbacks.</p>
</blockquote>
<p>您可以将 Spring 容器配置为在每个bean上“查找”名为 initialization 和 destroy 的回调方法名。这意味着，作为应用程序开发人员，您可以编写应用程序类并使用名为 init() 的初始化回调，而不必为每个bean 定义配置 init-method=&quot;init&quot; 属性。在创建bean时，Spring IoC 容器调用该方法(并根据前面描述的标准生命周期回调契约)。该特性还强制对初始化和销毁方法回调使用一致的命名约定。</p>
<blockquote>
<p>Suppose that your initialization callback methods are named init() and your destroy callback methods are named destroy(). Your class then resembles the class in the following example:</p>
</blockquote>
<p>假设您的初始化回调方法命名为init()，而销毁回调方法命名为destroy()。你的类类似于下面例子中的类:</p>
<pre><code class="language-java">public class DefaultBlogService implements BlogService {

    private BlogDao blogDao;

    public void setBlogDao(BlogDao blogDao) {
        this.blogDao = blogDao;
    }

    // this is (unsurprisingly) the initialization callback method
    public void init() {
        if (this.blogDao == null) {
            throw new IllegalStateException(&quot;The [blogDao] property must be set.&quot;);
        }
    }
}
</code></pre>
<p>然后你可以在一个类似如下的bean中使用这个类:</p>
<pre><code class="language-xml">&lt;beans default-init-method=&quot;init&quot;&gt;

    &lt;bean id=&quot;blogService&quot; class=&quot;com.something.DefaultBlogService&quot;&gt;
        &lt;property name=&quot;blogDao&quot; ref=&quot;blogDao&quot; /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="combining-lifecycle-mechanisms">Combining Lifecycle Mechanisms</h3>
<blockquote>
<p>As of Spring 2.5, you have three options for controlling bean lifecycle behavior:</p>
</blockquote>
<p>从spring2.5开始，你有三个控制bean生命周期行为的选项:</p>
<ul>
<li>The InitializingBean and DisposableBean callback interfaces</li>
<li>Custom init() and destroy() methods</li>
<li>The @PostConstruct and @PreDestroy annotations. You can combine these mechanisms to control a given bean.</li>
</ul>
<pre><code class="language-java">@PostConstruct
public void init(){
    System.out.println(&quot;IndexDaoImpl...init&quot;);
}
</code></pre>
<p>使用不同的初始化方法为同一个bean配置多个生命周期机制，调用方法如下:<br>
1、Methods annotated with @PostConstruct<br>
2、afterPropertiesSet() as defined by the InitializingBean callback interface<br>
3、A custom configured init() method</p>
<h1 id="其他">其他</h1>
<h2 id="using-filters-to-customize-scanning">Using Filters to Customize Scanning</h2>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-scanning-filters">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-scanning-filters</a></p>
<pre><code class="language-java">// 表明这是一个 xml 文件
@Configuration
// 注解扫描包
@ComponentScan(value = &quot;com.ssm&quot;,excludeFilters = {@ComponentScan.Filter(type = FilterType.REGEX, pattern = &quot;com.ssm.service.*&quot;)})
public class SpringConfig {
</code></pre>
<p>测试：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        IndexService indexService = (IndexService) context.getBean(&quot;indexService&quot;);
        indexService.service();

    }
}
</code></pre>
<p>Exception in thread &quot;main&quot; org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named 'indexService' available<br>
分析：自定义扫描过滤 com.ssm.service.* ，于是无法扫描到 IndexService，因此报错没有名为 indexService 的 bean。</p>
<h2 id="providing-qualifier-metadata-with-annotations">Providing Qualifier Metadata with Annotations</h2>
<p>1、当有两个 IndexDao 的实现类时，</p>
<pre><code class="language-java">@Repository
public class IndexDaoImpl implements IndexDao{
</code></pre>
<pre><code class="language-java">@Repository
public class IndexDaoImpl2 implements IndexDao {
</code></pre>
<p>2、Service 类使用 @Autowired 注入 IndexDao</p>
<pre><code class="language-java">@Service
public class IndexService {
    @Autowired
    IndexDao indexDao;
</code></pre>
<p>3、运行报错<br>
Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'com.ssm.dao.IndexDao' available: expected single matching bean but found 2: indexDaoImpl,indexDaoImpl2<br>
4、分析<br>
@Autowired 默认使用 byType 注入，结果发现了两个 IndexDao：IndexDaoImpl、IndexDaoImpl2，注入失败；于是采用 byName 注入（IndexDao indexDao;），在 Spring 容器中寻找 name = indexDao 的，没有找到（有名为 indexDaoImpl 和名为 indexDaoImpl2），注入失败。</p>
<h3 id="解决方案一primary">解决方案一：@Primary</h3>
<pre><code class="language-java">@Repository
@Primary
public class IndexDaoImpl implements IndexDao{
</code></pre>
<p>当向 IndexDaoImpl 类加入 @Primary 注解时，通过 byType 找到两个，于是注入 @Primary 注解修饰的类 IndexDaoImpl。</p>
<h3 id="解决方案二qualifier">解决方案二：@Qualifier</h3>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-scanning-qualifiers">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-scanning-qualifiers</a></p>
<pre><code class="language-java">@Service
public class IndexService {

    @Autowired
    @Qualifier(&quot;indexDaoImpl2&quot;)
    IndexDao indexDao;
</code></pre>
<h2 id="using-the-bean-annotation">Using the @Bean Annotation</h2>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-java-bean-annotation">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-java-bean-annotation</a></p>
<blockquote>
<p>@Bean is a method-level annotation and a direct analog of the XML <bean/> element. The annotation supports some of the attributes offered by <bean/>, such as: * init-method * destroy-method * autowiring * name.</p>
</blockquote>
<p>@Bean是方法级别的注释，是XML <bean/>元素的直接模拟。注释支持<bean/>提供的一些属性，比如:* init-method * destroy-method * autowiring * name。<br>
1、pom.xml</p>
<pre><code class="language-xml">&lt;dependencies&gt;
  &lt;!-- spring-ioc --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.0.9.RELEASE&lt;/version&gt;
  &lt;/dependency&gt;

  &lt;!-- mybatis --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
    &lt;version&gt;3.4.6&lt;/version&gt;
  &lt;/dependency&gt;

  &lt;!-- spring-mybatis --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;1.3.2&lt;/version&gt;
  &lt;/dependency&gt;

  &lt;!-- Spring 数据源 --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;
  &lt;/dependency&gt;

  &lt;!-- mysql --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;5.1.6&lt;/version&gt;
  &lt;/dependency&gt;

&lt;/dependencies&gt;
</code></pre>
<p>2、@Bean 注解的使用</p>
<pre><code class="language-java">// 表明这是一个 xml 文件
@Configuration
// 注解扫描包
@ComponentScan(&quot;com.ssm&quot;)
public class SpringConfig {

    @Bean
    public DataSource dataSource(){
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
        dataSource.setUsername(&quot;root&quot;);
        dataSource.setPassword(&quot;123456&quot;);
        dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);
        return dataSource;
    }

    @Bean
    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){
        SqlSessionFactoryBean sqlSessionFactoryBean =  new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource);
        return sqlSessionFactoryBean;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 并发——CAS 和 AQS]]></title>
        <id>https://epitomm.github.io/post/java-bing-fa-cas-he-aqs/</id>
        <link href="https://epitomm.github.io/post/java-bing-fa-cas-he-aqs/">
        </link>
        <updated>2020-04-29T15:37:33.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>多线程
<ul>
<li>Synchronized Volatile单例</li>
<li>锁：封锁。
<ul>
<li>悲观锁、写（增删改）多，读（查）少Lock</li>
<li>乐观锁：读（查）多、写少版本</li>
</ul>
</li>
<li>1.5 JUC</li>
</ul>
</li>
</ul>
<h1 id="一-cas">一、CAS</h1>
<h2 id="1-概念">1. 概念</h2>
<ul>
<li>CompareAndSet：比较和设置</li>
<li>CompareAndSwap：比较和交换。一种无锁的原子算法，乐观锁。</li>
<li>思想：
<ul>
<li>给你一个期望值，与现有的值比较，如果相等则修改；如果不相等什么事情都不做。</li>
<li>CAS(V,E,N)
<ul>
<li>V：目前拿到的值</li>
<li>E：期望值</li>
<li>N：新值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-作用及优点">2. 作用及优点</h2>
<ul>
<li>CAS 实现稍微复杂，无锁，不存在阻塞，提高了效率，CPU的吞吐量高，性能好。</li>
</ul>
<h2 id="3-实例">3. 实例</h2>
<pre><code class="language-java">package luban;

public class CASDemo1 {

    private static volatile int m = 0;

    public static void increase(){
        m ++;
    }
    public static void main(String[] args){
        for (int i = 0; i &lt; 20; i++) {
            new Thread(() -&gt; {
                CASDemo1.increase();
            }).start();
        }
        System.out.println(m);
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>16
</code></pre>
<p>分析：<br>
m++ 不具有原子性。</p>
<p>修改后：</p>
<pre><code class="language-java">package luban;

/**
 * volatile 变量
 * join()
 */
public class CASDemo3 {

    private static volatile int m = 0;
    public static void increase(){
        m ++;
    }
    public static void main(String[] args) throws InterruptedException {
        Thread[] threads = new Thread[20];
        for (int i = 0; i &lt; threads.length; i++) {
            threads[i] = new Thread(() -&gt; {
                CASDemo3.increase();
            });
            threads[i].start();
            threads[i].join();
        }
        System.out.println(m);
    }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/join.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">join()</p>
<p>反汇编：</p>
<pre><code>javap -c CASDemo3
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/i++.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">i++ 三步操作</p>
<pre><code class="language-java">package luban;

/**
 * AtomicInteger 变量
 * join()
 */

import java.util.concurrent.atomic.AtomicInteger;

public class CASDemo2 {

    private static AtomicInteger atomicI = new AtomicInteger(0);

    public static void increastAtomic(){
        atomicI.incrementAndGet();
    }
    public static void main(String[] args) throws InterruptedException {
        Thread[] threads = new Thread[20];
        for (int i = 0; i &lt; threads.length; i++) {
            threads[i] = new Thread(() -&gt; {
                CASDemo2.increastAtomic();
            });
            threads[i].start();
            threads[i].join();// join()：加入。当前 threads[i] 线程加入到线程组中，当前线程等待 threads[i]线程执行完了之后再执行
        }
        System.out.println(atomicI.get());
    }
}
</code></pre>
<p>反汇编：</p>
<pre><code>javap -c CASDemo2
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/atomicI.incrementAndGet.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">atomicI.incrementAndGet() 实现 i++ 只需一步操作</p>
<h2 id="4-方法摘要">4. 方法摘要</h2>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/atomic%E6%96%B9%E6%B3%95.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">java.util.concurrent.atomic</p>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/AtomicInteger%E6%96%B9%E6%B3%95.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">AtomicInteger 方法摘要</p>
<h2 id="5-原理">5. 原理</h2>
<p>JUC下的atomic类都是通过CAS来实现的，下面就以AtomicInteger为例来阐述CAS的实现。如下：</p>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/AtomicInteger%E7%B1%BB.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">AtomicInteger 类</p>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/getUnsafe.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">JVM 调用底层指令实现 getUnsafe()</p>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/incrementAndGet.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">incrementAndGet() 方法</p>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/getAndAddInt.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">getAndAddInt() 方法</p>
<pre><code class="language-java">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);
// var1：现在拿到的值
// var2：期望的值
// var4:最终改变的值
// var5：最后改变了的值  
</code></pre>
<p>总结：CAS的原子性流程<br>
<img src="https://epitomm.github.io/post-images/Unsafe.png" alt="图片" loading="lazy"></p>
<p style = "text-align:center;font-family:楷体">Unsafe 的返回值是 Atomic::cmpchg(x, addr, e)</p>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/Unsafe_2.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">Atomic::cmpchg(jint exchange_value, volatile jint* dest, jint com)</p>
<p>incrementAndGet -&gt; unsafe.java -&gt; unsafe.cpp -&gt; 汇编 cmpxchg</p>
<p>需要<strong>硬件支持</strong>汇编指令 cmpxchg</p>
<p>Unsafe是CAS的核心类，Java无法直接访问底层操作系统，而是通过本地（native）方法来访问。不过尽管如此，JVM还是开了一个后门：Unsafe，它提供了硬件级别的原子操作。</p>
<h2 id="6-缺点">6. 缺点</h2>
<ul>
<li>无法检测到中间值的变化：A(100) -&gt; B(110) -&gt; A(100)</li>
</ul>
<p>CAS需要检查操作值有没有发生改变，如果没有发生改变则更新。但是存在这样一种情况：如果一个值原来是A，变成了B，然后又变成了A，那么在CAS检查的时候会发现没有改变，但是实质上它已经发生了改变，这就是所谓的ABA问题。</p>
<pre><code class="language-java">package luban;
/**
 * 无法检测到中间值的变化
 */
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class CASDemo4 {

    private static AtomicInteger atomicI = new AtomicInteger(100);

    public static void main(String[] args){
        ExecutorService service = Executors.newCachedThreadPool();
        service.execute(() -&gt; {
            System.out.println(&quot;(1) 100 变为 110：&quot; + atomicI.compareAndSet(100,110));
        });

        service.execute(() -&gt; {
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;(2) 110 变为 100：&quot; + atomicI.compareAndSet(110,100));
        });

        service.execute(() -&gt; {
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;(3) 110 变为 100：&quot; + atomicI.compareAndSet(100,120));
        });

        service.shutdown();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>(1) 100 变为 110：true
(2) 110 变为 100：true
(3) 110 变为 100：true
</code></pre>
<h2 id="7-改进">7. 改进</h2>
<p>类 AtomicStampedReference<V></p>
<p>增加版本号声明：A1(100) -&gt; B2(110) -&gt; A3(100)</p>
<pre><code class="language-java">package luban;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicStampedReference;

public class CASDemo5 {

    // 设置初值时，给定版本号
    private static AtomicStampedReference asr = new AtomicStampedReference(100, 1);
    public static void main(String[] args){
        ExecutorService service = Executors.newCachedThreadPool();
        service.execute(() -&gt; {
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;100 变为 110：&quot; + asr.compareAndSet(100,110,asr.getStamp(), asr.getStamp() + 1));
            System.out.println(&quot;110 变成 100：&quot; +asr.compareAndSet(110,100,asr.getStamp(), asr.getStamp() + 1));
        });
        service.execute(() -&gt; {
            // 得到版本号
            int stamp = asr.getStamp();
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(asr.getStamp());
            System.out.println(stamp);
            System.out.println(&quot;100 变成 120：&quot; +asr.compareAndSet( 100,120,stamp, stamp  + 1));
//            System.out.println(&quot;100 变成 120：&quot; +asr.compareAndSet( 100,120,asr.getStamp(), asr.getStamp()  + 1));
        });
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>100 变为 110：true
110 变成 100：true
3
1
100 变成 120：false
</code></pre>
<p>分析：第一个线程 sleep 2 秒后执行 set，所以第二个线程先 getStamp() 到的stamp 是初始化的，还未修改过的 stamp = 1；而第二个线程 sleep 后的 asr 得到的 stamp = 3，现有值与期望值不同，所以修改失败。<br>
CAS 的应用场景：</p>
<ul>
<li>应用于简单的数据计算。</li>
<li>适合线程冲突少的场景。</li>
</ul>
<h1 id="二-aqs">二、AQS</h1>
<h2 id="1-概念-2">1. 概念</h2>
<ul>
<li>AbstractQueuedSynchronizer</li>
<li>同步发生器</li>
<li>构建 LOCK</li>
<li>JUC：java.util.current</li>
</ul>
<h2 id="2-基本思想">2. 基本思想</h2>
<ul>
<li>通过内置得到 FIFO 同步队列来完成线程争夺资源的管理工作。</li>
</ul>
<h2 id="3-clh同步队列">3. CLH同步队列</h2>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/CLH%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">CLH 同步队列</p>
<pre><code>static final class Node {
    /** Marker to indicate a node is waiting in shared mode */
    static final Node SHARED = new Node(); // 共享
    /** Marker to indicate a node is waiting in exclusive mode */
    static final Node EXCLUSIVE = null; // 排他

    /** waitStatus value to indicate thread has cancelled */
    static final int CANCELLED =  1; // 因中断、完成 退出队列
    /** waitStatus value to indicate successor's thread needs unparking */
    static final int SIGNAL    = -1; // 节点的后继结点被阻塞
    /** waitStatus value to indicate thread is waiting on condition */
    static final int CONDITION = -2; // 条件阻塞
    /**
     * waitStatus value to indicate the next acquireShared should
     * unconditionally propagate
     */
    static final int PROPAGATE = -3; // 共享模式下，头结点的状态
</code></pre>
<h1 id="三-自定义锁">三、自定义锁</h1>
<ul>
<li>AQS 写一个锁（Lock）
<ul>
<li>子类定义为非公共内部帮助器类（私有的内部类继承AQS），写锁的时候的一个帮助器，提供获取或和释放锁的功能。</li>
</ul>
</li>
<li>方法
<ul>
<li>acquire(int arg)：以<strong>独占</strong>模式获取，忽略中断。</li>
<li>acquireShared(int arg)：以<strong>共享</strong>模式获取，忽略中断。</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
</code></pre>
<ul>
<li>tryAcquire(int arg) ：尝试以独占模式获取对象状态。</li>
<li>tryAcquireShared(int arg)：尝试以共享模式获取对象状态 。</li>
</ul>
<pre><code class="language-java">private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    // Try the fast path of enq; backup to full enq on failure
    Node pred = tail;
    if (pred != null) {
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    enq(node);
    return node;
}
</code></pre>
<ul>
<li>release(int arg)：以独占模式释放对象。</li>
<li>releaseShared(int arg)：以共享模式释放对象。</li>
</ul>
<h2 id="实例">实例</h2>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/Lock%E7%B1%BB%E6%96%B9%E6%B3%95.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">Lock 类的方法</p>
<pre><code class="language-java">package luban;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.AbstractQueuedSynchronizer;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;

public class MyLock implements Lock {

    private Helper helper = new Helper();

    private class Helper extends AbstractQueuedSynchronizer{
        // 获取锁
        @Override
        protected boolean tryAcquire(int arg) {
            int state = getState();
            if(state == 0){
                // 利用 CAS 原理修改 state
                if(compareAndSetState(0, arg)){
                    // 设置当前线程占有资源
                    setExclusiveOwnerThread(Thread.currentThread());
                    return true;
                }
            }
            return false;
        }

        // 释放锁
        @Override
        protected boolean tryRelease(int arg) {// arg:信号量
            int state = getState() - arg;
            boolean flag = false;
            // 判断释放后是否为 0
            if(state == 0){
                setExclusiveOwnerThread(null);
                setState(state);
                return true;
            }
            setState(state);//不存在线程安全问题。重入性的问题，已经独占了资源state，其他线程不会干扰
            return false;
        }
        public Condition newConditionObject(){
            return new ConditionObject();
        }
    }
    @Override
    public void lock() {
        helper.acquire(1);
    }

    @Override
    public void lockInterruptibly() throws InterruptedException {
        helper.acquireInterruptibly(1);
    }

    @Override
    public boolean tryLock() {
        return helper.tryAcquire(1);
    }

    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return helper.tryAcquireNanos(1, unit.toNanos(time));
    }

    @Override
    public void unlock() {
        helper.release(1);
    }

    @Override
    public Condition newCondition() {
        return helper.newConditionObject();
    }
}
</code></pre>
<ol>
<li>不加锁的实现有问题</li>
</ol>
<pre><code class="language-java">package luban;
import java.util.concurrent.TimeUnit;

public class Demo {
    private int m = 0;
    private int next(){
        try {
            TimeUnit.SECONDS.sleep(1);
            return m++;
        } catch (InterruptedException e) {
            throw new RuntimeException(&quot;ERROR&quot;);
        }
    }

    public static void main(String[] args){
        Demo demo = new Demo();
        Thread[] th = new Thread[10];
        for(int i = 0 ; i &lt; 10 ; i ++){
            th[i] = new Thread(() -&gt; {
                System.out.println(demo.next());
            });
            th[i].start();
        }
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>1
7
8
6
5
0
4
3
2
0
</code></pre>
<ol start="2">
<li>使用自定义锁的实现正确</li>
</ol>
<pre><code class="language-java">package luban;

public class Demo01 {

    private MyLock lock = new MyLock();

    private int m = 0;

    public int next(){
        lock.lock();
        try {
            return m++;
        } finally{
            lock.unlock();
        }
    }

    public static void main(String[] args){
        Demo01 demo = new Demo01();
        Thread[] th = new Thread[10];
        for(int i = 0 ; i &lt; 10 ; i ++){
            th[i] = new Thread(() -&gt; {
                System.out.println(demo.next());
            });
            th[i].start();
        }
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>0
4
3
2
1
5
6
7
8
9
</code></pre>
<p>上面实现的 MyLock 不具有可重入性。测试：</p>
<pre><code class="language-java">package luban;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Demo02 {

    private MyLock lock = new MyLock();

    private int m = 0;

    public void a(){
        lock.lock();
        System.out.println(&quot;a&quot;);
        b();
        lock.unlock();
    }
    public void b(){
        lock.lock();
        System.out.println(&quot;b&quot;);
        lock.unlock();
    }

    public int next(){
        lock.lock();
        try {
            return m++;
        } finally{
            lock.unlock();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Demo02 demo = new Demo02();
        ExecutorService service = Executors.newCachedThreadPool();
        service.execute(() -&gt; {
            demo.a();
        });
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>a
（阻塞···）
</code></pre>
<h2 id="可重入性">可重入性</h2>
<p>同一个锁对同一资源进行占有的时候，直接分配给这个线程。</p>
<p>【占有锁的线程再次申请锁时仍可获取。获取一次，锁这个变量值(默认为 0) 加一。释放一次，锁这个变量值减一。锁这个变量值为 0 时，说明该锁没有被线程占用。】</p>
<p>对 MyLock 代码进行修改，使其具有可重入性：</p>
<pre><code class="language-java">package luban;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.AbstractQueuedSynchronizer;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;

public class MyLock implements Lock {

    private Helper helper = new Helper();

    private class Helper extends AbstractQueuedSynchronizer{
        // 获取锁
        @Override
        protected boolean tryAcquire(int arg) {
            int state = getState();
            if(state == 0){
                // 利用 CAS 原理修改 state
                if(compareAndSetState(0, arg)){
                    // 设置当前线程占有资源
                    setExclusiveOwnerThread(Thread.currentThread());
                    return true;
                }
            }else if(getExclusiveOwnerThread() == Thread.currentThread()){//可重入
                setState(getState() + arg);
                return true;
            }
            return false;
        }

        // 释放锁
        @Override
        protected boolean tryRelease(int arg) {// arg:信号量
            int state = getState() - arg;
            boolean flag = false;
            // 判断释放后是否为 0
            if(state == 0){
                setExclusiveOwnerThread(null);
                setState(state);
                return true;
            }
            setState(state);//不存在线程安全问题。重入性的问题，已经独占了资源state，其他线程不会干扰
            return false;
        }

        public Condition newConditionObject(){
            return new ConditionObject();
        }
    }
    @Override
    public void lock() {
        helper.acquire(1);
    }

    @Override
    public void lockInterruptibly() throws InterruptedException {
        helper.acquireInterruptibly(1);
    }

    @Override
    public boolean tryLock() {
        return helper.tryAcquire(1);
    }

    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return helper.tryAcquireNanos(1, unit.toNanos(time));
    }

    @Override
    public void unlock() {
        helper.release(1);
    }

    @Override
    public Condition newCondition() {
        return helper.newConditionObject();
    }
}
</code></pre>
<p>测试：</p>
<pre><code class="language-java">package luban;


import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Demo02 {

    private MyLock lock = new MyLock();

    private int m = 0;

    public void a(){
        lock.lock();
        System.out.println(&quot;a&quot;);
        b();
        lock.unlock();
    }
    public void b(){
        lock.lock();
        System.out.println(&quot;b&quot;);
        lock.unlock();
    }

    public int next(){
        lock.lock();
        try {
            return m++;
        } finally{
            lock.unlock();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Demo02 demo = new Demo02();
        ExecutorService service = Executors.newCachedThreadPool();
        service.execute(() -&gt; {
            demo.a();
        });
        service.shutdown();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>a
b
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 并发——并发锁和并发工具]]></title>
        <id>https://epitomm.github.io/post/java-bing-fa-bing-fa-suo-he-bing-fa-gong-ju/</id>
        <link href="https://epitomm.github.io/post/java-bing-fa-bing-fa-suo-he-bing-fa-gong-ju/">
        </link>
        <updated>2020-04-28T08:13:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-并发锁">一、并发锁</h1>
<h2 id="reentrantlock">ReentrantLock</h2>
<ul>
<li>一个<strong>可重入互斥Lock</strong>，具有与使用synchronized方法和语句访问的隐式监视锁相同的基本行为和语义，但具有<strong>扩展功能</strong>。</li>
</ul>
<pre><code class="language-java"> class X { 
   
   private final ReentrantLock lock = new ReentrantLock(); 
   // ... 
   
   public void m() { 
     lock.lock(); // block until condition holds 
     try { 
       // ... method body 
     } finally { 
       lock.unlock() 
     } 
  } 
  
} 
</code></pre>
<ul>
<li>构造方法：
<ul>
<li>ReentrantLock()：创建一个 ReentrantLock的实例。</li>
<li>ReentrantLock(boolean fair)：根据给定的<strong>公平</strong>政策创建一个 ReentrantLock的实例。</li>
</ul>
</li>
</ul>
<h2 id="reentrantreadwritelock">ReentrantReadWriteLock</h2>
<ul>
<li>ReadWriteLock</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/ReentrantReadWriteLock.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">ReadWriteLock 类的方法</center>
<ul>
<li>write.unlock()写锁释放之前要加读锁read.lock()：锁降级：从写锁降级到读锁</li>
</ul>
<h1 id="二-并发工具">二、并发工具</h1>
<p>航班查询：APP ---&gt;多个线程到不同的公司查询 ---&gt; 全部线程都查询完毕后，整理结果 result 返回给前台用户。</p>
<h2 id="1-countdownlatch">1. CountDownLatch</h2>
<h3 id="countdownlatch-用法">CountDownLatch 用法</h3>
<ul>
<li>CountDownLatch 类位于java.util.concurrent包下，利用它可以实现类似<strong>计数器</strong>的功能。</li>
<li>比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch 来实现这种功能了。</li>
<li>CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。</li>
</ul>
<h3 id="countdownlatch-如何工作">CountDownLatch 如何工作</h3>
<ul>
<li>构造方法
<ul>
<li>CountDownLatch(int count)：构造一个以给定计数初始化的CountDownLatch。</li>
<li>构造器的计数值（count）实际上就是闭锁需要等待的线程数量。这个值只能被设置一次，而且CountDownLatch 没有提供任何机制去重新设置这个计数值。</li>
<li>与CountDownLatch的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用CountDownLatch.await() 方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</li>
<li>其他N个线程必须引用闭锁对象，因为他们需要通知CountDownLatch对象，他们已经完成了各自的任务。这种通知机制是通过CountDownLatch.countDown() 方法来完成的；每调用一次这个方法，在构造函数中初始化的count值就减1。所以当N个线程都调用了这个方法，count的值等于0，然后主线程就能通过await() 方法，恢复执行自己的任务。</li>
</ul>
</li>
<li>await()
<ul>
<li>使当前线程在锁存器倒计时至零前一直等待，除非线程被中断。</li>
<li>当 count 减少到零时，唤醒当前线程</li>
</ul>
</li>
<li>countDown()
<ul>
<li>递减锁存器的计数，如果计数达到零，则释放所有等待。</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/CountDownLatch.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">CountDownLatch 航班查询流程图</center>
<h3 id="示例">示例</h3>
<pre><code class="language-java">package luban;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
public class FightQueryDemo {
    private static List&lt;String&gt; company = Arrays.asList(&quot;东方航空&quot;,&quot;南方航空&quot;,&quot;海南航空&quot;);
    // 结果列表
    private static List&lt;String&gt; fightList = new ArrayList&lt;&gt;();
    public static void main(String[] args) throws InterruptedException {
        // 出发地
        String origin = &quot;BJ&quot;;
        // 目的地
        String dest = &quot;SH&quot;;
        // 定义门闩
        CountDownLatch latch = new CountDownLatch(company.size());
        // 创建线程池
        ExecutorService service = Executors.newCachedThreadPool();
        // 创建线程
        for (int i = 0; i &lt; company.size(); i++) {
            String name = company.get(i);
            service.execute(() -&gt; {
                // 获取公司名称
                System.out.println(name + &quot;查询从&quot; + origin + &quot;到&quot; + dest + &quot;的机票&quot;);
                // 生成随机数表示此公司机票数量
                int val = new Random().nextInt(10);
                try {
                    TimeUnit.SECONDS.sleep(val);
                    fightList.add(name + &quot;:&quot; + val);
                    System.out.println(name + &quot;查询成功！&quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 这个公司查询完毕，门闩 - 1
                latch.countDown();
            });
        }
        service.shutdown();
        // 等待所有线程结束
        latch.await();
        System.out.println(&quot;==== 查询结果如下 ====&quot;);
        System.out.println(fightList);
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>东方航空查询从BJ到SH的机票
海南航空查询从BJ到SH的机票
南方航空查询从BJ到SH的机票
海南航空查询成功！
南方航空查询成功！
东方航空查询成功！
==== 查询结果如下 ====
[海南航空:6, 南方航空:7, 东方航空:7]
</code></pre>
<h2 id="2-cyclicbarries">2. CyclicBarries</h2>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/CyclicBarries.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">CyclieBarries 模拟运动员跑步比赛</center>
<h3 id="cyclicbarrier用法">CyclicBarrier用法</h3>
<ul>
<li>字面意思<strong>回环栅栏</strong>，通过它可以实现让一组线程等待至某个状态之后再<strong>全部同时执行</strong>。</li>
<li>叫做回环是因为<strong>当所有等待线程都被释放以后</strong>，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用awai() 方法之后，线程就处于barrier了。</li>
<li>赛跑：
<ul>
<li>需要所有的子任务都完成时，才执行主任务，这个时候就可以选择使用CyclicBarrier。</li>
</ul>
</li>
</ul>
<h3 id="基本原理">基本原理：</h3>
<ul>
<li>每个线程执行时，都会碰到一个屏障，直到所有线程执行结束，然后屏障便会打开，使所有线程继续往下执行。</li>
<li>在 CyclicBarrier 的内部定义了一个 Lock 对象，每当一个线调用 await 方法时，将拦截的线程数加减 1，然后判断计数器当前是否等于 0 ，如果不是，进入Lock对象的条件队列等待。如果是，执行 barrierAction 对象的 Runnable 方法，然后将锁的条件队列中的所有线程放入锁等待队列中，这些线程会依次的获取锁、释放锁。</li>
<li>CyclicBarrier的两个<strong>构造函数</strong>：
<ul>
<li>CyclicBarrier（int parties）：声明需要拦截的线程数</li>
<li>CyclicBarrier（int parties，Runnable barierAction）：声明需要拦截的线程数，定义一个等待所有线程到达屏障优先执行的Runnable对象。</li>
</ul>
</li>
</ul>
<pre><code class="language-java">package luban;
import java.util.Random;
import java.util.concurrent.*;
public class RaceDemo {
    public static void main(String[] args) {
        CyclicBarrier barrier = new CyclicBarrier(8);
        ExecutorService service = Executors.newCachedThreadPool();
        for(int i = 0 ; i &lt; 8 ; i++){
            service.execute(() -&gt; {
                try {
                    TimeUnit.SECONDS.sleep(new Random().nextInt(10));
                    System.out.println(Thread.currentThread().getName() + &quot;准备好了&quot;);
                    // 此线程已经准备好，唤醒其他线程
                    barrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
                System.out.println(&quot;选手&quot; + Thread.currentThread().getName() + &quot;起跑&quot;);
            });
        }
        service.shutdown();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>pool-1-thread-8准备好了
pool-1-thread-4准备好了
pool-1-thread-5准备好了
pool-1-thread-2准备好了
pool-1-thread-1准备好了
pool-1-thread-7准备好了
pool-1-thread-3准备好了
pool-1-thread-6准备好了
选手pool-1-thread-6起跑
选手pool-1-thread-8起跑
选手pool-1-thread-5起跑
选手pool-1-thread-4起跑
选手pool-1-thread-3起跑
选手pool-1-thread-7起跑
选手pool-1-thread-1起跑
选手pool-1-thread-2起跑
</code></pre>
<ul>
<li>一般情况下对于两个非常相似的类，我们一般都会想当然地去把他们进行类比。对于CountDownLatch 和CyclicBarrier 两个类，我们可以看到CountDownLatch 类都是一个类似于集结点的概念，很多个线程做完事情之后等待其他线程完成，全部线程完成之后再恢复运行。不同的是CountDownLatch 类需要你自己调用countDown() 方法减少一个计数，然后调用await() 方法即可。而CyclicBarrier 则直接调用await() 方法即可。</li>
<li>所以从上面来看，CountDownLatch更倾向于多个线程合作的情况，等你所有东西都准备好了，我这边就自动执行了。而CyclicBarrier则是我们都在一个地方等你，大家到齐了，大家再一起执行。</li>
</ul>
<h2 id="3-semaphore">3. Semaphore</h2>
<ul>
<li>资源有限共享</li>
<li>停车场为例：</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/Semaphore.png" alt="图片" loading="lazy"></figure>
<pre><code class="language-java">package com.ssm;

import java.util.Random;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

public class CarDemo {
    public static void main(String[] args) throws InterruptedException {
        // 创建 Semaphore
        Semaphore semaphore = new Semaphore(3);
        Thread [] cars = new Thread[10];
        for (int i = 0; i &lt; 10; i++) {
            cars[i] = new Thread(()-&gt;{
                try {
                    // 请求许可
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName() + &quot;可以进入停车场&quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                // 使用资源
                try {
                    int val = new Random().nextInt(5);
                    TimeUnit.SECONDS.sleep(val);
                    System.out.println(Thread.currentThread().getName()+&quot;停留了&quot;+val+&quot;秒&quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 离开（释放资源）
                semaphore.release();
                System.out.println(Thread.currentThread().getName() + &quot;离开了停车场&quot;);
            },&quot;car[&quot;+i+&quot;]&quot;);
            cars[i].start();
        }
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>car[0]可以进入停车场
car[2]可以进入停车场
car[7]可以进入停车场
car[0]停留了0秒
car[0]离开了停车场
car[4]可以进入停车场
car[7]停留了2秒
car[7]离开了停车场
car[8]可以进入停车场
car[2]停留了3秒
car[8]停留了1秒
car[3]可以进入停车场
car[2]离开了停车场
car[5]可以进入停车场
car[8]离开了停车场
car[4]停留了4秒
car[4]离开了停车场
car[1]可以进入停车场
car[3]停留了2秒
car[3]离开了停车场
car[9]可以进入停车场
car[9]停留了0秒
car[9]离开了停车场
car[6]可以进入停车场
car[6]停留了0秒
car[6]离开了停车场
car[1]停留了1秒
car[1]离开了停车场
car[5]停留了3秒
car[5]离开了停车场
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP系列（四）安全的HTTPS]]></title>
        <id>https://epitomm.github.io/post/http-xi-lie-si-an-quan-de-https/</id>
        <link href="https://epitomm.github.io/post/http-xi-lie-si-an-quan-de-https/">
        </link>
        <updated>2020-04-28T04:18:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-http-与-https">一、HTTP 与 HTTPS</h1>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/HTTPS_1.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/HTTPS_2.png" alt="图片" loading="lazy"></figure>
<p>HTTP 协议：超文本传输协议，应用层协议，HTTP 协议通过 请求-响应的方式，在客户端和服务端之间进行通信。HTTP 协议传输<strong>明文</strong>，不安全。</p>
<h2 id="明文信息传输">明文信息传输</h2>
<p>小风向向小萌发出一个请求 “小萌，我喜欢你！” 来表白。</p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E6%98%8E%E6%96%87%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93.png" alt="图片" loading="lazy"></figure>
<h3 id="中间人攻击">中间人攻击</h3>
<p>但是由于传输信息是明文，这个信息可能被某个中间人恶意拦截甚至篡改：<strong>中间人攻击</strong>。</p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E6%98%8E%E6%96%87%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93_%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB.png" alt="图片" loading="lazy"></figure>
<h2 id="加密信息传输">加密信息传输</h2>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93.png" alt="图片" loading="lazy"></figure>
<h3 id="加密算法">加密算法</h3>
<ul>
<li>对称加密：加密、解密使用同一个秘钥</li>
<li>非对称加密：加密、解密使用不同的秘钥，公钥加密私钥解密</li>
</ul>
<h3 id="对称加密传输">对称加密传输</h3>
<p>小风和小萌事先约定好一种加密方式，并且约定一个随机生成的秘钥，后续通信信息的发送方使用秘钥对信息进行加密，信息的接收方使用同一个秘钥对接收到的密文进行解密。</p>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>小风发送聊天请求，小萌回复给小风一个秘钥，小风后面发送的信息都先使用秘钥加密后再发送。后续发送信息都是不可读的密文了。</p>
</blockquote>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93_2.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>如果不知道秘钥，即使拦截到了信息，也没有办法解析和篡改。<br>
但是这样做并不是绝对安全的，虽然在后续的通信中对明文进行了加密，但是<strong>第一次约定加密方式、约定加密方式之后的秘钥的传输</strong>还是用明文。如果第一次通信就已经被拦截了，那么秘钥就会泄露给中间人， 中间人仍可以解密后续所有通信内容。</p>
</blockquote>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93_%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB.png" alt="图片" loading="lazy"></figure>
<h2 id="非对称加密传输">非对称加密传输</h2>
<p>非对称加密的一组秘钥中包含一个公钥和一个私钥，既可以公钥加密私钥解密，也可以私钥加密公钥解密。</p>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_1.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>在小风和小萌建立通信时，小萌首先把自己的公钥 KEY1 发送给小风。</p>
</blockquote>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_2.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>收到小萌的公钥后，小风自己生成一个用于对称加密的公钥 KEY2，这个秘钥是为了后续聊天加密来用的，就是上次被中间人发现的那个秘钥，为了安全不再明文约定发送，而是用刚才接收到的公钥 KEY1 对 KEY2 进行加密，得到 VA3=KEY1(KEY2)，把 VA3 发送给小萌。</p>
</blockquote>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_3.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>小萌可以用自己的非对称加密的私钥，解开公钥 KEY1 的加密，获得了 KEY2 的内容，从此以后用 KEY2 进行加密通信。</p>
</blockquote>
<p>在这个通信过程中，即使中间人一开始就截获了公钥 KEY1，由于不知道私钥是什么，也没有办法去解密。</p>
<h3 id="总结">总结</h3>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_%E6%80%BB%E7%BB%93.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>发送方和接收方都有一套自己的公钥和私钥，公钥是所有人都知道的，私钥只有自己知道。<br>
<strong>发送方使用接收方的公钥进行加密，接收方使用自己的私钥对接收的密文进行解密。</strong></p>
</blockquote>
<h3 id="中间人攻击-2">中间人攻击</h3>
<p>中间人不知道小萌的私钥是什么，但是它截获了小萌的公钥 KEY1 后，可以自己另外生成一对公钥和私钥，把自己的公钥 KEY3 发送给小风，</p>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB_1.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>小风以为 KEY3 就是小萌的公钥，用 KEY3 加密自己生成的对称加密的公钥 KEY2 得到 VA4=KEY3(KEY2)，发送给小萌，中间人用自己的私钥解开 KEY3 加密，获得了 KEY2，然后用小萌发来的 KEY1 重新加密，得到 VAL5，发给小萌。</p>
</blockquote>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB_2.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>两个人的后续通信尽管一直在用 KEY2 做对称加密，但是中间人已经掌握了 KEY2，就可以轻松地解密获取内容了。</p>
</blockquote>
<h2 id="证书机构">证书机构</h2>
<p><img src="https://epitomm.github.io/post-images/%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84_2.png" alt="图片" loading="lazy"></p>
<blockquote>
<p>小萌把自己的公钥 KEY1 发给证书颁发机构去申请证书，证书颁发机构自己有一对公钥和私钥，机构利用自己的私钥来加密 KEY1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过了机构的私钥加密，这样制作完成一个证书，机构把这个证书发给服务端小萌。</p>
</blockquote>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84_3.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>当后续小风向小萌请求通信时，小萌不再返回自己的公钥，而是直接把自己申请的证书返回给小风。</p>
</blockquote>
<figure data-type="image" tabindex="16"><img src="https://epitomm.github.io/post-images/%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84_4.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>小风收到证书后， 验证证书的真伪，各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥，所以，小风只需要知道是哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书的签名。接下来小风按照同样的签名规则，自己生成一个证书签名，如果两个签名一致，说明证书有效，验证成功后，小风就可以放心地再次利用机构的公钥解密出服务端小萌的公钥 KEY1，小风生成自己对应的对称加密的秘钥 KEY2，并且用服务端公钥 KEY1 加密 KEY2 生成 VA3，发送给小萌。</p>
</blockquote>
<figure data-type="image" tabindex="17"><img src="https://epitomm.github.io/post-images/%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84_5.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>小萌用自己的私钥解开加密得到对称加密的秘钥 KEY2，于是两个人可以开始用 KEY2 进行对称加密通信。</p>
</blockquote>
<h1 id="二-https-协议概述">二、HTTPS 协议概述</h1>
<ul>
<li>HTTPS可以认为是HTTP+TLS。</li>
<li>TLS是传输层加密协议，它的前身是SSL协议。</li>
</ul>
<blockquote>
<p>我们默认 TLS 和 SSL 指的是一个东西。</p>
</blockquote>
<figure data-type="image" tabindex="18"><img src="https://epitomm.github.io/post-images/SSL.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>TLS 建立在 传输层和应用层之间，TLS 实际上是 TCP 之上建立了一个加密通道，TLS 协议主要有五个部分：应用数据层协议、握手协议、报警协议、加密消息确认协议、心跳协议。<br>
目前常用的 HTTP 协议是 HTTP1.1，常用的 TLS 协议版本有：TLS1.2、TLS1.1、TLS1.0 和 SSL3.0 这样几个版本。其中 SSL3.0 由于某种攻击，认为 SSL3.0 协议是不安全的。TLS1.0 也存在部分安全漏洞，TLS1.1 和 TLS1.2 暂时没有已知的安全漏洞。</p>
</blockquote>
<h2 id="https-功能介绍">HTTPS 功能介绍</h2>
<blockquote>
<p>HTTP 本身是明文传输，没有经过任何安全处理，比如在百度搜索一个关键字：小米手机，中间人能够查看这个消息并且有可能打电话推销；在使用百度的过程中，搜索返回的结果页面有广告。这里的中间者主要指网络节点，用户数据在浏览器和百度服务器中间传输必须要经过的那些节点。比如 wifi 热点、路由器、防火墙、反向代理、缓存服务器等，在 HTTP 协议下，中间人可随意窃听用户的搜索内容，窃取客户隐私甚至篡改网页，HTTPS 协议就是这些攻击的克星。</p>
</blockquote>
<ul>
<li>内容加密</li>
</ul>
<blockquote>
<p>浏览器到服务器的内容是以加密的形式传输的，中间者无法查看。</p>
<ul>
<li>非对称秘钥交换</li>
<li>对称内容加密<br>
对称加密的第一步：协商加密算法和秘钥，中间人依然可以在第一次通信时，截获加密方式和秘钥，这样有对称内容加密就安全了一些。<br>
非对称加密用公钥和私钥的方式把正常通信的秘钥 KEY2 协商好，但是在协商过程中，有一步骤是服务器把自己的公钥 KEY1 用明文传给客户端，</li>
</ul>
</blockquote>
<ul>
<li>身份认证</li>
</ul>
<blockquote>
<p>证书的存在保证用户访问的是你想访问的服务，在使用慕课看视频，HTTPS 证书保证了此时访问的一定是慕课网，即使被 DNS 劫持到了第三方站点，也会提醒用户没有访问慕课服务，有可能被劫持。</p>
</blockquote>
<ul>
<li>数据完整性</li>
</ul>
<blockquote>
<p>防止内容被第三方冒充或篡改。</p>
</blockquote>
<h2 id="https-原理介绍">HTTPS 原理介绍</h2>
<ul>
<li>内容加密</li>
</ul>
<p>非对称密钥交换</p>
<blockquote>
<p>非对称加密：公钥和私钥的方式把正常通信的 KEY2 协商好，协商的过程中，服务器把自己的公钥 KEY1 用明文传递给客户端，这里面涉及很多高级算法：对称加密的两种模式：流式加密、分组加密。在秘钥交换的过程中，中间人可以截获 KEY1，换成自己的公钥 KEY3，这样一来中间人依然可以获取正常通信时的秘钥，于是引入了数字证书。</p>
</blockquote>
<p>对称内容加密</p>
<blockquote>
<p>对称加密：协商加密算法和秘钥，中间人可以在第一次通信时拦截加密方式和秘钥。</p>
</blockquote>
<ul>
<li>身份认证</li>
</ul>
<p>数字证书</p>
<blockquote>
<p>服务端向权威机构申请证书。<br>
客户端和服务端通信时，服务端先把证书传递给客户端，客户端收到证书后，用证书机构的公钥解密证书签名，然后用签名生成的规则再生成一个签名，对比一致就是真整数，不一致就是假证书。<br>
如果确认是真证书，解密服务器公钥 KEY1，再生成通信用的秘钥 KEY2，用服务器端的公钥 KEY1 加密，发给服务端。</p>
</blockquote>
<h1 id="三-https-使用成本">三、HTTPS 使用成本</h1>
<ul>
<li>证书费用以及更新维护</li>
<li>HTTPS 降低用户访问速度</li>
<li>消耗CPU资源，需要增加大量机器</li>
</ul>
<h1 id="四-https-对性能的影响">四、HTTPS 对性能的影响</h1>
<ul>
<li>协议交互所增加的网络RTT</li>
</ul>
<blockquote>
<p>RTT：往返时延。从发送端发送数据开始，到发送端收到来自接收端的确认总共经过的时延。</p>
</blockquote>
<ul>
<li>加解密相关的计算耗时</li>
</ul>
<h2 id="网络耗时">网络耗时</h2>
<figure data-type="image" tabindex="19"><img src="https://epitomm.github.io/post-images/HTTP%E7%BD%91%E7%BB%9C%E8%80%97%E6%97%B6.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>HTTP 协议访问网站，交互延迟如上图，用户只需要完成 TCP 三次握手，建立 TCP 连接就能直接发送 HTTP 请求获取应用层数据了。除此之外在访问网络的过程中，也没有需要消耗计算资源的地方。</p>
</blockquote>
<figure data-type="image" tabindex="20"><img src="https://epitomm.github.io/post-images/HTTPS%E7%BD%91%E7%BB%9C%E8%80%97%E6%97%B6.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>HTTPS 访问流程如上图。<br>
① TCP 三次握手建立连接，一个 RTT<br>
② HTTP GET 请求服务端返回 302跳转到 HTTPS，一个 RTT 和 302 跳转时延。因为用户不会手动输入 https 访问网站，比如说百度，用户一般输入 baidu.com，而不会直接输入：https://www.baidu.com，所以服务端只能返回 302 强制浏览器跳转到 HTTPS。<br>
③ 而浏览器处理 302 跳转本身也需要耗时，这个耗时暂且不算，302 跳转到 https 服务器之后，由于端口和服务器不一样，所以需要重新完成三次握手，建立 TCP 连接。耗时一个 RTT。<br>
④ TLS 完全握手阶段1，耗时一个 RTT，这个阶段主要完成加密套件的协商和证书的身份确认。这个阶段下，服务端和浏览器会协商出来相同的秘钥交换算法、对称加密算法、内容一致性校验算法、证书签名算法等。<br>
浏览器获取到证书后，校验证书的有效性，比如证书是否过期，是否撤销等，浏览器首先获取证书里的 CA 域名，如果 CA 域名没有命中缓存的话，浏览器需要解析 CA 域名的 DNS，这个 DNS 解析至少耗费一个 RTT。DNS 解析到 ip 后，三次握手，建立 CA 站点的 TCP 连接，耗时一个 RTT，接着浏览器发送 Ocsp 请求获取响应，耗时一个 RTT,<br>
Ocsp：在线证书状态协议，维护服务器和其他网络资源安全性的两种普遍模式之一。另外一个叫做 CRL 证书注销列表。当用户试图访问一个服务器时，在线证书状态协议发送一个对于证书状态信息的请求，服务器会回复一个有效、过期或者未知的响应。协议规定了服务器和客户端应用程序的通信语法，在线证书状态协议给用户到期的证书一个宽限期，这样他们就可以在更新以前的一段时间继续访问到这个服务器。这里就需要发起对于证书状态信息的请求，也需要消耗一个 RTT。<br>
⑤ TLS 完全握手阶段2：秘钥协商，耗时一个 RTT 和计算时间，这个完全握手结束后，浏览器和服务器之间进行应用层也就是 HTTP 的数据传输。这和 HTTP 的方式几乎是相同的。<br>
一共耗时 7 个 RTT。<br>
如果不是第一次请求，比如 CA 域名解析，如果有缓存的话，就无需进行 DNS 解析，就可以减少一个 RTT。</p>
</blockquote>
<h2 id="计算耗时">计算耗时</h2>
<ul>
<li>浏览器计算耗时</li>
</ul>
<blockquote>
<p>浏览器解析证书签名，秘钥交换，应用层数据加密、解密，一致性的交换</p>
</blockquote>
<ul>
<li>服务端计算耗时</li>
</ul>
<blockquote>
<p>秘钥交换，应用层数据加密、解密耗时。<br>
由于客户端 CPU 和操作系统种类比较多，所以计算耗时不能一概而论。</p>
</blockquote>
<h1 id="五-https-常见问题">五、HTTPS 常见问题</h1>
<ul>
<li>https加密是不是需要我在电脑上安装证书/保存密码？</li>
</ul>
<blockquote>
<p>不需要，操作系统、浏览器把这些操作都做好了</p>
</blockquote>
<ul>
<li>https 不就是在http后面加个s，很难么？</li>
</ul>
<blockquote>
<p>HTTPS 包含证书、流量转发、负载均衡......<br>
小型网站不难，大型网站很难</p>
</blockquote>
<ul>
<li>https 解决了所有劫持问题吗？</li>
</ul>
<blockquote>
<p>https 是为了解决中间人攻击，假设在 https 页面中加载了 http 资源，http 资源还是有劫持的风险，客户端、局域网的风险也很大，恶意插件、木马、路由器、DNS 也都非常脆弱。HTTPS 能够在绝大部分下保证互联网访问数据传输的安全性。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP 系列（三）熟悉 HTTP 协议结构和通讯原理]]></title>
        <id>https://epitomm.github.io/post/http-xi-lie-san-shou-xi-http-xie-yi-jie-gou-he-tong-xun-yuan-li/</id>
        <link href="https://epitomm.github.io/post/http-xi-lie-san-shou-xi-http-xie-yi-jie-gou-he-tong-xun-yuan-li/">
        </link>
        <updated>2020-04-27T04:12:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="http-协议之身份认证">HTTP 协议之身份认证</h1>
<h2 id="身份认证信息">身份认证信息</h2>
<ul>
<li>密码</li>
</ul>
<blockquote>
<p>只有本人才知道的字符串信息</p>
</blockquote>
<ul>
<li>动态令牌</li>
</ul>
<blockquote>
<p>仅限本人持有的设备内显示的一次性密码</p>
</blockquote>
<ul>
<li>数字证书</li>
</ul>
<blockquote>
<p>只有本人终端持有的信息</p>
</blockquote>
<ul>
<li>生物认证</li>
</ul>
<blockquote>
<p>指纹、虹膜</p>
</blockquote>
<ul>
<li>IC 卡等</li>
</ul>
<blockquote>
<p>仅限本人持有的</p>
</blockquote>
<blockquote>
<p>身份认证信息时用来核对只有登陆者本人才知道、拥有的信息内容，但是即便对方是假冒用户，只要能够通过用户认证，HTTP 服务器就会默认这是出自于本人的行为。因此掌控机密性的密码不能让其他人得到，更不能轻易被破解。</p>
</blockquote>
<h2 id="常见认证方式">常见认证方式</h2>
<ul>
<li>BASIC 认证（基本认证）</li>
<li>DIGEST 认证（摘要认证）</li>
<li>SSL 客户端认证</li>
<li>FormBase 认证（基于表单认证）</li>
</ul>
<h2 id="basic-认证">BASIC 认证</h2>
<h3 id="什么是-basic-认证">什么是 BASIC 认证</h3>
<ul>
<li>从 HTTP1.0 就定义的一种认证方式，现在仍有一部分网站在使用。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/BASIC%E8%AE%A4%E8%AF%81.png" alt="图片" loading="lazy"></figure>
<ul>
<li>WEB 服务器与通信客户端之间进行的统一认证方式。</li>
</ul>
<h3 id="basic-认证过程">BASIC 认证过程</h3>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/BASIC%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<ul>
<li>客户端发送需要 BASIC 认证的请求资源</li>
<li>当请求的资源需要 BASIC 认证时，服务器会随状态码 401 返回一个 Authorization Required，告诉客户端需要身份认证</li>
<li>接收到状态码 401 的客户端为了通过 BASIC 认证，需要将用户名、密码发送给服务器，发送的字符和内容形式为是用户名和密码，中间用 “：” 拼接，将其经过 Base64 的编码后写入到首部字段 Authorization，并在前面加上“Basic ”，表明要执行的是 Basic 认证，发送给服务器。</li>
<li>服务器端接收到包含首部字段 Authorization 的请求后，会去认证信息的正确性，如果验证通过，返回包含 Request URI 的资源响应，返回的是 200；如果认证失败，继续返回 401，表示认证未通过。</li>
</ul>
<blockquote>
<p>BASIC 认证虽然采用 Base64 的编码方式，但是这不是加密处理，不需要任何附加信息就可以对 Base64 进行解码，由于明文解码后就是用户名和密码，在 HTTP 这样非加密通信的线路上，进行 BASIC 认证的过程中，如果不小心被别人窃听了，被盗的可能性就会非常大。<br>
BASIC 认证在使用上不够便捷灵活，而且不安全，所以并不常用。</p>
</blockquote>
<h2 id="digest-认证">DIGEST 认证</h2>
<h3 id="什么是digest认证">什么是DIGEST认证？</h3>
<ul>
<li>为弥补BASIC认证存在的弱点，从HTTP/1.1起就有了DIGEST认证。</li>
<li>DIGEST 认证同样使用质询/响应的方式，但不会像BASIC认证那样直接发送明文密码。</li>
</ul>
<blockquote>
<p>质询-响应方式：一方先发送认证要求给另一方，使用从另一方接收到的质询码，计算生成响应码，最后将响应码返回给对方进行认证。<br>
因为发送给对方的只是响应摘要，以及由质询码产生的计算结果，所以比 BASIC 认证多了一层保护，密码泄露的可能性也就降低了。</p>
</blockquote>
<h3 id="digest-认证过程">DIGEST 认证过程</h3>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/DIGEST%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<ul>
<li>客户端发送需要 DIGEST 认证的请求</li>
<li>服务端返回状态码 401，同时里面包含一个头部字段，包含质询-响应认证方式所需要的临时质询码，质询码是一个随机数 nonce，一次返回都是 401 响应生成的任意随机的 Base64 编码的字符串，多数情况下，由一串数字、或一串字符或一串其他的组成</li>
<li>接收到 401 状态码的客户端返回的响应中包含 DIGEST 认证必须要的头部字段 Authorization，包含这些信息：Digest username=&quot;xxx&quot;, realm=&quot;DIGEST&quot;, nonce=&quot;xxxxx&quot;, url=&quot;&quot;, response=&quot;&quot; ，其中 realm 和 nonce 就是从服务器端接收和响应的字段。username 是 realm 限定范围内可进行认证的内容，response 存放经过 MD5 算法运算生成的密码字符串。</li>
<li>服务器接收到包含首部字段的 Authorization，服务器端接收到这个请求会确认认证信息的正确性</li>
</ul>
<blockquote>
<p>DIGEST 认证提供了高于 BASIC 认证的安全等级，但是和 HTTPS 客户端认证相比还是很弱。DIGEST 认证提供了 <strong>“防止密码被窃听</strong>” 的保护机制，但是并不存在 “<strong>防止用户伪装</strong>” 的保护机制。DIGEST 认证和 BASIC 认证一样，使用上不那么便捷灵活，安全性不够，适用范围有限。<br>
使用用户名、密码的认证方式，只要二者的内容正确就可以认为是本人的行为，但是如果用户名和密码被盗，就很有可能<strong>被第三方冒充</strong>。所以利用 SSL 客户端认证，就可以避免这种情况的发生。</p>
</blockquote>
<h2 id="ssl客户端认证">SSL客户端认证</h2>
<ul>
<li>SSL 客户端认证是借由HTTPS的客户端<strong>证书</strong>完成认证的方式。凭借客户端证书认证，服务器可确认访问是否来自已登录的客户端。</li>
</ul>
<blockquote>
<p>银行网银：先输入用户名、密码，输入正确后下载它们的证书，下载好之后，以后每次登录会把证书也通过 HTTP 报文的方式发给服务器，开始通信。<br>
细节过程：①当服务器接收到需要认证资源的请求，服务器给客户端发送一个报文要求客户端提供客户端证书，②用户选择将发送的客户端证书后，客户端会把客户端证书信息以报文方式发送给服务器，③服务器验证客户端证书，验证通过后，就可以领取证书内客户端的公开秘钥，然后开始 HTTPS 的加密通信。</p>
</blockquote>
<h2 id="基于表单的认证">基于表单的认证</h2>
<ul>
<li>基于表单的认证方法并不是在HTTP协议中定义的。</li>
<li>使用由Web应用程序各自实现基于表单的认证方式。</li>
<li>通过Cookie和Session的方式来保持用户的状态。</li>
</ul>
<h1 id="http-的长连接与短连接">HTTP 的长连接与短连接</h1>
<blockquote>
<p>资源消耗的优化：长连接。<br>
连接好比从 A 地到 B 地的交通方式，想从 A 地到 B 地，打车过去，这样是一个短连接，就连通了一下，没办法让更多的人上车；后来发现从 A 去 B 的人很多，于是开通了一条地铁线，建立了一条长连接，很多人都可以复用这个连接。<br>
能一次性节约很多资源的、服务很多次的是长连接。</p>
</blockquote>
<ul>
<li>HTTP协议是基于请求/响应模式的，因此只要服务端给了响应，本次HTTP请求就结束了。</li>
<li>HTTP的长连接和短连接本质上是<strong>TCP长连接和短连接</strong>。</li>
</ul>
<blockquote>
<p>HTTP 协议是应用层协议，传输层使用的是 TCP 协议，网络层使用的是IP 协议，IP 协议主要解决网络路由、寻址的问题， TCP 协议解决的是如何在 IP 层之上可靠的传递数据包，使得在接收端能收到发送方发送的所有包，并且顺序与发出顺序一致。<br>
HTTP 分成长连接和短连接，本质上就是 TCP 连接。TCP 连接是一个双向通道，可以保持一段时间不关闭，因此 TCP 连接才有真正的长连接和短连接。</p>
</blockquote>
<ul>
<li>HTTP/1.0中，默认使用的是<strong>短连接</strong>。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，结束就中断。</li>
</ul>
<blockquote>
<p>如果客户端浏览器访问某个 html，该 html 内包含其他 js、css、img 资源，当浏览器每遇到一个 web 资源，就会建立一个 HTTP 会话。</p>
</blockquote>
<ul>
<li>HTTP/1.1起，默认使用<strong>长连接</strong>，用以保持连接特性。</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/HTTP%E9%95%BF%E8%BF%9E%E6%8E%A5.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>使用长连接的情况时，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接，这个 keep-alive 不会永久保持连接，有一个保持时间，在不同的服务器软件可以设置。</p>
</blockquote>
<ul>
<li>短连接：</li>
</ul>
<p>建立连接一数据传输一关闭连接..建立连接一数据传输一关闭连接</p>
<blockquote>
<p>客户端向服务器发送连接请求，Server 接到请求，双方建立连接，客户端向 Server 发送消息，Server 回应 Client，一次读写就完成了，这时候双方任何一个都可以发起 close 关闭的操作，一般都是 Client 先发起 close。短连接一般只会在 Client-Server 间传递一次读写操作。</p>
</blockquote>
<ul>
<li>长连接：</li>
</ul>
<p>建立连接—数据传输…（保持连接）.…数据传输——关闭连接</p>
<blockquote>
<p>Client 向 Server 发起连接请求，Server 接受 Client 的请求，双方建立连接，Client 与 Server 完成一次读写之后，它们之间的连接不会主动关闭，后续的读写操作会继续使用这个连接。<br>
短连接对于服务器来说，它的管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段，但如果客户请求频繁，将在 TCP 建立和关闭的操作上浪费时间也浪费带宽，响应的反应速度就会变慢，客户体验感不好。<br>
长连接可以省去较多的 TCP 连接和关闭的时间，减少浪费、节约时间，对于频繁请求资源的客户来说，比较适合使用长连接。在长连接的应用场景下， Client 端一般不会主动关闭连接，与短连接不同，Client 与 Server 之间的连接如果一直不关闭的话，就会存在问题：随着客户端连接越来越多，Server 承受不住，这时 Server 端需要采取一些策略，比如说，关闭一些长时间没有读写事件发生的连接，可以避免一些恶意连接导致 Server 端服务受损。</p>
</blockquote>
<h1 id="http-中介之代理">HTTP 中介之代理</h1>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/HTTP%E4%B8%AD%E4%BB%8B%E4%B9%8B%E4%BB%A3%E7%90%86.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>一般情况下是客户端直接与服务器连接，但是出于不方便或是其他的特殊原因，可能会通过一个中间人与服务器连接。这个中间人就叫做 <strong>web 代理</strong>，这个中间人<strong>既是客户端、又是服务端</strong>，对于服务器来说，由于请求是从代理访问过来的，所以在这个过程中，代理起到了客户端的作用；而对于真正的客户端来说，请求是发给代理的，所以代理起到了服务器的作用。</p>
</blockquote>
<h2 id="代理的作用">代理的作用</h2>
<ul>
<li>抓包</li>
</ul>
<blockquote>
<p>为了能够更好的分析 HTTP 请求，或者达到安全措施的目的，只有使用代理才可以更好的对客户端的数据包进行拦截，在这里代理的名字有另外一种叫法：拦截服务器</p>
</blockquote>
<ul>
<li>FQ</li>
</ul>
<blockquote>
<p>如果想通过计算机访问 facebook，由于长城防火墙屏蔽了 facebook、YouTube 这些网站，不可直接访问，就要通过代理翻墙。</p>
</blockquote>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/FQ.png" alt="图片" loading="lazy"></figure>
<ul>
<li>匿名访问</li>
</ul>
<blockquote>
<p>HTTP 协议本身具有匿名性，HTTP 代理服务器通过删除 HTTP 报文中的身份特性，比如客户端的 IP 地址、Cookie、会话 ID 等，从而对远端的服务器隐藏原始用户的 IP 地址以及其他细节，同时 HTTP 代理服务器上也不会记录原始用户访问记录，就使得代理上网的客户可以在更加安全隐秘的环境中访问网络。</p>
</blockquote>
<ul>
<li>过滤器</li>
</ul>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E8%BF%87%E6%BB%A4%E5%99%A8.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>HTTP 协议并不知道在访问网络的是谁，即便是个小朋友登上父母的账号进行访问，认证起来我们也认为他就是他的父母。通过代理服务器进行分析和部分请求的拦截，进一步加强对网络的控制。</p>
</blockquote>
<h1 id="http-中介之网关">HTTP 中介之网关</h1>
<ul>
<li>网关可以作为某种翻译器使用，它抽象出了一种能够到达资源的方法。网关是资源和应用程序之间的粘合剂。</li>
<li>网关扮演的是“协议转换器”的角色。</li>
</ul>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/HTTP%E4%B8%AD%E4%BB%8B%E4%B9%8B%E7%BD%91%E5%85%B3.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>代理连接的是两个或多个使用相同协议的应用程序。<br>
网关连接的是两个或多个使用不同协议的端点，网关扮演的是 “<strong>协议转换器</strong>” 的角色，网关可以向数据库发送查询数据、发邮件、生成动态内容。</p>
</blockquote>
<h2 id="web-网关">WEB 网关</h2>
<ul>
<li>Web网关在一侧使用HTTP协议，在另一侧使用另一种协议。</li>
</ul>
<p>&lt;客户端协议&gt;/&lt;服务器端协议&gt;</p>
<p>①（HTTP/）服务器端网关：通过HTTP协议与客户端对话，通过其他协议与服务器通信。</p>
<blockquote>
<p>发邮件就是服务器端网关，客户端是 HTTP 协议，邮件服务器是 SMTP 协议</p>
</blockquote>
<p>②（/HTTP）客户端网关：通过其他协议与客户端对话，通过HTTP协议与服务器通信。</p>
<h2 id="常见的网关类型">常见的网关类型</h2>
<ul>
<li>（HTTP/*）服务器端Web网关</li>
</ul>
<blockquote>
<p>客户端发送 HTTP 请求，服务器端 web网关会把这个请求转换为其他协议与服务器进行连接，完成获取资源后，会将对象放在一条 HTTP 响应中，发送给客户端：发邮件。</p>
</blockquote>
<ul>
<li>（HTTP/HTTPS）服务器端安全网关</li>
</ul>
<blockquote>
<p>客户端发送 HTTP 请求，网关自动进行加密，加密来自客户端的请求，然后再发送给服务器，为了安全问题。</p>
</blockquote>
<ul>
<li>（HTTPS/HTTP）客户端安全加速器网关</li>
</ul>
<blockquote>
<p>客户端发送的请求是经过加密的安全的 HTTPS ，通过网关进行解密后再向 web 服务器发送普通的 HTTP 请求。</p>
</blockquote>
<ul>
<li>资源网关</li>
</ul>
<blockquote>
<p>客户端通过 HTTP 连接到应用程序的服务器，服务器并不回送文件，而是将请求通过网关 API 发送给运行在服务器上的应用程序，应用程序将请求资源回送给客户端。</p>
</blockquote>
<h1 id="http-缓存">HTTP 缓存</h1>
<h2 id="为什么要使用http缓存">为什么要使用HTTP缓存？</h2>
<p>请求一次服务器，请求头大小 1KB，响应头大小 1KB，请求的文件大小 10KB，一次请求的流量就是 12KB，10 次就是 120KB，n 次请求就是 12*n KB。</p>
<ul>
<li><strong>客户端</strong>每次都要请求服务器，浪费<strong>流量</strong>。</li>
<li><strong>服务器</strong>每次都提供查找、下载，请求用户基数如果太大，服务器就会存在很大<strong>压力</strong>。</li>
<li><strong>客户端</strong>每次请求完都要进行页面渲染，<strong>用户体验差</strong>。</li>
</ul>
<p>是否可以将请求的文件存放起来使用：HTTP 缓存。</p>
<h2 id="缓存的内容又是什么">缓存的内容又是什么？</h2>
<p>主要针对样式：CSS、JS、图片这一系列更新频率不大的<strong>静态文件</strong>进行缓存。</p>
<blockquote>
<p>缓存是通过什么实现的？请求头-响应头</p>
</blockquote>
<h2 id="http缓存头部字段">HTTP缓存头部字段</h2>
<ul>
<li>Cache-Control请求/响应头，缓存控制字段</li>
</ul>
<blockquote>
<p>控制 HTTP 缓存的最高指令，要不要缓存也是 Cache-Control 说了算。</p>
</blockquote>
<p>no-store：所有内容都不缓存。</p>
<p>no-cache：缓存，但是浏览器使用缓存前，都会请求服务器判断缓存资源是否是最新。</p>
<p>max-age=X（单位秒）请求缓存后的X秒不再发起请求。</p>
<p>s-maxage=X（单位秒）代理服务器请求源站缓存后的X秒不再发起请求，只对CDN缓存有效。</p>
<p>public：客户端和代理服务器（CDN）都可缓存。</p>
<p>private：只有客户端可以缓存。</p>
<ul>
<li>Expires</li>
</ul>
<p>响应头，代表资源过期时间，由服务器返回提供，是http1.0的属性，在与max-age共存的情况下，优先级要低。</p>
<ul>
<li>Last-Modified</li>
</ul>
<p>响应头，资源最新修改时间，由服务器告诉浏览器。</p>
<ul>
<li>if-Modified-Since</li>
</ul>
<p>请求头，资源最新修改时间，由浏览器告诉服务器，和Last-Modified是一对，它两会进行对比。</p>
<ul>
<li>Etag</li>
</ul>
<p>响应头，资源标识，由服务器告诉浏览器。</p>
<ul>
<li>if-None-Match</li>
</ul>
<p>请求头，缓存资源标识，由浏览器告诉服务器（其实就是上次服务器给的Etag），和Etag是一对，它两会进行对比。</p>
<h2 id="http缓存工作方式">HTTP缓存工作方式</h2>
<h3 id="expires">Expires</h3>
<ul>
<li>场景一：让服务器与浏览器约定一个文件过期时间一Expires</li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/Expires.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>① 第一次请求时，浏览器向服务器请求一个 f.js 文件<br>
② 服务器说文件给你，我们约定一个时间，通过响应头返回一个 Expires 过期约定时间，同时返回了 f.js<br>
③ 后续请求浏览器先对比当前时间是否已经大于 Expires，判断缓存的文件是否超过了约定的过期时间，时间没过的话，不发起请求，直接使用本地缓存；时间过期了，就发起请求，再返回到步骤 ①。<br>
假设 Expires 已经过期，浏览器请求服务器，但是 f.js 并未改变，如何避免这时发起请求呢？</p>
</blockquote>
<h3 id="last-modified-与-if-modified-since">Last-Modified 与 if-Modified-Since</h3>
<ul>
<li>场景二：让服务器与浏览器在约定文件过期时间的基础上，再加一个文件最新修改时间的对比——Last-Modified 与 if-Modified-Since</li>
</ul>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/Last-Modified.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>① 浏览器向服务器请求 f.js，并要一个过期时间<br>
② 服务器返回给浏览器 f.js 和 一个过期时间，再给一个文件最新修改时间 Last-Modified，通过设置响应头返回给浏览器，文件过期后，双方核对文件修改时间<br>
后续浏览器可能有如下三种情况：</p>
<ol>
<li>Expires 还未过期，浏览器使用本地缓存</li>
<li>Expires 过期，浏览器请求服务器时带上文件最新修改时间，在请求头里面加上 if-Modified-Since，也就是上次请求服务器返回的 Last-Modified，把这个值又带回去。服务器把这个 if-Modified-Since（请求头里的文件最近修改时间） 和 服务器上的文件最新修改时间 Last-Modified 作对比，如果两个值不相等，服务器查找最新的 f.js + Expires + Last-Modified 返回给浏览器；如果相等，服务器返回状态码 304：文件未修改过，你还是用你的本地缓存吧。</li>
</ol>
</blockquote>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/Last-Modified_2.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>浏览器端可以随意修改 Expires，很极端的情况下，Last-Modified 只能精确到秒，假设文件在 1秒 内发生变化，Last-Modified 无法感知这个文件的变化，这样情况下，浏览器永远无法拿到最新文件。</p>
</blockquote>
<h3 id="etag与lf-none-match">Etag与lf-None-Match</h3>
<ul>
<li>场景三：让服务器与浏览器在过期时间Expires+Last-Modified的基础上，增加一个文件内容唯一对比标记——Etag与lf-None-Match。Expires不稳定，再加入一个max-age来加以代替。</li>
</ul>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/Etag.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>① 浏览器请求 f.js<br>
② 服务器将 f.js + max-age(过期时间) + Last-Modified + Etag（文件内容的唯一标识）<br>
③ 浏览器 60s 内不发起请求，直接使用本地缓存，<br>
max-age=60代表成功缓存后的 60s 内不再向服务器发起请求，与 Expires 相似，但 max-age 优先级比 Expires 高，max-age 存在时 Expires 就没用了。</p>
<blockquote>
<p>④ 60s 后，浏览器带上 If-Modified-Since 和 If-None-Match 向服务器发起请求，服务器对比 If-None-Match 与服务器端的 Etag，这时候尽管给出了 If-Modified-Since，但是不会再对比 If-Modified-Since 和 Last-Modified 了，因为 Etag 优先级比 Last-Modified 高，Etag 就是为了解决 1s 内文件发生改变的问题。如果 If-None-Match 与 Etag 不相等，说明 f.js 这个内容被修改过，服务器返回给浏览器最新的 f.js + 全新的 Etag + max-age +Last-Modified（没什么用了，优先级 &lt; Etag） + Expires（没什么用了，优先级&lt;max-age）；如果 Etag 与 If-None-Match 相等，返回 304 告诉浏览器继续使用之前的本地缓存。</p>
</blockquote>
</blockquote>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/Etag_2.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>max-age 或 Expires 不过期的时候，浏览器没有办法主动感知服务器的文件变化。<br>
如果服务端改变了文件，怎样让客户端知道呢？</p>
</blockquote>
<h2 id="缓存改进方案">缓存改进方案</h2>
<h3 id="md5hash缓存">md5/hash缓存</h3>
<p>通过不缓存html，为静态文件添加MD5或者hash标识，解决浏览器无法跳过缓存过期时间主动感知文件变化的问题。</p>
<blockquote>
<p>HTTP 缓存方案：服务器与浏览器的文件修改时间对比，文件内容标识对比，前提的基础都是建立在两者文件路径完全相同的基础上，请求的都是 f.js，这才能够解读这样的缓存，但是如果第一次要获取的名字是 f-hash1.js，下一次文件修改了就变成了 f-hash2.js，这是两个完全不同的文件。<br>
浏览器第一次加载页面，请求并缓存了 f-hash1,js，第二次加载同样一个地方文件指向 f-hash2.js，浏览器不会询问缓存了，因为本地没有这个缓存，浏览器会直接重新请求 f-hash2.js，因为这就是两个不同的文件。<br>
通过这种方式就可以解决过期时间没到，浏览器无法主动请求服务器的问题，只需要在在项目每次发布迭代的时候，将修改过的静态文件添加不同的 MD5 或者 hash 标识即可。</p>
</blockquote>
<h3 id="cdn缓存">CDN缓存</h3>
<p>CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</p>
<blockquote>
<p>假设多年前，我们所在的城市只有一个火车站，每次春运整个城市的人都得去这个火车站买票， 人流量及购票需求激增，为了缓解这个问题，城市的不同区都出现了火车票的代售点，这样每个区的人都可以就近买票，火车站总站的压力大大减轻。<br>
可以把每个区的售票点称之为 CDN 节点，也就是前面所说的 代理服务器，简而言之，可以把 CDN 理解成浏览器与服务器之间的临时站点，它会替服务器处理部分浏览器请求，从而减轻总服务器上的压力。静态资源也是一样的，可以分成多个临时站点来存储。<br>
把 CDN 的价值归纳为：<br>
①通过分流大大减轻了原站（服务器端）的压力。<br>
②解决了跨地区访问问题（就近站点访问）。</p>
</blockquote>
<h3 id="cdn-缓存工作方式">CDN 缓存工作方式</h3>
<ul>
<li>第一次请求</li>
</ul>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/CDN%E7%BC%93%E5%AD%98%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AF%B7%E6%B1%82.png" alt="图片" loading="lazy"></figure>
<ul>
<li>后续请求</li>
</ul>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/CDN%E7%BC%93%E5%AD%98%E5%90%8E%E7%BB%AD%E8%AF%B7%E6%B1%82.png" alt="图片" loading="lazy"></figure>
<p>可能出现以下几种情况：</p>
<p>① CDN 节点自己缓存的文件还没过期，于是返回 304 给浏览器，打回了这次请求</p>
<p>② CND 节点发现自己缓存的文件过期了，为了保险起见，自己发送请求给服务器，成功拿回最新数据，然后交还给浏览器。</p>
<p>CND 缓存的问题和 HTTP 缓存的问题一样，CDN 缓存时间不过期，浏览器始终被拦截，无法拿到最新的文件。回归 HTTP 缓存本身，缓存本身针对于更新频率不高的静态文件，CDN 缓存提供了分流、访问加速等。</p>
<p>CDN 与 HTTP 缓存不一样的是：CDN 类似于一个平台，可以通过登录手动更新 CDN 缓存，变相解决了浏览器缓存无法手动控制的问题。</p>
<h2 id="浏览器操作对http缓存的影响">浏览器操作对HTTP缓存的影响</h2>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>用户操作</strong></th>
<th style="text-align:left"><strong>Expires/Cache-Control</strong></th>
<th style="text-align:left"><strong>Last-Modihed/Etag</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">地址栏回车</td>
<td style="text-align:left">有效</td>
<td style="text-align:left">有效</td>
</tr>
<tr>
<td style="text-align:left">页面链接跳转</td>
<td style="text-align:left">有效</td>
<td style="text-align:left">有效</td>
</tr>
<tr>
<td style="text-align:left">新开窗口</td>
<td style="text-align:left">有效</td>
<td style="text-align:left">有效</td>
</tr>
<tr>
<td style="text-align:left">前进、后退</td>
<td style="text-align:left">有效</td>
<td style="text-align:left">有效</td>
</tr>
<tr>
<td style="text-align:left">F5刷新</td>
<td style="text-align:left">无效</td>
<td style="text-align:left">有效</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+F5刷新</td>
<td style="text-align:left">无效</td>
<td style="text-align:left">无效</td>
</tr>
</tbody>
</table>
<h1 id="内容协商机制">内容协商机制</h1>
<blockquote>
<p>访问谷歌，同一个 URL，在国内打开谷歌是中文，在国外打开是英文的。</p>
</blockquote>
<ul>
<li>指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言，字符集，编码方式等作为判断的基准。</li>
</ul>
<h2 id="内容协商方式">内容协商方式</h2>
<ul>
<li>客户端驱动</li>
</ul>
<p>客户端发起请求，服务器发送可选项列表，客户端作出选择后在发送第二次请求。</p>
<ul>
<li>服务器驱动</li>
</ul>
<p>服务器检查客户端的请求头部集并决定提供哪个版本的页面。</p>
<ul>
<li>透明协商</li>
</ul>
<p>某个中间设备（通常是缓存代理）代表客户端进行协商。</p>
<h2 id="服务器驱动内容协商-请求首部集">服务器驱动内容协商-请求首部集</h2>
<ul>
<li>Accept：告知服务器发送何种媒体类型</li>
<li>Accept-Language：告知服务器发送何种语言</li>
<li>Accept-Charset：告知服务器发送何种字符集</li>
<li>Accept-Encoding：告知服务器采用何种编码</li>
</ul>
<h2 id="服务器驱动内容协商-请求首部集-2">服务器驱动内容协商-请求首部集</h2>
<ul>
<li>Content-Type</li>
<li>Content-Language</li>
<li>Content-Type</li>
<li>Content-Encoding</li>
</ul>
<h2 id="服务器驱动内容协商-近似匹配">服务器驱动内容协商-近似匹配</h2>
<blockquote>
<p>客户端的 Accept-Language 指的是西班牙语，服务器端只有英语和法语，这个客户端希望在没有西班牙语的时候优先返回英语。这就意味着需要一种 HTTP 机制更详细的描述偏好：近似匹配方式。</p>
</blockquote>
<p>Accept-Language:en; q=0.5, fr; q=0.0, nl; q=1.0, tr; q=0.0</p>
<blockquote>
<p>上述首部表示用户最愿意接受 nl：荷兰语(nl; q=1.0)；其次，如果没有荷兰语的话，英文也行：en;q=0.5；不接受法语：fr;q=0.0 ，不接受土耳其语：tr;q=0.0</p>
</blockquote>
<p>q 值的范围是 0-1，不代表所有权重和为 1，不是权重的概念，只是优先级的概念。</p>
<blockquote>
<p>如果服务端既没有 nl 也没有 en，服务器端猜测，服务器端设置默认值。</p>
</blockquote>
<h2 id="断点续传和多线程下载">断点续传和多线程下载</h2>
<ul>
<li>断点续传？多线程下载？</li>
</ul>
<blockquote>
<p>下载文件时，下载到一半，突然网络不太好，下载中断了；<br>
或者主动暂停下载；<br>
用迅雷下载一个大文件，会分成好多块分开下载。<br>
上述叫断点续传。</p>
<ul>
<li>HTTP是通过在Header里两个参数实现的，客户端发请求时对应的是Range，服务器端响应时对应的是Content-Range。<br>
不论是断点续传还是迅雷的多线程分块下载，如果续传成功，返回 206，如果文件有变动，返回 200 和新文件的内容。</li>
</ul>
</blockquote>
<p>Range</p>
<ul>
<li>用于请求头中，指定第一个字节的位置和最后一个字节的位置，一般格式：</li>
<li>Range:（unit=first byte pos）-[last byte pos] 左开右闭区间
<ul>
<li>Range:bytes=0-499</li>
<li>Range:bytes=500-999</li>
<li>Range:bytes=-500  后 500 个字节的内容</li>
<li>imooc Range:bytes=500-   从第 500 字节开始，到文件结束部分</li>
<li>Range:bytes=500-600,601-999</li>
</ul>
</li>
</ul>
<p>Content-Range</p>
<ul>
<li>用于响应头中，在发出带 Range的请求后，服务器会在Content-Range 头部返回当前接受的范围和文件总大小。一般格式：
<ul>
<li>Content-Range:bytes（unit first byte pos）-[last byte pos]/[entity legth]</li>
</ul>
</li>
<li>而在响应完成后，返回的响应头内容也不同：
<ul>
<li>HTTP/1.1200 Ok（不使用断点续传方式）</li>
<li>HTTP/1.1 206 Partial Content（使用断点续传方式）</li>
</ul>
</li>
</ul>
<h2 id="断点续传过程">断点续传过程</h2>
<p>1.客户端下载一个1024K的文件，已经下载了其中512K。</p>
<p>2.网络中断，客户端请求续传，因此需要在HTTP头中申明本次需要续传的片段：Range:bytes=512000-</p>
<p>这个头通知服务端从文件的512K位置开始传输文件。</p>
<p>3.服务端收到断点续传请求，从文件的512K位置开始传输，并且在HTTP头中增加：</p>
<p>Content-Range:bytes 512000-/1024000并且此时服务端返回的HTTP状态码应该是206，而不是200。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM 垃圾回收]]></title>
        <id>https://epitomm.github.io/post/jvm-la-ji-hui-shou/</id>
        <link href="https://epitomm.github.io/post/jvm-la-ji-hui-shou/">
        </link>
        <updated>2020-04-24T14:54:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-如何判断对象可以回收">一、如何判断对象可以回收</h1>
<h2 id="11-引用计数法">1.1 引用计数法</h2>
<p>如果一个对象被其他变量引用，计数器 +1，如果某个变量不再引用，计数器 -1。如果一个对象的<strong>引用次数为 0</strong>，就可以被回收。</p>
<h3 id="循环引用问题">循环引用问题</h3>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png" alt="图片" loading="lazy"></figure>
<p>A 对象引用 B 对象，B 对象的引用计数 = 1；B 对象引用了 A 对象，A 对象的引用计数 = 1，但是没有其他对象在引用它们两个，它们本应被回收，却因彼此循环引用，计数器不为 0 ，不能被回收，造成内存泄露。</p>
<h2 id="12-可达性分析算法">1.2 可达性分析算法</h2>
<ul>
<li>Java 虚拟机中的垃圾回收器采用<strong>可达性分析</strong>来探索所有存活的对象</li>
<li>扫描<strong>堆</strong>中的对象，看是否能够沿着 <strong>GC Root对象为起点的引用链找到该对象</strong>，找不到，表示可以回收</li>
</ul>
<h3 id="哪些对象可以作为-gc-root">哪些对象可以作为 GC Root ?</h3>
<ul>
<li>虚拟机栈中局部变量引用的对象</li>
<li>本地方法栈中 JNI 中引用的对象</li>
<li>方法去区静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
</ul>
<h2 id="13-四种引用">1.3 四种引用</h2>
<h3 id="131-强引用">1.3.1. 强引用</h3>
<blockquote>
<p>一个对象通过等号赋值运算符赋值给变量，如：List<String> list = new ArrayList&lt;&gt;();<br>
变量 list 强引用了对象 ArrayList。只要沿着 GC Root 能够找到这个对象，这个对象就不会被垃圾回收。</p>
</blockquote>
<ul>
<li>只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E5%BC%BA%E5%BC%95%E7%94%A8.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E5%BC%BA%E5%BC%95%E7%94%A82.png" alt="图片" loading="lazy"></figure>
<pre><code>package cn.itcast.jvm.t2;

import java.io.IOException;
import java.lang.ref.SoftReference;
import java.util.ArrayList;
import java.util.List;

/**
 * 演示强引用
 * -Xmx20m -XX:+PrintGCDetails -verbose:gc
 */
public class Demo2_3 {
    private static final int _4MB = 4 * 1024 * 1024;
    public static void main(String[] args) throws IOException {
      List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
      for (int i = 0; i &lt; 5; i++) {
          list.add(new byte[_4MB]);// 读取图片放到 list 集合中进行显示，但是图片资源并不属于核心业务资源，如果图片过多，用强引用就会导致溢出。不太重要的资源能不能在内存紧张时把它占用的内存释放掉，以后如果再用到的话再读取一遍呢？采用软引用。
      } 
      System.in.read();
    }
}
</code></pre>
<p>通过 <code>-Xmx20m -XX:+PrintGCDetails -verbose:gc</code> 设置堆空间大小为 20M 并且打印 GC 信息，创建 list 变量强引用 ArrayLsit 对象，向 ArrayList 内放入 20M 对象，由于程序一直未被终止，所以 list 不能被回收，导致 堆内存溢出异常 <code>OutOfMemoryError: Java heap space</code>。</p>
<p>运行结果：</p>
<pre><code>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space
	at cn.itcast.jvm.t2.Demo2_3.main(Demo2_3.java:21)
</code></pre>
<h3 id="132-软引用softreference">1.3.2. 软引用（SoftReference）</h3>
<ul>
<li>仅有软引用引用该对象时，在<strong>垃圾回收后，内存仍不足</strong>时会再次触发垃圾回收，回收软引用对象</li>
<li>可以配合<strong>引用队列</strong>来释放软引用自身</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E8%BD%AF%E5%BC%95%E7%94%A8.png" alt="图片" loading="lazy"></figure>
<pre><code>package cn.itcast.jvm.t2;

import java.io.IOException;
import java.lang.ref.SoftReference;
import java.util.ArrayList;
import java.util.List;

/**
 * 演示软引用
 * -Xmx20m -XX:+PrintGCDetails -verbose:gc
 */
public class Demo2_3 {

    private static final int _4MB = 4 * 1024 * 1024;

    public static void main(String[] args) throws IOException {
        soft();
    }

    public static void soft() {
        // list --&gt; SoftReference --&gt; byte[]
        // list 和 SoftReference 之间是强引用，SoftReference 和 byte[] 之间是软引用
        List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 5; i++) {
            SoftReference&lt;byte[]&gt; ref = new SoftReference&lt;&gt;(new byte[_4MB]);
            System.out.println(ref.get());
            list.add(ref);
            System.out.println(list.size());

        }
        System.out.println(&quot;循环结束：&quot; + list.size());
        for (SoftReference&lt;byte[]&gt; ref : list) {
            System.out.println(ref.get());
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/%E8%BD%AF%E5%BC%95%E7%94%A8GC.png" alt="图片" loading="lazy"></figure>
<p><strong>清理无用的软引用：引用队列</strong></p>
<p>软引用对象被释放后，没必要再保存在 list 中了，希望把<strong>软引用本身做一个清理</strong>，从 list 集合中清理掉。</p>
<pre><code>package cn.itcast.jvm.t2;

import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.SoftReference;
import java.util.ArrayList;
import java.util.List;

/**
 * 演示软引用, 配合引用队列
 */
public class Demo2_4 {
    private static final int _4MB = 4 * 1024 * 1024;

    public static void main(String[] args) {
        List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();

        // 引用队列
        ReferenceQueue&lt;byte[]&gt; queue = new ReferenceQueue&lt;&gt;();
        for (int i = 0; i &lt; 5; i++) {
            // 关联了引用队列， 当软引用所关联的 byte[]被回收时，软引用自己会加入到 queue 中去
            SoftReference&lt;byte[]&gt; ref = new SoftReference&lt;&gt;(new byte[_4MB], queue);
            System.out.println(ref.get());
            list.add(ref);
            System.out.println(list.size());
        }

        // 从队列中获取无用的 软引用对象，并移除
        Reference&lt;? extends byte[]&gt; poll = queue.poll();
        while( poll != null) {
            list.remove(poll);
            poll = queue.poll();
        }

        System.out.println(&quot;===========================&quot;);
        for (SoftReference&lt;byte[]&gt; reference : list) {
            System.out.println(reference.get());
        }

    }
}
</code></pre>
<p>运行结果：值为空的软引用都被从 list 集合中清除了</p>
<pre><code>[B@6d6f6e28
1
[B@135fbaa4
2
[B@45ee12a7
3
[B@330bedb4
4
[B@2503dbd3
5
===========================
[B@2503dbd3
</code></pre>
<h3 id="133-弱引用weakreference">1.3.3. 弱引用（WeakReference）</h3>
<ul>
<li>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</li>
<li>可以配合引用队列来释放弱引用自身</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E5%BC%B1%E5%BC%95%E7%94%A8.png" alt="图片" loading="lazy"></figure>
<p>引用队列：</p>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E5%BC%B1%E5%BC%95%E7%94%A8%E5%BC%95%E7%94%A8%E9%98%9F%E5%88%97.png" alt="图片" loading="lazy"></figure>
<p>当软引用的对象被回收后，软引用自身也是一个对象，如果在创建时给他分配了一个引用队列，那在它<strong>引用的对象被回收</strong>时，软引用就会进入这个<strong>引用队列</strong>。当弱引用的对象被垃圾回收后，弱引用如果被分配了引用队列的话， 弱引用也会进入引用队列。因为软引用、弱引用自身也要占用一定内存，如果要对它俩占用的内存进一步释放，需要使用引用队列来找到它们。</p>
<pre><code>package cn.itcast.jvm.t2;

import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.List;

/**
 * 演示弱引用
 * -Xmx20m -XX:+PrintGCDetails -verbose:gc
 */
public class Demo2_5 {
    private static final int _4MB = 4 * 1024 * 1024;

    public static void main(String[] args) {
        //  list --&gt; WeakReference --&gt; byte[]
        List&lt;WeakReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 10; i++) {
            WeakReference&lt;byte[]&gt; ref = new WeakReference&lt;&gt;(new byte[_4MB]);
            list.add(ref);
            for (WeakReference&lt;byte[]&gt; w : list) {
                System.out.print(w.get()+&quot; &quot;);
            }
            System.out.println();

        }
        System.out.println(&quot;循环结束：&quot; + list.size());
    }
}
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/%E5%BC%B1%E5%BC%95%E7%94%A8GC.png" alt="图片" loading="lazy"></figure>
<p>在<strong>垃圾回收时，会把弱引用所占用的内存释放掉</strong>，弱引用自身占用的内存要释放的话，要结合引用队列来实现。</p>
<h3 id="134-虚引用phantomreference">1.3.4. 虚引用（PhantomReference）</h3>
<p>虚引用和终结器引用必须配合引用队列使用。<strong>当创建虚引用和终结器引用时，都会关联一个引用队列。</strong></p>
<ul>
<li>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队， 由 Reference Handler 线程调用虚引用相关方法<strong>释放直接内存</strong></li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/%E8%99%9A%E5%BC%95%E7%94%A8.png" alt="图片" loading="lazy"></figure>
<p>创建 ByteBuffer 的实现对象时，会创建一个名为 Cleaner 的<strong>虚引用对象</strong>，ByteBuffer 会分配一块直接内存，并且会把直接内存的地址传递给虚引用对象。将来 ByteBuffer 没有被强引用引用时，ByteBuffer 就会被垃圾回收，但是给他分配的<strong>直接内存并不能被 Java 垃圾回收</strong>管理。</p>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/%E8%99%9A%E5%BC%95%E7%94%A82.png" alt="图片" loading="lazy"></figure>
<p>所以在 ByteBuffer 被回收时，让虚引用对象进入引用队列，虚引用所在的引用队列会由 ReferenceHandler 线程定时到这个引用队列中找看有没有新入队的 Cleaner，如果有，就会调用 Cleaner 中的 clean() 方法，根据前面记录的直接内存的地址调用 Unsafe.freeMemory()，<strong>释放直接内存</strong>。</p>
<h3 id="135-终结器引用finalreference">1.3.5. 终结器引用（FinalReference）</h3>
<ul>
<li>无需手动编码，但其内部<strong>配合引用队列使用</strong>，在<strong>垃圾回收</strong>时，<strong>终结器引用入队</strong>（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并<strong>调用它的 finalize 方法</strong>，<strong>第二次 GC 时才能回收被引用对象</strong></li>
</ul>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/%E7%BB%88%E7%BB%93%E5%99%A8%E5%BC%95%E7%94%A8.png" alt="图片" loading="lazy"></figure>
<p>所有的 Java 对象都会继承在 Object 父类，Object 类中有一个 finalize() 终结方法。某个对象<strong>重写了 finalize() 方法</strong>，当没有强引用引用它时，就由虚拟机创建它对应的终结器引用，当这个对象要被垃圾回收时，就会把这个<strong>终结器引用加入引用队列</strong>，再由一个<strong>优先级很低的线程 <strong>（finalize() 迟迟未能被调用，导致对象很久不能被真正回收，所以不推荐使用 finalize() 释放资源）finalizeHandler 线程查看引用队列中是否有终结器引用，如果有，就会根据终结器引用找到那个</strong>要被垃圾回收的对象</strong>，并且<strong>调用它的 finalize()方法</strong>，调用完了，<strong>下一次垃圾回收时就可以把这个对象占用的内存真正回收了</strong>。</p>
<h1 id="二-垃圾回收算法">二、垃圾回收算法</h1>
<h2 id="21-标记清除">2.1 标记清除</h2>
<p>定义： Mark Sweep</p>
<ul>
<li>速度快</li>
<li>会造成内存碎片</li>
</ul>
<h3 id="标记清除流程">标记清除流程</h3>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png" alt="图片" loading="lazy"></figure>
<p><strong>标记</strong>：沿着 GC Root 的引用链去找，扫描整个堆对象的过程中，如果发现某个堆对象确实被引用了，那么这个堆对象是非垃圾对象，如果某个对<strong>象没有任何一个 GC Root 直接或间接引用</strong>它，那么把它<strong>标记为垃圾对象</strong>。</p>
<p><strong>清除</strong>：将被标记为垃圾对象所占用的空间释放掉。这里说的释放不是把这个对象所占用的内存的每个字节清零，只需要把垃<strong>圾对象占用内存的起始、结束地址记录下来，放在一个空闲地址列表</strong>，下次分配新对象时，到空闲地址列表中找是否有一块足够的空间能容纳新对象。</p>
<h3 id="优点">优点</h3>
<p><strong>速度快</strong>，只需把垃圾对象的起始、结束地址记录下来。</p>
<h3 id="缺点">缺点</h3>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E5%86%85%E7%A2%8E%E7%89%87.png" alt="图片" loading="lazy"></figure>
<p>易产生<strong>内存碎片</strong>。清除垃圾对象后不会对内存空间进行整理，如果分配了一个较大的对象，比如数组，数组需要一段连续的内存。每个小的空闲空间都不足以容纳下这个较大的新对象，虽然总的空闲空间足够，但由于<strong>不连续</strong>，造成新对象不能被保存。</p>
<h2 id="22-标记整理">2.2 标记整理</h2>
<p>定义：Mark Compact</p>
<ul>
<li>速度慢</li>
<li>没有内存碎片</li>
</ul>
<h3 id="标记整理流程">标记整理流程</h3>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png" alt="图片" loading="lazy"></figure>
<p><strong>标记</strong>：没有任何 GC Root 直接或间接指向的堆对象被标记为垃圾对象。</p>
<p><strong>整理</strong>：避免标记清除时的内存碎片问题，在清理垃圾的过程中，会把可用的对象向前移动，让内存更为<strong>紧凑</strong>，连续的内存空间就更大了。</p>
<h3 id="优点-2">优点</h3>
<p><strong>没有内碎片</strong>。</p>
<h3 id="缺点-2">缺点</h3>
<p>由于整理牵扯到对象的移动，<strong>效率降低</strong>。</p>
<p>对象在整理过程中发生移动，如果有其他局部变量引用了这个被移动的对象，就需要改变这些引用的地址。</p>
<h2 id="23-复制">2.3 复制</h2>
<p>定义：Copy</p>
<ul>
<li>不会有内存碎片</li>
<li>需要占用双倍内存空间</li>
</ul>
<h3 id="复制流程">复制流程</h3>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/%E5%A4%8D%E5%88%B61.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">标记垃圾对象</p>
<figure data-type="image" tabindex="16"><img src="https://epitomm.github.io/post-images/%E5%A4%8D%E5%88%B62.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">复制 FROM 区域的非垃圾对象到 TO 区域</p>
<figure data-type="image" tabindex="17"><img src="https://epitomm.github.io/post-images/%E5%A4%8D%E5%88%B63.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">清空 FROM 区域剩余的垃圾对象后交换 FROM 和 TO 区域</p>
<p>将内存区域划分成两块大小相等的区域，FROM 和 TO（空闲）。</p>
<p><strong>标记</strong>：找到那些不被引用的对象标记为垃圾对象。</p>
<p><strong>复制</strong>：把 <strong>FROM 区域上的非垃圾对象复制到 TO 区域</strong>中，复制的过程中完成碎片整理。复制完成后，<strong>FROM 区域</strong>都是垃圾对象，<strong>全部清除</strong>，并且<strong>交换 FROM 和 TO 区域</strong>。</p>
<h3 id="优点-3">优点</h3>
<p><strong>不会产生碎片。</strong></p>
<h3 id="缺点-3">缺点</h3>
<p><strong>占用双倍内存空间。</strong></p>
<h1 id="三-分代垃圾回收">三、分代垃圾回收</h1>
<p><strong>堆内存划分</strong></p>
<ul>
<li>新生代：用完了就丢弃。<strong>朝生夕死</strong>的对象
<ul>
<li>伊甸园 Eden</li>
<li>幸存区 FROM</li>
<li>幸存区 TO</li>
</ul>
</li>
<li>老年代：长时间使用的对象。<strong>长期存活</strong>的对象</li>
</ul>
<blockquote>
<p>有一栋居民楼，类似 Java 虚拟机中的堆内存，居民楼中每家每户每天要产生一些垃圾，需要保洁工人来处理，如果保洁工人挨家挨户去收垃圾，效率低，所以设立一个垃圾场（新生代），存放生命周期短的垃圾，比如盒饭、包装袋等，都是回收更为频繁的垃圾，保洁工人需要每天打扫了一次。 每家每户里存储的垃圾（老年代），比如用旧的椅子，暂存在家里，将来空间紧张到放不下时，找保洁员清理这些垃圾。</p>
</blockquote>
<figure data-type="image" tabindex="18"><img src="https://epitomm.github.io/post-images/%E5%A0%86%E5%86%85%E5%AD%98%E5%88%92%E5%88%86.png" alt="图片" loading="lazy"></figure>
<ul>
<li><strong>对象首先分配在伊甸园区域</strong></li>
<li><strong>新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1并且交换 from、to</strong></li>
<li><strong>minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</strong>
<ul>
<li>对象的复制会更改对象地址，如果用户线程仍在运行，就会造成访问原来对象的地址找不到。</li>
</ul>
</li>
<li><strong>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15</strong>（对象头中占用 4bit：1111B）</li>
<li><strong>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时间更长，如果之后空间仍不足，就会内存溢出。</strong></li>
</ul>
<h2 id="31-分代垃圾回收机制原理">3.1 分代垃圾回收机制原理</h2>
<figure data-type="image" tabindex="19"><img src="https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_1.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">当伊甸园被占满时要添加新对象，触发 minor gc</p>
<figure data-type="image" tabindex="20"><img src="https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_2.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">将伊甸园区的对象进行标记后，非垃圾对象复制到幸存区 TO，并且将这些非垃圾对象的寿命 +1，清空伊甸园内剩余的垃圾对象</p>
<figure data-type="image" tabindex="21"><img src="https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_3.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">交换 FROM 和 TO</p>
<p>创建一个新对象，存放到<strong>伊甸园</strong>，当伊甸园被占满时，触发 <strong>minor gc</strong>，先对伊甸园区域内的对象进行<strong>标记</strong>，标记结束后，采用<strong>复制算法</strong>，将非垃圾对象<strong>复制</strong>到幸存区 TO，并让这些对象的寿命+1，伊甸园剩余的垃圾对象回收掉，<strong>交换</strong> FROM 和 TO，第一次 minor gc 结束。</p>
<figure data-type="image" tabindex="22"><img src="https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_4.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">将伊甸园和幸存区 FROM 中的非垃圾对象复制到幸存区 TO，并将这些对象的寿命 +1，清空伊甸园和幸存区 FROM 中的非垃圾对象，交换 FROM 和 TO。将新对象放入伊甸园。</p>
<p>继续创建对象向伊甸园添加，伊甸园再次被填满，再次触发 minor gc，除了要将伊甸园中的非垃圾对象找到以外，还要把<strong>幸存区 FROM</strong> 中的非垃圾对象找到，将非垃圾对象复制到幸存区 TO，并让这些对象的寿命 +1，伊甸园和幸存区 FROM 的垃圾对象清除，交换 FROM 和 TO，第二次 minor gc 结束。</p>
<figure data-type="image" tabindex="23"><img src="https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_5.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">当幸存区对象的寿命 = 15时，将此对对象移动到老年代。</p>
<figure data-type="image" tabindex="24"><img src="https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_6.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">当老年代空间不足，触发 FULL GC，对整个堆进行清理。</p>
<h2 id="32-相关-vm-参数">3.2 相关 VM 参数</h2>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>含义</strong></th>
<th style="text-align:left"><strong>参数</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">堆初始大小</td>
<td style="text-align:left">-Xms</td>
</tr>
<tr>
<td style="text-align:left">堆最大大小</td>
<td style="text-align:left">-Xmx 或 -XX:MaxHeapSize=size</td>
</tr>
<tr>
<td style="text-align:left">新生代大小</td>
<td style="text-align:left">-Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )</td>
</tr>
<tr>
<td style="text-align:left">幸存区比例（动态）</td>
<td style="text-align:left">-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</td>
</tr>
<tr>
<td style="text-align:left">幸存区比例</td>
<td style="text-align:left">-XX:SurvivorRatio=ratio</td>
</tr>
<tr>
<td style="text-align:left">晋升阈值</td>
<td style="text-align:left">-XX:MaxTenuringThreshold=threshold</td>
</tr>
<tr>
<td style="text-align:left">晋升详情</td>
<td style="text-align:left">-XX:+PrintTenuringDistribution</td>
</tr>
<tr>
<td style="text-align:left">GC详情</td>
<td style="text-align:left">-XX:+PrintGCDetails -verbose:gc</td>
</tr>
<tr>
<td style="text-align:left">FullGC 前 MinorGC</td>
<td style="text-align:left">-XX:+ScavengeBeforeFullGC</td>
</tr>
</tbody>
</table>
<ol>
<li>没有运行任何代码时，虚拟机参数 <code>-Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</code> 的堆内存占用情况</li>
</ol>
<pre><code>public class Demo2_1 {
    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc
    // -Xms20M：初始堆空间20M；
    // -Xmx20M：最大堆空间20M；
    // -Xmn10M：新生代10M；
    // -XX:+UseSerialGC：垃圾回收器，幸存区比例不会动态调整
    // -XX:+PrintGCDetails -verbose:gc：打印 gc 详情
    public static void main(String[] args) throws InterruptedException {


    }
</code></pre>
<figure data-type="image" tabindex="25"><img src="https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B0.png" alt="图片" loading="lazy"></figure>
<p>2.Eden 区域不足时，触发 minor gc 时的堆内存占用</p>
<pre><code>package cn.itcast.vm.t2;
import java.util.ArrayList;
public class Demo2_1 {
    private static final int _7MB = 7 * 1024 * 1024;

    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC
    public static void main(String[] args) throws InterruptedException {
        ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
        list.add(new byte[_7MB]);
    }
}
</code></pre>
<p>因为 Eden 共 8M，类加载时创建一些对象占用了 29% 的空间，大概剩余 6M 空间，创建一个 7M 的对象，加入 Eden，Eden 内存不足，会触发垃圾回收。<br>
<img src="https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B02.png" alt="图片" loading="lazy"></p>
<pre><code>package cn.itcast.jvm.t2;

import java.util.ArrayList;

/**
 *  演示内存的分配策略
 */
public class Demo2_1 {
    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * 1024 * 1024;
    private static final int _7MB = 7 * 1024 * 1024;
    private static final int _8MB = 8 * 1024 * 1024;

    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC
    public static void main(String[] args) throws InterruptedException {
        ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
        list.add(new byte[_7MB]);
        list.add(new byte[_512KB]);
    }
}
</code></pre>
<figure data-type="image" tabindex="26"><img src="https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B03.png" alt="图片" loading="lazy"></figure>
<ol start="3">
<li>新生代区域内存不足创建对象，放入老年代</li>
</ol>
<pre><code>package cn.itcast.jvm.t2;

import java.util.ArrayList;

/**
 *  演示内存的分配策略
 */
public class Demo2_1 {
    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * 1024 * 1024;
    private static final int _7MB = 7 * 1024 * 1024;
    private static final int _8MB = 8 * 1024 * 1024;

    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC
    public static void main(String[] args) throws InterruptedException {
        ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
        list.add(new byte[_7MB]);
        list.add(new byte[_512KB]);
        list.add(new byte[_512KB]);
    }
}
</code></pre>
<figure data-type="image" tabindex="27"><img src="https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B04.png" alt="图片" loading="lazy"></figure>
<ol start="4">
<li>添加的对象比新生代总内存大，直接放入老年代且不触发 GC。</li>
</ol>
<pre><code>package cn.itcast.jvm.t2;
import java.util.ArrayList;
public class Demo2_1 {
    private static final int _8MB = 8 * 1024 * 1024;
    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC
    public static void main(String[] args) throws InterruptedException {
        ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
        list.add(new byte[_8MB]);
    }
}
</code></pre>
<figure data-type="image" tabindex="28"><img src="https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B05.png" alt="图片" loading="lazy"></figure>
<ol start="5">
<li>内存溢出</li>
</ol>
<pre><code>package cn.itcast.jvm.t2;

import java.util.ArrayList;

/**
 *  演示内存的分配策略
 */
public class Demo2_1 {
    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * 1024 * 1024;
    private static final int _7MB = 7 * 1024 * 1024;
    private static final int _8MB = 8 * 1024 * 1024;

    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC
    public static void main(String[] args) throws InterruptedException {
        ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
        list.add(new byte[_8MB]);
        list.add(new byte[_8MB]);
    }
}
</code></pre>
<figure data-type="image" tabindex="29"><img src="https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B06.png" alt="图片" loading="lazy"></figure>
<ol start="6">
<li>当内存溢出发生在子线程中，是否会导致 java 进程结束？</li>
</ol>
<pre><code>package cn.itcast.jvm.t2;

import java.util.ArrayList;

/**
 *  演示内存的分配策略
 */
public class Demo2_1 {
    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * 1024 * 1024;
    private static final int _7MB = 7 * 1024 * 1024;
    private static final int _8MB = 8 * 1024 * 1024;

    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails 
    public static void main(String[] args) throws InterruptedException {
        new Thread(() -&gt; {
            ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
            list.add(new byte[_8MB]);
            list.add(new byte[_8MB]);

        }).start();

        System.out.println(&quot;sleep....&quot;);
        Thread.sleep(1000L);  
    }
}
</code></pre>
<figure data-type="image" tabindex="30"><img src="https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B07.png" alt="图片" loading="lazy"></figure>
<h1 id="四-垃圾回收器">四、垃圾回收器</h1>
<ol>
<li>串行</li>
</ol>
<ul>
<li>单线程</li>
<li>堆内存较小，适合个人电脑</li>
</ul>
<ol start="2">
<li>吞吐量优先</li>
</ol>
<ul>
<li>多线程</li>
<li>堆内存较大，多核 cpu</li>
<li>让单位时间内，STW 的时间最短。两次垃圾回收：0.2+0.2 = 0.4，<strong>垃圾回收时间占比最低，这样就称吞吐量高</strong></li>
</ul>
<ol start="3">
<li>响应时间优先</li>
</ol>
<ul>
<li>多线程</li>
<li>堆内存较大，多核 cpu</li>
<li>尽可能让<strong>单次 STW 的时间最短</strong>。五次垃圾回收：0.1+0.1+0.1+0.1+0.1 = 0.5</li>
</ul>
<h2 id="41-串行">4.1 串行</h2>
<pre><code>-XX:+UseSerialGC = Serial + SerialOld
</code></pre>
<p>Serial：工作在<strong>新生代</strong>。<strong>复制</strong>算法<br>
SerialOld：工作在<strong>老年代</strong>。<strong>标记整理</strong>算法</p>
<figure data-type="image" tabindex="31"><img src="https://epitomm.github.io/post-images/%E4%B8%B2%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="图片" loading="lazy"></figure>
<p>四个 CPU 在运行，某时刻堆内存不足，触发垃圾回收。触发垃圾回收时，需要让这些线程到达一个<strong>安全点</strong>再停下，因为在垃圾回收的过程中，可能对象的地址发生改变，为了保证安全地使用这些对象地址，需要所有正在工作的用户线程到达这个安全点在停下。因为 Serial、SerialOld 都是<strong>单线程</strong>的垃圾回收器，因此在一个垃圾回收线程运行时，其他的用户线程都要<strong>阻塞</strong>，等到垃圾回收线程结束后，其他的用户线程再恢复运行。</p>
<h2 id="42-吞吐量优先">4.2 吞吐量优先</h2>
<p><strong>吞吐量</strong>：CPU 用于运行用户程序的时间与总时间的比值。</p>
<pre><code>-XX:+UseParallelGC ~ -XX:+UseParallelOldGC
-XX:+UseAdaptiveSizePolicy
-XX:GCTimeRatio=ratio 
-XX:MaxGCPauseMillis=ms 
-XX:ParallelGCThreads=n 
</code></pre>
<p><code>-XX:+UseParallelGC ~ -XX:+UseParallelOldGC</code>：JDK 1.8 默认使用 ParallelGC <strong>并行</strong>的垃圾回收器。<br>
UseParallelGC 并行的新生代垃圾回收器，采用<strong>复制</strong>算法；UseParallelOldGC 并行的老年代垃圾回收器，采用<strong>标记整理</strong>算法。</p>
<p><code>-XX:+UseAdaptiveSizePolicy</code>：自适应大小调整（新生代：Eden 和 Survival）策略</p>
<p><code>-XX:GCTimeRatio=ratio</code>：根据设置目标调整堆的大小以达到期望的目标。吞吐量：垃圾回收时间和总时间占比。1/(1+ratio)。一般堆调大，减少垃圾回收次数。</p>
<p><code>-XX:MaxGCPauseMillis=ms</code>：最大暂停毫秒数（每一次垃圾回收耗时）</p>
<p><code>-XX:ParallelGCThreads=n</code> ：控制 ParallelGC 运行时的<strong>线程数</strong>。</p>
<figure data-type="image" tabindex="32"><img src="https://epitomm.github.io/post-images/%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="图片" loading="lazy"></figure>
<p>四个 CPU 在运行，某一时刻内存不足触发垃圾回收，用户线程就会到达安全点然后停下来，垃圾回收器<strong>开启多个线程进行垃圾回收</strong>。垃圾回收线程个数默认和 CPU 核数相关。回收结束后再恢复其他的线程运行。在垃圾回收时，四核 CPU 都去进行垃圾回收了，<strong>CPU 占用率</strong>会一下达到 100%。</p>
<h2 id="43-响应时间优先">4.3 响应时间优先</h2>
<pre><code>-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld 
-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads 
-XX:CMSInitiatingOccupancyFraction=percent 
-XX:+CMSScavengeBeforeRemark
</code></pre>
<p><code>-XX:+UseConcMarkSweepGC</code> ：<strong>并发标记清除</strong>。垃圾回收器工作的同时，其他用户线程也能同时进行。垃圾回收线程和用户线程并发执行，都要去抢占 CPU。<br>
<code>-XX:+UseParNewGC</code>：工作在新生代，复制算法。 <strong>SerialOld</strong>：老年代垃圾回收器由并发退化为单线程 （基于标记整理的老年垃圾回收器）。<br>
<img src="https://epitomm.github.io/post-images/%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="图片" loading="lazy"></p>
<p>多个 CPU 并行执行，老年代内存不足，所有进程到达安全点，执行<strong>初始标记</strong>，用户线程阻塞，STW；初始标记结束后，用户线程开始运行，停止 STW，与此同时垃圾回收线程<strong>并发标记</strong>，把剩余的垃圾找出来；并发标记结束后，进行<strong>重新标记</strong>，这个过程 STW，因为并发标记的过程用户线程可能对垃圾回收做了干扰，所以并发标记结束后还要再做一次重新标记；重新标记结束后，用户线程继续运行，垃圾回收线程<strong>并发清理</strong>。</p>
<h2 id="44-g1">4.4 G1</h2>
<p>定义：Garbage First</p>
<ul>
<li>2004 论文发布</li>
<li>2009 JDK 6u14 体验</li>
<li>2012 JDK 7u4 官方支持</li>
<li>2017 JDK 9 默认。G1 取代了 CMS</li>
</ul>
<p>适用场景</p>
<ul>
<li>同时注重<strong>吞吐量</strong>（Throughput）和<strong>低延迟</strong>（Low latency），默认的暂停目标是 200 ms</li>
<li>并发的垃圾回收器，和 CMS 一样追求低延迟，可以在用户线程工作的同时垃圾回收线程也并发执行。另外还借鉴了 Parallel：注重吞吐量垃圾回收器的思想，可以进行调整，设置默认暂停目标（<code>-XX:MaxGCPauseMillis</code>）。</li>
<li><strong>超大堆内存</strong>，会<strong>将堆划分为多个大小相等的 Region</strong></li>
</ul>
<p>随着堆内存容量的增大，G1 与 CMS 相比优势更加明显。</p>
<p>将堆划分为多个大小相等的 Region：每个区域都可以独立地作为 Eden、survive、老年代。</p>
<p><code>-XX:G1HeapRegionSize</code>：设置区域的大小，必须是2的幂。如果堆内存过大，回收速度会变慢，因为会涉及对象的复制标记，而分成小的区域进行管理，可以化整为零，进行一些优化加快标记拷贝的速度。</p>
<ul>
<li>整体上是 <strong>标记+整理</strong> 算法（避免标记清除算法产生的内碎片），两个区域之间是复制算法</li>
</ul>
<p>相关 JVM 参数</p>
<pre><code>-XX:+UseG1GC 
-XX:G1HeapRegionSize=size 
-XX:MaxGCPauseMillis=time
</code></pre>
<figure data-type="image" tabindex="33"><img src="https://epitomm.github.io/post-images/G1_2.png" alt="图片" loading="lazy"></figure>
<h3 id="1-g1-垃圾回收阶段">1) G1 垃圾回收阶段</h3>
<figure data-type="image" tabindex="34"><img src="https://epitomm.github.io/post-images/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%98%B6%E6%AE%B5.png" alt="图片" loading="lazy"></figure>
<p>刚开始新生代垃圾收集，如果某时刻老年代内存超过阈值了，在新生代垃圾收集的同时进行并发标记，这个阶段结束后会进行混合收集：会对新生代、幸存区、老年代都进行收集。混合收集结束，Eden 内存释放掉，会再进入新生代垃圾收集。</p>
<h3 id="2-young-collection">2) Young Collection</h3>
<ul>
<li>会 STW</li>
</ul>
<figure data-type="image" tabindex="35"><img src="https://epitomm.github.io/post-images/G1%E5%88%86%E5%8C%BA.png" alt="图片" loading="lazy"></figure>
<p>G1 垃圾回收器把<strong>堆内存划分成大小相等的一个个区域</strong>，每个区域都可独立作为伊甸园、幸存区、老年代。刚开始白色的区域表示是空闲的区域，类加载时新创建的对象刚开始会分配到伊甸园区，绿色的 E 就代表 Eden 区，当 Eden 区域逐渐被占满，就会触发新生代的垃圾回收。</p>
<figure data-type="image" tabindex="36"><img src="https://epitomm.github.io/post-images/G1%E6%96%B0%E7%94%9F%E4%BB%A3%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="图片" loading="lazy"></figure>
<p>新生代垃圾回收会把非垃圾对象以复制算法放入幸存区。</p>
<figure data-type="image" tabindex="37"><img src="https://epitomm.github.io/post-images/G1%E8%80%81%E5%B9%B4%E4%BB%A3.png" alt="图片" loading="lazy"></figure>
<p>当幸存区对象放不下，或幸存区对象寿命达到一定值，会触发垃圾回收，幸存区一部分对象会晋升到老年代，而寿命未达到阈值的会拷贝到另一个幸存区，新生代的非垃圾对象也会复制到这个幸存区。</p>
<h3 id="3-young-collection-cm">3) Young Collection + CM</h3>
<p>CM：Concurrent mark：并发标记</p>
<p><strong>初始标记</strong>：找到那些根对象，标记根对象。</p>
<p><strong>并发标记</strong>：从根对象出发，顺着引用链找到其他非垃圾对象，标记那些其他非垃圾对象。</p>
<ul>
<li>在 Young GC 时会进行 GC Root 的<strong>初始标记</strong></li>
<li>老年代占用堆空间比例达到阈值时，进行<strong>并发标记</strong>（不会 STW），由下面的 JVM 参数决定</li>
</ul>
<pre><code>-XX:InitialtingHeapOccupancyPercent=percent（默认45%）
</code></pre>
<p>老年代占用堆空间内存达到 45% 时，会进行并发标记。<br>
<img src="https://epitomm.github.io/post-images/G1%E8%80%81%E5%B9%B4%E4%BB%A3%E8%BF%87%E5%A4%9A%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0.png" alt="图片" loading="lazy"></p>
<p>E：Eden</p>
<p>S：Survive</p>
<p>O：Old</p>
<h3 id="4-mixed-collection">4) Mixed Collection</h3>
<p>会对 E、S、O 进行<strong>全面垃圾回收</strong></p>
<ul>
<li>最终标记（Remark）会 STW</li>
<li>拷贝存活（Evacuation）会 STW</li>
</ul>
<p>-XX:MaxGCPauseMillis=ms</p>
<figure data-type="image" tabindex="38"><img src="https://epitomm.github.io/post-images/G1%E5%85%A8%E9%9D%A2%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png" alt="图片" loading="lazy"></figure>
<p>Eden 区域的非垃圾对象被复制到 Survive 区域，Survive 区域寿命未达到阈值的非垃圾对象被复制到另一个 Survive 区域，寿命达到阈值的晋升到老年代区域。一部分老年代区域的幸存对象通过复制算法复制到新的的老年代区域，为什么没有把所有老年代都通过箭头指向新的老年代呢？因为 G1 会根据最大暂停时间有选择地进行回收，有时候堆内存空间太大了，老年代的垃圾回收可能时间比较长（复制算法大量对象的复制），就达不到<strong>最大暂停时间</strong>的目标了，为了达到这个目标，G1 会从老年代中挑出<strong>回收价值最高</strong>的区域（垃圾回收后能释放空间多的区域），只从老年代中挑选一部分区域复制，复制的区域少了，就可以达到暂停时间的目标了。如果老年代没有那么多，可以达到最大暂停时间的话， 就会把所有区域都进行复制。</p>
<h3 id="5-full-gc">5) Full GC</h3>
<ul>
<li>SerialGC：串行
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足发生的垃圾收集 - full gc</li>
</ul>
</li>
<li>ParallelGC：并行
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足发生的垃圾收集 - full gc</li>
</ul>
</li>
<li>CMS
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足
<ul>
<li>并发收集失败后 Full GC</li>
</ul>
</li>
</ul>
</li>
<li>G1
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足
<ul>
<li>有一个阈值，当老年代内存达到阈值，就会触发并发标记、混合收集阶段。如果垃圾回收的速度高于新的用户线程产生垃圾的速度，就处于并发垃圾收集阶段，这阶段还不算 Full GC。</li>
<li>当垃圾回收的速度跟不上垃圾产生的速度，并发收集失败，就会触发串行收集，这阶段叫做 Full GC。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-young-collection-跨代引用">6) Young Collection 跨代引用</h3>
<p>新生代回收的跨代引用（老年代引用新生代）问题</p>
<figure data-type="image" tabindex="39"><img src="https://epitomm.github.io/post-images/Card.png" alt="图片" loading="lazy"></figure>
<p>新生代垃圾回收：找到根对象，沿着引用链找到存活对象，存活对象进行复制到幸存区。要找新生代对象的根对象，<strong>根对象有一部分来自于老年代</strong>，老年代的存活对象非常多，如果遍历老年代找根对象效率低，因此把<strong>老年代区域再进行细分</strong>，分成一个个 Card，每个 Card 是512KB，如果老年代其中有一个 <strong>Card 中的对象引用了新生代的某一个对象</strong>，就把这个 <strong>Card 标记为脏</strong>，这样以后，做 GC Root 遍历的时候就不用去找整个老年代了，只需要关注那些脏 Card 即可，减少搜索范围，<strong>提高扫描根对象的效率</strong>。</p>
<ul>
<li>卡表与 Remembered Set</li>
<li>在引用变更时通过 post-write barrier + dirty card queue</li>
<li>concurrent refinement threads 更新 Remembered Set</li>
</ul>
<figure data-type="image" tabindex="40"><img src="https://epitomm.github.io/post-images/Card2.png" alt="图片" loading="lazy"></figure>
<p>粉色的 Card 都是<strong>脏卡区</strong>，Card 内有对象指向新生代区域的对象，新生代会记录 <strong>Remembered Set：从外部对我的引用</strong>，将来对新生代 Eden 进行垃圾回收时，就可以先通过 Remembered Set 知道它对应的哪些脏 Card，然后在到这些脏卡区遍历对象找到 GC Root。通过 <strong>post-write barrier</strong>：写屏障在每次<strong>对象的引用发生变更时，去更新脏 Card</strong>，这个过程是<strong>异步</strong>操作，不会立刻完成脏卡的更新，会把更新指令放在 <strong>dirty card queue 脏卡队列</strong>中，将来由一个线程完成脏卡更新的操作。</p>
<h3 id="7-remark-重标记阶段">7) Remark 重标记阶段</h3>
<ul>
<li>pre-write barrier + satb_mark_queue</li>
</ul>
<p><code>pre-write barrier</code>：写屏障：在对象引用改变前，将对象加入到 <code>satb_mark_queue</code> 队列，将来 remark 从队列中取出对象进一步判断。</p>
<figure data-type="image" tabindex="41"><img src="https://epitomm.github.io/post-images/%E9%87%8D%E6%A0%87%E8%AE%B0_1.png" alt="图片" loading="lazy"></figure>
<p>并发标记阶段对象的 true 和 false，其中图中<strong>黑色</strong>表示已经处理完成，并且有引用在引用它们，在垃圾回收后会被<strong>保留</strong>下来。<strong>灰色</strong>的是正在<strong>触发中</strong>，灰色的因为有强引用黑色的在指向它，所以最终会变成黑色，<strong>白色</strong>的是<strong>尚未处理</strong>，如果有强引用指向它最后会变成黑色，如果没有引用指向它最终还是白色，会被当成垃圾回收。垃圾回收结束后，会根据对象的黑白状态区分它到底应该存活还是被回收。</p>
<p><img src="https://epitomm.github.io/post-images/%E9%87%8D%E6%A0%87%E8%AE%B0_2.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/%E9%87%8D%E6%A0%87%E8%AE%B0_3.png" alt="图片" loading="lazy"></p>
<p><strong>Remark 流程：</strong><br>
<img src="https://epitomm.github.io/post-images/%E9%87%8D%E6%A0%87%E8%AE%B0_4.png" alt="图片" loading="lazy"></p>
<h3 id="8-jdk-8u20-字符串去重">8) JDK 8u20 字符串去重</h3>
<ul>
<li>优点：节省大量内存</li>
<li>缺点：略微多占用了 cpu 时间，新生代回收时间略微增加</li>
</ul>
<p><code>-XX:+UseStringDeduplication</code></p>
<pre><code>String s1 = new String(&quot;hello&quot;); // char[]{'h','e','l','l','o'} 
String s2 = new String(&quot;hello&quot;); // char[]{'h','e','l','l','o'}
</code></pre>
<ul>
<li>将所有新分配的字符串放入一个<strong>队列</strong></li>
<li>当新生代回收时，G1并发检查队列中是否有字符串重复</li>
<li>如果它们值一样，让它们<strong>引用同一个 char[]</strong></li>
<li>注意，与 String.intern() 不一样
<ul>
<li>String.intern() 关注的是<strong>字符串对象</strong></li>
<li>而字符串去重关注的是 <strong>char[]</strong></li>
<li>在 JVM 内部，使用了不同的字符串表</li>
</ul>
</li>
</ul>
<h3 id="9-jdk-8u40-并发标记类卸载">9) JDK 8u40 并发标记类卸载</h3>
<p>所有对象都经过并发标记后，就能知道<strong>哪些类不再被使用</strong>，当一个类加载器的所有类都不再使用，则<strong>卸载它所加载的所有类</strong></p>
<p><code>-XX:+ClassUnloadingWithConcurrentMark</code> 默认启用</p>
<h3 id="10-jdk-8u60-回收巨型对象">10) JDK 8u60 回收巨型对象</h3>
<figure data-type="image" tabindex="42"><img src="https://epitomm.github.io/post-images/%E5%9B%9E%E6%94%B6%E5%B7%A8%E5%9E%8B%E5%AF%B9%E8%B1%A1.png" alt="图片" loading="lazy"></figure>
<p>Region 区域内粉色的 H 就是巨型对象。</p>
<ul>
<li>一个对象<strong>大于 region 的一半</strong>时，称之为巨型对象</li>
<li>G1 <strong>不会对巨型对象进行拷贝</strong></li>
<li><strong>回收时被优先考虑</strong></li>
<li>G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0 的巨型对象就可以在新生代垃圾回收时处理掉</li>
</ul>
<figure data-type="image" tabindex="43"><img src="https://epitomm.github.io/post-images/%E5%9B%9E%E6%94%B6%E5%B7%A8%E5%9E%8B%E5%AF%B9%E8%B1%A1_2.png" alt="图片" loading="lazy"></figure>
<h3 id="11-jdk-9-并发标记起始时间的调整">11) JDK 9 并发标记起始时间的调整</h3>
<p>如果垃圾回收的速度跟不上垃圾产生的速度，最终会退化为 Full GC。G1 的 Full GC 是多线程的，Full GC 的 STW 过程很长，因此要尽可能避免 Full GC 的发生。如何减少 Full GC 呢？提前让垃圾回收开始，并发标记、混合收集提前开始，就能减少 Full GC 发生的几率。</p>
<ul>
<li>并发标记必须在堆空间占满前完成，否则退化为 FullGC</li>
<li>JDK 9 之前需要使用 <code>-XX:InitiatingHeapOccupancyPercent</code>：老年代在堆内存的占比，当超过设置的这个阈值时，就会触发并发垃圾回收。</li>
<li>JDK 9 可以动态调整
<ul>
<li><code>-XX:InitiatingHeapOccupancyPercent</code> 用来设置<strong>初始值</strong></li>
<li>进行<strong>数据采样</strong>并<strong>动态调整</strong></li>
<li>总会添加一个安全的空档空间</li>
</ul>
</li>
</ul>
<h3 id="12-jdk-9-更高效的回收">12) JDK 9 更高效的回收</h3>
<p>250+增强</p>
<p>180+bug修复</p>
<p><a href="https://docs.oracle.com/en/java/javase/12/gctuning">https://docs.oracle.com/en/java/javase/12/gctuning</a></p>
<h1 id="五-垃圾回收调优">五、垃圾回收调优</h1>
<p>预备知识</p>
<ul>
<li>掌握 GC 相关的 VM 参数，会基本的空间调整</li>
<li>掌握相关工具</li>
<li>明白一点：调优跟应用、环境有关，没有放之四海而皆准的法则</li>
</ul>
<p>查看虚拟机运行参数：</p>
<pre><code>&quot;C:\Program Files\Java\jdk1.8.0_172\bin\java&quot; -XX:+PrintFlagsFinal -version | findstr &quot;GC&quot;
</code></pre>
<figure data-type="image" tabindex="44"><img src="https://epitomm.github.io/post-images/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%B0%83%E4%BC%98.png" alt="图片" loading="lazy"></figure>
<h2 id="51-调优领域">5.1 调优领域</h2>
<ul>
<li>内存</li>
<li>锁竞争</li>
<li>cpu 占用</li>
<li>io</li>
</ul>
<h2 id="52-确定目标">5.2 确定目标</h2>
<ul>
<li>【低延迟】还是【高吞吐量】，选择合适的回收器</li>
<li>CMS，G1，ZGC：低延迟</li>
<li>ParallelGC：高吞吐量</li>
<li>Zing</li>
</ul>
<h2 id="53-最快的-gc-是不发生-gc">5.3 最快的 GC 是不发生 GC</h2>
<p>答案是不发生 GC</p>
<ul>
<li>查看 FullGC 前后的内存占用，考虑下面几个问题
<ul>
<li>数据是不是太多？
<ul>
<li><code>resultSet = statement.executeQuery(&quot;select * from 大表 limit n&quot;)</code></li>
</ul>
</li>
<li>数据表示是否太臃肿？
<ul>
<li>对象图</li>
<li>对象大小 16 Integer 24 int 4</li>
</ul>
</li>
<li>是否存在内存泄漏？
<ul>
<li>static Map map 不断向里面放数据</li>
<li>软</li>
<li>弱</li>
<li>第三方缓存实现</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="54-新生代调优">5.4 新生代调优</h2>
<h3 id="新生代的特点">新生代的特点</h3>
<ul>
<li>所有的 new 操作的内存分配非常廉价
<ul>
<li>TLAB thread-local allocation buffer
<ul>
<li>在 Eden 中给<strong>每个线程分配一块私有缓冲区 TLAB</strong>，new 对象时会首先检查 TLAB 缓冲区内是否有空白区域，如果有就优先在 TLAB 这块内存分配。因为线程安全问题，比如线程 1 要用这块内存，分配还没结束时，线程 2 不能也要用这块内存，造成内存分配混乱，  因此在对象的内存分配时，要做线程安全的保护，<strong>减少线程之间对分配时的并发冲突</strong>：TLAB  ：线程局部分配缓冲区。每个线程用自己私有的 Eden 内存来进行内存分配，多个线程即使同时创建对象，也不会产生对内存占用的干扰。</li>
</ul>
</li>
</ul>
</li>
<li>死亡对象的回收代价是零
<ul>
<li>新生代发生垃圾回收时，垃圾回收器复制算法：把 Eden、幸存区 FROM 中的幸存对象都复制到幸存区 TO，Eden、FROM 中的内存就被释放了，因此死亡对象的回收代价是零。</li>
</ul>
</li>
<li>新生代大部分对象用过即死</li>
<li>Minor GC 的时间远远低于 Full GC</li>
</ul>
<h3 id="新生代越大越好吗">新生代越大越好吗？</h3>
<p>-Xmn</p>
<blockquote>
<p>Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery).<br>
GC is performed in this region more often than in other regions. If the size for the young<br>
generation is too small, then a lot of minor garbage collections are performed. If the size is too  large, then only full garbage collections are performed, which can take a long time to complete.<br>
Oracle recommends that you keep the size for the young generation greater than 25% and less than 50% of the overall heap size.</p>
</blockquote>
<p>-Xmn：设置堆中新生代的初始和最大值。<strong>新生代设置小</strong>了，<strong>可用空间少</strong>，创建对象时一旦发现新生代的空间不足就会触发新生代的 <strong>minor gc</strong>。如果新<strong>生代内存太大</strong>了，<strong>老年代的可用空间相对少了</strong>，老年代的空间少了，将来新生代觉得我空闲空间很多，新创建的对象都还不会触发垃圾回收，但是老年代的空间紧张，再触发垃圾回收，就是 full gc，<strong>full gc 的暂停时间比 minor gc 时间更长</strong>。<strong>新生代大于堆内存的 1/4 ,小于 1/2 即可</strong>。</p>
<figure data-type="image" tabindex="45"><img src="https://epitomm.github.io/post-images/%E6%96%B0%E7%94%9F%E4%BB%A3-%E5%90%9E%E5%90%90%E9%87%8F.png" alt="图片" loading="lazy"></figure>
<p><strong>吞吐量</strong>：单位时间能响应的请求数量。</p>
<p>随着新生代空间越来越大，吞吐量越来越高，垃圾回收占用整个 CPU 计算的时间比例少了，CPU时间更多用来处理请求了，吞吐量就变高了，但是到了一定的大小后，会有一个下降：<strong>新生代空间大了，意味着回收的时间较长</strong>。</p>
<p><strong>新生代调整尽可能大</strong>，新生代的垃圾回收都是复制算法，复制算法分成：标记、复制两个阶段，复制阶段花费的时间更多，而<strong>新生代的对象，绝大部分都是朝生夕死的，最终只有少量的对象会存活下来，复制所占用的时间也是相对较短的</strong>，而标记时间相对于复制时间来讲，就显得不是很重要了，所以<strong>新生代调大的情况下，主要时间还是耗费在复制上，即使增得很大，效率也不会有很明显的下降</strong>。</p>
<h3 id="新生代的大小设置">新生代的大小设置</h3>
<ul>
<li><strong>新生代能容纳并发量 *  (一次请求-响应过程产生的对象)的数据</strong>
<ul>
<li>并发量 * 请求 - 响应过程中所产生的的对象</li>
<li>如果一次 请求-响应 过程中产生的对象是 512KB，并发量是 1000，那么新生代理想的内存就是 1000* 512KB = 521M。因为一次 请求-响应的过程，在这次 请求-响应 结束后，大多数对象都会被回收，只要这一次 请求-响应 占用的内存不超过新生代的内存，就不会触发新生代的垃圾回收</li>
</ul>
</li>
<li><strong>幸存区大到能保留当前活跃对象+需要晋升对象</strong>
<ul>
<li>幸存区中有两类对象：<strong>①生命周期较短，下一次垃圾回收就把它回收掉了</strong>，但由于现在还在使用，暂时不能回收；<strong>②将来会被晋升到老年代</strong>，但是由于年龄不够，所以暂时存放在幸存区中。</li>
<li><strong>如果幸存区较小，就会由 JVM 动态调整晋升阈值</strong>，也许本来有些对象不应该晋升的，但是由于幸存区内存不够，导致会提前<strong>把本应回收的对象晋升到老年代</strong>。如果存活时间短的对象被晋升到了老年代，需要等到老年代内存不足，触发 Full GC 时才能把它当做垃圾进行回收，延长了对象的生存时间。</li>
</ul>
</li>
<li><strong>晋升阈值配置得当，让长时间存活对象尽快晋升</strong>
<ul>
<li>如果是一个<strong>长期存活的对象</strong>，把它<strong>留到幸存区里</strong>，只会<strong>耗费幸存区的内存</strong>，并且新生代垃圾回收都是复制算法，要把幸存区的存活对象从 FROM 复制到 TO，如果大量长时间存活的对象不能及早晋升，那么就要留在幸存区被<strong>复制来复制去</strong>。调整晋升阈值，让<strong>长时间存活的对象尽快晋升到老年代</strong>。</li>
</ul>
</li>
</ul>
<p>调整最大晋升阈值：</p>
<pre><code>-XX:MaxTenuringThreshold=threshold 
</code></pre>
<p>显示幸存区对象详情：</p>
<pre><code>-XX:+PrintTenuringDistribution 
</code></pre>
<pre><code>Desired survivor size 48286924 bytes, new threshold 10 (max 10) 
- age 1: 28992024 bytes, 28992024 total 
- age 2: 1366864 bytes, 30358888 total 
- age 3: 1425912 bytes, 31784800 total 
...
</code></pre>
<h2 id="55-老年代调优">5.5 老年代调优</h2>
<h3 id="以-cms-为例">以 CMS 为例</h3>
<p>CMS 垃圾回收器：<strong>低响应时间、并发的</strong>（垃圾回收线程在工作的同时其他用户线程也能在并发的执行：垃圾回收的同时其他用户线程也在运行，就会产生新的浮动垃圾，如果浮动垃圾产生导致内存不足，就会造成 CMS 并发失败，CMS 垃圾回收器退化为 串行老年代垃圾回收器：STW）</p>
<ul>
<li>CMS 的<strong>老年代内存越大越好</strong>
<ul>
<li>预留更多空间，避免浮动垃圾引起的并发失败</li>
</ul>
</li>
<li><strong>先尝试不做调优</strong>，如果没有 Full GC 那么已经可以了，否则先尝试调优新生代</li>
<li>观察<strong>发生 Full GC 时老年代内存占用</strong>，将老年代内存预设调大 1/4 ~ 1/3</li>
</ul>
<pre><code>-XX:CMSInitiatingOccupancyFraction=percent
</code></pre>
<p>老年代的空间占用达到老年代的 percent% 时，触发垃圾回收 percent 越小，老年代垃圾回收触发时间越早。</p>
<h2 id="56-案例">5.6 案例</h2>
<h3 id="案例1-full-gc-和-minor-gc频繁空间紧张">案例1 Full GC 和 Minor GC频繁：空间紧张</h3>
<ul>
<li>问题分析：</li>
</ul>
<p>新生代空间紧张：当业务高峰期来了，大量对象被创建，<strong>新生代被填满</strong>，<strong>幸存区空间紧张</strong>了，<strong>晋升对象的阈值就会降低</strong>，导致很多原来<strong>生存周期很短的对象被晋升到老年代</strong>了，老年代存了大量生存周期很短的对象，进一步触发老年代 <strong>Full GC</strong> 发生。</p>
<ul>
<li>问题解决：</li>
</ul>
<p><strong>增大新生代内存</strong>，新生代内存增大了，内存充裕，新生代的垃圾回收不那么频繁了，增大了幸存区的空间以及晋升阈值，生命周期较短的对象尽可能在幸存区被回收，而不要晋升到老年代，减少老年代 Full GC。</p>
<h3 id="案例2-请求高峰期发生-full-gc单次暂停时间特别长-cms">案例2 请求高峰期发生 Full GC，单次暂停时间特别长 （CMS）</h3>
<ul>
<li>问题分析：</li>
</ul>
<p>查看日志，看 CMS 哪个阶段耗费时间长</p>
<figure data-type="image" tabindex="46"><img src="https://epitomm.github.io/post-images/%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="图片" loading="lazy"></figure>
<p>初始标记和并发标记都是比较快的，<strong>重新标记比较慢</strong>， 查看 GC 日志会把每一阶段耗费的时间显示。</p>
<ul>
<li>问题解决：</li>
</ul>
<p>重新标记会扫描整个内存，不光是要扫描老年代对象，也要同时扫描新生代对象，如果是业务高峰期，新生代对象比较多，扫描标记时间就会很长，因为要根据对象找它的引用，能不能<strong>在重新标记前把新生代的对象做一次垃圾回收</strong>，减少新生代对象的数量，减少重新标记阶段耗费的时间。通过设置：<code>-XX:+CMSScavengeBeforeRemark</code>：在重新标记发生之前，先对新生代进行一次垃圾清理。</p>
<h3 id="案例3-老年代充裕情况下发生-full-gc-cms-jdk17">案例3 老年代充裕情况下，发生 Full GC （CMS jdk1.7）</h3>
<ul>
<li>问题分析：</li>
</ul>
<p>CMS 可能由于空间不足导致并发失败，或者由于空间碎片多都会产生 Full GC。但是经过排查，在 GC 日志没有并发失败或者碎片过多的提示。说明老年代空间充裕，不是由于老年代空间不足产生的 Full GC。<strong>JDK1.7 及以前采用永久代作为方法区的实现，永久代空间不足也会导致 Full GC 发生</strong>，1.8 以后使用元空间就不是由 Java 控制了，所以元空间使用操作系统的空间一般情况是比较充裕的。1.7 以前永久代空间设置小了就会触发整个堆的 Full GC。</p>
<ul>
<li>问题解决：</li>
</ul>
<p>增大永久代的初始值和最大值</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP 系列（二）熟悉 HTTP 协议结构和通讯原理]]></title>
        <id>https://epitomm.github.io/post/http-xi-lie-er-shou-xi-http-xie-yi-jie-gou-he-tong-xun-yuan-li/</id>
        <link href="https://epitomm.github.io/post/http-xi-lie-er-shou-xi-http-xie-yi-jie-gou-he-tong-xun-yuan-li/">
        </link>
        <updated>2020-04-23T06:24:08.000Z</updated>
        <content type="html"><![CDATA[<h1 id="http-特点">HTTP 特点</h1>
<h2 id="支持-客户服务器-模式">支持 客户/服务器 模式</h2>
<p>客户/服务器模式工作的方式是由客户端向服务器发出请求，服务器端响应请求，并进行相应服务。</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/client-server.png" alt="图片" loading="lazy"></figure>
<h2 id="简单快速">简单快速</h2>
<ul>
<li>客户向服务器请求服务时，只需传送<strong>请求方法和路径</strong></li>
<li>请求方法常用的有<strong>GET、HEAD、POST</strong>。每种方法规定了客户与服务器联系的类型不同</li>
<li>由于HTTP协议简单，使得HTTP服务器的程序规模小，因而<strong>通信速度很快</strong></li>
</ul>
<h2 id="灵活">灵活</h2>
<ul>
<li><strong>HTTP允许传输任意类型的数据对象</strong></li>
<li>正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记</li>
</ul>
<h2 id="无连接">无连接</h2>
<ul>
<li>无连接的含义是限制<strong>每次连接只处理一个请求</strong></li>
<li>服务器处理完客户的请求，并收到客户的应答后，即断开连接</li>
<li>采用这种方式可以<strong>节省传输时间</strong></li>
</ul>
<h2 id="无状态">无状态</h2>
<ul>
<li>HTTP协议是无状态协议</li>
<li>无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大</li>
<li>另一方面，在服务器不需要先前信息时它的应答就较快</li>
</ul>
<h1 id="uri-与-url">URI 与 URL</h1>
<p>Q：我们输入在浏览器里的Web地址应该叫URL还是URI？</p>
<p>小A：我们访问的就是<strong>URL</strong>！</p>
<p>小B：不！其实那时<strong>URI</strong>好不好！</p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/URI.png" alt="图片" loading="lazy"></figure>
<ul>
<li>URI：一个紧凑的字符串用来标示抽象或物理资源</li>
<li>A URI 可以进一步被分为定位符、名字或两者都是</li>
<li>术语&quot;Uniform Resource Locator&quot;（URL）是URI的子集，除了确定一个资源，还提供一种定位该资源的主要访问机制（如其网络“位置”）</li>
</ul>
<h2 id="维基百科解释">维基百科解释</h2>
<ul>
<li>URI可以分为URL，URN或同时具备locators 和names特性的一个东西</li>
<li>URN作用就好像一个人的<strong>名字</strong>，URL就像一个人的<strong>地址</strong></li>
<li>换句话说：URN确定了东西的身份，URL提供了找到它的方式</li>
</ul>
<blockquote>
<p>一家公司的总经理有一张名片，上面写了 “北京 xxx 公司总经理张三”、办公室地址 “北京市海淀区长安街35号 xx 楼 xxx 办公室”。<br>
头衔：北京 xxx 公司总经理 —— 张三，建立一个映射，这个头衔就是 URI，<strong>只要看到一个 URI 就知道它代表什么</strong>。<br>
<a href="http://www.baidu.cn">www.baidu.cn</a> —— 百度网，<a href="http://www.baidu.com">www.baidu.com</a> 就是一个 URI<br>
admin@qq.com —— 代表某个人的 QQ 邮箱，admin@qq.com 也是一个 URI<br>
<strong>URI 是一个网络资源的头衔</strong>，是一个统称，通过 URI 可以把网络世界里的每一个事务都加以标记并且区分开来。<br>
“北京 xxx 公司总经理” 是一个 URI，我们知道这个头衔对应的是张三，但是我们不能去找到这个人，因为不知道他的地址，要定位到他就必须要知道他的办公室地址。反映到网络世界，网络世界中的每个资源不只有头衔，还要能够被人访问，所以网络地址也是必须的，否则这个网络资源的存在就没有任何意义了，这个<strong>网络地址就叫做 URL</strong>。</p>
</blockquote>
<ul>
<li>URL是URI的一种，但不是所有的URI都是URL</li>
<li>URI和URL最大的差别是“访问机制（HTTP 还是 FTP）&quot;</li>
<li>URN 是唯一标识的一部分，是身份信息</li>
</ul>
<h2 id="安能辨我是雌雄">安能辨我是雌雄</h2>
<ul>
<li>ftp://ftp.is.co.za/rfc/rfc1808.txt
<ul>
<li>URL，提供了访问机制是 FTP</li>
</ul>
</li>
<li>http://www.ietf.org/rfc/rfc2396.txt
<ul>
<li>URL，提供了访问机制是 HTTP</li>
</ul>
</li>
<li>Idap://[2001:db8::7]/c=GB?objectClass?one
<ul>
<li>URL，提供了访问机制 LDAP</li>
</ul>
</li>
<li>mailto:John.Doe@example.com
<ul>
<li>URL，通过邮件进行访问</li>
</ul>
</li>
<li>news:comp.infosystems.www.servers.unix
<ul>
<li>URL</li>
</ul>
</li>
<li>tel:+1-816-555-1212
<ul>
<li>URI：电话号码可以标识某一个人，但是没有访问机制</li>
</ul>
</li>
<li>telnet://192.0.2.16:80/
<ul>
<li>URL，访问机制 telnet</li>
</ul>
</li>
<li>urn:oasis:names:specification:docbook:dtd:xml:4.1.2
<ul>
<li>URL，地址中已经显示了 urn，没有自己的访问方式</li>
</ul>
</li>
</ul>
<h1 id="http-报文结构分析-请求报文">HTTP 报文结构分析 - 请求报文</h1>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>报文头和报文体中间有一行空行<br>
报文体内是表单的数据，不同参数之间使用 &amp; 进行拼接</p>
</blockquote>
<h2 id="http-报文头">HTTP 报文头</h2>
<ul>
<li>HTTP的报文头大体可以分为四类，分别是：通用报文头、请求报文头、响应报文头和实体报文头</li>
<li>在HTTP/1.1里一共规范了47种报文头字段</li>
</ul>
<h3 id="通用报文头">通用报文头</h3>
<table>
<thead>
<tr>
<th style="text-align:left">首部字段名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Cache-Control</td>
<td style="text-align:left">控制缓存的行为</td>
</tr>
<tr>
<td style="text-align:left">Connection</td>
<td style="text-align:left">逐跳首部、连接的管理</td>
</tr>
<tr>
<td style="text-align:left">Date</td>
<td style="text-align:left">创建报文的日期时间</td>
</tr>
<tr>
<td style="text-align:left">Pragma</td>
<td style="text-align:left">报文指令</td>
</tr>
<tr>
<td style="text-align:left">Trailer</td>
<td style="text-align:left">报文末端的首部一览</td>
</tr>
<tr>
<td style="text-align:left">Transfer-Encoding</td>
<td style="text-align:left">指定报文主体的传输编码方式</td>
</tr>
<tr>
<td style="text-align:left">Upgrade</td>
<td style="text-align:left">升级为其他协议</td>
</tr>
<tr>
<td style="text-align:left">Via</td>
<td style="text-align:left">代理服务器的相关信息</td>
</tr>
<tr>
<td style="text-align:left">Warning</td>
<td style="text-align:left">错误通知</td>
</tr>
</tbody>
</table>
<h3 id="请求报文头">请求报文头</h3>
<table>
<thead>
<tr>
<th style="text-align:left">首部字段名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Accept</td>
<td style="text-align:left">用户代理可处理的媒体类型</td>
</tr>
<tr>
<td style="text-align:left">Accept-Charset</td>
<td style="text-align:left">优先的字符集</td>
</tr>
<tr>
<td style="text-align:left">Accept-Encoding</td>
<td style="text-align:left">优先的内容编码</td>
</tr>
<tr>
<td style="text-align:left">Accept-Language</td>
<td style="text-align:left">优先的语言（自然语言）</td>
</tr>
<tr>
<td style="text-align:left">Authorization</td>
<td style="text-align:left">Web 认证信息</td>
</tr>
<tr>
<td style="text-align:left">Expect</td>
<td style="text-align:left">期待服务器的特定行为</td>
</tr>
<tr>
<td style="text-align:left">From</td>
<td style="text-align:left">用户的电子邮箱地址</td>
</tr>
<tr>
<td style="text-align:left">Host</td>
<td style="text-align:left">请求资源所在服务器</td>
</tr>
<tr>
<td style="text-align:left">If-Match</td>
<td style="text-align:left">比较实体标记（ETag）</td>
</tr>
<tr>
<td style="text-align:left">If-Modified-Since</td>
<td style="text-align:left">比较资源的更新时间</td>
</tr>
<tr>
<td style="text-align:left">If-None-Match</td>
<td style="text-align:left">比较实体标记（与 If-Match 相反）</td>
</tr>
<tr>
<td style="text-align:left">If-Range</td>
<td style="text-align:left">资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td style="text-align:left">If-Unmodified-Since</td>
<td style="text-align:left">比较资源的更新时间（与 If-Modified-Since相反）</td>
</tr>
<tr>
<td style="text-align:left">Max-Forwards</td>
<td style="text-align:left">最大传输逐跳数</td>
</tr>
<tr>
<td style="text-align:left">Proxy-Authorization</td>
<td style="text-align:left">代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td style="text-align:left">Range</td>
<td style="text-align:left">实体的字节范围请求</td>
</tr>
<tr>
<td style="text-align:left">Referrer</td>
<td style="text-align:left">对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td style="text-align:left">TE</td>
<td style="text-align:left">传输编码的优先级</td>
</tr>
<tr>
<td style="text-align:left">User-Agent</td>
<td style="text-align:left">HTTP 客户端程序的信息</td>
</tr>
</tbody>
</table>
<h3 id="响应报文头">响应报文头</h3>
<table>
<thead>
<tr>
<th style="text-align:left">首部字段名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Accept-Ranges</td>
<td style="text-align:left">是否接受字节范围请求</td>
</tr>
<tr>
<td style="text-align:left">Age</td>
<td style="text-align:left">推算资源创建经过时间</td>
</tr>
<tr>
<td style="text-align:left">ETag</td>
<td style="text-align:left">资源的匹配信息</td>
</tr>
<tr>
<td style="text-align:left">Location</td>
<td style="text-align:left">令客户端重定向至指定 URI</td>
</tr>
<tr>
<td style="text-align:left">Proxy-Authenticate</td>
<td style="text-align:left">代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td style="text-align:left">Retry-After</td>
<td style="text-align:left">对再次发起请求的时机要求</td>
</tr>
<tr>
<td style="text-align:left">Server</td>
<td style="text-align:left">HTTP服务器的安装信息</td>
</tr>
<tr>
<td style="text-align:left">Vary</td>
<td style="text-align:left">代理服务器缓存的管理信息</td>
</tr>
<tr>
<td style="text-align:left">WWW-Authenticate</td>
<td style="text-align:left">服务器对客户端的认证信息</td>
</tr>
</tbody>
</table>
<h3 id="实体报文头">实体报文头</h3>
<table>
<thead>
<tr>
<th style="text-align:left">首部字段名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Allow</td>
<td style="text-align:left">资源可支持的 HTTP 方法</td>
</tr>
<tr>
<td style="text-align:left">Content-Encoding</td>
<td style="text-align:left">实体主体使用的编码方式</td>
</tr>
<tr>
<td style="text-align:left">Content-Language</td>
<td style="text-align:left">实体主体的自然语言</td>
</tr>
<tr>
<td style="text-align:left">Content-Length</td>
<td style="text-align:left">实体主体的大小（单位：字节）</td>
</tr>
<tr>
<td style="text-align:left">Content-Location</td>
<td style="text-align:left">替代对应资源的 URI</td>
</tr>
<tr>
<td style="text-align:left">Content-MD5</td>
<td style="text-align:left">实体主体的报文摘要</td>
</tr>
<tr>
<td style="text-align:left">Content-Range</td>
<td style="text-align:left">实体主体的位置范围</td>
</tr>
<tr>
<td style="text-align:left">Content-Type</td>
<td style="text-align:left">实体主体的媒体类型</td>
</tr>
<tr>
<td style="text-align:left">Expires</td>
<td style="text-align:left">实体主体过期的日期时间</td>
</tr>
<tr>
<td style="text-align:left">Last-Modified</td>
<td style="text-align:left">资源的最后修改日期时间</td>
</tr>
</tbody>
</table>
<h2 id="accept">ACCEPT</h2>
<ul>
<li>作用：<strong>浏览器端可以接受的媒体类型</strong></li>
</ul>
<p>Accept:<strong>text/html</strong> 代表浏览器可以接受服务器回发的类型为 text/html 也就是我们常说的 html 文档，如果服务器无法返回 text/html 类型的数据，服务器应该返回一个406错误（Non Acceptable）</p>
<p>如果想要给显示的媒体类型增加优先级，则使用q=来额外表示权重值）；重值 q 的范围是0~1（可精确到小数点后 3 位），且 1 为最大值。不指定权重 q 值时，默认权重为 q=1.0。当服务器提供多种内容时，将会首先返回权重值最高的媒体类型。</p>
<h2 id="accept-encoding">Accept-Encoding</h2>
<ul>
<li>作用：浏览器申明自己接收的<strong>编码方法</strong>，通常指定<strong>压缩</strong>方法，是否支持压缩，支持什么压缩方法（gzip，deflate）
<ul>
<li>Accept-Encoding:gzip，deflate</li>
</ul>
</li>
<li>作用：浏览器申明自己接收的语言
<ul>
<li>Accept-Language:zh-cn, zh; q=0.7, en-us, en; q=0.3</li>
<li>客户端在服务器有中文版资源的情况下，会请求其返回中文版对应的响应，没有中文版时，则请求返回英文版响应</li>
</ul>
</li>
<li><strong>Connection:keep-alive</strong> ：当一个网页打开完成后，客户端和服务器之间<strong>用于传输HTTP数据的TCP连接不会关闭</strong>，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。</li>
<li>Connection:close 代表<strong>一个Request</strong>完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭，当客户端再次发送Request，需要重新建立TCP连接</li>
</ul>
<h2 id="host">Host</h2>
<ul>
<li>作用：请求报头域主要用于指定被请求资源的 <strong>Internet主机和端口号</strong>，它通常从HTTP URL中提取出来的</li>
</ul>
<p>我们在浏览器中输入：http://www.fljf.com:8080 刘览器发送的请求消息中，就会包含Host请求报头域，如下：Host：www.fljf.com:8080</p>
<h2 id="referer">Referer</h2>
<p>当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理</p>
<h2 id="user-agent">User-Agent</h2>
<ul>
<li>作用：告诉HTTP服务器，客户端使用的操作系统和浏览器的名称和版本</li>
<li>很多情况下我们会通过User-Agnet来判断浏览器类型，从而进行不同的兼容设计</li>
</ul>
<h2 id="content-type">Content-Type</h2>
<ul>
<li>作用：说明了报文体内对象的媒体类型</li>
</ul>
<p>text/html：HTML格式</p>
<p>text/plain：纯文本格式</p>
<p>text/xml：XML格式</p>
<p>image/gif：gif图片格式</p>
<p>image/jpeg：jpg图片格式</p>
<p>image/png：png图片格式</p>
<p>application/xhtml+xml：XHTML格式</p>
<p>application/xml：XML数据格式</p>
<p>application/atom+xml：Atom XML聚合格式</p>
<p>application/json：JSON数据格式</p>
<p>application/pdf：pdf格式</p>
<p>application/msword：Word文档格式</p>
<p>application/octet-stream：二进制流数据（如常见的文件下载）</p>
<p>application/x-www-form-urlencoded：表单提交</p>
<h1 id="http-报文结构分析-响应报文">HTTP 报文结构分析 - 响应报文</h1>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.png" alt="图片" loading="lazy"></figure>
<h1 id="http-请求方法剖析">HTTP 请求方法剖析</h1>
<p>HTTP/1.1常用方法</p>
<p>①GET</p>
<p>② POST</p>
<p>③ PUT</p>
<p>④HEAD</p>
<p>⑤ DELETE</p>
<p>⑥OPTIONS</p>
<p>⑦TRACE</p>
<p>③ CONNECT</p>
<h2 id="get-获取资源">GET 获取资源</h2>
<ul>
<li>GET方法用来请求访问已被URI识别的资源</li>
<li>指定的资源经服务器端解析后返回响应内容</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/GET%E8%AF%B7%E6%B1%82.png" alt="图片" loading="lazy"></figure>
<ul>
<li>GET方法也可以用来提交表单和其他数据</li>
<li>http://localhost/login.php?username=aa&amp;password=1234 从上面的 URL 请求中，很容易就可以辩认出表单提交的内容</li>
</ul>
<h2 id="post">POST</h2>
<ul>
<li>POST 方法与 GET 功能类似，一般用来<strong>传输实体的主体</strong></li>
<li>POST 方法的主要目的不是获取响应主体的内容</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/POST%E8%AF%B7%E6%B1%82.png" alt="图片" loading="lazy"></figure>
<h3 id="说下-get-和-post-的区别">说下 GET 和 POST 的区别？</h3>
<p>GET 和 POST 本质都是 HTTP 请求，只不过对它们的作用做了界定和适配，并且让他们适应各自的场景。</p>
<ul>
<li>本质区别：GET 只是一次 HTTP请求，POST 先发请求头再发请求体，实际上是两次请求。</li>
<li>从功能上讲，GET 一般用来<strong>从服务器上获取资源</strong>，POST 一般用来<strong>更新服务器上的资源</strong>；</li>
<li>从 REST 服务角度上说，<strong>GET 是幂等</strong>的，即读取同一个资源，总是得到相同的数据，而 <strong>POST 不是幂等</strong>的，因为每次请求对资源的改变并不是相同的；进一步地，GET 不会改变服务器上的资源，而 POST 会对服务器资源进行改变；</li>
<li>从请求参数形式上看，<strong>GET 请求的数据会附在 URL 之后</strong>，即将请求数据放置在 HTTP 报文的 请求头 中，以 ? 分割 URL 和传输数据，参数之间以 &amp; 相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用 BASE64 加密，得出如：%E4%BD%A0%E5%A5%BD，其中 ％XX 中的 XX 为该符号以 16 进制表示的 ASCII)；而 **POST 请求会把提交的数据则放置在是 HTTP 请求报文的 **<strong>请求体</strong> 中；</li>
<li>就安全性而言，<strong>POST 的安全性要比 GET 的安全性高</strong>，因为 GET 请求提交的数据将明文出现在 URL 上，而且 POST 请求参数则被包装到请求体中，相对更安全；</li>
<li>从请求的大小看，GET 请求的长度受限于浏览器或服务器对 URL 长度的限制，允许发送的数据量比较小，而 POST 请求则是没有大小限制的。</li>
</ul>
<h2 id="put">PUT</h2>
<ul>
<li>从客户端向服务器传送的数据<strong>取代指定的文档的内容</strong></li>
<li>PUT方法与POST方法最大的不同是：PUT是幂等的，而POST是不幂等的</li>
<li>因此，我们更多时候将PUT方法用作传输资源</li>
</ul>
<blockquote>
<p>创建对象用 POST，更新对象用 PUT。<br>
但是，HTTP1.1 的 PUT 方法不带有验证机制，存在一定的安全问题，所以一般不使用 PUT，更新对象可以使用 POST 请求，然后在后端代码逻辑处理。</p>
</blockquote>
<h2 id="headdelete">HEAD/DELETE</h2>
<ul>
<li>HEAD类似于GET请求，只不过返回的响应中没有具体的内容，用于<strong>获取报头</strong>。</li>
<li>DELETE请求服务器删除指定的资源。</li>
</ul>
<blockquote>
<p>DELETE 方法没有验证机制，所以一般不使用。</p>
</blockquote>
<h2 id="options">OPTIONS</h2>
<p>用来查询针对请求URI指定的资源支持的方法</p>
<blockquote>
<p>不知道对方支持什么方法，询问一下。</p>
</blockquote>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/OPTIONS%E8%AF%B7%E6%B1%82.png" alt="图片" loading="lazy"></figure>
<h2 id="traceconnect">TRACE/CONNECT</h2>
<ul>
<li>TRACE：回显服务器收到的请求，主要用于测试或诊断</li>
</ul>
<blockquote>
<p>容易引发 XSP 攻击，所以一般不使用 TRACE 请求</p>
</blockquote>
<ul>
<li>CONNECT：开启一个客户端与所请求资源之间的双向沟通的通道，它可以用来创建隧道</li>
</ul>
<blockquote>
<p>代理服务器访问互联网时，就是用 CONNECT 方法。<br>
浏览器向代理服务器发送 CONNECT 请求，代理服务器返回状态码 200，浏览器就和服务器三次握手交换数据，代理服务器只负责传输彼此的数据包，并不能读取数据内容。</p>
</blockquote>
<h1 id="状态码">状态码</h1>
<p>是用以表示网页服务器超文本传输协议响应状态的3位数字代码。</p>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/%E7%8A%B6%E6%80%81%E7%A0%81.png" alt="图片" loading="lazy"></figure>
<h2 id="http-状态码详解">HTTP 状态码详解</h2>
<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1XX</td>
<td style="text-align:left">表示消息。这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。</td>
</tr>
<tr>
<td style="text-align:left">2XX</td>
<td style="text-align:left">表示<strong>成功</strong>。这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。</td>
</tr>
<tr>
<td style="text-align:left">3XX</td>
<td style="text-align:left">表示<strong>重定向</strong>。这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。</td>
</tr>
<tr>
<td style="text-align:left">4XX</td>
<td style="text-align:left">表示<strong>请求错误</strong>。这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。</td>
</tr>
<tr>
<td style="text-align:left">5XX</td>
<td style="text-align:left">表示<strong>服务器错误</strong>。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。</td>
</tr>
</tbody>
</table>
<h3 id="常用http状态码">常用HTTP状态码</h3>
<p>2XX 状态码：</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">状态码英文名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">200</td>
<td style="text-align:left">OK</td>
<td style="text-align:left">请求已成功，请求所希望的响应头或数据体将随此响应返回</td>
</tr>
<tr>
<td style="text-align:left">202</td>
<td style="text-align:left">Accepted</td>
<td style="text-align:left">已接受，已经接受请求，但未处理完成</td>
</tr>
<tr>
<td style="text-align:left">206</td>
<td style="text-align:left">Partial Content</td>
<td style="text-align:left">部分内容，服务器成功处理了部分GET请求</td>
</tr>
</tbody>
</table>
<p>3XX 状态码：</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">状态码英文名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">301</td>
<td style="text-align:left">Moved Permanently</td>
<td style="text-align:left"><strong>永久移动</strong>，请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替（<strong>更换域名</strong>）</td>
</tr>
<tr>
<td style="text-align:left">302</td>
<td style="text-align:left">Found</td>
<td style="text-align:left">临时移动，与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
</tbody>
</table>
<p>4XX 状态码：</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">状态码英文名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left">Bad Request</td>
<td style="text-align:left">客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td style="text-align:left">401</td>
<td style="text-align:left">Unauthorized</td>
<td style="text-align:left">请求要求用户的身份认证</td>
</tr>
<tr>
<td style="text-align:left">403</td>
<td style="text-align:left">Forbidden</td>
<td style="text-align:left">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td style="text-align:left">404</td>
<td style="text-align:left">Not Found</td>
<td style="text-align:left">服务器无法根据客户端的请求找到资源（网页）。</td>
</tr>
</tbody>
</table>
<p>5XX 状态码：</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">状态码英文名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left">Internal Server Error</td>
<td style="text-align:left">服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td style="text-align:left">502</td>
<td style="text-align:left">Bad Gateway</td>
<td style="text-align:left">充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</td>
</tr>
</tbody>
</table>
<h1 id="http状态管理cookie与session">HTTP状态管理：Cookie与Session</h1>
<p>HTTP 是无状态协议，每个请求都是独立的，如果后续处理需要前面的信息，必须重传，就会导致连接传送的数据量增大，于是引入 Cookie 和 Session 保存 HTTP 连接状态。</p>
<h2 id="cookie">Cookie</h2>
<ul>
<li>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就向客户端浏览器颁发一个Cookie。</li>
<li><strong>客户端浏览器</strong>会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态<br>
<img src="https://epitomm.github.io/post-images/cookie.png" alt="图片" loading="lazy"></li>
</ul>
<blockquote>
<p>在浏览器地址栏输入 www.baidu.com ，浏览器向百度服务器发送读取网页的请求，并且把结果显示回显示器上。<br>
发送之前，这个网页在本机电脑上寻找百度网站设置的 cookie 文件，如果找到，浏览器会把 cookie 文件中的数据连同 url 一同发送给百度服务器，服务器收到数据，就会在它的数据库中检索 id、搜索记录等信息，并且记录下这次新的内容，增加到数据库和 cookie 文件中。如果没有检测到 cookie，或者 cookie 信息与数据库信息不符合，说明这是第一次浏览这个网站，服务器就会创建一个新的 id，并且保存到数据库，并给浏览器下发一个 cookie，这样下一次访问就会像前面描述的那样查到 cookie 记录了。</p>
</blockquote>
<h2 id="cookie-工作原理">Cookie 工作原理</h2>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/cookie%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="图片" loading="lazy"></figure>
<p>1.浏览器发送请求到服务器</p>
<p>2.如果是第一次访问这个服务器，服务器 set-cookie</p>
<p>3.服务器通过 set-cookie 这样的一个响应头把 cookie 发送给客户端</p>
<p>4.客户端读取到 set-cookie 之后，把 cookie 存储到本地的文本文件中</p>
<p>5.再次发送请求，会把 cookie 一起发送到服务器端</p>
<p>6.服务器接收到这个 cookie，检查 cookie，证明没问题，确实是我已经存在的用户了，返回响应结果。</p>
<h2 id="session">Session</h2>
<ul>
<li>Session是另一种记录客户状态的机制，保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上</li>
<li>客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了</li>
</ul>
<p>##Session 工作原理<br>
<img src="https://epitomm.github.io/post-images/session%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="图片" loading="lazy"></p>
<blockquote>
<p>用户访问一个服务器，如果服务器启用 session，服务器就要为这个用户创建一个 session，在创建这个 session 的时候，服务器首先检查这个用户发来的请求里，是否包含一个 sessionID，如果包含了，就说明这个用户此前已经登陆过，并且已经创建过 session，就按照这个 sessionID 把 session 从服务器的内存中查找出来。如果查找不到或客户端请求就不包含这个 sessionID，就为这个客户端创建一个新的 session，并且生成一个与此 session 相关的 sessionID，这个 sessionID 在服务端是唯一的，这个 sessionID会在这一次响应中返回到客户端进行保存，保存这个 sessionID 的正是 cookie。</p>
</blockquote>
<h2 id="保存session-id的方式">保存Session ID的方式</h2>
<ul>
<li>Cookie</li>
<li>URL重写：
<ul>
<li>https://.../xxx?sessionID=BpRZx3lQx33ccEoU6QZcEb64（参数）</li>
<li>https://.../xxx;SessionID=BpRZx3lQx33ccEoU6QZcEb64（路径附加信息）</li>
</ul>
</li>
<li>隐藏表单</li>
</ul>
<h2 id="session的有效期">Session的有效期</h2>
<ul>
<li>Session超时失效
<ul>
<li>服务器空间有限，设置 session 有效时间，防止更多的用户访问造成服务器内存溢出</li>
</ul>
</li>
<li>程序调用HttpSession.invalidate()
<ul>
<li>点击退出，手动调用 session 失效方法</li>
</ul>
</li>
<li>服务器进程被停止</li>
<li>Cokie 与 Session理存放位置不同
<ul>
<li>Cookie 保存在客户端</li>
<li>Session 保存在服务端</li>
</ul>
</li>
<li>安全性（隐私策略）的不同
<ul>
<li>Cookie 存储在浏览器，对客户端可见，客户端的程序可修改 Cookie 中的内容</li>
<li>Session 存储在服务器端，对客户端来说是透明的，不存在敏感信息泄露的风险</li>
</ul>
</li>
<li>有效期的不同
<ul>
<li>设置 Cookie 的过期时间为很大的数字，Cookie 就可以在浏览器保存很长时间</li>
<li>服务器端会定时清理超时的 sessionID，避免出现过大的压力</li>
<li>session 依赖名为 sessionID 这样类似的 cookie，而 cookie 的 sessionID 过期时间默许是 -1，所以只要关闭了浏览器，也就是<strong>一次会话</strong>结束，这个 session 就失效了。</li>
</ul>
</li>
<li>对服务器压力的不同
<ul>
<li>session 保管在服务器端，每个用户都保存一个 session，耗费大量内存。</li>
<li>cookie 保存在客户端，不太占用服务器的资源。</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode876. 链表的中间结点]]></title>
        <id>https://epitomm.github.io/post/leetcode876-lian-biao-de-zhong-jian-jie-dian/</id>
        <link href="https://epitomm.github.io/post/leetcode876-lian-biao-de-zhong-jian-jie-dian/">
        </link>
        <updated>2020-04-23T02:57:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个带有头结点 head 的非空单链表，返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<h2 id="示例">示例</h2>
<p>示例 1：</p>
<p>输入：[1,2,3,4,5]<br>
输出：此列表中的结点 3 (序列化形式：[3,4,5])<br>
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。<br>
注意，我们返回了一个 ListNode 类型的对象 ans，这样：<br>
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.</p>
<p>示例 2：</p>
<p>输入：[1,2,3,4,5,6]<br>
输出：此列表中的结点 4 (序列化形式：[4,5,6])<br>
由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</p>
<p>提示：</p>
<p>给定链表的结点数介于 1 和 100 之间。</p>
<h2 id="方法一遍历两次链表">方法一：遍历两次链表</h2>
<h3 id="问题分析">问题分析</h3>
<ul>
<li>
<p>遍历链表，记录下链表长度 length。</p>
</li>
<li>
<p>再遍历链表返回第 length/2 个节点。</p>
</li>
</ul>
<h3 id="复杂度分析">复杂度分析</h3>
<ul>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
</ul>
<p>链表节点数为奇数个时：</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9.png" alt="图片" loading="lazy"></figure>
<p>链表节点数为偶数个时：</p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B92.png" alt="图片" loading="lazy"></figure>
<h3 id="代码">代码</h3>
<pre><code>public class AlgoCasts {
  public class ListNode {
    int val;
    ListNode next;
    ListNode(int x) {
      val = x;
    }
  }
  // Time: O(n), Space: O(1)
  public ListNode getMiddleNodeTwoPass(ListNode head) {
    ListNode p = head;
    int len = 0;
    for (; p != null; p = p.next) ++len;
    p = head;
    for (int i = 0; i &lt; len/2; ++i) p = p.next;
    return p;
  }
}
</code></pre>
<h2 id="方法二快慢指针">方法二：快慢指针</h2>
<h3 id="问题分析-2">问题分析</h3>
<p>快指针一次走两步，慢指针一次走一步，<strong>当快指针遍历完链表时，慢指针正好指向中间节点</strong>。</p>
<h3 id="复杂度分析-2">复杂度分析</h3>
<ul>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
</ul>
<pre><code>while(fast != nul &amp;&amp; fast.next != null){
  fast = fast.next.next; // 快指针移动两步
  slow = slow.next; // 慢指针移动一步
}  
</code></pre>
<p>链表节点数为奇数个时：<br>
<img src="https://epitomm.github.io/post-images/%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9_%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%881.png" alt="图片" loading="lazy"></p>
<p>链表节点数为偶数个时：<br>
<img src="https://epitomm.github.io/post-images/%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9_%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%882.png" alt="图片" loading="lazy"></p>
<h3 id="代码-2">代码</h3>
<pre><code>public class AlgoCasts {
  public class ListNode {
    int val;
    ListNode next;
    ListNode(int x) {
      val = x;
    }
  }
  // Time: O(n), Space: O(1)
  public ListNode getMiddleNodeOnePass(ListNode head) {
    ListNode fast = head, slow = head;
    while (fast != null &amp;&amp; fast.next != null) {
      fast = fast.next.next;
      slow = slow.next;
    }
    return slow;
  }
}
</code></pre>
]]></content>
    </entry>
</feed>