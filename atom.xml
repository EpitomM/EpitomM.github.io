<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://epitomm.github.io</id>
    <title>SSM</title>
    <updated>2020-04-24T15:23:32.983Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://epitomm.github.io"/>
    <link rel="self" href="https://epitomm.github.io/atom.xml"/>
    <subtitle>热心善良的老学姐</subtitle>
    <logo>https://epitomm.github.io/images/avatar.png</logo>
    <icon>https://epitomm.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, SSM</rights>
    <entry>
        <title type="html"><![CDATA[JVM 垃圾回收]]></title>
        <id>https://epitomm.github.io/post/jvm-la-ji-hui-shou/</id>
        <link href="https://epitomm.github.io/post/jvm-la-ji-hui-shou/">
        </link>
        <updated>2020-04-24T14:54:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-如何判断对象可以回收">一、如何判断对象可以回收</h1>
<h2 id="11-引用计数法"><strong>1.1 引用计数法</strong></h2>
<p>如果一个对象被其他变量引用，计数器 +1，如果某个变量不再引用，计数器 -1。如果一个对象的<strong>引用次数为 0</strong>，就可以被回收。</p>
<h3 id="循环引用问题">循环引用问题</h3>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png" alt="图片" loading="lazy"></figure>
<p>A 对象引用 B 对象，B 对象的引用计数 = 1；B 对象引用了 A 对象，A 对象的引用计数 = 1，但是没有其他对象在引用它们两个，它们本应被回收，却因彼此循环引用，计数器不为 0 ，不能被回收，造成内存泄露。</p>
<h2 id="12-可达性分析算法">**1.2 可达性分析算法 **</h2>
<ul>
<li>Java 虚拟机中的垃圾回收器采用<strong>可达性分析</strong>来探索所有存活的对象</li>
<li>扫描<strong>堆</strong>中的对象，看是否能够沿着 **GC Root对象 **<strong>为起点的引用链找到该对象</strong>，找不到，表示可以回收</li>
<li>哪些对象可以作为 GC Root ?
<ul>
<li>虚拟机栈中局部变量引用的对象</li>
<li>本地方法栈中 JNI 中引用的对象</li>
<li>方法去区静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
</ul>
</li>
</ul>
<h2 id="13-四种引用">**1.3 四种引用 **</h2>
<ol>
<li>强引用</li>
</ol>
<blockquote>
<p>一个对象通过等号赋值运算符赋值给变量，如：List<String> list = new ArrayList&lt;&gt;();<br>
变量 list 强引用了对象 ArrayList。只要沿着 GC Root 能够找到这个对象，这个对象就不会被垃圾回收。</p>
</blockquote>
<ul>
<li>只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E5%BC%BA%E5%BC%95%E7%94%A8.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E5%BC%BA%E5%BC%95%E7%94%A82.png" alt="图片" loading="lazy"></figure>
<ol start="2">
<li>软引用（SoftReference）</li>
</ol>
<ul>
<li>仅有软引用引用该对象时，在<strong>垃圾回收后，内存仍不足</strong>时会再次触发垃圾回收，回收软引用对象</li>
<li>可以配合<strong>引用队列</strong>来释放软引用自身</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E8%BD%AF%E5%BC%95%E7%94%A8.png" alt="图片" loading="lazy"></figure>
<pre><code>package cn.itcast.jvm.t2;

import java.io.IOException;
import java.lang.ref.SoftReference;
import java.util.ArrayList;
import java.util.List;

/**
 * 演示软引用
 * -Xmx20m -XX:+PrintGCDetails -verbose:gc
 */
public class Demo2_3 {
    private static final int _4MB = 4 * 1024 * 1024;
    public static void main(String[] args) throws IOException {
      List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
      for (int i = 0; i &lt; 5; i++) {
          list.add(new byte[_4MB]);// 读取图片放到 list 集合中进行显示，但是图片资源并不属于核心业务资源，如果图片过多，用强引用就会导致溢出。不太重要的资源能不能在内存紧张时把它占用的内存释放掉，以后如果再用到的话再读取一遍呢？采用软引用。
      } 
      System.in.read();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space
	at cn.itcast.jvm.t2.Demo2_3.main(Demo2_3.java:21)
</code></pre>
<pre><code>package cn.itcast.jvm.t2;

import java.io.IOException;
import java.lang.ref.SoftReference;
import java.util.ArrayList;
import java.util.List;

/**
 * 演示软引用
 * -Xmx20m -XX:+PrintGCDetails -verbose:gc
 */
public class Demo2_3 {

    private static final int _4MB = 4 * 1024 * 1024;

    public static void main(String[] args) throws IOException {
        soft();
    }

    public static void soft() {
        // list --&gt; SoftReference --&gt; byte[]
        // list 和 SoftReference 之间是强引用，SoftReference 和 byte[] 之间是软引用
        List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 5; i++) {
            SoftReference&lt;byte[]&gt; ref = new SoftReference&lt;&gt;(new byte[_4MB]);
            System.out.println(ref.get());
            list.add(ref);
            System.out.println(list.size());

        }
        System.out.println(&quot;循环结束：&quot; + list.size());
        for (SoftReference&lt;byte[]&gt; ref : list) {
            System.out.println(ref.get());
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/%E8%BD%AF%E5%BC%95%E7%94%A8GC.png" alt="图片" loading="lazy"></figure>
<p><strong>清理无用的软引用：引用队列</strong></p>
<p>软引用对象被释放后，没必要再保存在 list 中了，希望把<strong>软引用本身做一个清理</strong>，从 list 集合中清理掉。</p>
<pre><code>package cn.itcast.jvm.t2;

import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.SoftReference;
import java.util.ArrayList;
import java.util.List;

/**
 * 演示软引用, 配合引用队列
 */
public class Demo2_4 {
    private static final int _4MB = 4 * 1024 * 1024;

    public static void main(String[] args) {
        List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();

        // 引用队列
        ReferenceQueue&lt;byte[]&gt; queue = new ReferenceQueue&lt;&gt;();
        for (int i = 0; i &lt; 5; i++) {
            // 关联了引用队列， 当软引用所关联的 byte[]被回收时，软引用自己会加入到 queue 中去
            SoftReference&lt;byte[]&gt; ref = new SoftReference&lt;&gt;(new byte[_4MB], queue);
            System.out.println(ref.get());
            list.add(ref);
            System.out.println(list.size());
        }

        // 从队列中获取无用的 软引用对象，并移除
        Reference&lt;? extends byte[]&gt; poll = queue.poll();
        while( poll != null) {
            list.remove(poll);
            poll = queue.poll();
        }

        System.out.println(&quot;===========================&quot;);
        for (SoftReference&lt;byte[]&gt; reference : list) {
            System.out.println(reference.get());
        }

    }
}
</code></pre>
<p>运行结果：值为空的软引用都被从 list 集合中清除了</p>
<pre><code>[B@6d6f6e28
1
[B@135fbaa4
2
[B@45ee12a7
3
[B@330bedb4
4
[B@2503dbd3
5
===========================
[B@2503dbd3
</code></pre>
<ol start="3">
<li>弱引用（WeakReference）</li>
</ol>
<ul>
<li>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</li>
<li>可以配合引用队列来释放弱引用自身</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E5%BC%B1%E5%BC%95%E7%94%A8.png" alt="图片" loading="lazy"></figure>
<p>引用队列：</p>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E5%BC%B1%E5%BC%95%E7%94%A8%E5%BC%95%E7%94%A8%E9%98%9F%E5%88%97.png" alt="图片" loading="lazy"></figure>
<p>当软引用的对象被回收后，软引用自身也是一个对象，如果在创建时给他分配了一个引用队列，那在它<strong>引用的对象被回收</strong>时，软引用就会进入这个<strong>引用队列</strong>。当弱引用的对象被垃圾回收后，弱引用如果被分配了引用队列的话， 弱引用也会进入引用队列。因为软引用、弱引用自身也要占用一定内存，如果要对它俩占用的内存进一步释放，需要使用引用队列来找到它们。</p>
<pre><code>package cn.itcast.jvm.t2;

import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.List;

/**
 * 演示弱引用
 * -Xmx20m -XX:+PrintGCDetails -verbose:gc
 */
public class Demo2_5 {
    private static final int _4MB = 4 * 1024 * 1024;

    public static void main(String[] args) {
        //  list --&gt; WeakReference --&gt; byte[]
        List&lt;WeakReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 10; i++) {
            WeakReference&lt;byte[]&gt; ref = new WeakReference&lt;&gt;(new byte[_4MB]);
            list.add(ref);
            for (WeakReference&lt;byte[]&gt; w : list) {
                System.out.print(w.get()+&quot; &quot;);
            }
            System.out.println();

        }
        System.out.println(&quot;循环结束：&quot; + list.size());
    }
}
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/%E5%BC%B1%E5%BC%95%E7%94%A8GC.png" alt="图片" loading="lazy"></figure>
<p>在<strong>垃圾回收时，会把弱引用所占用的内存释放掉</strong>，弱引用自身占用的内存要释放的话，要结合引用队列来实现。</p>
<ol start="4">
<li>虚引用（PhantomReference）</li>
</ol>
<p>虚引用和终结器引用必须配合引用队列使用。<strong>当创建虚引用和终结器引用时，都会关联一个引用队列。</strong></p>
<ul>
<li>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队， 由 Reference Handler 线程调用虚引用相关方法**释放直接内存 **</li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/%E8%99%9A%E5%BC%95%E7%94%A8.png" alt="图片" loading="lazy"></figure>
<p>创建 ByteBuffer 的实现对象时，会创建一个名为 Cleaner 的<strong>虚引用对象</strong>，ByteBuffer 会分配一块直接内存，并且会把直接内存的地址传递给虚引用对象。将来 ByteBuffer 没有被强引用引用时，ByteBuffer 就会被垃圾回收，但是给他分配的<strong>直接内存并不能被 Java 垃圾回收</strong>管理。</p>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/%E8%99%9A%E5%BC%95%E7%94%A82.png" alt="图片" loading="lazy"></figure>
<p>所以在 ByteBuffer 被回收时，让虚引用对象进入引用队列，虚引用所在的引用队列会由 ReferenceHandler 线程定时到这个引用队列中找看有没有新入队的 Cleaner，如果有，就会调用 Cleaner 中的 clean() 方法，根据前面记录的直接内存的地址调用 Unsafe.freeMemory()，<strong>释放直接内存</strong>。</p>
<ol start="5">
<li>终结器引用（FinalReference）</li>
</ol>
<ul>
<li>无需手动编码，但其内部<strong>配合引用队列使用</strong>，在<strong>垃圾回收</strong>时，<strong>终结器引用入队</strong>（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并<strong>调用它的 finalize 方法</strong>，<strong>第二次 GC 时才能回收被引用对象</strong></li>
</ul>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/%E7%BB%88%E7%BB%93%E5%99%A8%E5%BC%95%E7%94%A8.png" alt="图片" loading="lazy"></figure>
<p>所有的 Java 对象都会继承在 Object 父类，Object 类中有一个 finalize() 终结方法。某个对象<strong>重写了 finalize() 方法</strong>，当没有强引用引用它时，就由虚拟机创建它对应的终结器引用，当这个对象要被垃圾回收时，就会把这个<strong>终结器引用加入引用队列</strong>，再由一个<strong>优先级很低的线程 <strong>（finalize() 迟迟未能被调用，导致对象很久不能被真正回收，所以不推荐使用 finalize() 释放资源）finalizeHandler 线程查看引用队列中是否有终结器引用，如果有，就会根据终结器引用找到那个</strong>要被垃圾回收的对象</strong>，并且<strong>调用它的 finalize()方法</strong>，调用完了，<strong>下一次垃圾回收时就可以把这个对象占用的内存真正回收了</strong>。</p>
<h1 id="二-垃圾回收算法">二、垃圾回收算法</h1>
<h2 id="21-标记清除">**2.1 标记清除 **</h2>
<p>定义： Mark Sweep</p>
<ul>
<li>速度快</li>
<li>会造成内存碎片</li>
</ul>
<h3 id="标记清除流程">标记清除流程</h3>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png" alt="图片" loading="lazy"></figure>
<p><strong>标记</strong>：沿着 GC Root 的引用链去找，扫描整个堆对象的过程中，如果发现某个堆对象确实被引用了，那么这个堆对象是非垃圾对象，如果某个对<strong>象没有任何一个 GC Root 直接或间接引用</strong>它，那么把它<strong>标记为垃圾对象</strong>。</p>
<p><strong>清除</strong>：将被标记为垃圾对象所占用的空间释放掉。这里说的释放不是把这个对象所占用的内存的每个字节清零，只需要把垃<strong>圾对象占用内存的起始、结束地址记录下来，放在一个空闲地址列表</strong>，下次分配新对象时，到空闲地址列表中找是否有一块足够的空间能容纳新对象。</p>
<h3 id="优点"><strong>优点</strong></h3>
<p><strong>速度快</strong>，只需把垃圾对象的起始、结束地址记录下来。</p>
<h3 id="缺点"><strong>缺点</strong></h3>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E5%86%85%E7%A2%8E%E7%89%87.png" alt="图片" loading="lazy"></figure>
<p>易产生<strong>内存碎片</strong>。清除垃圾对象后不会对内存空间进行整理，如果分配了一个较大的对象，比如数组，数组需要一段连续的内存。每个小的空闲空间都不足以容纳下这个较大的新对象，虽然总的空闲空间足够，但由于<strong>不连续</strong>，造成新对象不能被保存。</p>
<h2 id="22-标记整理">2.2 标记整理</h2>
<p>定义：Mark Compact</p>
<ul>
<li>速度慢</li>
<li>没有内存碎片</li>
</ul>
<h3 id="标记整理流程">标记整理流程</h3>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png" alt="图片" loading="lazy"></figure>
<p><strong>标记</strong>：没有任何 GC Root 直接或间接指向的堆对象被标记为垃圾对象。</p>
<p><strong>整理</strong>：避免标记清除时的内存碎片问题，在清理垃圾的过程中，会把可用的对象向前移动，让内存更为<strong>紧凑</strong>，连续的内存空间就更大了。</p>
<h3 id="优点-2">优点</h3>
<p><strong>没有内碎片</strong>。</p>
<h3 id="缺点-2">缺点</h3>
<p>由于整理牵扯到对象的移动，<strong>效率降低</strong>。</p>
<p>对象在整理过程中发生移动，如果有其他局部变量引用了这个被移动的对象，就需要改变这些引用的地址。</p>
<h2 id="23-复制">2.3 复制</h2>
<p>定义：Copy</p>
<ul>
<li>不会有内存碎片</li>
<li>需要占用双倍内存空间</li>
</ul>
<h3 id="复制流程">复制流程</h3>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/%E5%A4%8D%E5%88%B61.png" alt="图片" loading="lazy"></figure>
<p>标记垃圾对象</p>
<figure data-type="image" tabindex="16"><img src="https://epitomm.github.io/post-images/%E5%A4%8D%E5%88%B62.png" alt="图片" loading="lazy"></figure>
<p>复制 FROM 区域的非垃圾对象到 TO 区域</p>
<figure data-type="image" tabindex="17"><img src="https://epitomm.github.io/post-images/%E5%A4%8D%E5%88%B63.png" alt="图片" loading="lazy"></figure>
<p>清空 FROM 区域剩余的垃圾对象后交换 FROM 和 TO 区域</p>
<p>将内存区域划分成两块大小相等的区域，FROM 和 TO（空闲）。</p>
<p><strong>标记</strong>：找到那些不被引用的对象标记为垃圾对象。</p>
<p><strong>复制</strong>：把** FROM 区域上的非垃圾对象复制到 TO 区域<strong>中，复制的过程中完成碎片整理。复制完成后，<strong>FROM 区域</strong>都是垃圾对象，<strong>全部清除</strong>，并且</strong>交换 FROM 和 TO 区域**。</p>
<h3 id="优点-3">优点</h3>
<p><strong>不会产生碎片。</strong></p>
<h3 id="缺点-3"><strong>缺点</strong></h3>
<p><strong>占用双倍内存空间。</strong></p>
<h1 id="三-分代垃圾回收">三、分代垃圾回收</h1>
<p><strong>堆内存划分</strong></p>
<ul>
<li>新生代：用完了就丢弃。<strong>朝生夕死</strong>的对象
<ul>
<li>伊甸园 Eden</li>
<li>幸存区 FROM</li>
<li>幸存区 TO</li>
</ul>
</li>
<li>老年代：长时间使用的对象。<strong>长期存活</strong>的对象</li>
</ul>
<blockquote>
<p>有一栋居民楼，类似 Java 虚拟机中的堆内存，居民楼中每家每户每天要产生一些垃圾，需要保洁工人来处理，如果保洁工人挨家挨户去收垃圾，效率低，所以设立一个垃圾场（新生代），存放生命周期短的垃圾，比如盒饭、包装袋等，都是回收更为频繁的垃圾，保洁工人需要每天打扫了一次。 每家每户里存储的垃圾（老年代），比如用旧的椅子，暂存在家里，将来空间紧张到放不下时，找保洁员清理这些垃圾。</p>
</blockquote>
<figure data-type="image" tabindex="18"><img src="https://epitomm.github.io/post-images/%E5%A0%86%E5%86%85%E5%AD%98%E5%88%92%E5%88%86.png" alt="图片" loading="lazy"></figure>
<ul>
<li>**对象首先分配在伊甸园区域 **</li>
<li>**新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1并且交换 from、to **</li>
<li>**minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行 **
<ul>
<li>对象的复制会更改对象地址，如果用户线程仍在运行，就会造成访问原来对象的地址找不到。</li>
</ul>
</li>
<li>**当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（对象头中占用 4bit：1111B） **</li>
<li><strong>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时间更长，如果之后空间仍不足，就会内存溢出。</strong></li>
</ul>
<h2 id="31-分代垃圾回收机制原理">3.1 分代垃圾回收机制原理</h2>
<figure data-type="image" tabindex="19"><img src="https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_1.png" alt="图片" loading="lazy"></figure>
<p>当伊甸园被占满时要添加新对象，触发 minor gc</p>
<figure data-type="image" tabindex="20"><img src="https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_2.png" alt="图片" loading="lazy"></figure>
<p>将伊甸园区的对象进行标记后，非垃圾对象复制到幸存区 TO，并且将这些非垃圾对象的寿命 +1，清空伊甸园内剩余的垃圾对象</p>
<figure data-type="image" tabindex="21"><img src="https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_3.png" alt="图片" loading="lazy"></figure>
<p>交换 FROM 和 TO</p>
<p>创建一个新对象，存放到<strong>伊甸园</strong>，当伊甸园被占满时，触发** minor gc**，先对伊甸园区域内的对象进行<strong>标记</strong>，标记结束后，采用<strong>复制算法</strong>，将非垃圾对象<strong>复制</strong>到幸存区 TO，并让这些对象的寿命+1，伊甸园剩余的垃圾对象回收掉，**交换 **FROM 和 TO，第一次 minor gc 结束。</p>
<figure data-type="image" tabindex="22"><img src="https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_4.png" alt="图片" loading="lazy"></figure>
<p>将伊甸园和幸存区 FROM 中的非垃圾对象复制到幸存区 TO，并将这些对象的寿命 +1，清空伊甸园和幸存区 FROM 中的非垃圾对象，交换 FROM 和 TO。将新对象放入伊甸园。</p>
<p>继续创建对象向伊甸园添加，伊甸园再次被填满，再次触发 minor gc，除了要将伊甸园中的非垃圾对象找到以外，还要把**幸存区 FROM **中的非垃圾对象找到，将非垃圾对象复制到幸存区 TO，并让这些对象的寿命 +1，伊甸园和幸存区 FROM 的垃圾对象清除，交换 FROM 和 TO，第二次 minor gc 结束。</p>
<figure data-type="image" tabindex="23"><img src="https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_5.png" alt="图片" loading="lazy"></figure>
<p>当幸存区对象的寿命 = 15时，将此对对象移动到老年代。</p>
<figure data-type="image" tabindex="24"><img src="https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_6.png" alt="图片" loading="lazy"></figure>
<p>当老年代空间不足，触发 FULL GC，对整个堆进行清理。</p>
<h2 id="32-相关-vm-参数">3.2 相关 VM 参数</h2>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>含义</strong></th>
<th style="text-align:left"><strong>参数</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">堆初始大小</td>
<td style="text-align:left">-Xms</td>
</tr>
<tr>
<td style="text-align:left">堆最大大小</td>
<td style="text-align:left">-Xmx 或 -XX:MaxHeapSize=size</td>
</tr>
<tr>
<td style="text-align:left">新生代大小</td>
<td style="text-align:left">-Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )</td>
</tr>
<tr>
<td style="text-align:left">幸存区比例（动态）</td>
<td style="text-align:left">-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</td>
</tr>
<tr>
<td style="text-align:left">幸存区比例</td>
<td style="text-align:left">-XX:SurvivorRatio=ratio</td>
</tr>
<tr>
<td style="text-align:left">晋升阈值</td>
<td style="text-align:left">-XX:MaxTenuringThreshold=threshold</td>
</tr>
<tr>
<td style="text-align:left">晋升详情</td>
<td style="text-align:left">-XX:+PrintTenuringDistribution</td>
</tr>
<tr>
<td style="text-align:left">GC详情</td>
<td style="text-align:left">-XX:+PrintGCDetails -verbose:gc</td>
</tr>
<tr>
<td style="text-align:left">FullGC 前 MinorGC</td>
<td style="text-align:left">-XX:+ScavengeBeforeFullGC</td>
</tr>
</tbody>
</table>
<ol>
<li>没有运行任何代码时，虚拟机参数 -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc 的堆内存占用情况</li>
</ol>
<pre><code>public class Demo2_1 {
    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc
    // -Xms20M：初始堆空间20M；
    // -Xmx20M：最大堆空间20M；
    // -Xmn10M：新生代10M；
    // -XX:+UseSerialGC：垃圾回收器，幸存区比例不会动态调整
    // -XX:+PrintGCDetails -verbose:gc：打印 gc 详情
    public static void main(String[] args) throws InterruptedException {


    }
</code></pre>
<figure data-type="image" tabindex="25"><img src="https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B0.png" alt="图片" loading="lazy"></figure>
<p>2.Eden 区域不足时，触发 minor gc 时的堆内存占用</p>
<pre><code>package cn.itcast.vm.t2;
import java.util.ArrayList;
public class Demo2_1 {
    private static final int _7MB = 7 * 1024 * 1024;

    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC
    public static void main(String[] args) throws InterruptedException {
        ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
        list.add(new byte[_7MB]);
    }
}
</code></pre>
<p>因为 Eden 共 8M，类加载时创建一些对象占用了 29% 的空间，大概剩余 6M 空间，创建一个 7M 的对象，加入 Eden，Eden 内存不足，会触发垃圾回收。<br>
<img src="https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B02.png" alt="图片" loading="lazy"></p>
<pre><code>package cn.itcast.jvm.t2;

import java.util.ArrayList;

/**
 *  演示内存的分配策略
 */
public class Demo2_1 {
    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * 1024 * 1024;
    private static final int _7MB = 7 * 1024 * 1024;
    private static final int _8MB = 8 * 1024 * 1024;

    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC
    public static void main(String[] args) throws InterruptedException {
        ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
        list.add(new byte[_7MB]);
        list.add(new byte[_512KB]);
    }
</code></pre>
<p>}</p>
<figure data-type="image" tabindex="26"><img src="https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B03.png" alt="图片" loading="lazy"></figure>
<ol start="3">
<li>新生代区域内存不足创建对象，放入老年代</li>
</ol>
<pre><code>package cn.itcast.jvm.t2;

import java.util.ArrayList;

/**
 *  演示内存的分配策略
 */
public class Demo2_1 {
    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * 1024 * 1024;
    private static final int _7MB = 7 * 1024 * 1024;
    private static final int _8MB = 8 * 1024 * 1024;

    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC
    public static void main(String[] args) throws InterruptedException {
        ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
        list.add(new byte[_7MB]);
        list.add(new byte[_512KB]);
        list.add(new byte[_512KB]);
    }
}
</code></pre>
<figure data-type="image" tabindex="27"><img src="https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B04.png" alt="图片" loading="lazy"></figure>
<ol start="4">
<li>添加的对象比新生代总内存大，直接放入老年代且不触发 GC。</li>
</ol>
<pre><code>package cn.itcast.jvm.t2;
import java.util.ArrayList;
public class Demo2_1 {
    private static final int _8MB = 8 * 1024 * 1024;
    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC
    public static void main(String[] args) throws InterruptedException {
        ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
        list.add(new byte[_8MB]);
    }
}
</code></pre>
<figure data-type="image" tabindex="28"><img src="https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B05.png" alt="图片" loading="lazy"></figure>
<ol start="5">
<li>内存溢出</li>
</ol>
<pre><code>package cn.itcast.jvm.t2;

import java.util.ArrayList;

/**
 *  演示内存的分配策略
 */
public class Demo2_1 {
    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * 1024 * 1024;
    private static final int _7MB = 7 * 1024 * 1024;
    private static final int _8MB = 8 * 1024 * 1024;

    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC
    public static void main(String[] args) throws InterruptedException {
        ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
        list.add(new byte[_8MB]);
        list.add(new byte[_8MB]);
    }
}
</code></pre>
<figure data-type="image" tabindex="29"><img src="https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B06.png" alt="图片" loading="lazy"></figure>
<ol start="6">
<li>当内存溢出发生在子线程中，是否会导致 java 进程结束？</li>
</ol>
<pre><code>package cn.itcast.jvm.t2;

import java.util.ArrayList;

/**
 *  演示内存的分配策略
 */
public class Demo2_1 {
    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * 1024 * 1024;
    private static final int _7MB = 7 * 1024 * 1024;
    private static final int _8MB = 8 * 1024 * 1024;

    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails 
    public static void main(String[] args) throws InterruptedException {
        new Thread(() -&gt; {
            ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
            list.add(new byte[_8MB]);
            list.add(new byte[_8MB]);

        }).start();

        System.out.println(&quot;sleep....&quot;);
        Thread.sleep(1000L);  
    }
}
</code></pre>
<figure data-type="image" tabindex="30"><img src="https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B07.png" alt="图片" loading="lazy"></figure>
<h1 id="四-垃圾回收器">四、垃圾回收器</h1>
<ol>
<li>串行</li>
</ol>
<ul>
<li>单线程</li>
<li>堆内存较小，适合个人电脑</li>
</ul>
<ol start="2">
<li>吞吐量优先</li>
</ol>
<ul>
<li>多线程</li>
<li>堆内存较大，多核 cpu</li>
<li>让单位时间内，STW 的时间最短。两次垃圾回收：0.2+0.2 = 0.4，<strong>垃圾回收时间占比最低，这样就称吞吐量高</strong></li>
</ul>
<ol start="3">
<li>响应时间优先</li>
</ol>
<ul>
<li>多线程</li>
<li>堆内存较大，多核 cpu</li>
<li>尽可能让**单次 STW 的时间最短。**五次垃圾回收：0.1+0.1+0.1+0.1+0.1 = 0.5</li>
</ul>
<h2 id="41-串行">4.1 串行</h2>
<pre><code>-XX:+UseSerialGC = Serial + SerialOld 
</code></pre>
<p>Serial：工作在<strong>新生代</strong>。<strong>复制</strong>算法<br>
SerialOld：工作在<strong>老年代</strong>。<strong>标记整理</strong>算法</p>
<figure data-type="image" tabindex="31"><img src="https://epitomm.github.io/post-images/%E4%B8%B2%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="图片" loading="lazy"></figure>
<p>四个 CPU 在运行，某时刻堆内存不足，触发垃圾回收。触发垃圾回收时，需要让这些线程到达一个<strong>安全点</strong>再停下，因为在垃圾回收的过程中，可能对象的地址发生改变，为了保证安全地使用这些对象地址，需要所有正在工作的用户线程到达这个安全点在停下。因为 Serial、SerialOld 都是<strong>单线程</strong>的垃圾回收器，因此在一个垃圾回收线程运行时，其他的用户线程都要<strong>阻塞</strong>，等到垃圾回收线程结束后，其他的用户线程再恢复运行。</p>
<h2 id="42-吞吐量优先">4.2 吞吐量优先</h2>
<pre><code>-XX:+UseParallelGC ~ -XX:+UseParallelOldGC
-XX:+UseAdaptiveSizePolicy
-XX:GCTimeRatio=ratio 
-XX:MaxGCPauseMillis=ms 
-XX:ParallelGCThreads=n 
</code></pre>
<p><strong>-XX:+UseParallelGC ~ -XX:+UseParallelOldGC</strong>：JDK 1.8 默认使用 ParallelGC <strong>并行</strong>的垃圾回收器。UseParallelGC 并行的新生代垃圾回收器，采用<strong>复制</strong>算法；UseParallelOldGC 并行的老年代垃圾回收器，采用<strong>标记整理</strong>算法。吞吐量：CPU 用于运行用户程序的时间与总时间的比值。<br>
<strong>-XX:+UseAdaptiveSizePolicy</strong>：自适应大小调整（新生代：Eden 和 Survival）策略</p>
<p><strong>-XX:GCTimeRatio=ratio</strong>：根据设置目标调整堆的大小以达到期望的目标。吞吐量：垃圾回收时间和总时间占比。1/(1+ratio)。一般堆调大，减少垃圾回收次数。</p>
<p><strong>-XX:MaxGCPauseMillis=ms</strong> ：最大暂停毫秒数（每一次垃圾回收耗时）</p>
<p><strong>-XX:ParallelGCThreads=n <strong>：控制 ParallelGC 运行时的</strong>线程数</strong>。<br>
<img src="https://epitomm.github.io/post-images/%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="图片" loading="lazy"></p>
<p>四个 CPU 在运行，某一时刻内存不足触发垃圾回收，用户线程就会到达安全点然后停下来，垃圾回收器<strong>开启多个线程进行垃圾回收</strong>。垃圾回收线程个数默认和 CPU 核数相关。回收结束后再恢复其他的线程运行。在垃圾回收时，四核 CPU 都去进行垃圾回收了，<strong>CPU 占用率</strong>会一下达到 100%。</p>
<h2 id="43-响应时间优先">4.3 响应时间优先</h2>
<pre><code>-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld 
-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads 
-XX:CMSInitiatingOccupancyFraction=percent 
-XX:+CMSScavengeBeforeRemark
</code></pre>
<p><strong>-XX:+UseConcMarkSweepGC</strong> ：<strong>并发标记清除</strong>。垃圾回收器工作的同时，其他用户线程也能同时进行。垃圾回收线程和用户线程并发执行，都要去抢占 CPU。<strong>-XX:+UseParNewGC</strong>：工作在新生代，复制算法。 **SerialOld **：老年代垃圾回收器由并发退化为单线程 （基于标记整理的老年垃圾回收器）。<br>
<img src="https://epitomm.github.io/post-images/%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="图片" loading="lazy"></p>
<p>多个 CPU 并行执行，老年代内存不足，所有进程到达安全点，执行初始标记，用户线程阻塞，STW；初始标记结束后，用户线程开始运行，停止 STW，与此同时垃圾回收线程并发标记，把剩余的垃圾找出来；并发标记结束后，进行重新标记，这个过程 STW，因为并发标记的过程用户线程可能对垃圾回收做了干扰，所以并发标记结束后还要再做一次重新标记；重新标记结束后，用户线程继续运行，垃圾回收线程并发清理。</p>
<h2 id="44-g1">4.4 G1</h2>
<p>定义：Garbage First</p>
<ul>
<li>2004 论文发布</li>
<li>2009 JDK 6u14 体验</li>
<li>2012 JDK 7u4 官方支持</li>
<li>2017 JDK 9 默认。G1 取代了 CMS</li>
</ul>
<p>适用场景</p>
<ul>
<li>同时注重<strong>吞吐量</strong>（Throughput）和<strong>低延迟</strong>（Low latency），默认的暂停目标是 200 ms</li>
<li>并发的垃圾回收器，和 CMS 一样追求低延迟，可以在用户线程工作的同时垃圾回收线程也并发执行。另外还借鉴了 Paralle：注重吞吐量垃圾回收器的思想，可以进行调整，设置默认暂停目标（-XX:MaxGCPauseMillis）。</li>
<li><strong>超大堆内存</strong>，会<strong>将堆划分为多个大小相等的 Region</strong></li>
</ul>
<p>随着堆内存容量的增大，G1 与 CMS 相比优势更加明显。</p>
<p>将堆划分为多个大小相等的 Region：每个区域都可以独立地作为 Eden、survive、老年代。</p>
<p>-XX:G1HeapRegionSize：设置区域的大小，必须是2的幂。如果堆内存过大，回收速度会变慢，因为会涉及对象的复制标记，而分成小的区域进行管理，可以化整为零，进行一些优化加快标记拷贝的速度。</p>
<ul>
<li>整体上是 <strong>标记+整理</strong> 算法（避免标记清除算法产生的内碎片），两个区域之间是复制算法</li>
</ul>
<p>相关 JVM 参数</p>
<pre><code>-XX:+UseG1GC 
-XX:G1HeapRegionSize=size 
-XX:MaxGCPauseMillis=time
</code></pre>
<figure data-type="image" tabindex="32"><img src="https://epitomm.github.io/post-images/G1_2.png" alt="图片" loading="lazy"></figure>
<h3 id="1-g1-垃圾回收阶段">1) G1 垃圾回收阶段</h3>
<figure data-type="image" tabindex="33"><img src="https://epitomm.github.io/post-images/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%98%B6%E6%AE%B5.png" alt="图片" loading="lazy"></figure>
<p>刚开始新生代垃圾收集，如果某时刻老年代内存超过阈值了，在新生代垃圾收集的同时进行并发标记，这个阶段结束后会进行混合收集：会对新生代、幸存区、老年代都进行收集。混合收集结束，Eden 内存释放掉，会再进入新生代垃圾收集。</p>
<h3 id="2-young-collection">2) Young Collection</h3>
<ul>
<li>会 STW</li>
</ul>
<figure data-type="image" tabindex="34"><img src="https://epitomm.github.io/post-images/G1%E5%88%86%E5%8C%BA.png" alt="图片" loading="lazy"></figure>
<p>G1 垃圾回收器把<strong>堆内存划分成大小相等的一个个区域</strong>，每个区域都可独立作为伊甸园、幸存区、老年代。刚开始白色的区域表示是空闲的区域，类加载时新创建的对象刚开始会分配到伊甸园区，绿色的 E 就代表 Eden 区，当 Eden 区域逐渐被占满，就会触发新生代的垃圾回收。</p>
<figure data-type="image" tabindex="35"><img src="https://epitomm.github.io/post-images/G1%E6%96%B0%E7%94%9F%E4%BB%A3%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="图片" loading="lazy"></figure>
<p>新生代垃圾回收会把非垃圾对象以复制算法放入幸存区。</p>
<figure data-type="image" tabindex="36"><img src="https://epitomm.github.io/post-images/G1%E8%80%81%E5%B9%B4%E4%BB%A3.png" alt="图片" loading="lazy"></figure>
<p>当幸存区对象放不下，或幸存区对象寿命达到一定值，会触发垃圾回收，幸存区一部分对象会晋升到老年代，而寿命未达到阈值的会拷贝到另一个幸存区，新生代的非垃圾对象也会复制到这个幸存区。</p>
<h3 id="3-young-collection-cm">3) Young Collection + CM</h3>
<p>CM：Concurrent mark：并发标记</p>
<p><strong>初始标记</strong>：找到那些根对象，标记根对象。</p>
<p><strong>并发标记</strong>：从根对象出发，顺着引用链找到其他非垃圾对象，标记那些其他非垃圾对象。</p>
<ul>
<li>在 Young GC 时会进行 GC Root 的<strong>初始标记</strong></li>
<li>老年代占用堆空间比例达到阈值时，进行<strong>并发标记</strong>（不会 STW），由下面的 JVM 参数决定</li>
</ul>
<pre><code>-XX:InitialtingHeapOccupancyPercent=percent（默认45%）
</code></pre>
<p>老年代占用堆空间内存达到 45% 时，会进行并发标记。<br>
<img src="https://epitomm.github.io/post-images/G1%E8%80%81%E5%B9%B4%E4%BB%A3%E8%BF%87%E5%A4%9A%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0.png" alt="图片" loading="lazy"></p>
<p>E：Eden</p>
<p>S：Survive</p>
<p>O：Old</p>
<h3 id="4-mixed-collection">4) Mixed Collection</h3>
<p>会对 E、S、O 进行<strong>全面垃圾回收</strong></p>
<ul>
<li>最终标记（Remark）会 STW</li>
<li>拷贝存活（Evacuation）会 STW</li>
</ul>
<p>-XX:MaxGCPauseMillis=ms</p>
<figure data-type="image" tabindex="37"><img src="https://epitomm.github.io/post-images/G1%E5%85%A8%E9%9D%A2%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png" alt="图片" loading="lazy"></figure>
<p>Eden 区域的非垃圾对象被复制到 Survive 区域，Survive 区域寿命未达到阈值的非垃圾对象被复制到另一个 Survive 区域，寿命达到阈值的晋升到老年代区域。一部分老年代区域的幸存对象通过复制算法复制到新的的老年代区域，为什么没有把所有老年代都通过箭头指向新的老年代呢？因为 G1 会根据最大暂停时间有选择地进行回收，有时候堆内存空间太大了，老年代的垃圾回收可能时间比较长（复制算法大量对象的复制），就达不到<strong>最大暂停时间</strong>的目标了，为了达到这个目标，G1 会从老年代中挑<strong>出回收价值最高</strong>的区域（垃圾回收后能释放空间多的区域），只从老年代中挑选一部分区域复制，复制的区域少了，就可以达到暂停时间的目标了。如果老年代没有那么多，可以达到最大暂停时间的话， 就会把所有区域都进行复制。</p>
<h3 id="5-full-gc">5) Full GC</h3>
<ul>
<li>SerialGC：串行
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足发生的垃圾收集 - full gc</li>
</ul>
</li>
<li>ParallelGC：并行
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足发生的垃圾收集 - full gc</li>
</ul>
</li>
<li>CMS
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足
<ul>
<li>并发收集失败后 Full GC</li>
</ul>
</li>
</ul>
</li>
<li>G1
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足
<ul>
<li>有一个阈值，当老年代内存达到阈值，就会触发并发标记、混合收集阶段。如果垃圾回收的速度高于新的用户线程产生垃圾的速度，就处于并发垃圾收集阶段，这阶段还不算 Full GC。</li>
<li>当垃圾回收的速度跟不上垃圾产生的速度，并发收集失败，就会触发串行收集，这阶段叫做 Full GC。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-young-collection-跨代引用">6) Young Collection 跨代引用</h3>
<p>新生代回收的跨代引用（老年代引用新生代）问题</p>
<figure data-type="image" tabindex="38"><img src="https://epitomm.github.io/post-images/Card.png" alt="图片" loading="lazy"></figure>
<p>新生代垃圾回收：找到根对象，沿着引用链找到存活对象，存活对象进行复制到幸存区。要找新生代对象的根对象，<strong>根对象有一部分来自于老年代</strong>，老年代的存活对象非常多，如果遍历老年代找根对象效率低，因此把<strong>老年代区域再进行细分</strong>，分成一个个 Card，每个 Card 是512KB，如果老年代其中有一个** Card 中的对象引用了新生代的某一个对象**，就把这个** Card 标记为脏**，这样以后，做 GC Root 遍历的时候就不用去找整个老年代了，只需要关注那些脏 Card 即可，减少搜索范围，<strong>提高扫描根对象的效率</strong>。</p>
<ul>
<li>卡表与 Remembered Set</li>
<li>在引用变更时通过 post-write barrier + dirty card queue</li>
<li>concurrent refinement threads 更新 Remembered Set</li>
</ul>
<figure data-type="image" tabindex="39"><img src="https://epitomm.github.io/post-images/Card2.png" alt="图片" loading="lazy"></figure>
<p>粉色的 Card 都是<strong>脏卡区</strong>，Card 内有对象指向新生代区域的对象，新生代会记录** Remembered Set：从外部对我的引用**，将来对新生代 Eden 进行垃圾回收时，就可以先通过 Remembered Set 知道它对应的哪些脏 Card，然后在到这些脏卡区遍历对象找到 GC Root。通过** post-write barrier**：写屏障在每次<strong>对象的引用发生变更时，去更新脏 Card</strong>，这个过程是<strong>异步</strong>操作，不会立刻完成脏卡的更新，会把更新指令放在 <strong>dirty card queue 脏卡队列</strong>中，将来由一个线程完成脏卡更新的操作。</p>
<h3 id="7-remark-重标记阶段">7) Remark 重标记阶段</h3>
<ul>
<li>pre-write barrier + satb_mark_queue</li>
</ul>
<p>pre-write barrier：写屏障：在对象引用改变前，将对象加入到 satb_mark_queue</p>
<p>队列，将来 remark 从队列中取出对象进一步判断。</p>
<figure data-type="image" tabindex="40"><img src="https://epitomm.github.io/post-images/%E9%87%8D%E6%A0%87%E8%AE%B0_1.png" alt="图片" loading="lazy"></figure>
<p>并发标记阶段对象的 true 和 false，其中图中<strong>黑色</strong>表示已经处理完成，并且有引用在引用它们，在垃圾回收后会被<strong>保留</strong>下来。<strong>灰色</strong>的是正在<strong>触发中</strong>，灰色的因为有强引用黑色的在指向它，所以最终会变成黑色，<strong>白色</strong>的是<strong>尚未处理</strong>，如果有强引用指向它最后会变成黑色，如果没有引用指向它最终还是白色，会被当成垃圾回收。垃圾回收结束后，会根据对象的黑白状态区分它到底应该存活还是被回收。</p>
<p><img src="https://epitomm.github.io/post-images/%E9%87%8D%E6%A0%87%E8%AE%B0_2.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/%E9%87%8D%E6%A0%87%E8%AE%B0_3.png" alt="图片" loading="lazy"></p>
<p><strong>Remark 流程：</strong><br>
<img src="https://epitomm.github.io/post-images/%E9%87%8D%E6%A0%87%E8%AE%B0_4.png" alt="图片" loading="lazy"></p>
<h3 id="8-jdk-8u20-字符串去重">8) JDK 8u20 字符串去重</h3>
<ul>
<li>优点：节省大量内存</li>
<li>缺点：略微多占用了 cpu 时间，新生代回收时间略微增加</li>
</ul>
<p>-XX:+UseStringDeduplication</p>
<pre><code>String s1 = new String(&quot;hello&quot;); // char[]{'h','e','l','l','o'} 
String s2 = new String(&quot;hello&quot;); // char[]{'h','e','l','l','o'}
</code></pre>
<ul>
<li>将所有新分配的字符串放入一个<strong>队列</strong></li>
<li>当新生代回收时，G1并发检查队列中是否有字符串重复</li>
<li>如果它们值一样，让它们<strong>引用同一个 char[]</strong></li>
<li>注意，与 String.intern() 不一样
<ul>
<li>String.intern() 关注的是<strong>字符串对象</strong></li>
<li>而字符串去重关注的是** char[]**</li>
<li>在 JVM 内部，使用了不同的字符串表</li>
</ul>
</li>
</ul>
<h3 id="9-jdk-8u40-并发标记类卸载">9) JDK 8u40 并发标记类卸载</h3>
<p>所有对象都经过并发标记后，就能知道<strong>哪些类不再被使用</strong>，当一个类加载器的所有类都不再使用，则<strong>卸载它所加载的所有类</strong></p>
<p>-XX:+ClassUnloadingWithConcurrentMark 默认启用</p>
<h3 id="10-jdk-8u60-回收巨型对象">10) JDK 8u60 回收巨型对象</h3>
<figure data-type="image" tabindex="41"><img src="https://epitomm.github.io/post-images/%E5%9B%9E%E6%94%B6%E5%B7%A8%E5%9E%8B%E5%AF%B9%E8%B1%A1.png" alt="图片" loading="lazy"></figure>
<p>Region 区域内粉色的 H 就是巨型对象。</p>
<ul>
<li>一个对象<strong>大于 region 的一半</strong>时，称之为巨型对象</li>
<li>G1 <strong>不会对巨型对象进行拷贝</strong></li>
<li><strong>回收时被优先考虑</strong></li>
<li>G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0 的巨型对象就可以在新生代垃圾回收时处理掉</li>
</ul>
<figure data-type="image" tabindex="42"><img src="https://epitomm.github.io/post-images/%E5%9B%9E%E6%94%B6%E5%B7%A8%E5%9E%8B%E5%AF%B9%E8%B1%A1_2.png" alt="图片" loading="lazy"></figure>
<h3 id="11-jdk-9-并发标记起始时间的调整">11) JDK 9 并发标记起始时间的调整</h3>
<p>如果垃圾回收的速度跟不上垃圾产生的速度，最终会退化为 Full GC。G1 的 Full GC 是多线程的，Full GC 的 STW 过程很长，因此要尽可能避免 Full GC 的发生。如何减少 Full GC 呢？提前让垃圾回收开始，并发标记、混合收集提前开始，就能减少 Full GC 发生的几率。</p>
<ul>
<li>并发标记必须在堆空间占满前完成，否则退化为 FullGC</li>
<li>JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent：老年代在堆内存的占比，当超过设置的这个阈值时，就会触发并发垃圾回收。</li>
<li>JDK 9 可以动态调整
<ul>
<li>-XX:InitiatingHeapOccupancyPercent 用来设置**初始值 **</li>
<li>进行<strong>数据采样</strong>并**动态调整 **</li>
<li>总会添加一个安全的空档空间</li>
</ul>
</li>
</ul>
<h3 id="12-jdk-9-更高效的回收">12) JDK 9 更高效的回收</h3>
<p>250+增强</p>
<p>180+bug修复</p>
<p><a href="https://docs.oracle.com/en/java/javase/12/gctuning">https://docs.oracle.com/en/java/javase/12/gctuning</a></p>
<h1 id="五-垃圾回收调优">五、垃圾回收调优</h1>
<p>预备知识</p>
<ul>
<li>掌握 GC 相关的 VM 参数，会基本的空间调整</li>
<li>掌握相关工具</li>
<li>明白一点：调优跟应用、环境有关，没有放之四海而皆准的法则</li>
</ul>
<p>查看虚拟机运行参数：</p>
<pre><code>&quot;C:\Program Files\Java\jdk1.8.0_172\bin\java&quot; -XX:+PrintFlagsFinal -version | findstr &quot;GC&quot;
</code></pre>
<figure data-type="image" tabindex="43"><img src="https://epitomm.github.io/post-images/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%B0%83%E4%BC%98.png" alt="图片" loading="lazy"></figure>
<h2 id="51-调优领域">5.1 调优领域</h2>
<ul>
<li>内存</li>
<li>锁竞争</li>
<li>cpu 占用</li>
<li>io</li>
</ul>
<h2 id="52-确定目标">5.2 确定目标</h2>
<ul>
<li>【低延迟】还是【高吞吐量】，选择合适的回收器</li>
<li>CMS，G1，ZGC：低延迟</li>
<li>ParallelGC：高吞吐量</li>
<li>Zing</li>
</ul>
<h2 id="53-最快的-gc-是不发生-gc">5.3 最快的 GC 是不发生 GC</h2>
<p>答案是不发生 GC</p>
<ul>
<li>查看 FullGC 前后的内存占用，考虑下面几个问题
<ul>
<li>数据是不是太多？
<ul>
<li>resultSet = statement.executeQuery(&quot;select * from 大表** limit n**&quot;)</li>
</ul>
</li>
<li>数据表示是否太臃肿？
<ul>
<li>对象图</li>
<li>对象大小 16 Integer 24 int 4</li>
</ul>
</li>
<li>是否存在内存泄漏？
<ul>
<li>static Map map 不断向里面放数据</li>
<li>软</li>
<li>弱</li>
<li>第三方缓存实现</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="54-新生代调优">5.4 新生代调优</h2>
<h3 id="新生代的特点">新生代的特点</h3>
<ul>
<li>所有的 new 操作的内存分配非常廉价
<ul>
<li>TLAB thread-local allocation buffer
<ul>
<li>在 Eden 中给<strong>每个线程分配一块私有缓冲区 TLAB</strong>，new 对象时会首先检查 TLAB 缓冲区内是否有空白区域，如果有就优先在 TLAB 这块内存分配。因为线程安全问题，比如线程 1 要用这块内存，分配还没结束时，线程 2 不能也要用这块内存，造成内存分配混乱，  因此在对象的内存分配时，要做线程安全的保护，<strong>减少线程之间对分配时的并发冲突</strong>：TLAB  ：线程局部分配缓冲区。每个线程用自己私有的 Eden 内存来进行内存分配，多个线程即使同时创建对象，也不会产生对内存占用的干扰。</li>
</ul>
</li>
</ul>
</li>
<li>死亡对象的回收代价是零
<ul>
<li>新生代发生垃圾回收时，垃圾回收器复制算法：把 Eden、幸存区 FROM 中的幸存对象都复制到幸存区 TO，Eden、FROM 中的内存就被释放了，因此死亡对象的回收代价是零。</li>
</ul>
</li>
<li>新生代大部分对象用过即死</li>
<li>Minor GC 的时间远远低于 Full GC</li>
</ul>
<h3 id="新生代越大越好吗">新生代越大越好吗？</h3>
<p>-Xmn</p>
<blockquote>
<p>Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery).<br>
GC is performed in this region more often than in other regions. If the size for the young<br>
generation is too small, then a lot of minor garbage collections are performed. If the size is too  large, then only full garbage collections are performed, which can take a long time to complete.<br>
Oracle recommends that you keep the size for the young generation greater than 25% and less than 50% of the overall heap size.</p>
</blockquote>
<p>-Xmn：设置堆中新生代的初始和最大值。<strong>新生代设置小</strong>了，<strong>可用空间少</strong>，创建对象时一旦发现新生代的空间不足就会触发新生代的** minor gc**。如果新<strong>生代内存太大</strong>了，<strong>老年代的可用空间相对少了</strong>，老年代的空间少了，将来新生代觉得我空闲空间很多，新创建的对象都还不会触发垃圾回收，但是老年代的空间紧张，再触发垃圾回收，就是 full gc，<strong>full gc 的暂停时间比 minor gc 时间更长</strong>。<strong>新生代大于堆内存的 1/4 ,小于 1/2 即可</strong>。</p>
<figure data-type="image" tabindex="44"><img src="https://epitomm.github.io/post-images/%E6%96%B0%E7%94%9F%E4%BB%A3-%E5%90%9E%E5%90%90%E9%87%8F.png" alt="图片" loading="lazy"></figure>
<p><strong>吞吐量</strong>：单位时间能响应的请求数量。</p>
<p>随着新生代空间越来越大，吞吐量越来越高，垃圾回收占用整个 CPU 计算的时间比例少了，CPU时间更多用来处理请求了，吞吐量就变高了，但是到了一定的大小后，会有一个下降：<strong>新生代空间大了，意味着回收的时间较长</strong>。</p>
<p><strong>新生代调整尽可能大</strong>，新生代的垃圾回收都是复制算法，复制算法分成：标记、复制两个阶段，复制阶段花费的时间更多，而新<strong>生代的对象，绝大部分都是朝生夕死的，最终只有少量的对象会存活下来，复制所占用的时间也是相对较短的</strong>，而标记时间相对于复制时间来讲，就显得不是很重要了，所以<strong>新生代调大的情况下，主要时间还是耗费在复制上，即使增得很大，效率也不会有很明显的下降</strong>。</p>
<h3 id="新生代的大小设置">新生代的大小设置</h3>
<ul>
<li><strong>新生代能容纳并发量 *  (一次请求-响应过程产生的对象)的数据</strong>
<ul>
<li>并发量 * 请求 - 响应过程中所产生的的对象</li>
<li>如果一次 请求-响应 过程中产生的对象是 512KB，并发量是 1000，那么新生代理想的内存就是 1000* 512KB = 521M。因为一次 请求-响应的过程，在这次 请求-响应 结束后，大多数对象都会被回收，只要这一次 请求-响应 占用的内存不超过新生代的内存，就不会触发新生代的垃圾回收</li>
</ul>
</li>
<li><strong>幸存区大到能保留当前活跃对象+需要晋升对象</strong>
<ul>
<li>幸存区中有两类对象：<strong>①生命周期较短，下一次垃圾回收就把它回收掉了</strong>，但由于现在还在使用，暂时不能回收；**②将来会被晋升到老年代，**但是由于年龄不够，所以暂时存放在幸存区中。</li>
<li><strong>如果幸存区较小，就会由 JVM 动态调整晋升阈值</strong>，也许本来有些对象不应该晋升的，但是由于幸存区内存不够，导致会提前<strong>把本应回收的对象晋升到老年代</strong>。如果存活时间短的对象被晋升到了老年代，需要等到老年代内存不足，触发 Full GC 时才能把它当做垃圾进行回收，延长了对象的生存时间。</li>
</ul>
</li>
<li><strong>晋升阈值配置得当，让长时间存活对象尽快晋升</strong>
<ul>
<li>如果是一个<strong>长期存活的对象</strong>，把它<strong>留到幸存区里</strong>，只会<strong>耗费幸存区的内存</strong>，并且新生代垃圾回收都是复制算法，要把幸存区的存活对象从 FROM 复制到 TO，如果大量长时间存活的对象不能及早晋升，那么就要留在幸存区被<strong>复制来复制去</strong>。调整晋升阈值，让<strong>长时间存活的对象尽快晋升到老年代</strong>。</li>
</ul>
</li>
</ul>
<p>调整最大晋升阈值：</p>
<pre><code>-XX:MaxTenuringThreshold=threshold 
</code></pre>
<p>显示幸存区对象详情：</p>
<pre><code>-XX:+PrintTenuringDistribution 
</code></pre>
<pre><code>Desired survivor size 48286924 bytes, new threshold 10 (max 10) 
- age 1: 28992024 bytes, 28992024 total 
- age 2: 1366864 bytes, 30358888 total 
- age 3: 1425912 bytes, 31784800 total 
...
</code></pre>
<h2 id="55-老年代调优">5.5 老年代调优</h2>
<h3 id="以-cms-为例">以 CMS 为例</h3>
<p>CMS 垃圾回收器：<strong>低响应时间、并发的</strong>（垃圾回收线程在工作的同时其他用户线程也能在并发的执行：垃圾回收的同时其他用户线程也在运行，就会产生新的浮动垃圾，如果浮动垃圾产生导致内存不足，就会造成 CMS 并发失败，CMS 垃圾回收器退化为 串行老年代垃圾回收器：STW）</p>
<ul>
<li>CMS 的<strong>老年代内存越大越好</strong>
<ul>
<li>预留更多空间，避免浮动垃圾引起的并发失败</li>
</ul>
</li>
<li><strong>先尝试不做调优</strong>，如果没有 Full GC 那么已经可以了，否则先尝试调优新生代</li>
<li>观察<strong>发生 Full GC 时老年代内存占用</strong>，将老年代内存预设调大 1/4 ~ 1/3</li>
</ul>
<pre><code>-XX:CMSInitiatingOccupancyFraction=percent
</code></pre>
<p>老年代的空间占用达到老年代的 percent% 时，触发垃圾回收<br>
percent 越小，老年代垃圾回收触发时间越早。</p>
<h2 id="56-案例">5.6 案例</h2>
<h3 id="案例1-full-gc-和-minor-gc频繁空间紧张">案例1 Full GC 和 Minor GC频繁：空间紧张</h3>
<ul>
<li>问题分析：</li>
</ul>
<p>新生代空间紧张：当业务高峰期来了，大量对象被创建，<strong>新生代被填满</strong>，<strong>幸存区空间紧张</strong>了，<strong>晋升对象的阈值就会降低</strong>，导致很多原来<strong>生存周期很短的对象被晋升到老年代</strong>了，老年代存了大量生存周期很短的对象，进一步触发老年代 <strong>Full GC</strong> 发生。</p>
<ul>
<li>问题解决：</li>
</ul>
<p><strong>增大新生代内存</strong>，新生代内存增大了，内存充裕，新生代的垃圾回收不那么频繁了，增大了幸存区的空间以及晋升阈值，生命周期较短的对象尽可能在幸存区被回收，而不要晋升到老年代，减少老年代 Full GC。</p>
<h3 id="案例2-请求高峰期发生-full-gc单次暂停时间特别长-cms">案例2 请求高峰期发生 Full GC，单次暂停时间特别长 （CMS）</h3>
<ul>
<li>问题分析：</li>
</ul>
<p>查看日志，看 CMS 哪个阶段耗费时间长</p>
<figure data-type="image" tabindex="45"><img src="https://epitomm.github.io/post-images/%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="图片" loading="lazy"></figure>
<p>初始标记和并发标记都是比较快的，<strong>重新标记比较慢</strong>， 查看 GC 日志会把每一阶段耗费的时间显示。</p>
<ul>
<li>问题解决：</li>
</ul>
<p>重新标记会扫描整个内存，不光是要扫描老年代对象，也要同时扫描新生代对象，如果是业务高峰期，新生代对象比较多，扫描标记时间就会很长，因为要根据对象找它的引用，能不能<strong>在重新标记前把新生代的对象做一次垃圾回收</strong>，减少新生代对象的数量，减少重新标记阶段耗费的时间。通过设置：-XX:+CMSScavengeBeforeRemark：在重新标记发生之前，先对新生代进行一次垃圾清理。</p>
<h3 id="案例3-老年代充裕情况下发生-full-gc-cms-jdk17">案例3 老年代充裕情况下，发生 Full GC （CMS jdk1.7）</h3>
<ul>
<li>问题分析：</li>
</ul>
<p>CMS 可能由于空间不足导致并发失败，或者由于空间碎片多都会产生 Full GC。但是经过排查，在 GC 日志没有并发失败或者碎片过多的提示。说明老年代空间充裕，不是由于老年代空间不足产生的 Full GC。<strong>JDK1.7 及以前采用永久代作为方法区的实现，永久代空间不足也会导致 Full GC 发生</strong>，1.8 以后使用元空间就不是由 Java 控制了，所以元空间使用操作系统的空间一般情况是比较充裕的。1.7 以前永久代空间设置小了就会触发整个堆的 Full GC。</p>
<ul>
<li>问题解决：</li>
</ul>
<p>增大永久代的初始值和最大值</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP 系列（二）熟悉 HTTP 协议结构和通讯原理]]></title>
        <id>https://epitomm.github.io/post/http-xi-lie-er-shou-xi-http-xie-yi-jie-gou-he-tong-xun-yuan-li/</id>
        <link href="https://epitomm.github.io/post/http-xi-lie-er-shou-xi-http-xie-yi-jie-gou-he-tong-xun-yuan-li/">
        </link>
        <updated>2020-04-23T06:24:08.000Z</updated>
        <content type="html"><![CDATA[<h1 id="http-特点">HTTP 特点</h1>
<h2 id="支持-客户服务器-模式">支持 客户/服务器 模式</h2>
<p>客户/服务器模式工作的方式是由客户端向服务器发出请求，服务器端响应请求，并进行相应服务。</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/client-server.png" alt="图片" loading="lazy"></figure>
<h2 id="简单快速">简单快速</h2>
<ul>
<li>客户向服务器请求服务时，只需传送<strong>请求方法和路径</strong></li>
<li>请求方法常用的有<strong>GET、HEAD、POST</strong>。每种方法规定了客户与服务器联系的类型不同</li>
<li>由于HTTP协议简单，使得HTTP服务器的程序规模小，因而<strong>通信速度很快</strong></li>
</ul>
<h2 id="灵活">灵活</h2>
<ul>
<li><strong>HTTP允许传输任意类型的数据对象</strong></li>
<li>正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记</li>
</ul>
<h2 id="无连接">无连接</h2>
<ul>
<li>无连接的含义是限制<strong>每次连接只处理一个请求</strong></li>
<li>服务器处理完客户的请求，并收到客户的应答后，即断开连接</li>
<li>采用这种方式可以<strong>节省传输时间</strong></li>
</ul>
<h2 id="无状态">无状态</h2>
<ul>
<li>HTTP协议是无状态协议</li>
<li>无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大</li>
<li>另一方面，在服务器不需要先前信息时它的应答就较快</li>
</ul>
<h1 id="uri-与-url">URI 与 URL</h1>
<p>Q：我们输入在浏览器里的Web地址应该叫URL还是URI？</p>
<p>小A：我们访问的就是<strong>URL</strong>！</p>
<p>小B：不！其实那时<strong>URI</strong>好不好！</p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/URI.png" alt="图片" loading="lazy"></figure>
<ul>
<li>URI：一个紧凑的字符串用来标示抽象或物理资源</li>
<li>A URI 可以进一步被分为定位符、名字或两者都是</li>
<li>术语&quot;Uniform Resource Locator&quot;（URL）是URI的子集，除了确定一个资源，还提供一种定位该资源的主要访问机制（如其网络“位置”）</li>
</ul>
<h2 id="维基百科解释">维基百科解释</h2>
<ul>
<li>URI可以分为URL，URN或同时具备locators 和names特性的一个东西</li>
<li>URN作用就好像一个人的<strong>名字</strong>，URL就像一个人的<strong>地址</strong></li>
<li>换句话说：URN确定了东西的身份，URL提供了找到它的方式</li>
</ul>
<blockquote>
<p>一家公司的总经理有一张名片，上面写了 “北京 xxx 公司总经理张三”、办公室地址 “北京市海淀区长安街35号 xx 楼 xxx 办公室”。<br>
头衔：北京 xxx 公司总经理 —— 张三，建立一个映射，这个头衔就是 URI，<strong>只要看到一个 URI 就知道它代表什么</strong>。<br>
<a href="http://www.baidu.cn">www.baidu.cn</a> —— 百度网，<a href="http://www.baidu.com">www.baidu.com</a> 就是一个 URI<br>
admin@qq.com —— 代表某个人的 QQ 邮箱，admin@qq.com 也是一个 URI<br>
<strong>URI 是一个网络资源的头衔</strong>，是一个统称，通过 URI 可以把网络世界里的每一个事务都加以标记并且区分开来。<br>
“北京 xxx 公司总经理” 是一个 URI，我们知道这个头衔对应的是张三，但是我们不能去找到这个人，因为不知道他的地址，要定位到他就必须要知道他的办公室地址。反映到网络世界，网络世界中的每个资源不只有头衔，还要能够被人访问，所以网络地址也是必须的，否则这个网络资源的存在就没有任何意义了，这个<strong>网络地址就叫做 URL</strong>。</p>
</blockquote>
<ul>
<li>URL是URI的一种，但不是所有的URI都是URL</li>
<li>URI和URL最大的差别是“访问机制（HTTP 还是 FTP）&quot;</li>
<li>URN 是唯一标识的一部分，是身份信息</li>
</ul>
<h2 id="安能辨我是雌雄">安能辨我是雌雄</h2>
<ul>
<li>ftp://ftp.is.co.za/rfc/rfc1808.txt
<ul>
<li>URL，提供了访问机制是 FTP</li>
</ul>
</li>
<li>http://www.ietf.org/rfc/rfc2396.txt
<ul>
<li>URL，提供了访问机制是 HTTP</li>
</ul>
</li>
<li>Idap://[2001:db8::7]/c=GB?objectClass?one
<ul>
<li>URL，提供了访问机制 LDAP</li>
</ul>
</li>
<li>mailto:John.Doe@example.com
<ul>
<li>URL，通过邮件进行访问</li>
</ul>
</li>
<li>news:comp.infosystems.www.servers.unix
<ul>
<li>URL</li>
</ul>
</li>
<li>tel:+1-816-555-1212
<ul>
<li>URI：电话号码可以标识某一个人，但是没有访问机制</li>
</ul>
</li>
<li>telnet://192.0.2.16:80/
<ul>
<li>URL，访问机制 telnet</li>
</ul>
</li>
<li>urn:oasis:names:specification:docbook:dtd:xml:4.1.2
<ul>
<li>URL，地址中已经显示了 urn，没有自己的访问方式</li>
</ul>
</li>
</ul>
<h1 id="http-报文结构分析-请求报文">HTTP 报文结构分析 - 请求报文</h1>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>报文头和报文体中间有一行空行<br>
报文体内是表单的数据，不同参数之间使用 &amp; 进行拼接</p>
</blockquote>
<h2 id="http-报文头">HTTP 报文头</h2>
<ul>
<li>HTTP的报文头大体可以分为四类，分别是：通用报文头、请求报文头、响应报文头和实体报文头</li>
<li>在HTTP/1.1里一共规范了47种报文头字段</li>
</ul>
<h3 id="通用报文头">通用报文头</h3>
<table>
<thead>
<tr>
<th style="text-align:left">首部字段名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Cache-Control</td>
<td style="text-align:left">控制缓存的行为</td>
</tr>
<tr>
<td style="text-align:left">Connection</td>
<td style="text-align:left">逐跳首部、连接的管理</td>
</tr>
<tr>
<td style="text-align:left">Date</td>
<td style="text-align:left">创建报文的日期时间</td>
</tr>
<tr>
<td style="text-align:left">Pragma</td>
<td style="text-align:left">报文指令</td>
</tr>
<tr>
<td style="text-align:left">Trailer</td>
<td style="text-align:left">报文末端的首部一览</td>
</tr>
<tr>
<td style="text-align:left">Transfer-Encoding</td>
<td style="text-align:left">指定报文主体的传输编码方式</td>
</tr>
<tr>
<td style="text-align:left">Upgrade</td>
<td style="text-align:left">升级为其他协议</td>
</tr>
<tr>
<td style="text-align:left">Via</td>
<td style="text-align:left">代理服务器的相关信息</td>
</tr>
<tr>
<td style="text-align:left">Warning</td>
<td style="text-align:left">错误通知</td>
</tr>
</tbody>
</table>
<h3 id="请求报文头">请求报文头</h3>
<table>
<thead>
<tr>
<th style="text-align:left">首部字段名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Accept</td>
<td style="text-align:left">用户代理可处理的媒体类型</td>
</tr>
<tr>
<td style="text-align:left">Accept-Charset</td>
<td style="text-align:left">优先的字符集</td>
</tr>
<tr>
<td style="text-align:left">Accept-Encoding</td>
<td style="text-align:left">优先的内容编码</td>
</tr>
<tr>
<td style="text-align:left">Accept-Language</td>
<td style="text-align:left">优先的语言（自然语言）</td>
</tr>
<tr>
<td style="text-align:left">Authorization</td>
<td style="text-align:left">Web 认证信息</td>
</tr>
<tr>
<td style="text-align:left">Expect</td>
<td style="text-align:left">期待服务器的特定行为</td>
</tr>
<tr>
<td style="text-align:left">From</td>
<td style="text-align:left">用户的电子邮箱地址</td>
</tr>
<tr>
<td style="text-align:left">Host</td>
<td style="text-align:left">请求资源所在服务器</td>
</tr>
<tr>
<td style="text-align:left">If-Match</td>
<td style="text-align:left">比较实体标记（ETag）</td>
</tr>
<tr>
<td style="text-align:left">If-Modified-Since</td>
<td style="text-align:left">比较资源的更新时间</td>
</tr>
<tr>
<td style="text-align:left">If-None-Match</td>
<td style="text-align:left">比较实体标记（与 If-Match 相反）</td>
</tr>
<tr>
<td style="text-align:left">If-Range</td>
<td style="text-align:left">资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td style="text-align:left">If-Unmodified-Since</td>
<td style="text-align:left">比较资源的更新时间（与 If-Modified-Since相反）</td>
</tr>
<tr>
<td style="text-align:left">Max-Forwards</td>
<td style="text-align:left">最大传输逐跳数</td>
</tr>
<tr>
<td style="text-align:left">Proxy-Authorization</td>
<td style="text-align:left">代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td style="text-align:left">Range</td>
<td style="text-align:left">实体的字节范围请求</td>
</tr>
<tr>
<td style="text-align:left">Referrer</td>
<td style="text-align:left">对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td style="text-align:left">TE</td>
<td style="text-align:left">传输编码的优先级</td>
</tr>
<tr>
<td style="text-align:left">User-Agent</td>
<td style="text-align:left">HTTP 客户端程序的信息</td>
</tr>
</tbody>
</table>
<h3 id="响应报文头">响应报文头</h3>
<table>
<thead>
<tr>
<th style="text-align:left">首部字段名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Accept-Ranges</td>
<td style="text-align:left">是否接受字节范围请求</td>
</tr>
<tr>
<td style="text-align:left">Age</td>
<td style="text-align:left">推算资源创建经过时间</td>
</tr>
<tr>
<td style="text-align:left">ETag</td>
<td style="text-align:left">资源的匹配信息</td>
</tr>
<tr>
<td style="text-align:left">Location</td>
<td style="text-align:left">令客户端重定向至指定 URI</td>
</tr>
<tr>
<td style="text-align:left">Proxy-Authenticate</td>
<td style="text-align:left">代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td style="text-align:left">Retry-After</td>
<td style="text-align:left">对再次发起请求的时机要求</td>
</tr>
<tr>
<td style="text-align:left">Server</td>
<td style="text-align:left">HTTP服务器的安装信息</td>
</tr>
<tr>
<td style="text-align:left">Vary</td>
<td style="text-align:left">代理服务器缓存的管理信息</td>
</tr>
<tr>
<td style="text-align:left">WWW-Authenticate</td>
<td style="text-align:left">服务器对客户端的认证信息</td>
</tr>
</tbody>
</table>
<h3 id="实体报文头">实体报文头</h3>
<table>
<thead>
<tr>
<th style="text-align:left">首部字段名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Allow</td>
<td style="text-align:left">资源可支持的 HTTP 方法</td>
</tr>
<tr>
<td style="text-align:left">Content-Encoding</td>
<td style="text-align:left">实体主体使用的编码方式</td>
</tr>
<tr>
<td style="text-align:left">Content-Language</td>
<td style="text-align:left">实体主体的自然语言</td>
</tr>
<tr>
<td style="text-align:left">Content-Length</td>
<td style="text-align:left">实体主体的大小（单位：字节）</td>
</tr>
<tr>
<td style="text-align:left">Content-Location</td>
<td style="text-align:left">替代对应资源的 URI</td>
</tr>
<tr>
<td style="text-align:left">Content-MD5</td>
<td style="text-align:left">实体主体的报文摘要</td>
</tr>
<tr>
<td style="text-align:left">Content-Range</td>
<td style="text-align:left">实体主体的位置范围</td>
</tr>
<tr>
<td style="text-align:left">Content-Type</td>
<td style="text-align:left">实体主体的媒体类型</td>
</tr>
<tr>
<td style="text-align:left">Expires</td>
<td style="text-align:left">实体主体过期的日期时间</td>
</tr>
<tr>
<td style="text-align:left">Last-Modified</td>
<td style="text-align:left">资源的最后修改日期时间</td>
</tr>
</tbody>
</table>
<h2 id="accept">ACCEPT</h2>
<ul>
<li>作用：<strong>浏览器端可以接受的媒体类型</strong></li>
</ul>
<p>Accept:<strong>text/html</strong> 代表浏览器可以接受服务器回发的类型为 text/html 也就是我们常说的 html 文档，如果服务器无法返回 text/html 类型的数据，服务器应该返回一个406错误（Non Acceptable）</p>
<p>如果想要给显示的媒体类型增加优先级，则使用q=来额外表示权重值）；重值 q 的范围是0~1（可精确到小数点后 3 位），且 1 为最大值。不指定权重 q 值时，默认权重为 q=1.0。当服务器提供多种内容时，将会首先返回权重值最高的媒体类型。</p>
<h2 id="accept-encoding">Accept-Encoding</h2>
<ul>
<li>作用：浏览器申明自己接收的<strong>编码方法</strong>，通常指定<strong>压缩</strong>方法，是否支持压缩，支持什么压缩方法（gzip，deflate）
<ul>
<li>Accept-Encoding:gzip，deflate</li>
</ul>
</li>
<li>作用：浏览器申明自己接收的语言
<ul>
<li>Accept-Language:zh-cn, zh; q=0.7, en-us, en; q=0.3</li>
<li>客户端在服务器有中文版资源的情况下，会请求其返回中文版对应的响应，没有中文版时，则请求返回英文版响应</li>
</ul>
</li>
<li><strong>Connection:keep-alive</strong> ：当一个网页打开完成后，客户端和服务器之间<strong>用于传输HTTP数据的TCP连接不会关闭</strong>，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。</li>
<li>Connection:close 代表<strong>一个Request</strong>完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭，当客户端再次发送Request，需要重新建立TCP连接</li>
</ul>
<h2 id="host">Host</h2>
<ul>
<li>作用：请求报头域主要用于指定被请求资源的 <strong>Internet主机和端口号</strong>，它通常从HTTP URL中提取出来的</li>
</ul>
<p>我们在浏览器中输入：http://www.fljf.com:8080 刘览器发送的请求消息中，就会包含Host请求报头域，如下：Host：www.fljf.com:8080</p>
<h2 id="referer">Referer</h2>
<p>当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理</p>
<h2 id="user-agent">User-Agent</h2>
<ul>
<li>作用：告诉HTTP服务器，客户端使用的操作系统和浏览器的名称和版本</li>
<li>很多情况下我们会通过User-Agnet来判断浏览器类型，从而进行不同的兼容设计</li>
</ul>
<h2 id="content-type">Content-Type</h2>
<ul>
<li>作用：说明了报文体内对象的媒体类型</li>
</ul>
<p>text/html：HTML格式</p>
<p>text/plain：纯文本格式</p>
<p>text/xml：XML格式</p>
<p>image/gif：gif图片格式</p>
<p>image/jpeg：jpg图片格式</p>
<p>image/png：png图片格式</p>
<p>application/xhtml+xml：XHTML格式</p>
<p>application/xml：XML数据格式</p>
<p>application/atom+xml：Atom XML聚合格式</p>
<p>application/json：JSON数据格式</p>
<p>application/pdf：pdf格式</p>
<p>application/msword：Word文档格式</p>
<p>application/octet-stream：二进制流数据（如常见的文件下载）</p>
<p>application/x-www-form-urlencoded：表单提交</p>
<h1 id="http-报文结构分析-响应报文">HTTP 报文结构分析 - 响应报文</h1>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.png" alt="图片" loading="lazy"></figure>
<h1 id="http-请求方法剖析">HTTP 请求方法剖析</h1>
<p>HTTP/1.1常用方法</p>
<p>①GET</p>
<p>② POST</p>
<p>③ PUT</p>
<p>④HEAD</p>
<p>⑤ DELETE</p>
<p>⑥OPTIONS</p>
<p>⑦TRACE</p>
<p>③ CONNECT</p>
<h2 id="get-获取资源">GET 获取资源</h2>
<ul>
<li>GET方法用来请求访问已被URI识别的资源</li>
<li>指定的资源经服务器端解析后返回响应内容</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/GET%E8%AF%B7%E6%B1%82.png" alt="图片" loading="lazy"></figure>
<ul>
<li>GET方法也可以用来提交表单和其他数据</li>
<li>http://localhost/login.php?username=aa&amp;password=1234 从上面的 URL 请求中，很容易就可以辩认出表单提交的内容</li>
</ul>
<h2 id="post">POST</h2>
<ul>
<li>POST 方法与 GET 功能类似，一般用来<strong>传输实体的主体</strong></li>
<li>POST 方法的主要目的不是获取响应主体的内容</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/POST%E8%AF%B7%E6%B1%82.png" alt="图片" loading="lazy"></figure>
<h3 id="说下-get-和-post-的区别">说下 GET 和 POST 的区别？</h3>
<p>GET 和 POST 本质都是 HTTP 请求，只不过对它们的作用做了界定和适配，并且让他们适应各自的场景。</p>
<ul>
<li>本质区别：GET 只是一次 HTTP请求，POST 先发请求头再发请求体，实际上是两次请求。</li>
<li>从功能上讲，GET 一般用来<strong>从服务器上获取资源</strong>，POST 一般用来<strong>更新服务器上的资源</strong>；</li>
<li>从 REST 服务角度上说，<strong>GET 是幂等</strong>的，即读取同一个资源，总是得到相同的数据，而 <strong>POST 不是幂等</strong>的，因为每次请求对资源的改变并不是相同的；进一步地，GET 不会改变服务器上的资源，而 POST 会对服务器资源进行改变；</li>
<li>从请求参数形式上看，<strong>GET 请求的数据会附在 URL 之后</strong>，即将请求数据放置在 HTTP 报文的 请求头 中，以 ? 分割 URL 和传输数据，参数之间以 &amp; 相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用 BASE64 加密，得出如：%E4%BD%A0%E5%A5%BD，其中 ％XX 中的 XX 为该符号以 16 进制表示的 ASCII)；而 **POST 请求会把提交的数据则放置在是 HTTP 请求报文的 **<strong>请求体</strong> 中；</li>
<li>就安全性而言，<strong>POST 的安全性要比 GET 的安全性高</strong>，因为 GET 请求提交的数据将明文出现在 URL 上，而且 POST 请求参数则被包装到请求体中，相对更安全；</li>
<li>从请求的大小看，GET 请求的长度受限于浏览器或服务器对 URL 长度的限制，允许发送的数据量比较小，而 POST 请求则是没有大小限制的。</li>
</ul>
<h2 id="put">PUT</h2>
<ul>
<li>从客户端向服务器传送的数据<strong>取代指定的文档的内容</strong></li>
<li>PUT方法与POST方法最大的不同是：PUT是幂等的，而POST是不幂等的</li>
<li>因此，我们更多时候将PUT方法用作传输资源</li>
</ul>
<blockquote>
<p>创建对象用 POST，更新对象用 PUT。<br>
但是，HTTP1.1 的 PUT 方法不带有验证机制，存在一定的安全问题，所以一般不使用 PUT，更新对象可以使用 POST 请求，然后在后端代码逻辑处理。</p>
</blockquote>
<h2 id="headdelete">HEAD/DELETE</h2>
<ul>
<li>HEAD类似于GET请求，只不过返回的响应中没有具体的内容，用于<strong>获取报头</strong>。</li>
<li>DELETE请求服务器删除指定的资源。</li>
</ul>
<blockquote>
<p>DELETE 方法没有验证机制，所以一般不使用。</p>
</blockquote>
<h2 id="options">OPTIONS</h2>
<p>用来查询针对请求URI指定的资源支持的方法</p>
<blockquote>
<p>不知道对方支持什么方法，询问一下。</p>
</blockquote>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/OPTIONS%E8%AF%B7%E6%B1%82.png" alt="图片" loading="lazy"></figure>
<h2 id="traceconnect">TRACE/CONNECT</h2>
<ul>
<li>TRACE：回显服务器收到的请求，主要用于测试或诊断</li>
</ul>
<blockquote>
<p>容易引发 XSP 攻击，所以一般不使用 TRACE 请求</p>
</blockquote>
<ul>
<li>CONNECT：开启一个客户端与所请求资源之间的双向沟通的通道，它可以用来创建隧道</li>
</ul>
<blockquote>
<p>代理服务器访问互联网时，就是用 CONNECT 方法。<br>
浏览器向代理服务器发送 CONNECT 请求，代理服务器返回状态码 200，浏览器就和服务器三次握手交换数据，代理服务器只负责传输彼此的数据包，并不能读取数据内容。</p>
</blockquote>
<h1 id="状态码">状态码</h1>
<p>是用以表示网页服务器超文本传输协议响应状态的3位数字代码。</p>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/%E7%8A%B6%E6%80%81%E7%A0%81.png" alt="图片" loading="lazy"></figure>
<h2 id="http-状态码详解">HTTP 状态码详解</h2>
<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1XX</td>
<td style="text-align:left">表示消息。这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。</td>
</tr>
<tr>
<td style="text-align:left">2XX</td>
<td style="text-align:left">表示<strong>成功</strong>。这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。</td>
</tr>
<tr>
<td style="text-align:left">3XX</td>
<td style="text-align:left">表示<strong>重定向</strong>。这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。</td>
</tr>
<tr>
<td style="text-align:left">4XX</td>
<td style="text-align:left">表示<strong>请求错误</strong>。这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。</td>
</tr>
<tr>
<td style="text-align:left">5XX</td>
<td style="text-align:left">表示<strong>服务器错误</strong>。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。</td>
</tr>
</tbody>
</table>
<h3 id="常用http状态码">常用HTTP状态码</h3>
<p>2XX 状态码：</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">状态码英文名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">200</td>
<td style="text-align:left">OK</td>
<td style="text-align:left">请求已成功，请求所希望的响应头或数据体将随此响应返回</td>
</tr>
<tr>
<td style="text-align:left">202</td>
<td style="text-align:left">Accepted</td>
<td style="text-align:left">已接受，已经接受请求，但未处理完成</td>
</tr>
<tr>
<td style="text-align:left">206</td>
<td style="text-align:left">Partial Content</td>
<td style="text-align:left">部分内容，服务器成功处理了部分GET请求</td>
</tr>
</tbody>
</table>
<p>3XX 状态码：</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">状态码英文名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">301</td>
<td style="text-align:left">Moved Permanently</td>
<td style="text-align:left"><strong>永久移动</strong>，请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替（<strong>更换域名</strong>）</td>
</tr>
<tr>
<td style="text-align:left">302</td>
<td style="text-align:left">Found</td>
<td style="text-align:left">临时移动，与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
</tbody>
</table>
<p>4XX 状态码：</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">状态码英文名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left">Bad Request</td>
<td style="text-align:left">客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td style="text-align:left">401</td>
<td style="text-align:left">Unauthorized</td>
<td style="text-align:left">请求要求用户的身份认证</td>
</tr>
<tr>
<td style="text-align:left">403</td>
<td style="text-align:left">Forbidden</td>
<td style="text-align:left">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td style="text-align:left">404</td>
<td style="text-align:left">Not Found</td>
<td style="text-align:left">服务器无法根据客户端的请求找到资源（网页）。</td>
</tr>
</tbody>
</table>
<p>5XX 状态码：</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">状态码英文名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left">Internal Server Error</td>
<td style="text-align:left">服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td style="text-align:left">502</td>
<td style="text-align:left">Bad Gateway</td>
<td style="text-align:left">充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</td>
</tr>
</tbody>
</table>
<h1 id="http状态管理cookie与session">HTTP状态管理：Cookie与Session</h1>
<p>HTTP 是无状态协议，每个请求都是独立的，如果后续处理需要前面的信息，必须重传，就会导致连接传送的数据量增大，于是引入 Cookie 和 Session 保存 HTTP 连接状态。</p>
<h2 id="cookie">Cookie</h2>
<ul>
<li>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就向客户端浏览器颁发一个Cookie。</li>
<li><strong>客户端浏览器</strong>会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态<br>
<img src="https://epitomm.github.io/post-images/cookie.png" alt="图片" loading="lazy"></li>
</ul>
<blockquote>
<p>在浏览器地址栏输入 www.baidu.com ，浏览器向百度服务器发送读取网页的请求，并且把结果显示回显示器上。<br>
发送之前，这个网页在本机电脑上寻找百度网站设置的 cookie 文件，如果找到，浏览器会把 cookie 文件中的数据连同 url 一同发送给百度服务器，服务器收到数据，就会在它的数据库中检索 id、搜索记录等信息，并且记录下这次新的内容，增加到数据库和 cookie 文件中。如果没有检测到 cookie，或者 cookie 信息与数据库信息不符合，说明这是第一次浏览这个网站，服务器就会创建一个新的 id，并且保存到数据库，并给浏览器下发一个 cookie，这样下一次访问就会像前面描述的那样查到 cookie 记录了。</p>
</blockquote>
<h2 id="cookie-工作原理">Cookie 工作原理</h2>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/cookie%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="图片" loading="lazy"></figure>
<p>1.浏览器发送请求到服务器</p>
<p>2.如果是第一次访问这个服务器，服务器 set-cookie</p>
<p>3.服务器通过 set-cookie 这样的一个响应头把 cookie 发送给客户端</p>
<p>4.客户端读取到 set-cookie 之后，把 cookie 存储到本地的文本文件中</p>
<p>5.再次发送请求，会把 cookie 一起发送到服务器端</p>
<p>6.服务器接收到这个 cookie，检查 cookie，证明没问题，确实是我已经存在的用户了，返回响应结果。</p>
<h2 id="session">Session</h2>
<ul>
<li>Session是另一种记录客户状态的机制，保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上</li>
<li>客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了</li>
</ul>
<p>##Session 工作原理<br>
<img src="https://epitomm.github.io/post-images/session%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="图片" loading="lazy"></p>
<blockquote>
<p>用户访问一个服务器，如果服务器启用 session，服务器就要为这个用户创建一个 session，在创建这个 session 的时候，服务器首先检查这个用户发来的请求里，是否包含一个 sessionID，如果包含了，就说明这个用户此前已经登陆过，并且已经创建过 session，就按照这个 sessionID 把 session 从服务器的内存中查找出来。如果查找不到或客户端请求就不包含这个 sessionID，就为这个客户端创建一个新的 session，并且生成一个与此 session 相关的 sessionID，这个 sessionID 在服务端是唯一的，这个 sessionID会在这一次响应中返回到客户端进行保存，保存这个 sessionID 的正是 cookie。</p>
</blockquote>
<h2 id="保存session-id的方式">保存Session ID的方式</h2>
<ul>
<li>Cookie</li>
<li>URL重写：
<ul>
<li>https://.../xxx?sessionID=BpRZx3lQx33ccEoU6QZcEb64（参数）</li>
<li>https://.../xxx;SessionID=BpRZx3lQx33ccEoU6QZcEb64（路径附加信息）</li>
</ul>
</li>
<li>隐藏表单</li>
</ul>
<h2 id="session的有效期">Session的有效期</h2>
<ul>
<li>Session超时失效
<ul>
<li>服务器空间有限，设置 session 有效时间，防止更多的用户访问造成服务器内存溢出</li>
</ul>
</li>
<li>程序调用HttpSession.invalidate()
<ul>
<li>点击退出，手动调用 session 失效方法</li>
</ul>
</li>
<li>服务器进程被停止</li>
<li>Cokie 与 Session理存放位置不同
<ul>
<li>Cookie 保存在客户端</li>
<li>Session 保存在服务端</li>
</ul>
</li>
<li>安全性（隐私策略）的不同
<ul>
<li>Cookie 存储在浏览器，对客户端可见，客户端的程序可修改 Cookie 中的内容</li>
<li>Session 存储在服务器端，对客户端来说是透明的，不存在敏感信息泄露的风险</li>
</ul>
</li>
<li>有效期的不同
<ul>
<li>设置 Cookie 的过期时间为很大的数字，Cookie 就可以在浏览器保存很长时间</li>
<li>服务器端会定时清理超时的 sessionID，避免出现过大的压力</li>
<li>session 依赖名为 sessionID 这样类似的 cookie，而 cookie 的 sessionID 过期时间默许是 -1，所以只要关闭了浏览器，也就是<strong>一次会话</strong>结束，这个 session 就失效了。</li>
</ul>
</li>
<li>对服务器压力的不同
<ul>
<li>session 保管在服务器端，每个用户都保存一个 session，耗费大量内存。</li>
<li>cookie 保存在客户端，不太占用服务器的资源。</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode876. 链表的中间结点]]></title>
        <id>https://epitomm.github.io/post/leetcode876-lian-biao-de-zhong-jian-jie-dian/</id>
        <link href="https://epitomm.github.io/post/leetcode876-lian-biao-de-zhong-jian-jie-dian/">
        </link>
        <updated>2020-04-23T02:57:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个带有头结点 head 的非空单链表，返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<h2 id="示例">示例</h2>
<p>示例 1：</p>
<p>输入：[1,2,3,4,5]<br>
输出：此列表中的结点 3 (序列化形式：[3,4,5])<br>
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。<br>
注意，我们返回了一个 ListNode 类型的对象 ans，这样：<br>
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.</p>
<p>示例 2：</p>
<p>输入：[1,2,3,4,5,6]<br>
输出：此列表中的结点 4 (序列化形式：[4,5,6])<br>
由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</p>
<p>提示：</p>
<p>给定链表的结点数介于 1 和 100 之间。</p>
<h2 id="方法一遍历两次链表">方法一：遍历两次链表</h2>
<h3 id="问题分析">问题分析</h3>
<ul>
<li>
<p>遍历链表，记录下链表长度 length。</p>
</li>
<li>
<p>再遍历链表返回第 length/2 个节点。</p>
</li>
</ul>
<h3 id="复杂度分析">复杂度分析</h3>
<ul>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
</ul>
<p>链表节点数为奇数个时：</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9.png" alt="图片" loading="lazy"></figure>
<p>链表节点数为偶数个时：</p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B92.png" alt="图片" loading="lazy"></figure>
<h3 id="代码">代码</h3>
<pre><code>public class AlgoCasts {
  public class ListNode {
    int val;
    ListNode next;
    ListNode(int x) {
      val = x;
    }
  }
  // Time: O(n), Space: O(1)
  public ListNode getMiddleNodeTwoPass(ListNode head) {
    ListNode p = head;
    int len = 0;
    for (; p != null; p = p.next) ++len;
    p = head;
    for (int i = 0; i &lt; len/2; ++i) p = p.next;
    return p;
  }
}
</code></pre>
<h2 id="方法二快慢指针">方法二：快慢指针</h2>
<h3 id="问题分析-2">问题分析</h3>
<p>快指针一次走两步，慢指针一次走一步，<strong>当快指针遍历完链表时，慢指针正好指向中间节点</strong>。</p>
<h3 id="复杂度分析-2">复杂度分析</h3>
<ul>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
</ul>
<pre><code>while(fast != nul &amp;&amp; fast.next != null){
  fast = fast.next.next; // 快指针移动两步
  slow = slow.next; // 慢指针移动一步
}  
</code></pre>
<p>链表节点数为奇数个时：<br>
<img src="https://epitomm.github.io/post-images/%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9_%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%881.png" alt="图片" loading="lazy"></p>
<p>链表节点数为偶数个时：<br>
<img src="https://epitomm.github.io/post-images/%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9_%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%882.png" alt="图片" loading="lazy"></p>
<h3 id="代码-2">代码</h3>
<pre><code>public class AlgoCasts {
  public class ListNode {
    int val;
    ListNode next;
    ListNode(int x) {
      val = x;
    }
  }
  // Time: O(n), Space: O(1)
  public ListNode getMiddleNodeOnePass(ListNode head) {
    ListNode fast = head, slow = head;
    while (fast != null &amp;&amp; fast.next != null) {
      fast = fast.next.next;
      slow = slow.next;
    }
    return slow;
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP系列（一）了解 HTTP 协议]]></title>
        <id>https://epitomm.github.io/post/httpyi-liao-jie-http-xie-yi/</id>
        <link href="https://epitomm.github.io/post/httpyi-liao-jie-http-xie-yi/">
        </link>
        <updated>2020-04-21T09:10:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="浏览器背后的故事">浏览器背后的故事</h1>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%85%E4%BA%8B.png" alt="图片" loading="lazy"></figure>
<ol>
<li>在浏览器地址栏<strong>输入域名</strong>想要访问某个网站，但是真正标识服务器的而是 IP 地址。</li>
<li>根据域名到 <strong>DNS 服务器中查询目标服务器对应的 IP 地址</strong></li>
<li>浏览器根据查询到的 IP 地址<strong>与 WEB 服务器进行通信</strong>，通信的协议就是 HTTP 协议。</li>
</ol>
<blockquote>
<p>把这个过程类比为电话通信的过程。如果我们想要给某个人打电话。</p>
<ol>
<li>从通讯录翻到这个人的名字（域名）</li>
<li>实际拨打过去的电话号（IP 地址）<br>
我们很容易记住姓名，但很难记住每个人的电话号。</li>
<li>打通电话后需要进行对话，就需要两个人使用共同的语言（HTTP 协议）。</li>
</ol>
</blockquote>
<ol>
<li>WEB 服务器收到请求，到后端进行执行，将执行结果以<strong>响应报文</strong>的形式回传到浏览器，如果直接将响应报文展示出来，是一串串代码，普通人难以理解。</li>
<li>浏览器对响应报文进行<strong>渲染</strong>，使用 HTML 描述对应数据，把网页资源的源代码转换为图像结果。</li>
</ol>
<h2 id="http">HTTP</h2>
<ul>
<li>超文本传输协议（HTTP）是一种<strong>通信协议</strong>，它允许将超文本标记语言（HTML）文档从Web服务器传送到客户端的浏览器。</li>
</ul>
<blockquote>
<p>超文本传输协议：传输超文本（HTML）的协议。在服务端和客户端传输 HTML 要遵守的<strong>规则</strong>。</p>
</blockquote>
<ul>
<li>HTTP是一个属于<strong>应用层的面向对象的协议</strong>，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展</li>
</ul>
<h2 id="web-与-http">WEB 与 HTTP</h2>
<ul>
<li>WEB是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式<strong>图形信息系统</strong>。</li>
<li>建立在Internet上的一种<strong>网络服务</strong>，为浏览者在Internet上查找和浏览信息提供了图形化的、易于访问的直观界面，其中的文档及超级链接将Internet上的信息节点组织成一个互为关联的网状结构。</li>
</ul>
<h1 id="http-协议的前世今生">HTTP 协议的前世今生</h1>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.png" alt="图片" loading="lazy"></figure>
<h1 id="透过-tcpip-看-http">透过 TCP/IP 看 HTTP</h1>
<ul>
<li>HTTP协议是构建在 <strong>TCP/IP</strong> 协议之上的，是TCP/IP协议的一个子集</li>
<li>为了更好的理解HTTP协议，我们先了解一下TCP/IP的相关知识。</li>
</ul>
<h2 id="tcpip协议族">TCP/IP协议族</h2>
<ul>
<li>TCP/IP 协议其实是一系列与互联网相关联的协议集合起来的总称</li>
<li>分层管理是 TCP/IP 协议的重要特征</li>
</ul>
<h2 id="tcpip协议族分层">TCP/IP协议族分层</h2>
<ul>
<li>TCP/IP协议族是由一个四层协议组成的系统，这四层分别为：和数据链路层、网络层、运输层、应用层</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E5%9B%9B%E5%B1%82%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84.png" alt="图片" loading="lazy"></figure>
<h3 id="应用层">应用层</h3>
<ul>
<li>应用层一般是我们编写的应用程序，决定了向用户提供的应用服务。应用层可以通过系统调用与传输层进行通信。</li>
<li>如：<strong>FTP、DNS、HTTP</strong>等。</li>
</ul>
<h3 id="传输层">传输层</h3>
<ul>
<li>传输层通过系统调用向应用层提供处于网络连接中的两台计算机之间的数据传输功能。</li>
<li>在传输层有两个性质不同的协议：**TCP **和 <strong>UDP</strong>。</li>
</ul>
<h3 id="网络层">网络层</h3>
<ul>
<li>网络层用来处理在网络上流动的数据包，数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（<strong>传输路线</strong>）到达对方计算机，并把数据包传输给对方。</li>
</ul>
<h3 id="链路层">链路层</h3>
<ul>
<li>链路层用来处理连接网络的<strong>硬件</strong>部分，包括控制操作系统、硬件设备驱动、NIC（Network Interface Card，网络适配器）以及光纤等物理可见部分。硬件上的范畴均在链路层的作用范围之内。</li>
</ul>
<h2 id="数据包的封装过程">数据包的封装过程</h2>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%B0%81%E8%A3%85%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<h2 id="http-数据传输过程">HTTP 数据传输过程</h2>
<p>发送端发送数据时，数据会从上层传输到下层，且每经过一层都会被打上该层的头部信息。而接收端接收数据时，数据会从下层传输到上层，传输前会把下层的头部信息删除</p>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/HTTP%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<p>发送端从应用层向下走，接收端从链路层向上走。</p>
<ul>
<li>作为发送端的客户端，在<strong>应用层</strong>，通过 HTTP 协议发出一个请求，</li>
<li>为了传输方便，在<strong>传输层</strong>，通过 TCP 协议把应用层收到的数据（HTTP 请求报文）进行分割并且在各个报文上打上标记序号、端口号等信息，发送到网络层</li>
<li>在<strong>网络层</strong>，通过 IP 协议，增加作为目的地的 MAC 地址，转发给链路层。</li>
<li><strong>链路层</strong>添加帧头、帧尾后，通过电信号传输给接收端。</li>
<li><strong>接收端</strong>的服务器在链路层接收到请求的数据，按顺序向上层发送，一直发送到应用层。</li>
</ul>
<h2 id="传输层-tcp-三次握手">传输层 —— TCP 三次握手</h2>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="图片" loading="lazy"></figure>
<p>使用TCP协议进行通信的双方必须先建立连接，然后才能开始传输数据。为了确保连接双方可靠性，在双方建立连接时，TCP协议采用了三次握手策略。</p>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B2.png" alt="图片" loading="lazy"></figure>
<ul>
<li><strong>第一次握手</strong>：客户端发送带有 SYN 标志的连接请求报文段，然后进入SYN_SEND状态，等待服务端的确认。</li>
</ul>
<blockquote>
<p>客户端：客户端发送能力正常<br>
服务端：客户端发送能力正常、服务端接收能力正常</p>
</blockquote>
<ul>
<li><strong>第二次握手</strong>：服务端接收到客户端的 SYN 报文段后，需要发送 ACK 信息对这个 SYN 报文段进行确认。同时，还要发送自己的 SYN 请求信息。服务端会将上述的信息放到一个报文段（SYN+ACK报文段）中，一并发送给客户端，此时服务端将会进入SYN_RECV状态。</li>
</ul>
<blockquote>
<p>客户端：客户端发送能力正常、服务端接收能力正常、客户端接收能力正常、服务端发送能力正常<br>
服务端：客户端发送能力正常、服务端接收能力正常</p>
</blockquote>
<ul>
<li><strong>第三次握手</strong>：客户端接收到服务端的 SYN+ACK 报文段后，会向服务端发送 ACK 确认报文段，这个报文段发送完毕后，客户端和服务端都进入 ESTABLISHED 状态，完成 TCP 三次握手。</li>
</ul>
<blockquote>
<p>客户端：客户端发送能力正常、服务端接收能力正常、客户端接收能力正常、服务端发送能力正常<br>
服务端：客户端发送能力正常、服务端接收能力正常、客户端端接收能力正常、服务端发送能力正常</p>
</blockquote>
<p>三次握手结束后，发送、接收双方都确认了彼此的发送和接收能力都正常。</p>
<h3 id="为什么两次握手不可以">为什么两次握手不可以？</h3>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8D%E5%8F%AF%E4%BB%A5.png" alt="图片" loading="lazy"></figure>
<p>为了防止已经失效的连接请求报文段突然又传送到了 B，因而产生错误。比如下面这种情况：A 发出的第一个连接请求报文段并没有丢失，而是在网路结点长时间滞留了，以致于延误到连接释放以后的某个时间段才到达 B。本来这是一个早已失效的报文段。但是 B 收到此失效的链接请求报文段后，就<strong>误认为 A 又发出一次新的连接请求</strong>。于是就向 A 发出确认报文段，同意建立连接。</p>
<p>对于上面这种情况，如果不进行第三次握手，<strong>B 发出确认后就认为新的运输连接已经建立了</strong>，并一直等待 A 发来数据。B 的许多资源就这样白白浪费了。</p>
<p>如果采用了三次握手，由于 A 实际上并没有发出建立连接请求，所以不会理睬 B 的确认，也不会向 B 发送数据。B 由于收不到确认，就知道 A 并没有要求建立连接。</p>
<h1 id="dns-域名解析">DNS 域名解析</h1>
<ul>
<li>已经介绍了与HTTP协议有着密切关系的TCP/IP协议，接下来介绍的DNS服务也是与HTTP协议有着密不可分的关系。</li>
<li>通常我们访问一个网站，使用的是主机名或者域名来进行访问的。因为相对于IP地址（一组纯数字），域名更容易让人记住。 但TCP/IP协议使用的是IP地址进行访问的，所以必须有个机制或服务把域名转换成IP地址。<strong>DNS</strong>服务就是用来解决这个问题的，它提供<strong>域名到IP地址之间的解析</strong>服务。</li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.png" alt="图片" loading="lazy"></figure>
<p>DNS 服务解析是有层次的，就近原则。</p>
<ul>
<li>本地电脑会将经常使用的域名和 IP 地址建立映射关系并且保存到<strong>系统文件</strong>中，在进行 DNS 解析时，系统会优先从 <strong>hosts 文件</strong>去寻找对应的 IP 地址，如果找到，直接使用 hosts 文件中的 IP 地址。</li>
<li>如果本地 hosts 文件没有找到该域名对应的 IP 地址的映射，向<strong>本地 DNS 服务器</strong>发送请求，查询域名对应的 IP 地址，本地域名服务器找到对应的 IP 地址，响应给浏览器。本地 DNS 服务有限，如果没有找到，依次向上层 DNS 服务器发起请求，</li>
<li>直到 <strong>DNS 根服务器</strong>，如果找到则返回。</li>
</ul>
<h2 id="dns-解析过程">DNS 解析过程</h2>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<h1 id="回溯-http-事务处理过程">回溯 HTTP 事务处理过程</h1>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/HTTP%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<p>当客户端访问Web站点时，首先会通过DNS服务查询到域名的IP地址。然后浏览器生成HTTP请求，并通过TCP/IP协议发送给Web服务器。Web服务器接收到请求后会根据请求生成响应内容，并通过TCP/IP协议返回给客户端。</p>
<h2 id="http-事务处理完整过程">HTTP 事务处理完整过程</h2>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/HTTP%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<ul>
<li>如果使用客户端浏览器浏览页面，需要从中分解出协议名、主机名、端口、对象路径等，得到协议是 HTTP 协议、主机是 mooc.com 主机、端口是 80 端口、路径是 mooc 的根节点。在这一步需要通过 DNS 服务器解析出它的 <strong>IP 地址</strong>。</li>
<li><strong>封装 HTTP 请求的数据包</strong>，把以上部分结合自己的本机信息封装成一个 HTTP 请求的数据包。</li>
<li>数据报向下封装成 <strong>TCP 包</strong>，<strong>三次握手建立 TCP 连接</strong>。</li>
<li>客户端<strong>发送请求</strong>给服务器</li>
<li>服务器进行<strong>响应</strong>，消息体有状态码、版本号</li>
<li><strong>释放 TCP 连接</strong></li>
</ul>
<h1 id="实验">实验</h1>
<ul>
<li>现在，我们已经了解了HTTP协议的基本概念，也知道了我们是如何从浏览器访问到我们想要的网站资源的。</li>
<li>那么对于浏览器来说，HTTP请求到底是什么样子的呢？让我们一起来跟踪查看一下！</li>
</ul>
<h2 id="环境搭建">环境搭建</h2>
<p>下载抓包工具：<a href="https://www.wireshark.org/">https://www.wireshark.org/</a></p>
<h2 id="实验过程">实验过程</h2>
<p>1.因为连接的是 WIFI，所以选择 WLAN，如下：</p>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/wireshark%E9%80%89%E6%8B%A9WLAN.png" alt="图片" loading="lazy"></figure>
<p>2.浏览器栏输入域名 <a href="http://www.baidu.com">www.baidu.com</a>（HTTPS协议）</p>
<p><a href="http://www.jszg.edu.cn/portal/home/index">http://www.jszg.edu.cn/portal/home/index</a>（HTTP协议）</p>
<p>3.Wireshark 点击停止</p>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/wireshark%E5%81%9C%E6%AD%A2.png" alt="图片" loading="lazy"></figure>
<p>4.分析处理过程</p>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/wrieshark%E5%88%86%E6%9E%90%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL 索引详解]]></title>
        <id>https://epitomm.github.io/post/mysql-suo-yin-xiang-jie/</id>
        <link href="https://epitomm.github.io/post/mysql-suo-yin-xiang-jie/">
        </link>
        <updated>2020-04-20T02:53:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="存储引擎">存储引擎</h2>
<p><code>InnoDB</code>：不加任何条件 <code>select</code> 出来的数据是排好序的（按主键字段排序）——聚簇索引。<code>MySQL</code>默认的存储引擎是 <code>InnoDB</code>。</p>
<p><code>MyISAM</code>：不加任何条件 <code>select</code> 出来的数据是没有排序的（按照插入顺序输出）——堆表</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"><code>MyISAM</code></th>
<th style="text-align:center"><code>InnoDB</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>锁级别</strong></td>
<td style="text-align:center">只有<strong>表级锁</strong></td>
<td style="text-align:center">支持<strong>行级锁和表级锁</strong>，默认为行级锁</td>
</tr>
<tr>
<td style="text-align:center">查询性能</td>
<td style="text-align:center">强调的是性能，每次查询具有原子性，执行速度快</td>
<td style="text-align:center">使用了聚簇索引、或需要访问的数据可以放入内存的应用下速度快</td>
</tr>
<tr>
<td style="text-align:center"><strong>是否支持事务</strong></td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center"><strong>是否支持崩溃后的安全恢复</strong></td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">支持。事务、回滚、崩溃修复能力和事务安全型表</td>
</tr>
<tr>
<td style="text-align:center">是否支持外键</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center">是否支持 <code>MVCC</code></td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">支持。应对高并发事务，<code>MVCC</code>比单纯的加锁更高效。<code>MVCC</code>只在<code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作；<code>MVCC</code> 可以使用乐观锁和悲观锁来实现。</td>
</tr>
<tr>
<td style="text-align:center">其他功能</td>
<td style="text-align:center">全文索引、压缩、空间函数</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="索引的分类">索引的分类</h2>
<h3 id="哈希索引">哈希索引</h3>
<ul>
<li>Hash索引底层的数据结构是<strong>哈希表</strong>。</li>
<li>Hash 索引仅仅能满足 &quot;=&quot;、&quot;IN&quot; 的<strong>等值查询</strong>，不能使用范围查询。</li>
<li>Hash 索引不能利用组合索引的<strong>部分索引键</strong>查询。</li>
<li>Hash 索引遇到大量 Hash 值相等的情况后会发生<strong>碰撞</strong>，性能不一定会比 B+树 高。</li>
</ul>
<h3 id="b树-索引">B+树 索引</h3>
<ul>
<li>B+树 索引底层的数据结构是 <strong>B+树</strong>。</li>
<li>B+树 索引支持<strong>范围查询</strong></li>
<li>B+树 索引可以使用组合索引的<strong>部分索引</strong>键查询。</li>
</ul>
<h4 id="innodb-的-b树聚簇索引"><code>InnoDB</code> 的 B+树：聚簇索引</h4>
<p><code>InnoDB</code> 中索引即数据，也就是聚簇索引的B+树的叶子节点中包含完整的数据记录。</p>
<p><code>InnoDB</code> 的 B+Tree 索引分为主索引和辅助索引。</p>
<p>主索引的叶子节点 data 域记录着<strong>完整的数据记录</strong>，这种索引方式被称为<strong>聚簇索引</strong>。</p>
<p>辅助索引的叶子节点的 data 域记录着<strong>主键的值</strong>，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>
<h5 id="聚簇索引">聚簇索引</h5>
<p>聚簇索引的特点：</p>
<ol>
<li>按<strong>主键值的大小</strong>进行记录和页的排序：</li>
</ol>
<ul>
<li>
<p>数据页(叶子节点)里的记录是按照主键值从小到大排序的一个单向链表。</p>
</li>
<li>
<p>数据页(叶子节点)之间也是是按照主键值从小到大排序的一个双向链表。</p>
</li>
<li>
<p>B+树中同一个层的页目录也是按照主键值从小到大排序的一个双向链表。</p>
</li>
</ul>
<ol start="2">
<li>B+树的<strong>叶子节点</strong>存储的是完整的用户记录，就是指这个记录中<strong>存储了所有列的值</strong>（包括隐藏列）。</li>
</ol>
<p>具有这两种特性的B+树称为<strong>聚簇索引</strong>，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在<code>MySQL</code>语句中显式的使用<code>INDEX</code>语句去创建。<code>InnoDB</code>存储引擎会自动的为我们创建聚簇索引。在<code>InnoDB</code>存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的<strong>索引即数据</strong>，数据即索引。</p>
<h4 id="myisam-的-b树非聚簇索引"><code>MyISAM</code> 的 B+树：非聚簇索引</h4>
<p><code>InnoDB</code> 中索引即数据，也就是聚簇索引的那棵B+树的叶子节点中已经把所有完整的用户记录都包含了，而<code>MyISAM</code> 的索引方案虽然也使用树形结构，但是却将<strong>索引和数据分开存储</strong>：</p>
<ul>
<li>
<p>将表中的记录按照记录的<strong>插入顺序</strong>单独存储在一个文件中，称之为数据文件。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。我们可以通过<strong>行号</strong>而快速访问到一条记录。</p>
</li>
<li>
<p>使用 <code>MyISAM</code> 存储引擎的表会把索引信息另外存储到一个称为<strong>索引文件</strong>的另一个文件中。<code>MyISAM</code>会单独为表的主键创建一个索引，只不过在索引的<strong>叶子节点</strong>中存储的不是完整的用户记录，而是<strong>主键值+行号</strong>的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录！这一点和<code>InnoDB</code>是完全不相同的，在<code>lnnoDB</code>存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在<code>MyISAM</code>中却需要进行一次回表操作，意味着<code>MyISAM</code>中建立的索引相当于全部都是二级索引！</p>
</li>
<li>
<p>如果有需要的话，我们也可以对其它的列分别建立索引或者建立联合索引，原理和<code>InnoDB</code>中的索引差不多，不过在叶子节点处存储的是相应的<strong>列+行号</strong>。这些索引也全部都是二级索引。</p>
</li>
</ul>
<blockquote>
<p>为什么不自动为每个列都建立个索引呢？</p>
<p>① 当对表中的数据进行增加、删除和修改的时候，索引也要<strong>动态的维护</strong>，这样就降低了数据的维护速度。</p>
<p>② 索引需要占<strong>物理空间</strong>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p>
<p>③ 创建索引和维护索引要<strong>耗费时间</strong>，这种时间随着数据量的增加而增加。</p>
</blockquote>
<h3 id="二级索引辅助索引">二级索引（辅助索引）</h3>
<p>聚簇索引只能在搜索条件是主键值时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。当我们想以别的列作为搜索条件时我们可以多建几棵B+树，不同的B+树中的数据采用不同的排序规则。</p>
<p>二级索引与聚簇索引有几处不同：</p>
<ol>
<li>
<p>按<strong>指定的索引列的值</strong>来进行排序</p>
</li>
<li>
<p><strong>叶子节点</strong>存储的不是完整的用户记录，而只是<strong>索引列+主键</strong>。</p>
</li>
<li>
<p>目录项记录中不是主键+页号，变成了<strong>索引列+页号</strong>。</p>
</li>
<li>
<p>在对二级索引进行查找数据时，需要根据主键值去聚簇索引中再查找一遍完整的用户记录，这个过程叫做 <strong>回表</strong></p>
</li>
</ol>
<h3 id="联合索引">联合索引</h3>
<p>以多个列的大小为排序规则建立的 B+树 称为联合索引，本质上也是一个二级索引。</p>
<h2 id="覆盖索引">覆盖索引</h2>
<h3 id="什么是覆盖索引">什么是覆盖索引</h3>
<p>如果<strong>一个索引包含（或者说覆盖）所有需要查询的字段的值</strong>，我们就称之为“覆盖索引”。我们知道在<code>InnoDB</code>存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>
<h3 id="覆盖索引使用实例">覆盖索引使用实例</h3>
<p>现在我创建了索引(username,age)，在查询数据的时候：<code>select username , age from user where username = 'Java' and age = 22</code>。要查询出的列在叶子节点都存在！所以，就不用回表。</p>
<h2 id="目录项记录的唯一性">目录项记录的唯一性</h2>
<p>我们需要保证在 B+树 的同一层内节点的目录项记录除页号这个字段以外是唯一的。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p>
<ul>
<li>
<p>索引列的值</p>
</li>
<li>
<p>主键值</p>
</li>
<li>
<p>页号</p>
</li>
</ul>
<h2 id="b树的索引总结">B+树的索引总结</h2>
<ol>
<li>
<p>每个索引都对应一棵<strong>B+树</strong>。用户记录都存储在 B+树 的叶子节点，所有目录记录都存储在非叶子节点。</p>
</li>
<li>
<p><code>InnoDB</code>存储引擎会自动为<strong>主键</strong>（如果没有它会自动帮我们添加）建立<strong>聚簇索引</strong>，聚簇索引的叶子节点包含完整的用户记录。</p>
</li>
<li>
<p>可以为指定的列建立二级索引，二级索引的叶子节点包含的用户记录由<strong>索引列 + 主键</strong>组成，所以如果想通过二级索引来查找完整的用户记录的话，需要通过<strong>回表</strong>操作，也就是在通过二级索引找到主键值之后再到聚簇索引中查找完整的用户记录。</p>
</li>
<li>
<p>B+树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是联合索引的话，则页面和记录先按照联合索引前边的列排序，如果该列值相同，再按照联合索引后边的列排序。</p>
</li>
<li>
<p>通过索引查找记录是从 B+树 的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了页目录，所以在这些页面中的查找非常快。</p>
</li>
</ol>
<p>表：</p>
<pre><code class="language-sql">create table t1(
  a int primary key, 
  b int,
  c int,
  d int, 
  e varchar(20)
)engine=InnoDB;
</code></pre>
<p>表记录：</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E8%A1%A8%E8%AE%B0%E5%BD%95.png" alt="图片" loading="lazy"></figure>
<p>创建索引：</p>
<pre><code class="language-sql">create index idx_t1_bcd on t1(b,c,d);
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B4%A2%E5%BC%95.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">自行创建索引</p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">主键索引</p>
<h2 id="索引的代价">索引的代价</h2>
<h3 id="空间上的代价">空间上的代价</h3>
<p>每建立一个索引都为要它建立一棵 B+树，每一棵 <strong>B+树 的每一个节点都是一个数据页</strong>，一个页默认会占用 <strong>16KB</strong> 的存储空间，一棵很大的 B+树 由许多数据页组成，那是很大的一片存储空间。</p>
<h3 id="时间上的代价">时间上的代价</h3>
<p>每次对表中的数据进行增、删、改操作时，都需要去修改各个 B+树 索引。而且我们讲过，B+树 每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收啥的操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的 B+树 都要进行相关的维护操作。</p>
<h2 id="b树索引实战">B+树索引实战</h2>
<h3 id="全值匹配">全值匹配</h3>
<p>如果我们的搜索条件中的列和索引列一致的话，这种情况就称为全值匹配，比方说下边这个查找语句：</p>
<pre><code class="language-sql">select * from t1 where b=1 and c=1 and d=1；
</code></pre>
<p><code>MySQL</code>中有查询优化器，会分析这些搜索条件并且按照可以使用的索引中列的顺序来决定先使用哪个搜索条件。</p>
<h3 id="匹配左边的列">匹配左边的列</h3>
<pre><code class="language-sql">select * from t1 where b=1；
select * from t1 where b=1 and c=1；
</code></pre>
<p>下面这个<code>sql</code>是用不到索引的</p>
<pre><code class="language-sql">select * from t1 where c = 1；
</code></pre>
<p>因为 B+树 的数据页和记录先是按照 b 列的值排序的，在 b 列的值相同的情况下才使用 c 列进行排序，也就是说 b 列的值不同的记录中 c 的值可能是无序的。而现在你跳过 b 列直接根据 c 的值去查找，这是做不到的。</p>
<h3 id="匹配列前缀"><strong>匹配列前缀</strong></h3>
<p>但是需要注意的是，如果只给出后缀或者中间的某个字符串，比如这样：</p>
<pre><code class="language-sql">select * from t1 where b like ''%101%';
</code></pre>
<p>MySQL 就无法快速定位记录位置了，所以只能全表扫描了。有时候我们有一些匹配某些字符串后缀的需求，比方说某个表有一个url列，该列中存储了许多url：</p>
<pre><code>www.baidu.com 

www.google.com 

www.qq.com
</code></pre>
<p>假设已经对该 url 列创建了索引，如果我们想查询以 com 为后缀的网址的话可以这样写查询条件：WHERE url LIKE '%com'，但是这样的话无法使用该 url 列的索引。为了在查询时用到这个索引而不至于全表扫描，我们可以把后缀查询改写成前缀查询，不过我们就得把表中的数据全部逆序存储一下，也就是说我们可以这样保存 url 列中的数据：</p>
<pre><code>moc.udiab.www 

moc.e1goog.www

moc.qq.www
</code></pre>
<p>这样再查找以com为后缀的网址时搜索条件便可以这么写：WHERE url LIKE 'moc%'，这样就可以用到索引了。</p>
<h3 id="匹配范围值">匹配范围值</h3>
<p>查询方式：</p>
<ul>
<li>
<p>辅助索引查询成本+回表成本</p>
</li>
<li>
<p>全表扫描成本</p>
</li>
</ul>
<p>所有记录都是按照索引列的值从小到大的顺序排好序的，所以这极大的方便我们查找索引列的值在某个范围内的记录。比方说下边这个查询语句：</p>
<pre><code>select * from t1 where b &gt; 1 and b &lt; 2000;
</code></pre>
<p>由于B+树中的数据页和记录是先按 b 列排序的，所以我们上边的查询过程其实是这样的：</p>
<ul>
<li>
<p>找到 b 值为 1 的记录。</p>
</li>
<li>
<p>找到 b 值为 20000 的记录。</p>
</li>
<li>
<p>由于所有记录都是由链表连起来的（记录之间用单链表，数据页之间用双链表），所以他们之间的记录都可以很容易的取出来</p>
</li>
<li>
<p>找到这些记录的主键值，再到聚簇索引中回表查找完整的记录。</p>
</li>
</ul>
<p>不过在使用联合进行范围查找的时候需要注意，如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到 B+树 索引，比方说这样：</p>
<pre><code class="language-sql">select * from t1 where b &gt; 1 and c &gt; 1;
</code></pre>
<p>上边这个查询可以分成两个部分：</p>
<ol>
<li>
<p>通过条件 b&gt;1 来对 b 进行范围查找，查找的结果可能有多条 b 值不同的记录，</p>
</li>
<li>
<p>对这些 b 值不同的记录继续通过 c&gt;1 继续过滤。</p>
</li>
</ol>
<p>这样子对于联合索引来说，只能用到 b 列的部分，而用不到 c 列的部分，因为只有 b 值相同的情况下才能用 c 列的值进行排序（select * from t1 where b = 1 and c &gt;1），而这个查询中通过 b 进行范围查找的记录中可能并不是按照 c 列进行排序的，所以在搜索条件中继续以 c 列进行查找时是用不到这个B+树索引的。</p>
<h3 id="精确匹配某一列并范围匹配另外一列">精确匹配某一列并范围匹配另外一列</h3>
<p>对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找，比方说这样：</p>
<pre><code class="language-sql">select * from t1 where b=1 and c&gt;1；
</code></pre>
<h3 id="排序">排序</h3>
<p>我们在写查询语句的时候经常需要对查询出来的记录通过 ORDER BY 子句按照某种规则进行排序。一般情况下，我们只能把记录都加载到内存中，再用一些排序算法，比如快速排序、归并排序等等在内存中对这些记录进行排序，有的时候可能查询的结果集太大以至于不能在内存中进行排序的话，还可能暂时借助磁盘的空间来存放中间结果，排序操作完成后再把排好序的结果集返回到客户端。在MySQL中，把这种在内存中或者磁盘上进行排序的方式统称为<strong>文件排序</strong>（英文名：filesort），这些排序操作非常慢。但是如果 ORDER BY 子句里使用到了我们的索引列，就有可能省去在内存或文件中排序的步骤，比如下边这个简单的查询语句：</p>
<pre><code class="language-sql">select * from t1 order by b，c，d
</code></pre>
<p>这个查询的结果集需要先按照 b 值排序，如果记录的 b 值相同，则需要按照 c 来排序，如果 c 的值相同，则需要按照 d 排序。因为这个 B+ 树索引本身就是按照上述规则排好序的，所以直接从索引中提取数据，然后进行回表操作取出该索引中不包含的列就好了。</p>
<h3 id="分组">分组</h3>
<pre><code class="language-sql">select b，c，d，count（*）from t1 group by b，c，d；
</code></pre>
<p>这个查询语句相当于做了3次分组操作：</p>
<ol>
<li>
<p>先把记录按照b值进行分组，所有 b 值相同的记录划分为一组。</p>
</li>
<li>
<p>将每个 b 值相同的分组里的记录再按照 c 的值进行分组，将 title 值相同的记录放到一个小分组里，所以看起来就像在一个大分组里又化分了好多小分组。</p>
</li>
<li>
<p>再将上一步中产生的小分组按照 d 的值分成更小的分组，所以整体上看起来就像是先把记录分成一个大分组，然后把大分组分成若干个小分组，然后把若干个小分组再细分成更多的小小分组。</p>
</li>
</ol>
<p>然后针对那些小小分组进行统计，比如在我们这个查询语句中就是统计每个小小分组包含的记录条数。如果没有索引的话，这个分组过程全部需要在内存里实现，而如果有了索引的话，恰巧这个分组顺序又和我们的 B+树 中的索引列的顺序是一致的，而我们的 B+树 索引又是按照索引列排好序的，所以可以直接使用 B+树 索引进行分组。</p>
<p>和使用 B+树 索引进行排序是一个道理，分组列的顺序也需要和索引列的顺序一致，也可以只使用索引列中左边的列进行分组。</p>
<h3 id="使用联合索引进行排序或分组的注意事项">使用联合索引进行排序或分组的注意事项</h3>
<p>对于联合索引有个问题需要注意，ORDER BY 的子句后边的列的顺序也必须按照索引列的顺序给出，如果给出 order by c，b 的顺序，那也是用不了 B+树 索引的。</p>
<p>同理，order by b，order by b，c 这种匹配索引左边的列的形式可以使用部分的 B+树 索引。当联合索引左边列的值为常量，也可以使用后边的列进行排序，比如这样：</p>
<pre><code class="language-sql">select * from t1 where b=1 order by c，d；
</code></pre>
<p>这个查询能使用联合索引进行排序是因为 b 列的值相同的记录是按照 c，d 排序的。</p>
<h3 id="不可以使用索引进行排序或分组的几种情况">不可以使用索引进行排序或分组的几种情况</h3>
<p><code>ASC</code>、<code>DESC</code>混用</p>
<p>对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是 <code>ASC</code> 规则排序，要么都是 <code>DESC</code> 规则排序。</p>
<blockquote>
<p>ORDER BY 子句后的列如果不加 <code>ASC</code> 或者 <code>DESC</code> 默认是按照 <code>ASC</code> 排序规则排序的，也就是升序排序的。</p>
</blockquote>
<pre><code class="language-sql">select * from t1 order by b ASC，c DESC；
</code></pre>
<p>这个查询时用不到索引的。</p>
<h2 id="如何建立索引">如何建立索引</h2>
<h3 id="考虑索引选择性">考虑索引选择性</h3>
<p>索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数的比值：</p>
<pre><code>选择性=基数/记录数
</code></pre>
<p>选择性的取值范围为（0，1]，选择性越高的索引价值越大。如果选择性等于1，就代表这个列的不重复值和表记录数是一样的，那么对这个列建立索引是非常合适的，如果选择性非常小，那么就代表这个列的重复值是很多的，不适合建立索引。</p>
<h3 id="考虑前缀索引">考虑前缀索引</h3>
<p>用列的前缀代替整个列作为索引 key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引 key 变短而减少了索引文件的大小和维护开销。</p>
<blockquote>
<p>使用mysql官网提供的示例数据库：<a href="https://dev.mysql.com/doc/employee/en/employees-installation.html">https://dev.mysql.com/doc/employee/en/employees-installation.html</a></p>
<p>github地址：<a href="https://github.com/datacharmer/test_db">https://github.com/datacharmer/test_db</a></p>
</blockquote>
<p>employees表只有一个索引&lt;emp_no&gt;，那么如果我们想按名字搜索一个人，就只能全表扫描了：</p>
<pre><code class="language-sql">EXPLAIN SELECT * FROM employees.employees WHERE first_name='Eric' AND last_name='Anido';
</code></pre>
<p>那么可以对 &lt;first_name&gt; 或 &lt;first_name，last_name&gt; 建立索引，看下两个索引的选择性：</p>
<pre><code class="language-sql">SELECT count(DISTINCT(first_name))/count(*) AS Selectivity FROM employees.employees; -- 0.0042

SELECT count(DISTINCT(concat(first_name, last_name)))/count(*) AS Selectivity FROM employees.employees; -- 0.9313
</code></pre>
<p>&lt;first_name&gt;显然选择性太低，&lt;first_name，last_name&gt;选择性很好，但是first_name和last_name加起来长度为30，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如&lt;first_name, left(last_name, 3)&gt;，看看其选择性：</p>
<pre><code class="language-sql">SELECT count(DISTINCT(concat(first_name, left(last_name, 3))))/count(*) AS Selectivity FROM employees.employees; -- 0.7879
</code></pre>
<p>选择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4：</p>
<pre><code class="language-sql">SELECT count(DISTINCT(concat(first_name, left(last_name, 4))))/count(*) AS Selectivity FROM employees.employees; -- 0.9007
</code></pre>
<p>这时选择性已很理想了，而这个索引的长度只有18，比&lt;first_name，last_name&gt;短了接近一半，建立前缀索引的方式为：</p>
<pre><code class="language-sql">ALTER TABLE employees.employees ADD INDEX first_name_last_name4 (first_name,last_name(4));
</code></pre>
<p>前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于 OFRDER BY 和 GROUP BY 操作，也不能用于覆盖索引。</p>
<h3 id="总结">总结</h3>
<ul>
<li>
<p>索引列的类型尽量小</p>
</li>
<li>
<p>利用索引字符串值的前缀</p>
</li>
<li>
<p>主键自增</p>
</li>
<li>
<p>定位并删除表中的重复和冗余索引</p>
</li>
<li>
<p>尽量使用覆盖索引进行查询，避免回表带来的性能损耗。</p>
</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<p>https://cyc2018.github.io/CS-Notes/#/notes/MySQL</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一篇文章彻底搞定 NIO]]></title>
        <id>https://epitomm.github.io/post/yi-pian-wen-zhang-che-di-gao-ding-nio/</id>
        <link href="https://epitomm.github.io/post/yi-pian-wen-zhang-che-di-gao-ding-nio/">
        </link>
        <updated>2020-04-19T06:58:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="用发展的眼光看看-bio">用发展的眼光看看 BIO</h1>
<h2 id="jdk14">JDK1.4</h2>
<ul>
<li>java.io包  XXX 类</li>
<li>BIO：Blocking IO：同步阻塞的 IO</li>
<li>Socket 应用程序：
<ul>
<li>监听端口：ServerSocket(9999);</li>
<li>获取客户端的 Socket：serverSocket.accept();</li>
<li>获取 IO 流对象，进行服务端和客户端的数据交互：socket.getInputStream()、getOutputStream()</li>
</ul>
</li>
</ul>
<h2 id="jdk14-之后">JDK1.4 之后</h2>
<ul>
<li>NIO：Non-Blocking IO 同步非阻塞</li>
<li>java.nio 包</li>
<li>对 NIO 做一个封装：netty</li>
</ul>
<h1 id="图解与代码展现bio及问题所在">图解与代码展现BIO及问题所在</h1>
<h2 id="单线程-bio">单线程 BIO</h2>
<h3 id="代码">代码</h3>
<pre><code>package com.gupao;
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
public class BIOServer {
    public static void main(String[] args) {
        byte [] bs = new byte[1024];
        List&lt;Socket&gt; list = new ArrayList&lt;&gt;();
        try(ServerSocket serverSocket = new ServerSocket(9999)) {
            System.out.println(&quot;BIOServer has started, listening on port:&quot; + serverSocket.getLocalSocketAddress());
            while (true){
                Socket clientSocket = serverSocket.accept();
                System.out.println(&quot;Connection from &quot; + clientSocket.getRemoteSocketAddress());
                // 业务处理的代码   
                try(Scanner input = new Scanner(clientSocket.getInputStream())) {
                    while (true){
                        String request = input.nextLine();
                        if(&quot;quit&quot;.equals(request)){
                            break;
                        }
                        System.out.println(String.format(&quot;From %s : %s&quot;, clientSocket.getRemoteSocketAddress(), request));
                        String response = &quot;From BIOServer Hello &quot; + request + &quot;.\n&quot;;
                        clientSocket.getOutputStream().write(response.getBytes());
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h3 id="运行结果">运行结果</h3>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E5%8D%95%E7%BA%BF%E7%A8%8BBIO%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="图片" loading="lazy"></figure>
<h3 id="分析">分析</h3>
<ul>
<li>第一个 Server 启动， 阻塞在 accept() 方法上，等待第二个 Server 的连接；</li>
<li>第二个 Server 连接上后，第一个 Server 不再阻塞在 accept() 上，继续向下运行，阻塞在 Scanner 的 nextLine() 方法上，等待第二个 Server 发送数据；</li>
<li>第二个 Server 数据准备好后，给第一个 Server 发送数据，第一个 Server 的 nextLine() 方法不再阻塞，继续向下运行，再次进行 while 循环，重新阻塞在 “等待数据准备好” 的方法上。</li>
<li>第三个 Server 进行连接，第一个 Server 无法接收到第三个 Server 连接成功请求，第三个 Server 也无法向第一个 Server 发送数据。
<ul>
<li>只有第二个 Server 通过 &quot;quit&quot; 与第一个 Server 断开连接后，第三个 Server 才能与第一个 Server 进行交互</li>
</ul>
</li>
</ul>
<p><strong>总结：不能使用两个客户端同时连接一个 Server 进行操作</strong></p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E5%8D%95%E7%BA%BF%E7%A8%8BBIO%E5%88%86%E6%9E%90.png" alt="图片" loading="lazy"></figure>
<h1 id="仔细想想bio的核心问题及解决方案">仔细想想BIO的核心问题及解决方案</h1>
<h2 id="多线程">多线程</h2>
<p><strong>那么如何同时处理多个客户端数据交互请求呢？</strong></p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E5%A4%9A%E7%BA%BF%E7%A8%8BBIO.png" alt="图片" loading="lazy"></figure>
<h2 id="线程池">线程池</h2>
<p>Client 越来越多， Server 端的线程就会越来越多，但是 Server 端的线程受 Server 端资源、CPU 影响，不能无限增大。就需要有效地<strong>控制线程的数量</strong>。</p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E7%BA%BF%E7%A8%8B%E6%B1%A0BIO.png" alt="图片" loading="lazy"></figure>
<h2 id="线程池-bio">线程池 BIO</h2>
<h3 id="代码-2">代码</h3>
<pre><code>package com.gupao;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ServerThreadPool {
    public static void main(String[] args) {
        // 线程池
        ExecutorService executor = Executors.newFixedThreadPool(2);

        RequestHandler requestHandler = new RequestHandler();
        // 监听
        try(ServerSocket serverSocket = new ServerSocket(9999)) {
            System.out.println(&quot;NIOServer has started, listening on port:&quot; + serverSocket.getLocalSocketAddress());
            while (true){
                Socket clientSocket = serverSocket.accept();
                System.out.println(&quot;Connection from &quot; + clientSocket.getRemoteSocketAddress());
                // 有客户端连接上来了，交给线程池处理
                executor.submit(new ClientHandler(clientSocket,requestHandler));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

package com.gupao;

import java.io.IOException;
import java.net.Socket;
import java.util.Scanner;

/**
 * 每个 Clinet 连接上来后，给它分配一个线程去执行对应的 Ruunable 任务
 */
public class ClientHandler implements Runnable {

    private final Socket clientSocket;
    private final RequestHandler requestHandler;

    public ClientHandler(Socket clientSocket, RequestHandler requestHandler) {
        this.clientSocket = clientSocket;
        this.requestHandler = requestHandler;
    }

    @Override
    public void run() {
        try(Scanner input = new Scanner(clientSocket.getInputStream())) {
            while (true){
                String request = input.nextLine();
                if(&quot;quit&quot;.equals(request)){
                    break;
                }
                System.out.println(String.format(&quot;From %s : %s&quot;, clientSocket.getRemoteSocketAddress(), request));
                // 真正的业务处理
                String response = requestHandler.handler(request);
                clientSocket.getOutputStream().write(response.getBytes());
            }
        } catch (IOException e) {
            System.out.println(&quot;Caught exception: &quot; + e);
            throw new RuntimeException(e);
        }
    }
}

package com.gupao;

/**
 * 业务处理代码
 */
public class RequestHandler {
    public String handler(String request){
        return &quot;From Server Hello &quot; + request + &quot;.\n&quot;;
    }
}
</code></pre>
<h3 id="运行结果-2">运行结果</h3>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/%E7%BA%BF%E7%A8%8B%E6%B1%A0BIO%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E7%BA%BF%E7%A8%8B%E6%B1%A0BIO%E7%BC%BA%E9%99%B7.png" alt="图片" loading="lazy"></figure>
<h1 id="顺其自带推导出nio的原理和代码实现">顺其自带推导出NIO的原理和代码实现</h1>
<h2 id="选择器-selector">选择器 Selector</h2>
<p>如果线程池的大小为 60，来了 60 个请求，Server 端正常应该可以同时处理这 60个请求。但是线程要想被执行的话， 一定要去抢到 CPU 的执行权，CPU 进行这 60 个线程的切换，<strong>频繁的线程上下文切换</strong>消耗 CPU 资源过多，利用率太低。多线程的情况下，线程的数量会影响 CPU 的性能，这就需要控制线程数量。</p>
<p><strong>线程创建的时机</strong></p>
<p>每来一个 Client 请求连接 accept()，就为它创建一个线程，这个线程会一直等待客户端的数据:input.nextLine();（<strong>阻塞</strong>）。</p>
<p><strong>有没有办法不阻塞</strong>？</p>
<p><strong>延迟线程创建的时机</strong>，<strong>等数据准备好以后，才去创建线程</strong>。线程的数量就会得到有效控制（有的 Client 只是连接，并不进行 IO）-&gt; CPU 用于上下文切换的时间减少 -&gt; CPU 利用率提升。</p>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/NIO%E9%80%89%E6%8B%A9%E5%99%A8.png" alt="图片" loading="lazy"></figure>
<p>注意看下面两段代码的注释：</p>
<pre><code>package com.gupao;

import java.io.IOException;
import java.net.Socket;
import java.util.Scanner;

/**
 * 每个 Clinet 连接上来后，给它分配一个线程去执行对应的 Ruunable 任务
 */
public class ClientHandler implements Runnable {

    private final Socket clientSocket;
    private final RequestHandler requestHandler;

    public ClientHandler(Socket clientSocket, RequestHandler requestHandler) {
        this.clientSocket = clientSocket;
        this.requestHandler = requestHandler;
    }

    @Override
    public void run() {
        // 说明线程已经创建了，
        try(Scanner input = new Scanner(clientSocket.getInputStream())) {
            while (true){
                // 等待客户端的输入数据 —— 阻塞的（当前虽然创建了一个线程，但它没有被用到，就浪费了。能不能等到真正处理 IO 的时候才去创建线程）
                String request = input.nextLine();
                if(&quot;quit&quot;.equals(request)){
                    break;
                }
                System.out.println(String.format(&quot;From %s : %s&quot;, clientSocket.getRemoteSocketAddress(), request));
                // 响应客户端
                String response = requestHandler.handler(request);
                clientSocket.getOutputStream().write(response.getBytes());
            }
        } catch (IOException e) {
            System.out.println(&quot;Caught exception: &quot; + e);
            throw new RuntimeException(e);
        }
    }
}
</code></pre>
<pre><code>package com.gupao;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ServerThreadPool {
    public static void main(String[] args) {
        // 线程池
        ExecutorService executor = Executors.newFixedThreadPool(2);

        RequestHandler requestHandler = new RequestHandler();
        // 监听
        try(ServerSocket serverSocket = new ServerSocket(9999)) {
            System.out.println(&quot;NIOServer has started, listening on port:&quot; + serverSocket.getLocalSocketAddress());
            while (true){
                Socket clientSocket = serverSocket.accept();
                System.out.println(&quot;Connection from &quot; + clientSocket.getRemoteSocketAddress());
                // 线程创建的时机——每个客户端来了就为它创建一个线程

//                map.put(clientSocket,&quot;Accepted&quot;);   // 不创建线程
//                什么时候创建线程 —— clientSocket 真正进行 IO 时，采取创建线程

                executor.submit(new ClientHandler(clientSocket,requestHandler));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h2 id="通道-channel">通道 Channel</h2>
<p>Client 与 Server 连接进行数据交互，然后数据再返回给 Client。</p>
<p>而在这个过程中，每次数据交互结束后，连接就会断开，</p>
<p>而建立连接需要三次握手很耗时，连接是很宝贵的，优化连接的方式：建立一条条<strong>通道</strong>。</p>
<p>连接和数据传输就在通道中进行，通道可以复用。</p>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/NIO%E9%80%9A%E9%81%93.png" alt="图片" loading="lazy"></figure>
<h2 id="缓存-buffer">缓存 Buffer</h2>
<p>阻塞/非阻塞 IO：实际上是针对的应用程序和 OS 数据之间交互的这样一种方式。</p>
<p>非阻塞 IO：OS 没有把所有数据全部传输完成，应用程序不会一直等待操作数据，应用程序允许 OS 一会传输一段数据。应用程序把每次接受到的一小段数据放到<strong>缓存</strong>内。</p>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/NIO%E7%BC%93%E5%AD%98.png" alt="图片" loading="lazy"></figure>
<p>很多情况下会发现，处理数据的时候，的确用的是多线程，但这个多线程不是为了解决 IO 阻塞问题。</p>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/NIO%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<h2 id="nio-代码">NIO 代码</h2>
<pre><code>package com.gupao;

import java.awt.image.DataBufferByte;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.util.Iterator;
import java.util.Set;

public class NIOServer {
    public static void main(String[] args) throws IOException {
        // 1.Channel 通道
        // 服务端 Channel
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        // 服务端 Channel 设置为非阻塞
        serverSocketChannel.configureBlocking(false);
        // Channel 绑定端口
        serverSocketChannel.bind(new InetSocketAddress(9999));
        System.out.println(&quot;NIOServer has started, listening on port: &quot; + serverSocketChannel.getLocalAddress());

        // 2.Selector 选择器：注册和选择哪个 Channel 进行读/写
        Selector selector = Selector.open();
        // 将连接上来的 Channel 注册到 Selector 选择器上，并且将默认状态设置为 “Accepted”
        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

        // 3.缓冲区 Buffer
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        RequestHandler requestHandler = new RequestHandler();
        // Selector 不断轮询监听有多少个客户端 Channel已经连接上了
        while (true){
            // 从 Selector 中拿到一个个客户端的 Channel
            int select = selector.select();
            if(select == 0){
                continue;
            }
            // Set 集合维护了 客户端-服务端 的 Channel（SelectionKey）
            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();
            // 迭代 set 集合，
            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();
            while (iterator.hasNext()){
                // 拿到一个 SelectionKey，SelectionKey 里面有：服务端的 ServerSocketChannel；客户端的 SocketChannel
                SelectionKey key = iterator.next();
                // 如果有一个客户端的 Channel 连接上来了（状态为“Accepted”），需要进行读/写操作
                if(key.isAcceptable()){
                    // 根据 SelectionKey 获得 ServerSocketChannel
                    ServerSocketChannel channel = (ServerSocketChannel) key.channel();
                    // 根据 ServerSocketChannel 获得 SocketChannel
                    SocketChannel clientChannel = channel.accept();
                    System.out.println(&quot;Connection from &quot; + clientChannel.getRemoteAddress());
                    // 客户端 Channel 设置为非阻塞
                    clientChannel.configureBlocking(false);
                    // 将 Channel 的状态改变为 READ，说明该 Channel 要读数据了
                    clientChannel.register(selector, SelectionKey.OP_READ);
                }

                // 如果 Channel 的状态为 Read，可以进行 读操作了。
                // 处理读操作：还是放在 main 线程中，而不是为这个 Client 请求创建一个新的线程
                if(key.isReadable()){
                    // 获取到 客户端 Channel
                    SocketChannel channel = (SocketChannel) key.channel();
                    // 数据放到 Buffer 中
                    channel.read(buffer);
                    String request = new String(buffer.array()).trim();
                    buffer.clear();
                    System.out.println(String.format(&quot;From %s : %s&quot;, channel.getRemoteAddress(),request));
                    // 给客户端一个响应
                    String response = requestHandler.handler(request);
                    channel.write(ByteBuffer.wrap(response.getBytes()));
                }
                iterator.remove();
            }
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL —— Explain 关键字]]></title>
        <id>https://epitomm.github.io/post/mysql-explain-guan-jian-zi/</id>
        <link href="https://epitomm.github.io/post/mysql-explain-guan-jian-zi/">
        </link>
        <updated>2020-04-18T15:17:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="explain-关键字">Explain 关键字</h1>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>列名</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">id</td>
<td style="text-align:left">在一个大的查询语句中每个SELECT关键字都对应一个唯一的id</td>
</tr>
<tr>
<td style="text-align:left">select_type</td>
<td style="text-align:left">SELECT关键字对应的那个查询的类型</td>
</tr>
<tr>
<td style="text-align:left">table</td>
<td style="text-align:left">表名</td>
</tr>
<tr>
<td style="text-align:left">partitions</td>
<td style="text-align:left">匹配的分区信息</td>
</tr>
<tr>
<td style="text-align:left"><strong>type</strong></td>
<td style="text-align:left"><strong>针对单表的访问方法</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>possible_keys</strong></td>
<td style="text-align:left"><strong>可能用到的索引</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>key</strong></td>
<td style="text-align:left"><strong>实际上使用的索引</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>key_len</strong></td>
<td style="text-align:left"><strong>实际使用到的索引长度</strong></td>
</tr>
<tr>
<td style="text-align:left">ref</td>
<td style="text-align:left">当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td>
</tr>
<tr>
<td style="text-align:left">rows</td>
<td style="text-align:left">预估的需要读取的记录条数</td>
</tr>
<tr>
<td style="text-align:left">filtered</td>
<td style="text-align:left">某个表经过搜索条件过滤后剩余记录条数的百分比</td>
</tr>
<tr>
<td style="text-align:left"><strong>Extra</strong></td>
<td style="text-align:left"><strong>一些额外的信息</strong></td>
</tr>
</tbody>
</table>
<h2 id="table">table</h2>
<p>表名</p>
<pre><code>mysql&gt; explain select * from t1 join t2; 
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/table.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">explain select * from t1 join t2; </p>
<h2 id="id">id</h2>
<p>我们写的查询语句一般都以SELECT关键字开头，比较简单的查询语句里只有一个SELECT关键字，但是下边两种情况下在一条查询语句中会出现多个SELECT关键字：</p>
<ul>
<li>查询中包含子查询的情况</li>
<li>查询中包含UNION语句的情况</li>
</ul>
<p>查询语句中每出现<strong>一个SELECT关键字</strong>，MySQL就会为它分配<strong>一个唯一的id值</strong>。这个id值就是EXPLAIN语句的第一个列。对于连接查询来说，一个SELECT关键字后边的<strong>FROM子句中可以跟随多个表</strong>，所以在连接查询的执行计划中，<strong>每个表都会对应一条记录，但是这些记录的id值都是相同的。</strong></p>
<pre><code>mysql&gt; explain select * from t1 join t2; 
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/id1.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">一个 select 关键字，两条记录 id 值相同</p>
<blockquote>
<p>在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，出现在前边的表是驱动表，出现在后边的表是被驱动表</p>
</blockquote>
<p>对于<strong>包含子查询的</strong>查询语句来说，就可能涉及<strong>多个SELECT</strong>关键字，所以在包含子查询的查询语句的执行计划中，<strong>每个SELECT关键字都会对应一个唯一的id值</strong>，比如这样：</p>
<pre><code>mysql&gt; explain select * from t1 where a in (select a from t2) or c = 'c'; 
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/id2.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体"> 两个 select 关键字，两个不同的 id  值</p>
<p>但是这里大家需要特别注意，<strong>查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询</strong>。所以如果我们想知道查询优化器对某个包含子查询的语句是否进行了重写，直接查看执行计划就好了，比如说：</p>
<pre><code>mysql&gt; explain select * from t1 where a in (select a from t2); 
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E5%B0%86%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E4%B8%BA%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">查询优化器将子查询优化为连接查询</p>
<p>可以看到，虽然我们的查询语句是一个子查询，但是执行计划中t1和t2表对应的记录的id值全部是1，这就表明了<strong>查询优化器将子查询转换为了连接查询</strong>。</p>
<p>对<strong>于包含UNION子句的查询语句来说，每个SELECT关键字对应一个id值</strong>也是没错的，不过还是有点儿特别的东西，比方说下边这个查询：</p>
<pre><code>mysql&gt; explain select * from t1 union select * from t2; 
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/union%E5%8E%BB%E9%87%8D.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">union 去重</p>
<p>这个语句的执行计划的第三条记录是什么？为什么id值是NULL？UNION会把多个查询的结果集合并起来并对结果集中的记录进行去重，怎么去重呢？MySQL使用的是内部的临时表。正如上边的查询计划中所示，<strong>UNION子句是为了把id为1的查询和id为2的查询的结果集合并起来并去重，所以在内部创建了一个名为的临时表</strong>（就是执行计划第三条记录的table列的名称），id为NULL表明这个临时表是为了合并两个查询的结果集而创建的。</p>
<p>跟UNION对比起来，<strong>UNION ALL就不需要为最终的结果集进行去重</strong>，它只是单纯的把多个查询的结果集中的记录合并成一个并返回给用户，所以也就不需要使用临时表。所以在包含UNION ALL子句的查询的执行计划中，就没有那个id为NULL的记录，如下所示：</p>
<pre><code>mysql&gt; explain select * from t1 union all select * from t2; 
+----+-------------+-------+------------+------+---------------+------+---------+----- 
-+------+----------+-------+ 
| id | select_type | table | partitions | type | possible_keys | key | key_len | ref  
| rows | filtered | Extra | 
+----+-------------+-------+------------+------+---------------+------+---------+----- 
-+------+----------+-------+ 
| 1 | PRIMARY | t1 | NULL | ALL | NULL | NULL | NULL | NULL 
| 8 | 100.00 | NULL | 
| 2 | UNION | t2 | NULL | ALL | NULL | NULL | NULL | NULL 
| 8 | 100.00 | NULL | 
+----+-------------+-------+------------+------+---------------+------+---------+----- 
-+------+----------+-------+ 
2 rows in set, 1 warning (0.00 sec) 
</code></pre>
<h2 id="select_type">select_type</h2>
<p>每一个SELECT关键字代表的小查询都定义了一个称之为select_type的属性，意思是我们只要知道了某个小查询的select_type属性，就知道了这个小查询在整个大查询中扮演了一个什么角色。</p>
<h3 id="simple">SIMPLE</h3>
<p>查询语句中<strong>不包含UNION或者子查询的查询</strong>都算作是SIMPLE类型。</p>
<pre><code>mysql&gt; explain select * from t1; 
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2SIMPLE.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">简单查询 select_type = SIMPLE</p>
<p>连接查询也算是SIMPLE类型</p>
<pre><code>mysql&gt; explain select * from t1 join t2; 
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2SIMPLE.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">连接查询 select_type = SIMPLE</p>
<h3 id="primary">PRIMARY</h3>
<p>对于包含UNION、UNION ALL或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的 select_type值就是PRIMARY，比方说：</p>
<pre><code>mysql&gt; explain select * from t1 where a in (select a from t2) or c = 'c'; 
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/PRIMARY.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">主查询的 select_type = PRIMARY；子查询的 select_type = SUBQUERY</p>
<p>从结果中可以看到，最左边的小查询select * from t1对应的是执行计划中的第一条记录，它的select_type值就是 PRIMARY。</p>
<h3 id="union">UNION</h3>
<p>对于包含UNION或者UNION ALL的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外， 其余的小查询的select_type值就是UNION。</p>
<pre><code>mysql&gt; explain select * from t1 union select * from t2; 
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/UNION.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">UNION 查询的最左边查询 select_type = RIMARY，其余小查询的 select_type = UNION</p>
<h3 id="union-result">UNION RESULT</h3>
<p>MySQL选择使用临时表来完成UNION查询的去重工作，针对该临时表的查询的select_type就是UNION RESULT，例子上边有。</p>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/UNION_RESULT.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">union 查询中临时表的 select_type = UNION RESULT</p>
<h3 id="subquery">SUBQUERY</h3>
<p><strong>非相关子查询</strong>，由于 select_type 为 SUBQUERY 的子查询由于会被物化，所以<strong>只需要执行一遍。</strong></p>
<pre><code>mysql&gt; explain select * from t1 where a in (select a from t2) or c = 'c'; 
</code></pre>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/SUBQUERY.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">非相关子查询 select_type = SUBQUERY</p>
<h3 id="dependent-subqurey">DEPENDENT SUBQUREY</h3>
<p><strong>相关子查询</strong>，select_type 为 DEPENDENT SUBQUERY 的查询可能<strong>会被执行多次</strong></p>
<pre><code>mysql&gt; explain select * from t1 where a in (select a from t2 where t1.a = t2.a) or c = 'c'; 
</code></pre>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/DEPENDENT_SUBQUREY.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">相关子查询 select_type = DEPENDENT SUBQUERY</p>
<h3 id="derived">DERIVED</h3>
<pre><code>mysql&gt; explain select * from (select a, count(*) from t2 group by a ) as deliver1; 
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/DERIVED.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">派生表 select_type = DRIVED </p>
<p>从执行计划中可以看出，id为2的记录就代表子查询的执行方式，它的select_type是DERIVED，说明该子查询是以物化的方式执行的。id为1的记录代表外层查询，大家注意看它的table列显示的是<derived2>，表示该查询是针对将派生表物化之后的表进行查询的。</p>
<h3 id="materialized">MATERIALIZED</h3>
<p>当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的 select_type属性就是MATERIALIZED。</p>
<pre><code>mysql&gt; explain select * from t1 where a in (select c from t2 where e = 1);
</code></pre>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/MATERIALIZED.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">物化表 select_type = MATERIALIZED </p>
<blockquote>
<p>将子查询出来的结果集放到一个物化表内，再将物化表与外层查询进行连接查询。</p>
</blockquote>
<h2 id="type">TYPE</h2>
<p>访问方法（全表扫描还是走哪个索引）</p>
<h3 id="system">system</h3>
<p>当<strong>表中只有一条记录并且该表使用的存储引擎的统计数据是精确</strong>的，比如MyISAM、Memory，那么对该表的访问方法就是system。比方说我们新建一个MyISAM表，并为其插入一条记录：</p>
<p>创建表 t</p>
<pre><code>mysql&gt; CREATE TABLE t(i int) Engine=MyISAM; 
Query OK, 0 rows affected (0.05 sec) 
</code></pre>
<p>向 t 表内插入一条数据</p>
<pre><code>mysql&gt; INSERT INTO t VALUES(1); 
Query OK, 1 row affected (0.01 sec)
</code></pre>
<p>执行 explain 语句</p>
<pre><code>mysql&gt; explain select * from t; 
</code></pre>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/system.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">表中只有一条数据、存储引擎精确统计 type = system</p>
<h3 id="const">const</h3>
<p>当我们根据<strong>主键</strong>或者<strong>唯一二级索引列</strong>与<strong>常数</strong>进行<strong>等值匹配时</strong>，对单表的访问方法就是const。</p>
<pre><code>mysql&gt; explain select * from t1 where a = 1; 
</code></pre>
<figure data-type="image" tabindex="16"><img src="https://epitomm.github.io/post-images/const.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">根据主键与常数进行等职匹配 type = const</p>
<h3 id="eq_ref">eq_ref</h3>
<p>在连接查询时，如果<strong>被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的</strong>（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是eq_ref</p>
<pre><code>mysql&gt; explain select * from t1 join t2 on t1.a = t2.a; 
</code></pre>
<figure data-type="image" tabindex="17"><img src="https://epitomm.github.io/post-images/eq_ref.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">被驱动表通过主键等值匹配的方式访问，被驱动表的 type = eq_ref</p>
<h3 id="ref">ref</h3>
<p>当通过<strong>普通的二级索引列</strong>与<strong>常量</strong>进行<strong>等值匹配</strong>时来查询某个表，那么对该表的访问方法就可能是ref。</p>
<p>查看所有索引：</p>
<pre><code>show keys for t1;
</code></pre>
<figure data-type="image" tabindex="18"><img src="https://epitomm.github.io/post-images/%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%B4%A2%E5%BC%95.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">查看所有索引</p>
<pre><code>mysql&gt; explain select * from t1 where b = 1; 
</code></pre>
<figure data-type="image" tabindex="19"><img src="https://epitomm.github.io/post-images/ref.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">当通过普通的二级索引列与常量进行等值匹配时来查询某个表 type = ref</p>
<h3 id="ref_of_null">ref_of_null</h3>
<p>当对<strong>普通二级索引进行等值匹配查询</strong>，<strong>该索引列的值也可以是NULL值</strong>时，那么对该表的访问方法就可能是 ref_or_null</p>
<pre><code>mysql&gt; explain select * from t1 where b = 1 or b is null; 
</code></pre>
<figure data-type="image" tabindex="20"><img src="https://epitomm.github.io/post-images/ref_of_null.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">对普通二级索引进行等值匹配查询，该索引列的值也可以是NULL值 type = ref_of_null</p>
<h3 id="index_merge">index_merge</h3>
<p><strong>索引合并</strong></p>
<pre><code>mysql&gt; explain select * from t1 where a = 1 or b = 1; 
</code></pre>
<figure data-type="image" tabindex="21"><img src="https://epitomm.github.io/post-images/index_merge.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">索引合并 type = index_merge</p>
<h3 id="unique_subquery">unique_subquery</h3>
<p>如果<strong>查询优化器决定将IN子查询转换为EXISTS子查询，<strong>而且</strong>子查询可以使用到主键进行等值匹配</strong>的话，那么该子查询执行计划的type列的值就是unique_subquery。</p>
<pre><code>mysql&gt; explain select * from t1 where c in (select a from t2 where t1.e = t2.e) or a = 1;
</code></pre>
<p>以上查询可以优化为 EXISTS 子查询：</p>
<pre><code>mysql&gt; explain select * from t1 where exists(select a from t2 where t1.e = t2.e and t1.c = t2.a) or a = 1
</code></pre>
<figure data-type="image" tabindex="22"><img src="https://epitomm.github.io/post-images/unique_subquery.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">查询优化器将IN子查询转换为EXISTS子查询，而且子查询可以使用到主键进行等值匹配 </p>
<p>type = unique_subquery</p>
<h3 id="index_subquery">index_subquery</h3>
<p>index_subquery与unique_subquery类似，只不过访问子查询中的表时使用的是普通的索引。</p>
<pre><code>mysql&gt; explain select * from t1 where c in (select b from t2 where t1.e = t2.e) or a = 1;
+----+--------------------+-------+------------+----------------+---------------+----- 
---------+---------+------+------+----------+-------------+ 
| id | select_type | table | partitions | type | possible_keys | key  
| key_len | ref | rows | filtered | Extra | 
+----+--------------------+-------+------------+----------------+---------------+----- 
---------+---------+------+------+----------+-------------+ 
| 1 | PRIMARY | t1 | NULL | ALL | PRIMARY | NULL  
| NULL | NULL | 9 | 100.00 | Using where | 
| 2 | DEPENDENT SUBQUERY | t2 | NULL | index_subquery | idx_t2_b_c_d | 
idx_t2_b_c_d | 5 | func | 1 | 12.50 | Using where | 
+----+--------------------+-------+------------+----------------+---------------+----- 
---------+---------+------+------+----------+-------------+ 
2 rows in set, 2 warnings (0.00 sec) 
</code></pre>
<h3 id="range">range</h3>
<p>范围查询</p>
<pre><code>mysql&gt; explain select * from t1 where a &gt; 1; 
</code></pre>
<figure data-type="image" tabindex="23"><img src="https://epitomm.github.io/post-images/%E5%A4%A7%E4%BA%8E_range.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">a > 1 type = range</p>
<pre><code>mysql&gt; explain select * from t1 where a in (1);
</code></pre>
<figure data-type="image" tabindex="24"><img src="https://epitomm.github.io/post-images/in_range.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">a in (1) type = const</p>
<pre><code>mysql&gt; explain select * from t1 where a in (1,2);
</code></pre>
<figure data-type="image" tabindex="25"><img src="https://epitomm.github.io/post-images/in_range2.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">a in (1,2) type = range</p>
<h3 id="index">index</h3>
<p>当我们可以使用覆盖索引，但<strong>需要扫描全部的索引记录</strong>时，该表的访问方法就是index。</p>
<p>遍历索引上的所有叶子节点，因为B+树所有数据都存储在叶子节点上，而非叶子结点是用来过滤筛选条件的。</p>
<pre><code>mysql&gt; explain select a from t1; 
</code></pre>
<figure data-type="image" tabindex="26"><img src="https://epitomm.github.io/post-images/index_1.png" alt="图片" loading="lazy"></figure>
<p>使用辅助索引没有使用主键索引的原因：辅助索引体积较小，辅助索引只存储字段b、c、d和主键a字段；而主索引存储所有字段值。</p>
<pre><code>mysql&gt; explain select b from t1;
</code></pre>
<figure data-type="image" tabindex="27"><img src="https://epitomm.github.io/post-images/index_2.png" alt="图片" loading="lazy"></figure>
<pre><code>mysql&gt; ecplain select e from t1;
</code></pre>
<figure data-type="image" tabindex="28"><img src="https://epitomm.github.io/post-images/index_3.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">e 字段没有索引，所以 type = ALL</p>
<h3 id="all">ALL</h3>
<p>全表扫描</p>
<h2 id="possible_keys-和-key">possible_keys 和 key</h2>
<p>possible_keys列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些，key列表示实际用到的索引有哪些。</p>
<p>不过有一点比较特别，就是在使用index访问方法来查询某个表时，possible_keys列是空的，而key列展示的是实际使用到的索引 。</p>
<blockquote>
<p>possible_keys列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长 时间，所以如果可以的话，尽量删除那些用不到的索引</p>
</blockquote>
<h2 id="key_len">key_len</h2>
<p>key_len列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度，它是由这三个部分构成的：</p>
<ul>
<li>对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是VARCHAR(100)，使用的字符集是 utf8，那么该列实际占用的最大存储空间就是100 × 3 = 300个字节。</li>
<li>如果该索引列可以存储NULL值，则key_len比不可以存储NULL值时多1个字节。</li>
<li>对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。</li>
</ul>
<figure data-type="image" tabindex="29"><img src="https://epitomm.github.io/post-images/key_len.png" alt="图片" loading="lazy"></figure>
<h2 id="ref-2">ref</h2>
<p>当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是const、eq_ref、ref、ref_or_null、 unique_subquery、index_subquery其中之一时，ref列展示的就是与索引列作等值匹配的东西是什么，比如只是一个常数或者是某个列。</p>
<pre><code>mysql&gt; explain select b from t1 where b = 1; 
</code></pre>
<figure data-type="image" tabindex="30"><img src="https://epitomm.github.io/post-images/ref_1.png" alt="图片" loading="lazy"></figure>
<pre><code>mysql&gt; explain select * from t1 where a in (select a from t2); 
</code></pre>
<figure data-type="image" tabindex="31"><img src="https://epitomm.github.io/post-images/ref_2.png" alt="图片" loading="lazy"></figure>
<h2 id="rows">rows</h2>
<p>如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的rows列就代表预计需要扫描的行数， 如果使用索引来执行查询时，执行计划的rows列就代表预计扫描的索引记录行数。</p>
<h2 id="filtered">filtered</h2>
<p>代表查询优化器预测在这扫描的记录中，有多少条记录满足其余的搜索条件。</p>
<pre><code>mysql&gt; explain select * from t1 where a &gt; 1 and e = 1; 
+----+-------------+-------+------------+-------+---------------+---------+---------+- 
-----+------+----------+-------------+ 
| id | select_type | table | partitions | type | possible_keys | key | key_len | 
ref | rows | filtered | Extra | 
+----+-------------+-------+------------+-------+---------------+---------+---------+- 
-----+------+----------+-------------+ 
| 1 | SIMPLE | t1 | NULL | range | PRIMARY | PRIMARY | 4 | 
NULL | 8 | 11.11 | Using where | 
+----+-------------+-------+------------+-------+---------------+---------+---------+- 
-----+------+----------+-------------+ 
1 row in set, 1 warning (0.00 sec) 
</code></pre>
<p>从执行计划的key列中可以看出来，该查询使用PRIMARY索引来执行查询，从rows列可以看出满足a &gt; 1的记录有 8条。执行计划的filtered列就代表查询优化器预测在这8条记录中，<strong>有多少条记录满足其余的搜索条件</strong>，也就是e = 1这个条件的百分比。此处filtered列的值是11.11，说明查询优化器预测在8条记录中有11.11%的记录满足e = 1 这个条件。<br>
对于单表查询来说，这个 filtered 列的值没什么意义，我们更关注在连接查询中驱动表对应的执行计划记录的  filtered 值，比方说下边这个查询：</p>
<pre><code>mysql&gt; explain select * from t1 join t2 on t1.a = t2.a where t1.e = 1; 
+----+-------------+-------+------------+--------+---------------+---------+--------- 
+------------+------+----------+-------------+ 
| id | select_type | table | partitions | type | possible_keys | key | key_len | 
ref | rows | filtered | Extra | 
+----+-------------+-------+------------+--------+---------------+---------+--------- 
+------------+------+----------+-------------+ 
| 1 | SIMPLE | t1 | NULL | ALL | PRIMARY | NULL | NULL | 
NULL | 9 | 11.11 | Using where | 
| 1 | SIMPLE | t2 | NULL | eq_ref | PRIMARY | PRIMARY | 4 | 
luban.t1.a | 1 | 100.00 | NULL | 
+----+-------------+-------+------------+--------+---------------+---------+--------- 
+------------+------+----------+-------------+ 
2 rows in set, 1 warning (0.00 sec) 
</code></pre>
<p>从执行计划中可以看出来，查询优化器打算把t1当作驱动表，t2当作被驱动表。我们可以看到驱动表t1表的执行计划的rows列为9， filtered 列为11.11，这意味着驱动表t1表经过条件过滤后有9 × 11.11% = 0.9999条记录，这说明还<strong>要对被驱动表执行大约1次(row * filtered)查询</strong>。</p>
<h2 id="extra">Extra</h2>
<p>Extra列是用来说明一些额外信息的，我们可以通过这些额外信息来更准确的理解MySQL到底将如何执行给定的查询语句。</p>
<h3 id="no-tables-used">No tables used</h3>
<p>当<strong>查询语句的没有FROM子句</strong>时将会提示该额外信息。</p>
<pre><code>mysql&gt; explain select 1; 
</code></pre>
<figure data-type="image" tabindex="32"><img src="https://epitomm.github.io/post-images/Notablesused.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">查询语句没有 FROM 子句时：Extra = No tables used</p>
<h3 id="impossible-where">Impossible WHERE</h3>
<p><strong>查询语句的WHERE子句永远为FALSE</strong>时将会提示该额外信息。</p>
<pre><code>mysql&gt; explain select b from t1 where 1=0; 
</code></pre>
<figure data-type="image" tabindex="33"><img src="https://epitomm.github.io/post-images/ImpossibleWHERE.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">WHERE 子句永远为 FALSE时：Extra = Impossible WHERE</p>
<h3 id="no-matching-minmax-row">No matching min/max row</h3>
<p>当<strong>查询列表处有MIN或者MAX聚集函数，但是并没有符合WHERE子句中的搜索条件的记录</strong>时，将会提示该额外信息。</p>
<pre><code>mysql&gt; explain select max(a) from t1 where a=100; 
</code></pre>
<figure data-type="image" tabindex="34"><img src="https://epitomm.github.io/post-images/No_matching_minmax_row.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">查询列表处有MIN或者MAX聚集函数，但是并没有符合WHERE子句中的搜索条件的记录时：Extra = No matching min/max row</p>
<h3 id="using-index">Using index</h3>
<p>当我们的<strong>查询列表以及搜索条件中只包含属于某个索引的列</strong>，也就是在<strong>可以使用索引覆盖</strong>的情况下，在Extra列将会提示该额外信息。</p>
<p>辅助索引包含 b、c、d 字段，根据查询条件 b=1 找到字段 d 的值，无需回表。</p>
<pre><code>mysql&gt; explain select d from t1 where b =1; 
</code></pre>
<figure data-type="image" tabindex="35"><img src="https://epitomm.github.io/post-images/UsingIndex.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">覆盖索引 Extra = Using index</p>
<h3 id="using-index-condition">Using index condition</h3>
<p>有些<strong>搜索条件中虽然出现了索引列，但却不能使用到索引</strong>（在MySQL 5.6版本后加入的新特性）</p>
<figure data-type="image" tabindex="36"><img src="https://epitomm.github.io/post-images/Using_index_condition.png" alt="图片" loading="lazy"></figure>
<pre><code>mysql&gt; explain select * from t1 where b =1 and c like '%1'; 
</code></pre>
<figure data-type="image" tabindex="37"><img src="https://epitomm.github.io/post-images/Using_index_condition2.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">搜索条件中虽然出现了索引列，但却不能使用到索引 Extra = Using index condition</p>
<h3 id="using-where">Using where</h3>
<p>当我们使用<strong>全表扫描来执行对某个表的查询，并且该语句的WHERE子句中有针对该表的搜索条件时</strong>，在Extra列中会提示上述额外信息。</p>
<pre><code>mysql&gt; explain select * from t1 where e = 1; 
</code></pre>
<figure data-type="image" tabindex="38"><img src="https://epitomm.github.io/post-images/UsingWhere.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">全表扫描来执行对某个表的查询，并且该语句的WHERE子句中有针对该表的搜索条件时：Extra = Using where</p>
<h3 id="using-joinbufferblock-nested-loop">Using joinbuffer(Block Nested Loop)</h3>
<p>在<strong>连接查询</strong>执行过程中，当被驱动表<strong>不能有效的利用索引</strong>加快访问速度，MySQL一般会为其分配一块名叫join buffer 的内存块来加快查询速度。</p>
<pre><code>mysql&gt; explain select * from t1 join t2 on t1.e = t2.e; 
</code></pre>
<figure data-type="image" tabindex="39"><img src="https://epitomm.github.io/post-images/Using_joinbuffer.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">连接查询不能用到索引，分配 join buffer 内存块：Extra = Using join buffer</p>
<p>可以在对t2表的执行计划的Extra列显示了两个提示：</p>
<ul>
<li>Using join buffer (Block Nested Loop)：这是因为对表t2的访问不能有效利用索引，只好退而求其次，使用join buffer来减少对t2表的访问次数，从而提高性能。</li>
<li>Using where：可以看到查询语句中有一个t1.e = t2.e条件，因为t1是驱动表，t2是被驱动表，所以在访问t2表时，t1.e的值已经确定下来了，所以实际上查询t2表的条件就是t2.e = 一个常数，所以提示了Using where额外信息。</li>
</ul>
<h3 id="using-filesort">Using filesort</h3>
<p>很多情况下排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）进行排序，这种<strong>在内存中或者磁盘上进行排序的方式统称为文件排序</strong>（英文名：filesort）。如果<strong>某个查询需要使用文件排序的方式执行查询</strong>，就会在执行计划的Extra列中显示Using filesort提示。</p>
<pre><code>mysql&gt; explain select * from t1 order by e; 
</code></pre>
<figure data-type="image" tabindex="40"><img src="https://epitomm.github.io/post-images/Using_filesort.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">排序 Extra = Using filesort</p>
<h3 id="using-temporary">Using temporary</h3>
<p>在许多查询的执行过程中，MySQL可能会借助<strong>临时表</strong>来完成一些功能，比如<strong>去重、排序</strong>之类的，比如我们在执行许多包含<strong>DISTINCT、GROUP BY、UNION</strong>等子句的查询过程中，如果<strong>不能</strong>有效<strong>利用索引</strong>来完成查询，MySQL很有可能寻求通过<strong>建立内部的临时表</strong>来执行查询。如果查询中使用到了内部的临时表，在执行计划的Extra列将会显示Using temporary提示。</p>
<p>能利用索引：</p>
<pre><code>mysql&gt; explain select distinct b from t1; 
</code></pre>
<figure data-type="image" tabindex="41"><img src="https://epitomm.github.io/post-images/Using_temporary.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">利用索引distinct：Extra = Using index</p>
<p>不能利用索引</p>
<pre><code>mysql&gt; explain select distinct e from t1; 
</code></pre>
<figure data-type="image" tabindex="42"><img src="https://epitomm.github.io/post-images/Using_temporary2.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">不能利用索引的 distinct，建立内部临时表：Extra = Using temporary</p>
<p>即有Using temporary，又有Using filesort，因为group by默认会先排序 （Using filesort）</p>
<pre><code>mysql&gt; explain select e, count(1) from t1 group by e; 
</code></pre>
<figure data-type="image" tabindex="43"><img src="https://epitomm.github.io/post-images/Using_temporary3.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">Extra = Using temporary; Using filesort</p>
<p>使用order by null禁用排序</p>
<pre><code>mysql&gt; explain select e, count(1) from t1 group by e order by null; 
</code></pre>
<figure data-type="image" tabindex="44"><img src="https://epitomm.github.io/post-images/Using_temporary4.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">禁用排序，Extra = Using temporary</p>
<h3 id="start-temporary-end-temporary">Start temporary、End temporary</h3>
<p><strong>查询优化器会优先尝试将IN子查询转换成semi-join</strong>，而semi-join又有好多种执行策略，当执行策略为 <strong>DuplicateWeedout <strong>时，也就是通过</strong>建立临时表</strong>来实现为外层查询中的记录进行<strong>去重</strong>操作时，<strong>驱动表</strong>查询执行计划的Extra列将显示<strong>Start temporary</strong>提示，<strong>被驱动表</strong>查询执行计划的Extra列将显示<strong>End temporary</strong>提示</p>
<pre><code>mysql&gt; explain select * from t1 where a in (select e from t2 where e = 1); 
</code></pre>
<figure data-type="image" tabindex="45"><img src="https://epitomm.github.io/post-images/Start_temporary.png" alt="图片" loading="lazy"></figure>
<h3 id="firstmatch表名">FirstMatch（表名）</h3>
<p>在将In子查询转为semi-join时，如果采用的是<strong>FirstMatch</strong>执行策略，则在<strong>被驱动表</strong>执行计划的Extra列就是显示 **FirstMatch(tbl_name)**提示。</p>
<pre><code>mysql&gt; explain select * from t1 where a in (select c from t2 where c = 1); 
</code></pre>
<figure data-type="image" tabindex="46"><img src="https://epitomm.github.io/post-images/FirstMatch.png" alt="图片" loading="lazy"></figure>
<h1 id="总结">总结</h1>
<h2 id="性能按-type-排序">性能按 type 排序</h2>
<p>system &gt; const &gt; eq_ref &gt; ref &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p>
<h2 id="性能按-extra-排序">性能按 Extra 排序</h2>
<ul>
<li>Using index：用了覆盖索引</li>
<li>Using index condition：用了条件索引（索引下推）</li>
<li>Using where：从索引查出来数据后继续用where条件过滤</li>
<li>Using join buffer (Block Nested Loop)：join的时候利用了join buffer（优化策略：去除外连接、增 大join buffer大小）</li>
<li>Using filesort：用了文件排序，排序的时候没有用到索引</li>
<li>Using temporary：用了临时表（优化策略：增加条件以减少结果集、增加索引，思路就是要么减少待排序的数量，要么就提前排好序）</li>
<li>Start temporary, End temporary：子查询的时候，可以优化成半连接，但是使用的是通过临时表来去重</li>
<li>FirstMatch(tbl_name)：子查询的时候，可以优化成半连接，但是使用的是直接进行数据比较来去重</li>
</ul>
<h2 id="常见的优化手段">常见的优化手段</h2>
<ol>
<li>SQL语句中IN包含的值不应过多，不能超过200个，200个以内查询优化器计算成本时比较精准，超过200 个是估算的成本，另外建议能用between就不要用in，这样就可以使用range索引了。</li>
<li>SELECT语句务必指明字段名称：SELECT * 增加很多不必要的消耗（cpu、io、内存、网络带宽）；增加了使用覆盖索引的可能性；当表结构发生改变时，前端也需要更新。所以要求直接在select后面接上字段名。</li>
<li>当只需要一条数据的时候，使用limit 1</li>
<li>排序时注意是否能用到索引</li>
<li>使用 or 时如果没有用到索引，可以改为union all 或者union</li>
<li>如果in不能用到索引，可以改成exists看是否能用到索引</li>
<li>使用合理的分页方式以提高分页的效率</li>
<li>不建议使用%前缀模糊查询</li>
<li>避免在where子句中对字段进行表达式操作</li>
<li>避免隐式类型转换 （字符 ‘a’ -&gt; 数字 0，数字 !-&gt; 字符）</li>
<li>对于联合索引来说，要遵守最左前缀法则</li>
<li>必要时可以使用force index来强制查询走某个索引</li>
<li>对于联合索引来说，如果存在范围查询，比如between,&gt;,&lt;等条件时，会造成后面的索引字段失效。</li>
<li>尽量使用inner join，避免left join，让查询优化器来自动选择小表作为驱动表</li>
<li>必要时刻可以使用straight_join来指定驱动表，前提条件是本身是inner join</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode53. 最大子序和]]></title>
        <id>https://epitomm.github.io/post/leetcode53-zui-da-zi-xu-he/</id>
        <link href="https://epitomm.github.io/post/leetcode53-zui-da-zi-xu-he/">
        </link>
        <updated>2020-04-16T14:01:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<h2 id="示例">示例:</h2>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>
输出: 6</p>
<p>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<p>进阶:<br>
如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<h2 id="分析">分析</h2>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>当前数字</strong></th>
<th style="text-align:center"><strong>连续子序列最大和 maxSum</strong></th>
<th style="text-align:center"><strong>子序列当前累加和 cur</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">-8</td>
<td style="text-align:center"></td>
<td style="text-align:center">-6</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">-3 &lt; 0, 更新 cur = 3</td>
</tr>
<tr>
<td style="text-align:center">-2</td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">-10</td>
<td style="text-align:center"></td>
<td style="text-align:center">-5</td>
</tr>
</tbody>
</table>
<ul>
<li>第一个数：2。连续子序列最大和 <code>maxSum = 2</code>；子序列当前累加和 <code>cur=2</code>；</li>
<li>第二个数：-8。<code>2 - 8 = -6 &lt; maxSum</code>，不更新 maxSum</li>
<li>第三个数：3。<code>-6 + 3 = -3 &lt; maxSum</code>，不更新 maxSum
<ul>
<li>如果不加 -6，而是让 3 自成一个子序列，<code>3 &gt; maxSum</code></li>
<li>maxSum = 3；cur = 3</li>
<li>如果前面累加的和为负数或零，对后面的求和不会有正向贡献，因此可以舍弃前面这段子序列的和，重新开始一个新的子序列。当前连续子序列的和记为 cur</li>
<li><code>if ( cur&lt;= 0 )</code>，就从当前元素重新开始一个新的子序列，当前和 cur 更新为当前的元素值 <code>cur = a[i];</code> 否则子序列就继续向前相加 <code>cur = cur + a[i]</code> 。每次子序列的和更新后，都要和最大值 maxSum 对比，以此更新最大值 <code>maxSum = max(maxSum, cur)</code>，这样遍历完数组，就能找到连续子序列的最大和</li>
</ul>
</li>
<li>第四个数：-2。<code>3 - 2 = 1</code>，<code>cur=1 &gt; 0</code>，于是保留 <code>cur=1</code>。<code>cur=1 &lt; maxSum=3</code>，不更新 maxSum</li>
<li>第五个数：4。<code>1+4=5 &gt; maxSum</code>，保留 <code>cur=5</code>，更新 maxSum=5</li>
<li>第六个数：-10。<code>5-10=-5 &lt; 5</code>，不更新 maxSum</li>
</ul>
<h3 id="复杂度分析">复杂度分析</h3>
<ul>
<li>T = O(n)<br>
遍历数组一遍，时间复杂度为 O(n)。</li>
<li>S = O(1)<br>
没有使用额外的存储空间，空间复杂度为 O(1)</li>
</ul>
<h2 id="代码">代码</h2>
<pre><code>class Solution {

  // Time: O(n), Space: O(1)
  public int maxSubArray(int[] nums) {
      // 初始化子序列最大和 max 和 子序列当前累加和
      int max = Integer.MIN_VALUE, cur = 0;
    // for 循环遍历数组
    for (int i = 0; i &lt; nums.length; ++i) {
      // 累加和 &lt;= 0，则用当前元素值 nums[i] 更新累加和，表示开始一个新的子序列；否则继续累加当前元素的值
      cur = cur &lt;= 0 ? nums[i] : (cur + nums[i]);
      // 更新当前子序列的最大值
      max = Math.max(max, cur);
    }
    return max;
  }

}
</code></pre>
<h2 id="来源">来源</h2>
<p>来源：力扣（LeetCode）<br>
链接：<a href="https://leetcode-cn.com/problems/maximum-subarray">https://leetcode-cn.com/problems/maximum-subarray</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入学习并发编程中的synchronized]]></title>
        <id>https://epitomm.github.io/post/shen-ru-xue-xi-bing-fa-bian-cheng-zhong-de-synchronized/</id>
        <link href="https://epitomm.github.io/post/shen-ru-xue-xi-bing-fa-bian-cheng-zhong-de-synchronized/">
        </link>
        <updated>2020-04-15T03:54:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第一章并发编程中的三个问题">第一章：并发编程中的三个问题</h1>
<h2 id="可见性">可见性</h2>
<p>可见性（Visibility）：是指<strong>一个线程对共享变量进行修改，另一个线程立即得到修改后的最新值</strong>。</p>
<h3 id="可见性演示">可见性演示</h3>
<p>案例演示：一个线程根据 <code>boolean</code> 类型的标记 <code>flag</code>， <code>while</code> 循环，另一个线程改变这个 <code>flag</code> 变量的值，这个线程并不会停止循环。</p>
<pre><code>package com.itheima.demo01_concurrent_problem;

/**
 *目标:演示可见性问题
 *     1.创建一个共享变量
 *     2.创建一个线程不断读取共享变量
 *     3.创建一饿线程修改共享变量
 */
public class Test01Visibility {
    // 1.创建一个共享变量
    private static boolean flag = true;

    public static void main(String[] args) throws InterruptedException {
        // 2.创建一个线程不断读取共享变量
        new Thread(() -&gt; {
            while (flag) {

            }
        }).start();

        Thread.sleep(2000);

        // 3.创建一个线程修改共享变量
        new Thread(() -&gt; {
            flag = false;
            System.out.println(&quot;线程修改了变量的值为false&quot;);
        }).start();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>线程修改了变量的值为false
（阻塞···）
</code></pre>
<h3 id="小结">小结</h3>
<p>并发编程时，会出现可见性问题，当一个线程对共享变量进行了修改，另外的线程并没有立即看到修改后的最新值。</p>
<h2 id="原子性">原子性</h2>
<p>原子性（Atomicity）：<strong>在一次或多次操作中，要么所有的操作都执行并且不会受其他因素干扰而中断，要么所有的操作都不执行</strong>。</p>
<h3 id="原子性演示">原子性演示</h3>
<p>案例演示:5个线程各执行1000次 i++;</p>
<pre><code>package com.itheima.demo01_concurrent_problem;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

/**
 * 目标:演示原子性问题
 *     1.定义一个共享变量number
 *     2.对number进行1000的++操作
 *     3.使用5个线程来进行
 */
public class Test02Atomicity {
    // 1.定义一个共享变量number
    private static int number = 0;

    public static void main(String[] args) throws InterruptedException {
        // 2.对number进行1000的++操作
        Runnable increment = () -&gt; {
            for (int i = 0; i &lt; 1000; i++) {
                number++;
            }
        };
        List&lt;Thread&gt; list = new ArrayList&lt;&gt;();
        // 3.使用5个线程来进行
        for (int i = 0; i &lt; 5; i++) {
            Thread t = new Thread(increment);
            t.start();
            list.add(t);
        }

        for (Thread t : list) {
            t.join();
        }

        System.out.println(&quot;number = &quot; + number);
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>number = 4955
</code></pre>
<p>使用<code>javap</code>反汇编<code>class</code>文件，得到下面的字节码指令：<br>
<img src="https://epitomm.github.io/post-images/%E5%8E%9F%E5%AD%90%E6%80%A7%E6%BC%94%E7%A4%BA.png" alt="图片" loading="lazy"></p>
<p>其中，对于 <code>number++</code> 而言（number 为静态变量），实际会产生如下的 JVM 字节码指令：</p>
<pre><code>9: getstatic #12    // 从类信息中加载 12 号 static 变量
12: iconst_1         // 把 int 类型常量 1 压入操作数栈
13: iadd               // 将操作数栈顶和次栈顶元素弹出并相加
14: putstatic #12 // 设置 12 号 static 变量
</code></pre>
<p>由此可见<code>number++</code>是由多条语句组成，以上多条指令在一个线程的情况下是不会出问题的，但是在多线程情况下就可能会出现问题。比如一个线程在执行<code>13: iadd</code>时，另一个线程又执行<code>9: getstatic</code>。会导致两次<code>number++</code>，实际上只加了1。</p>
<h3 id="小结-2">小结</h3>
<p>并发编程时，会出现原子性问题，当一个线程对共享变量操作到一半时，另外的线程也有可能来操作共享变量，干扰了前一个线程的操作。</p>
<h2 id="有序性">有序性</h2>
<p>有序性（Ordering）：是指程序中代码的执行顺序，Java在编译时和运行时会对代码进行优化，会导致<strong>程序最终的执行顺序不一定就是我们编写代码时的顺序</strong>。</p>
<pre><code>public static void main(String[] args) {
    int a = 10;
    int b = 20;
}
</code></pre>
<h3 id="有序性演示">有序性演示</h3>
<p><code>jcstress</code>是<code>Java</code>并发压测工具。<a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">https://wiki.openjdk.java.net/display/CodeTools/jcstress</a></p>
<p>修改pom文件，添加依赖：</p>
<pre><code>&lt;dependency&gt; 
  &lt;groupId&gt;org.openjdk.jcstress&lt;/groupId&gt; 
  &lt;artifactId&gt;jcstress-core&lt;/artifactId&gt; 
  &lt;version&gt;${jcstress.version}&lt;/version&gt; 
&lt;/dependency&gt;  
</code></pre>
<p>代码<br>
Test03Orderliness.java</p>
<pre><code>import org.openjdk.jcstress.annotations.*;
import org.openjdk.jcstress.infra.results.I_Result;
@JCStressTest
@Outcome(id = {&quot;1&quot;, &quot;4&quot;}, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)
@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;danger&quot;)
@State
public class Test03Orderliness {
    int num = 0;
    boolean ready = false;
    // 线程一执行的代码
    @Actor
    public void actor1(I_Result r) {
        if(ready) {
            r.r1 = num + num;
        } else {
            r.r1 = 1;
        }
    }
    // 线程2执行的代码
    @Actor
    public void actor2(I_Result r) {
        num = 2;
        ready = true;
    }
}
</code></pre>
<ul>
<li><code>I_Result</code> 是一个对象，有一个属性 <code>r1</code> 用来保存结果，在多线程情况下可能出现几种结果？
<ul>
<li>情况1：线程1先执行<code>actor1</code>，这时<code>ready = false</code>，所以进入else分支结果为1。</li>
<li>情况2：线程2执行到<code>actor2</code>，执行了<code>num = 2;</code>和<code>ready = true</code>，线程1执行，这回进入 if 分支，结果为 4。</li>
<li>情况3：线程2先执行<code>actor2</code>，只执行<code>num = 2</code>；但没来得及执行 <code>ready = true</code>，线程1执行，还是进入 else分支，结果为1。</li>
<li><strong>还有一种结果0</strong>。代码重排序将 <code>actor2</code> 中 <code>num = 2</code> 和 <code>ready = true</code> 反序。先执行 <code>actor2</code> 中的 <code>ready = true</code>，然后执行 <code>actor1</code> 中 if 判断，结果为 0 + 0 = 0。</li>
</ul>
</li>
</ul>
<p>运行测试：</p>
<pre><code>mvn clean install 
java -jar target/jcstress.jar
</code></pre>
<h3 id="小结-3">小结</h3>
<p>程序代码在执行过程中的先后顺序，由于<code>Java</code>在编译期以及运行期的优化，导致了代码的执行顺序未必就是开发者编写代码时的顺序。</p>
<h1 id="第二章java内存模型jmm">第二章：Java内存模型(JMM)</h1>
<p>在介绍Java内存模型之前，先来看一下到底什么是计算机内存模型。</p>
<h2 id="计算机结构">计算机结构</h2>
<h3 id="计算机结构简介">计算机结构简介</h3>
<p>冯诺依曼，提出计算机由五大组成部分，<strong>输入设备，输出设备，存储器，控制器，运算器</strong>。</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center">计算机结构</p>
<h3 id="cpu">CPU</h3>
<p>中央处理器，是计算机的<strong>控制和运算</strong>的核心，我们的程序最终都会变成指令让CPU去执行，处理程序中的数据。<br>
<img src="https://epitomm.github.io/post-images/CPU.png" alt="图片" loading="lazy"></p>
<p style = "text-align:center">CPU</p>
<h3 id="内存">内存</h3>
<p>我们的程序都是在内存中运行的，<strong>内存会保存程序运行时的数据</strong>，供CPU处理。</p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E5%86%85%E5%AD%98.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center">内存</p>
<h3 id="缓存">缓存</h3>
<p><strong>CPU的运算速度和内存的访问速度相差比较大</strong>。这就导致CPU每次操作内存都要耗费很多等待时间。内存的读写速度成为了计算机运行的瓶颈。于是就有了在CPU和主内存之间增加缓存的设计。最靠近CPU 的缓存称为L1，然后依次是 L2，L3和主内存，CPU缓存模型如图下图所示。</p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/CPU%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center">CPU 缓存模型</p>
<p>CPU Cache分成了三个级别: L1， L2， L3。级别越小越接近CPU，速度也更快，同时也代表着容量越小。</p>
<ol>
<li>L1是最接近CPU的，它容量最小，例如32K，速度最快，每个核上都有一个L1 Cache。</li>
<li>L2 Cache 更大一些，例如256K，速度要慢一些，一般情况下每个核上都有一个独立的L2 Cache。</li>
<li>L3 Cache是三级缓存中最大的一级，例如12MB，同时也是缓存中最慢的一级，在同一个CPU插槽之间的核共享一个L3 Cache。<br>
<img src="https://epitomm.github.io/post-images/CPU%E5%8F%82%E6%95%B0.png" alt="图片" loading="lazy"></li>
</ol>
<blockquote>
<p>Latency：延迟</p>
</blockquote>
<p>Cache的出现是为了解决<strong>CPU直接访问内存效率低下</strong>问题的，程序在运行的过程中，CPU接收到指令后，它会最先向CPU中的一级缓存（L1 Cache）去寻找相关的数据，如果命中缓存，CPU进行计算时就可以直接对CPU Cache中的数据进行读取和写入，当运算结束之后，再将CPU Cache中的最新数据刷新到主内存当中，CPU通过直接访问Cache的方式替代直接访问主存的方式极大地提高了CPU 的吞吐能力。但是由于一级缓存（L1 Cache）容量较小，所以不可能每次都命中。这时CPU会继续向下一级的二级缓存（L2 Cache）寻找，同样的道理，当所需要的数据在二级缓存中也没有的话，会继续转向L3 Cache、内存(主存)和硬盘。</p>
<h3 id="小结-4">小结</h3>
<p>计算机的主要组成：CPU，内存，输入设备，输出设备。</p>
<h2 id="java内存模型">Java内存模型</h2>
<p>Java Memory Molde (Java内存模型/JMM)，千万不要和Java内存结构混淆</p>
<p>关于“Java内存模型”的权威解释，请参考 <a href="https://download.oracle.com/otn-pub/jcp/memory_model-1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.pdf?AuthParam=1581232382_a0e88fb559ae2cdd224df3335e1eb9d3">https://download.oracle.com/otn-pub/jcp/memory_model-1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.pdf</a>。</p>
<p>Java 内存模型，是 Java 虚拟机规范中所定义的一种内存模型，Java 内存模型是标准化的，屏蔽掉了底层不同计算机的区别。</p>
<p>Java内存模型是一套规范，描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节，具体如下。</p>
<ul>
<li>主内存</li>
</ul>
<p>主内存是<strong>所有线程都共享</strong>的，都能访问的。所有的<strong>共享变量</strong>都存储于主内存。</p>
<ul>
<li>工作内存</li>
</ul>
<p><strong>每一个线程有自己的工作内存</strong>，工作内存只存储该线程对<strong>共享变量的副本</strong>。线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接访问对方工作内存中的变量。</p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center"> Java 内存模型</p>
<h3 id="java-内存模型的作用">Java 内存模型的作用</h3>
<p>Java内存模型是一套在多线程读写共享数据时，对共享数据的可见性、有序性、和原子性的规则和保障。</p>
<p>synchronized,volatile</p>
<h3 id="cpu缓存内存与-java-内存模型的关系">CPU缓存，内存与 Java 内存模型的关系</h3>
<p>通过对前面的CPU硬件内存架构、Java内存模型以及Java多线程的实现原理的了解，我们应该已经意识到，<strong>多线程的执行最终都会映射到硬件处理器上进行执行</strong>。</p>
<p>但 Java 内存模型和硬件内存架构并不完全一致。对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存和主内存之分，也就是说 Java 内存模型对内存的划分对硬件内存并没有任何影响， 因为 JMM 只是一种抽象的概念，是一组规则，不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说，Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种<strong>抽象概念划分与真实物理硬件的交叉</strong>。</p>
<p><strong>JMM内存模型与CPU硬件内存架构的关系：</strong></p>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/JMM%E4%B8%8ECPU%E7%A1%AC%E4%BB%B6%E5%86%85%E5%AD%98%E6%9E%B6%E6%9E%84%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="图片" loading="lazy"></figure>
<p><strong>小结</strong></p>
<p>Java 内存模型是一套<strong>规范</strong>，描述了 <strong>Java 程序中各种变量(线程共享变量)的访问规则</strong>，以及在 JVM 中将变量存储到内存和从内存中读取变量这样的底层细节，Java 内存模型是对共享数据的可见性、有序性、和原子性的规则和保障。</p>
<h2 id="主内存与工作内存之间的数据交互过程">主内存与工作内存之间的数据交互过程</h2>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E4%B8%BB%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E7%9A%84%E4%BA%A4%E4%BA%92.png" alt="图片" loading="lazy"></figure>
<p>Java内存模型中定义了以下8种操作来完成，主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的。</p>
<p>对应如下的流程图：</p>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E4%B8%BB%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E5%85%B7%E4%BD%93%E7%9A%84%E4%BA%A4%E4%BA%92%E5%8D%8F%E8%AE%AE.png" alt="图片" loading="lazy"></figure>
<ul>
<li>read：从主内存读取共享变量（<code>boolean x= true</code>）</li>
<li>load：将共享变量（<code>boolean x = tru</code>e）放入工作内存的变量副本中</li>
<li>use：把工作内存中一个变量的<strong>值</strong>（true）传递给执行引擎</li>
<li>assign：把一个从执行引擎接收到的值赋给工作内存的变量</li>
<li>store：把工作内存的一个共享变量传送到主内存中</li>
<li>write：在 store 之后执行，把 store 得到的值放入主内存的变量中</li>
<li>lock：作用于主内存的变量</li>
<li>unlock</li>
</ul>
<p>注意:</p>
<ol>
<li>
<p>如果对一个变量执行lock操作，将会<strong>清空工作内存中此变量的值</strong></p>
</li>
<li>
<p>对一个变量执行unlock操作之前，必须先<strong>把此变量同步到主内存中</strong></p>
</li>
</ol>
<h3 id="小结-5">小结</h3>
<p>主内存与工作内存之间的数据交互过程</p>
<pre><code>lock -&gt; read -&gt; load -&gt; use -&gt; assign -&gt; store -&gt; write -&gt; unlock
</code></pre>
<h1 id="第三章synchronized保证三大特性">第三章：synchronized保证三大特性</h1>
<p>synchronized能够保证在同一时刻最多只有一个线程执行该段代码，以达到保证并发安全的效果。</p>
<pre><code>synchronized (锁对象) { 
    // 受保护资源; 
}
</code></pre>
<h2 id="synchronized与原子性">synchronized与原子性</h2>
<h3 id="使用synchronized保证原子性">使用synchronized保证原子性</h3>
<p>案例演示:5个线程各执行1000次 i++;</p>
<pre><code>import java.util.ArrayList;
/**
 案例演示:5个线程各执行1000次 i++; 
 */
public class Test01Atomicity {
    private static int number = 0;
    public static void main(String[] args) throws InterruptedException {
        Runnable increment = new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i &lt; 1000; i++) {
                    synchronized (Test01Atomicity.class) {
                        number++;
                    }
                }
            }
        };
        ArrayList&lt;Thread&gt; ts = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 50; i++) {
            Thread t = new Thread(increment);
            t.start();
            ts.add(t);
        }
        for (Thread t : ts) {
            t.join();
        }
        System.out.println(&quot;number = &quot; + number);
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>number = 50000
</code></pre>
<p>主要代码：</p>
<pre><code>for (int i = 0; i &lt; 1000; i++) {
    synchronized (Test01Atomicity.class) {
        number++;
    }
}
</code></pre>
<h3 id="synchronized保证原子性的原理">synchronized保证原子性的原理</h3>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/synchronized%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8E%9F%E7%90%86.png" alt="图片" loading="lazy"></figure>
<p>对<code>number++</code>;增加同步代码块后，保证同一时间只有一个线程操作<code>number++</code>;。就不会出现安全问题。</p>
<h3 id="小结-6">小结</h3>
<p>synchronized保证原子性的原理：synchronized保证只有一个线程拿到锁，能够进入同步代码块。</p>
<h2 id="synchronized与可见性">synchronized与可见性</h2>
<h3 id="使用synchronized保证可见性">使用synchronized保证可见性</h3>
<p>案例演示：一个线程根据boolean类型的标记flag， while循环，另一个线程改变这个flag变量的值，使用 synchronized 加锁这个线程会停止循环。</p>
<pre><code>/*
    目标:演示可见性问题
        1.创建一个共享变量
        2.创建一个线程不断读取共享变量
        3.创建一个线程修改共享变量
 */
public class Test01Visibility {
    // 1.创建一个使用 volatile 修饰的共享变量
    private static boolean flag = true;
    private static Object obj = new Object();
    public static void main(String[] args) throws InterruptedException {
        // 2.创建一个线程不断读取共享变量
        new Thread(() -&gt; {
            while (flag) {
                synchronized (obj){

                }
            }
        }).start();

        Thread.sleep(2000);

        // 3.创建一个线程修改共享变量
        new Thread(() -&gt; {
            flag = false;
            System.out.println(&quot;线程修改了变量的值为false&quot;);
        }).start();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>线程修改了变量的值为false
</code></pre>
<p>分析：<br>
synchronized ：当线程 2 将 flag 的值改为 false 后，线程 1 再次执行 while 操作时：读取主内存变量到工作空间前，执行 Lock 操作，使工作内存内的共享变量失效，再次去主内存读取刷新共享变量的值。</p>
<p><strong>synchronized保证可见性的原理</strong><br>
<img src="https://epitomm.github.io/post-images/%E4%B8%BB%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E5%85%B7%E4%BD%93%E7%9A%84%E4%BA%A4%E4%BA%92%E5%8D%8F%E8%AE%AE.png" alt="图片" loading="lazy"></p>
<p>如果 while 方法内增加输出语句 <code>System.out.println(&quot;run = &quot; + run);</code>，即使不显式使用 <code>synchronized</code> 加锁也能终止死循环。</p>
<pre><code>/**
 案例演示:
 一个线程根据boolean类型的标记flag， while循环，另一个线程改变这个flag变量的值，
 另一个线程并不会停止循环.
 */
public class Test01Visibility {
    // 多个线程都会访问的数据，我们称为线程的共享数据
    private static boolean run = true;
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -&gt; {
            while (run) {
                // 增加对象共享数据的打印，println是同步方法
                System.out.println(&quot;run = &quot; + run);
            }
        });
        t1.start();
        Thread.sleep(1000);
        Thread t2 = new Thread(() -&gt; {
            run = false;
            System.out.println(&quot;时间到，线程2设置为false&quot;);
        });
        t2.start();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>run = true
run = true
run = true
······
run = true
run = true
run = true
时间到，线程2设置为false
</code></pre>
<p>分析：<br>
使用 sout 输出，程序会停止，而不是一直阻塞，因为 sout 内部使用了 synchronized</p>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/sout.png" alt="图片" loading="lazy"></figure>
<h3 id="使用-volatile-保证可见性">使用 volatile 保证可见性</h3>
<pre><code>package com.itheima.demo02_concurrent_problem;

/*
    目标:演示可见性问题
        1.创建一个共享变量
        2.创建一个线程不断读取共享变量
        3.创建一个线程修改共享变量
 */
public class Test01Visibility {
    // 1.创建一个使用 volatile 修饰的共享变量
    private static volatile boolean flag = true;
    private static Object obj = new Object();
    public static void main(String[] args) throws InterruptedException {
        // 2.创建一个线程不断读取共享变量
        new Thread(() -&gt; {
            while (flag) {

            }
        }).start();

        Thread.sleep(2000);

        // 3.创建一个线程修改共享变量
        new Thread(() -&gt; {
            flag = false;
            System.out.println(&quot;线程修改了变量的值为false&quot;);
        }).start();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>线程修改了变量的值为false
</code></pre>
<h3 id="小结-7">小结</h3>
<p>synchronized保证可见性的原理，执行synchronized时，会对应lock原子操作会刷新工作内存中共享变量的值</p>
<h2 id="synchronized与有序性">synchronized与有序性</h2>
<h3 id="为什么要重排序">为什么要重排序</h3>
<p>为了<strong>提高程序的执行效率</strong>，编译器和CPU会对程序中代码进行重排序。</p>
<h3 id="as-if-serial语义">as-if-serial语义</h3>
<p>as-if-serial语义的意思是：不管编译器和CPU如何重排序，必须保证在<strong>单线程情况下程序的结果是正确</strong>的。</p>
<p>以下数据有依赖关系，不能重排序。</p>
<p>写后读：</p>
<pre><code>int a = 1;
int b = a;
</code></pre>
<p>写后写：</p>
<pre><code>int a = 1;
int a = 2;
</code></pre>
<p>读后写：</p>
<pre><code>int a = 1;
int b = a;
int a = 2;
</code></pre>
<p>编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。</p>
<pre><code>int a = 1;
int b = 2;
int c = a + b;
</code></pre>
<p>上面3个操作的数据依赖关系如图所示：<br>
<img src="https://epitomm.github.io/post-images/%E4%B8%89%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.png" alt="图片" loading="lazy"></p>
<p>如上图所示 a 和 c 之间存在数据依赖关系，同时 b 和 c 之间也存在数据依赖关系。因此在最终执行的指令序列中，c 不能被重排序到 a 和 b 的前面。但 a 和 b 之间没有数据依赖关系，编译器和处理器可以重排序 a 和 b 之间的执行顺序。下图是该程序的两种执行顺序。</p>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/%E4%B8%89%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB2.png" alt="图片" loading="lazy"></figure>
<pre><code>可以这样：
int a = 1;
int b = 2;
int c = a + b;

也可以重排序这样：
int b = 2;
int a = 1;
int c = a + b; 
</code></pre>
<h3 id="使用-synchronized-保证有序性">使用 synchronized 保证有序性</h3>
<pre><code>package com.itheima.demo02_concurrent_problem;

import org.openjdk.jcstress.annotations.*;
import org.openjdk.jcstress.infra.results.I_Result;
@JCStressTest
@Outcome(id = {&quot;1&quot;}, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)
@Outcome(id = {&quot;4&quot;}, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;danger2&quot;)
@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;danger&quot;)
@State
public class Test03Ordering {
    private Object obj = new Object();
    volatile int num = 0;
    volatile boolean ready = false;
    // 线程1执行的代码
    @Actor
    public void actor1(I_Result r) {
        synchronized (obj){
            if (ready) {
                r.r1 = num + num;
            } else {
                r.r1 = 1;
            }
        }
    }
    // 线程2执行的代码
    @Actor
    public void actor2(I_Result r) {
        synchronized (obj){
            num = 2;
            ready = true;
        }
    }
}
</code></pre>
<p>运行结果只有 1 和 4，没有 0。</p>
<h3 id="synchronized保证有序性的原理">synchronized保证有序性的原理</h3>
<p>synchronized后，虽然进行了重排序，保证<strong>只有一个线程会进入同步代码块</strong>，也能保证有序性。</p>
<h3 id="小结-8">小结</h3>
<p>synchronized 保证有序性的原理，我们加 synchronized 后，依然会发生重排序，只不过，我们有同步代码块，可以保证只有一个线程执行同步代码中的代码，保证有序性。</p>
<h1 id="第四章synchronized的特性">第四章：synchronized的特性</h1>
<h2 id="可重入特性">可重入特性</h2>
<p>一个线程可以多次执行 synchronized, 重复获取同一把锁。</p>
<pre><code>package com.itheima.demo03_synchronized_nature;

/**
 * 目标:演示 synchronized 可重入
 *     1.自定义一个线程类
 *     2.在线程类的run方法中使用嵌套的同步代码块
 *     3.使用两个线程来执行
 */
public class Demo01 {
    public static void main(String[] args) {
        new MyThread().start();
        new MyThread().start();
    }
    public static void test01() {
        synchronized (MyThread.class) {
            String name = Thread.currentThread().getName();
            System.out.println(name + &quot;进入了同步代码块2&quot;);
        }
    }
}
// 1.自定义一个线程类
class MyThread extends Thread {
    @Override
    public void run() {
        synchronized (MyThread.class) {
            System.out.println(getName() + &quot;进入了同步代码块1&quot;);

            Demo01.test01();
        }
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>Thread-0进入了同步代码块1
Thread-0进入了同步代码块2
Thread-1进入了同步代码块1
Thread-1进入了同步代码块2
</code></pre>
<h3 id="可重入原理">可重入原理</h3>
<p>synchronized 的锁对象中有一个计数器（recursions变量）会<strong>记录线程获得几次锁</strong>。</p>
<h3 id="可重入的好处">可重入的好处</h3>
<ol>
<li>可以避免死锁</li>
<li>可以让我们更好的来封装代码</li>
</ol>
<h3 id="小结-9">小结</h3>
<p>synchronized 是可重入锁，内部锁对象中会有一个计数器记录线程获取几次锁了，在执行完同步代码块时，计数器的数量会-1，直到计数器的数量为0，就释放这个锁。</p>
<h2 id="不可中断特性">不可中断特性</h2>
<p>一个线程获得锁后，另一个线程想要获得锁，必须处于阻塞或等待状态，如果第一个线程不释放锁，第二个线程会一直<strong>阻塞或等待，不可被中断</strong>。</p>
<h3 id="synchronized不可中断演示">synchronized不可中断演示</h3>
<p>synchronized 是不可中断，处于阻塞状态的线程会一直等待锁。</p>
<pre><code>/*
    目标:演示synchronized不可中断
    1.定义一个Runnable
    2.在Runnable定义同步代码块
    3.先开启一个线程来执行同步代码块,保证不退出同步代码块
    4.后开启一个线程来执行同步代码块(阻塞状态)
    5.停止第二个线程
*/
public class Demo02_Uninterruptible {
    private static Object obj = new Object();
    public static void main(String[] args) throws InterruptedException {
        // 1.定义一个Runnable
        Runnable run = () -&gt; {
            // 2.在Runnable定义同步代码块
            synchronized (obj) {
                String name = Thread.currentThread().getName();
                System.out.println(name + &quot;进入同步代码块&quot;);
                // 保证不退出同步代码块
                try {
                    Thread.sleep(888888);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };
        // 3.先开启一个线程来执行同步代码块
        Thread t1 = new Thread(run);
        t1.start();
        Thread.sleep(1000);
        // 4.后开启一个线程来执行同步代码块(阻塞状态)
        Thread t2 = new Thread(run);
        t2.start();
        // 5.停止第二个线程
        System.out.println(&quot;停止线程前&quot;);
        t2.interrupt();
        System.out.println(&quot;停止线程后&quot;);
        System.out.println(t1.getState());
        System.out.println(t2.getState());
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>Thread-0进入同步代码块
停止线程前
停止线程后
TIMED_WAITING
BLOCKED//处于阻塞状态，不可被中断
</code></pre>
<h3 id="reentrantlock不可中断演示">ReentrantLock不可中断演示</h3>
<pre><code>package com.itheima.demo03_synchronized_nature;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 目标:演示Lock不可中断
 */
public class Demo03_Interruptible {
    private static Lock lock = new ReentrantLock();
    public static void main(String[] args) throws InterruptedException {
         test01();
    }

    // 演示Lock不可中断
    public static void test01() throws InterruptedException {
        Runnable run = () -&gt; {
            String name = Thread.currentThread().getName();
            try {
                lock.lock();
                System.out.println(name + &quot;获得锁,进入锁执行&quot;);
                Thread.sleep(88888);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
                System.out.println(name + &quot;释放锁&quot;);
            }
        };
        Thread t1 = new Thread(run);
        t1.start();
        Thread.sleep(1000);
        Thread t2 = new Thread(run);
        t2.start();

        System.out.println(&quot;停止t2线程前&quot;);
        t2.interrupt();
        System.out.println(&quot;停止t2线程后&quot;);
        Thread.sleep(1000);
        System.out.println(t1.getState());
        System.out.println(t2.getState());
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>Thread-0获得锁,进入锁执行
停止t2线程前
停止t2线程后
TIMED_WAITING
WAITING //t2 interrupt中断失败，一直处于等待状态
</code></pre>
<h3 id="reentrantlock可中断演示">ReentrantLock可中断演示</h3>
<pre><code>package com.itheima.demo03_synchronized_nature;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 目标:演示Lock可中断
 */
public class Demo03_Interruptible {
    private static Lock lock = new ReentrantLock();
    public static void main(String[] args) throws InterruptedException { 
        test02();
    }

    // 演示Lock可中断
    public static void test02() throws InterruptedException {
        Runnable run = () -&gt; {
            String name = Thread.currentThread().getName();
            boolean b = false;
            try {
                b = lock.tryLock(3, TimeUnit.SECONDS);
                if (b) {
                    System.out.println(name + &quot;获得锁,进入锁执行&quot;);
                    Thread.sleep(88888);
                } else {
                    System.out.println(name + &quot;在指定时间没有得到锁做其他操作&quot;);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                if (b) {
                    lock.unlock();
                    System.out.println(name + &quot;释放锁&quot;);
                }
            }
        };

        Thread t1 = new Thread(run);
        t1.start();
        Thread.sleep(1000);
        Thread t2 = new Thread(run);
        t2.start();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>Thread-0获得锁,进入锁执行
Thread-1在指定时间没有得到锁做其他操作
(阻塞很久)
Thread-0释放锁
</code></pre>
<h3 id="小结-10">小结</h3>
<p>不可中断是指，当一个线程获得锁后，另一个线程一直处于阻塞或等待状态，前一个线程不释放锁，后一个线程会一直阻塞或等待，不可被中断。</p>
<p><code>synchronized</code> 属于不可被中断</p>
<p><code>Lock</code> 的 <code>lock</code> 方法是不可中断的</p>
<p><code>Lock</code> 的 <code>tryLock</code> 方法是可中断的</p>
<h1 id="第五章synchronized-原理">第五章：synchronized 原理</h1>
<h2 id="javap-反汇编">javap 反汇编</h2>
<p>我们编写一个简单的synchronized代码，如下：</p>
<pre><code>public class Demo01 {
    private static Object obj = new Object();
    public static void main(String[] args) {
        synchronized (obj) {
            System.out.println(&quot;1&quot;);
        }
    }
    public synchronized void test() {
        System.out.println(&quot;a&quot;);
    }
}
</code></pre>
<p>我们要看 synchronized 的原理，但是 synchronized 是一个关键字，看不到源码。我们可以将class文件进行反汇编。</p>
<p>JDK自带的一个工具： javap ，对字节码进行反汇编，查看字节码指令。</p>
<p>在 DOS 命令行输入：</p>
<pre><code>javap -p -v C:\Users\Only\悄悄的努力\AQS\synchronized资料\案例\Synchronized\target\classes\com\itheima\demo04_synchronized_monitor\Demo01
</code></pre>
<p>反汇编后的效果如下：</p>
<pre><code>  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=3, args_size=1
         0: getstatic     #2                  // Field obj:Ljava/lang/Object;
         3: dup
         4: astore_1
         5: monitorenter
         6: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
         9: ldc           #4                  // String 1
        11: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        14: aload_1
        15: monitorexit
        16: goto          24
        19: astore_2
        20: aload_1
        21: monitorexit
        22: aload_2
        23: athrow
        24: return
      Exception table:
         from    to  target type
             6    16    19   any
            19    22    19   any
      LineNumberTable:
        line 7: 0
        line 8: 6
        line 9: 14
        line 10: 24
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      25     0  args   [Ljava/lang/String;
      StackMapTable: number_of_entries = 2
        frame_type = 255 /* full_frame */
          offset_delta = 19
          locals = [ class &quot;[Ljava/lang/String;&quot;, class java/lang/Object ]
          stack = [ class java/lang/Throwable ]
        frame_type = 250 /* chop */
          offset_delta = 4

  public synchronized void test();
    descriptor: ()V
    flags: (0x0021) ACC_PUBLIC, ACC_SYNCHRONIZED
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #6                  // String a
         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      LineNumberTable:
        line 13: 0
        line 14: 8
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       9     0  this   Lcom/itheima/demo04_synchronized_monitor/Demo01;
  static {};
    descriptor: ()V
    flags: (0x0008) ACC_STATIC
    Code:
      stack=2, locals=0, args_size=0
         0: new           #7                  // class java/lang/Object
         3: dup
         4: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
         7: putstatic     #2                  // Field obj:Ljava/lang/Object;
        10: return
      LineNumberTable:
        line 4: 0
}

SourceFile: &quot;Demo01.java&quot;
</code></pre>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97.png" alt="图片" loading="lazy"></figure>
<p>同步代码块</p>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/synchronized.png" alt="图片" loading="lazy"></figure>
<h3 id="monitorenter">monitorenter</h3>
<p><strong>首先我们来看一下JVM规范中对于monitorenter的描述：</strong></p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter</a></p>
<blockquote>
<p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner.<br>
The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref， as follows:<br>
If the entry count of the monitor associated with objectref is zero， the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.<br>
If the thread already owns the monitor associated with objectref， it reenters the monitor， incrementing its entry count.<br>
If another thread  already owns the monitor associated with objectref， the thread blocks until the monitor's entry count is zero， then tries again to gain ownership.</p>
</blockquote>
<p>翻译过来： 每一个对象都会和一个监视器 monitor 关联。监视器被占用时会被锁住，其他线程无法来获 取该 monitor。 当 JVM 执行某个线程的某个方法内部的 monitorenter 时，它会尝试去获取当前对象对应的 monitor 的所有权。其过程如下：</p>
<ol>
<li>若 monior 的进入数为 0，线程可以进入 monitor，并将 monitor 的进入数置为 1。当前线程成为 monitor 的owner（所有者）</li>
<li>若当前线程已拥有 monitor 的所有权，允许它重入 monitor，则进入 monitor 的进入数加 1</li>
<li>若其他线程已经占有 monitor 的所有权，那么当前尝试获取 monitor 的所有权的线程会被阻塞，直到 monitor 的进入数变为 0，才能重新尝试获取 monitor 的所有权。</li>
</ol>
<p><strong>monitorenter小结：</strong></p>
<p>synchronized 的锁对象会关联一个 monitor, 这个 monitor 不是我们主动创建的，是 JVM 的线程执行到这个同步代码块,发现锁对象没有 monitor 就会创建 monitor, monitor 内部有两个重要的成员变量 <strong>owner:拥有这把锁的线程</strong>, <strong>recursions会记录线程拥有锁的次数</strong>，当一个线程拥有 monito r后其他线程只能等待。</p>
<h3 id="monitorexit">monitorexit</h3>
<p><strong>首先我们来看一下JVM规范中对于monitorexit的描述：</strong></p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit</a></p>
<blockquote>
<p>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.<br>
The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero， the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p>
</blockquote>
<p>翻译过来：</p>
<ol>
<li>能执行 monitorexit 指令的线程一定是拥有当前对象的 monitor 的所有权的线程。</li>
<li>执行 monitorexit 时会将 monitor 的进入数减 1。当 monitor 的进入数减为 0 时，当前线程退出 monitor，不再拥有 monitor 的所有权，此时其他被这个 monitor 阻塞的线程可以尝试去获取这个 monitor 的所有权 。</li>
</ol>
<h4 id="monitorexit-释放锁">monitorexit 释放锁。</h4>
<p>monitorexit 插入在<strong>方法结束处</strong>和<strong>异常处</strong>，JVM保证每个 monitorenter 必须有对应的monitorexit。</p>
<h4 id="面试题-synchroznied-出现异常会释放锁吗">面试题 synchroznied 出现异常会释放锁吗?</h4>
<p>会释放锁</p>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/synchronized%E5%87%BA%E7%8E%B0%E5%BC%82%E5%B8%B8%E4%BC%9A%E9%87%8A%E6%94%BE%E9%94%81.png" alt="图片" loading="lazy"></figure>
<p>synchronized出现异常会释放锁</p>
<h3 id="同步方法">同步方法</h3>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10</a></p>
<p>可以看到同步方法在反汇编后，会增加 <code>ACC_SYNCHRONIZED</code> 修饰。会隐式调用 monitorenter 和 monitorexit。在执行同步方法前会调用 monitorenter，在执行完同步方法后会调用 monitorexit。</p>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center">同步方法</p>
<h3 id="小结-11">小结</h3>
<p>通过 javap 反汇编我们看到 synchronized 使用变成了 monitorenter 和 monitorexit 两个指令.每个锁对象都会关联一个 monitor(监视器,它才是真正的锁对象),它内部有两个重要的成员变量owner 会保存获得锁的线程，recursions 会保存线程获得锁的次数,当执行到 monitorexit 时,recursions 会 -1,当计数器减到 0 时这个线程就会释放锁。</p>
<h3 id="面试题synchronized与lock的区别">面试题：synchronized与Lock的区别</h3>
<ol>
<li>synchronized 是关键字，而 Lock 是一个接口。</li>
<li>synchronized 会自动释放锁，而 Lock 必须手动释放锁。</li>
<li>synchronized 是不可中断的，Lock 可以中断也可以不中断。</li>
<li>通过 Lock 可以知道线程有没有拿到锁（tryLock()的返回值），而 synchronized 不能。</li>
<li>synchronized 能锁住方法和代码块，而 Lock 只能锁住代码块。</li>
<li>Lock 可以使用读锁提高多线程读效率（ReentrantReadWriteLock）。</li>
<li>synchronized 是非公平锁，ReentrantLock 可以控制是否是公平锁。</li>
</ol>
<h2 id="深入jvm源码">深入JVM源码</h2>
<h3 id="jvm源码下载">JVM源码下载</h3>
<p><a href="http://openjdk.java.net/">http://openjdk.java.net/</a> --&gt; Mercurial --&gt; jdk8 --&gt; hotspot --&gt; zip</p>
<h3 id="ideclion-下载">IDE(Clion )下载</h3>
<p><a href="https://www.jetbrains.com/">https://www.jetbrains.com/</a></p>
<h3 id="monitor监视器锁">monitor监视器锁</h3>
<p>可以看出无论是 synchronized 代码块还是 synchronized 方法，其线程安全的语义实现最终依赖一个叫 monitor 的东西，那么这个神秘的东西是什么呢？下面让我们来详细介绍一下。</p>
<p>在 HotSpot 虚拟机中，monitor 是由 ObjectMonitor 实现的。其源码是用 C++ 来实现的，位于HotSpot 虚拟机源码 ObjectMonitor.hpp 文件中(src/share/vm/runtime/objectMonitor.hpp)。ObjectMonitor 主要数据结构如下：</p>
<pre><code>ObjectMonitor() { 
  _header = NULL; 
  _count = 0; 
  _waiters = 0， 
  _recursions = 0; // 线程的重入次数
  _object = NULL; // 存储该monitor的对象 
  _owner = NULL; // 标识拥有该monitor的线程 
  _WaitSet = NULL; // 处于wait状态的线程，会被加入到_WaitSet 
  _WaitSetLock = 0 ; 
  _Responsible = NULL; 
  _succ = NULL; 
  _cxq = NULL; // 多线程竞争锁时的单向列表 
  FreeNext = NULL; 
  _EntryList = NULL; // 处于等待锁block状态的线程，会被加入到该列表 
  _SpinFreq = 0; 
  _SpinClock = 0; 
  OwnerIsThread = 0; 
}
</code></pre>
<ol>
<li>_owner：初始时为NULL。当有<strong>线程占有该monitor</strong>时，owner 标记为该线程的唯一标识。当线程释放 monitor 时，owner又恢复为 NULL。owner 是一个临界资源，JVM 是通过 CAS 操作来保证其线程安全的。</li>
<li>_cxq：竞争队列，<strong>所有请求锁的线程</strong>首先会被放在这个队列中（单向链接）。_cxq 是一个临界资源，JVM 通过 CAS 原子指令来修改 _cxq 队列。修改前 _cxq 的旧值填入了 node 的 next 字段，_cxq 指向新值（新线程）。因此_cxq 是一个后进先出的 stack（栈）。</li>
<li>_EntryList：_cxq 队列中<strong>有资格成为候选资源的线程</strong>会被移动到该队列中。</li>
<li>_WaitSet：因为<strong>调用wait方法而被阻塞</strong>的线程会被放在该队列中。</li>
</ol>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/monitor%E7%9B%91%E8%A7%86%E5%99%A8.png" alt="图片" loading="lazy"></figure>
<p>每一个 Java 对象都可以与一个监视器 monitor 关联，我们可以把它理解成为一把锁，当一个线程想要执行一段被 synchronized 圈起来的同步方法或者代码块时，该线程得先获取到 synchronized 修饰的对象对应的 monitor。</p>
<p>我们的 Java 代码里不会显示地去创造这么一个 monitor 对象，我们也无需创建，事实上可以这么理解： monitor 并不是随着对象创建而创建的。我们是通过 synchronized 修饰符告诉 JVM 需要为我们的某个对象创建关联的 monitor 对象。每个线程都存在两个 ObjectMonitor 对象列表，分别为free 和 used 列表。 同时 JVM 中也维护着 global locklist。当线程需要 ObjectMonitor 对象时，首先从线程自身的 free 表中申请，若存在则使用，若不存在则从 global list 中申请。</p>
<p>ObjectMonitor 的数据结构中包含：_owner、_WaitSet 和 _EntryList，它们之间的关系转换可以用下图表示：</p>
<figure data-type="image" tabindex="16"><img src="https://epitomm.github.io/post-images/monitor%E7%9B%91%E8%A7%86%E5%99%A8%E9%94%812.png" alt="图片" loading="lazy"></figure>
<h3 id="monitor竞争">monitor竞争</h3>
<ul>
<li>什么时候会产生 monitor 竞争
<ul>
<li>两个线程同时执行 synchronized 时，会发生竞争。</li>
</ul>
</li>
</ul>
<p><strong>如何竞争</strong></p>
<ol>
<li>执行 monitorenter 时，会调用InterpreterRuntime.cpp</li>
</ol>
<p>(位于：src/share/vm/interpreter/interpreterRuntime.cpp) 的 InterpreterRuntime::monitorenter 函数。具体代码可参见 HotSpot 源码。</p>
<pre><code>IRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))
#ifdef ASSERT
  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);
#endif
  if (PrintBiasedLockingStatistics) {
    Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
  }
  Handle h_obj(thread, elem-&gt;obj());
  assert(Universe::heap()-&gt;is_in_reserved_or_null(h_obj()),
         &quot;must be NULL or an object&quot;);
  if (UseBiasedLocking) {//是否设置使用了偏向锁
    // Retry fast entry if bias is revoked to avoid unnecessary inflation
    ObjectSynchronizer::fast_enter(h_obj, elem-&gt;lock(), true, CHECK);
  } else {  // 使用重量级锁
    ObjectSynchronizer::slow_enter(h_obj, elem-&gt;lock(), CHECK);
  }
  assert(Universe::heap()-&gt;is_in_reserved_or_null(elem-&gt;obj()),
         &quot;must be NULL or an object&quot;);
</code></pre>
<ol>
<li>对于重量级锁，monitorenter 函数中会调用 ObjectSynchronizer::slow_enter</li>
<li>最终调用 ObjectMonitor::enter（位于：src/share/vm/runtime/objectMonitor.cpp），源码如下：</li>
</ol>
<pre><code>void ATTR ObjectMonitor::enter(TRAPS) { 
  // The following code is ordered to check the most common cases first 
  // and to reduce RTS-&gt;RTO cache line upgrades on SPARC and IA32 processors. 
  Thread * const Self = THREAD ; 
  void * cur ; 
  
  // 通过CAS操作尝试把monitor的_owner字段设置为当前线程 
  cur = Atomic::cmpxchg_ptr (Self， &amp;_owner， NULL) ; 
  if (cur == NULL) { 
    // Either ASSERT _recursions == 0 or explicitly set _recursions = 0. 
    assert (_recursions == 0 ， &quot;invariant&quot;) ; 
    assert (_owner == Self， &quot;invariant&quot;) ; 
    // CONSIDER: set or assert OwnerIsThread == 1 
    return ; 
  }
  // 线程重入，recursions++ 
  if (cur == Self) { 
    // TODO-FIXME: check for integer overflow! BUGID 6557169. 
    _recursions ++ ; 
    return ; 
  }
  
  // 如果当前线程是第一次进入该monitor，设置_recursions为1，_owner为当前线程
  if (Self-&gt;is_lock_owned ((address)cur)) {
    assert (_recursions == 0， &quot;internal state error&quot;);
    _recursions = 1 ;
    // Commute owner from a thread-specific on-stack BasicLockObject address to
    // a full-fledged &quot;Thread *&quot;.
    _owner = Self ;
    OwnerIsThread = 1 ;
    return ;
  }
  
  // 省略一些代码
  for (;;) {
    jt-&gt;set_suspend_equivalent();
    // cleared by handle_special_suspend_equivalent_condition()
    // or java_suspend_self()
    
    // 如果获取锁失败，则阻塞，等待锁的释放，进入_cxq列表；
    EnterI (THREAD) ;
    
    if (!ExitSuspendEquivalent(jt)) break ;

  //
  // We have acquired the contended monitor， but while we were
  // waiting another thread suspended us. We don't want to enter
  // the monitor while suspended because that would surprise the
  // thread that suspended us.
  //
      _recursions = 0 ;
    _succ = NULL ;
    exit (false， Self) ;
  
    jt-&gt;java_suspend_self();
  }
  Self-&gt;set_current_pending_monitor(NULL);
}
</code></pre>
<p>此处省略锁的自旋优化等操作，统一放在后面synchronzied优化中说。<br>
以上代码的具体流程概括如下：</p>
<ol>
<li>通过CAS尝试把 monitor 的 owner 字段设置为当前线程。</li>
<li>如果设置之前的 owner 指向当前线程，说明当前线程再次进入monitor，即重入锁，执行 _recursions++ ，记录重入的次数。</li>
<li>如果当前线程是第一次进入该 monitor，设置 _recursions 为 1，_owner 为当前线程，该线程成功获得锁并返回。</li>
<li>如果获取锁失败，则等待锁的释放。</li>
</ol>
<h3 id="monitor等待">monitor等待</h3>
<p>竞争失败等待调用的是 ObjectMonitor 对象的 EnterI 方法（位于：src/share/vm/runtime/objectMonitor.cpp），源码如下所示：</p>
<pre><code>void ATTR ObjectMonitor::EnterI (TRAPS) { 
  Thread * Self = THREAD ;
  
  // Try the lock - TATAS 
  if (TryLock (Self) &gt; 0) { 
    assert (_succ != Self , &quot;invariant&quot;) ; 
    assert (_owner == Self , &quot;invariant&quot;) ; 
    assert (_Responsible != Self , &quot;invariant&quot;) ; 
    return ; 
  }
  
  if (TrySpin (Self) &gt; 0) { 
    assert (_owner == Self , &quot;invariant&quot;) ; 
    assert (_succ != Self , &quot;invariant&quot;) ; 
    assert (_Responsible != Self , &quot;invariant&quot;) ; 
    return ; 
  }
  
  // 省略部分代码 
  
  // 当前线程被封装成ObjectWaiter对象node，状态设置成ObjectWaiter::TS_CXQ； 
  ObjectWaiter node(Self) ; 
  Self-&gt;_ParkEvent-&gt;reset() ; 
  node._prev = (ObjectWaiter *) 0xBAD ; 
  node.TState = ObjectWaiter::TS_CXQ ; 
  
  // 通过CAS把node节点push到_cxq列表中 
  ObjectWaiter * nxt ; 
  for (;;) { 
    node._next = nxt = _cxq ; 
    if (Atomic::cmpxchg_ptr (&amp;node， &amp;_cxq， nxt) == nxt) break ; 
    
    // Interference - the CAS failed because _cxq changed. Just retry. 
    // As an optional optimization we retry the lock. 
    if (TryLock (Self) &gt; 0) { 
      assert (_succ != Self ， &quot;invariant&quot;) ; 
      assert (_owner == Self ， &quot;invariant&quot;) ; 
      assert (_Responsible != Self ， &quot;invariant&quot;) ; 
      return ; 
    } 
  }
  
  // 省略部分代码 
  for (;;) { 
    // 线程在被挂起前做一下挣扎，看能不能获取到锁 
    if (TryLock (Self) &gt; 0) break ; 
    assert (_owner != Self， &quot;invariant&quot;) ; 
    if ((SyncFlags &amp; 2) &amp;&amp; _Responsible == NULL) { 
      Atomic::cmpxchg_ptr (Self， &amp;_Responsible， NULL) ; 
    }
    
    // park self 
    if (_Responsible == Self || (SyncFlags &amp; 1)) { 
      TEVENT (Inflated enter - park TIMED) ; 
      Self-&gt;_ParkEvent-&gt;park ((jlong) RecheckInterval) ; 
      // Increase the RecheckInterval， but clamp the value. 
      RecheckInterval *= 8 ; 
      if (RecheckInterval &gt; 1000) RecheckInterval = 1000 ; 
    } else { 
      TEVENT (Inflated enter - park UNTIMED) 
      // 通过park将当前线程挂起，等待被唤醒 
      Self-&gt;_ParkEvent-&gt;park() ; 
    }
    // 被唤醒后尝试获取锁
    if (TryLock(Self) &gt; 0) break ; 
    // 省略部分代码 
  }
  
  // 省略部分代码 
}
</code></pre>
<p>当该线程被唤醒时，会从挂起的点继续执行，通过 ObjectMonitor::TryLock 尝试获取锁，TryLock方法实现如下：</p>
<pre><code>int ObjectMonitor::TryLock (Thread * Self) { 
  for (;;) { 
    void * own = _owner ; 
    if (own != NULL) return 0 ; 
    // CAS 尝试获取锁
    if (Atomic::cmpxchg_ptr (Self， &amp;_owner， NULL) == NULL) { 
      // Either guarantee _recursions == 0 or set _recursions = 0. 
      assert (_recursions == 0， &quot;invariant&quot;) ; 
      assert (_owner == Self， &quot;invariant&quot;) ; 
      // CONSIDER: set or assert that OwnerIsThread == 1 
      return 1 ; 
    }
    // The lock had been free momentarily， but we lost the race to the lock. 
    // Interference -- the CAS failed. 
    // We can either return -1 or retry. 
    // Retry doesn't make as much sense because the lock was just acquired. 
    if (true) return -1 ; 
  } 
}
</code></pre>
<p>以上代码的具体流程概括如下：</p>
<ol>
<li>当前线程被封装成 ObjectWaiter 对象 node，状态设置成 ObjectWaiter::TS_CXQ。</li>
<li>在 for 循环中，通过 CAS 把 node 节点 push 到 _cxq 列表中，同一时刻可能有多个线程把自己的 node 节点 pus h到 _cxq 列表中。</li>
<li>node 节点 push 到 _cxq 列表之后，通过自旋尝试获取锁，如果还是没有获取到锁，则通过 park 将当前线程挂起，等待被唤醒。</li>
<li>当该线程被唤醒时，会从挂起的点继续执行，通过 ObjectMonitor::TryLock 尝试获取锁。</li>
</ol>
<h3 id="monitor释放">monitor释放</h3>
<p>当某个持有锁的线程执行完同步代码块时，会进行锁的释放，给其它线程机会执行同步代码，在 HotSpot 中，通过退出 monitor 的方式实现锁的释放，并通知被阻塞的线程，具体实现位于 ObjectMonitor 的 exit 方法中。（位于：src/share/vm/runtime/objectMonitor.cpp），源码如下所示：</p>
<pre><code>void ATTR ObjectMonitor::exit(bool not_suspended， TRAPS) { 
  Thread * Self = THREAD ; 
  // 省略部分代码 
  // 重入锁
  if (_recursions != 0) { 
    _recursions--; // this is simple recursive enterTEVENT (Inflated exit - recursive) ; 
    return ; 
  }
  
  // 省略部分代码 
  // 等待的线程用 ObjectWaiter 包装，使用变量 w 存放被唤醒的线程
  ObjectWaiter * w = NULL ; 
  int QMode = Knob_QMode ; 
  
  // qmode = 2：直接绕过EntryList队列，从cxq队列中获取线程用于竞争锁 
  if (QMode == 2 &amp;&amp; _cxq != NULL) { 
    w = _cxq ; // _cxq 的链表头赋值给 w
    assert (w != NULL， &quot;invariant&quot;) ; 
    assert (w-&gt;TState == ObjectWaiter::TS_CXQ， &quot;Invariant&quot;) ; 
    ExitEpilog (Self， w) ; // 唤醒线程
    return ; 
  }
  
  // qmode =3：cxq队列插入EntryList尾部； 
  if (QMode == 3 &amp;&amp; _cxq != NULL) { 
    w = _cxq ; 
    for (;;) { 
      assert (w != NULL， &quot;Invariant&quot;) ; 
      ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL， 
      &amp;_cxq， w) ; 
      if (u == w) break ; 
      w = u ; 
    }
    assert (w != NULL ， &quot;invariant&quot;) ; 
    
    ObjectWaiter * q = NULL ; 
    ObjectWaiter * p ; 
    for (p = w ; p != NULL ; p = p-&gt;_next) { 
      guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ， &quot;Invariant&quot;) ; 
      p-&gt;TState = ObjectWaiter::TS_ENTER ; 
      p-&gt;_prev = q ; 
      q = p ; 
    }
    ObjectWaiter * Tail ; 
    for (Tail = _EntryList ; Tail != NULL &amp;&amp; Tail-&gt;_next != NULL ; Tail = Tail-&gt;_next) ; 
    if (Tail == NULL) { 
      _EntryList = w ; 
    } else { 
      Tail-&gt;_next = w ; 
      w-&gt;_prev = Tail ; 
    } 
  }
  
  // qmode =4：cxq队列插入到_EntryList头部 
  if (QMode == 4 &amp;&amp; _cxq != NULL) { 
    w = _cxq ; 
    for (;;) { 
      assert (w != NULL， &quot;Invariant&quot;) ; 
      ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL， 
      &amp;_cxq， w) ; 
      if (u == w) break ; 
      w = u ;
    }
    assert (w != NULL ， &quot;invariant&quot;) ; 
    
    ObjectWaiter * q = NULL ; 
    ObjectWaiter * p ; 
    for (p = w ; p != NULL ; p = p-&gt;_next) { 
      guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ， &quot;Invariant&quot;) ; 
      p-&gt;TState = ObjectWaiter::TS_ENTER ; 
      p-&gt;_prev = q ; 
      q = p ; 
    }
    if (_EntryList != NULL) { 
      q-&gt;_next = _EntryList ; 
      _EntryList-&gt;_prev = q ; 
    }
    _EntryList = w ; 
  }
  w = _EntryList ; 
  if (w != NULL) { 
    assert (w-&gt;TState == ObjectWaiter::TS_ENTER， &quot;invariant&quot;) ; 
    ExitEpilog (Self， w) ; 
    return ; 
  }
  w = _cxq ; 
  if (w == NULL) continue ; 
  for (;;) { 
    assert (w != NULL， &quot;Invariant&quot;) ; 
    ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL， &amp;_cxq，w) ; 
    if (u == w) break ; 
    w = u ; 
  }
  TEVENT (Inflated exit - drain cxq into EntryList) ; 
  assert (w != NULL ， &quot;invariant&quot;) ; 
  assert (_EntryList == NULL ， &quot;invariant&quot;) ; 
  if (QMode == 1) { 
    // QMode == 1 : drain cxq to EntryList， reversing order 
    // We also reverse the order of the list. 
    ObjectWaiter * s = NULL ; 
    ObjectWaiter * t = w ; 
    ObjectWaiter * u = NULL ; 
    while (t != NULL) { 
      guarantee (t-&gt;TState == ObjectWaiter::TS_CXQ， &quot;invariant&quot;) ; 
      t-&gt;TState = ObjectWaiter::TS_ENTER ; 
      u = t-&gt;_next ; 
      t-&gt;_prev = u ; 
      t-&gt;_next = s ; 
      s = t; 
      t = u ; 
    }
    _EntryList = s ; 
    assert (s != NULL， &quot;invariant&quot;) ;
  } else { 
    // QMode == 0 or QMode == 2 
    _EntryList = w ; 
    ObjectWaiter * q = NULL ; 
    ObjectWaiter * p ; 
    for (p = w ; p != NULL ; p = p-&gt;_next) { 
      guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ， &quot;Invariant&quot;) ; 
      p-&gt;TState = ObjectWaiter::TS_ENTER ; 
      p-&gt;_prev = q ; 
      q = p ; 
      } 
    }
    if (_succ != NULL) continue; 
    
    w = _EntryList ; 
    if (w != NULL) { 
      guarantee (w-&gt;TState == ObjectWaiter::TS_ENTER， &quot;invariant&quot;) ; 
      ExitEpilog (Self， w) ; // 唤醒线程
      return ; 
    } 
  } 
}
</code></pre>
<ol>
<li>退出同步代码块时会让 _recursions 减 1，当 _recursions 的值减为0时，说明线程释放了锁。</li>
<li>根据不同的策略（由QMode指定），从 _cxq 或 EntryList 中获取头节点，通过ObjectMonitor::ExitEpilog 方法唤醒该节点封装的线程，唤醒操作最终由 unpark 完成，实现如下：</li>
</ol>
<pre><code>void ObjectMonitor::ExitEpilog (Thread * Self， ObjectWaiter * Wakee) { 
  assert (_owner == Self， &quot;invariant&quot;) ; 
  
  _succ = Knob_SuccEnabled ? Wakee-&gt;_thread : NULL ; 
  ParkEvent * Trigger = Wakee-&gt;_event ; 
  
  Wakee = NULL ; 
  
  // Drop the lock 
  OrderAccess::release_store_ptr (&amp;_owner， NULL) ; 
  OrderAccess::fence() ; // ST _owner vs LD in 
  unpark() 
  if (SafepointSynchronize::do_call_back()) { 
    TEVENT (unpark before SAFEPOINT) ; 
  }
  
  DTRACE_MONITOR_PROBE(contended__exit， this， object()， Self); 
  Trigger-&gt;unpark() ; // 唤醒之前被pack()挂起的线程. 
  
  // Maintain stats and report events to JVMTI 
  if (ObjectMonitor::_sync_Parks != NULL) { 
    ObjectMonitor::_sync_Parks-&gt;inc() ; 
  } 
}
</code></pre>
<p>被唤醒的线程，会回到 void ATTR ObjectMonitor::EnterI (TRAPS) 的第600行，继续执行monitor 的竞争。</p>
<pre><code>// park self 
if (_Responsible == Self || (SyncFlags &amp; 1)) { 
  TEVENT (Inflated enter - park TIMED) ; 
  Self-&gt;_ParkEvent-&gt;park ((jlong) RecheckInterval) ; 
  // Increase the RecheckInterval， but clamp the value. 
  RecheckInterval *= 8 ; 
  if (RecheckInterval &gt; 1000) RecheckInterval = 1000 ; 
} else { 
  TEVENT (Inflated enter - park UNTIMED) ; 
  Self-&gt;_ParkEvent-&gt;park() ; 
}
if (TryLock(Self) &gt; 0) break ;
</code></pre>
<h3 id="monitor是重量级锁">monitor是重量级锁</h3>
<p>可以看到 ObjectMonitor 的函数调用中会涉及到 Atomic::cmpxchg_ptr，Atomic::inc_ptr 等内核函数，执行同步代码块，没有竞争到锁的对象会 park() 被挂起，竞争到锁的线程会 unpark() 唤醒。这个时候就会存在操作系统<strong>用户态和内核态的转换</strong>，这种切换会消耗大量的系统资源。所以synchronized 是 Java 语言中是一个重量级(Heavyweight)的操作。</p>
<p>用户态和和内核态是什么东西呢？要想了解用户态和内核态还需要先了解一下 Linux 系统的体系架构：</p>
<figure data-type="image" tabindex="17"><img src="https://epitomm.github.io/post-images/Linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center">Linux系统的体系架构</p>
<p>从上图可以看出，Linux操作系统的体系架构分为：用户空间（应用程序的活动空间）和内核。</p>
<p><strong>内核</strong>：本质上可以理解为一种软件，控制计算机的硬件资源，并提供上层应用程序运行的环境。</p>
<p><strong>用户空间</strong>：上层应用程序活动的空间。应用程序的执行必须依托于内核提供的资源，包括CPU资源、存储资源、I/O资源等。</p>
<p><strong>系统调用</strong>：为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用。</p>
<p>所有进程初始都运行于用户空间，此时即为用户运行状态（简称：用户态）；但是当它调用系统调用执行某些操作时，例如 I/O调用，此时需要陷入内核中运行，我们就称进程处于内核运行态（或简称为内核态）。 系统调用的过程可以简单理解为：</p>
<ol>
<li>用户态程序将一些数据值放在寄存器中， 或者使用参数创建一个堆栈， 以此表明需要操作系统提供的服务。</li>
<li>用户态程序执行系统调用。</li>
<li>CPU切换到内核态，并跳到位于内存指定位置的指令。</li>
<li>系统调用处理器(system call handler)会读取程序放入内存的数据参数，并执行程序请求的服务。</li>
<li>系统调用完成后，操作系统会重置CPU为用户态并返回系统调用的结果。</li>
</ol>
<p>由此可见用户态切换至内核态需要传递许多变量，同时内核还需要保护好用户态在切换时的一些寄存器值、变量等，以备内核态切换回用户态。<strong>这种切换就带来了大量的系统资源消耗</strong>，这就是在 synchronized 未优化之前，效率低的原因。</p>
<h1 id="第六章jdk6-synchronized优化">第六章：JDK6 synchronized优化</h1>
<h2 id="cas">CAS</h2>
<p>CAS的全称是： Compare And Swap(比较相同再交换)。是现代CPU广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。</p>
<p>CAS的作用：CAS可以将比较和交换转换为原子操作，这个<strong>原子操作直接由CPU保证</strong>。CAS可以保证共享变量赋值时的原子操作。CAS操作依赖3个值：内存中的值V，旧的预估值X，要修改的新值B，如果旧的预估值X等于内存中的值V，就将新的值B保存到内存中。</p>
<p><strong>CAS 和 volatile 实现无锁并发</strong></p>
<pre><code>package com.itheima.demo05_cas;
import java.util.ArrayList;
import java.util.concurrent.atomic.AtomicInteger;
public class Demo01 {
    public static void main(String[] args) throws InterruptedException {
        AtomicInteger atomicInteger = new AtomicInteger();
        Runnable mr = () -&gt; {
            for (int i = 0; i &lt; 1000; i++) {
                atomicInteger.incrementAndGet();
            }
        };
        ArrayList&lt;Thread&gt; ts = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 5; i++) {
            Thread t = new Thread(mr);
            t.start();
            ts.add(t);
        }
        for (Thread t : ts) {
            t.join();
        }
        System.out.println(&quot;atomicInteger = &quot; + atomicInteger.get());
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>atomicInteger  = 5000
</code></pre>
<h3 id="cas原理">CAS原理</h3>
<p>通过刚才 AtomicInteger 的源码我们可以看到，Unsafe 类提供了原子操作。</p>
<p><strong>Unsafe类介绍</strong></p>
<p>Unsafe 类使 Java 拥有了像 C 语言的指针一样操作内存空间的能力，同时也带来了指针的问题。过度的使用 Unsafe 类会使得出错的几率变大，因此 Java 官方并不建议使用的，官方文档也几乎没有。Unsafe 对象不能直接调用，只能通过反射获得。</p>
<figure data-type="image" tabindex="18"><img src="https://epitomm.github.io/post-images/unsafe%E7%B1%BB.png" alt="图片" loading="lazy"></figure>
<pre><code>public class AtomicInteger extends Number implements java.io.Serializable {
    private static final long serialVersionUID = 6214790243416807050L;

    // setup to use Unsafe.compareAndSwapInt for updates
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    // value 的偏移地址
    private static final long valueOffset;

    static {
        try {
            valueOffset = unsafe.objectFieldOffset
                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));
        } catch (Exception ex) {
             throw new Error(ex); 
        }
    }
    // 数字保存在 value 中。根据 AtomicInteger 对象的内存地址 和 value 的偏移地址，找到 value 的值
    private volatile int value;
</code></pre>
<p><strong>Unsafe实现CAS</strong><br>
<img src="https://epitomm.github.io/post-images/unsafe%E5%AE%9E%E7%8E%B0CAS.png" alt="图片" loading="lazy"></p>
<h3 id="乐观锁和悲观锁">乐观锁和悲观锁</h3>
<p><strong>悲观锁</strong>从悲观的角度出发：</p>
<p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞。因此<strong>synchronized</strong>我们也将其称之为悲观锁。JDK中的<strong>ReentrantLock</strong>也是一种悲观锁。性能较差！</p>
<p><strong>乐观锁</strong>从乐观的角度出发:</p>
<p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，就算改了也没关系，再重试即可。所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去修改这个数据，如果没有人修改则更新，如果有人修改则重试。</p>
<p>CAS这种机制我们也可以将其称之为乐观锁。综合性能较好！</p>
<blockquote>
<p>CAS获取共享变量时，为了保证该变量的可见性，需要使用volatile修饰。结合CAS和volatile可以实现无锁并发，适用于竞争不激烈、多核 CPU 的场景下。</p>
<ol>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一。</li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响。</li>
</ol>
</blockquote>
<h3 id="小结-12">小结</h3>
<ul>
<li><strong>CAS的作用?</strong>
<ul>
<li>Compare And Swap，CAS可以将比较和交换转换为原子操作，这个原子操作直接由处理器保证。</li>
</ul>
</li>
<li><strong>CAS的原理？</strong>
<ul>
<li>CAS需要3个值:内存地址V，旧的预期值A，要修改的新值B，如果内存地址V和旧的预期值A相等就修改内存地址值为B</li>
</ul>
</li>
</ul>
<h2 id="synchronized锁升级过程">synchronized锁升级过程</h2>
<p>高效并发是从 JDK5 到 JDK6 的一个重要改进，HotSpot 虛拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术，包括偏向锁( Biased Locking )、轻量级锁( Lightweight Locking )和如适应性自旋(Adaptive Spinning)、锁消除( Lock Elimination)、锁粗化( Lock Coarsening )等，这些技术都是为了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。</p>
<p><strong>无锁 --&gt; 偏向锁 --&gt; 轻量级锁 –&gt; 重量级锁</strong></p>
<h2 id="java对象的布局">Java对象的布局</h2>
<p>术语参考: <a href="http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html">http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html</a></p>
<p>在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。如下图所示：</p>
<figure data-type="image" tabindex="19"><img src="https://epitomm.github.io/post-images/%E5%AF%B9%E8%B1%A1%E5%A4%B4.png" alt="图片" loading="lazy"></figure>
<h3 id="对象头">对象头</h3>
<p>当一个线程尝试访问 synchronized 修饰的代码块时，它首先要获得锁，那么这个锁到底存在哪里呢？是存在锁对象的对象头中的。</p>
<p>HotSpot 采用 instanceOopDesc 和 arrayOopDesc 来描述对象头，arrayOopDesc 对象用来描述数组类型。instanceOopDesc 的定义的在 Hotspot 源码的 instanceOop.hpp 文件中，另外，arrayOopDesc 的定义对应 arrayOop.hpp 。</p>
<pre><code>class instanceOopDesc : public oopDesc {
    public:
    // aligned header size.
    static int header_size() { return sizeof(instanceOopDesc)/HeapWordSize; }
    // If compressed, the offset of the fields of the instance may not be aligned.
    static int base_offset_in_bytes() {
    // offset computation code breaks if UseCompressedClassPointers
    // only is true
            return (UseCompressedOops &amp;&amp; UseCompressedClassPointers) ?
            klass_gap_offset_in_bytes() :
            sizeof(instanceOopDesc);
    }
    static bool contains_field_offset(int offset, int nonstatic_field_size) {
        int base_in_bytes = base_offset_in_bytes();
        return (offset &gt;= base_in_bytes &amp;&amp;
            (offset-base_in_bytes) &lt; nonstatic_field_size * heapOopSize);
    }
};
</code></pre>
<p>从 instanceOopDesc 代码中可以看到 instanceOopDesc 继承自 oopDesc，oopDesc 的定义在Hotspot 源码中的 oop.hpp 文件中。</p>
<pre><code>class oopDesc {
    friend class VMStructs;
   private:
    volatile markOop _mark;
    union _metadata {
        Klass* _klass;
        narrowKlass _compressed_klass;
    } _metadata;
// Fast access to barrier set. Must be initialized. 
    static BarrierSet* _bs;
// 省略其他代码 
};
</code></pre>
<p>在普通实例对象中，oopDesc 的定义包含两个成员，分别是 _mark 和 _metadata</p>
<p>_mark 表示<strong>对象标记</strong>、属于 markOop 类型，也就是接下来要讲解的 Mark World，它记录了<strong>对象和锁有关的信息</strong></p>
<p>_metadata 表示<strong>类元信息</strong>，类元信息存储的是<strong>对象指向它的类元数据(Klass)的首地址</strong>，其中 Klass 表示普通指针、 _compressed_klass 表示压缩类指针。</p>
<figure data-type="image" tabindex="20"><img src="https://epitomm.github.io/post-images/%E5%AF%B9%E8%B1%A1%E5%A4%B4.png" alt="图片" loading="lazy"></figure>
<p>对象头由两部分组成，一部分用于存储自身的运行时数据，称之为 Mark Word，另外一部分是类型指针，及对象指向它的类元数据的指针。</p>
<p><strong>Mark Word</strong></p>
<p>Mark Word用于存储<strong>对象自身的运行时数据</strong>，如<strong>哈希码（HashCode）、GC分代年龄、锁状态标志、 线程持有的锁、偏向线程ID、偏向时间戳</strong>等等，占用内存大小与虚拟机位长一致。Mark Word对应的类型是 markOop 。源码位于 markOop.hpp 中。</p>
<pre><code>// Bit-format of an object header (most significant first, big endian layout below): 
//
// 32 bits: 
// -------- 
// hash:25 ------------&gt;| age:4 biased_lock:1 lock:2 (normal object)// JavaThread*:23 epoch:2 age:4 biased_lock:1 lock:2 (biased object) 
// size:32 ------------------------------------------&gt;| (CMS free block) 
// PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object) 
//
// 64 bits: 
// -------- 
// unused:25 hash:31 --&gt;| unused:1 age:4 biased_lock:1 lock:2 (normal object) 
// JavaThread*:54 epoch:2 unused:1 age:4 biased_lock:1 lock:2 (biased object) 
// PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object) 
// size:64 -----------------------------------------------------&gt;| (CMS free block) 
// [JavaThread* | epoch | age | 1 | 01] lock is biased toward given thread 
// [0 | epoch | age | 1 | 01] lock is anonymously biased 
//
// - the two lock bits are used to describe three states: locked/unlocked and monitor. 
//
// [ptr | 00] locked ptr points to real header on stack 
// [header | 0 | 01] unlocked regular object header 
// [ptr | 10] monitor inflated lock (header is wapped out) 
// [ptr | 11] marked used by markSweep to mark an object 
// not valid at any other time 
</code></pre>
<figure data-type="image" tabindex="21"><img src="https://epitomm.github.io/post-images/%E5%AF%B9%E8%B1%A1%E5%A4%B42.png" alt="图片" loading="lazy"></figure>
<p>在64位虚拟机下，Mark Word 是 64bit 大小的，其存储结构如下：</p>
<figure data-type="image" tabindex="22"><img src="https://epitomm.github.io/post-images/64%E4%BD%8D%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E5%A4%B4.png" alt="图片" loading="lazy"></figure>
<p>在32位虚拟机下，Mark Word 是 32bit 大小的，其存储结构如下：</p>
<figure data-type="image" tabindex="23"><img src="https://epitomm.github.io/post-images/32%E4%BD%8D%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E5%A4%B4.png" alt="图片" loading="lazy"></figure>
<p><strong>klass pointer</strong></p>
<p>这一部分用于存储对象的类型指针，该指针指向它的类元数据，JVM通过这个指针确定对象是<strong>哪个类的实例</strong>。该指针的位长度为 JVM 的一个字大小，即 32 位的 JVM 为 32 位，64 位的 JVM 为 64 位。</p>
<p>如果应用的对象过多，使用 64 位的指针将浪费大量内存，统计而言，64 位的 JVM 将会比 32 位的 JVM 多耗费 50% 的内存。为了节约内存可以使用选项 <code>-XX:+UseCompressedOops</code> 开启指针压缩，其中，oop 即 ordinary object pointer 普通对象指针。开启该选项后，下列指针将压缩至 32 位：</p>
<ol>
<li>每个Class的属性指针（即静态变量）</li>
<li>每个对象的属性指针（即对象变量）</li>
<li>普通对象数组的每个元素指针</li>
</ol>
<p>当然，也不是所有的指针都会压缩，一些特殊类型的指针 JVM 不会优化，比如指向 PermGen 的 Class 对象指针(JDK8 中指向元空间的 Class 对象指针)、本地变量、堆栈元素、入参、返回值和 NULL 指针等。</p>
<p>对象头 = Mark Word + 类型指针（未开启指针压缩的情况下）</p>
<p>在32位系统中，Mark Word = 4 bytes，类型指针 = 4bytes，对象头 = 8 bytes = 64 bits；</p>
<p>在64位系统中，Mark Word = 8 bytes，类型指针 = 8bytes，对象头 = 16 bytes = 128bits；</p>
<h3 id="实例数据">实例数据</h3>
<p>就是类中定义的成员变量。</p>
<h3 id="对齐填充">对齐填充</h3>
<p>对齐填充并不是必然存在的，也没有什么特别的意义，他仅仅起着占位符的作用，由于 HotSpot VM 的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头正好是8字节的倍数，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h3 id="查看java对象布局">查看Java对象布局</h3>
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;
  &lt;artifactId&gt;jol-core&lt;/artifactId&gt;
  &lt;version&gt;0.9&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code>package com.itheima.demo06_object_layout;

public class LockObj {
    private int x;
    private boolean b;
}
</code></pre>
<pre><code>package com.itheima.demo06_object_layout;

import org.openjdk.jol.info.ClassLayout;

public class Demo01 {
    public static void main(String[] args) {
        LockObj obj = new LockObj();

        obj.hashCode();
        System.out.println(obj.hashCode());
        System.out.println(Integer.toHexString(obj.hashCode()));

        System.out.println(ClassLayout.parseInstance(obj).toPrintable());
    }
}
</code></pre>
<figure data-type="image" tabindex="24"><img src="https://epitomm.github.io/post-images/%E5%AF%B9%E8%B1%A1%E5%A4%B43.png" alt="图片" loading="lazy"></figure>
<h3 id="小结-13">小结</h3>
<p>Java对象由3部分组成，对象头，实例数据，对齐数据</p>
<p>对象头分成两部分：Mark World + Klass pointer</p>
<h2 id="偏向锁">偏向锁</h2>
<p>偏向锁是 JDK6 中的重要引进，因为HotSpot作者经过研究实践发现，在大多数情况下，<strong>锁不仅不存在多线程竞争，而且总是由同一线程多次获得</strong>，为了让线程获得锁的代价更低，引进了偏向锁。</p>
<p>偏向锁的“偏”，就是偏心的“偏”、偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程，会在对象头存储锁偏向的线程ID，以后该线程进入和退出同步块时只需要检查是否为偏向锁、锁标志位以 ThreadID 即可。</p>
<figure data-type="image" tabindex="25"><img src="https://epitomm.github.io/post-images/%E5%81%8F%E5%90%91%E9%94%81.png" alt="图片" loading="lazy"></figure>
<p>不过<strong>一旦出现多个线程竞争时必须撤销偏向锁</strong>，所以撤销偏向锁消耗的性能必须小于之前节省下来的CAS原子操作的性能消耗，不然就得不偿失了。</p>
<h3 id="偏向锁原理">偏向锁原理</h3>
<p>当线程第一次访问同步块并获取锁时，偏向锁处理流程如下：</p>
<ol>
<li>虚拟机将会把对象头中的标志位设为“01”，即偏向模式。</li>
<li>同时使用 CAS 操作把获取到这个锁的线程的 ID 记录在对象的 Mark Word 之中 ，如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。</li>
</ol>
<figure data-type="image" tabindex="26"><img src="https://epitomm.github.io/post-images/%E5%81%8F%E5%90%91%E9%94%81.png" alt="图片" loading="lazy"></figure>
<p>持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以<strong>不再进行任何同步操作</strong>，偏向锁的效率高。</p>
<h3 id="偏向锁的撤销">偏向锁的撤销</h3>
<ol>
<li>偏向锁的撤销动作必须等待<strong>全局安全点</strong> （所有线程都停下来的点。举例：统计 9 点某地有多少人，9 点让所有人停下来，不能进出，开始统计）</li>
<li><strong>暂停拥有偏向锁的线程</strong>，判断锁对象是否处于被锁定状态</li>
<li>撤销偏向锁，恢复到无锁（标志位为 <strong>01</strong>）或轻量级锁（标志位为 <strong>00</strong>）的状态</li>
</ol>
<p>偏向锁在 Java6 之后是默认启用的，但在应用程序启动几秒钟之后才激活，可以使用 <code>-XX:BiasedLockingStartupDelay=0</code> 参数关闭延迟，如果确定应用程序中所有锁通常情况下处于竞争状态，可以通过 <code>XX:-UseBiasedLocking=false</code> 参数关闭偏向锁。</p>
<h3 id="偏向锁好处">偏向锁好处</h3>
<p>偏向锁是在只有一个线程执行同步块时进一步提高性能，适用于<strong>一个线程反复获得同一锁</strong>的情况。偏向锁可以提高带有同步但无竞争的程序性能。</p>
<p>它同样是一个带有效益权衡性质的优化，也就是说，它并不一定总是对程序运行有利，如果程序中<strong>大多数的锁总是被多个不同的线程访问</strong>比如<strong>线程池</strong>，那偏向模式就是多余的。</p>
<p>在 JDK5 中偏向锁默认是关闭的，而到了 JDK6 中偏向锁已经默认开启。但在应用程序启动几秒钟之后才激活，可以使用 <code>-XX:BiasedLockingStartupDelay=0</code> 参数关闭延迟，如果确定应用程序中所有锁通常情况下处于竞争状态，可以通过 <code>XX:-UseBiasedLocking=false</code> 参数关闭偏向锁。</p>
<h3 id="小结-14">小结</h3>
<ul>
<li>偏向锁的原理是什么?</li>
</ul>
<p>当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，偏向锁设置为“1”，即偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中 ，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。</p>
<ul>
<li>偏向锁的好处是什么?</li>
</ul>
<p>偏向锁是在只有一个线程执行同步块时进一步提高性能，适用于<strong>一个线程反复获得同一锁</strong>的情况。偏向锁可以提高带有同步但无竞争的程序性能。</p>
<h2 id="轻量级锁">轻量级锁</h2>
<p>轻量级锁是 JDK6 之中加入的新型锁机制，它名字中的“轻量级”是相对于使用 monitor 的传统锁而言的，因此传统的锁机制就称为“重量级”锁。首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的。</p>
<p>引入轻量级锁的目的：在<strong>多线程交替执行同步块</strong>的情况下，尽量避免重量级锁引起的性能消耗，但是如果多个线程在同一时刻进入临界区，会导致轻量级锁膨胀升级重量级锁，所以轻量级锁的出现并非是要替代重量级锁。</p>
<h3 id="轻量级锁原理">轻量级锁原理</h3>
<figure data-type="image" tabindex="27"><img src="https://epitomm.github.io/post-images/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%86.png" alt="图片" loading="lazy"></figure>
<p>当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步骤如下： 获取锁</p>
<ol>
<li>判断当前对象是否处于无锁状态（hashcode、0、01），如果是，则 JVM 首先将在当前线程的<strong>栈帧</strong>中建立一个名为<strong>锁记录</strong>（Lock Record）的空间，用于存储<strong>锁对象目前的 Mark Word 的拷贝</strong>（官方把这份拷贝加了一个 Displaced 前缀，即 Displaced Mark Word），将对象的 Mark Word 复制到栈帧中的 Lock Record 中，将 Lock Reocrd 中的 owner 指向当前对象。</li>
<li>JVM 利用 CAS 操作尝试<strong>将对象的 Mark Word 更新为指向 Lock Record 的指针</strong>，如果<strong>成功</strong>表示<strong>竞争到锁</strong>，则将锁标志位变成 00，执行同步操作。</li>
<li>如果失败则<strong>判断当前对象的 Mark Word 是否指向当前线程的栈帧</strong>，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成 10，后面等待的线程将会进入阻塞状态。</li>
</ol>
<p><img src="https://epitomm.github.io/post-images/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81CAS%E6%93%8D%E4%BD%9C%E4%B9%8B%E5%89%8D%E5%A0%86%E6%A0%88%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81CAS%E6%93%8D%E4%BD%9C%E4%B9%8B%E5%90%8E%E5%A0%86%E6%A0%88%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="图片" loading="lazy"></p>
<h3 id="轻量级锁的释放">轻量级锁的释放</h3>
<p>轻量级锁的释放也是通过 CAS 操作来进行的，主要步骤如下：</p>
<ol>
<li>取出在获取轻量级锁保存在 Displaced Mark Word 中的数据。</li>
<li>用 CAS 操作将取出的数据替换当前对象的 Mark Word 中，如果成功，则说明释放锁成功。</li>
<li>如果 CAS 操作替换失败，说明有其他线程尝试获取该锁，则需要将轻量级锁需要膨胀升级为重量级锁。</li>
</ol>
<p>对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，<strong>在整个生命周期内都是不会存在竞争的</strong>”，如果打破这个依据则除了互斥的开销外，还有额外的 CAS 操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢。</p>
<h3 id="轻量级锁好处">轻量级锁好处</h3>
<p>在多线程<strong>交替</strong>执行同步块的情况下，可以避免重量级锁引起的性能消耗。</p>
<h3 id="小结-15">小结</h3>
<ul>
<li>轻量级锁的原理是什么？</li>
</ul>
<p>将对象的 Mark Word 复制到栈帧中的 Lock Recod 中。Mark Word 更新为指向 Lock Record 的指针。</p>
<ul>
<li>轻量级锁好处是什么？</li>
</ul>
<p>在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。</p>
<h2 id="自旋锁">自旋锁</h2>
<h3 id="自旋锁原理">自旋锁原理</h3>
<pre><code>synchronized (Demo01.class) {
  ...
  System.out.println(&quot;aaa&quot;);
}
</code></pre>
<p>前面我们讨论 monitor 实现锁的时候，知道monitor会阻塞和唤醒线程，线程的阻塞和唤醒需要CPU从用户态转为核心态，<strong>频繁的阻塞和唤醒对CPU来说是一件负担很重的工作</strong>，这些操作给系统的并发性能带来了很大的压力。同时，虚拟机的开发团队也注意到在许多应用上，<strong>共享数据的锁定状态只会持续很短的一段时间</strong>，为了这段时间阻塞和唤醒线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个<strong>忙循环(自旋) ,</strong> 这项技术就是所谓的<strong>自旋锁</strong>。<br>
自旋锁在 JDK1.4.2 中就已经引入 ，只不过默认是关闭的，可以使用 <code>-XX:+UseSpinning</code> 参数开启，在 JDK6 中就已经改为默认开启了。自旋等待不能代替阻塞，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，<strong>如果锁被占用的时间很短，自旋等待的效果就会非常好</strong>，反之，如果锁被占用的时间很长。那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。因此，自旋等待的时间必须要有一定的限度，如果在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是10次，用户可以使用参数 <code>-XX:PreBlockSpin</code>来更改。</p>
<h3 id="适应性自旋锁">适应性自旋锁</h3>
<p>在 JDK6 中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是<strong>由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</strong>。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100次循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虛拟机就会变得越来越“聪明”了。</p>
<pre><code>int ObjectMonitor::TrySpin_VaryDuration (Thread * Self) {

    // Dumb, brutal spin.  Good for comparative measurements against adaptive spinning.
    // 固定次数的自旋锁
    int ctr = Knob_FixedSpin ;
    if (ctr != 0) {
        while (--ctr &gt;= 0) {
            if (TryLock (Self) &gt; 0) return 1 ;
            SpinPause () ;
        }
        return 0 ;
    }
    // 适应性自旋锁
    for (ctr = Knob_PreSpin + 1; --ctr &gt;= 0 ; ) {
      // 如果抢到了锁
      if (TryLock(Self) &gt; 0) {
        // Increase _SpinDuration ...
        // Note that we don't clamp SpinDuration precisely at SpinLimit.
        // Raising _SpurDuration to the poverty line is key.
        int x = _SpinDuration ;
        if (x &lt; Knob_SpinLimit) {
           if (x &lt; Knob_Poverty) x = Knob_Poverty ;
           // 修改自旋时间
           _SpinDuration = x + Knob_BonusB ;
        }
        return 1 ;
      }
      SpinPause () ;
    }

    // 省略部分代码
}
</code></pre>
<h2 id="锁消除">锁消除</h2>
<p>锁消除是指虚拟机即时编译器（JIT）在运行时，对<strong>一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁</strong>进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中，<strong>堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行</strong>。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是程序员自己应该是很清楚的，怎么会在明知道不存在数据争用的情况下要求同步呢?实际上有许多同步措施并不是程序员自己加入的，同步的代码在Java程序中的普遍程度也许超过了大部分读者的想象。下面这段非常简单的代码仅仅是输出3个字符串相加的结果，无论是源码字面上还是程序语义上都没有同步。</p>
<pre><code>public class Demo01 {
    public static void main(String[] args) {
        contactString(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;);
    }

    public static String contactString(String s1, String s2, String s3) {
        return new StringBuffer().append(s1).append(s2).append(s3).toString();
    }
}
@Override
public synchronized StringBuffer append(String str) {
    toStringCache = null;
    super.append(str);
    return this;
}
</code></pre>
<p>StringBuffffer 的 append() 是一个同步方法，锁就是 this 也就是(new StringBuilder())。虚拟机发现它的动态作用域被限制在 concatString() 方法内部。也就是说, new StringBuilder()对象的引用永远不会“逃逸”到 concatString() 方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除掉，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了。</p>
<h2 id="锁粗化">锁粗化</h2>
<p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对<strong>同一个对象反复加锁和解锁</strong>，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p>
<pre><code>public class Demo01 {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i &lt; 100; i++) {
            sb.append(&quot;aa&quot;);
        }
        System.out.println(sb.toString());
    }
}
@Override
public synchronized StringBuffer append(String str) {
    toStringCache = null;
    super.append(str);
    return this;
 }
</code></pre>
<figure data-type="image" tabindex="28"><img src="https://epitomm.github.io/post-images/%E9%94%81%E7%B2%97%E5%8C%96.png" alt="图片" loading="lazy"></figure>
<h3 id="小结-16">小结</h3>
<p>什么是锁粗化？</p>
<p>JVM会探测到一连串细小的操作都使用同一个对象加锁，将同步代码块的范围放大，放到这串操作的外面，这样只需要加一次锁即可。</p>
<h2 id="平时写代码如何对synchronized优化">平时写代码如何对synchronized优化</h2>
<h3 id="减少-synchronized-的范围">减少 synchronized 的范围</h3>
<p>同步代码块中尽量短，减少同步代码块中代码的执行时间，减少锁的竞争。</p>
<pre><code>synchronized (Demo01.class) {
    System.out.println(&quot;aaa&quot;);
}
</code></pre>
<h3 id="降低synchronized锁的粒度">降低synchronized锁的粒度</h3>
<p>将一个锁拆分为多个锁提高并发度</p>
<pre><code>Hashtable hs = new Hashtable(); 
hs.put(&quot;aa&quot;, &quot;bb&quot;); 
hs.put(&quot;xx&quot;, &quot;yy&quot;);
</code></pre>
<figure data-type="image" tabindex="29"><img src="https://epitomm.github.io/post-images/Hashtable%E9%94%81%E5%AE%9A%E6%95%B4%E4%B8%AA%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="30"><img src="https://epitomm.github.io/post-images/ConcurrentHashMap%E5%B1%80%E9%83%A8%E9%94%81%E5%AE%9A.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="31"><img src="https://epitomm.github.io/post-images/LinkedBlockingQueue%E5%85%A5%E9%98%9F%E5%87%BA%E9%98%9F%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E9%94%81.png" alt="图片" loading="lazy"></figure>
<p>LinkedBlockingQueue入队和出队使用不同的锁，相对于读写只有一个锁效率要高</p>
<figure data-type="image" tabindex="32"><img src="https://epitomm.github.io/post-images/LinkedBlockingQueue%E5%85%A5%E9%98%9F%E5%87%BA%E9%98%9F%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E9%94%812.png" alt="图片" loading="lazy"></figure>
<h3 id="读写分离">读写分离</h3>
<p><strong>读取时不加锁，写入和删除时加锁</strong></p>
<p>ConcurrentHashMap，CopyOnWriteArrayList 和 ConyOnWriteSet</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode191. 位1的个数]]></title>
        <id>https://epitomm.github.io/post/leetcode-191-wei-1-de-ge-shu/</id>
        <link href="https://epitomm.github.io/post/leetcode-191-wei-1-de-ge-shu/">
        </link>
        <updated>2020-04-14T12:12:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p>
<h2 id="示例">示例</h2>
<p>示例 1：<br>
输入：00000000000000000000000000001011<br>
输出：3<br>
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。</p>
<p>示例 2：<br>
输入：00000000000000000000000010000000<br>
输出：1<br>
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。</p>
<p>示例 3：<br>
输入：11111111111111111111111111111101<br>
输出：31<br>
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。</p>
<p>提示：<br>
请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</p>
<h2 id="方法一">方法一</h2>
<h3 id="分析">分析</h3>
<p>利用与运算</p>
<pre><code>0 &amp; 0 = 0
0 &amp; 1 = 0
1 &amp; 0 = 0
1 &amp; 1 = 1
</code></pre>
<p>我们发现，1 与 任何数相与，结果为任何数。于是我们可以利用这个性质，首先初始化 count = 0，<strong>将二进制表达式中的每一位数字依次与 1 进行与运算</strong>，如果结果为 1，就代表此位二进制数为 1，count++；如果结果为 0，就代表此位二进制数为 0。最终返回 count 值即为二进制表达式中数字位数为 ‘1’ 的个数。</p>
<h3 id="实例分析">实例分析</h3>
<p>输入：00000000000000000000000000001011<br>
输出：3<br>
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。<br>
<img src="https://epitomm.github.io/post-images/leetcode191_1.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/leetcode191_2.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/leetcode191_3.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/leetcode191_4.png" alt="图片" loading="lazy"></p>
<h3 id="代码">代码</h3>
<pre><code>public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        // 字符 '1' 的个数 count 初始化为 0
        int count = 0;
        // 初始化掩码为 1
        int mark = 1;
        // 循环直至掩码左移 32 为后为 0
        while(mark != 0){
            // 将数字 n 的二进制表达式中每一位数字依次与 1 进行与运算
            if((n &amp; mark) != 0){ // 如果结果不为0，表示此位为 1
                count ++;
            }
            // 掩码左移，让前一位对应的数字与 1 进行与运算
            mark &lt;&lt;= 1;
        }
        return count;
    }
}
</code></pre>
<h3 id="复杂度分析">复杂度分析</h3>
<ul>
<li>T = O(m)<br>
遍历每一位二进制位，所以时间复杂度为 O(m)，m 为二进制位数的个数</li>
<li>S = O(1)<br>
没有使用额外的空间，所以空间复杂度为 O(1)</li>
</ul>
<h2 id="方法二">方法二</h2>
<h3 id="实例分析-2">实例分析</h3>
<p>输入：00000000000000000000000000001011<br>
输出：3<br>
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。</p>
<pre><code>n = 1011
n-1 = 1010
n &amp; n-1 = 1010
</code></pre>
<p>也就是说，对于整数 n ，n &amp; (n-1) 的效果是把 n 的二进制表示中最低位的 1 消除，有了这个特性，我们就只需不断去检查 n 是否为 0，不为 0 时，计数器 + 1，然后把它最低位的 1 消除，这样循环操作后，n 最后一定会变成 0，而计数器中保存的则是整数 n 二进制表示中 1 的个数 。<br>
<img src="https://epitomm.github.io/post-images/leetcode191_5.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/leetcode191_6.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/leetcode191_7.png" alt="图片" loading="lazy"></p>
<h3 id="代码-2">代码</h3>
<pre><code>public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int count = 0;
        while(n!= 0){
            ++count;
            n = n &amp; (n-1);
        }
        return count;
    }
}
</code></pre>
<h3 id="复杂度">复杂度</h3>
<ul>
<li>T：O(k)<br>
k 表示整数二进制表示中 1 的个数</li>
<li>S：O(1)</li>
</ul>
<h2 id="来源">来源</h2>
<p>来源：力扣（LeetCode）<br>
链接：<a href="https://leetcode-cn.com/problems/number-of-1-bits">https://leetcode-cn.com/problems/number-of-1-bits</a></p>
]]></content>
    </entry>
</feed>