<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://epitomm.github.io</id>
    <title>SSM</title>
    <updated>2020-03-26T03:30:53.917Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://epitomm.github.io"/>
    <link rel="self" href="https://epitomm.github.io/atom.xml"/>
    <subtitle>热心善良的老学姐</subtitle>
    <logo>https://epitomm.github.io/images/avatar.png</logo>
    <icon>https://epitomm.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, SSM</rights>
    <entry>
        <title type="html"><![CDATA[面试题系列 —— JVM]]></title>
        <id>https://epitomm.github.io/post/mian-shi-ti-xi-lie-jvm/</id>
        <link href="https://epitomm.github.io/post/mian-shi-ti-xi-lie-jvm/">
        </link>
        <updated>2020-03-25T11:36:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-比较-jvm-jre-jdk">1. 比较 JVM 、JRE、JDK</h1>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/jre-jvm-jdk.png" alt="图片" loading="lazy"></figure>
<ul>
<li>JVM：Java Virtual Machine：Java 虚拟机</li>
<li>JRE：Java Runtime Environment：Java 运行环境（JVM + 基础类库）</li>
<li>JDK：JVM + 基础类库 + 编译工具（java、javac、javap）</li>
</ul>
<h1 id="2-介绍下-java-内存区域-结构运行时数据区">2. 介绍下 Java 内存区域 / 结构（运行时数据区）</h1>
<h2 id="线程私有的">线程私有的：</h2>
<h3 id="程序计数器">程序计数器</h3>
<ul>
<li>作用：记录正在执行的虚拟机<strong>字节码指令的地址</strong>（如果正在执行的是本地方法则为空）</li>
<li>唯一一个<strong>不会 OutOfMemory</strong> 的内存区域</li>
</ul>
<h3 id="虚拟机栈线程栈">虚拟机栈（线程栈）</h3>
<ul>
<li>组成：<strong>栈帧</strong>（每个方法有一个栈帧）
<ul>
<li>局部变量表</li>
<li>操作数栈</li>
<li>动态链接</li>
<li>出口信息</li>
</ul>
</li>
</ul>
<blockquote>
<p>ps：几个小问题</p>
</blockquote>
<ul>
<li><strong>垃圾回收是否涉及栈内存？</strong>
<ul>
<li>栈内存放的是栈帧，每一次方法调用结束后（或抛出异常后）栈帧都会自动弹出栈，所以不需要垃圾回收来管理栈内存。</li>
</ul>
</li>
<li><strong>栈内存分配越大越好吗</strong>？
<ul>
<li>不，物理内存的大小是一定的，每个线程都有一个栈，如果栈内存过大，会让线程数变少。</li>
</ul>
</li>
<li><strong>方法内的局部变量是否线程安全</strong>？
<ul>
<li>如果方法内局部变量没有逃逸出方法，线程安全</li>
<li>如果方法内局部变量逃逸出方法的作用范围，
<ul>
<li>基本数据类型存在<strong>栈帧</strong>内，其他线程无法访问，线程安全。</li>
<li>引用数据类型存在于<strong>堆</strong>内，如果逃逸出方法（方法参数、返回值），其他线程拿到对象的引用，就可以通过引用找到堆内存中的对象进行修改，线程不安全。</li>
</ul>
</li>
</ul>
</li>
<li><strong>栈内存溢出：</strong>
<ul>
<li>栈帧过多：递归调用中没有设置正确的结束条件。</li>
<li>栈帧过大</li>
</ul>
</li>
</ul>
<h3 id="本地方法栈">本地方法栈</h3>
<ul>
<li>JVM 在调用本地方法（native 修饰的方法）时，需要为本地方法提供的内存空间。</li>
</ul>
<h2 id="线程共有的">线程共有的</h2>
<h3 id="堆">堆</h3>
<ul>
<li>通过 <strong>new</strong> 关键字创建出来的对象存放在堆内存中。</li>
<li>有<strong>垃圾回收</strong>机制。</li>
</ul>
<h3 id="方法区方法区内有常量池">方法区（方法区内有常量池）</h3>
<p>存储类结构相关的信息：成员变量、成员方法和构造器方法的代码部分、包括一些特殊方法。</p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E6%96%B9%E6%B3%95%E5%8C%BA1.6.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>HotSpot 1.6 虚拟机内存结构：<br>
方法区是一个概念，用一个<strong>永久代</strong>作为方法区的实现。永久代包括：Class 类信息、类加载器、运行时常量池。StringTable 存在于运行时常量池中。<br>
方法区与永久代：方法区是一种<strong>概念</strong>，永久代是 HotSpot 虚拟机对虚拟机规范中方法区的一种<strong>实现</strong>。</p>
</blockquote>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E6%96%B9%E6%B3%95%E5%8C%BA.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>HotSpot 1.8 虚拟机内存结构：<br>
方法区还是一个概念上的东西，方法区的实现使用<strong>元空间</strong>。元空间内包含了：Class 类信息、类加载器、常量池，不过他已经不再占用堆内存了（不是由 JVM 管理它的内存结构），移出到本地内存（<strong>操作系统内存</strong>）中。本地内存中还会放一些其他进程，有一块是元空间。StringTable 串被移动到了堆中。</p>
</blockquote>
<h1 id="3-介绍下-java-内存模型">3. 介绍下 Java 内存模型</h1>
<ul>
<li>JMM：Java Memory Mmodel</li>
<li>Java 内存模型定义了一套在<strong>多线程</strong>读写共享数据时，对数据的可见性、有序性和原子性的保障。</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/jmm.png" alt="图片" loading="lazy"></figure>
<h1 id="4-如何判断对象是否死亡">4. 如何判断对象是否死亡？</h1>
<h2 id="引用计数法">引用计数法</h2>
<p>为每个对象添加一个<strong>引用计数器</strong>，每当有一个引用指向这个对象，就把引用计数器的值 +1，当引用失效，计数器值 -1，直到引用计数器的值为 0，表示不再有引用指向这个对象，就可判定这个对象已死亡。</p>
<p>因为无法解决对象间<strong>循环引用</strong>的问题，所以主流的 Java 虚拟机中没有采用这种方法来管理内存。</p>
<h2 id="可达性分析法">可达性分析法</h2>
<p>以 GC Root 为起点向下搜索，搜索过的路径称为引用链，当一个对象到 GC Root 没有任何引用链相连时，则证明这个对象是不可用的。</p>
<h3 id="哪些对象可以作为-gc-root">哪些对象可以作为 GC Root？</h3>
<ul>
<li>虚拟机栈中局部变量引用的对象</li>
<li>本地方法栈中 JNI 中引用的对象</li>
<li>方法去区静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
</ul>
<h1 id="5-介绍一下-强引用-软引用-弱引用-虚引用">5. 介绍一下 强引用、软引用、弱引用、虚引用</h1>
<h2 id="强引用">强引用</h2>
<p>只要一个对象还有<strong>强引用</strong>指向它，它就不会被回收。</p>
<p>使用 **new **一个对象的方式来创建强引用。</p>
<pre><code>Object obj = new Object();
</code></pre>
<h2 id="软引用">软引用</h2>
<p>仅有软引用指向该对象时，在<strong>垃圾回收后，内存仍不足</strong>就会再次触发垃圾回收，回收<strong>软引用对象</strong>。可配合引用队列回收软引用本身。</p>
<p>使用** SoftReference** 类来创建软引用。</p>
<pre><code>Object obj = new Object();
SoftReference&lt;Ojbect&gt; sf = new SoftReference&lt;Object&gt;(obj);
obj = null; // 使对象只被软引用关联
</code></pre>
<h2 id="弱引用">弱引用</h2>
<p>当仅有弱引用指向该对象时，在<strong>垃圾回收</strong>时，无论内存是否充足，都会回收弱引用对象。可配合引用队列回收软引用本身。</p>
<p>使用 **WeakReference **类来创建弱引用。</p>
<pre><code>Object obj = new Object();
WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);
obj = null;
</code></pre>
<h2 id="虚引用">虚引用</h2>
<p>一个对象是否有虚引用的存在，不会对其生存时间造成影响，也<strong>无法通过虚引用得到一个对象</strong>。</p>
<p>为一个对象设置虚引用的唯一目的就是能<strong>在这个对象被回收时收到一个系统通知</strong>。</p>
<p>使用 <strong>PhantomReference</strong> 来创建虚引用。</p>
<pre><code>Object obj = new Object();
PhantomReference &lt;Object&gt; wf = new PhantomReference &lt;Object&gt;(obj, null);
obj = null;
</code></pre>
<h1 id="6-垃圾收集有哪些算法各自的特点">6. 垃圾收集有哪些算法？各自的特点？</h1>
<h2 id="标记清除算法">标记清除算法</h2>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png" alt="图片" loading="lazy"></figure>
<p>过程：</p>
<ul>
<li><strong>标记</strong>：从 GC Root 开始向下找，如果某个对象没有经过任意一条引用链，则把这个对象标记为垃圾对象</li>
<li><strong>清除</strong>：清除标记为垃圾的对象，并不是把内存中每个字节都清零，只是把这段内存的起始、结束地址放入一个空闲地址列表，下次分配内存时从空闲地址列表选择一块空闲内存进行分配。</li>
</ul>
<p>特点：</p>
<ul>
<li>速度快</li>
<li>易造成内碎片</li>
</ul>
<h2 id="标记整理算法">标记整理算法</h2>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png" alt="图片" loading="lazy"></figure>
<p>过程：</p>
<ul>
<li><strong>标记</strong>：由 GC Root 向下找，经过的路径称为引用链，如果某个对象没有经过任何一条引用链，将其标记为垃圾对象。</li>
<li><strong>整理</strong>：清理垃圾的过程中，将非垃圾对象依次向前移动，使内存更加紧凑。</li>
</ul>
<p>特点：</p>
<ul>
<li>涉及到大量对象的移动，<strong>速度慢</strong>。对象在整理的过程中，如果有其他引用指向这个对象，需要更改这些引用。</li>
<li>没有内碎片</li>
</ul>
<h2 id="复制算法">复制算法</h2>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E5%A4%8D%E5%88%B61.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/%E5%A4%8D%E5%88%B62.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/%E5%A4%8D%E5%88%B63.png" alt="图片" loading="lazy"></figure>
<p>过程：</p>
<ul>
<li>标记：将不经过引用链的对象标记垃圾对象。</li>
<li>复制：将非垃圾对象从 FROM 区域复制到 TO 区域，在复制的过程中完成了整理，FROM 区域存在的都是垃圾对象，全部清除，交换 FROM 区域和 TO 区域。</li>
</ul>
<p>特点：</p>
<ul>
<li>不会有内碎片</li>
<li>需要占用双倍空间</li>
</ul>
<h2 id="分代收集算法">分代收集算法</h2>
<p>将堆划分为新生代和老年代</p>
<ul>
<li>新生代使用：复制算法</li>
<li>老年代使用：标记-清除 算法 或 标记-整理 算法</li>
</ul>
<h1 id="7-hotspot-为什么要分为新生代和老年代">7. HotSpot 为什么要分为新生代和老年代？</h1>
<p>HotSpot 根据对象存活周期的不同将内存划分为新生代和老年代，<strong>新生代</strong>在垃圾回收后，只有少部分对象会被保留，所以采用<strong>复制算法</strong>；而<strong>老年代则</strong>有大部分对象被保留，使用<strong>标记-清除</strong> 或 <strong>标记-整理</strong> 算法。</p>
<h1 id="8-方法区的回收">8. 方法区的回收</h1>
<p>主要是对常量池的回收和类的回收。</p>
<p>类的回收需要满足三个条件：</p>
<ul>
<li>该类的所有实例已经被回收，此时堆中不存在该类的任何实例。</li>
<li>该类的类加载器已经被回收。</li>
<li>该类的类对象没有在任何地方被引用，且通过反射也无法获得该类方法。</li>
</ul>
<h1 id="9-hotspot-gc-的触发条件">9. HotSpot GC 的触发条件</h1>
<h2 id="minor-gc">Minor GC</h2>
<p>新生代中的 Eden 区域内存不足时触发 Minor GC</p>
<h2 id="full-gc">Full GC</h2>
<ul>
<li>调用 System.gc() 建议虚拟机执行 Full GC</li>
<li>老年代空间不足（大对象或长期存活的对象进入老年代导致老年代空间不足）时触发 Full GC</li>
<li>空间分配担保失败</li>
<li>JDK1.7 及以前的永久代空间不足</li>
</ul>
<h1 id="10-什么情况下新生代对象会晋升到老年代">10. 什么情况下新生代对象会晋升到老年代？</h1>
<ul>
<li>晋升年龄达到阈值的对象，会晋升到老年代。</li>
<li>大对象直接进入老年代：避免在 Eden 和 Survior 之间来回进行大量复制。</li>
<li>Minor GC 后，如果对象太大无法进入 Suirior 区，则直接进入老年代。</li>
<li>如果在 Survior 区中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄对象就可以直接进入老年代，无须等年龄达到晋升阈值。</li>
</ul>
<h1 id="11-常见的垃圾收集器有哪些">11. 常见的垃圾收集器有哪些？</h1>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="图片" loading="lazy"></figure>
<p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p>
<ul>
<li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程。</li>
<li>串行与并行：串行指的是垃圾收集器工作的时候必须停止用户线程；并行指的是垃圾收集器和用户线程同时工作。除了 CMS 和 G1之外，其他垃圾收集器都是以串行的方式执行的。</li>
</ul>
<h2 id="serial串行单线程收集器">Serial（串行单线程）收集器</h2>
<ul>
<li><strong>串行</strong>方式执行</li>
<li><strong>单线程</strong>收集器，只使用一个线程进行垃圾手机工作</li>
<li><strong>简单高效</strong>，单个 CPU 没有进程切换的开销。</li>
</ul>
<p>它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。</p>
<h2 id="parnew串行多线程-收集器">ParNew（串行多线程） 收集器</h2>
<ul>
<li><strong>串行</strong></li>
<li><strong>多线程</strong>垃圾收集器</li>
</ul>
<p>它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。</p>
<h2 id="parallel-scavenge串行多线程吞吐量-收集器">Parallel Scavenge（串行多线程吞吐量） 收集器</h2>
<ul>
<li><strong>多线程</strong>垃圾收集器</li>
<li><strong>吞吐量优先</strong>。吞吐量：CPU 用于运行用户程序的时间与总时间的比值。</li>
</ul>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p>
<p><strong>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的</strong>：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p>
<p>可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>
<h2 id="serial-old串行单线程老年代-收集器">Serial Old（串行单线程老年代） 收集器</h2>
<p>是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：</p>
<ul>
<li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>
</ul>
<h2 id="parallel-old多线程吞吐量老年代-收集器">Parallel Old（多线程吞吐量老年代） 收集器</h2>
<p>是 Parallel Scavenge 收集器的老年代版本。</p>
<p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p>
<h2 id="cms-收集器">CMS 收集器</h2>
<p>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。</p>
<p>分为以下四个流程：</p>
<ul>
<li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li>
<li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li>
<li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li>
<li>并发清除：不需要停顿。</li>
</ul>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p>
<p>具有以下缺点：</p>
<ul>
<li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li>
<li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li>
<li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li>
</ul>
<h2 id="g1-收集器">G1 收集器</h2>
<p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。 HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p>
<p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/heap.png" alt="图片" loading="lazy"></figure>
<p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/G1.png" alt="图片" loading="lazy"></figure>
<p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p>
<p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用</p>
<p>Remembered Set，在做可达性分析的时候就可以避免全堆扫描</p>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/G1_2.png" alt="图片" loading="lazy"></figure>
<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li>
<li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ul>
<p>具备如下特点：</p>
<ul>
<li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复 制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒</li>
</ul>
<h1 id="12-类加载的过程">12. 类加载的过程</h1>
<p>包含了加载、验证、准备、解析和初始化这 5 个阶段。</p>
<p><strong>1. 加载</strong></p>
<p>加载是类加载的一个阶段，注意不要混淆。</p>
<p>加载过程完成以下三件事：</p>
<ul>
<li>通过类的完全限定名称获取定义该类的二进制字节流。</li>
<li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构。</li>
<li>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。</li>
</ul>
<p>其中二进制字节流可以从以下方式中获取：</p>
<ul>
<li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。</li>
<li>从网络中获取，最典型的应用是 Applet。</li>
<li>运行时计算生成，例如动态代理技术，在 java.lang.reflflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。</li>
<li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类。</li>
</ul>
<p><strong>2. 验证</strong></p>
<p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p><strong>3. 准备</strong></p>
<p>类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。</p>
<p>实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。</p>
<p>初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。</p>
<pre><code>public static int value = 123; 
</code></pre>
<p>如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。</p>
<pre><code>public static final int value = 123; 
</code></pre>
<p><strong>4. 解析</strong><br>
将常量池的符号引用替换为直接引用的过程。</p>
<p>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p>
<p><strong>5. 初始化</strong></p>
<p>初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 <clinit>() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。</p>
<p><clinit>() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：</p>
<pre><code>public class Test { 
    static { 
        i = 0; // 给变量赋值可以正常编译通过 
        System.out.print(i); // 这句编译器会提示“非法向前引用” 
    }
    static int i = 1; 
} 
</code></pre>
<p>由于父类的 <clinit>() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：</p>
<pre><code>static class Parent { 
    public static int A = 1; 
    static { 
        A = 2; 
    } 
}
static class Sub extends Parent { 
    public static int B = A; 
}
public static void main(String[] args) { 
    System.out.println(Sub.B); // 2 
} 
</code></pre>
<p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 <clinit>() 方法。但接口与类不同的是，执行接口的 <clinit>() 方法不需要先执行父接口的 <clinit>() 方法。只有当父接口中定义的变量使<br>
用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 <clinit>() 方法。</p>
<p>虚拟机会保证一个类的 <clinit>() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 <clinit>() 方法，其它线程都会阻塞等待，直到活动线程执行 <clinit>() 方法完毕。如果在一 个类的 <clinit>() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</p>
<p><strong>类初始化时机</strong></p>
<p><strong>1. 主动引用</strong></p>
<p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：</p>
<ul>
<li>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 fifinal 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。</li>
<li>使用 java.lang.reflflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；</li>
<li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；</li>
</ul>
<p><strong>2. 被动引用</strong></p>
<p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引 用。被动引用的常见例子包括：</p>
<ul>
<li>通过子类引用父类的静态字段，不会导致子类初始化。</li>
</ul>
<pre><code>System.out.println(SubClass.value); // value 字段在 SuperClass 中定义 
</code></pre>
<p>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</p>
<pre><code>SuperClass[] sca = new SuperClass[10]; 
</code></pre>
<p>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</p>
<pre><code>System.out.println(ConstClass.HELLOWORLD);
</code></pre>
<h1 id="13-java-虚拟机中有哪些类加载器">13. Java 虚拟机中有哪些类加载器？</h1>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>名称</strong></th>
<th style="text-align:left"><strong>加载哪的类</strong></th>
<th style="text-align:center"><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Bootstrap ClassLoader（启动类加载器）</td>
<td style="text-align:left">JAVA_HOME/jre/lib</td>
<td style="text-align:center">无法直接访问</td>
</tr>
<tr>
<td style="text-align:left">Extension ClassLoader（扩展类加载器）</td>
<td style="text-align:left">JAVA_HOME/jre/lib/ext</td>
<td style="text-align:center">上级为 Bootstrap，显示为 null</td>
</tr>
<tr>
<td style="text-align:left">Application ClassLoader（应用程序类加载器）</td>
<td style="text-align:left">classpath</td>
<td style="text-align:center">上级为 Extension</td>
</tr>
<tr>
<td style="text-align:left">自定义类加载器</td>
<td style="text-align:left">自定义</td>
<td style="text-align:center">上级为 Application</td>
</tr>
</tbody>
</table>
<h1 id="14-什么是双亲委派模型">14. 什么是双亲委派模型？</h1>
<p>如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把类加载的请求委派给父类加载器去完成，每一层次的类加载器都是如此，因此所有的加载请求最终都会传送到顶层的启动类加载器中，只有当父类无法处理这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
<h1 id="15-使用双亲委派模型有什么好处">15. 使用双亲委派模型有什么好处？</h1>
<p>双亲委派模型保证了 Java 程序的稳定运行，可以<strong>避免类的重复加载</strong>（JVM 区分类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也<strong>保证了 Java 的核心 API 不被篡改</strong>。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个 java.lang.Object 类的话，那么程序运行的时候，系统就会出现多个不同的 Object 类。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试题系列 —— Java 集合]]></title>
        <id>https://epitomm.github.io/post/mian-shi-ti-xi-lie-java-ji-he/</id>
        <link href="https://epitomm.github.io/post/mian-shi-ti-xi-lie-java-ji-he/">
        </link>
        <updated>2020-03-24T11:57:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-说一说-list-set-map-三者的区别">1. 说一说 List、Set、Map 三者的区别</h1>
<ul>
<li><code>List</code> 是存储<strong>有序</strong>的集合</li>
<li><code>Set</code> 集合元素<strong>不可重复</strong></li>
<li><code>Map</code> 是存储<strong>键值对</strong>的集合</li>
</ul>
<h1 id="2-arraylist-与-linkedlist-的区别">2. ArrayList 与 LinkedList 的区别</h1>
<ol>
<li>底层存储数据结构：</li>
</ol>
<ul>
<li><code>ArrayList</code> 初始容量时 10，底层是<strong>Object 数组</strong>，所以具有数组的特性，可<strong>随机访问</strong>，并且实现了<code>RandomAccess</code> 接口标识支持随机访问。</li>
<li><code>LinkedList</code> 底层是<strong>双向链表</strong>，所以具有链表的特性，<strong>增删速度快</strong>，但每个节点都有维护前后两个指针，占用<strong>存储空间较大</strong>。</li>
</ul>
<ol start="2">
<li>增删查效率：</li>
</ol>
<ul>
<li><code>ArrayList</code> 如果添加到<strong>末尾</strong>，时间复杂度** O(1)<strong>；如果添加</strong>中间<strong>到指定 i 位置，需要把 i ~ n 位置的元素统一向后移动，时间复杂度 <strong>O(n-i)</strong>。如果</strong>按下标查找**，时间复杂度<strong>O(1)</strong>。</li>
<li><code>LinkedList</code> 如果添加<strong>末尾</strong>，时间复杂度 <strong>O(1)</strong>，如果插入到<strong>中间</strong>第 i 个位置，需要先查找到到 i 个位置的元素，查找效率 <strong>O(n)</strong>，然后执行添加操作，修改指针指向，复杂度** O(1)<strong>。如果</strong>按下标查找**，需要判断下标是否大于当前 <code>size/2</code> ，如果大于则从末尾向中间查找；否则从头向中间查找，时间复杂度** O(n)**。</li>
</ul>
<h1 id="3-arraylist-扩容机制">3. ArrayList 扩容机制</h1>
<pre><code>private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}
</code></pre>
<blockquote>
<p>上述代码基于 JDK1.8</p>
</blockquote>
<h1 id="4-arraylist-和-vector-的区别">4. ArrayList 和 Vector 的区别</h1>
<p>线程安全</p>
<ul>
<li><code>ArrayList</code> 线程不安全</li>
<li><code>Vector</code> 方法都使用 <code>synchronized</code> 修饰，所以线程安全，同时效率也低。正因为 <code>Vector</code> 效率低，所以一般不会使用，如果想实现同步，可以使用 <code>Collections.synchronizedList(new ArrayList&lt;&gt;());</code></li>
</ul>
<p>扩容机制：</p>
<ul>
<li><code>ArrayList</code> 扩容后的容量为原来的 1.5 倍</li>
<li><code>Vector</code> 扩容后的容量 是原来的 2 倍</li>
</ul>
<h1 id="5-hashmap-和-hashtable的区别">5. HashMap 和 Hashtable的区别</h1>
<p>线程安全：</p>
<ul>
<li><code>HashMap</code> 线程不安全</li>
<li><code>Hashtable</code> 的方法使用 <code>synchronized</code> 修饰，所以线程安全，也是正因为用 <code>synchronized</code> 修饰，所以效率较低。</li>
</ul>
<p>初始大小扩容机制：</p>
<ul>
<li><code>HashMap</code> 的默认初始容量为 16（2 &lt;&lt; 4）；如果指定了初始容量，会把它扩充为 2 的幂次。扩容后容量为原来的 2n</li>
<li><code>Hashtable</code> 默认初始容量时 11，如果指定初始容量，使用初始容量。扩容后容量为原来的 2n+1</li>
</ul>
<p>是否允许 null 键值</p>
<ul>
<li><code>HashMap</code> 允许 null 键值</li>
<li><code>Hashtable</code> 不允许 null 键值</li>
</ul>
<h1 id="6-hashmap-的-put-方法的具体流程">6. HashMap 的 put 方法的具体流程</h1>
<pre><code>public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/put.png" alt="图片" loading="lazy"></figure>
<ol>
<li>如果散列表为 null，<code>resize()</code> 初始化散列表</li>
<li>没有发生碰撞，直接添加元素到散列表中</li>
<li>如果发生碰撞，判断时红黑树还是链表，然后调用相应的插入方法</li>
<li>HashMap 的 resize() 扩容方法</li>
</ol>
<h1 id="7-hashmap-的-resize-扩容方法">7. HashMap 的 resize() 扩容方法</h1>
<p>如果当前容量 &gt; 阈值（容量 * 装填因子），则扩容</p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/resize.png" alt="图片" loading="lazy"></figure>
<h1 id="8-hashmap-容量为什么是-2-的幂次">8. HashMap 容量为什么是 2 的幂次</h1>
<p>减少 <code>hash</code> 冲突，因为要用 <code>hash &amp; (n-1)</code> 确定元素存在数组中的下标位置，如果 n 是 2 的幂（1000），那么 n-1 得到的结果就全为 1 （10000 - 1 = 1111），这样 <code>(n-1) &amp; hash</code> 的值就是 hash。如果 n-1 中有某位为 0，那么 0 与任何数 &amp; 结果都为0，增加了hash 冲突的概率。</p>
<h1 id="9-hashmap-17-18-对比">9. HashMap 1.7 1.8 对比</h1>
<ul>
<li>JDK1.7</li>
</ul>
<p>数据结构：数组+链表</p>
<p>JDK1.7 hash 方法：9 次扰动（4 次位运算，5 次异或运算）</p>
<pre><code>static int hash(int h) {
    // This function ensures that hashCodes that differ only by
    // constant multiples at each bit position have a bounded
    // number of collisions (approximately 8 at default load factor).
    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
}
</code></pre>
<ul>
<li>JDK 1.8</li>
</ul>
<p>数据结构：数组 + 链表 + 红黑树</p>
<p>JDK 1.8 hash 方法：2 次扰动（1 次位运算，1 次异或运算）</p>
<pre><code>static final int hash(Object key) {
    int h;
    // key.hashCode()：返回散列值也就是hashcode
    // ^ ：按位异或
    // &gt;&gt;&gt;:⽆符号右移，忽略符号位，空位都以0补⻬
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}
</code></pre>
<p>贴一张比较详细的图：<br>
<img src="https://epitomm.github.io/post-images/hashmap.png" alt="图片" loading="lazy"></p>
<p>图片来源；<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247485685&amp;idx=2&amp;sn=b393e444487c88e8c204821faddff370&amp;chksm=ebd749f4dca0c0e257e15c656f4504f224456495ad78e8aeb9ea370214ebd4b5c455b15e6045&amp;token=1948873548&amp;lang=zh_CN#rd">https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247485685&amp;idx=2&amp;sn=b393e444487c88e8c204821faddff370&amp;chksm=ebd749f4dca0c0e257e15c656f4504f224456495ad78e8aeb9ea370214ebd4b5c455b15e6045&amp;token=1948873548&amp;lang=zh_CN#rd</a></p>
<h1 id="10-hashmap-是怎么解决哈希冲突的">10. HashMap 是怎么解决哈希冲突的</h1>
<p>什么是哈希冲突：两个不同的输入值，根据同一散列函数，计算出相同的散列值。</p>
<ul>
<li>使用<strong>拉链法</strong>来链接具有相同 hash 值的数据</li>
<li>使用<strong>两次扰动函数</strong>（hash 函数）来降低哈希冲突的概率，使得<strong>数据分布更均匀</strong></li>
<li>引入<strong>红黑树</strong>降低查找的时间复杂度</li>
</ul>
<h1 id="11-hashmap-17-18多线程操作导致死循环问题">11. HashMap 1.7 1.8多线程操作导致死循环问题</h1>
<p>参考链接：<a href="https://coolshell.cn/articles/9606.html">https://coolshell.cn/articles/9606.html</a></p>
<h1 id="12-hashmap-的-key-值要是为类对象则该类需要满足什么条件">12. HashMap 的 key 值要是为类对象则该类需要满⾜什么条件？</h1>
<p><strong>重写 hashCode() 和 equals() 方法。</strong></p>
<p><code>Hashmap</code> 中放入相同的 <code>key</code>，会覆盖 <code>value</code> 值，而不是重新添加一个 <code>key-value</code> 对，这就要求我们判断 <code>key</code> 是否相同。</p>
<p>以下为 <code>HashMap</code> 的 <code>final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)</code> 方法：</p>
<pre><code>if (p.hash == hash &amp;&amp;
    ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
</code></pre>
<p>从源码得知判断分为三个步骤：①判断 <code>key</code> 的 <code>hash</code> 值是否相同，这就要求我们重写 <code>hashCode()</code> 方法；② 通过 <code>==</code> 判断 <code>key</code> 对象引用是否相等；③ 使用 <code>equals()</code> 判断对象是否相等，这就要求我们重写 <code>equals()</code> 方法。</p>
<h1 id="13-concurrenthashmap-的底层实现方式">13. ConcurrentHashMap 的底层实现方式</h1>
<p>JDK1.7</p>
<ul>
<li>数据结构：分段数组（<code>Segment</code> 继承了 <code>ReentrantLock</code>，每个段都有一个锁） + 链表（<code>HashEntry</code>）</li>
<li>线程安全：对整个桶数组进行了分割分段，每把锁只锁住一<strong>段</strong>，多线程访问其他段的数据时不会产生冲突。</li>
</ul>
<p>JDK1.8</p>
<ul>
<li>数据结构：数组 + 链表 + 红黑树</li>
<li>线程安全：部分锁定 + CAS。<code>synchronized</code> 只锁定<strong>当前链表或红黑二叉树的首节点</strong>，这样只要 hash 不冲突，就不会产生并发。</li>
</ul>
<h1 id="14-concurrenthashmap-和-hashtable-的区别">14. ConcurrentHashMap 和 Hashtable 的区别</h1>
<p><code>Hashtable</code> 数据结构：数组 + 链表</p>
<p><code>Hashtable</code> 实现线程安全：会锁住整个数组，某个线程在进行 put 操作时，其他线程只能阻塞。</p>
<h1 id="15-如何选用集合">15. 如何选用集合</h1>
<ul>
<li>如果存储键值对，选 <code>Map</code> 接口下的集合
<ul>
<li>如果需要排序，选择 <code>TreeMap</code></li>
<li>如果不需要排序，优先选择 <code>HashMap</code></li>
<li>如果需要线程安全，选择 <code>ConcurrentHashMap</code></li>
</ul>
</li>
<li>只需要存放元素值时，选择 <code>Collection</code> 接口下的集合
<ul>
<li>如果需要顺序放取，选择 <code>ArrayList</code></li>
<li>如果需要频繁增删，选择 <code>LinkedList</code></li>
<li>如果需要元素不重复且排序，选择 <code>TreeSet</code></li>
<li>如果需要元素不重复但无需排序，优先选择 <code>HashSet</code></li>
</ul>
</li>
</ul>
<p>参考链接：</p>
<p><a href="https://github.com/ZhongFuCheng3y/3y">https://github.com/ZhongFuCheng3y/3y</a></p>
<p><a href="https://github.com/Snailclimb/JavaGuide">https://github.com/Snailclimb/JavaGuide</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试题系列 —— Zookeeper]]></title>
        <id>https://epitomm.github.io/post/zookeeper-mian-shi-ti/</id>
        <link href="https://epitomm.github.io/post/zookeeper-mian-shi-ti/">
        </link>
        <updated>2020-03-14T15:40:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-谈谈你对-zookeeper-的认识">1. 谈谈你对 Zookeeper 的认识</h1>
<p><code>Zookeeper</code> 是一个<strong>分布式协调服务</strong>的开源框架。主要用来解决分布式集群中应用系统的<strong>一致性</strong>问题，例如怎样避免同时操作同一数据造成脏读的问题。</p>
<p><strong><code>ZooKeeper</code> 本质上是一个分布式的小文件存储系统</strong>。提供基于类似于文件系统的目录树方式的数据存储，并且可以对树中的节点进行有效管理。从而用来维护和监控你存储的数据的状态变化。通过监控这些数据状态的变化，从而可以达到基于数据的集群管理。诸如：统一命名服务、分布式配置管理、分布式消息队列、分布式锁、分布式协调等功能。</p>
<h1 id="2-zookeeper-特性">2. ZooKeeper 特性</h1>
<ol>
<li><strong>全局数据一致</strong>：集群中每个服务器保存一份相同的数据副本，<code>client</code> 无论连接到哪个服务器，展示的数据都是一致的，这是最重要的特征；</li>
<li><strong>可靠性</strong>：如果消息【<strong>增、删、改、查</strong>】被其中一台服务器接受，那么将被所有的服务器接受。</li>
<li><strong>顺序性</strong>：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息 a 在消息 b 前发布，则在所有 <code>Server</code> 上消息 a 都将在消息 b 前被发布；偏序是指如果一个消息 b 在消息 a 后被同一个发送者发布，a 必将排在 b 前面。</li>
<li><strong>数据更新原子性</strong>：一次数据更新要么成功（半数以上节点成功），要么失败，不存在中间状态。</li>
<li><strong>实时性</strong>：<code>Zookeeper</code> 保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。</li>
</ol>
<h1 id="3-zookeeper-数据模型">3． ZooKeeper 数据模型</h1>
<p><code>ZooKeeper</code> 的数据模型，在结构上和标准文件系统的非常相似，拥有一个层次的命名空间，都是采用<strong>树形层次结构</strong>，<code>ZooKeeper</code> 树中的每个节点被称为— <strong><code>Znode</code></strong>。和文件系统的目录树一样，<code>ZooKeeper</code> 树中的每个节点可以拥有子节点。但也有不同之处：</p>
<ol>
<li><strong><code>Znode</code> 兼具文件和目录两种特点</strong>。既像文件一样维护着数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分，并可以具有子 <code>Znode</code>。用户对 <code>Znode</code> 具有增、删、改、查等操作（权限允许的情况下）。</li>
<li><strong><code>Znode</code> 具有原子性操作</strong>，读操作将获取与节点相关的所有数据，写操作也将替换掉节点的所有数据。另外，每一个节点都拥有自己的 ACL(访问控制列表)，这个列表规定了用户的权限，即限定了特定用户对目标节点可以执行的操作。</li>
<li><strong><code>Znode</code> 存储数据大小有限制</strong>。<code>ZooKeeper</code> 虽然可以关联一些数据，但并没有被设计为常规的数据库或者大数据存储，相反的是，它用来管理调度数据，比如分布式应用中的配置文件信息、状态信息、汇集位置等等。这些数据的共同特性就是它们都是很小的数据，<strong>通常以 KB 为大小单位</strong>。ZooKeeper 的服务器和客户端都被设计为严格检查并限制每个 Znode 的数据大小至多 1M，当时常规使用中应该远小于此值。</li>
<li><strong><code>Znode</code> 通过路径引用</strong>，如同 <code>Unix</code> 中的文件路径。<strong>路径必须是绝对的</strong>，因此他们必须<strong>由斜杠字符来开头</strong>。除此以外，他们必须是唯一的，也就是说每一个路径只有一个表示，因此这些路径不能改变。在 <code>ZooKeeper</code> 中，路径由 <code>Unicode</code> 字符串组成，并且有一些限制。字符串&quot;/zookeeper&quot;用以保存管理信息，比如关键配额信息。</li>
</ol>
<h2 id="31数据结构图">3.1．数据结构图</h2>
<p><img src="https://epitomm.github.io/post-images/1584240732240.jpg" alt="" loading="lazy"><br>
图中的每个节点称为一个 <code>Znode</code>。 每个 <code>Znode</code> 由 3 部分组成:</p>
<ul>
<li><code>stat</code>：此为状态信息, 描述该 <code>Znode</code> 的版本, 权限等信息</li>
<li><code>data</code>：与该 <code>Znode</code> 关联的数据</li>
<li><code>children</code>：该 <code>Znode</code> 下的子节点</li>
</ul>
<h2 id="32节点类型">3.2．节点类型</h2>
<p><code>Znode</code> 有两种，分别为<strong>临时节点</strong>和<strong>永久节点</strong>。</p>
<p>节点的类型<strong>在创建时即被确定，并且不能改变。</strong></p>
<p><strong>临时节点</strong>：该节点的生命周期依赖于创建它们的会话。一旦<strong>会话结束，临时节点将被自动删除</strong>，当然可以也可以手动删除。<strong>临时节点不允许拥有子节点</strong>。</p>
<p><strong>永久节点</strong>：该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，他们才能被删除。</p>
<p><code>Znode</code> 还有一个<strong>序列化</strong>的特性，如果创建的时候指定的话，该 <code>Znode</code> 的名字后面会<strong>自动追加一个不断增加的序列号</strong>。序列号对于此节点的父节点来说是唯一的，这样便会<strong>记录每个子节点创建的先后顺序</strong>。它的格式为“%10d”(10 位数字，没有数值的数位用 0 补充，例如“0000000001”)。</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/1584240804281.jpg" alt="" loading="lazy"></figure>
<p>这样便会存在四种类型的 <code>Znode</code> 节点，分别对应：</p>
<ul>
<li><code>PERSISTENT</code>：永久节点</li>
<li><code>EPHEMERAL</code>：临时节点</li>
<li><code>PERSISTENT_SEQUENTIAL</code>：永久节点、序列化</li>
<li><code>EPHEMERAL_SEQUENTIAL</code>：临时节点、序列化</li>
</ul>
<h1 id="4-zookeeper-watcher">4． ZooKeeper Watcher</h1>
<p><code>ZooKeeper</code> 提供了分布式数据<strong>发布/订阅功能</strong>，一个典型的发布/订阅模型系统定义了一种一对多的订阅关系，能让多个订阅者同时监听某一个主题对象，当这个主题对象自身状态变化时，会通知所有订阅者，使他们能够做出相应的处理。</p>
<p><code>ZooKeeper</code> 中，引入了 <strong>Watcher 机制来实现这种分布式的通知功能</strong> 。 <code>ZooKeeper</code> 允许客户端向服务端注册一个 <code>Watcher</code> 监听，当服务端的一些事件触发了这个 <code>Watcher</code>，那么就会向指定客户端发送一个事件通知来实现分布式的通知功能。</p>
<p>触发事件种类很多，如：节点创建，节点删除，节点改变，子节点改变等。</p>
<p>总的来说可以概括 <code>Watcher</code> 为以下三个过程：<strong>客户端向服务端注册 <code>Watcher</code>、服务端事件发生触发 <code>Watcher</code>、客户端回调 <code>Watcher</code> 得到触发事件情况</strong></p>
<h2 id="41-watch-机制特点">4.1． Watch 机制特点</h2>
<h3 id="一次性触发"><strong>一次性触发</strong></h3>
<p>事件发生触发监听，一个 <code>watcher event</code> 就会被发送到设置监听的客户端，这种效果是一次性的，后续再次发生同样的事件，不会再次触发。</p>
<h3 id="事件封装"><strong>事件封装</strong></h3>
<p><code>ZooKeeper</code> 使用 <code>WatchedEvent</code> 对象来封装服务端事件并传递。</p>
<p><code>WatchedEvent</code> 包含了每一个事件的三个基本属性：</p>
<p><strong>通知状态（<code>keeperState</code>），事件类型（<code>EventType</code>）和节点路径（<code>path</code>）</strong></p>
<h3 id="event-异步发送"><strong>event 异步发送</strong></h3>
<p><code>watcher</code> 的通知事件从服务端发送到客户端是异步的。</p>
<h3 id="先注册再触发"><strong>先注册再触发</strong></h3>
<p><code>Zookeeper</code> 中的 <code>watch</code> 机制，必须客户端先去服务端注册监听，这样事件发送才会触发监听，通知给客户端。</p>
<h1 id="5-zookeeper-选举机制">5． ZooKeeper 选举机制</h1>
<p><code>zookeeper</code> 默认的算法是 <code>FastLeaderElection</code>，采用投票数大于半数则胜出的逻辑。</p>
<h2 id="51-概念">5.1． 概念</h2>
<p><strong>服务器 ID</strong></p>
<ul>
<li>比如有三台服务器，编号分别是 1,2,3。</li>
<li>编号越大在选择算法中的权重越大。</li>
</ul>
<p><strong>选举状态</strong></p>
<ul>
<li><code>LOOKING</code>，竞选状态。</li>
<li><code>FOLLOWING</code>，随从状态，同步 <code>leader</code> 状态，参与投票。</li>
<li><code>OBSERVING</code>，观察状态,同步 <code>leader</code> 状态，不参与投票。</li>
<li><code>LEADING</code>，领导者状态。</li>
</ul>
<p><strong>数据 ID</strong></p>
<ul>
<li>服务器中存放的最新数据 <code>version</code>。</li>
<li>值越大说明数据越新，在选举算法中数据越新权重越大。</li>
</ul>
<p><strong>逻辑时钟</strong></p>
<p>也叫投票的次数，同一轮投票过程中的逻辑时钟值是相同的。每投完一次票这个数据就会增加，然后与接收到的其它服务器返回的投票信息中的数值相比，根据不同的值做出不同的判断。</p>
<h2 id="52-全新集群选举">5.2． 全新集群选举</h2>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/1584240883089.png" alt="" loading="lazy"></figure>
<p>假设目前有 5 台服务器，<strong>每台服务器均没有数据</strong>，它们的编号分别是1,2,3,4,5,<strong>按编号依次启动</strong>，它们的选择举过程如下：</p>
<ul>
<li>服务器 1 启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器 1 的状态一直属于 <code>Looking</code>。</li>
<li>服务器 2 启动，给自己投票，同时与之前启动的服务器 1 交换结果，由于服务器 2 的编号大所以服务器 2 胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是 <code>LOOKING</code>。</li>
<li>服务器 3 启动，给自己投票，同时与之前启动的服务器 1,2 交换信息，由于服务器 3 的编号最大所以服务器 3 胜出，此时投票数正好大于半数，所以服务器 3 成为领导者，服务器 1,2 成为小弟。</li>
<li>服务器 4 启动，给自己投票，同时与之前启动的服务器 1,2,3 交换信息，尽管服务器 4 的编号大，但之前服务器 3 已经胜出，所以服务器 4 只能成为小弟。</li>
<li>服务器 5 启动，后面的逻辑同服务器 4 成为小弟。</li>
</ul>
<h2 id="53-非全新集群选举">5.3． 非全新集群选举</h2>
<p>对于运行正常的 <code>zookeeper</code> 集群，中途有机器 <code>down</code> 掉，需要重新选举时，选举过程就需要加入<strong>数据 ID</strong>、<strong>服务器 ID</strong> 和<strong>逻辑时钟</strong>。</p>
<p>数据 ID：数据新的 <code>version</code> 就大，数据每次更新都会更新 <code>version</code>。</p>
<p>服务器 ID：就是我们配置的 <code>myid</code> 中的值，每个机器一个。</p>
<p>逻辑时钟：这个值从 0 开始递增,每次选举对应一个值。 如果在同一次选举中,这个值是一致的。</p>
<p>这样选举的标准就变成：</p>
<p>1、逻辑时钟小的选举结果被忽略，重新投票；</p>
<p>2、统一逻辑时钟后，数据 id 大的胜出；</p>
<p>3、数据 id 相同的情况下，服务器 id 大的胜出；根据这个规则选出 <code>leader</code>。</p>
<h1 id="6-zookeeper-典型应用">6． ZooKeeper 典型应用</h1>
<h2 id="61-数据发布与订阅配置中心">6.1． 数据发布与订阅（配置中心）</h2>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/1584241030128.png" alt="" loading="lazy"></figure>
<p>发布与订阅模型，即所谓的配置中心，顾名思义就是<strong>发布者将数据发布到 ZK节点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新</strong>。</p>
<p>应用在启动的时候会主动来获取一次配置，同时，在节点上注册一个 <code>Watcher</code>，这样一来，以后每次配置有更新的时候，都会实时通知到订阅的客户端，从来达到获取最新配置信息的目的。比如：</p>
<p>分布式搜索服务中，索引的元信息和服务器集群机器的节点状态存放在 ZK 的一些指定节点，供各个客户端订阅使用。</p>
<p>注意：适合<strong>数据量很小的场景</strong>，这样数据更新可能会比较快。</p>
<h2 id="62-命名服务naming-service">6.2． 命名服务(Naming Service)</h2>
<p>在分布式系统中，<strong>通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息</strong>。<strong>被命名的实体通常可以是集群中的机器，提供的服务地址，远程对象等等——这些我们都可以统称他们为名字（Name）</strong>。其中较为常见的就是一些分布式服务框架中的服务地址列表。通过调用 ZK 提供的创建节点的 API，能够很容易创建一个<strong>全局唯一的 path</strong>，这个 path 就可以作为一个名称。</p>
<p>阿里巴巴集团开源的分布式服务框架 <strong>Dubbo 中使用 ZooKeeper 来作为其命名服务</strong>，维护全局的服务地址列表。</p>
<h2 id="63-分布式锁">6.3． 分布式锁</h2>
<p>分布式锁，这个主要得益于 <code>ZooKeeper</code> 保证了数据的强一致性。锁服务可以分为两类，一个是<strong>保持独占</strong>，另一个是<strong>控制时序</strong>。</p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/1584241059824.png" alt="" loading="lazy"></figure>
<p>所谓<strong>保持独占</strong>，就是所有试图来获取这个锁的客户端，最终只有一个可以成功获得这把锁。通常的做法是把 zk 上的一个 <code>znode</code> 看作是一把锁，通过 <code>create znode</code> 的方式来实现。所有客户端都去创建 <code>/distribute_lock</code> <strong>临时非序列化</strong>节点，最终成功创建的那个客户端也即拥有了这把锁。</p>
<p><strong>控制时序</strong>，就是所有试图来获取这个锁的客户端，最终都是会被安排执行，只是有个全局时序了。做法和上面基本类似，只是这里<code>/distribute_lock</code> 已经预先存在，客户端在它下面创建<strong>临时有序</strong>节点（这个可以通过节点的属性控制：<code>CreateMode.EPHEMERAL_SEQUENTIAL</code> 来指定）。Zk 的父节点（<code>/distribute_lock</code>）</p>
<p>维持一份 <code>sequence</code>,保证子节点创建的时序性，从而也形成了每个客户端的全局时序。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Gridea 检测远程连接失败]]></title>
        <id>https://epitomm.github.io/post/gridea-jian-ce-yuan-cheng-lian-jie-shi-bai/</id>
        <link href="https://epitomm.github.io/post/gridea-jian-ce-yuan-cheng-lian-jie-shi-bai/">
        </link>
        <updated>2020-02-18T16:09:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="问题一">问题一</h1>
<h3 id="我的环境">我的环境</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows10</td>
</tr>
<tr>
<td>软件版本</td>
<td>0.9.1</td>
</tr>
<tr>
<td>主题名称</td>
<td>Notes</td>
</tr>
</tbody>
</table>
<h2 id="问题描述">问题描述</h2>
<p>根据教程设置好一系列信息，经测试域名可访问，并且确保其他信息均正确</p>
<p>检查远程连接错误：<strong>远程连接失败,请检查仓库、用户名和 token 设置</strong></p>
<h2 id="问题分析">问题分析</h2>
<ol>
<li>先查看 <code>Gridea</code> 文件存储目录：C:\Users\Only\Documents\Gridea\output.git 下的 config 文件，看是否有 [remote &quot;origin&quot;] 信息，如果没有自行添加</li>
</ol>
<pre><code>[remote &quot;origin&quot;]
	url = https://你的github用户名:Token@github.com/你的github用户/仓库名
	fetch = +refs/heads/*:refs/remotes/origin/*
</code></pre>
<p>附：查看<code>Gridea</code>文件存储目录<br>
<img src="https://epitomm.github.io/post-images/1582604204611.png" alt="" loading="lazy"></p>
<ol start="2">
<li>检查错误信息：<br>
<img src="https://epitomm.github.io/post-images/1582041933549.png" alt="" loading="lazy"></li>
</ol>
<blockquote>
<p>[<em>&quot;fatal: unable to access 'https://github.com/Epitom…led to connect to github.com port 443: Timed out↵&quot;</em>]</p>
</blockquote>
<h2 id="问题解决">问题解决</h2>
<ol>
<li>谷歌 433 错误，得知是<strong>没有设置代理服务器</strong>的原因。</li>
</ol>
<p>以下为网上一高赞解决方式，可自行尝试，（不过对我的问题无效果）<br>
参考链接：<a href="https://blog.csdn.net/runningman2012/article/details/54633677">https://blog.csdn.net/runningman2012/article/details/54633677</a></p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/1582604339501.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>再次谷歌 git 如何设置代理服务器</li>
</ol>
<pre><code>git config --global http.proxy 'socks5://127.0.0.1:1080'

git config --global https.proxy 'socks5://127.0.0.1:1080'
</code></pre>
<p>参考：<a href="https://blog.csdn.net/isea533/article/details/84748009">https://blog.csdn.net/isea533/article/details/84748009</a></p>
<ol start="3">
<li>再次尝试检测远程连接成功</li>
</ol>
<p>接下来同步查看效果完成后就可以开启开心的写作之旅啦~</p>
<h1 id="问题二">问题二</h1>
<h3 id="我的环境-2">我的环境</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows10</td>
</tr>
<tr>
<td>软件版本</td>
<td>0.9.2</td>
</tr>
<tr>
<td>主题名称</td>
<td>Notes</td>
</tr>
</tbody>
</table>
<h2 id="问题描述-2">问题描述</h2>
<p>版本更新到 0.9.2 后重新安装了 Gridea ，再次检测远程连接失败</p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/1582604400732.png" alt="" loading="lazy"></figure>
<p>错误信息</p>
<pre><code>connect ETIMEDOUT 140.82.114.4:443
</code></pre>
<h2 id="问题分析-2">问题分析</h2>
<ol>
<li>cmd 命令行 ping github.com 失败。代理问题</li>
</ol>
<h2 id="问题解决-2">问题解决</h2>
<ol start="2">
<li>
<p>使用 ping 检测工具找一个能够 ping 通 github.com 的 IP，检测工具网址如下：</p>
<p><a href="http://ping.chinaz.com/github.com">http://ping.chinaz.com/github.com</a></p>
</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/1582041969896.png" alt="" loading="lazy"></figure>
<ol start="3">
<li>选择一个响应较快的 IP，添加到 C:\Windows\System32\drivers\etc\host 文件末尾：</li>
</ol>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/1582041983918.png" alt="" loading="lazy"></figure>
<pre><code>140.82.113.3 github.com
</code></pre>
<ol start="4">
<li>再次检测远程连接，成功。</li>
</ol>
]]></content>
    </entry>
</feed>