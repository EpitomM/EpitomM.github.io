<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://epitomm.github.io</id>
    <title>SSM</title>
    <updated>2020-05-17T03:54:28.519Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://epitomm.github.io"/>
    <link rel="self" href="https://epitomm.github.io/atom.xml"/>
    <subtitle>热心善良的老学姐</subtitle>
    <logo>https://epitomm.github.io/images/avatar.png</logo>
    <icon>https://epitomm.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, SSM</rights>
    <entry>
        <title type="html"><![CDATA[Spring系列（十一）Spring源码解析]]></title>
        <id>https://epitomm.github.io/post/spring-xi-lie-shi-yi-spring-yuan-ma-jie-xi/</id>
        <link href="https://epitomm.github.io/post/spring-xi-lie-shi-yi-spring-yuan-ma-jie-xi/">
        </link>
        <updated>2020-05-17T03:47:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="如何处理bean">如何处理@Bean</h1>
<p>给配置类产生 CGLIB 代理：需要维护配置类中 Bean 的作用域。</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E9%85%8D%E7%BD%AE%E7%B1%BB%E4%BA%A7%E7%94%9FCGLIB%E4%BB%A3%E7%90%86.png" alt="图片" loading="lazy"></figure>
<h2 id="enhance">enhance</h2>
<pre><code class="language-java">public Class&lt;?&gt; enhance(Class&lt;?&gt; configClass, @Nullable ClassLoader classLoader) {
   // 判断是否被代理过
   // 如何判断是否被代理？这个 AppConfig 一旦被代理了，就会产生一个EnhancedConfiguration接口。
   // 如果实现了这个接口，就代表已经被代理过了，直接 return
   if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {
      if (logger.isDebugEnabled()) {
         logger.debug(String.format(&quot;Ignoring request to enhance %s as it has &quot; +
               &quot;already been enhanced. This usually indicates that more than one &quot; +
               &quot;ConfigurationClassPostProcessor has been registered (e.g. via &quot; +
               &quot;&lt;context:annotation-config&gt;). This is harmless, but you may &quot; +
               &quot;want check your configuration and remove one CCPP if possible&quot;,
               configClass.getName()));
      }
      return configClass;
   }
   // 如果没有被代理，就cglib 代理
   Class&lt;?&gt; enhancedClass = createClass(newEnhancer(configClass, classLoader));
   if (logger.isDebugEnabled()) {
      logger.debug(String.format(&quot;Successfully enhanced %s; enhanced class name is: %s&quot;,
            configClass.getName(), enhancedClass.getName()));
   }
   return enhancedClass;
}
</code></pre>
<h2 id="newenhancer">newEnhancer</h2>
<pre><code class="language-java">private Enhancer newEnhancer(Class&lt;?&gt; configSuperClass, @Nullable ClassLoader classLoader) {
   Enhancer enhancer = new Enhancer();
   // 增强父类，cglib 是基于继承来的
   // 把当前类 configSuperClass 作为 enhancer 的父类
   enhancer.setSuperclass(configSuperClass);
   // 增强接口，为什么要增强接口？
   // 便于判断，表示一个类已经被增强了
   enhancer.setInterfaces(new Class&lt;?&gt;[] {EnhancedConfiguration.class});
   enhancer.setUseFactory(false);
   enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
   // BeanFactoryAwareGeneratorStrategy 是一个生成策略
   // 主要为生成的 CGLIB 类中添加成员变量 $$beanFactory
   // 同时基于接口 EnhancedConfiguration 的父接口 BeanFactoryAware 中的 setBeanFactory 方法，
   // 设置此变量的值为当前 Context 中的 beanFactory，这样一来我们这个 cglib 代理的对象就有了 beanFactory
   // 有了 factory 就能获得对象，而不用去通过方法获得对象了，因为通过方法获得对象不能控制其过程
   // BeanFactory 的作用是在 this 调用时拦截该调用，并直接在 beanFactory 中获得目标 bean
   enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader));
   // 过滤方法，不能每次都去 new
   enhancer.setCallbackFilter(CALLBACK_FILTER);
   enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());
   return enhancer;
}
</code></pre>
<pre><code class="language-java">private static final ConditionalCallbackFilter CALLBACK_FILTER = new ConditionalCallbackFilter(CALLBACKS);
</code></pre>
<pre><code class="language-java">private static final Callback[] CALLBACKS = new Callback[] {
      // 增强方法，主要控制 bean 的作用域，就是不让它每调用方法都去 new
      new BeanMethodInterceptor(),
      // 设置一个 BeanFactory
      new BeanFactoryAwareMethodInterceptor(),
      NoOp.INSTANCE
};
</code></pre>
<h1 id="怎样拿到-cglib-代理产生的类">怎样拿到 CGLIB 代理产生的类？</h1>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      // 初始化 Spring 的环境
      context. refresh();
      /**
       * 对目标对象的所有方法进行拦截
       */
      Enhancer enhancer = new Enhancer();
      enhancer.setSuperclass(IndexDaoImpl.class);
      // 增强接口
      enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
      // 添加方法过滤器
      enhancer.setCallback(new TestMethodCallabck());
      IndexDaoImpl indexDao = (IndexDaoImpl) enhancer.create();
      indexDao.query();
      try {
         System.in.read();
      } catch (IOException e) {
         e.printStackTrace();
      }
   }
}
</code></pre>
<pre><code class="language-java">public class TestMethodCallabck implements MethodInterceptor {
   /**
    *
    * @param o 代理对象
    * @param method 当前方法，目标对象的方法
    * @param objects 参数
    * @param methodProxy 代理对象的方法
    * @return
    * @throws Throwable
    */
   @Override
   public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
      System.out.println(&quot;method...&quot;);
      return methodProxy.invokeSuper(o,objects);
   }
}
</code></pre>
<h2 id="原始类未经过代理的">原始类（未经过代理的）</h2>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
public class AppConfig {
   @Bean
   public IndexDao indexDao2(){
      indexDao();
      return new IndexDaoImpl2();
   }
   @Bean
   public IndexDao indexDao(){
      return new IndexDaoImpl();
   }
}
</code></pre>
<h2 id="经过-cglib-代理后得到的代理类">经过 CGLIB 代理后得到的代理类</h2>
<h3 id="我们的猜测">我们的猜测</h3>
<pre><code class="language-plain">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
public class xxxx extends AppConfig implements EnhancedConfiguration{
   private BeanFactory $$beanFactory;
   @Bean
   public IndexDao indexDao2(){
      if(第一次调用){
        // 调用父类方法，让父类去 new
        proxy.invokeSuper();
      }else{
        // 如果不是第一次调用，直接从 bean 工厂中取出对象并返回
        return $$beanFactory.getBean();
      }
   }
   @Bean
   public IndexDao indexDao(){
      return new IndexDaoImpl();
   }
}
</code></pre>
<ul>
<li>代理类 extends AppConfig implements EnhancedConfiguration</li>
</ul>
<pre><code class="language-java">enhancer.setInterfaces(new Class&lt;?&gt;[] {EnhancedConfiguration.class});
</code></pre>
<ul>
<li>添加了一个属性：private BeanFactory $$beanFactory;</li>
</ul>
<p>为代理类添加了一个方法过滤器后，代理类与原始类代码有什么区别？</p>
<p>在外部调用时， AppConfig appConfig = getBean(); 拿到的对象是代理类 xxxx</p>
<p>当调用 appConfig.indexDao() 时，具体方法里面是什么样还不知道。</p>
<p>其实 indexDao() 方法并没有改变，只不过在这个方法前面还执行了一段代码进行拦截，可以调用父类方法，也可以直接调用子类方法。</p>
<h3 id="查看-cglib-生成的-class-文件">查看 CGLIB 生成的 class 文件</h3>
<p>java -classpath &quot;C:\Program Files\Java\jdk1.8.0_172\lib\sa-jdi.jar&quot; sun.jvm.hotspot.HSDB</p>
<pre><code class="language-java">Only@DESKTOP-MHJI7PB MINGW64 ~/Downloads/spring-framework-5.0.x
$ jps
11408 RemoteMavenServer36
22980 Test
23636 Launcher
24132 KotlinCompileDaemon
24708
22172 Jps
Only@DESKTOP-MHJI7PB MINGW64 ~/Downloads/spring-framework-5.0.x
$ java -classpath &quot;C:\Program Files\Java\jdk1.8.0_172\lib\sa-jdi.jar&quot; sun.jvm.hotspot.HSDB
</code></pre>
<p><img src="https://epitomm.github.io/post-images/%E5%BE%97%E5%88%B0CGLIB%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90%E7%9A%84class%E6%96%87%E4%BB%B6_1.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/%E5%BE%97%E5%88%B0CGLIB%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90%E7%9A%84class%E6%96%87%E4%BB%B6_2.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/%E5%BE%97%E5%88%B0CGLIB%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90%E7%9A%84class%E6%96%87%E4%BB%B6_3.png" alt="图片" loading="lazy"></p>
<p>创建完成后，在当前运行目录  ~/Downloads/spring-framework-5.0.x 下</p>
<p><img src="https://epitomm.github.io/post-images/%E5%BE%97%E5%88%B0CGLIB%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90%E7%9A%84class%E6%96%87%E4%BB%B6_4.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/%E5%BE%97%E5%88%B0CGLIB%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90%E7%9A%84class%E6%96%87%E4%BB%B6_5.png" alt="图片" loading="lazy"></p>
<pre><code class="language-java">public final void query() {
    // CGLIB$CALLBACK_0 对应 TestMethodInterceptor 类
    MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
    if (var10000 == null) {
        CGLIB$BIND_CALLBACKS(this);
        var10000 = this.CGLIB$CALLBACK_0;
    }
    if (var10000 != null) {
        // 调用 TestMethodInterceptor 的 intercept 方法
        var10000.intercept(this, CGLIB$query$0$Method, CGLIB$emptyArgs, CGLIB$query$0$Proxy);
    } else {
        super.query();
    }
}
</code></pre>
<p>JDK 动态代理是实现一个接口，CGLIB 动态代理是继承父类。</p>
<h1 id="如何判断是不是第一次调用">如何判断是不是第一次调用</h1>
<p>第一次调用 indexDao() 方法时 new IndexDaoImpl ，之后再次调用 indexDao() ，则直接从容器中拿出来，factory.getBean() ，如此保持了 IndexDaoImpl 对象的单例。</p>
<p>当 Spring 容器解析到 @Bean 时，就会调用 indexDao()，产生一个 Bean，把它放到 Spring 的 singleObjects 中，得到对象。</p>
<h2 id="intercept">intercept</h2>
<pre><code class="language-java">public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,
         MethodProxy cglibMethodProxy) throws Throwable {
   // enhancedConfigInstance 代理对象
   // 通过 enhancedConfigInstance 中 cglib 生成的成员变量 $$beanFactory 获得 beanFactory
   ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance);
   String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod);
   // Determine whether this bean is a scoped-proxy
   Scope scope = AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class);
   if (scope != null &amp;&amp; scope.proxyMode() != ScopedProxyMode.NO) {
      String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName);
      if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {
         beanName = scopedBeanName;
      }
   }
   // To handle the case of an inter-bean method reference, we must explicitly check the
   // container for already cached instances.
   // First, check to see if the requested bean is a FactoryBean. If so, create a subclass
   // proxy that intercepts calls to getObject() and returns any cached bean instance.
   // This ensures that the semantics of calling a FactoryBean from within @Bean methods
   // is the same as that of referring to a FactoryBean within XML. See SPR-6602.
   if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &amp;&amp;
         factoryContainsBean(beanFactory, beanName)) {
      // 如何判断这个 Bean 是不是 FactoryBean？
      // 从 BeanFactory 中拿 &quot;&amp;beanName&quot;，如果能够拿到，证明这就是一个 FactoryBean
      Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName);
      if (factoryBean instanceof ScopedProxyFactoryBean) {
         // Scoped proxy factory beans are a special case and should not be further proxied
      }
      else {
         // It is a candidate FactoryBean - go ahead with enhancement
         return enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName);
      }
   }
   // 判断是不是第一次调用，如果是第一次就 new；否则 factory,getBean()
   // 判断执行的方法和调用方法是不是同一个方法
   if (isCurrentlyInvokedFactoryMethod(beanMethod)) {
      // The factory is calling the bean method in order to instantiate and register the bean
      // (i.e. via a getBean() call) -&gt; invoke the super implementation of the method to actually
      // create the bean instance.
      if (logger.isWarnEnabled() &amp;&amp;
            BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {
         logger.warn(String.format(&quot;@Bean method %s.%s is non-static and returns an object &quot; +
                     &quot;assignable to Spring's BeanFactoryPostProcessor interface. This will &quot; +
                     &quot;result in a failure to process annotations such as @Autowired, &quot; +
                     &quot;@Resource and @PostConstruct within the method's declaring &quot; +
                     &quot;@Configuration class. Add the 'static' modifier to this method to avoid &quot; +
                     &quot;these container lifecycle issues; see @Bean javadoc for complete details.&quot;,
               beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()));
      }
      return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);
   }
   return resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName);
}
</code></pre>
<p>beanMethod 是当前调用的方法。</p>
<pre><code class="language-java">public void query(){
  //...具体操作
}
// query2()是调用方法，query()是执行方法
public void query2(){
  // 判断当前调用方法 query2 与执行方法 query 是否相同，如果相同，证明是第一次调用，就执行 new；如果不同，证明不是第一次调用，就执行 factory.getBean()。
  query();
  //...具体操作
}
</code></pre>
<pre><code class="language-java">public class TestMethodCallabck implements MethodInterceptor {
   /**
    *
    * @param o 代理对象
    * @param method 当前方法，目标对象的方法
    * @param objects 参数
    * @param methodProxy 代理对象的方法
    * @return
    * @throws Throwable
    */
    // 当一个方法调用时，method 与 methodProxy 相同。当在 query2()内调用 query() 时，method=query() 与 methodProxy=query2() 不同。
   @Override
   public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
      System.out.println(&quot;method...&quot;);
      return methodProxy.invokeSuper(o,objects);
   }
}
</code></pre>
<pre><code class="language-java">private boolean isCurrentlyInvokedFactoryMethod(Method method) {
   //  得到代理方法（调用方法），如果调用方法名与执行方法名相同，即method.getName().equals(currentlyInvoked.getName())，就认为是第一次调用
   Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod();
   return (currentlyInvoked != null &amp;&amp; method.getName().equals(currentlyInvoked.getName()) &amp;&amp;
         Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()));
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8.png" alt="图片" loading="lazy"></figure>
<p>第一次调用时，需要 new，直接调用父类方法，父类方法内含有 new，让父类去 new，上述 intercept 方法第 55 行：</p>
<pre><code class="language-java">cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8indexDao2.png" alt="图片" loading="lazy"></figure>
<p>首先扫描 @Bean，调用 indexDao2() 方法，</p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8indexDao.png" alt="图片" loading="lazy"></figure>
<p>调用 indexDao2() 方法内部的 indexDao() 方法</p>
<p><img src="https://epitomm.github.io/post-images/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%B0%83%E7%94%A8indexDao.png" alt="图片" loading="lazy"><br>
扫描下一个 @Bean，调用 indexDao() 方法</p>
<p>intercept 方法的第 58 行：</p>
<pre><code class="language-java">private Object resolveBeanReference(Method beanMethod, Object[] beanMethodArgs,
      ConfigurableBeanFactory beanFactory, String beanName) {
   // The user (i.e. not the factory) is requesting this bean through a call to
   // the bean method, direct or indirect. The bean may have already been marked
   // as 'in creation' in certain autowiring scenarios; if so, temporarily set
   // the in-creation status to false in order to avoid an exception.
   // 判断它是否正在创建
   boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName);
   try {
      if (alreadyInCreation) {
         beanFactory.setCurrentlyInCreation(beanName, false);
      }
      boolean useArgs = !ObjectUtils.isEmpty(beanMethodArgs);
      if (useArgs &amp;&amp; beanFactory.isSingleton(beanName)) {
         // Stubbed null arguments just for reference purposes,
         // expecting them to be autowired for regular singleton references?
         // A safe assumption since @Bean singleton arguments cannot be optional...
         for (Object arg : beanMethodArgs) {
            if (arg == null) {
               useArgs = false;
               break;
            }
         }
      }
      Object beanInstance = (useArgs ? beanFactory.getBean(beanName, beanMethodArgs) :
            beanFactory.getBean(beanName));
      if (!ClassUtils.isAssignableValue(beanMethod.getReturnType(), beanInstance)) {
         // Detect package-protected NullBean instance through equals(null) check
         if (beanInstance.equals(null)) {
            if (logger.isDebugEnabled()) {
               logger.debug(String.format(&quot;@Bean method %s.%s called as bean reference &quot; +
                     &quot;for type [%s] returned null bean; resolving to null value.&quot;,
                     beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(),
                     beanMethod.getReturnType().getName()));
            }
            beanInstance = null;
         }
         else {
            String msg = String.format(&quot;@Bean method %s.%s called as bean reference &quot; +
                  &quot;for type [%s] but overridden by non-compatible bean instance of type [%s].&quot;,
                  beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(),
                  beanMethod.getReturnType().getName(), beanInstance.getClass().getName());
            try {
               BeanDefinition beanDefinition = beanFactory.getMergedBeanDefinition(beanName);
               msg += &quot; Overriding bean of same name declared in: &quot; + beanDefinition.getResourceDescription();
            }
            catch (NoSuchBeanDefinitionException ex) {
               // Ignore - simply no detailed message then.
            }
            throw new IllegalStateException(msg);
         }
      }
      Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod();
      if (currentlyInvoked != null) {
         String outerBeanName = BeanAnnotationHelper.determineBeanNameFor(currentlyInvoked);
         beanFactory.registerDependentBean(beanName, outerBeanName);
      }
      return beanInstance;
   }
   finally {
      if (alreadyInCreation) {
         beanFactory.setCurrentlyInCreation(beanName, true);
      }
   }
}
</code></pre>
<p>一个对象有三种状态：</p>
<ul>
<li>no 没有创建
<ul>
<li>去创建它</li>
</ul>
</li>
<li>ing 在创建中
<ul>
<li>标识正在创建</li>
</ul>
</li>
<li>ed 创建成功
<ul>
<li>直接拿出来</li>
</ul>
</li>
</ul>
<p>Spring 的 getBean() 方法做了封装：没有就创建，有就直接拿。</p>
<h1 id="spring-当中-bean-的后置处理器">Spring 当中 Bean 的后置处理器</h1>
<p>Spring 当中的后置处理器是 Spring 提供的一个扩展点，程序员只要去实现 BeanPostProcessor 接口，就能插手 Bean 的实例化过程，怎么插手呢？在 Bean 被放到 Spring 这个 Bean 容器之前去插手，能够对 Bean 做一些改变。经典场景：① Bean 的生命周期回调：CommonAnnotationBeanPostProcessor、② AOP：@AspectJ</p>
<h1 id="beanfactorypostprocessor-的作用">BeanFactoryPostProcessor 的作用</h1>
<p>BeanFactoryPostProcessor 主要能够在 Spring 的 bean容器当中的任意一个类被实例化之前来回调里面的方法。经典应用场景：ConfigurationClassPostProcessor#postProcessBeanFactory，针对 @Configuration 配置类加上 CGLIB 代理</p>
<h1 id="beandefinitionregistrypostprocessor">BeanDefinitionRegistryPostProcessor</h1>
<p>是 BeanFactoryPostProcessor 的子类，在 BeanFactoryPostProcessor 之前执行。</p>
<p>Spinrg 底层源码决定的，先遍历 BeanDefinitionRegistryPostProcessor：Spring 提供的 + 自定义的：context.addBeanFactoryPostProcessor()，先执行自定义的，后执行 Spring 提供的【参照源码：refresh(); ---&gt; invokeBeanFactoryPostProcessors(beanFactory); ---&gt; invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); ---&gt; invokeBeanFactoryPostProcessors】，后遍历 BeanFactoryPostProcessor。</p>
<p>应用场景：ConfigurationClassPostProcessor 扫描、解析。ConfigurationClassPostProcessor 实现了 BeanDefinitionRegistryPostProcessor 接口，这个类当中有一个回调方法，完成了 Spring 的核心功能：扫描类，包括3种import的扫描、@Bean的扫描、判断配置类是否是一个完整的配置类，解析、解析配置类、解析 XML。</p>
<h1 id="importselector">ImportSelector</h1>
<p>通过 selectImports 方法返回一个类名（全限定类名），把它变成 bd，动态添加 bd（这个 bd 是死的）。如果用 ImportSelector，实现了 selectImports 方法，返回全限定类名，Spring 会得到这些类名，然后通过这些类名得到一个 Class，然后把它变成一个 BeanDefinition，但是把 Class 变成 BeanDefinition 的过程是由 Spring 完成的，所以这个 BeanDefinition 是死的，这个 Class 是怎样的，这个 BeanDefinition 就是怎样的。</p>
<p>ImportSelector 还可以动态扫描</p>
<pre><code class="language-java">String[] selectImports(AnnotationMetadata importingClassMetadata){
  class A extends Spring扫描器{
    A 完成扫描，返回字符串xxxx，把字符串返回给 String[],也能注入成功
  }
}
</code></pre>
<p>扫描谁都可以做，关键是扫描出来后，程序员不能把它变成 BeanDefinition，因为扫描出来的仅仅是一个 Class 或者是 Resource，怎样把它变成 BeanDefinition 呢？要么交给 Spring，让 Spring 把它变成 BeanDefinition；要么手动 new reader，然后通过一个 BeanDefinition <br>
的实现类的构造方法去 new。而 selectImports 方法只需要把它变成 Class，后续 Spring 会把它变成一个 BeanDefinition。一些应用直接扩展 ImportSlector，在里面扩展 Spring 扫描器，完成自己的扫描，经典场景 MyBatis：MyBatis 扩展 Spring 扫描器，扫描 Dao，但是扫描出来由Spring 把它变成 BeanDefinition。但是 MyBatis 用的不是 ImportSelector，因为 MyBatis 底层要做一些 BeanDefinition 的改变，ImportSelector 无法实现。</p>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Import(MapperScannerRegistrar.class)
public @interface MapperScan {
</code></pre>
<pre><code class="language-java">public class MapperScannerRegistrar implements ImportBeanDefinitionRegistrar, ResourceLoaderAware {
</code></pre>
<pre><code class="language-java">// BeanDefinitionRegistry 注册器：在注册前可以改变 BeanDefinition，然后再注册到 Spring 容器中
public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
  AnnotationAttributes annoAttrs = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));
  ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);
  // this check is needed in Spring 3.1
  if (resourceLoader != null) {
    scanner.setResourceLoader(resourceLoader);
  }
  Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass(&quot;annotationClass&quot;);
  if (!Annotation.class.equals(annotationClass)) {
    scanner.setAnnotationClass(annotationClass);
  }
  Class&lt;?&gt; markerInterface = annoAttrs.getClass(&quot;markerInterface&quot;);
  if (!Class.class.equals(markerInterface)) {
    scanner.setMarkerInterface(markerInterface);
  }
  Class&lt;? extends BeanNameGenerator&gt; generatorClass = annoAttrs.getClass(&quot;nameGenerator&quot;);
  if (!BeanNameGenerator.class.equals(generatorClass)) {
    scanner.setBeanNameGenerator(BeanUtils.instantiateClass(generatorClass));
  }
  Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = annoAttrs.getClass(&quot;factoryBean&quot;);
  if (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) {
    scanner.setMapperFactoryBean(BeanUtils.instantiateClass(mapperFactoryBeanClass));
  }
  scanner.setSqlSessionTemplateBeanName(annoAttrs.getString(&quot;sqlSessionTemplateRef&quot;));
  scanner.setSqlSessionFactoryBeanName(annoAttrs.getString(&quot;sqlSessionFactoryRef&quot;));
  List&lt;String&gt; basePackages = new ArrayList&lt;String&gt;();
  for (String pkg : annoAttrs.getStringArray(&quot;value&quot;)) {
    if (StringUtils.hasText(pkg)) {
      basePackages.add(pkg);
    }
  }
  for (String pkg : annoAttrs.getStringArray(&quot;basePackages&quot;)) {
    if (StringUtils.hasText(pkg)) {
      basePackages.add(pkg);
    }
  }
  for (Class&lt;?&gt; clazz : annoAttrs.getClassArray(&quot;basePackageClasses&quot;)) {
    basePackages.add(ClassUtils.getPackageName(clazz));
  }
  scanner.registerFilters();
  scanner.doScan(StringUtils.toStringArray(basePackages));
}
</code></pre>
<pre><code class="language-java">public class ClassPathMapperScanner extends ClassPathBeanDefinitionScanner {
</code></pre>
<h1 id="importselector-与-importbeandefinitionregistrar-的区别">ImportSelector 与  ImportBeanDefinitionRegistrar 的区别</h1>
<p>ImportSelector 与 ImportBeanDefinitionRegistrar 的区别，实现的 ImportSelector，永远停留在 BeanDefinition 级别，Bean 的级别要到 BeanPostProcessor 那里去。</p>
<p><strong>什么时候用 ImportSelector，什么时候用 ImportBeanDefinitionRegistrar</strong> ？</p>
<p>看要不要动态改变这个 BeanDefinition，如果这个 BeanDefinition 不要动态改变，就用 ImportSelector；如果需要动态改变，就用 Registrar。</p>
<p>ImportSelector 能拿到 AnnotationMetadata 注解，但是 Registrar 不一定能拿到。</p>
<p>ImportSelector 能做的事情，Registrar 都能做，但是 Registrar 能动态改变 BeanDefinition，ImportSelector 做不了。</p>
<p>ImportSelector 的 String[] selectImports(AnnotationMetadata importingClassMetadata); 返回字符串，Spring 帮忙注册。</p>
<p>ImportBeanDefinitionRegistrar 的 registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry); 提供环境 registry，让程序员自己注册。</p>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/%E6%80%BB%E7%BB%93.png" alt="图片" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring系列（十）Spring源码解析]]></title>
        <id>https://epitomm.github.io/post/spring-xi-lie-shi-spring-yuan-ma/</id>
        <link href="https://epitomm.github.io/post/spring-xi-lie-shi-spring-yuan-ma/">
        </link>
        <updated>2020-05-15T15:32:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="processconfigurationclass">processConfigurationClass</h1>
<p>context.<em>refresh</em>(); ---&gt; <em>invokeBeanFactoryPostProcessors</em>(beanFactory); ---&gt; PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); ---&gt;invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); ---&gt; postProcessor.<em>postProcessBeanDefinitionRegistry</em>(registry); ---&gt; <em>processConfigBeanDefinitions</em>(registry);处理@Configuration ---&gt; parser.parse(candidates); 解析注解对象---&gt; parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName()); ---&gt; processConfigurationClass(new ConfigurationClass(metadata, beanName)); 处理Import---&gt; sourceClass = doProcessConfigurationClass(configClass, sourceClass); ---&gt; this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()); ---&gt; scanner.doScan(StringUtils.toStringArray(basePackages));扫描包</p>
<pre><code class="language-java">protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
   // 判断是否应该跳过解析
   if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
      return;
   }
   // 处理 Imported 的情况
   // 就是当前这个类有没有被别的类 @Import
   ConfigurationClass existingClass = this.configurationClasses.get(configClass);
   if (existingClass != null) {
      if (configClass.isImported()) {
         if (existingClass.isImported()) {
            existingClass.mergeImportedBy(configClass);
         }
         // Otherwise ignore new imported config class; existing non-imported class overrides it.
         return;
      }
      else {
         // Explicit bean definition found, probably replacing an import.
         // Let's remove the old one and go with the new one.
         this.configurationClasses.remove(configClass);
         this.knownSuperclasses.values().removeIf(configClass::equals);
      }
   }
   // Recursively process the configuration class and its superclass hierarchy.
   SourceClass sourceClass = asSourceClass(configClass);
   do {
      sourceClass = doProcessConfigurationClass(configClass, sourceClass);
   }
   while (sourceClass != null);
   // 一个 map，用来存放扫描出来的 bean（注意这里的 bean 不是对象，仅仅是 bean 的信息，因为还没到实例化）
   this.configurationClasses.put(configClass, configClass);
}
</code></pre>
<h2 id="扫描普通类component并放到-map-中">扫描普通类@Component，并放到 map 中</h2>
<h3 id="doprocessconfigurationclass">doProcessConfigurationClass</h3>
<p>上述代码第 29 行：解析注解类</p>
<pre><code class="language-java">protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)
      throws IOException {
   // Recursively process any member (nested) classes first
   // 处理内部类
   processMemberClasses(configClass, sourceClass);
   // Process any @PropertySource annotations
   for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
         sourceClass.getMetadata(), PropertySources.class,
         org.springframework.context.annotation.PropertySource.class)) {
      if (this.environment instanceof ConfigurableEnvironment) {
         processPropertySource(propertySource);
      }
      else {
         logger.warn(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() +
               &quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;);
      }
   }
   // Process any @ComponentScan annotations
   Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(
         sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
   if (!componentScans.isEmpty() &amp;&amp;
         !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
      for (AnnotationAttributes componentScan : componentScans) {
         // The config class is annotated with @ComponentScan -&gt; perform the scan immediately
         // 扫描普通类=componentScan=com.ssm
         // 这里扫描出来所有 @Component
         Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =
               this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
         // Check the set of scanned definitions for any further config classes and parse recursively if needed
         // 检查扫描出来的类当中是否还有 Configuration
         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
            BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
            if (bdCand == null) {
               bdCand = holder.getBeanDefinition();
            }
            if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
               parse(bdCand.getBeanClassName(), holder.getBeanName());
            }
         }
      }
   }
   /**
    * 上面的代码就是扫描普通类——@Component
    * 并且放到了map当中
    */
   // Process any @Import annotations
   // 处理 @Import：三种情况
   // ImportSelector、ImportBeanDefinitionRegistrar、普通类
   /**
    * 这里处理的 import 是需要判断我们的类当中是否有@Import注解： getImports(sourceClass)
    * 如果有 @Import 注解，就把这个值拿出来，是一个类
    * 比如 @Import(xxxx.class)，那么这里便把 xxxx 传进去进行解析
    * 在解析的过程中如果发觉是一个 importSelector 那么就回调 selector 的方法
    * 返回一个字符串（类名），通过这个字符串得到一个类
    * 继而在递归调用本方法来处理这个类
    *
    * 判断一组类是不是 imports(3种import)
    */
   processImports(configClass, sourceClass, getImports(sourceClass), true);
   // Process any @ImportResource annotations
   AnnotationAttributes importResource =
         AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
   if (importResource != null) {
      String[] resources = importResource.getStringArray(&quot;locations&quot;);
      Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;);
      for (String resource : resources) {
         String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
         configClass.addImportedResource(resolvedResource, readerClass);
      }
   }
   // Process individual @Bean methods
   Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
   for (MethodMetadata methodMetadata : beanMethods) {
      configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
   }
   // Process default methods on interfaces
   processInterfaces(configClass, sourceClass);
   // Process superclass, if any
   if (sourceClass.getMetadata().hasSuperClass()) {
      String superclass = sourceClass.getMetadata().getSuperClassName();
      if (superclass != null &amp;&amp; !superclass.startsWith(&quot;java&quot;) &amp;&amp;
            !this.knownSuperclasses.containsKey(superclass)) {
         this.knownSuperclasses.put(superclass, configClass);
         // Superclass found, return its annotation metadata and recurse
         return sourceClass.getSuperClass();
      }
   }
   // No superclass -&gt; processing is complete
   return null;
}
</code></pre>
<p>普通类扫描后就完成了注册：上述代码第 26 行：<br>
上述代码第 31 行：</p>
<pre><code class="language-java">public Set&lt;BeanDefinitionHolder&gt; parse(AnnotationAttributes componentScan, final String declaringClass) {
   ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,
         componentScan.getBoolean(&quot;useDefaultFilters&quot;), this.environment, this.resourceLoader);
   // BeanNameGenerator：Bean名字生成器
   Class&lt;? extends BeanNameGenerator&gt; generatorClass = componentScan.getClass(&quot;nameGenerator&quot;);
   boolean useInheritedGenerator = (BeanNameGenerator.class == generatorClass);
   scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator :
         BeanUtils.instantiateClass(generatorClass));
   ScopedProxyMode scopedProxyMode = componentScan.getEnum(&quot;scopedProxy&quot;);
   if (scopedProxyMode != ScopedProxyMode.DEFAULT) {
      scanner.setScopedProxyMode(scopedProxyMode);
   }
   else {
      Class&lt;? extends ScopeMetadataResolver&gt; resolverClass = componentScan.getClass(&quot;scopeResolver&quot;);
      scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));
   }
   scanner.setResourcePattern(componentScan.getString(&quot;resourcePattern&quot;));
   // 遍历当中的过滤
   for (AnnotationAttributes filter : componentScan.getAnnotationArray(&quot;includeFilters&quot;)) {
      for (TypeFilter typeFilter : typeFiltersFor(filter)) {
         scanner.addIncludeFilter(typeFilter);
      }
   }
   for (AnnotationAttributes filter : componentScan.getAnnotationArray(&quot;excludeFilters&quot;)) {
      for (TypeFilter typeFilter : typeFiltersFor(filter)) {
         scanner.addExcludeFilter(typeFilter);
      }
   }
   // 扫描出来的这个类是否需要懒加载：默认 false
   // xml 配置懒加载：&lt;beans lazy=&quot;true&quot;&gt;&lt;bean&gt;&lt;/bean&gt;&lt;/beans&gt;
   // JavaConfig配置懒加载：@Lazy   public class AppConfig{
   boolean lazyInit = componentScan.getBoolean(&quot;lazyInit&quot;);
   if (lazyInit) {
      scanner.getBeanDefinitionDefaults().setLazyInit(true);
   }
   Set&lt;String&gt; basePackages = new LinkedHashSet&lt;&gt;();
   String[] basePackagesArray = componentScan.getStringArray(&quot;basePackages&quot;);
   for (String pkg : basePackagesArray) {
      String[] tokenized = StringUtils.tokenizeToStringArray(this.environment.resolvePlaceholders(pkg),
            ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);
      Collections.addAll(basePackages, tokenized);
   }
   for (Class&lt;?&gt; clazz : componentScan.getClassArray(&quot;basePackageClasses&quot;)) {
      basePackages.add(ClassUtils.getPackageName(clazz));
   }
   if (basePackages.isEmpty()) {
      basePackages.add(ClassUtils.getPackageName(declaringClass));
   }
   scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {
      @Override
      protected boolean matchClassName(String className) {
         return declaringClass.equals(className);
      }
   });
   return scanner.doScan(StringUtils.toStringArray(basePackages));
}
</code></pre>
<p>上述代码第 62 行，调用 doScan 方法完成扫描</p>
<pre><code class="language-java">protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) {
   Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;);
   Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;&gt;();
   // 循环所有 basePackages，因为@ComponentScan({&quot;com.ssm.dao&quot;},{&quot;com.ssm.service&quot;})可以写多个
   for (String basePackage : basePackages) {
      // 扫表 basePackage 路径下的 java 文件
      // 并把它转成 BeanDefinition 类型
      Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);
      for (BeanDefinition candidate : candidates) {
         // 解析 scope 属性
         ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
         candidate.setScope(scopeMetadata.getScopeName());
         String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
         if (candidate instanceof AbstractBeanDefinition) {
            // 如果这个类是 AbstractBeanDefinition 的子类
            // 则为它设置默认值，比如 lazy，init destroy
            postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
         }
         if (candidate instanceof AnnotatedBeanDefinition) {
            // 检查并且处理常用的注解
            // 这里的处理主要是指把常用注解的值设置到 AnnotatedBeanDefinition 当中
            // 当前前提是这个类必须是 AnnotatedBeanDefinition 类型的，说白了就是加了注解的类
            AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
         }
         if (checkCandidate(beanName, candidate)) {
            BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
            definitionHolder =
                  AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
            beanDefinitions.add(definitionHolder);
            // 加入到 map 中
            registerBeanDefinition(definitionHolder, this.registry);
         }
      }
   }
   return beanDefinitions;
}
</code></pre>
<p>上述代码第 8 行：</p>
<pre><code class="language-java">Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);
</code></pre>
<p>调用 findCandidateComponents 方法完成扫描，并把扫描出来的类都转化成 BeanDefinition，<br>
第 31 行：把所有的 BeanDefinition 注册到 map 中。</p>
<p>即：普通类扫描后就完成了注册。</p>
<pre><code class="language-java">@Import(MyImportSelector.class)
@ComponentScan
public class AppConfig{
  
}
</code></pre>
<p>上述代码完成了：扫描所有的 @ComponentScan，并把 BeanDefinition 放到 map 中。<br>
还没有开始处理 @Import。</p>
<h2 id="处理-import">处理 @Import</h2>
<p>什么时候处理 @Import呢？上述 processConfigurationClass 方法的第 64 行：</p>
<pre><code class="language-java">/**
 * 这里处理的 import 是需要判断我们的类当中是否有@Import注解： getImports(sourceClass)
 * 如果有 @Import 注解，就把这个值拿出来，是一个类
 * 比如 @Import(xxxx.class)，那么这里便把 xxxx 传进去进行解析
 * 在解析的过程中如果发觉是一个 importSelector 那么就回调 selector 的方法
 * 返回一个字符串（类名），通过这个字符串得到一个类
 * 继而在递归调用本方法来处理这个类
 *
 * 判断一组类是不是 imports(3中import)
 */
processImports(configClass, sourceClass, getImports(sourceClass), true);
</code></pre>
<h3 id="示例代码">示例代码</h3>
<p>1、有一个配置类：</p>
<p>① 扫描包 com.ssm；</p>
<p>② @Import(MyImportSelector.class)；</p>
<p>③ 通过 @Bean 注入 IndexDaoImpl2</p>
<pre><code>@ComponentScan(&quot;com.ssm&quot;)
@Import(MyImportSelector.class)
public class AppConfig {
   @Bean
   public IndexDaoImpl2 indexDaoImpl2(){
      return new IndexDaoImpl2();
   }
}
</code></pre>
<p>2、有一个 IndexDaoImpl 通过 @Repository(&quot;indexDao&quot;) 注入到 Spring 容器中。</p>
<pre><code class="language-java">@Repository(&quot;indexDao&quot;)
public class IndexDaoImpl implements IndexDao{
   @Override
   public void query() {
      System.out.println(&quot;dao...模拟查询数据库&quot;);
   }
}
</code></pre>
<p>3、有一个 IndexDaoImpl2 在此类中并未添加 @Component，但是在 AppConfig 通过 @Bean 的方式 new IndexDaoImpl2 添加到 Spring 容器中了。</p>
<pre><code class="language-java">public class IndexDaoImpl2 implements IndexDao{
   @Override
   public void query() {
      System.out.println(&quot;dao2...模拟查询数据库&quot;);
   }
}
</code></pre>
<p>4、MyImportSelector implements ImportSelector，返回 “类的字符串”，即 IndexDaoImpl3.class.getName()</p>
<pre><code class="language-java">public class MyImportSelector implements ImportSelector {
   @Override
   public String[] selectImports(AnnotationMetadata importingClassMetadata) {
      return new String[]{IndexDaoImpl3.class.getName()};
   }
}
</code></pre>
<p>5、IndexDaoImpl3 implements BeanPostProcessor</p>
<pre><code class="language-java">public class IndexDaoImpl3 implements IndexDao, BeanPostProcessor {
   @Override
   public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
      if(beanName.equals(&quot;indexDao&quot;)){
         bean = Proxy.newProxyInstance(this.getClass().getClassLoader(), new Class[]{IndexDao.class},new MyInvocationHandler(bean));
      }
      return bean;
   }
   @Override
   public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
      return null;
   }
   @Override
   public void query() {
      System.out.println(&quot;dao3...模拟查询数据库&quot;);
   }
}
</code></pre>
<p>6、MyInvocationHandler implements InvocationHandler</p>
<pre><code class="language-java">public class MyInvocationHandler implements InvocationHandler {
   Object target;
   public MyInvocationHandler(Object target){
      this.target = target;
   }
   @Override
   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
      System.out.println(&quot;代理方法...&quot;);
      return method.invoke(target,args);
   }
}
</code></pre>
<p>7、测试类</p>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      // 初始化 Spring 的环境
      context. refresh();
      IndexDao dao = (IndexDao) context.getBean(&quot;indexDao&quot;);
      dao.query();
   }
}
</code></pre>
<p>8、运行结果：</p>
<pre><code>代理方法...
dao...模拟查询数据库
</code></pre>
<h3 id="processimports">processImports</h3>
<pre><code class="language-java">private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,
      Collection&lt;SourceClass&gt; importCandidates, boolean checkForCircularImports) {
   // 如果没有加@Import，直接返回
   if (importCandidates.isEmpty()) {
      return;
   }
   if (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) {
      this.problemReporter.error(new CircularImportProblem(configClass, this.importStack));
   }
   else {
      this.importStack.push(configClass);
      try {
         for (SourceClass candidate : importCandidates) {
            // @Import(IndexDao.class)、@Import(ImportSelector)、@Import(ImportBeanDefinitionRegistrar)
            // 判断是不是 ImportSelector
            if (candidate.isAssignable(ImportSelector.class)) {
               // Candidate class is an ImportSelector -&gt; delegate to it to determine imports
               Class&lt;?&gt; candidateClass = candidate.loadClass();
               // 反射实现一个对象
               ImportSelector selector = BeanUtils.instantiateClass(candidateClass, ImportSelector.class);
               ParserStrategyUtils.invokeAwareMethods(
                     selector, this.environment, this.resourceLoader, this.registry);
               if (this.deferredImportSelectors != null &amp;&amp; selector instanceof DeferredImportSelector) {
                  this.deferredImportSelectors.add(
                        new DeferredImportSelectorHolder(configClass, (DeferredImportSelector) selector));
               }
               else {
                  // 回调
                  String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
                  Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames);
                  // 递归，这里第二次调用 processImports
                  // 如果是一个普通类，会进 else
                  processImports(configClass, currentSourceClass, importSourceClasses, false);
               }
            }
            // 判断是不是 ImportBeanDefinitionRegistrar
            else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
               // Candidate class is an ImportBeanDefinitionRegistrar -&gt;
               // delegate to it to register additional bean definitions
               Class&lt;?&gt; candidateClass = candidate.loadClass();
               ImportBeanDefinitionRegistrar registrar =
                     BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);
               ParserStrategyUtils.invokeAwareMethods(
                     registrar, this.environment, this.resourceLoader, this.registry);
               // 添加到一个 list 当中和 importSelector 不同
               configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
            }
            // 普通类：@Import(IndexDao.class)
            else {
               // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt;
               // process it as an @Configuration class
               // 否则，加入到 importStack 后调用 processConfigurationClass 进行处理
               // processConfigurationClass 里面主要就是把类放到 configurationClasses
               // configurationClasses 是一个集合，会在后面拿出来解析成 bd 继而注册
               // 可以看到普通类在扫描出来的时候就被注册了
               // 如果是 importSelector，会先放到 configurationClasses 后面进行出来注册
               this.importStack.registerImport(
                     currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
               processConfigurationClass(candidate.asConfigClass(configClass));
            }
         }
      }
      catch (BeanDefinitionStoreException ex) {
         throw ex;
      }
      catch (Throwable ex) {
         throw new BeanDefinitionStoreException(
               &quot;Failed to process import candidates for configuration class [&quot; +
               configClass.getMetadata().getClassName() + &quot;]&quot;, ex);
      }
      finally {
         this.importStack.pop();
      }
   }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/candidate.png" alt="图片" loading="lazy"></figure>
<p>上述代码第 15-20 行：</p>
<pre><code class="language-java">for (SourceClass candidate : importCandidates) {
    // @Import(IndexDao.class)、@Import(ImportSelector)、@Import(ImportBeanDefinitionRegistrar)
    // 判断是不是 ImportSelector
    if (candidate.isAssignable(ImportSelector.class)) {
    // Candidate class is an ImportSelector -&gt; delegate to it to determine imports
        Class&lt;?&gt; candidateClass = candidate.loadClass(
        
</code></pre>
<p>解析到了 @Import(MyImportSelector.class)，</p>
<pre><code class="language-java">public class MyImportSelector implements ImportSelector {
   @Override
   public String[] selectImports(AnnotationMetadata importingClassMetadata) {
      return new String[]{IndexDaoImpl3.class.getName()};
   }
}
</code></pre>
<p>解析到 @MyImportSelector 后，会返回一个 “类的字符串”，如上述代码第 4 行所示。<br>
这个 “类的字符串” 肯定会放到 map 中，但此时还没有放进去。</p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/candidateClass.png" alt="图片" loading="lazy"></figure>
<p>普通类通过 doScan 方法被扫描出来，转化成 BeanDefinition，并被加入到 map 中：所以被 @Reposity 修饰的 IndexDaoImpl 此时已经在容器中了。</p>
<h3 id="何时将-importselector-返回的字符串放到-map-中">何时将 @ImportSelector 返回的字符串放到 map 中</h3>
<p>反射实现一个对象：Spring 要知道这个 ImportSelector  到底返回了哪些字符串（return new String[]{IndexDaoImpl3.class.getName()};），然后通过这个字符串反射得到类名。</p>
<pre><code class="language-java">public class MyImportSelector implements ImportSelector {
   @Override
   public String[] selectImports(AnnotationMetadata importingClassMetadata) {
      return new String[]{IndexDaoImpl3.class.getName()};
   }
}
</code></pre>
<p>得到 selectImports 方法返回的字符串数组：String[] strs = selectImports();<br>
for(String str: strs){</p>
<p>// 通过反射得到类名</p>
<p>class = Class.forName(str);</p>
<p>}</p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/importSourceClasses.png" alt="图片" loading="lazy"></figure>
<h2 id="递归调用-processimports">递归调用 processImports</h2>
<p>得到类名 IndexDaoImpl3，正常情况可能会想：将 IndexDaoImpl3 转化成 BeanDefinition，然后放到 map 中，但是，Spring 并不是这样做的，因为有可能这个 IndexDaoImpl3 里面也有一个 @Import，所以 Spring 进行递归处理。</p>
<p>上述 processImports 方法的第 30-35 行：</p>
<pre><code class="language-java">// 得到类名
String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames);
// 递归，这里第二次调用 processImports
// 如果是一个普通类，会进 else
processImports(configClass, currentSourceClass, importSourceClasses, false);
</code></pre>
<p>于是再次调用 processImports 方法：<br>
上述 processImports  方法第 18 行判断：</p>
<pre><code class="language-java">if (candidate.isAssignable(ImportSelector.class)) {
</code></pre>
<p>IndexDaoImpl3 不是一个 ImportSelector<br>
上述 processImports  方法第 39 行判断：</p>
<pre><code class="language-java">else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
</code></pre>
<p>IndexDaoImpl3 不是一个 ImportBeanDefinitionRegistrar<br>
所以进入 processImports  方法的第 51 行 else 分支</p>
<pre><code class="language-java">else{
  this.importStack.registerImport(
      currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
processConfigurationClass(candidate.asConfigClass(configClass));
}
</code></pre>
<h3 id="外部调用">外部调用</h3>
<p>从外部调用时，doProcessConfigurationClass 方法的第 64 行：</p>
<pre><code class="language-java">processImports(configClass, sourceClass, getImports(sourceClass), true);
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/getImports.png" alt="图片" loading="lazy"></figure>
<p>传递的第三个参数是获得 @Import(MyImportSelector.class) 的值：MyImportSelector。判断 AppConfig 中 @Import 的值到底是哪一种 Import，然后再来进行处理。</p>
<p>再来看 processImports 方法的参数</p>
<pre><code class="language-java">private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,
      Collection&lt;SourceClass&gt; importCandidates, boolean checkForCircularImports) {
</code></pre>
<p>第三个参数 importCandidates 即 MyImportSelector</p>
<h3 id="内部调用">内部调用</h3>
<p>内部递归调用时，传递的第三个参数是当前类：</p>
<pre><code class="language-java">processImports(configClass, currentSourceClass, importSourceClasses, false);
</code></pre>
<p>内部调用判断当前类 IndexDaoImpl3 到底是哪一种 @Import。<br>
<strong>getImports(sourceClass) 是获取 @Import 注解内的值，而 processImports 仅仅判断传进来的类（第三个参数）是 三种Import 中的哪一种</strong>。</p>
<h2 id="processconfigurationclass-2">processConfigurationClass</h2>
<p>前面提到递归调用会进入 else 分支，调用 processConfigurationClass 方法：</p>
<pre><code class="language-java">protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
   // 判断是否应该跳过解析
   if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
      return;
   }
   // 处理 Imported 的情况
   // 就是当前这个类有没有被别的类 @Import
   ConfigurationClass existingClass = this.configurationClasses.get(configClass);
   if (existingClass != null) {
      if (configClass.isImported()) {
         if (existingClass.isImported()) {
            existingClass.mergeImportedBy(configClass);
         }
         // Otherwise ignore new imported config class; existing non-imported class overrides it.
         return;
      }
      else {
         // Explicit bean definition found, probably replacing an import.
         // Let's remove the old one and go with the new one.
         this.configurationClasses.remove(configClass);
         this.knownSuperclasses.values().removeIf(configClass::equals);
      }
   }
   // Recursively process the configuration class and its superclass hierarchy.
   SourceClass sourceClass = asSourceClass(configClass);
   do {
      sourceClass = doProcessConfigurationClass(configClass, sourceClass);
   }
   while (sourceClass != null);
   // 一个 map，用来存放扫描出来的 bean（注意这里的 bean 不是对象，仅仅是 bean 的信息，因为还没到实例化）
   this.configurationClasses.put(configClass, configClass);
}
</code></pre>
<p>上述代码第 34 行：将类放到 configurationClasses 变量中。</p>
<pre><code class="language-java">private final Map&lt;ConfigurationClass, ConfigurationClass&gt; configurationClasses = new LinkedHashMap&lt;&gt;();
</code></pre>
<h1 id="spring-处理四种类">Spring 处理四种类</h1>
<h2 id="普通类-component">普通类 @Component</h2>
<p>扫描完成后注册</p>
<h2 id="importselector">importSelector</h2>
<p><strong>先放到 Map&lt;ConfigurationClass, ConfigurationClass&gt; configurationClasses = new LinkedHashMap&lt;&gt;(); 中，然后再注册</strong>。</p>
<p>context.<em>refresh</em>(); ---&gt; <em>invokeBeanFactoryPostProcessors</em>(beanFactory); ---&gt; PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); ---&gt;invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); ---&gt; postProcessor.<em>postProcessBeanDefinitionRegistry</em>(registry); ---&gt; <em>processConfigBeanDefinitions</em>(registry);处理@Configuration ---&gt; parser.parse(candidates); 解析注解对象---&gt; parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName()); ---&gt; processConfigurationClass(new ConfigurationClass(metadata, beanName)); 处理Import</p>
<pre><code class="language-java">protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
   // 判断是否应该跳过解析
   if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
      return;
   }
   // 处理 Imported 的情况
   // 就是当前这个类有没有被别的类 @Import
   ConfigurationClass existingClass = this.configurationClasses.get(configClass);
   if (existingClass != null) {
      if (configClass.isImported()) {
         if (existingClass.isImported()) {
            existingClass.mergeImportedBy(configClass);
         }
         // Otherwise ignore new imported config class; existing non-imported class overrides it.
         return;
      }
      else {
         // Explicit bean definition found, probably replacing an import.
         // Let's remove the old one and go with the new one.
         this.configurationClasses.remove(configClass);
         this.knownSuperclasses.values().removeIf(configClass::equals);
      }
   }
   // Recursively process the configuration class and its superclass hierarchy.
   SourceClass sourceClass = asSourceClass(configClass);
   do {
      sourceClass = doProcessConfigurationClass(configClass, sourceClass);
   }
   while (sourceClass != null);
   // 一个 map，用来存放扫描出来的 bean（注意这里的 bean 不是对象，仅仅是 bean 的信息，因为还没到实例化）
   this.configurationClasses.put(configClass, configClass);
}
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/map%E4%B8%AD%E6%9C%898%E4%B8%AA.png" alt="图片" loading="lazy"></figure>
<p>context. refresh(); ---&gt; invokeBeanFactoryPostProcessors(beanFactory); ---&gt; PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); ---&gt; invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); ---&gt; postProcessor.postProcessBeanDefinitionRegistry(registry); ---&gt; processConfigBeanDefinitions(registry); ---&gt; this.reader.loadBeanDefinitions(configClasses);</p>
<pre><code class="language-java">public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
   //定义一个 list 存放 app 提供的 bd：项目当中提供了 @Component
   List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;();
   // 获取容器中注册的所有 bd 名字
   // 7 个
   String[] candidateNames = registry.getBeanDefinitionNames();
   // 依次取出每个&lt;beanName,beanDefinition&gt;
   /**
    * full
    * lite
    */
   for (String beanName : candidateNames) {
      BeanDefinition beanDef = registry.getBeanDefinition(beanName);
      // 判断当前 bean 是否被处理过：使用 isFullConfigurationClass 来标识
      if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
            ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {
         // 如果 BeanDefinition 中的 configurationClass 属性为 full 或者 lite，则意味着已经处理过了，直接跳过
         // 这里需要结合下面的代码才能理解
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Bean definition has already been processed as a configuration class: &quot; + beanDef);
         }
      }
      // 判断这个 BeanDefinition 是否是 Configuration类，如果加了 Configuration 下面的这几个注解就不再判断了
      // 还有  add(Component.class.getName())
      //         candidateIndicators.add(ComponentScan.class.getName())
      //         candidateIndicators.add(Import.class.getName())
      //         candidateIndicators.add(ImportResource.class.getName())
      else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
         configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
      }
   }
   // Return immediately if no @Configuration classes were found
   if (configCandidates.isEmpty()) {
      return;
   }
   // 排序，根据 order，不重要
   // Sort by previously determined @Order value, if applicable
   configCandidates.sort((bd1, bd2) -&gt; {
      int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
      int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
      return Integer.compare(i1, i2);
   });
   // Detect any custom bean name generation strategy supplied through the enclosing application context
   SingletonBeanRegistry sbr = null;
   // 如果 BeanDefinitionRegistry 是 SingletonBeanRegistry 子类的话
   // 由于会将 registry 强转为 SingletonBeanRegistry
   if (registry instanceof SingletonBeanRegistry) {
      sbr = (SingletonBeanRegistry) registry;
      if (!this.localBeanNameGeneratorSet) {//是否有自定义的
         BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);
         // SingletonBeanRegistry 中有 id 为 org.springframework.context.annotation.internalConfigurationBeanNameGenerator
         // 如果有则利用它的，否则则使用 Spring 默认的
         if (generator != null) {
            this.componentScanBeanNameGenerator = generator;
            this.importBeanNameGenerator = generator;
         }
      }
   }
   if (this.environment == null) {
      this.environment = new StandardEnvironment();
   }
   // Parse each @Configuration class
   // 实例化 ConfigurationClassParser 为了解析各个配置类
   ConfigurationClassParser parser = new ConfigurationClassParser(
         this.metadataReaderFactory, this.problemReporter, this.environment,
         this.resourceLoader, this.componentScanBeanNameGenerator, registry);
   // 实例化 2 个 set，candidates 用于将之前加入的 configCandidates 进行去重
   // 因为可能有多个配置类重复了
   // alreadyParsed 用户判断是否处理过
   Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates);
   Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size());
   do {
      parser.parse(candidates);
      parser.validate();
      Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());
      configClasses.removeAll(alreadyParsed);
      // Read the model and create bean definitions based on its content
      if (this.reader == null) {
         this.reader = new ConfigurationClassBeanDefinitionReader(
               registry, this.sourceExtractor, this.resourceLoader, this.environment,
               this.importBeanNameGenerator, parser.getImportRegistry());
      }
      // 把扫描出来的 bean 对应的 beanDefinitions 添加到 factory 的 map 当中
      this.reader.loadBeanDefinitions(configClasses);
      alreadyParsed.addAll(configClasses);
      candidates.clear();
      if (registry.getBeanDefinitionCount() &gt; candidateNames.length) {
         String[] newCandidateNames = registry.getBeanDefinitionNames();
         Set&lt;String&gt; oldCandidateNames = new HashSet&lt;&gt;(Arrays.asList(candidateNames));
         Set&lt;String&gt; alreadyParsedClasses = new HashSet&lt;&gt;();
         for (ConfigurationClass configurationClass : alreadyParsed) {
            alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
         }
         for (String candidateName : newCandidateNames) {
            if (!oldCandidateNames.contains(candidateName)) {
               BeanDefinition bd = registry.getBeanDefinition(candidateName);
               if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp;
                     !alreadyParsedClasses.contains(bd.getBeanClassName())) {
                  candidates.add(new BeanDefinitionHolder(bd, candidateName));
               }
            }
         }
         candidateNames = newCandidateNames;
      }
   }
   while (!candidates.isEmpty());
   // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes
   if (sbr != null &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {
      sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
   }
   if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {
      // Clear cache in externally provided MetadataReaderFactory; this is a no-op
      // for a shared cache since it'll be cleared by the ApplicationContext.
      ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();
   }
}
</code></pre>
<p>上述代码第 82 行：</p>
<pre><code class="language-java">Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());
</code></pre>
<pre><code>public Set&lt;ConfigurationClass&gt; getConfigurationClasses() {
   return this.configurationClasses.keySet();
}
</code></pre>
<pre><code class="language-java">private final Map&lt;ConfigurationClass, ConfigurationClass&gt; configurationClasses = new LinkedHashMap&lt;&gt;();
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/getConfigurationClasses.png" alt="图片" loading="lazy"></figure>
<p>通过 parser.getConfigurationClasses() 方法，得到：普通类 @Component、 @Import 类、本身类 appConfig ，其中 普通类、本身类已经注册了，@Import 类还没有注册。</p>
<p>如何知道哪些类还没有注册呢？</p>
<p>上述代码第 92 行：</p>
<pre><code class="language-java">this.reader.loadBeanDefinitions(configClasses);
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E6%89%A7%E8%A1%8CloadBeanDefinitions%E5%89%8D.png" alt="图片" loading="lazy"></figure>
<pre><code class="language-java">public void loadBeanDefinitions(Set&lt;ConfigurationClass&gt; configurationModel) {
   TrackedConditionEvaluator trackedConditionEvaluator = new TrackedConditionEvaluator();
   for (ConfigurationClass configClass : configurationModel) {
      loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);
   }
}
</code></pre>
<pre><code class="language-java">private void loadBeanDefinitionsForConfigurationClass(
      ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) {
   if (trackedConditionEvaluator.shouldSkip(configClass)) {
      String beanName = configClass.getBeanName();
      if (StringUtils.hasLength(beanName) &amp;&amp; this.registry.containsBeanDefinition(beanName)) {
         this.registry.removeBeanDefinition(beanName);
      }
      this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());
      return;
   }
   if (configClass.isImported()) {
      registerBeanDefinitionForImportedConfigurationClass(configClass);
   }
   for (BeanMethod beanMethod : configClass.getBeanMethods()) {
      loadBeanDefinitionsForBeanMethod(beanMethod);
   }
   loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());
   // 注册 Registrar
loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());
}
</code></pre>
<p>上述代码第 22 行：</p>
<pre><code class="language-java">private void loadBeanDefinitionsFromRegistrars(Map&lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&gt; registrars) {
   registrars.forEach((registrar, metadata) -&gt;
         registrar.registerBeanDefinitions(metadata, this.registry));
}
</code></pre>
<p>如果一个类是 Registrar，将它放到 importBeanDefinitionRegistrars 中，循环遍历 importBeanDefinitionRegistrars  注册。<br>
当执行完 this.reader.loadBeanDefinitions(configClasses);</p>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/%E6%89%A7%E8%A1%8CloadBeanDefinitions%E5%90%8E.png" alt="图片" loading="lazy"></figure>
<p>IndexDaoImpl2 是通过 @Bean 注入到容器中的，IndexDaoImpl3 是通过 “将 @ImportSelector 返回的字符串放到 map 中” 注入到容器中的。</p>
<h2 id="registrar">Registrar</h2>
<p>先放到 importBeanDefinitionRegistrars 中，然后再 通过 loadBeanDefinitionsFromRegistrars 方法注册。</p>
<p>processImports 方法的第 39-49 行：</p>
<pre><code class="language-java">else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
    // Candidate class is an ImportBeanDefinitionRegistrar -&gt;
    // delegate to it to register additional bean definitions
    Class&lt;?&gt; candidateClass = candidate.loadClass();
    ImportBeanDefinitionRegistrar registrar = BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);
    ParserStrategyUtils.invokeAwareMethods(registrar, this.environment, this.resourceLoader, this.registry);
    // 添加到一个 list 当中和 importSelector 不同
    configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
}
</code></pre>
<p>如果有一个类是 ImportBeanDefinitionRegistrar，把这个类拿出来，把它实例化，放到 configClass 中。<br>
上述代码第 8 行：</p>
<pre><code class="language-java">public void addImportBeanDefinitionRegistrar(ImportBeanDefinitionRegistrar registrar, AnnotationMetadata importingClassMetadata) {
   this.importBeanDefinitionRegistrars.put(registrar, importingClassMetadata);
}
</code></pre>
<pre><code class="language-java">private final Map&lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&gt; importBeanDefinitionRegistrars = new LinkedHashMap&lt;&gt;();
</code></pre>
<h2 id="import-普通类">import 普通类</h2>
<p><strong>先放到 configurationClasses，注册时判断里面有没有，如果有就不注册了，因为扫描出来的已经有了</strong>。</p>
<p>processImports 方法第 51-62 行：</p>
<pre><code class="language-java">else {
    // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt;
    // process it as an @Configuration class
    // 否则，加入到 importStack 后调用 processConfigurationClass 进行处理
    // processConfigurationClass 里面主要就是把类放到 configurationClasses
    // configurationClasses 是一个集合，会在后面拿出来解析成 bd 继而注册
    // 可以看到普通类在扫描出来的时候就被注册了
    // 如果是 importSelector，会先放到 configurationClasses 后面进行出来注册
    this.importStack.registerImport(currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
               processConfigurationClass(candidate.asConfigClass(configClass));
}     
</code></pre>
<p>上述代码第 10 行：</p>
<pre><code class="language-java">protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
   // 判断是否应该跳过解析
   if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
      return;
   }
   // 处理 Imported 的情况
   // 就是当前这个类有没有被别的类 @Import
   ConfigurationClass existingClass = this.configurationClasses.get(configClass);
   if (existingClass != null) {
      if (configClass.isImported()) {
         if (existingClass.isImported()) {
            existingClass.mergeImportedBy(configClass);
         }
         // Otherwise ignore new imported config class; existing non-imported class overrides it.
         return;
      }
      else {
         // Explicit bean definition found, probably replacing an import.
         // Let's remove the old one and go with the new one.
         this.configurationClasses.remove(configClass);
         this.knownSuperclasses.values().removeIf(configClass::equals);
      }
   }
   // Recursively process the configuration class and its superclass hierarchy.
   SourceClass sourceClass = asSourceClass(configClass);
   do {
      sourceClass = doProcessConfigurationClass(configClass, sourceClass);
   }
   while (sourceClass != null);
   // 一个 map，用来存放扫描出来的 bean（注意这里的 bean 不是对象，仅仅是 bean 的信息，因为还没到实例化）
   this.configurationClasses.put(configClass, configClass);
}
</code></pre>
<p>至此为止，执行完了 自定义的 BeanDefinitionRegistryPostProcessor + Spring 内部的 BeanDefinitionRegistryPostProcessor 所有的 postProcessBeanDefinitionRegistry 方法。<br>
context. refresh(); ---&gt; invokeBeanFactoryPostProcessors(beanFactory); ---&gt; PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); 获取<strong>自定义的 beanFactoryPostProcessors+ Spring 内部自己实现了 BeanDefinitionRegistryPostProcessor 接口的对象</strong></p>
<p>---&gt; invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); <strong>执行所有 BeanDefinitionRegistryPostProcessor</strong>---&gt; postProcessor.postProcessBeanDefinitionRegistry(registry); ---&gt; processConfigBeanDefinitions(registry); ---&gt; parser.parse(candidates); 解析：把普通类放到 map 中；this.reader.loadBeanDefinitions(configClasses); 特殊类：处理所有的 @Import；</p>
<pre><code class="language-java">public static void invokeBeanFactoryPostProcessors(
      ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) {
   // Invoke BeanDefinitionRegistryPostProcessors first, if any.
   Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;();
   if (beanFactory instanceof BeanDefinitionRegistry) {
      BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
      // 定义两个 list， BeanDefinitionRegistryPostProcessor 实现了 BeanFactoryPostProcessor 接口
      // 因为 bdrp 是子类，子类肯定扩展了父类中的功能。
      List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;();
      List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;();
      // 自定义的 beanFactoryPostProcessors
      for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
         if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
            BeanDefinitionRegistryPostProcessor registryProcessor =
                  (BeanDefinitionRegistryPostProcessor) postProcessor;
            registryProcessor.postProcessBeanDefinitionRegistry(registry);
            registryProcessors.add(registryProcessor);
         }
         else {
            regularPostProcessors.add(postProcessor);
         }
      }
      // Do not initialize FactoryBeans here: We need to leave all regular beans
      // uninitialized to let the bean factory post-processors apply to them!
      // Separate between BeanDefinitionRegistryPostProcessors that implement
      // PriorityOrdered, Ordered, and the rest.
      // 这个 currentRegistryProcessors 放的是 Spring 内部自己实现了 BeanDefinitionRegistryPostProcessor 接口的对象
      List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;();
      // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
      // BeanDefinitionRegistryPostProcessor 等于 BeanFactoryPostProcessor
      // getBeanNamesForType：根据 bean 的 Type 类型获取 bean 的名字
      String[] postProcessorNames =
            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
      // 这个地方可以得到一个 BeanFactoryPostProcessor，因为是 Spring 默认在最开始自己注册的
      // 为什么要在最开始注册这个呢？
      // 因为 Spring 的工厂需要注解去扫描等等功能
      // 而这些功能都是需要在 Spring 工厂初始化完成之前就执行
      // 要么在工厂最开始的时候，要么在工厂初始化之中，反正不能在之后
      // 因为如果在之后就没有意义，因为那个时候已经需要使用工厂了
      // 所以这里 Spring 在一开始就注册了一个 BeanFactoryPostProcessor，用来插手 springFactory 的实例化过程
      // 在这个地方断点可以知道这个类叫做 ConfigurationClassPostProcessor
      // ConfigurationClassPostProcessor 那么这个类能干嘛呢？可以参考源码
      // 下面对这个“插手 Spring 工厂实例化过程”的类重点解释
      for (String ppName : postProcessorNames) {
         if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
         }
      }
      // 排序不重要，况且 currentRegistryProcessor 这里也只有一个数据
      sortPostProcessors(currentRegistryProcessors, beanFactory);
      // 合并 List，不重要（为什么要合并，因为有自定义的Spring自己的）
      registryProcessors.addAll(currentRegistryProcessors);
      // 最重要。注意这里是方法调用
      // 执行所有 BeanDefinitionRegistryPostProcessor
      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
      // 执行完了所有的 BeanDefinitionRegistryPostProcessor
      // 这个 list 只是一个临时变量，故而要清除
      currentRegistryProcessors.clear();
      // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
      for (String ppName : postProcessorNames) {
         if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
         }
      }
      sortPostProcessors(currentRegistryProcessors, beanFactory);
      registryProcessors.addAll(currentRegistryProcessors);
      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
      currentRegistryProcessors.clear();
      // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
      boolean reiterate = true;
      while (reiterate) {
         reiterate = false;
         postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
         for (String ppName : postProcessorNames) {
            if (!processedBeans.contains(ppName)) {
               currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
               processedBeans.add(ppName);
               reiterate = true;
            }
         }
         sortPostProcessors(currentRegistryProcessors, beanFactory);
         registryProcessors.addAll(currentRegistryProcessors);
         invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
         currentRegistryProcessors.clear();
      }
      // Now, invoke the postProcessBeanFactory callback of all processors handled so far.
      // 执行 BeanFactoryPostProcessor 的回调，前面不是吗？
      // 前面执行的 BeanFactoryPostProcessor 的子类 BeanDefinitionRegistryPostProcessor 的回调
      // 这里执行的是 BeanFactoryPostProcessor 的回调
      invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
      //
      invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
   }
   else {
      // Invoke factory processors registered with the context instance.
      invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
   }
   // Do not initialize FactoryBeans here: We need to leave all regular beans
   // uninitialized to let the bean factory post-processors apply to them!
   String[] postProcessorNames =
         beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);
   // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
   // Ordered, and the rest.
   List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();
   List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();
   List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();
   for (String ppName : postProcessorNames) {
      if (processedBeans.contains(ppName)) {
         // skip - already processed in first phase above
      }
      else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
         priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
      }
      else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
         orderedPostProcessorNames.add(ppName);
      }
      else {
         nonOrderedPostProcessorNames.add(ppName);
      }
   }
   // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
   invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);
   // Next, invoke the BeanFactoryPostProcessors that implement Ordered.
   List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();
   for (String postProcessorName : orderedPostProcessorNames) {
      orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
   }
   sortPostProcessors(orderedPostProcessors, beanFactory);
   invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);
   // Finally, invoke all other BeanFactoryPostProcessors.
   List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();
   for (String postProcessorName : nonOrderedPostProcessorNames) {
      nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
   }
   invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);
   // Clear cached merged bean definitions since the post-processors might have
   // modified the original metadata, e.g. replacing placeholders in values...
   beanFactory.clearMetadataCache();
}
</code></pre>
<p>上述第 98-102 行代码：</p>
<pre><code class="language-java">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.
// 执行 BeanFactoryPostProcessor 的回调，前面不是吗？
// 前面执行的 BeanFactoryPostProcessor 的子类 BeanDefinitionRegistryPostProcessor 的回调
// 这里执行的是 BeanFactoryPostProcessor 的回调
invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
</code></pre>
<p>执行 BeanFactoryPostProcessor 的回调，前面不是吗？<br>
前面执行的 BeanFactoryPostProcessor 的子类 BeanDefinitionRegistryPostProcessor 的回调。这里执行的是 BeanFactoryPostProcessor 的回调。</p>
<p>于是我们来看一下前面的代码验证一下，上述方法第 16 行，判断是不是 BeanDefinitionRegistryPostProcessor，如果是，就把它放到 registryProcessors 中：</p>
<pre><code class="language-java">for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
   if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
      BeanDefinitionRegistryPostProcessor registryProcessor =
            (BeanDefinitionRegistryPostProcessor) postProcessor;
      registryProcessor.postProcessBeanDefinitionRegistry(registry);
      registryProcessors.add(registryProcessor);
   }
   else {
      regularPostProcessors.add(postProcessor);
   }
}
</code></pre>
<p>接下来看 invokeBeanFactoryPostProcessors 方法：完成 BeanFactoryPostProcessor 的回调</p>
<pre><code class="language-java">private static void invokeBeanFactoryPostProcessors(
      Collection&lt;? extends BeanFactoryPostProcessor&gt; postProcessors, ConfigurableListableBeanFactory beanFactory) {
   for (BeanFactoryPostProcessor postProcessor : postProcessors) {
      postProcessor.postProcessBeanFactory(beanFactory);
   }
}
</code></pre>
<p>点进来这个方法：</p>
<pre><code class="language-java">public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
   int factoryId = System.identityHashCode(beanFactory);
   if (this.factoriesPostProcessed.contains(factoryId)) {
      throw new IllegalStateException(
            &quot;postProcessBeanFactory already called on this post-processor against &quot; + beanFactory);
   }
   this.factoriesPostProcessed.add(factoryId);
   if (!this.registriesPostProcessed.contains(factoryId)) {
      // BeanDefinitionRegistryPostProcessor hook apparently not supported...
      // Simply call processConfigurationClasses lazily at this point then.
      processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);
   }
   // 产生 cglib 代理
   // 为什么需要产生 cglib 代理
   enhanceConfigurationClasses(beanFactory);
   beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory));
}
</code></pre>
<h1 id="full-与-lite">FULL 与 LITE</h1>
<p>上述代码第 16 行：</p>
<pre><code class="language-java">public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) {
   Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = new LinkedHashMap&lt;&gt;();
   for (String beanName : beanFactory.getBeanDefinitionNames()) {
      BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);
      // 判断是否是一个全注解类
      // 什么是全注解类？FULL 和 LITE
      if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) {
         if (!(beanDef instanceof AbstractBeanDefinition)) {
            throw new BeanDefinitionStoreException(&quot;Cannot enhance @Configuration bean definition '&quot; +
                  beanName + &quot;' since it is not stored in an AbstractBeanDefinition subclass&quot;);
         }
         else if (logger.isWarnEnabled() &amp;&amp; beanFactory.containsSingleton(beanName)) {
            logger.warn(&quot;Cannot enhance @Configuration bean definition '&quot; + beanName +
                  &quot;' since its singleton instance has been created too early. The typical cause &quot; +
                  &quot;is a non-static @Bean method with a BeanDefinitionRegistryPostProcessor &quot; +
                  &quot;return type: Consider declaring such methods as 'static'.&quot;);
         }
         configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);
      }
   }
   if (configBeanDefs.isEmpty()) {
      // nothing to enhance -&gt; return immediately
      return;
   }
   ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer();
   for (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) {
      AbstractBeanDefinition beanDef = entry.getValue();
      // If a @Configuration class gets proxied, always proxy the target class
      beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);
      try {
         // Set enhanced subclass of the user-specified bean class
         Class&lt;?&gt; configClass = beanDef.resolveBeanClass(this.beanClassLoader);
         if (configClass != null) {
            Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, this.beanClassLoader);
            if (configClass != enhancedClass) {
               if (logger.isDebugEnabled()) {
                  logger.debug(String.format(&quot;Replacing bean definition '%s' existing class '%s' with &quot; +
                        &quot;enhanced class '%s'&quot;, entry.getKey(), configClass.getName(), enhancedClass.getName()));
               }
               beanDef.setBeanClass(enhancedClass);
            }
         }
      }
      catch (Throwable ex) {
         throw new IllegalStateException(&quot;Cannot load configuration class: &quot; + beanDef.getBeanClassName(), ex);
      }
   }
}
</code></pre>
<p>如果没有添加 @Configuration 会直接在上述代码第 23 行 return;<br>
如果添加了 @Configuration 后，就不会在第 23 行 return;而是会继续向下走到第 26 行。</p>
<p>加了 @Configuration 会进行 cglib 代理，如果不加 @Configuration  就不会进行 cglib 动态代理。</p>
<p>为什么加了 @Configuration 能够向下走到第 26 行呢？</p>
<p>上述代码第 5-8 行：</p>
<pre><code class="language-java">// 判断是否是一个全注解类
// 什么是全注解类？FULL 和 LITE
if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) {
  if (!(beanDef instanceof AbstractBeanDefinition)) {  
</code></pre>
<p>在解析 AppConfig 时，如果 AppConfig 有 @Configuration 注解，就会给它设置一个属性 FULL；如果没有，就设置属性 LITE。<br>
<strong>FULL 与 LITE 只是 Spring 当中的一个标识，Spring 标识为 FULL，表示它是一个全配置类，Spring 在为它生成 Bean 时，会加上 cglib 代理。标志为 LITE，表示它是一个部分配置类</strong>。</p>
<p><img src="https://epitomm.github.io/post-images/%E6%B7%BB%E5%8A%A0@Configuration%E6%B3%A8%E8%A7%A3.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/%E4%B8%8D%E6%B7%BB%E5%8A%A0@Configuration%E6%B3%A8%E8%A7%A3.png" alt="图片" loading="lazy"></p>
<h1 id="为什么要给这个类加上-cglib-动态代理">为什么要给这个类加上 cglib 动态代理</h1>
<pre><code class="language-java">public class IndexDaoImpl2 implements IndexDao{
   @Override
   public void query() {
      System.out.println(&quot;dao2...模拟查询数据库&quot;);
   }
}
</code></pre>
<pre><code class="language-java">public class IndexDaoImpl implements IndexDao{
   public IndexDaoImpl(){
      System.out.println(&quot;indexDao...constructor&quot;);
   }
   @Override
   public void query() {
      System.out.println(&quot;dao...模拟查询数据库&quot;);
   }
}
</code></pre>
<pre><code class="language-java">@ComponentScan(&quot;com.ssm&quot;)
public class AppConfig {
   @Bean
   public IndexDao indexDao2(){
      return new IndexDaoImpl2();
   }
   @Bean
   public IndexDao indexDao(){
      return new IndexDaoImpl();
   }
}
</code></pre>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      // 初始化 Spring 的环境
      context. refresh();
   }
}
</code></pre>
<p>运行结果：</p>
<pre><code>indexDao...constructor
</code></pre>
<p>分析：当执行 indexDao() 时，new IndexDaoImpl()，调用 IndexDaoImpl 的构造方法，所以IndexDaoImpl 的构造方法执行一次。</p>
<pre><code class="language-java">@ComponentScan(&quot;com.ssm&quot;)
public class AppConfig {
   @Bean
   public IndexDao indexDao2(){
      indexDao();
      return new IndexDaoImpl2();
   }
   @Bean
   public IndexDao indexDao(){
      return new IndexDaoImpl();
   }
}
</code></pre>
<p>运行结果：</p>
<pre><code>indexDao...constructor
indexDao...constructor
</code></pre>
<p>分析：当执行 indexDao() 时，new IndexDaoImpl()，调用 IndexDaoImpl 的构造方法。<br>
当执行 indexDao2 方法时，再次调用 indexDao(); 方法，所以IndexDaoImpl 的构造方法共执行了两次。</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
public class AppConfig {
   @Bean
   public IndexDao indexDao2(){
      indexDao();
      return new IndexDaoImpl2();
   }
   @Bean
   public IndexDao indexDao(){
      return new IndexDaoImpl();
   }
}
</code></pre>
<p>运行结果：</p>
<pre><code>indexDao...constructor
</code></pre>
<p>分析：<strong>添加了 @Configuration 后，仅调用一次 IndexDao 的构造方法</strong>。<br>
indexDao() 方法被改变了，即使在 indexDao2() 内再次调用 indexDao()，也不会执行方法内的代码 new IndexDaoImpl(); 了。</p>
<p>如何改变一个方法 indexD()？</p>
<p><strong>代理 AppConfig</strong>，当调用 AppConfig 的 indexDao() 时，调用的是代理类 AppConfig 内部的 indexDao()，而不是普通类 AppConfig 内部的 indexDao()。</p>
<pre><code class="language-java">public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) {
   Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = new LinkedHashMap&lt;&gt;();
   for (String beanName : beanFactory.getBeanDefinitionNames()) {
      BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);
      // 判断是否是一个全注解类
      // 什么是全注解类？FULL 和 LITE
      if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) {
         if (!(beanDef instanceof AbstractBeanDefinition)) {
            throw new BeanDefinitionStoreException(&quot;Cannot enhance @Configuration bean definition '&quot; +
                  beanName + &quot;' since it is not stored in an AbstractBeanDefinition subclass&quot;);
         }
         else if (logger.isWarnEnabled() &amp;&amp; beanFactory.containsSingleton(beanName)) {
            logger.warn(&quot;Cannot enhance @Configuration bean definition '&quot; + beanName +
                  &quot;' since its singleton instance has been created too early. The typical cause &quot; +
                  &quot;is a non-static @Bean method with a BeanDefinitionRegistryPostProcessor &quot; +
                  &quot;return type: Consider declaring such methods as 'static'.&quot;);
         }
         //  如果是一个全注解，添加到 configBeanDefs 中；如果不是全注解，则不会put，即 configBeanDefs 为空
         configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);
      }
   }
   // 如果不是全注解，configBeanDefs 为空，直接 return;
   if (configBeanDefs.isEmpty()) {
      // nothing to enhance -&gt; return immediately
      return;
   }
   ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer();
   for (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) {
      AbstractBeanDefinition beanDef = entry.getValue();
      // If a @Configuration class gets proxied, always proxy the target class
      beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);
      try {
         // Set enhanced subclass of the user-specified bean class
         Class&lt;?&gt; configClass = beanDef.resolveBeanClass(this.beanClassLoader);
         if (configClass != null) {
            // 完成对全注解类的 cglib 代理
            Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, this.beanClassLoader);
            if (configClass != enhancedClass) {
               if (logger.isDebugEnabled()) {
                  logger.debug(String.format(&quot;Replacing bean definition '%s' existing class '%s' with &quot; +
                        &quot;enhanced class '%s'&quot;, entry.getKey(), configClass.getName(), enhancedClass.getName()));
               }
               beanDef.setBeanClass(enhancedClass);
            }
         }
      }
      catch (Throwable ex) {
         throw new IllegalStateException(&quot;Cannot load configuration class: &quot; + beanDef.getBeanClassName(), ex);
      }
   }
}
</code></pre>
<p>上述代码第 38 行：</p>
<pre><code class="language-java">public Class&lt;?&gt; enhance(Class&lt;?&gt; configClass, @Nullable ClassLoader classLoader) {
   if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {
      if (logger.isDebugEnabled()) {
         logger.debug(String.format(&quot;Ignoring request to enhance %s as it has &quot; +
               &quot;already been enhanced. This usually indicates that more than one &quot; +
               &quot;ConfigurationClassPostProcessor has been registered (e.g. via &quot; +
               &quot;&lt;context:annotation-config&gt;). This is harmless, but you may &quot; +
               &quot;want check your configuration and remove one CCPP if possible&quot;,
               configClass.getName()));
      }
      return configClass;
   }
   // cglib 代理
   Class&lt;?&gt; enhancedClass = createClass(newEnhancer(configClass, classLoader));
   if (logger.isDebugEnabled()) {
      logger.debug(String.format(&quot;Successfully enhanced %s; enhanced class name is: %s&quot;,
            configClass.getName(), enhancedClass.getName()));
   }
   return enhancedClass;
}
</code></pre>
<p>创建一个类，把这个类 enhancedClass  返回，因为此时还没有实例化对象，<br>
AppConfig - cglib的class - BeanDefinition - cglib的Bean</p>
<p>如何返回一个 cglib 的 class？</p>
<p>上述代码第 14 行：</p>
<pre><code class="language-java">private Enhancer newEnhancer(Class&lt;?&gt; configSuperClass, @Nullable ClassLoader classLoader) {
   Enhancer enhancer = new Enhancer();
   // 增强父类，cglib 是基于继承来的
   // 把当前类 configSuperClass 作为 enhancer 的父类
   enhancer.setSuperclass(configSuperClass);
   // 增强接口，为什么要增强接口？
   // 便于判断，表示一个类已经被增强了
   enhancer.setInterfaces(new Class&lt;?&gt;[] {EnhancedConfiguration.class});
   enhancer.setUseFactory(false);
   enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
   // BeanFactoryAwareGeneratorStrategy 是一个生成策略
   // 主要为生成的 CGLIB 类中添加成员变量 $$beanFactory
   // 同时基于接口 EnhancedConfiguration 的父接口 BeanFactoryAware 中的 setBeanFactory 方法，
   // 设置此变量的值为当前 Context 中的 beanFactory，这样一来我们这个 cglib 代理的对象就有了 beanFactory
   // 有了 factory 就能获得对象，而不用去通过方法获得对象了，因为通过方法获得对象不能控制其过程
   // BeanFactory 的作用是在 this 调用时拦截该调用，并直接在 beanFactory 中获得目标 bean
   enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader));
   // 当调用 indexDao() 时进行拦截
   enhancer.setCallbackFilter(CALLBACK_FILTER);
   enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());
   return enhancer;
}
</code></pre>
<p>EnhancedConfiguration 继承了 BeanFactoryAware</p>
<pre><code class="language-java">public interface EnhancedConfiguration extends BeanFactoryAware {
</code></pre>
<p>BeanFactoryAware 实现了 Aware，Aware 里面有一个 setBeanFactory 方法</p>
<pre><code class="language-java">public interface BeanFactoryAware extends Aware {
   /**
    * Callback that supplies the owning factory to a bean instance.
    * &lt;p&gt;Invoked after the population of normal bean properties
    * but before an initialization callback such as
    * {@link InitializingBean#afterPropertiesSet()} or a custom init-method.
    * @param beanFactory owning BeanFactory (never {@code null}).
    * The bean can immediately call methods on the factory.
    * @throws BeansException in case of initialization errors
    * @see BeanInitializationException
    */
   void setBeanFactory(BeanFactory beanFactory) throws BeansException;
}
</code></pre>
<p>让 CGLIB 产生的代理对象能够获得 BeanFactory。</p>
<h3 id="cglib-的代理对象为什么要得到-beanfactory">CGLIB 的代理对象为什么要得到 BeanFactory？</h3>
<p>AppConfig 在执行代理前直接使用它得到原始类，就会执行原始类中的原始方法，每调用一次 indexDao() 方法，就会 new IndexDaoImpl(); 违背了 Spring 中的单例原则，所以不能使用原始对象，就需要使用代理对象，当再次调用 indexDao() 方法时，执行代理对象内的 indexDao() 方法，不再 new  IndexDaoImpl()，而是直接返回已经存在的 IndexDaoImpl。</p>
<p>![图片](https://epitomm.github.io/post-images/CGLIB的代理对象为什么要得到 BeanFactory.png)</p>
<p>当第一次调用 indexDao() 时，new IndexDaoImpl()，放到容器中，当第二次调用时，不再 new，而是直接从容器中拿出来 <strong>factory.getBean()</strong>，就需要在代理对象中有一个 BeanFactory，不然没办法 factory.getBean()。</p>
<h3 id="如何得到一个-beanfactory">如何得到一个 BeanFactory？</h3>
<p>实现 BeanFactoryAware 接口，后置处理器在实例化对象前，把它放进来。</p>
<p>BeanFactoryAwareGeneratorStrategy：CGLIB 生成类的策略。</p>
<p>默认策略：DefaultGeneratorStrategy，生成基本的。如果需要扩展，使用一个类 BeanFactoryAwareGeneratorStrategy：CGLIB  继承 DefaultGeneratorStrategy，在生成这个类的过程中，调用 declare_field 方法：声明一个属性 $$beanFactory。</p>
<pre><code class="language-java">protected ClassGenerator transform(ClassGenerator cg) throws Exception {
   ClassEmitterTransformer transformer = new ClassEmitterTransformer() {
      @Override
      public void end_class() {
         declare_field(Constants.ACC_PUBLIC, BEAN_FACTORY_FIELD, Type.getType(BeanFactory.class), null);
         super.end_class();
      }
   };
   return new TransformingClassGenerator(cg, transformer);
}
</code></pre>
<pre><code class="language-java">private static final String BEAN_FACTORY_FIELD = &quot;$$beanFactory&quot;;
</code></pre>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      // 初始化 Spring 的环境
      context. refresh();
      /**
        * 对目标对象的所有方法进行拦截
        */
      Enhancer enhancer = new Enhancer();
      enhancer.setSuperclass(IndexDaoImpl.class);
      // 增强接口
      enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
      // 添加方法过滤器
      enhancer.setCallback(new TestMethodCallabck());
      IndexDaoImpl indexDao = (IndexDaoImpl) enhancer.create();
      indexDao.query();
   }
}
</code></pre>
<pre><code class="language-java">public class TestMethodCallabck implements MethodInterceptor {
   /**
    *
    * @param o 代理对象
    * @param method 当前方法，目标对象的方法
    * @param objects 参数
    * @param methodProxy 代理对象的方法
    * @return
    * @throws Throwable
    */
   @Override
   public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
      System.out.println(&quot;method...&quot;);
      return methodProxy.invokeSuper(o,objects);
   }
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-java">indexDao...constructor
indexDao...constructor
method...
dao...模拟查询数据库
</code></pre>
<p>newEnhancer 方法的第 19 行：</p>
<pre><code class="language-java">private static final ConditionalCallbackFilter CALLBACK_FILTER = new ConditionalCallbackFilter(CALLBACKS);
</code></pre>
<pre><code class="language-java">private static final Callback[] CALLBACKS = new Callback[] {
      new BeanMethodInterceptor(),
      new BeanFactoryAwareMethodInterceptor(),
      NoOp.INSTANCE
};
</code></pre>
<h1 id="configuration">@Configuration</h1>
<p>让 AppConfig 产生一个 CGLIB 动态代理类，这个 CGLIB 代理类会去实现一个 BeanFactoryAware 接口，自动注入一个 BeanFactory，于是当再次调用 indexDao() 时，首先会判断是不是第一次，如果是，则 new IndexDaoImpl；如果不是，从 BeanFactory 中得到这个 Bean 并返回。</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
public class AppConfig {
   @Bean
   public IndexDao indexDao2(){
      indexDao();
      return new IndexDaoImpl2();
   }
   @Bean
   public static IndexDao indexDao(){
      return new IndexDaoImpl();
   }
}
</code></pre>
<p>即使添加了 @Configuration，如果 使用 static 修饰 indexDao()，也会创建两遍</p>
<pre><code>indexDao...constructor
indexDao...constructor
</code></pre>
<pre><code class="language-java">private void loadBeanDefinitionsForConfigurationClass(
      ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) {
   if (trackedConditionEvaluator.shouldSkip(configClass)) {
      String beanName = configClass.getBeanName();
      if (StringUtils.hasLength(beanName) &amp;&amp; this.registry.containsBeanDefinition(beanName)) {
         this.registry.removeBeanDefinition(beanName);
      }
      this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());
      return;
   }
   // 如果一个类是被 import 的，会被 Spring 标注
   // 在这里完成注册
   if (configClass.isImported()) {
      registerBeanDefinitionForImportedConfigurationClass(configClass);
   }
   // BeanMethod：得到 AppConfig 中的所有包，
   for (BeanMethod beanMethod : configClass.getBeanMethods()) {
      loadBeanDefinitionsForBeanMethod(beanMethod);
   }
   // xml
   loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());
   // 注册 Registrar
   loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());
}
</code></pre>
<pre><code class="language-java">private void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {
   ConfigurationClass configClass = beanMethod.getConfigurationClass();
   MethodMetadata metadata = beanMethod.getMetadata();
   String methodName = metadata.getMethodName();
   // Do we need to mark the bean as skipped by its condition?
   if (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {
      configClass.skippedBeanMethods.add(methodName);
      return;
   }
   if (configClass.skippedBeanMethods.contains(methodName)) {
      return;
   }
   AnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);
   Assert.state(bean != null, &quot;No @Bean annotation attributes&quot;);
   // Consider name and any aliases
   List&lt;String&gt; names = new ArrayList&lt;&gt;(Arrays.asList(bean.getStringArray(&quot;name&quot;)));
   String beanName = (!names.isEmpty() ? names.remove(0) : methodName);
   // Register aliases even when overridden
   for (String alias : names) {
      this.registry.registerAlias(beanName, alias);
   }
   // Has this effectively been overridden before (e.g. via XML)?
   if (isOverriddenByExistingDefinition(beanMethod, beanName)) {
      if (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) {
         throw new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(),
               beanName, &quot;Bean name derived from @Bean method '&quot; + beanMethod.getMetadata().getMethodName() +
               &quot;' clashes with bean name for containing configuration class; please make those names unique!&quot;);
      }
      return;
   }
   ConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass, metadata);
   beanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));
   if (metadata.isStatic()) {
      // static @Bean method
      beanDef.setBeanClassName(configClass.getMetadata().getClassName());
      beanDef.setFactoryMethodName(methodName);
   }
   else {
      // instance @Bean method
      beanDef.setFactoryBeanName(configClass.getBeanName());
      beanDef.setUniqueFactoryMethodName(methodName);
   }
   beanDef.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);
   beanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);
   AnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);
   Autowire autowire = bean.getEnum(&quot;autowire&quot;);
   if (autowire.isAutowire()) {
      beanDef.setAutowireMode(autowire.value());
   }
   String initMethodName = bean.getString(&quot;initMethod&quot;);
   if (StringUtils.hasText(initMethodName)) {
      beanDef.setInitMethodName(initMethodName);
   }
   String destroyMethodName = bean.getString(&quot;destroyMethod&quot;);
   beanDef.setDestroyMethodName(destroyMethodName);
   // Consider scoping
   ScopedProxyMode proxyMode = ScopedProxyMode.NO;
   AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(metadata, Scope.class);
   if (attributes != null) {
      beanDef.setScope(attributes.getString(&quot;value&quot;));
      proxyMode = attributes.getEnum(&quot;proxyMode&quot;);
      if (proxyMode == ScopedProxyMode.DEFAULT) {
         proxyMode = ScopedProxyMode.NO;
      }
   }
   // Replace the original bean definition with the target one, if necessary
   BeanDefinition beanDefToRegister = beanDef;
   if (proxyMode != ScopedProxyMode.NO) {
      BeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(
            new BeanDefinitionHolder(beanDef, beanName), this.registry,
            proxyMode == ScopedProxyMode.TARGET_CLASS);
      beanDefToRegister = new ConfigurationClassBeanDefinition(
            (RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);
   }
   if (logger.isDebugEnabled()) {
      logger.debug(String.format(&quot;Registering bean definition for @Bean method %s.%s()&quot;,
            configClass.getMetadata().getClassName(), beanName));
   }
   this.registry.registerBeanDefinition(beanName, beanDefToRegister);
}
</code></pre>
<p>上述代码第 40 行：</p>
<pre><code class="language-java">if (metadata.isStatic()) {
   // static @Bean method
   // 如果是静态的，BeanDefinition 中放的是 Bean   beanDef.setBeanClassName(configClass.getMetadata().getClassName());
   beanDef.setFactoryMethodName(methodName);
}
else {
   // instance @Bean method
   // 如果不是静态的，BeanDefinition 中放的是 FactoryBean
   // FactoryBean 是怎样被创建出来的？
   // FactoryBean 有两个意义：本身是一个 Bean，
   // 如何 new 出来一个 FactoryBean 给它呢？
   // 通过 setUniqueFactoryMethodName
   beanDef.setFactoryBeanName(configClass.getBeanName());
   beanDef.setUniqueFactoryMethodName(methodName);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring系列（九）Spring源码解析]]></title>
        <id>https://epitomm.github.io/post/spring-xi-lie-jiu-yuan-ma-jie-xi/</id>
        <link href="https://epitomm.github.io/post/spring-xi-lie-jiu-yuan-ma-jie-xi/">
        </link>
        <updated>2020-05-10T13:08:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="spring-bean-的生命周期">Spring Bean 的生命周期</h1>
<h2 id="1得到用户自定义的-beandefinitionregistrypostprocessor">1.得到用户自定义的 BeanDefinitionRegistryPostProcessor</h2>
<p>具体流程：</p>
<p>context.<em>refresh</em>(); ---&gt; invokeBeanFactoryPostProcessors(beanFactory); ---&gt; 		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); ---&gt; 其中 getBeanFactoryPostProcessors() 方法返回值是BeanFactoryPostProcessor ---&gt; ConfigurationClassPostProcessor 实现了 BeanDefinitionRegistryPostProcessor，而 BeanDefinitionRegistryPostProcessor 继承了 BeanFactoryPostProcessor。</p>
<h2 id="2得到-spring-内置的-beandefinitionregistrypostprocessor">2.得到 Spring 内置的 BeanDefinitionRegistryPostProcessor</h2>
<p><em>目前 Spring 只内置了一个 <em>BeanDefinitionRegistryPostProcessor，也就是</em>ConfigurationClassPostProcessor</em></p>
<p>具体流程：</p>
<p>context.<em>refresh</em>(); ---&gt; <em>invokeBeanFactoryPostProcessors</em>(beanFactory); ---&gt; PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); ---&gt; List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList&lt;&gt;(); 这个 currentRegistryProcessors 中放的就是 Spring 内部自己实现了 BeanDefinitionRegistryPostProcessor 接口的对象</p>
<h2 id="3处理-beandefinitionregistrypostprocessor">3.处理 BeanDefinitionRegistryPostProcessor</h2>
<pre><code class="language-java">private static void invokeBeanDefinitionRegistryPostProcessors(
      Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry) {
   // 遍历所有 &quot;用户自定义+Spirng内置&quot; 的 BeanDefinitionRegistryPostProcessor 
   for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
      // 调用 postProcessBeanDefinitionRegistry 方法处理每一个 postProcessor
      postProcessor.postProcessBeanDefinitionRegistry(registry);
   }
}
</code></pre>
<p>具体流程：<br>
context.<em>refresh</em>(); ---&gt; <em>invokeBeanFactoryPostProcessors</em>(beanFactory); ---&gt; PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); ---&gt;invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); ---&gt; postProcessor.<em>postProcessBeanDefinitionRegistry</em>(registry); ---&gt; <em>processConfigBeanDefinitions</em>(registry);处理@Configuration ---&gt; parser.parse(candidates); 解析注解对象---&gt; parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName()); ---&gt; processConfigurationClass(new ConfigurationClass(metadata, beanName)); 处理Import---&gt; sourceClass = doProcessConfigurationClass(configClass, sourceClass); ---&gt; this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()); ---&gt; scanner.doScan(StringUtils.toStringArray(basePackages));扫描包</p>
<h1 id="spring-源码解析">Spring 源码解析</h1>
<h2 id="配置类只扫描包没有添加-configuration注解">配置类只扫描包，没有添加 @Configuration注解</h2>
<pre><code class="language-java">@ComponentScan(&quot;com.ssm&quot;)
public class AppConfig {
}
</code></pre>
<pre><code class="language-java">@Repository(&quot;indexDao&quot;)
public class IndexDaoImpl implements IndexDao{
   @Override
   public void query() {
      System.out.println(&quot;dao...模拟查询数据库&quot;);
   }
}
</code></pre>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
//    context.addBeanFactoryPostProcessor(new MyBeanFactoryProcessor());
      // 初始化 Spring 的环境
      context.refresh();
      IndexDao indexDao = context.getBean(IndexDaoImpl.class);
      indexDao.query();
   }
}
</code></pre>
<p>运行结果：</p>
<pre><code>dao...模拟查询数据库
</code></pre>
<p>总结：即使没有添加 @Configuration 注解，也能正确完成对 AppConfig 类的扫描：扫描包 com.ssm。那么 @Configuration 到底有什么用呢？</p>
<h1 id="1processconfigbeandefinitions">1.processConfigBeanDefinitions</h1>
<p>context.<em>refresh</em>(); ---&gt; invokeBeanFactoryPostProcessors(beanFactory); ---&gt; 		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); ---&gt; invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); ---&gt; postProcessor.postProcessBeanDefinitionRegistry(registry); ---&gt; processConfigBeanDefinitions(registry);</p>
<pre><code class="language-java">public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
   //定义一个 list 存放 app 提供的 bd：项目当中提供了 @Component
   List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;();
   // 获取容器中注册的所有 bd 名字
   // 7 个
   String[] candidateNames = registry.getBeanDefinitionNames();
   // 依次取出每个&lt;beanName,beanDefinition&gt;
   /**
    * full
    * lite
    */
   for (String beanName : candidateNames) {
      BeanDefinition beanDef = registry.getBeanDefinition(beanName);
      // 判断当前 bean 是否被处理过：使用 isFullConfigurationClass 来标识
      if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
            ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {
         // 如果 BeanDefinition 中的 configurationClass 属性为 full 或者 lite，则意味着已经处理过了，直接跳过
         // 这里需要结合下面的代码才能理解
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Bean definition has already been processed as a configuration class: &quot; + beanDef);
         }
      }
      // 判断这个 BeanDefinition 是否是 Configuration类，如果加了 Configuration 下面的这几个注解就不再判断了
      // 还有  add(Component.class.getName())
      //         candidateIndicators.add(ComponentScan.class.getName())
      //         candidateIndicators.add(Import.class.getName())
      //         candidateIndicators.add(ImportResource.class.getName())
      else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
         configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
      }
   }
   // Return immediately if no @Configuration classes were found
   if (configCandidates.isEmpty()) {
      return;
   }
   // 排序，根据 order，不重要
   // Sort by previously determined @Order value, if applicable
   configCandidates.sort((bd1, bd2) -&gt; {
      int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
      int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
      return Integer.compare(i1, i2);
   });
   // Detect any custom bean name generation strategy supplied through the enclosing application context
   SingletonBeanRegistry sbr = null;
   // 如果 BeanDefinitionRegistry 是 SingletonBeanRegistry 子类的话
   // 由于会将 registry 强转为 SingletonBeanRegistry
   if (registry instanceof SingletonBeanRegistry) {
      sbr = (SingletonBeanRegistry) registry;
      if (!this.localBeanNameGeneratorSet) {//是否有自定义的
         BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);
         // SingletonBeanRegistry 中有 id 为 org.springframework.context.annotation.internalConfigurationBeanNameGenerator
         // 如果有则利用它的，否则则使用 Spring 默认的
         if (generator != null) {
            this.componentScanBeanNameGenerator = generator;
            this.importBeanNameGenerator = generator;
         }
      }
   }
   if (this.environment == null) {
      this.environment = new StandardEnvironment();
   }
   // Parse each @Configuration class
   // 实例化 ConfigurationClassParser 为了解析各个配置类
   ConfigurationClassParser parser = new ConfigurationClassParser(
         this.metadataReaderFactory, this.problemReporter, this.environment,
         this.resourceLoader, this.componentScanBeanNameGenerator, registry);
   // 实例化 2 个 set，candidates 用于将之前加入的 configCandidates 进行去重
   // 因为可能有多个配置类重复了
   // alreadyParsed 用户判断是否处理过
   Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates);
   Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size());
   do {
      parser.parse(candidates);
      parser.validate();
      Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());
      configClasses.removeAll(alreadyParsed);
      // Read the model and create bean definitions based on its content
      if (this.reader == null) {
         this.reader = new ConfigurationClassBeanDefinitionReader(
               registry, this.sourceExtractor, this.resourceLoader, this.environment,
               this.importBeanNameGenerator, parser.getImportRegistry());
      }
      // 把扫描出来的 bean 对应的 beanDefinitions 添加到 factory 的 map 当中
      this.reader.loadBeanDefinitions(configClasses);
      alreadyParsed.addAll(configClasses);
      candidates.clear();
      if (registry.getBeanDefinitionCount() &gt; candidateNames.length) {
         String[] newCandidateNames = registry.getBeanDefinitionNames();
         Set&lt;String&gt; oldCandidateNames = new HashSet&lt;&gt;(Arrays.asList(candidateNames));
         Set&lt;String&gt; alreadyParsedClasses = new HashSet&lt;&gt;();
         for (ConfigurationClass configurationClass : alreadyParsed) {
            alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
         }
         for (String candidateName : newCandidateNames) {
            if (!oldCandidateNames.contains(candidateName)) {
               BeanDefinition bd = registry.getBeanDefinition(candidateName);
               if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp;
                     !alreadyParsedClasses.contains(bd.getBeanClassName())) {
                  candidates.add(new BeanDefinitionHolder(bd, candidateName));
               }
            }
         }
         candidateNames = newCandidateNames;
      }
   }
   while (!candidates.isEmpty());
   // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes
   if (sbr != null &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {
      sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
   }
   if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {
      // Clear cache in externally provided MetadataReaderFactory; this is a no-op
      // for a shared cache since it'll be cleared by the ApplicationContext.
      ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();
   }
}
</code></pre>
<p>上述代码第 28 行判断这个 bd 是否加了 @Configuration 注解</p>
<pre><code class="language-java">// 判断这个 BeanDefinition 是否是 Configuration类，如果加了 Configuration 下面的这几个注解就不再判断了
// 还有  add(Component.class.getName())
//         candidateIndicators.add(ComponentScan.class.getName())
//         candidateIndicators.add(Import.class.getName())
//         candidateIndicators.add(ImportResource.class.getName())
else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
   configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
}
</code></pre>
<p>我们点进 ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) 这个方法</p>
<h2 id="11-checkconfigurationclasscandidate">1.1 checkConfigurationClassCandidate</h2>
<pre><code class="language-java">    public static boolean checkConfigurationClassCandidate(BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) {
      String className = beanDef.getBeanClassName();
      if (className == null || beanDef.getFactoryMethodName() != null) {
         return false;
      }
      AnnotationMetadata metadata;
      if (beanDef instanceof AnnotatedBeanDefinition &amp;&amp;
            className.equals(((AnnotatedBeanDefinition) beanDef).getMetadata().getClassName())) {
         // Can reuse the pre-parsed metadata from the given BeanDefinition...
         // 如果 BeanDefinition 是 AnnotatedBeanDefinition 的实例，并且 className 和 BeanDefinition 中的元数据的类名相同
         // 则直接从 BeanDefinition 获得元数据Metadata
         metadata = ((AnnotatedBeanDefinition) beanDef).getMetadata();
      }
      else if (beanDef instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) beanDef).hasBeanClass()) {
         // Check already loaded Class if present...
         // since we possibly can't even load the class file for this Class.
         // 如果 BeanDefinition 是 AbstractBeanDefinition 的实例，并且 beanDef 有 beanClass 属性存在
         // 则实例化 StandardAnnotationMetadata
         Class&lt;?&gt; beanClass = ((AbstractBeanDefinition) beanDef).getBeanClass();
         metadata = new StandardAnnotationMetadata(beanClass, true);
      }
      else {
         try {
            MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);
            metadata = metadataReader.getAnnotationMetadata();
         }
         catch (IOException ex) {
            if (logger.isDebugEnabled()) {
               logger.debug(&quot;Could not find class file for introspecting configuration annotations: &quot; + className, ex);
            }
            return false;
         }
      }
      // 判断当前这个 bd 中存在的类是不是加了 @Configuration 注解，但是如果加了 @Configuration，下面的这几个注解就不再判断，因为这是一个 if-else if 分支
      // 只有满足了 &quot;没有加 @Configuration注解&quot;，才会走 else 分支去判断是否添加了其他注解
      // 如果存在则 Spring 认为它是一个全注解 FULL 的类
      if (isFullConfigurationCandidate(metadata)) {
         // 如果存在 Configuration 注解，则为 BeanDefinition 设置 configurationClass 属性为 FULL
         beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);
      }
      // 判断是否加了以下注解，摘录 isLiteConfigurationCandidate 的源码
//    candidateIndicators.add(Component.class.getName());
//    candidateIndicators.add(ComponentScan.class.getName());
//    candidateIndicators.add(Import.class.getName());
//    candidateIndicators.add(ImportResource.class.getName());
//    如果不存在 @Configuration 注解，Spring 则认为是一个部分注解 LITE 类
      else if (isLiteConfigurationCandidate(metadata)) {
         beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
      }
      else {
         return false;
      }
      // It's a full or lite configuration candidate... Let's determine the order value, if any.
      Integer order = getOrder(metadata);
      if ( order != null) {
         beanDef.setAttribute(ORDER_ATTRIBUTE, order);
      }
      return true;
   }
</code></pre>
<h3 id="111-isfullconfigurationcandidate">1.1.1 isFullConfigurationCandidate</h3>
<p>上述代码第 39 行：</p>
<pre><code class="language-java">public static boolean isFullConfigurationCandidate(AnnotationMetadata metadata) {
   return metadata.isAnnotated(Configuration.class.getName());
}
</code></pre>
<h3 id="112-isliteconfigurationcandidate">1.1.2 isLiteConfigurationCandidate</h3>
<p>上述代码第 49 行：</p>
<pre><code class="language-java">public static boolean isLiteConfigurationCandidate(AnnotationMetadata metadata) {
   // Do not consider an interface or an annotation...
   if (metadata.isInterface()) {
      return false;
   }
   // Any of the typical annotations found?
   for (String indicator : candidateIndicators) {
      if (metadata.isAnnotated(indicator)) {
         return true;
      }
   }
   // Finally, let's look for @Bean methods...
   try {
      return metadata.hasAnnotatedMethods(Bean.class.getName());
   }
   catch (Throwable ex) {
      if (logger.isDebugEnabled()) {
         logger.debug(&quot;Failed to introspect @Bean methods on class [&quot; + metadata.getClassName() + &quot;]: &quot; + ex);
      }
      return false;
   }
}
</code></pre>
<p>上述第 8 行：</p>
<pre><code class="language-java">private static final Set&lt;String&gt; candidateIndicators = new HashSet&lt;&gt;(8);
static {
   candidateIndicators.add(Component.class.getName());
   candidateIndicators.add(ComponentScan.class.getName());
   candidateIndicators.add(Import.class.getName());
   candidateIndicators.add(ImportResource.class.getName());
}
</code></pre>
<p>上述 checkConfigurationClassCandidate 方法的第 39-51 行：</p>
<pre><code class="language-java">      // 判断当前这个 bd 中存在的类是不是加了 @Configuration 注解，但是如果加了 @Configuration，下面的这几个注解就不再判断，因为这是一个 if-else if 分支
      // 只有满足了 &quot;没有加 @Configuration注解&quot;，才会走 else 分支去判断是否添加了其他注解
      if (isFullConfigurationCandidate(metadata)) {
         // 如果存在 Configuration 注解，则为 BeanDefinition 设置 configurationClass 属性为 FULL
         beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);
      }
      // 判断是否加了以下注解，摘录 isLiteConfigurationCandidate 的源码
/nss/    candidateIndicators.add(Component.class.getName());
//    candidateIndicators.add(ComponentScan.class.getName());
//    candidateIndicators.add(Import.class.getName());
//    candidateIndicators.add(ImportResource.class.getName());
      else if (isLiteConfigurationCandidate(metadata)) {
         beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
</code></pre>
<p>如果一个类加了 @Configuration 注解，BeanDefinition 中的 attribute =  CONFIGURATION_CLASS_FULL；否则，BeanDefinition 中的 attribute =   CONFIGURATION_CLASS_LITE</p>
<h3 id="113-parse">1.1.3 parse</h3>
<p>上述 checkConfigurationClassCandidate 方法的第 79 行：</p>
<pre><code class="language-java"> parser.parse(candidates);
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/parse%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AAappConfig%E9%9C%80%E8%A6%81%E6%9B%B4%E6%96%B0.png" alt="图片" loading="lazy"></figure>
<pre><code class="language-java">public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) {
   // deferred：延迟的
   this.deferredImportSelectors = new LinkedList&lt;&gt;();
   // 根据 BeanDefinition 的类型做不同的处理，一般都会调用 ConfigurationClassParse#parse 进行解析
   for (BeanDefinitionHolder holder : configCandidates) {
      BeanDefinition bd = holder.getBeanDefinition();
      try {
         // 判断这个 bd 是否被加了注解
         if (bd instanceof AnnotatedBeanDefinition) {
            // 解析注解对象，并且把解析出来的 bd 放到 map，但是这里的 bd 指的是普通的
            // 何为不普通的呢？比如 @Bean 和 beanFactoryPostProcessor 得到的 bean 不在
            // 但是是这里解析，只是不 put 而已
            parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
         }
         else if (bd instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) {
            parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
         }
         else {
            parse(bd.getBeanClassName(), holder.getBeanName());
         }
      }
      catch (BeanDefinitionStoreException ex) {
         throw ex;
      }
      catch (Throwable ex) {
         throw new BeanDefinitionStoreException(
               &quot;Failed to parse configuration class [&quot; + bd.getBeanClassName() + &quot;]&quot;, ex);
      }
   }
   processDeferredImportSelectors();
}
</code></pre>
<p>上述代码第 13 行：</p>
<pre><code class="language-java">protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {
   processConfigurationClass(new ConfigurationClass(metadata, beanName));
}
</code></pre>
<p>上述代码第 2 行：</p>
<pre><code class="language-java">protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
   // 判断是否应该跳过解析
   if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
      return;
   }
   // 处理 Imported 的情况
   // 就是当前这个类有没有被别的类 @Import
   ConfigurationClass existingClass = this.configurationClasses.get(configClass);
   if (existingClass != null) {
      if (configClass.isImported()) {
         if (existingClass.isImported()) {
            existingClass.mergeImportedBy(configClass);
         }
         // Otherwise ignore new imported config class; existing non-imported class overrides it.
         return;
      }
      else {
         // Explicit bean definition found, probably replacing an import.
         // Let's remove the old one and go with the new one.
         this.configurationClasses.remove(configClass);
         this.knownSuperclasses.values().removeIf(configClass::equals);
      }
   }
   // Recursively process the configuration class and its superclass hierarchy.
   // 将 AppConfig 这个类转化成 SourceClass 
   SourceClass sourceClass = asSourceClass(configClass);
   do {
      sourceClass = doProcessConfigurationClass(configClass, sourceClass);
   }
   while (sourceClass != null);
   // 一个 map，用来存放扫描出来的 bean（注意这里的 bean 不是对象，仅仅是 bean 的信息，因为还没到实例化）
   this.configurationClasses.put(configClass, configClass);
}
</code></pre>
<h4 id="1131-doprocessconfigurationclass">1.1.3.1  doProcessConfigurationClass</h4>
<p>上述代码第 30 行：</p>
<pre><code class="language-java">protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)
      throws IOException {
   // Recursively process any member (nested) classes first
   // 处理内部类
   processMemberClasses(configClass, sourceClass);
   // 处理 @PropertySource 注解
   for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
         sourceClass.getMetadata(), PropertySources.class,
         org.springframework.context.annotation.PropertySource.class)) {
      if (this.environment instanceof ConfigurableEnvironment) {
         processPropertySource(propertySource);
      }
      else {
         logger.warn(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() +
               &quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;);
      }
   }
   // 处理 @ComponentScan 注解
   Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(
         sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
   if (!componentScans.isEmpty() &amp;&amp;
         !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
      for (AnnotationAttributes componentScan : componentScans) {
         // The config class is annotated with @ComponentScan -&gt; perform the scan immediately
         // 扫描普通类 componentScan=com.ssm 
         // 这里扫描出来所有 @Component
         Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =
               this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
         // Check the set of scanned definitions for any further config classes and parse recursively if needed
         // 检查扫描出来的类当中是否还有 Configuration
         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
            BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
            if (bdCand == null) {
               bdCand = holder.getBeanDefinition();
            }
            if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
               parse(bdCand.getBeanClassName(), holder.getBeanName());
            }
         }
      }
   }
   // Process any @Import annotations
   // 处理 @Import
   processImports(configClass, sourceClass, getImports(sourceClass), true);
   // Process any @ImportResource annotations
   AnnotationAttributes importResource =
         AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
   if (importResource != null) {
      String[] resources = importResource.getStringArray(&quot;locations&quot;);
      Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;);
      for (String resource : resources) {
         String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
         configClass.addImportedResource(resolvedResource, readerClass);
      }
   }
   // Process individual @Bean methods
   Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
   for (MethodMetadata methodMetadata : beanMethods) {
      configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
   }
   // Process default methods on interfaces
   processInterfaces(configClass, sourceClass);
   // Process superclass, if any
   if (sourceClass.getMetadata().hasSuperClass()) {
      String superclass = sourceClass.getMetadata().getSuperClassName();
      if (superclass != null &amp;&amp; !superclass.startsWith(&quot;java&quot;) &amp;&amp;
            !this.knownSuperclasses.containsKey(superclass)) {
         this.knownSuperclasses.put(superclass, configClass);
         // Superclass found, return its annotation metadata and recurse
         return sourceClass.getSuperClass();
      }
   }
   // No superclass -&gt; processing is complete
   return null;
}
</code></pre>
<p>上述代码第 30 行：</p>
<pre><code class="language-java">public Set&lt;BeanDefinitionHolder&gt; parse(AnnotationAttributes componentScan, final String declaringClass) {
   ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,
         componentScan.getBoolean(&quot;useDefaultFilters&quot;), this.environment, this.resourceLoader);
   
   // BeanNameGenerator：Bean名字生成器
   Class&lt;? extends BeanNameGenerator&gt; generatorClass = componentScan.getClass(&quot;nameGenerator&quot;);
   boolean useInheritedGenerator = (BeanNameGenerator.class == generatorClass);
   scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator :
         BeanUtils.instantiateClass(generatorClass));
   ScopedProxyMode scopedProxyMode = componentScan.getEnum(&quot;scopedProxy&quot;);
   if (scopedProxyMode != ScopedProxyMode.DEFAULT) {
      scanner.setScopedProxyMode(scopedProxyMode);
   }
   else {
      Class&lt;? extends ScopeMetadataResolver&gt; resolverClass = componentScan.getClass(&quot;scopeResolver&quot;);
      scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));
   }
   scanner.setResourcePattern(componentScan.getString(&quot;resourcePattern&quot;));
   for (AnnotationAttributes filter : componentScan.getAnnotationArray(&quot;includeFilters&quot;)) {
      for (TypeFilter typeFilter : typeFiltersFor(filter)) {
         scanner.addIncludeFilter(typeFilter);
      }
   }
   for (AnnotationAttributes filter : componentScan.getAnnotationArray(&quot;excludeFilters&quot;)) {
      for (TypeFilter typeFilter : typeFiltersFor(filter)) {
         scanner.addExcludeFilter(typeFilter);
      }
   }
  
    // 扫描出来的这个类是否需要懒加载：默认 false
   // xml 配置懒加载：&lt;beans lazy=&quot;true&quot;&gt;&lt;bean&gt;&lt;/bean&gt;&lt;/beans&gt;
   // JavaConfig配置懒加载：@Lazy   public class AppConfig{
   boolean lazyInit = componentScan.getBoolean(&quot;lazyInit&quot;);
   if (lazyInit) {
      scanner.getBeanDefinitionDefaults().setLazyInit(true);
   }
   Set&lt;String&gt; basePackages = new LinkedHashSet&lt;&gt;();
   String[] basePackagesArray = componentScan.getStringArray(&quot;basePackages&quot;);
   for (String pkg : basePackagesArray) {
      String[] tokenized = StringUtils.tokenizeToStringArray(this.environment.resolvePlaceholders(pkg),
            ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);
      Collections.addAll(basePackages, tokenized);
   }
   for (Class&lt;?&gt; clazz : componentScan.getClassArray(&quot;basePackageClasses&quot;)) {
      basePackages.add(ClassUtils.getPackageName(clazz));
   }
   if (basePackages.isEmpty()) {
      basePackages.add(ClassUtils.getPackageName(declaringClass));
   }
   scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {
      @Override
      protected boolean matchClassName(String className) {
         return declaringClass.equals(className);
      }
   });
   return scanner.doScan(StringUtils.toStringArray(basePackages));
}
</code></pre>
<p>上述代码第  12 行：</p>
<pre><code class="language-java">   ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,
         componentScan.getBoolean(&quot;useDefaultFilters&quot;), this.environment, this.resourceLoader);
</code></pre>
<p>这里 new 了一个 ClassPathBeanDefinitionScanner 真正去扫描包的类。<br>
我们再来看一下构造方法中的 scanner：</p>
<pre><code class="language-java">public AnnotationConfigApplicationContext() {
   /**
    * 父类的构造方法 super()
    *创建一个读取注解的 Bean 定义读取器：reader 能读取被加了注解的类
    * 什么是 bean 定义？BeanDefinition
    */
   this.reader = new AnnotatedBeanDefinitionReader(this);
   // 定义扫描器
   // 可以用来扫描包，继而转换成 bd
   // 但是实际上我们扫描包工作不是 scanner 这个对象
   // 是 Spring 自己 new 的一个 ClasspathBeanDefinitionScanner
   // 这里的 scanner 仅仅是为了程序员能够在外部调用 AnnotationConfigApplicationContext 对象的 scan 方法用的。
   this.scanner = new ClassPathBeanDefinitionScanner(this);
}
</code></pre>
<p>这里的 scanner 仅仅是为了程序员能够在外部调用 AnnotationConfigApplicationContext 对象的 scan 方法用的，而不是真正的扫描包。<br>
上述 parse 方法的第 36-39 行：</p>
<pre><code class="language-java">// 扫描出来的这个类是否需要懒加载：默认 false
// xml 配置懒加载：&lt;beans lazy=&quot;true&quot;&gt;&lt;bean&gt;&lt;/bean&gt;&lt;/beans&gt;
// JavaConfig配置懒加载：@Lazy   public class AppConfig{
boolean lazyInit = componentScan.getBoolean(&quot;lazyInit&quot;);   
if (lazyInit) {
  scanner.getBeanDefinitionDefaults().setLazyInit(true);
}
</code></pre>
<p>这里设置懒加载时，将 isLazyInit 设置为 true，而不是将 BeanDefinition 内的 lazy 设置为 true，因为这个时候还没有 BeanDefinition。<br>
上述 parse 方法第 61 行：</p>
<pre><code class="language-java">return scanner.doScan(StringUtils.toStringArray(basePackages));
</code></pre>
<h4 id="doscan">doScan</h4>
<p>点进去 doScan 方法：</p>
<pre><code class="language-java">protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) {
   Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;);
   Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;&gt;();
   // 循环所有 basePackages，因为@ComponentScan({&quot;com.ssm.dao&quot;},{&quot;com.ssm.service&quot;})可以写多个
   for (String basePackage : basePackages) {
      // 扫表 basePackage 路径下的 java 文件
      // 并把它转成 BeanDefinition 类型
      Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);
      for (BeanDefinition candidate : candidates) {
         // 解析 scope 属性
         ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
         candidate.setScope(scopeMetadata.getScopeName());
         String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
         if (candidate instanceof AbstractBeanDefinition) {
            // 如果这个类是 AbstractBeanDefinition 的子类
            // 则为它设置默认值，比如 lazy，init destroy
            postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
         }
         if (candidate instanceof AnnotatedBeanDefinition) {
            // 检查并且处理常用的注解
            // 这里的处理主要是指把常用注解的值设置到 AnnotatedBeanDefinition 当中
            // 当前前提是这个类必须是 AnnotatedBeanDefinition 类型的，说白了就是加了注解的类
            AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
         }
         if (checkCandidate(beanName, candidate)) {
            BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
            definitionHolder =
                  AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
            beanDefinitions.add(definitionHolder);
            registerBeanDefinition(definitionHolder, this.registry);
         }
      }
   }
   return beanDefinitions;
}
</code></pre>
<p>上述第 8 行代码：</p>
<pre><code class="language-java">public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) {
   if (this.componentsIndex != null &amp;&amp; indexSupportsIncludeFilters()) {
      return addCandidateComponentsFromIndex(this.componentsIndex, basePackage);
   }
   else {
      return scanCandidateComponents(basePackage);
   }
}
</code></pre>
<p>上述第 6 行，asm 读取 class 文件：</p>
<pre><code class="language-java">private Set&lt;BeanDefinition&gt; scanCandidateComponents(String basePackage) {
   Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;&gt;();
   try {
      String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
            resolveBasePackage(basePackage) + '/' + this.resourcePattern;
      // asm 读取 class 文件
      Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);
      boolean traceEnabled = logger.isTraceEnabled();
      boolean debugEnabled = logger.isDebugEnabled();
      for (Resource resource : resources) {
         if (traceEnabled) {
            logger.trace(&quot;Scanning &quot; + resource);
         }
         if (resource.isReadable()) {
            try {
               MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);
               if (isCandidateComponent(metadataReader)) {
                  // 通过 Spring 扫描出来的 BeanDefinition 叫 ScannedGenericBeanDefinition 
                  ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
                  sbd.setSource(resource);
                  if (isCandidateComponent(sbd)) {
                     if (debugEnabled) {
                        logger.debug(&quot;Identified candidate component class: &quot; + resource);
                     }
                     candidates.add(sbd);
                  }
                  else {
                     if (debugEnabled) {
                        logger.debug(&quot;Ignored because not a concrete top-level class: &quot; + resource);
                     }
                  }
               }
               else {
                  if (traceEnabled) {
                     logger.trace(&quot;Ignored because not matching any filter: &quot; + resource);
                  }
               }
            }
            catch (Throwable ex) {
               throw new BeanDefinitionStoreException(
                     &quot;Failed to read candidate component class: &quot; + resource, ex);
            }
         }
         else {
            if (traceEnabled) {
               logger.trace(&quot;Ignored because not readable: &quot; + resource);
            }
         }
      }
   }
   catch (IOException ex) {
      throw new BeanDefinitionStoreException(&quot;I/O failure during classpath scanning&quot;, ex);
   }
   return candidates;
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/asm%E6%89%AB%E6%8F%8F%E6%96%87%E4%BB%B6.png" alt="图片" loading="lazy"></figure>
<p>上述代码第 17 行：</p>
<pre><code class="language-java">protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException {
   // 当前这个类是否在 excludeFilters 当中
   for (TypeFilter tf : this.excludeFilters) {
      if (tf.match(metadataReader, getMetadataReaderFactory())) {
         // 如果当前类在排除条件中，返回 false
         return false;
      }
   }
   // 当前这个类是否在 includeFilters当中
   for (TypeFilter tf : this.includeFilters) {
      if (tf.match(metadataReader, getMetadataReaderFactory())) {
         return isConditionMatch(metadataReader);
      }
   }
   return false;
}
</code></pre>
<p>上述代码第 19 行：</p>
<pre><code class="language-java">// 通过 Spring 扫描出来的 BeanDefinition 叫 ScannedGenericBeanDefinition 
ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
</code></pre>
<p>来看一下这个类 ScannedGenericBeanDefinition：</p>
<pre><code class="language-java">public class ScannedGenericBeanDefinition extends GenericBeanDefinition implements AnnotatedBeanDefinition {
</code></pre>
<p>而 GenericBeanDefinition 类：</p>
<pre><code class="language-java">public class GenericBeanDefinition extends AbstractBeanDefinition {
</code></pre>
<p>所以：所有扫描出来的类都 instanceof AbstractBeanDefinition <br>
上述代码第 21 行：</p>
<pre><code class="language-java">protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) {
   AnnotationMetadata metadata = beanDefinition.getMetadata();
   return (metadata.isIndependent() &amp;&amp; (metadata.isConcrete() ||
         (metadata.isAbstract() &amp;&amp; metadata.hasAnnotatedMethods(Lookup.class.getName()))));
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/candidates.png" alt="图片" loading="lazy"></figure>
<p>doScan 方法第 14-24 行</p>
<pre><code class="language-java">// 所有扫描出来的类都 instanceof AbstractBeanDefinition 
if (candidate instanceof AbstractBeanDefinition) {
    // 如果这个类是 AbstractBeanDefinition 的子类
    // 则为它设置默认值，比如 lazy，init destroy
    postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
}
// 如果这个类是被加了注解的
if (candidate instanceof AnnotatedBeanDefinition) {
    // 检查并且处理常用的注解
    // 这里的处理主要是指把常用注解的值设置到 AnnotatedBeanDefinition 当中
    // 当前前提是这个类必须是 AnnotatedBeanDefinition 类型的，说白了就是加了注解的类
          AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
}
</code></pre>
<p>由于上面的分析，上述判断的第 1 行的 if 分支成立<br>
把一个类扫描出来后，需要填充 BeanDefinition，postProcessBeanDefinition 就是填充这个 BeanDefinition，为它设置默认值。</p>
<pre><code class="language-java">protected void postProcessBeanDefinition(AbstractBeanDefinition beanDefinition, String beanName) {
   beanDefinition.applyDefaults(this.beanDefinitionDefaults);
   if (this.autowireCandidatePatterns != null) {
      beanDefinition.setAutowireCandidate(PatternMatchUtils.simpleMatch(this.autowireCandidatePatterns, beanName));
   }
}
</code></pre>
<p>上述代码第 2 行：</p>
<pre><code class="language-java">// 为 BeanDefinition 设置默认值
public void applyDefaults(BeanDefinitionDefaults defaults) {
   // 默认设置懒加载
   setLazyInit(defaults.isLazyInit());
   setAutowireMode(defaults.getAutowireMode());
   setDependencyCheck(defaults.getDependencyCheck());
   setInitMethodName(defaults.getInitMethodName());
   setEnforceInitMethod(false);
   setDestroyMethodName(defaults.getDestroyMethodName());
   setEnforceDestroyMethod(false);
}
</code></pre>
<p>上述判断懒加载时，将 isLazyInit 设置为 true，而不是将 BeanDefinition 内的 lazy 设置为 true，因为那时候还没有 BeanDefinition。<br>
看一下第 12 行的判断：</p>
<pre><code class="language-java">AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
</code></pre>
<p>点进去这个 processCommonDefinitionAnnotations 方法</p>
<pre><code class="language-java">public static void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd) {
   processCommonDefinitionAnnotations(abd, abd.getMetadata());
}
</code></pre>
<p>点进去这个 processCommonDefinitionAnnotations 方法</p>
<pre><code class="language-java">static void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata) {
   AnnotationAttributes lazy = attributesFor(metadata, Lazy.class);
   if (lazy != null) {
      abd.setLazyInit(lazy.getBoolean(&quot;value&quot;));
   }
   else if (abd.getMetadata() != metadata) {
      lazy = attributesFor(abd.getMetadata(), Lazy.class);
      if (lazy != null) {
         abd.setLazyInit(lazy.getBoolean(&quot;value&quot;));
      }
   }
   if (metadata.isAnnotated(Primary.class.getName())) {
      abd.setPrimary(true);
   }
   AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);
   if (dependsOn != null) {
      abd.setDependsOn(dependsOn.getStringArray(&quot;value&quot;));
   }
   if (abd instanceof AbstractBeanDefinition) {
      AbstractBeanDefinition absBd = (AbstractBeanDefinition) abd;
      AnnotationAttributes role = attributesFor(metadata, Role.class);
      if (role != null) {
         absBd.setRole(role.getNumber(&quot;value&quot;).intValue());
      }
      AnnotationAttributes description = attributesFor(metadata, Description.class);
      if (description != null) {
         absBd.setDescription(description.getString(&quot;value&quot;));
      }
   }
}
</code></pre>
<p>doScan 方法的第 30 行：</p>
<pre><code class="language-java">// 加入到 map 中
registerBeanDefinition(definitionHolder, this.registry);
</code></pre>
<p>点进去 registerBeanDefinition：</p>
<pre><code class="language-java">protected void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) {
   BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry);
}
</code></pre>
<p>在点进去 registerBeanDefinition：</p>
<pre><code class="language-java">public static void registerBeanDefinition(
      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
      throws BeanDefinitionStoreException {
   // Register bean definition under primary name.
   String beanName = definitionHolder.getBeanName();
   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
   // Register aliases for bean name, if any.
   String[] aliases = definitionHolder.getAliases();
   if (aliases != null) {
      for (String alias : aliases) {
         registry.registerAlias(beanName, alias);
      }
   }
}
</code></pre>
<p>doProcessConfigurationClass 代码的第 48 行</p>
<pre><code class="language-java">// 处理 @Import
processImports(configClass, sourceClass,getImports(sourceClass), true);
</code></pre>
<p>点进去这个 processImports 方法：</p>
<pre><code class="language-java">private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,
      Collection&lt;SourceClass&gt; importCandidates, boolean checkForCircularImports) {
   // 如果没有加@Import，直接返回
   if (importCandidates.isEmpty()) {
      return;
   }
   if (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) {
      this.problemReporter.error(new CircularImportProblem(configClass, this.importStack));
   }
   else {
      this.importStack.push(configClass);
      try {
         for (SourceClass candidate : importCandidates) {
            // @Import(IndexDao.class)、@Import(ImportSelector)、@Import(ImportBeanDefinitionRegistrar)
            // 判断是不是 ImportSelector
            if (candidate.isAssignable(ImportSelector.class)) {
               // Candidate class is an ImportSelector -&gt; delegate to it to determine imports
               Class&lt;?&gt; candidateClass = candidate.loadClass();
               // 通过反射实现一个对象 
               ImportSelector selector = BeanUtils.instantiateClass(candidateClass, ImportSelector.class);
               ParserStrategyUtils.invokeAwareMethods(
                     selector, this.environment, this.resourceLoader, this.registry);
               if (this.deferredImportSelectors != null &amp;&amp; selector instanceof DeferredImportSelector) {
                  this.deferredImportSelectors.add(
                        new DeferredImportSelectorHolder(configClass, (DeferredImportSelector) selector));
               }
               else {
                  String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
                  Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames);
                  processImports(configClass, currentSourceClass, importSourceClasses, false);
               }
            }
            // 判断是不是 ImportBeanDefinitionRegistrar
            else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
               // Candidate class is an ImportBeanDefinitionRegistrar -&gt;
               // delegate to it to register additional bean definitions
               Class&lt;?&gt; candidateClass = candidate.loadClass();
               ImportBeanDefinitionRegistrar registrar =
                     BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);
               ParserStrategyUtils.invokeAwareMethods(
                     registrar, this.environment, this.resourceLoader, this.registry);
               configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
            }
            // 普通类：@Import(IndexDao.class)
            else {
               // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt;
               // process it as an @Configuration class
               this.importStack.registerImport(
                     currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
               processConfigurationClass(candidate.asConfigClass(configClass));
            }
         }
      }
      catch (BeanDefinitionStoreException ex) {
         throw ex;
      }
      catch (Throwable ex) {
         throw new BeanDefinitionStoreException(
               &quot;Failed to process import candidates for configuration class [&quot; +
               configClass.getMetadata().getClassName() + &quot;]&quot;, ex);
      }
      finally {
         this.importStack.pop();
      }
   }
}
</code></pre>
<h1 id="import">Import</h1>
<h2 id="importselector">ImportSelector</h2>
<pre><code class="language-java">public class MyImportSelector implements ImportSelector {
   @Override
   public String[] selectImports(AnnotationMetadata importingClassMetadata) {
      return new String[]{IndexDaoImpl3.class.getName()};
   }
}
</code></pre>
<pre><code class="language-java">@ComponentScan(&quot;com.ssm&quot;)
@Import(MyImportSelector.class)
public class AppConfig {
</code></pre>
<pre><code class="language-java">public class IndexDaoImpl3 implements IndexDao{
   @Override
   public void query() {
      System.out.println(&quot;dao3...模拟查询数据库&quot;);
   }
}
</code></pre>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      // 初始化 Spring 的环境
      context. refresh();
      IndexDao dao = context.getBean(IndexDaoImpl3.class);
      dao.query();
   }
}
</code></pre>
<p>运行结果：</p>
<pre><code>dao3...模拟查询数据库
</code></pre>
<p>直接在 IndexDaoImpl3 添加 @Component 注解也能实现将 对象注入到 Spring 容器中，为什么要使用一个 MyImportSelector implements ImportSelector 类呢？<br>
因为有的功能需要 Spring 动态帮我们加载，比如 IndexDaoImpl3 是我开发的程序，我开发的程序并不一定在我的项目中，可以在 AppConfig 中修改扫描包，但是如果只有一个类需要引用，修改扫描包 @ComponentScan 不是好的办法。可以开关闭某些功能。</p>
<p>动态代理：</p>
<p>Spring 底层的 AOP 提供一个开关来开启是否要对 AOP 的支持</p>
<pre><code class="language-java">public class IndexDaoImpl3 implements IndexDao, BeanPostProcessor {
   @Override
   public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
      if(beanName.equals(&quot;indexDao&quot;)){
         bean = Proxy.newProxyInstance(this.getClass().getClassLoader(), new Class[]{IndexDao.class},new MyInvocationHandler(bean));
      }
      return bean;
   }
   @Override
   public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
      return null;
   }
   @Override
   public void query() {
      System.out.println(&quot;dao3...模拟查询数据库&quot;);
   }
}
</code></pre>
<p>怎样实现 Spring 动态加载？</p>
<pre><code class="language-java">public class MyImportSelector implements ImportSelector {
   @Override
   public String[] selectImports(AnnotationMetadata importingClassMetadata) {
      // 得到 @EnableLuban 注解的值
      // int value = importingClassMetadata.getAnnotationTypes().value
      // if(value)   return new String[]{IndexDaoImpl3.class.getName()};
      return new String[]{IndexDaoImpl3.class.getName()};
   }
}
</code></pre>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
@Import(MyImportSelector.class)
public @interface EnableLuban {
}
</code></pre>
<pre><code class="language-java">@ComponentScan(&quot;com.ssm&quot;)
@EnableLuban
public class AppConfig {
</code></pre>
<p>如果配置类有 @EnableLuban 注解，运行结果：</p>
<pre><code>dao3...模拟查询数据库
</code></pre>
<p>如果配置类没有 @EnableLuban 注解，运行结果：</p>
<pre><code>Exception in thread &quot;main&quot; org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'com.ssm.dao.impl.IndexDaoImpl3' available
</code></pre>
<pre><code class="language-java">public class MyInvocationHandler implements InvocationHandler {
   Object target;
   public MyInvocationHandler(Object target){
      this.target = target;
   }
   @Override
   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
      System.out.println(&quot;代理方法...&quot;);
      return method.invoke(target,args);
   }
}
</code></pre>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      // 初始化 Spring 的环境
      context. refresh();
      IndexDao dao = (IndexDao) context.getBean(&quot;indexDao&quot;);
      dao.query();
   }
}
</code></pre>
<p>运行结果：</p>
<pre><code>代理方法...
dao...模拟查询数据库
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring系列（八）Spring源码解析]]></title>
        <id>https://epitomm.github.io/post/spring-xi-lie-ba-spring-yuan-ma-jie-xi/</id>
        <link href="https://epitomm.github.io/post/spring-xi-lie-ba-spring-yuan-ma-jie-xi/">
        </link>
        <updated>2020-05-09T07:58:17.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      // 初始化 Spring 环境
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // 注册 AppConfig.class
      context.register(AppConfig.class);
      // 解析 AppConfig.class
      context.refresh();
      IndexDao indexDao = context.getBean(IndexDaoImpl.class);
      indexDao.query();
   }
}
</code></pre>
<h1 id="1new-annotationconfigapplicationcontext">1.new AnnotationConfigApplicationContext();</h1>
<p>第 6-7 行代码：由于 AnnotationConfigApplicationContext 有父类，所以会先调用父类构造方法。</p>
<pre><code class="language-java">public class AnnotationConfigApplicationContext extends GenericApplicationContext implements AnnotationConfigRegistry {
</code></pre>
<p>父类构造方法 GenericApplicationContext() 中创建一个 DefaultListableBeanFactory 工厂：</p>
<pre><code class="language-java">public GenericApplicationContext() {
   this.beanFactory = new DefaultListableBeanFactory();
}
</code></pre>
<p>父类构造方法调用完成后，调用本类构造方法，初始化读取器 AnnotatedBeanDefinitionReader 和扫描器 ClassPathBeanDefinitionScanner：</p>
<pre><code class="language-java">public AnnotationConfigApplicationContext() {
   /**
    * 父类的构造方法 super()
    *创建一个读取注解的 Bean 定义读取器：reader 能读取被加了注解的类
    * 什么是 bean 定义？BeanDefinition
    */
   this.reader = new AnnotatedBeanDefinitionReader(this);
   // 定义扫描器
   // 可以用来扫描包，继而转换成 bd
   // 但是实际上我们扫描包工作不是 scanner 这个对象
   // 是 Spring 自己 new 的一个 ClasspathBeanDefinitionScanner
   // 这里的 scanner 仅仅是为了程序员能够在外部调用 AnnotationConfigApplicationContext 对象的 scan 方法用的。
   this.scanner = new ClassPathBeanDefinitionScanner(this);
}
</code></pre>
<h2 id="11-new-annotatedbeandefinitionreaderthis">1.1 new AnnotatedBeanDefinitionReader(this)</h2>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/7%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B.png" alt="图片" loading="lazy"></figure>
<h1 id="2contextrefresh">2.context.refresh();</h1>
<p>Test 类第 12 行代码：</p>
<pre><code class="language-java">context.refresh();
</code></pre>
<p>点进去如下：</p>
<pre><code class="language-java">public void refresh() throws BeansException, IllegalStateException {
   synchronized (this.startupShutdownMonitor) {
      // Prepare this context for refreshing.
      // 准备工作包括设置启动时间、是否激活标识位，初始化属性源（property source）配置
      prepareRefresh();
      // Tell the subclass to refresh the internal bean factory.
      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
      // Prepare the bean factory for use in this context.
      // 准备 Bean 工厂
      prepareBeanFactory(beanFactory);
      try {
         // Allows post-processing of the bean factory in context subclasses.
         // 这个方法在当前版本的 spring 是没有任何代码的
         // 可能 Spring 期待在后面的版本中去扩展吧
         postProcessBeanFactory(beanFactory);
         // Invoke factory processors registered as beans in the context.
         // 在 Spring 的环境中执行已经被注册的 factory processors
         // 设置执行自定义的 ProcessBeanFactory 和 Spring 内部自己定义的，比如 ConfigurationClassPostProcessor
         invokeBeanFactoryPostProcessors(beanFactory);
         // Register bean processors that intercept bean creation.
         registerBeanPostProcessors(beanFactory);
         // Initialize message source for this context.
         initMessageSource();
         // Initialize event multicaster for this context.
         initApplicationEventMulticaster();
         // Initialize other special beans in specific context subclasses.
         onRefresh();
         // Check for listener beans and register them.
         registerListeners();
         // Instantiate all remaining (non-lazy-init) singletons.
         finishBeanFactoryInitialization(beanFactory);
         // Last step: publish corresponding event.
         finishRefresh();
      }
      catch (BeansException ex) {
         if (logger.isWarnEnabled()) {
            logger.warn(&quot;Exception encountered during context initialization - &quot; +
                  &quot;cancelling refresh attempt: &quot; + ex);
         }
         // Destroy already created singletons to avoid dangling resources.
         destroyBeans();
         // Reset 'active' flag.
         cancelRefresh(ex);
         // Propagate exception to caller.
         throw ex;
      }
      finally {
         // Reset common introspection caches in Spring's core, since we
         // might not ever need metadata for singleton beans anymore...
         resetCommonCaches();
      }
   }
}
</code></pre>
<h2 id="21-preparebeanfactory">2.1 prepareBeanFactory</h2>
<p>上述代码第 12 行准备 Bean 工厂：</p>
<pre><code class="language-java">/**
 * 配置工厂标准的特征，比如上下文的加载器 ClassLoader 和 post-processors 回调
 * Configure the factory's standard context characteristics,
 * such as the context's ClassLoader and post-processors.
 * @param beanFactory the BeanFactory to configure
 */
protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
   // Tell the internal bean factory to use the context's class loader etc.
   beanFactory.setBeanClassLoader(getClassLoader());
   // bean 表达式解析器，能够在前台页面获取 bean 当中的属性
   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
   // 对象与 string 类型的转换 &lt;property ref=&quot;dao&quot;&gt; 将dao转为对象
   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));
   // Configure the bean factory with context callbacks.
   // 添加一个后置管理器：ApplicationContextAwareProcessor 实现了 BeanPostProcessor接口：插手 Bean 的创建过程
   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
   // 忽略接口
   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);
   // BeanFactory interface not registered as resolvable type in a plain factory.
   // MessageSource registered (and found for autowiring) as a bean.
   // 依赖替换：如果注入的是 BeanFactory，就用 beanFactory 替代
   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
   beanFactory.registerResolvableDependency(ResourceLoader.class, this);
   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
   beanFactory.registerResolvableDependency(ApplicationContext.class, this);
   // Register early post-processor for detecting inner beans as ApplicationListeners.
   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));
   // Detect a LoadTimeWeaver and prepare for weaving, if found.
   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
      // Set a temporary ClassLoader for type matching.
      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
   }
   // 意思是如果自定义的 Bean 中没有名为 &quot;systemProperties&quot; 和 &quot;systemEnvironment&quot; 的 Bean
   // 则注册两个 Bean，key 为 &quot;systemProperties&quot; 和 &quot;systemEnvironment&quot;, value 为 map
   // 这两个 Bean 就是一些系统配置和系统环境信息
   // Register default environment beans.
   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
   }
   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
   }
   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
   }
}
</code></pre>
<h2 id="22-invokebeanfactorypostprocessors">2.2 invokeBeanFactoryPostProcessors</h2>
<p>看 refresh 方法的第 23 行 ：</p>
<pre><code class="language-java">invokeBeanFactoryPostProcessors(beanFactory);
</code></pre>
<p>点进去这个方法：</p>
<pre><code class="language-java">protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
   // 这个地方需要注意 getBeanFactoryPostProcessors() 是获取手动给 Spring 的 BeanFactoryPostProcessor
   // 自定义的并不仅仅是程序员自己写的
   // 自己写的可以加 @Component,也可以不加，
   // 如果加了@Component这个getBeanFactoryPostProcessors()方法得不到，应该是 Spring 自己扫描的
   // 为什么得不到？因为 getBeanFactoryPostProcessors() 这个方法是直接获取一个 list，
   // 这个 list 是在 AnnotationConfigApplicationContext被定义
   // 所谓的自定义的就是你手动调用 AnnotationConfigApplicationContext.addBeanFactoryPostProcessor(new XxxBeanFactoryPostProcessor());
   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
   // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
   // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
   if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
   }
}
</code></pre>
<h3 id="221-getbeanfactorypostprocessors">2.2.1 getBeanFactoryPostProcessors</h3>
<p>上述代码第 9 行中的 getBeanFactoryPostProcessors()：</p>
<pre><code class="language-java">public List&lt;BeanFactoryPostProcessor&gt; getBeanFactoryPostProcessors() {
   return this.beanFactoryPostProcessors;
}
</code></pre>
<p>beanFactoryPostProcessors 变量的定义如下：</p>
<pre><code class="language-java">private final List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors = new ArrayList&lt;&gt;();
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E8%87%AA%E5%AE%9A%E4%B9%89beanFactoryPostProcessor.png" alt="图片" loading="lazy"></figure>
<h3 id="222-invokebeanfactorypostprocessors">2.2.2 invokeBeanFactoryPostProcessors</h3>
<p>同样的 invokeBeanFactoryPostProcessors 方法的第 9 行：</p>
<pre><code class="language-java">public static void invokeBeanFactoryPostProcessors(
      ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) {
   // Invoke BeanDefinitionRegistryPostProcessors first, if any.
   Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;();
   if (beanFactory instanceof BeanDefinitionRegistry) {
      BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
      // 定义两个 list， BeanDefinitionRegistryPostProcessor 实现了 BeanFactoryPostProcessor 接口
      // 因为 bdrp 是子类，子类扩展了父类中的功能。
      List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;();
      List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;(); 
      // 自定义的 beanFactoryPostProcessors
      // 因为传参，所以 beanFactoryPostProcessors 是 BeanFactoryPostProcessor 类型
      // 这里因为 beanFactoryPostProcessors长度为0，所以不会进入 for 循环 
      for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
         // 判断 postProcessor 是否是 BeanFactoryPostProcessor 的子类 BeanDefinitionRegistryPostProcessor
         if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
            BeanDefinitionRegistryPostProcessor registryProcessor =
                  (BeanDefinitionRegistryPostProcessor) postProcessor;
            registryProcessor.postProcessBeanDefinitionRegistry(registry);
            registryProcessors.add(registryProcessor);
         }
         else {
         // 如果 postProcessor 不是 BeanFactoryPostProcessor 的子类 BeanDefinitionRegistryPostProcessor，那 postProcessor 就一定是 BeanFactoryPostProcessor 类型，添加到 List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors 中
            regularPostProcessors.add(postProcessor);
         }
      }
      
      // 这个 currentRegistryProcessors 放的是 Spring 内部自己实现了 BeanDefinitionRegistryPostProcessor 接口的对象
      List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;();
      // BeanDefinitionRegistryPostProcessor 等于 BeanFactoryPostProcessor
      String[] postProcessorNames =
            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
      // 这个地方可以得到一个 BeanFactoryPostProcessor，因为是 Spring 默认在最开始自己注册的
      // 为什么要在最开始注册这个呢？
      // 因为 Spring 的工厂需要注解去扫描等等功能
      // 而这些功能都是需要在 Spring 工厂初始化完成之前就执行
      // 要么在工厂最开始的时候，要么在工厂初始化之中，反正不能在之后
      // 因为如果在之后就没有意义，因为那个时候已经需要使用工厂了
      // 所以这里 Spring 在一开始就注册了一个 BeanFactoryPostProcessor，用来插手 springFactory 的实例化过程
      // 在这个地方断点可以知道这个类叫做 ConfigurationClassPostProcessor
      // ConfigurationClassPostProcessor 那么这个类能干嘛呢？可以参考源码
      // 下面对这个“插手 Spring 工厂实例化过程”的类重点解释
      for (String ppName : postProcessorNames) {
         if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
         }
      }
      // 排序不重要，况且 currentRegistryProcessor 这里也只有一个数据
      sortPostProcessors(currentRegistryProcessors, beanFactory);
      // 合并 List，不重要（为什么要合并，因为有自定义的Spring自己的）
      registryProcessors.addAll(currentRegistryProcessors);
      // 最重要。注意这里是方法调用
      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
      currentRegistryProcessors.clear();
      // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
      for (String ppName : postProcessorNames) {
         if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
         }
      }
      sortPostProcessors(currentRegistryProcessors, beanFactory);
      registryProcessors.addAll(currentRegistryProcessors);
      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
      currentRegistryProcessors.clear();
      // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
      boolean reiterate = true;
      while (reiterate) {
         reiterate = false;
         postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
         for (String ppName : postProcessorNames) {
            if (!processedBeans.contains(ppName)) {
               currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
               processedBeans.add(ppName);
               reiterate = true;
            }
         }
         sortPostProcessors(currentRegistryProcessors, beanFactory);
         registryProcessors.addAll(currentRegistryProcessors);
         invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
         currentRegistryProcessors.clear();
      }
      // Now, invoke the postProcessBeanFactory callback of all processors handled so far.
      invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
      invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
   }
   else {
      // Invoke factory processors registered with the context instance.
      invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
   }
   // Do not initialize FactoryBeans here: We need to leave all regular beans
   // uninitialized to let the bean factory post-processors apply to them!
   String[] postProcessorNames =
         beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);
   // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
   // Ordered, and the rest.
   List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();
   List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();
   List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();
   for (String ppName : postProcessorNames) {
      if (processedBeans.contains(ppName)) {
         // skip - already processed in first phase above
      }
      else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
         priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
      }
      else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
         orderedPostProcessorNames.add(ppName);
      }
      else {
         nonOrderedPostProcessorNames.add(ppName);
      }
   }
   // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
   invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);
   // Next, invoke the BeanFactoryPostProcessors that implement Ordered.
   List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();
   for (String postProcessorName : orderedPostProcessorNames) {
      orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
   }
   sortPostProcessors(orderedPostProcessors, beanFactory);
   invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);
   // Finally, invoke all other BeanFactoryPostProcessors.
   List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();
   for (String postProcessorName : nonOrderedPostProcessorNames) {
      nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
   }
   invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);
   // Clear cached merged bean definitions since the post-processors might have
   // modified the original metadata, e.g. replacing placeholders in values...
   beanFactory.clearMetadataCache();
}
</code></pre>
<p>上述第 11、12、31 行分别定义了一个 List：</p>
<ul>
<li>List<BeanFactoryPostProcessor> regularPostProcessors：放程序员手动添加的 BeanFactoryPostProcessor</li>
<li>List<BeanDefinitionRegistryPostProcessor> registryProcessors：放程序员手动添加的 BeanDefinitionRegistryPostProcessor</li>
<li>List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors：放 Spring 内部自己的 BeanDefinitionRegistryPostProcessor</li>
</ul>
<p>上述第 35-36 行代码：</p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/currentRegistryProcessors.png" alt="图片" loading="lazy"></figure>
<p>上述第 47-51 行代码：</p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/postProcessorNames.png" alt="图片" loading="lazy"></figure>
<p>上述代码第 58 行：</p>
<pre><code class="language-java">private static void invokeBeanDefinitionRegistryPostProcessors(
      Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry) {
   for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
      postProcessor.postProcessBeanDefinitionRegistry(registry);
   }
}
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/postProcessors.png" alt="图片" loading="lazy"></figure>
<p>点进去上述第  5 行代码：</p>
<pre><code class="language-java">@Override
public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
   int registryId = System.identityHashCode(registry);
   if (this.registriesPostProcessed.contains(registryId)) {
      throw new IllegalStateException(
            &quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot; + registry);
   }
   if (this.factoriesPostProcessed.contains(registryId)) {
      throw new IllegalStateException(
            &quot;postProcessBeanFactory already called on this post-processor against &quot; + registry);
   }
   this.registriesPostProcessed.add(registryId);
   processConfigBeanDefinitions(registry);
}
</code></pre>
<h4 id="2221-processconfigbeandefinitions">2.2.2.1 processConfigBeanDefinitions</h4>
<p>点进上述第 14 行代码：</p>
<pre><code class="language-java">public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
   // app 提供的 bean：每扫描到添加了 @Configuraion 注解的类就添加到这个 set 集合中
   List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;();
   // 获取容器中注册的所有 bean 名字
   String[] candidateNames = registry.getBeanDefinitionNames();
   // 依次取出每个&lt;beanName,beanDefinition&gt;
   for (String beanName : candidateNames) {
      BeanDefinition beanDef = registry.getBeanDefinition(beanName);
      // 判断当前 bean 是否被处理过：使用 isFullConfigurationClass 来标识
      if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
            ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {
         // 如果 BeanDefinition 中的 configurationClass 属性为 full 或者 lite，则意味着已经处理过了，直接跳过
         // 这里需要结合下面的代码才能理解
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Bean definition has already been processed as a configuration class: &quot; + beanDef);
         }
      }
      // 判断这个 BeanDefinition 是否是 Configuration类，这其实主要是看是否有
      else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
         configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
      }
   }
   // Return immediately if no @Configuration classes were found
   if (configCandidates.isEmpty()) {
      return;
   }
   // 排序，根据 order，不重要
   // Sort by previously determined @Order value, if applicable
   configCandidates.sort((bd1, bd2) -&gt; {
      int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
      int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
      return Integer.compare(i1, i2);
   });
   // Detect any custom bean name generation strategy supplied through the enclosing application context
   SingletonBeanRegistry sbr = null;
   // 如果 BeanDefinitionRegistry 是 SingletonBeanRegistry 子类的话
   // 由于会将 registry 强转为 SingletonBeanRegistry
   if (registry instanceof SingletonBeanRegistry) {
      sbr = (SingletonBeanRegistry) registry;
      if (!this.localBeanNameGeneratorSet) {//是否有自定义的
         BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);
         // SingletonBeanRegistry 中有 id 为 org.springframework.context.annotation.internalConfigurationBeanNameGenerator
         // 如果有则利用它的，否则则使用 Spring 默认的
         if (generator != null) {
            this.componentScanBeanNameGenerator = generator;
            this.importBeanNameGenerator = generator;
         }
      }
   }
   if (this.environment == null) {
      this.environment = new StandardEnvironment();
   }
   // Parse each @Configuration class
   // 实例化 ConfigurationClassParser 为了解析各个配置类
   ConfigurationClassParser parser = new ConfigurationClassParser(
         this.metadataReaderFactory, this.problemReporter, this.environment,
         this.resourceLoader, this.componentScanBeanNameGenerator, registry);
   // 实例化 2 个 set，candidates 用于将之前加入的 configCandidates 进行去重
   // 因为可能有多个配置类重复了
   // alreadyParsed 用户判断是否处理过
   Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates);
   Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size());
   do {
      parser.parse(candidates);
      parser.validate();
      Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());
      configClasses.removeAll(alreadyParsed);
      // Read the model and create bean definitions based on its content
      if (this.reader == null) {
         this.reader = new ConfigurationClassBeanDefinitionReader(
               registry, this.sourceExtractor, this.resourceLoader, this.environment,
               this.importBeanNameGenerator, parser.getImportRegistry());
      }
      // 把扫描出来的 bean 对应的 beanDefinitions 添加到 factory 的 map 当中
      this.reader.loadBeanDefinitions(configClasses);
      alreadyParsed.addAll(configClasses);
      candidates.clear();
      if (registry.getBeanDefinitionCount() &gt; candidateNames.length) {
         String[] newCandidateNames = registry.getBeanDefinitionNames();
         Set&lt;String&gt; oldCandidateNames = new HashSet&lt;&gt;(Arrays.asList(candidateNames));
         Set&lt;String&gt; alreadyParsedClasses = new HashSet&lt;&gt;();
         for (ConfigurationClass configurationClass : alreadyParsed) {
            alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
         }
         for (String candidateName : newCandidateNames) {
            if (!oldCandidateNames.contains(candidateName)) {
               BeanDefinition bd = registry.getBeanDefinition(candidateName);
               if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp;
                     !alreadyParsedClasses.contains(bd.getBeanClassName())) {
                  candidates.add(new BeanDefinitionHolder(bd, candidateName));
               }
            }
         }
         candidateNames = newCandidateNames;
      }
   }
   while (!candidates.isEmpty());
   // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes
   if (sbr != null &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {
      sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
   }
   if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {
      // Clear cache in externally provided MetadataReaderFactory; this is a no-op
      // for a shared cache since it'll be cleared by the ApplicationContext.
      ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();
   }
}
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/getBeanDefinitionNames.png" alt="图片" loading="lazy"></figure>
<h5 id="22211-checkconfigurationclasscandidate">2.2.2.1.1 checkConfigurationClassCandidate</h5>
<p>上述代码第 19 行：</p>
<pre><code class="language-java">else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
</code></pre>
<p>refresh() 的主要功能是要解析类：Spring 认为添加了@Configuration、@Component、@Import...注解的类都是需要解析的类。<br>
如何将一个 User 类变成 BeanDefinition：XxxBeanDefinition bd = new XxxBeanDefinition(user);</p>
<p>Spring 如何判断一个类是否是应该解析的类？</p>
<p>①判断一个 bd 是否被加了注解（AnnotatedBeanDefinition abd = new AnnotatedBeanDefinition(AppConfig.class); register.regisyBD(abd); ）；②把信息（元数据）拿出来；③根据信息判断加了什么注解</p>
<pre><code class="language-java">public static boolean checkConfigurationClassCandidate(BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) {
   String className = beanDef.getBeanClassName();
   if (className == null || beanDef.getFactoryMethodName() != null) {
      return false;
   }
   AnnotationMetadata metadata;
   // 判断这个 bd 是否被加了注解
   if (beanDef instanceof AnnotatedBeanDefinition &amp;&amp;
         className.equals(((AnnotatedBeanDefinition) beanDef).getMetadata().getClassName())) {
      // Can reuse the pre-parsed metadata from the given BeanDefinition...
      // 如果 BeanDefinition 是 AnnotatedBeanDefinition 的实例，并且 className 和 BeanDefinition 中的元数据的类名相同
      // 则直接从 BeanDefinition 获得元数据Metadata
      metadata = ((AnnotatedBeanDefinition) beanDef).getMetadata();
   }
   else if (beanDef instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) beanDef).hasBeanClass()) {
      // Check already loaded Class if present...
      // since we possibly can't even load the class file for this Class.
      // 如果 BeanDefinition 是 AbstractBeanDefinition 的实例，并且 beanDef 有 beanClass 属性存在
      // 则实例化 StandardAnnotationMetadata
      Class&lt;?&gt; beanClass = ((AbstractBeanDefinition) beanDef).getBeanClass();
      metadata = new StandardAnnotationMetadata(beanClass, true);
   }
   else {
      try {
         MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);
         metadata = metadataReader.getAnnotationMetadata();
      }
      catch (IOException ex) {
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Could not find class file for introspecting configuration annotations: &quot; + className, ex);
         }
         return false;
      }
   }
   // 判断当前这个 bd 中存在的类是不是加了 @Configuration 注解，但是如果加了 @Configuration，下面的这几个注解就不再判断，因为这是一个 if-else if 分支
   // 只有满足了 &quot;没有加 @Configuration注解&quot;，才会走 else 分支去判断是否添加了其他注解
   if (isFullConfigurationCandidate(metadata)) {
      // 如果存在 Configuration 注解，则为 BeanDefinition 设置 configurationClass 属性为 FULL
      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);
   }
   // 判断是否加了以下注解，摘录 isLiteConfigurationCandidate 的源码
   // candidateIndicators.add(Component.class.getName());
   // candidateIndicators.add(ComponentScan.class.getName());
   // candidateIndicators.add(Import.class.getName());
   // candidateIndicators.add(ImportResource.class.getName());
   else if (isLiteConfigurationCandidate(metadata)) {
      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
   }
   else {
      return false;
   }
   // It's a full or lite configuration candidate... Let's determine the order value, if any.
   Integer order = getOrder(metadata);
   if (order != null) {
      beanDef.setAttribute(ORDER_ATTRIBUTE, order);
   }
   return true;
}
</code></pre>
<p>上述代码第 39 行，判断是否加了 @Configuration 注解</p>
<pre><code class="language-java">public static boolean isFullConfigurationCandidate(AnnotationMetadata metadata) {
   return metadata.isAnnotated(Configuration.class.getName());
}
</code></pre>
<p>上述代码第 48 行，判断是否加了其他注解：</p>
<pre><code class="language-java">public static boolean isLiteConfigurationCandidate(AnnotationMetadata metadata) {
   // Do not consider an interface or an annotation...
   if (metadata.isInterface()) {
      return false;
   }
   // Any of the typical annotations found?
   for (String indicator : candidateIndicators) {
      if (metadata.isAnnotated(indicator)) {
         return true;
      }
   }
   // Finally, let's look for @Bean methods...
   try {
      return metadata.hasAnnotatedMethods(Bean.class.getName());
   }
   catch (Throwable ex) {
      if (logger.isDebugEnabled()) {
         logger.debug(&quot;Failed to introspect @Bean methods on class [&quot; + metadata.getClassName() + &quot;]: &quot; + ex);
      }
      return false;
   }
}
</code></pre>
<p>上述代码第 8 行中提到的 candidateIndicators</p>
<pre><code class="language-java">private static final Set&lt;String&gt; candidateIndicators = new HashSet&lt;&gt;(8);
static {
   candidateIndicators.add(Component.class.getName());
   candidateIndicators.add(ComponentScan.class.getName());
   candidateIndicators.add(Import.class.getName());
   candidateIndicators.add(ImportResource.class.getName());
}
</code></pre>
<p>关于 39-48 行的 if-else if 判断是否添加注解，其中 &quot;eles if&quot; 分支的作用，补充说明：</p>
<ul>
<li>如果一个类添加了 @Configuration，Spring 把它扫描出来，知道它是一个配置类，然后再去解析这个类，就可以依次扫描到其他注解：@ComponentScan、@Import</li>
<li>但是如果一个类没有添加 @Configuration 注解，只加入了 @ImportResource(&quot;spring.xml&quot;) 注解，这时候就需要使用到上述的 eles if 分支单独进行处理。</li>
</ul>
<p>上述 processConfigBeanDefinitions 方法的第 79 行：</p>
<pre><code class="language-java">parser.parse(candidates);
</code></pre>
<p>点进这个方法：</p>
<pre><code class="language-java">public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) {
   this.deferredImportSelectors = new LinkedList&lt;&gt;();
   // 根据 BeanDefinition 的类型做不同的处理，一般都会调用 ConfigurationClassParse#parse 进行解析
   for (BeanDefinitionHolder holder : configCandidates) {
      BeanDefinition bd = holder.getBeanDefinition();
      try {
         // 判断这个 bd 是否被加了注解
         if (bd instanceof AnnotatedBeanDefinition) {
            parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
         }
         else if (bd instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) {
            parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
         }
         else {
            parse(bd.getBeanClassName(), holder.getBeanName());
         }
      }
      catch (BeanDefinitionStoreException ex) {
         throw ex;
      }
      catch (Throwable ex) {
         throw new BeanDefinitionStoreException(
               &quot;Failed to parse configuration class [&quot; + bd.getBeanClassName() + &quot;]&quot;, ex);
      }
   }
   processDeferredImportSelectors();
}
</code></pre>
<p>上述代码第 9 行：</p>
<pre><code class="language-java">parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
</code></pre>
<p>点进这个方法：</p>
<pre><code class="language-java">protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {
   processConfigurationClass(new ConfigurationClass(metadata, beanName));
}
</code></pre>
<p>点进第 2 行这个方法：</p>
<pre><code class="language-java">protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
   // 判断是否应该跳过解析
   if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
      return;
   }
   // 处理 Imported 的情况
   ConfigurationClass existingClass = this.configurationClasses.get(configClass);
   if (existingClass != null) {
      if (configClass.isImported()) {
         if (existingClass.isImported()) {
            existingClass.mergeImportedBy(configClass);
         }
         // Otherwise ignore new imported config class; existing non-imported class overrides it.
         return;
      }
      else {
         // Explicit bean definition found, probably replacing an import.
         // Let's remove the old one and go with the new one.
         this.configurationClasses.remove(configClass);
         this.knownSuperclasses.values().removeIf(configClass::equals);
      }
   }
   // Recursively process the configuration class and its superclass hierarchy.
   SourceClass sourceClass = asSourceClass(configClass);
   do {
      sourceClass = doProcessConfigurationClass(configClass, sourceClass);
   }
   while (sourceClass != null);
   // 一个 map，用来存放扫描出来的 bean（注意这里的 bean 不是对象，仅仅是 bean 的信息，因为还没到实例化）
   this.configurationClasses.put(configClass, configClass);
}
</code></pre>
<p>上述代码第 28 行：</p>
<pre><code class="language-java">@Nullable
protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)
      throws IOException {
   // Recursively process any member (nested) classes first
   // 处理内部类
   processMemberClasses(configClass, sourceClass);
   // Process any @PropertySource annotations
   for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
         sourceClass.getMetadata(), PropertySources.class,
         org.springframework.context.annotation.PropertySource.class)) {
      if (this.environment instanceof ConfigurableEnvironment) {
         processPropertySource(propertySource);
      }
      else {
         logger.warn(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() +
               &quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;);
      }
   }
   // Process any @ComponentScan annotations
   Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(
         sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
   if (!componentScans.isEmpty() &amp;&amp;
         !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
      for (AnnotationAttributes componentScan : componentScans) {
         // The config class is annotated with @ComponentScan -&gt; perform the scan immediately
         Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =
               this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
         // Check the set of scanned definitions for any further config classes and parse recursively if needed
         // 检查扫描出来的类当中是否还有 Configuration
         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
            BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
            if (bdCand == null) {
               bdCand = holder.getBeanDefinition();
            }
            if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
               parse(bdCand.getBeanClassName(), holder.getBeanName());
            }
         }
      }
   }
   // Process any @Import annotations
   // 处理 @Import
   processImports(configClass, sourceClass, getImports(sourceClass), true);
   // Process any @ImportResource annotations
   AnnotationAttributes importResource =
         AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
   if (importResource != null) {
      String[] resources = importResource.getStringArray(&quot;locations&quot;);
      Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;);
      for (String resource : resources) {
         String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
         configClass.addImportedResource(resolvedResource, readerClass);
      }
   }
   // Process individual @Bean methods
   Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
   for (MethodMetadata methodMetadata : beanMethods) {
      configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
   }
   // Process default methods on interfaces
   processInterfaces(configClass, sourceClass);
   // Process superclass, if any
   if (sourceClass.getMetadata().hasSuperClass()) {
      String superclass = sourceClass.getMetadata().getSuperClassName();
      if (superclass != null &amp;&amp; !superclass.startsWith(&quot;java&quot;) &amp;&amp;
            !this.knownSuperclasses.containsKey(superclass)) {
         this.knownSuperclasses.put(superclass, configClass);
         // Superclass found, return its annotation metadata and recurse
         return sourceClass.getSuperClass();
      }
   }
   // No superclass -&gt; processing is complete
   return null;
}
</code></pre>
<p>上述代码第 47 行，判断有没有加 Import 标签</p>
<pre><code class="language-java">private Set&lt;SourceClass&gt; getImports(SourceClass sourceClass) throws IOException {
   Set&lt;SourceClass&gt; imports = new LinkedHashSet&lt;&gt;();
   Set&lt;SourceClass&gt; visited = new LinkedHashSet&lt;&gt;();
   collectImports(sourceClass, imports, visited);
   return imports;
}
</code></pre>
<p>@Import 注解：</p>
<ul>
<li>@Import(IndexDao.class)、</li>
<li>@Import(ImportSelector)、</li>
<li>@Import(ImportBeanDefinitionRegistrar)</li>
</ul>
<p>同样的上述代码第 47 行：</p>
<pre><code class="language-java">private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,
      Collection&lt;SourceClass&gt; importCandidates, boolean checkForCircularImports) {
   // 如果没有加@Import，直接返回
   if (importCandidates.isEmpty()) {
      return;
   }
   if (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) {
      this.problemReporter.error(new CircularImportProblem(configClass, this.importStack));
   }
   else {
      this.importStack.push(configClass);
      try {
         for (SourceClass candidate : importCandidates) {
            // @Import(IndexDao.class)、@Import(ImportSelector)、@Import(ImportBeanDefinitionRegistrar)
            // 判断是不是 ImportSelector
            if (candidate.isAssignable(ImportSelector.class)) {
               // Candidate class is an ImportSelector -&gt; delegate to it to determine imports
               Class&lt;?&gt; candidateClass = candidate.loadClass();
               ImportSelector selector = BeanUtils.instantiateClass(candidateClass, ImportSelector.class);
               ParserStrategyUtils.invokeAwareMethods(
                     selector, this.environment, this.resourceLoader, this.registry);
               if (this.deferredImportSelectors != null &amp;&amp; selector instanceof DeferredImportSelector) {
                  this.deferredImportSelectors.add(
                        new DeferredImportSelectorHolder(configClass, (DeferredImportSelector) selector));
               }
               else {
                  String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
                  Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames);
                  processImports(configClass, currentSourceClass, importSourceClasses, false);
               }
            }
            // 判断是不是 ImportBeanDefinitionRegistrar
            else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
               // Candidate class is an ImportBeanDefinitionRegistrar -&gt;
               // delegate to it to register additional bean definitions
               Class&lt;?&gt; candidateClass = candidate.loadClass();
               ImportBeanDefinitionRegistrar registrar =
                     BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);
               ParserStrategyUtils.invokeAwareMethods(
                     registrar, this.environment, this.resourceLoader, this.registry);
               configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
            }
            // 普通类：@Import(IndexDao.class)
            else {
               // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt;
               // process it as an @Configuration class
               this.importStack.registerImport(
                     currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
               processConfigurationClass(candidate.asConfigClass(configClass));
            }
         }
      }
      catch (BeanDefinitionStoreException ex) {
         throw ex;
      }
      catch (Throwable ex) {
         throw new BeanDefinitionStoreException(
               &quot;Failed to process import candidates for configuration class [&quot; +
               configClass.getMetadata().getClassName() + &quot;]&quot;, ex);
      }
      finally {
         this.importStack.pop();
      }
   }
}
</code></pre>
<p>插手 Spring 中 Bean 工厂的建设：<br>
BeanFactoryPostProcessor：把它设置为一个 Bean 的属性。</p>
<p>ImportBeanDefinitionRegistrar：把 map 暴露出来，用户就可以向 map 中动态添加 bean 了。</p>
<h1 id="注册-bean-的方法">注册 Bean 的方法</h1>
<h2 id="registerindexdaoimplclass">register(IndexDaoImpl.class);</h2>
<ul>
<li>bdmap.put()</li>
<li>需要的是一个类，一个类变成 BeanDefinition 的过程是没办法参与的</li>
</ul>
<h2 id="scancomssm">scan(&quot;com.ssm&quot;)</h2>
<ul>
<li>需要的是一个类，一个类变成 BeanDefinition 的过程是没办法参与的</li>
</ul>
<h2 id="importbeandefinitionregistrar">ImportBeanDefinitionRegistrar</h2>
<ul>
<li>向 map 中添加一个 bd</li>
<li>好处：可以参与一个类变成 BeanDefinition 的过程</li>
</ul>
<p>@MapperScan() 的作用：扫描 mapper</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
@MapperScan(&quot;com.ssm.dao&quot;)
public class AppConfig{
    @Bean
    public DataSource dataSource(){
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
        dataSource.setUsername(&quot;root&quot;);
        dataSource.setPassword(&quot;123456&quot;);
        dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/card&quot;);
        return dataSource;
    }
    @Bean
    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){
        SqlSessionFactoryBean sqlSessionFactoryBean =  new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource);
        return sqlSessionFactoryBean;
    }
}
</code></pre>
<pre><code class="language-java">@Component
public class CardService{
  @Autowired
  CardDao cardDao;
  public void list(){
    System.out.println(cardDao.list(&quot;xxx&quot;));
  }
}
</code></pre>
<pre><code class="language-java">public interface CardDao{
  @Select(&quot;select * from card where card_number like '%s{number}%'&quot;)
  public List&lt;Map&lt;Integer,String&gt;&gt; list(@Param(&quot;number&quot;) String number);
}
</code></pre>
<p>CardDao 是一个接口，一个接口如何变成一个对象？</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        context.getBean(CardService.class).list();
    }
}
</code></pre>
<p>@MapperScan() ：将一个接口变成一个对象，且把变成的这个对象放到 Spring 容器中。</p>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Import(MapperScannerRegistrar.class)
public @interface MapperScan {
</code></pre>
<p>Spring 在解析到 @MapperScan 后，又会去解析 @Import，然后再解析 MapperScannerRegistrar<br>
MapperScannerRegistrar 类中有一个 registerBeanDefinitions 方法，此方法有一个参数是 BeanDefinitionRegistry，即把注册器暴露出来，就可以向容器中添加 Bean 了，这个方法是在所有 Bean 执行之前执行的：</p>
<pre><code class="language-java">public class MapperScannerRegistrar implements ImportBeanDefinitionRegistrar, ResourceLoaderAware {
  private ResourceLoader resourceLoader;
  /**
   * {@inheritDoc}
   */
  @Override
  public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
</code></pre>
<p>@Autowired<br>
CardDao cardDao;</p>
<p>如果有一个类 A extends CardService，不会将类 A 自动注入给 CardDao。如果有一个类 A implements CardDao，会将类 A 注入给 CardDao。</p>
<p>模拟 Mybatis：在现在的基础上完成：① 创建一个对象；② 对象实现 CardDao 接口； ③这个对象在 Spring 容器中。</p>
<h3 id="让一个接口变成对象代理">让一个接口变成对象：代理</h3>
<p>1.测试类</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        CardDao cardDao = (CardDao) Proxy.newProxyInstance(Test.class.getClassLoader(), new Class[]{CardDao.class}, new MyInvocationHandler());
        cardDao.list(&quot;1&quot;);
    }
}
</code></pre>
<p>2.MyInvocationHandler</p>
<pre><code class="language-java">public class MyInvocationHandler implements InvocationHandler {
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;handler...&quot;);
        return null;
    }
}
</code></pre>
<p>3.输出结果：</p>
<pre><code>handler...
</code></pre>
<p>4.分析：<br>
通过 JDK 动态代理生成一个对象，执行代理方法时打印了 handler...</p>
<p>上述步骤 1、2、3、4 已经实现了① 创建一个对象；② 对象实现 CardDao 接口，接下来实现步骤 ③将这个对象放到 Spring 容器中</p>
<h3 id="将对象放到-spring-容器中">将对象放到 Spring 容器中</h3>
<h4 id="方法一实现-beanfactorypostprocessor-接口">方法一：实现 BeanFactoryPostProcessor 接口</h4>
<pre><code class="language-java">// 对 Bean 工厂进行插手，只能对 Bean 工厂进行初始化，不能将对象放入到 map 中，没有对应API
public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
    }
}
</code></pre>
<h4 id="方法二实现-importselector-接口">方法二：实现 ImportSelector  接口</h4>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
@MapperScan(&quot;com.ssm&quot;)
// Spring 把 MyImportSelect 类中 invoke 方法返回的字符串数组类名 new 出对象放到 Spring 工厂中
@Import(MyImportSelect.class) 
public class AppConfig{
</code></pre>
<pre><code class="language-java">public class MyImportSelect implements ImportSelector {
    @Override
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        // 因为是要将代理对象放到Spring工厂中，但是这里得不到代理对象的类名
        return new String[]{CardDaoProxy.class.getSimpleName()};
    }
}
</code></pre>
<p>必须先产生代理对象出来，然后再来执行：Spring 扫描 @Import 注解，将 MyImportSelect 类中 invoke 方法返回的字符串数组类名 new 出对象放到 Spring 工厂中。</p>
<h4 id="方法三实现-importbeandefinitionregistrar-接口">方法三：实现 ImportBeanDefinitionRegistrar  接口</h4>
<p>1、实现 ImportBeanDefinitionRegistrar  接口：创建代理对象，并添加到 Spring 容器中</p>
<pre><code class="language-java">public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        // 1.得到 BeanDefinition
            // 扫描所有接口：扫描 com.ssm.dao 下所有接口。这里为了方便写死，不模拟动态了
        // carDao：代理对象
        CardDao cardDao = (CardDao) Proxy.newProxyInstance(Test.class.getClassLoader(), new Class[]{CardDao.class}, new MyInvocationHandler());
        cardDao.list(&quot;2&quot;);
        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(cardDao.getClass());
        GenericBeanDefinition beanDefinition = (GenericBeanDefinition) builder.getBeanDefinition();
        registry.registerBeanDefinition(&quot;cardDao&quot;,beanDefinition);
    }
}
</code></pre>
<p>2、配置类扫描 MyImportBeanDefinitionRegistrar</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
@MapperScan(&quot;com.ssm&quot;)
@Import(MyImportBeanDefinitionRegistrar.class)
public class AppConfig{
</code></pre>
<p>3、测试类：初始化 Spring 容器</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
    }
}
</code></pre>
<p>5、测试结果：</p>
<pre><code>handler...
Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'cardDao': Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'java.lang.reflect.InvocationHandler' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {}
</code></pre>
<p>6、分析<br>
代理对象的代理方法执行了（证明 cardDao.list(&quot;2&quot;) 执行到了），但是代理对象注入不进来，因为 Spring 没有办法这样处理一个类，这个 dao 中的某些属性 Spring 没有注入进来。</p>
<pre><code class="language-java">public class MyInvocationHandler implements InvocationHandler {
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;proxy...&quot;);
        return null;
    }
}
</code></pre>
<p>7、接口不能实例化</p>
<pre><code class="language-java">public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        // 得到 BeanDefinition(扫描所有接口：扫描 com.ssm.dao 下所有接口。这里为了方便写死，不模拟动态了)
        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(CardDao.class);
        // 得到 BeanDefinition，BeanDefinition 有一个属性 beanClass 表示类型 CardDao.class
        GenericBeanDefinition beanDefinition = (GenericBeanDefinition) builder.getBeanDefinition();
        registry.registerBeanDefinition(&quot;cardDao&quot;,beanDefinition);
    }
}
</code></pre>
<pre><code>Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.ssm.dao.CardDao]: Specified class is an interface
</code></pre>
<p>根据 beanName=&quot;cardDao&quot; 取出 BeanDefinition，当执行完上述第 5 行代码后，取出的 BeanDefinition 类型为 CardDao 接口，接口不能实例化。<br>
所以需要将一个代理对象放入 map 中，{ beanName=&quot;dao&quot;, BeanDefinition={beanClass=$Proxy01.class; ...} }</p>
<p>8、引入 FactoryBean</p>
<pre><code class="language-java">public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        // 得到 BeanDefinition(扫描所有接口：扫描 com.ssm.dao 下所有接口。这里为了方便写死，不模拟动态了)
        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(CardDao.class);
        // 得到 BeanDefinition，BeanDefinition 有一个属性 beanClass 表示类型 CardDao
        GenericBeanDefinition beanDefinition = (GenericBeanDefinition) builder.getBeanDefinition();
        // 给 BeanDefinition 添加构造方法，因为 public MyFactoryBean(Class clazz) { 构造方法有参数
        beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(&quot;com.ssm.dao.CardDao&quot;);
        // 设置 BeanDefinition 的 beanClass 为代理对象
        beanDefinition.setBeanClass(MyFactoryBean.class);
        registry.registerBeanDefinition(&quot;cardDao&quot;,beanDefinition);
    }
}
</code></pre>
<p>如果类实现了 FactoryBean，那么 Spring 容器当中存在两个对象，一个是 getObject() 方法返回的代理对象（name=&quot;myFactoryBean &quot;）；还有一个是当前对象 MyFactoryBean（name=&amp;myFactoryBean ） 。</p>
<pre><code class="language-java">public class MyFactoryBean implements FactoryBean, InvocationHandler {
    Class clazz;
    public MyFactoryBean(Class clazz) {
        this.clazz = clazz;
    }
    @Override
    public Object getObject() throws Exception {
        Class[] clazzs = new Class[]{clazz};
        Object proxy = Proxy.newProxyInstance(this.getClass().getClassLoader(),clazzs,this);
        return proxy;
    }
    @Override
    public Class&lt;?&gt; getObjectType() {
        return clazz;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 得到代理对象的接口，通过名字去拿方法
        Method method1 = proxy.getClass().getInterfaces()[0].getMethod(method.getName(), String.class);
        // 拿到这个方法的注解
        Select select = method1.getDeclaredAnnotation(Select.class);
        System.out.println(String.valueOf(select.value()[0]));
        System.out.println(&quot;proxy&quot;);
        return null;
    }
}
</code></pre>
<p>自定义注解：</p>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
@Import(MyImportBeanDefinitionRegistrar.class)
public @interface LuBanScan {
    String value();
}
</code></pre>
<p>配置类：</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
@LuBanScan(&quot;com.ssm&quot;)
@Import(MyImportBeanDefinitionRegistrar.class)
public class AppConfig{
</code></pre>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        CardDao cardDao = (CardDao) context.getBean(&quot;cardDao&quot;);
        cardDao.list(&quot;2&quot;);
    }
}
</code></pre>
<p>测试结果：</p>
<pre><code>select * from t1 where a=#{number}
proxy
</code></pre>
<h1 id="mybatis">MyBatis</h1>
<pre><code class="language-xml">&lt;bean id=&quot;userMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;
  &lt;property name=&quot;mapperInterface&quot; value=&quot;org.mybatis.spring.sample.mapper.UserMapper&quot; /&gt;
  &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p>如果不想使用 @MapperScan，采用上述代码同样可以完成扫描 mapper 的功能。上述代码不是将 UserMapper 注册给 MapperFactoryBean。<br>
正确含义：MapperFactoryBean 就是前面手动模拟的 MyFactoryBean：</p>
<pre><code class="language-java">public class MyFactoryBean implements FactoryBean, InvocationHandler {
    Class clazz;
    public MyFactoryBean(Class clazz) {
        this.clazz = clazz;
    }
</code></pre>
<p>上述的 xml 代码含义：将 UserMapper 作为 Class 参数传递给 MapperFactoryBean，MapperFactoryBean 得到接口后，内部动态生成代理对象。<br>
Mybatis 源码：MapperFactoryBean 内部同样有一个 Class，构造方法 MapperFactoryBean(Class<T> mapperInterface)，是不是与我们模拟的 MyFactoryBean 几乎一样呢？</p>
<pre><code class="language-java">public class MapperFactoryBean&lt;T&gt; extends SqlSessionDaoSupport implements FactoryBean&lt;T&gt; {
  private Class&lt;T&gt; mapperInterface;
  private boolean addToConfig = true;
  public MapperFactoryBean() {
    //intentionally empty 
  }
  
  public MapperFactoryBean(Class&lt;T&gt; mapperInterface) {
    this.mapperInterface = mapperInterface;
  }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring系列（七）Spring源码解析]]></title>
        <id>https://epitomm.github.io/post/spring-xi-lie-qi-spring-yuan-ma-jie-xi/</id>
        <link href="https://epitomm.github.io/post/spring-xi-lie-qi-spring-yuan-ma-jie-xi/">
        </link>
        <updated>2020-05-08T08:47:27.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      // 初始化 Spring 的环境
      context.refresh();
      IndexDao indexDao = context.getBean(IndexDaoImpl.class);
      indexDao.query();
   }
}
</code></pre>
<h1 id="1new-annotationconfigapplicationcontext">1.new AnnotationConfigApplicationContext();</h1>
<p>第 6 行代码，new AnnotationConfigApplicationContext(); 时，由于 AnnotationConfigApplicationContext 有父类</p>
<pre><code class="language-java">public class AnnotationConfigApplicationContext extends GenericApplicationContext implements AnnotationConfigRegistry {
</code></pre>
<h2 id="11-genericapplicationcontext">1.1 GenericApplicationContext()</h2>
<p>所以会先调用父类 GenericApplicationContext  的构造方法（上一篇文章中提到过），今天就从它父类的构造方法说起：实例化了一个 Bean 工厂，</p>
<pre><code class="language-java">/**
 * Create a new GenericApplicationContext.
 * @see #registerBeanDefinition
 * @see #refresh
 */
public GenericApplicationContext() {
   // 实例化一个 Bean 工厂
   this.beanFactory = new DefaultListableBeanFactory();
}
</code></pre>
<h3 id="111-defaultlistablebeanfactory">1.1.1 DefaultListableBeanFactory</h3>
<p>这个 Bean 工厂内到底有些什么属性呢，这里列举出几个常用重要属性：</p>
<pre><code class="language-java">/** 从序列化ID映射到工厂实例 */
private static final Map&lt;String, Reference&lt;DefaultListableBeanFactory&gt;&gt; serializableFactories =
      new ConcurrentHashMap&lt;&gt;(8);
/** 该工厂的可选ID，用于序列化 */
// 可以理解为身份证号
@Nullable
private String serializationId;
// 工厂中能够处理类的实例化顺序
@Nullable
private Comparator&lt;Object&gt; dependencyComparator;
// map&lt;beanName,beanDefinition&gt;
private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);
/** List of bean definition names, in registration order */
private volatile List&lt;String&gt; beanDefinitionNames = new ArrayList&lt;&gt;(256);
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/bean%E5%B7%A5%E5%8E%82.png" alt="图片" loading="lazy"></figure>
<h2 id="12-annotationconfigapplicationcontext">1.2 AnnotationConfigApplicationContext()</h2>
<p>调用完父类构造方法后，调用本类构造方法，即</p>
<pre><code class="language-java">public AnnotationConfigApplicationContext() {
   /**
    * 父类的构造方法 super()
    *创建一个读取注解的 Bean 定义读取器：reader 能读取被加了注解的类
    * 什么是 bean 定义？BeanDefinition
    */
   this.reader = new AnnotatedBeanDefinitionReader(this);
   // 定义扫描器
   this.scanner = new ClassPathBeanDefinitionScanner(this);
}
</code></pre>
<h3 id="121-thisreader-new-annotatedbeandefinitionreaderthis">1.2.1 this.reader = new AnnotatedBeanDefinitionReader(this);</h3>
<p>我们来看上述代码第 7 行的参数为 this（AnnotatedBeanDefinitionReader），点进这个方法看到参数类型为 BeanDefinitionRegistry，也就是意味着 AnnotatedBeanDefinitionReader = BeanDefinitionRegistry</p>
<pre><code class="language-java">public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry) {
   this(registry, getOrCreateEnvironment(registry));
}
</code></pre>
<h4 id="1211-annotatedbeandefinitionreaderbeandefinitionregistry-registry-environment-environment">1.2.1.1 AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment)</h4>
<p>这里调用了一个重载的构造方法</p>
<pre><code class="language-java">public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) {
   Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;);
   Assert.notNull(environment, &quot;Environment must not be null&quot;);
   this.registry = registry;
   this.conditionEvaluator = new ConditionEvaluator(registry, environment, null);
   AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
}
</code></pre>
<p>看第 6 行点进去</p>
<pre><code class="language-java">public static void registerAnnotationConfigProcessors(BeanDefinitionRegistry registry) {
   registerAnnotationConfigProcessors(registry, null);
}
</code></pre>
<p>在点进去第 2 行这个方法：</p>
<pre><code class="language-java">public static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors(
      BeanDefinitionRegistry registry, @Nullable Object source) {
   // 通过 registry 得到 Bean 工厂
   DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);
   if (beanFactory != null) {
      // AnnotationAwareOrderComparator 主要能解析 @Order 注解和 @Priority
      if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {
         // ContextAnnotationAutowireCandidateResolver 提供处理器延迟加载的功能
         beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);
      }
      if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) {
         beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());
      }
   }
   Set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;&gt;(8);
   // BeanDefinition的注册，这里很重要，需要理解注册每个 bean 的类型
   if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {
      // 需要注意的是 ConfigurationClassPostProcessor 的类型是 BeanDefinitionRegistryPostProcessor
      // 而 BeanDefinitionRegistryPostProcessor 最终实现 BeanFactoryPostProcess
      RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);
      def.setSource(source);
      beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
   }
   if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {
      RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);
      def.setSource(source);
      beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
   }
   if (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {
      RootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);
      def.setSource(source);
      beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
   }
   // Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.
   if (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {
      RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);
      def.setSource(source);
      beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));
   }
   // Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.
   if (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {
      RootBeanDefinition def = new RootBeanDefinition();
      try {
         def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,
               AnnotationConfigUtils.class.getClassLoader()));
      }
      catch (ClassNotFoundException ex) {
         throw new IllegalStateException(
               &quot;Cannot load optional framework class: &quot; + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);
      }
      def.setSource(source);
      beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));
   }
   
   if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {
      RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);
      def.setSource(source);
      beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));
   }
   if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {
      RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);
      def.setSource(source);
      beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));
   }
   return beanDefs;
}
</code></pre>
<p>上述代码第 24 行</p>
<pre><code class="language-java">beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
</code></pre>
<pre><code class="language-java">private static BeanDefinitionHolder registerPostProcessor(
      BeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName) {
   definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
   registry.registerBeanDefinition(beanName, definition);
   return new BeanDefinitionHolder(definition, beanName);
}
</code></pre>
<p>上述第 6 行代码：通过 registry 的 registerBeanDefinition 方法将 &lt;beanName,definition&gt; 放到 map 中：</p>
<h3 id="122-thisscanner-new-classpathbeandefinitionscannerthis">1.2.2 this.scanner = new ClassPathBeanDefinitionScanner(this);</h3>
<p>继续看本类构造方法的第 9 行，能够扫描一个类，并且转换成 BeanDefinition</p>
<pre><code class="language-java">public AnnotationConfigApplicationContext() {
   /**
    * 父类的构造方法 super()
    *创建一个读取注解的 Bean 定义读取器：reader 能读取被加了注解的类
    * 什么是 bean 定义？BeanDefinition
    */
   this.reader = new AnnotatedBeanDefinitionReader(this);
   // 定义扫描器
   this.scanner = new ClassPathBeanDefinitionScanner(this);
}
</code></pre>
<h1 id="2contextregisterappconfigclass">2.context.register(AppConfig.class);</h1>
<p>接下来看 Test 测试类的第 10 行：</p>
<pre><code class="language-java">context.register(AppConfig.class);
</code></pre>
<p>点进 register 方法如下：</p>
<pre><code class="language-java">public void register(Class&lt;?&gt;... annotatedClasses) {
   Assert.notEmpty(annotatedClasses, &quot;At least one annotated class must be specified&quot;);
   this.reader.register(annotatedClasses);
}
</code></pre>
<p>第 3 行：调用 reader 的 register() 方法，将  AppConfig.class 这个普通的类交给 reader，由 reader 将它转化成 BeanDefinition。那么这个具体的 register 方法是如何实现的呢？点进去这个 register() 方法</p>
<h2 id="21-doregisterbean">2.1 doRegisterBean</h2>
<p>(中间省略两步代码)最终会到 doRegisterBean 方法：</p>
<pre><code class="language-java">&lt;T&gt; void doRegisterBean(Class&lt;T&gt; annotatedClass, @Nullable Supplier&lt;T&gt; instanceSupplier, @Nullable String name,
      @Nullable Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers) {
   /**
    *
    * AnnotatedGenericBeanDefinition：被注解的 BeanDefinition(描述Bean)
    * 将 bean 放入 map 中，bean 的 name 是 map 的 key，
    * map 中的 value 为 AnnotatedGenericBeanDefinition 对象
    */
   AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass);
   /**
    * 判断这个类是否需要跳过解析
    * 通过代码可以知道 Spring 判断是否跳过解析，主要判断有没有加注解
    */
   // 这个类如果没有加注解，就不需要解析。因为 AnnotatedGenericBeanDefinition 是为了注册被加了注解的；
   // 如果这个类没有被加注解，就跳过不解析
   if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) {
      return;
   }
   abd.setInstanceSupplier(instanceSupplier);
   /**
    * 得到类的作用域
    *     如果是 context.register(SpringConfig.class);则作用域没有什么作用
    *     注册单个类时需要，比如：context.register(IndexService.class);
    */
   ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);
   /**
    * 将类的作用域添加到数据结构中
    */
   abd.setScope(scopeMetadata.getScopeName());
   /**
    * 生成类的名字通过 beanNameGenerator
    */
   String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));
   /**
    * 处理类当中的其他通用注解
    * 分析源码可以知道它主要处理：Lazy、DependsOn、Primary、Role 等注解
    * 处理完成之后 processCommonDefinitionAnnotation 中依然是把它添加到数据结构 AnnotatedGenericBeanDefinition 当中
    */
   AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
   /**
    * 如果在向容器注册注解 @Bean定义时，使用了额外的限定符注解则解析
    * 关于 Qualifier 和 Primary 主要涉及到 Spring 的自动装配
    * 这里需要注意的
    *     beanName 和 qualifier 这个变量时 Annotation 类型的数组，里面不仅仅是 Qualifier 注解
    *     理论上里面存的是一切注解，所以可以看到下面的代码 Spring 去循环了这个数组
    *     然后依次判断注解当中是否包含了 Primary，是否包含了 Lazy
    */
   if (qualifiers != null) {
      for (Class&lt;? extends Annotation&gt; qualifier : qualifiers) {
         if (Primary.class == qualifier) {
            abd.setPrimary(true);
         }
         else if (Lazy.class == qualifier) {
            abd.setLazyInit(true);
         }
         else {
            abd.addQualifier(new AutowireCandidateQualifier(qualifier));
         }
      }
   }
   for (BeanDefinitionCustomizer customizer : definitionCustomizers) {
      customizer.customize(abd);
   }
   /**
    * 这个 BeanDefinitionHolder 也是一个数据结构
    * BeanDefinitionHolder 是一个 map，里面放了一个 (BeanDefinition，beanName)
    */
   BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);
   definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
   /**
    * 把上述的这个数据结构注册给 registry
    * registry 就是 AnnotationConfigApplicationContext
    * AnnotationConfigApplicationContext 在初始化的时候通过调用父类的构造方法实例化了一个 DefaultListableBeanFactory
    * registerBeanDefinition 里面就是把 definitionHolder 这个数据结构包含的信息注册到 DefaultListableBeanFactory 这个工厂
    */
   BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
}
</code></pre>
<p>为什么 deoRegisterBean 方法中要解析作用域、其他通用注解等信息？<br>
因为如果 context.register(IndexServiceImpl.class); 参数是 Bean 时，则需要获取 Bean 具体信息然后封装成 BeanDefinition，注册进 map 中。</p>
<h3 id="211-new-annotatedgenericbeandefinitionannotatedclass">2.1.1 new AnnotatedGenericBeanDefinition(annotatedClass);</h3>
<p>上述第 10 行代码，使用 new AnnotatedGenericBeanDefinition(annotatedClass); 的方式将一个普通的 annotatedClass(AppConfig.class) 转化成 AnnotatedGenericBeanDefinition。</p>
<h3 id="212-registerbeandefinitiondefinitionholder-thisregistry">2.1.2 registerBeanDefinition(definitionHolder, this.registry);</h3>
<p>上述代码第 80 行：</p>
<pre><code class="language-java">BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
</code></pre>
<p>点进 registerBeanDefinition 方法：</p>
<pre><code class="language-java">public static void registerBeanDefinition(
      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
      throws BeanDefinitionStoreException {
   // Register bean definition under primary name.
   String beanName = definitionHolder.getBeanName();
   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
   // Register aliases for bean name, if any.
   String[] aliases = definitionHolder.getAliases();
   if (aliases != null) {
      for (String alias : aliases) {
         registry.registerAlias(beanName, alias);
      }
   }
}
</code></pre>
<p>上述代码第 7 行，使用 registry 的 registerBeanDefinition 方法将 &lt;beanName,BeanDefinition&gt;注册到 map 中。<br>
<img src="https://epitomm.github.io/post-images/registerBeanDefinition.png" alt="图片" loading="lazy"></p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/bean%E5%B7%A5%E5%8E%82_2.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/register_2.png" alt="图片" loading="lazy"></figure>
<h1 id="3contextrefresh">3.context.refresh()</h1>
<pre><code class="language-java">@Override
public void refresh() throws BeansException, IllegalStateException {
   synchronized (this.startupShutdownMonitor) {
      // Prepare this context for refreshing.
      // 准备工作包括设置启动时间、是否激活标识位，初始化属性源（property source）配置
      prepareRefresh();
      // 告诉子类 refresh Bean 工厂
      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
      // 用这个上下文准备 Bean 工厂
      prepareBeanFactory(beanFactory);
      try {
         // Allows post-processing of the bean factory in context subclasses.
         postProcessBeanFactory(beanFactory);
         // Invoke factory processors registered as beans in the context.
         invokeBeanFactoryPostProcessors(beanFactory);
         // Register bean processors that intercept bean creation.
         registerBeanPostProcessors(beanFactory);
         // Initialize message source for this context.
         initMessageSource();
         // Initialize event multicaster for this context.
         initApplicationEventMulticaster();
         // Initialize other special beans in specific context subclasses.
         onRefresh();
         // Check for listener beans and register them.
         registerListeners();
         // Instantiate all remaining (non-lazy-init) singletons.
         finishBeanFactoryInitialization(beanFactory);
         // Last step: publish corresponding event.
         finishRefresh();
      }
      catch (BeansException ex) {
         if (logger.isWarnEnabled()) {
            logger.warn(&quot;Exception encountered during context initialization - &quot; +
                  &quot;cancelling refresh attempt: &quot; + ex);
         }
         // Destroy already created singletons to avoid dangling resources.
         destroyBeans();
         // Reset 'active' flag.
         cancelRefresh(ex);
         // Propagate exception to caller.
         throw ex;
      }
      finally {
         // Reset common introspection caches in Spring's core, since we
         // might not ever need metadata for singleton beans anymore...
         resetCommonCaches();
      }
   }
}
</code></pre>
<h2 id="31-preparerefresh">3.1 prepareRefresh();</h2>
<p>上述第6 行代码：<strong>准备工作包括设置启动时间、是否激活标识位，初始化属性源（property source）配置</strong></p>
<h2 id="32-obtainfreshbeanfactory">3.2 obtainFreshBeanFactory();</h2>
<p>上述第 9 行代码：得到 BeanFactory，因为需要对 BeanFactory 进行设置</p>
<pre><code class="language-java">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
</code></pre>
<h2 id="33-preparebeanfactorybeanfactory">3.3 prepareBeanFactory(beanFactory);</h2>
<p>上述第 12 行代码：准备 Bean 工厂</p>
<pre><code class="language-java">prepareBeanFactory(beanFactory);
</code></pre>
<p>点进这个 prepareBeanFactory 方法：</p>
<pre><code class="language-java">protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
   // Tell the internal bean factory to use the context's class loader etc.
   beanFactory.setBeanClassLoader(getClassLoader());
   // bean 表达式解析器
   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
   // 注册属性编辑器
   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));
   // Configure the bean factory with context callbacks.
   // 添加一个后置管理器：ApplicationContextAwareProcessor 实现了 BeanPostProcessor接口：插手 Bean 的创建过程
   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);
   // BeanFactory interface not registered as resolvable type in a plain factory.
   // MessageSource registered (and found for autowiring) as a bean.
   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
   beanFactory.registerResolvableDependency(ResourceLoader.class, this);
   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
   beanFactory.registerResolvableDependency(ApplicationContext.class, this);
   // Register early post-processor for detecting inner beans as ApplicationListeners.
   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));
   // Detect a LoadTimeWeaver and prepare for weaving, if found.
   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
      // Set a temporary ClassLoader for type matching.
      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
   }
   // Register default environment beans.
   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
   }
   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
   }
   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
   }
}
</code></pre>
<p>上述代码第 3 行，添加一个类加载器：</p>
<pre><code class="language-java">beanFactory.setBeanClassLoader(getClassLoader());
</code></pre>
<p>上述代码第 5 行，添加 bean 表达式解析器，为了能够让 BeanFactory 去解析 bean 表达式</p>
<pre><code class="language-java">//bean 表达式解析器
beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
// 注册属性编辑器
</code></pre>
<p>上述 12-17 行，添加了自动注入被忽略的列表：</p>
<pre><code class="language-java">  beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);   
</code></pre>
<p>上述代码第 27 行，添加了一个 ApplicationListenerDetector 后置处理器</p>
<pre><code class="language-java">beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));
</code></pre>
<h3 id="331-beanfactoryaddbeanpostprocessornew-applicationcontextawareprocessorthis">3.3.1 beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</h3>
<p>上述代码第 11 行，</p>
<pre><code class="language-java">// 添加一个后置管理器：ApplicationContextAwareProcessor 实现了 BeanPostProcessor接口：插手 Bean 的创建过程
beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
</code></pre>
<p>点进去 (new ApplicationContextAwareProcessor(this)：</p>
<pre><code class="language-java">public ApplicationContextAwareProcessor(ConfigurableApplicationContext applicationContext) {
   this.applicationContext = applicationContext;
   this.embeddedValueResolver = new EmbeddedValueResolver(applicationContext.getBeanFactory());
}
</code></pre>
<p>在点进去看 beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</p>
<pre><code class="language-java">@Override
public void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) {
   Assert.notNull(beanPostProcessor, &quot;BeanPostProcessor must not be null&quot;);
   // Remove from old position, if any
   this.beanPostProcessors.remove(beanPostProcessor);
   // Track whether it is instantiation/destruction aware
   if (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) {
      this.hasInstantiationAwareBeanPostProcessors = true;
   }
   if (beanPostProcessor instanceof DestructionAwareBeanPostProcessor) {
      this.hasDestructionAwareBeanPostProcessors = true;
   }
   // Add to end of list
   this.beanPostProcessors.add(beanPostProcessor);
}
</code></pre>
<p>上述 14 行 提到的 beanPostProcessors，是一个 List<BeanPostProcessor></p>
<pre><code class="language-java">/** BeanPostProcessors to apply in createBean */
private final List&lt;BeanPostProcessor&gt; beanPostProcessors = new CopyOnWriteArrayList&lt;&gt;();
</code></pre>
<h2 id="34-postprocessbeanfactorybeanfactory">3.4 postProcessBeanFactory(beanFactory);</h2>
<p>看 refresh() 看 的第 16 行代码：</p>
<pre><code class="language-java">// 这个方法在当前版本的 spring 是没有任何代码的
// 可能 Spring 期待在后面的版本中去扩展吧
postProcessBeanFactory(beanFactory);
</code></pre>
<h2 id="35-invokebeanfactorypostprocessorsbeanfactory">3.5 invokeBeanFactoryPostProcessors(beanFactory);</h2>
<p>看 refresh() 看 的第 19 行代码：</p>
<pre><code class="language-java">invokeBeanFactoryPostProcessors(beanFactory);
</code></pre>
<p>点进去这个代码：</p>
<pre><code class="language-java">protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
   // 这个地方需要注意 getBeanFactoryPostProcessors() 是获取自定义的
   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
   // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
   // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
   if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
   }
}
</code></pre>
<h3 id="351-getbeanfactorypostprocessors">3.5.1 getBeanFactoryPostProcessors()</h3>
<p>看上述第 3 行代码中的 getBeanFactoryPostProcessors()：是获取自定义的（程序员自己写的，并且没有交给 Spring 管理的，就是没有加上 @Component 注解的）</p>
<p>此时的代码 getBeanFactoryPostProcessors() 运行的结果 size=0。</p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/getBeanFactoryPostProcessors.png" alt="图片" loading="lazy"></figure>
<p>接下来我们看看什么叫做自定义的？</p>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      // 初始化 Spring 的环境
      context.refresh();
      IndexDao indexDao = context.getBean(IndexDaoImpl.class);
      indexDao.query();
      System.out.println(indexDao);
      System.out.println(context.getBean(IndexDaoImpl.class));
   }
}
</code></pre>
<p>因为 bean 默认是单例的，所以两次 context.getBean()获取的是同一个对象</p>
<pre><code class="language-java">dao...模拟查询数据库
com.ssm.dao.impl.IndexDaoImpl@47fd17e3
com.ssm.dao.impl.IndexDaoImpl@47fd17e3
</code></pre>
<p>插手 Bean 的初始化过程，将作用域设置为原型的：</p>
<p>但由于代码未添加 @Component 注解，所以这个类不会生效</p>
<pre><code class="language-java">public class MyBeanFactoryProcessor implements BeanFactoryPostProcessor {
   @Override
   public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
      AnnotatedBeanDefinition annotatedBeanDefinition = (AnnotatedBeanDefinition) beanFactory.getBeanDefinition(&quot;indexDao&quot;);
      annotatedBeanDefinition.setScope(&quot;prototype&quot;);
   }
}
</code></pre>
<p>打印效果：</p>
<pre><code class="language-java">dao...模拟查询数据库
com.ssm.dao.impl.IndexDaoImpl@47fd17e3
com.ssm.dao.impl.IndexDaoImpl@47fd17e3
</code></pre>
<p>在 refresh() 前 context.addBeanFactoryPostProcessor( new MyBeanFactoryProcessor());</p>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      context.addBeanFactoryPostProcessor( new MyBeanFactoryProcessor());
      // 初始化 Spring 的环境
      context.refresh();
      IndexDao indexDao = context.getBean(IndexDaoImpl.class);
      indexDao.query();
      System.out.println(indexDao);
      System.out.println(context.getBean(IndexDaoImpl.class));
   }
}
</code></pre>
<p>即使 MyBeanFactoryProcessor 类并没有添加注解，但是通过 addBeanFactoryPostProcessor 结果显示 IndexDao 对象为原型的了：</p>
<pre><code class="language-java">dao...模拟查询数据库
com.ssm.dao.impl.IndexDaoImpl@47fd17e3
com.ssm.dao.impl.IndexDaoImpl@7cdbc5d3
</code></pre>
<p>结论：<strong>context.addBeanFactoryPostProcessor( new MyBeanFactoryProcessor()); 就称之为自定义的</strong>。<br>
此时 getBeanFactoryPostProcessors() 执行后的结果 size 不为 0 了。</p>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/getBeanFactoryPostProcessors_2.png" alt="图片" loading="lazy"></figure>
<h3 id="352-invokebeanfactorypostprocessorsbeanfactory-getbeanfactorypostprocessors">3.5.2 invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</h3>
<pre><code class="language-java">public static void invokeBeanFactoryPostProcessors(
      ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) {
   // Invoke BeanDefinitionRegistryPostProcessors first, if any.
   Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;();
   if (beanFactory instanceof BeanDefinitionRegistry) {
      BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
      // 定义 List&lt;BeanFactoryPostProcessor&gt;
      List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;();
       // 定义 List&lt;BeanDefinitionRegistryPostProcessor&gt;
      List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;();
      // 遍历 beanFactoryPostProcessors
      for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
         // 判断如果 postProcessor 是 BeanDefinitionRegistryPostProcessor 类型，就添加到 registryProcessors 中
         if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
            BeanDefinitionRegistryPostProcessor registryProcessor =
                  (BeanDefinitionRegistryPostProcessor) postProcessor;
            registryProcessor.postProcessBeanDefinitionRegistry(registry);
            registryProcessors.add(registryProcessor);
         }
         // 否则，添加到 regularPostProcessors中
         else {
            regularPostProcessors.add(postProcessor);
         }
      }
      // Do not initialize FactoryBeans here: We need to leave all regular beans
      // uninitialized to let the bean factory post-processors apply to them!
      // Separate between BeanDefinitionRegistryPostProcessors that implement
      // PriorityOrdered, Ordered, and the rest.
      // 这个 currentRegistryProcessors 放的是 Spring 内部自己实现了 BeanDefinitionRegistryPostProcessor 接口的对象
      List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;();
      // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
      String[] postProcessorNames =
            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
            // 这个地方可以得到一个 BeanFactoryPostProcessor，因为是 Spring 默认在最开始自己注册的
            // 为什么要在最开始注册这个呢？
            // 因为 Spring 的工厂需要注解去扫描等等功能
            // 而这些功能都是需要在 Spring 工厂初始化完成之前就执行
            // 要么在工厂最开始的时候，要么在工厂初始化之中，反正不能在之后
            // 因为如果在之后就没有意义，因为那个时候已经需要使用工厂了
            // 所以这里 Spring 在一开始就注册了一个 BeanFactoryPostProcessor，用来插手 springFactory 的实例化过程
            // 在这个地方断点可以知道这个类叫做 ConfigurationClassPostProcessor
            // ConfigurationClassPostProcessor 那么这个类能干嘛呢？可以参考源码
            // 下面对这个“插手 Spirng 工厂实例化过程”的类重点解释
      for (String ppName : postProcessorNames) {
         if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
         }
      }
      // 排序不重要，况且 currentRegistryProcessor 这里也只有一个数据
      sortPostProcessors(currentRegistryProcessors, beanFactory);
      // 合并 List，不重要（为什么要合并，因为有自定义的Spring自己的）
      registryProcessors.addAll(currentRegistryProcessors);
      // 最重要。注意这里是方法调用
      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
      currentRegistryProcessors.clear();
      // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
      for (String ppName : postProcessorNames) {
         if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
         }
      }
      sortPostProcessors(currentRegistryProcessors, beanFactory);
      registryProcessors.addAll(currentRegistryProcessors);
      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
      currentRegistryProcessors.clear();
      // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
      boolean reiterate = true;
      while (reiterate) {
         reiterate = false;
         postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
         for (String ppName : postProcessorNames) {
            if (!processedBeans.contains(ppName)) {
               currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
               processedBeans.add(ppName);
               reiterate = true;
            }
         }
         sortPostProcessors(currentRegistryProcessors, beanFactory);
         registryProcessors.addAll(currentRegistryProcessors);
         invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
         currentRegistryProcessors.clear();
      }
      // Now, invoke the postProcessBeanFactory callback of all processors handled so far.
      invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
      invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
   }
   else {
      // Invoke factory processors registered with the context instance.
      invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
   }
   // Do not initialize FactoryBeans here: We need to leave all regular beans
   // uninitialized to let the bean factory post-processors apply to them!
   String[] postProcessorNames =
         beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);
   // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
   // Ordered, and the rest.
   List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();
   List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();
   List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();
   for (String ppName : postProcessorNames) {
      if (processedBeans.contains(ppName)) {
         // skip - already processed in first phase above
      }
      else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
         priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
      }
      else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
         orderedPostProcessorNames.add(ppName);
      }
      else {
         nonOrderedPostProcessorNames.add(ppName);
      }
   }
   // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
   invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);
   // Next, invoke the BeanFactoryPostProcessors that implement Ordered.
   List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();
   for (String postProcessorName : orderedPostProcessorNames) {
      orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
   }
   sortPostProcessors(orderedPostProcessors, beanFactory);
   invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);
   // Finally, invoke all other BeanFactoryPostProcessors.
   List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();
   for (String postProcessorName : nonOrderedPostProcessorNames) {
      nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
   }
   invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);
   // Clear cached merged bean definitions since the post-processors might have
   // modified the original metadata, e.g. replacing placeholders in values...
   beanFactory.clearMetadataCache();
}
</code></pre>
<h4 id="3521-listbeanfactorypostprocessor-listbeandefinitionregistrypostprocessor">3.5.2.1  List<BeanFactoryPostProcessor>、List<BeanDefinitionRegistryPostProcessor></h4>
<p>看一下上述 10-12 行：</p>
<pre><code class="language-java">// 定义 List&lt;BeanFactoryPostProcessor&gt;
List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;();
// 定义 List&lt;BeanDefinitionRegistryPostProcessor&gt;
List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;();
</code></pre>
<p>为什么定义两个 List？<br>
自己定义的 BeanFactoryProcessor可以有两种方式：</p>
<p>1.实现 BeanFactoryPostProcessor 接口</p>
<p>2.实现BeanDefinitionRegistryPostProcessor接口</p>
<p>因为 BeanDefinitionRegistryPostProcessor 实现了 BeanFactoryPostProcessor 接口</p>
<p>于是可以猜想实现 bdrp 和实现 bfp 是能够完成不同的功能，</p>
<p>因为 bdrp 是子类，子类肯定扩展了父类中的功能。</p>
<p>父类 BeanFactoryPostProcessor  中有一个 postProcessBeanFactory 方法：</p>
<pre><code class="language-java">@FunctionalInterface
public interface BeanFactoryPostProcessor {
   void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;
}
</code></pre>
<p>子类 BeanDefinitionRegistryPostProcessor  扩展了一个 postProcessBeanDefinitionRegistry() 方法：</p>
<pre><code class="language-java">public interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor {
   void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException;
}
</code></pre>
<h4 id="3522-getbeannamesfortype">3.5.2.2 getBeanNamesForType</h4>
<p>上述 invokeBeanFactoryPostProcessors 方法的第 37-54 行：</p>
<pre><code class="language-java">String[] postProcessorNames =
      beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
for (String ppName : postProcessorNames) {
   if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
      currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
      processedBeans.add(ppName);
   }
}
</code></pre>
<p>getBeanNamesForType：这个方法是 beanFactory 中的方法，顾名思义，这个方法能够得到通过类得到 bean名字，这里的 Type 指的是 bd 当中描述当前类的 Class 类型。<br>
beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false)：获取 Type 为 BeanDefinitionRegistryPostProcessor 对应的 bean 名字。</p>
<p>我们先来查看当前工厂的 map 中有哪些&lt;beanName, beanDefinition&gt;，之前说过在执行 register() 时向容器内添加了 7 个对象，我们看到有一个 BeanClass 为 ConfigurationClassPostProcessor 的类</p>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/ConfigurationClassPostProcessor.png" alt="图片" loading="lazy"></figure>
<p>我们发现 ConfigurationClassPostProcessor 类实现了 BeanDefinitionRegistryPostProcessor 接口：</p>
<pre><code class="language-java">public class ConfigurationClassPostProcessor implements BeanDefinitionRegistryPostProcessor,
      PriorityOrdered, ResourceLoaderAware, BeanClassLoaderAware, EnvironmentAware {
</code></pre>
<p>所以 beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); 就把 ConfigurationClassPostProcessor  类（Spring 内部自己定义的）拿出来了。</p>
<h4 id="3523-invokebeandefinitionregistrypostprocessors">3.5.2.3 invokeBeanDefinitionRegistryPostProcessors</h4>
<p>上述 invokeBeanFactoryPostProcessors 方法的第 60 行：</p>
<pre><code class="language-java">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
</code></pre>
<p>我们点进这个 invokeBeanDefinitionRegistryPostProcessors 方法：</p>
<pre><code class="language-java">private static void invokeBeanDefinitionRegistryPostProcessors(
      Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry) {
   // 循环所有的 BeanDefinitionRegistryPostProcessor
   for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
      postProcessor.postProcessBeanDefinitionRegistry(registry);
   }
}
</code></pre>
<p>上述代码第 5 行点进去：调用 BeanDefinitionRegistryPostProcessor<br>
扩展父类的方法 postProcessBeanDefinitionRegistry()：</p>
<pre><code class="language-java">@Override
public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
   int registryId = System.identityHashCode(registry);
   if (this.registriesPostProcessed.contains(registryId)) {
      throw new IllegalStateException(
            &quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot; + registry);
   }
   if (this.factoriesPostProcessed.contains(registryId)) {
      throw new IllegalStateException(
            &quot;postProcessBeanFactory already called on this post-processor against &quot; + registry);
   }
   this.registriesPostProcessed.add(registryId);
   processConfigBeanDefinitions(registry);
}
</code></pre>
<p>上述代码第 14 行点进去：</p>
<pre><code class="language-java">public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
   // app 提供的 bean
   List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;();
   // 获取容器中注册的所有 bean 名字
   String[] candidateNames = registry.getBeanDefinitionNames();
   // 依次取出每个&lt;beanName,beanDefinition&gt;
   for (String beanName : candidateNames) {
      BeanDefinition beanDef = registry.getBeanDefinition(beanName);
      // 判断当前 bean 是否被处理过：使用 isFullConfigurationClass 来标识
      if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
            ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {
         // 如果 BeanDefinition 中的 configurationClass 属性为 full 或者 lite，则意味着已经处理过了，直接跳过
         // 这里需要结合下面的代码才能理解
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Bean definition has already been processed as a configuration class: &quot; + beanDef);
         }
      }
      // 判断这个 BeanDefinition 是否包含了 @Configuration、@Service 注解
      else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
         configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
      }
   }
   // Return immediately if no @Configuration classes were found
   if (configCandidates.isEmpty()) {
      return;
   }
    
   // 排序，根据 order，不重要
   // Sort by previously determined @Order value, if applicable
   configCandidates.sort((bd1, bd2) -&gt; {
      int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
      int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
      return Integer.compare(i1, i2);
   });
   // Detect any custom bean name generation strategy supplied through the enclosing application context
   SingletonBeanRegistry sbr = null;
   // 如果 BeanDefinitionRegistry 是 SingletonBeanRegistry 子类的话
   // 由于会将 registry 强转为 SingletonBeanRegistry
   if (registry instanceof SingletonBeanRegistry) {
      sbr = (SingletonBeanRegistry) registry;
      if (!this.localBeanNameGeneratorSet) {
         BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);
         // SingletonBeanRegistry 中有 id 为 org.springframework.context.annotation.internalConfigurationBeanNameGenerator
         // 如果有则利用它的，否则则使用 Spring 默认的
         if (generator != null) {
            this.componentScanBeanNameGenerator = generator;
            this.importBeanNameGenerator = generator;
         }
      }
   }
   if (this.environment == null) {
      this.environment = new StandardEnvironment();
   }
   // Parse each @Configuration class
   // 实例化 ConfigurationClassParser 为了解析各个配置类
   ConfigurationClassParser parser = new ConfigurationClassParser(
         this.metadataReaderFactory, this.problemReporter, this.environment,
         this.resourceLoader, this.componentScanBeanNameGenerator, registry);
         
   // 实例化 2 个 set，candidates 用于将之前加入的 configCandidates 进行去重
   // 因为可能有多个配置类重复了
   // alreadyParsed 用户判断是否处理过
   Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates);
   Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size());
   do {
      parser.parse(candidates);
      parser.validate();
      Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());
      configClasses.removeAll(alreadyParsed);
      // Read the model and create bean definitions based on its content
      if (this.reader == null) {
         this.reader = new ConfigurationClassBeanDefinitionReader(
               registry, this.sourceExtractor, this.resourceLoader, this.environment,
               this.importBeanNameGenerator, parser.getImportRegistry());
      }
      // 把扫描出来的 bean 对应的 beanDefinitions 添加到 factory 的 map 当中
      this.reader.loadBeanDefinitions(configClasses);
      alreadyParsed.addAll(configClasses);
      candidates.clear();
      if (registry.getBeanDefinitionCount() &gt; candidateNames.length) {
         String[] newCandidateNames = registry.getBeanDefinitionNames();
         Set&lt;String&gt; oldCandidateNames = new HashSet&lt;&gt;(Arrays.asList(candidateNames));
         Set&lt;String&gt; alreadyParsedClasses = new HashSet&lt;&gt;();
         for (ConfigurationClass configurationClass : alreadyParsed) {
            alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
         }
         for (String candidateName : newCandidateNames) {
            if (!oldCandidateNames.contains(candidateName)) {
               BeanDefinition bd = registry.getBeanDefinition(candidateName);
               if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp;
                     !alreadyParsedClasses.contains(bd.getBeanClassName())) {
                  candidates.add(new BeanDefinitionHolder(bd, candidateName));
               }
            }
         }
         candidateNames = newCandidateNames;
      }
   }
   while (!candidates.isEmpty());
   // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes
   if (sbr != null &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {
      sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
   }
   if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {
      // Clear cache in externally provided MetadataReaderFactory; this is a no-op
      // for a shared cache since it'll be cleared by the ApplicationContext.
      ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();
   }
}
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/candidateNames.png" alt="图片" loading="lazy"></figure>
<p>上述 processConfigBeanDefinitions 方法第 18-21 行：</p>
<pre><code class="language-java">      // 判断这个 BeanDefinition 是否包含了 @Configuration、@Service 注解
      else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
         configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
      }      
</code></pre>
<p>checkConfigurationClassCandidate<br>
先来看上述第二行调用 checkConfigurationClassCandidate 方法判断是否加了 @Configuration 注解，checkConfigurationClassCandidate 方法如下：</p>
<pre><code class="language-java">public static boolean checkConfigurationClassCandidate(BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) {
   String className = beanDef.getBeanClassName();
   if (className == null || beanDef.getFactoryMethodName() != null) {
      return false;
   }
   AnnotationMetadata metadata;
   if (beanDef instanceof AnnotatedBeanDefinition &amp;&amp;
         className.equals(((AnnotatedBeanDefinition) beanDef).getMetadata().getClassName())) {
      // Can reuse the pre-parsed metadata from the given BeanDefinition...
      // 如果 BeanDefinition 是 AnnotatedBeanDefinition 的实例，并且 className 和 BeanDefinition 中的元数据的类名相同
      // 则直接从 BeanDefinition 获得元数据Metadata
      metadata = ((AnnotatedBeanDefinition) beanDef).getMetadata();
   }
   else if (beanDef instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) beanDef).hasBeanClass()) {
      // Check already loaded Class if present...
      // since we possibly can't even load the class file for this Class.
      Class&lt;?&gt; beanClass = ((AbstractBeanDefinition) beanDef).getBeanClass();
      metadata = new StandardAnnotationMetadata(beanClass, true);
   }
   else {
      try {
         MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);
         metadata = metadataReader.getAnnotationMetadata();
      }
      catch (IOException ex) {
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Could not find class file for introspecting configuration annotations: &quot; + className, ex);
         }
         return false;
      }
   }
  
   // 判断当前这个 bd 中存在的类是不是加了 @Configuration 注解
   if (isFullConfigurationCandidate(metadata)) {
      // 如果存在 Configuration 注解，则为 BeanDefinition 设置 configurationClass 属性为 FULL，结合 processConfigBeanDefinitions 方法的第 10 行，使用 isFullConfigurationClass 判断是否处理过
      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);
   }
   // 判断是否加了以下注解，摘录 isLiteConfigurationCandidate 的源码
   // candidateIndicators.add(Component.class.getName());
   // candidateIndicators.add(ComponentScan.class.getName());
   // candidateIndicators.add(Import.class.getName());
   // candidateIndicators.add(ImportResource.class.getName());
   else if (isLiteConfigurationCandidate(metadata)) {
      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
   }
   else {
      return false;
   }
   // It's a full or lite configuration candidate... Let's determine the order value, if any.
   // 得到排序：如果有多个加了 @Configuration 的类，根据 @Order进行排序决定解析顺序
   Integer order = getOrder(metadata);
   if (order != null) {
      beanDef.setAttribute(ORDER_ATTRIBUTE, order);
   }
   return true;
}
</code></pre>
<p>上述代码第 35 行，判断当前这个 bd 中存在的类是不是加了 @Configuration 注解：</p>
<pre><code class="language-java">public static boolean isFullConfigurationCandidate(AnnotationMetadata metadata) {
   return metadata.isAnnotated(Configuration.class.getName());
}
</code></pre>
<p>上述 checkConfigurationClassCandidate 方法第 44-46 行，判断是否加了其他注解</p>
<pre><code class="language-java">// 判断是否加了以下注解，摘录 isLiteConfigurationCandidate 的源码
// candidateIndicators.add(Component.class.getName());
// candidateIndicators.add(ComponentScan.class.getName());
// candidateIndicators.add(Import.class.getName());
// candidateIndicators.add(ImportResource.class.getName());
  else if (isLiteConfigurationCandidate(metadata)) {
      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
  }
</code></pre>
<p>点进 isLiteConfigurationCandidate 方法如下：</p>
<pre><code class="language-java">public static boolean isLiteConfigurationCandidate(AnnotationMetadata metadata) {
   // Do not consider an interface or an annotation...
   if (metadata.isInterface()) {
      return false;
   }
   // Any of the typical annotations found?
   for (String indicator : candidateIndicators) {
      if (metadata.isAnnotated(indicator)) {
         return true;
      }
   }
   // Finally, let's look for @Bean methods...
   try {
      return metadata.hasAnnotatedMethods(Bean.class.getName());
   }
   catch (Throwable ex) {
      if (logger.isDebugEnabled()) {
         logger.debug(&quot;Failed to introspect @Bean methods on class [&quot; + metadata.getClassName() + &quot;]: &quot; + ex);
      }
      return false;
   }
}
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/candidateIndicators.png" alt="图片" loading="lazy"></figure>
<p>processConfigBeanDefinitions 方法的第 62 行：</p>
<pre><code class="language-java">parser.parse(candidates);
</code></pre>
<p>点进这个 parse 方法：</p>
<pre><code class="language-java">public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) {
   this.deferredImportSelectors = new LinkedList&lt;&gt;();
   // 根据 BeanDefinition 的类型做不同的处理，一般都会调用 ConfigurationClassParse#parse 进行解析
   for (BeanDefinitionHolder holder : configCandidates) {
      BeanDefinition bd = holder.getBeanDefinition();
      try {
         // 判断这个 bd 是否被加了注解
         if (bd instanceof AnnotatedBeanDefinition) {
            parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
         }
         else if (bd instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) {
            parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
         }
         else {
            parse(bd.getBeanClassName(), holder.getBeanName());
         }
      }
      catch (BeanDefinitionStoreException ex) {
         throw ex;
      }
      catch (Throwable ex) {
         throw new BeanDefinitionStoreException(
               &quot;Failed to parse configuration class [&quot; + bd.getBeanClassName() + &quot;]&quot;, ex);
      }
   }
   processDeferredImportSelectors();
}
</code></pre>
<p>再点进上述代码第 9 行的 parse 方法：</p>
<pre><code class="language-java">protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {
   processConfigurationClass(new ConfigurationClass(metadata, beanName));
}
</code></pre>
<p>上述代码第二行调用了 processConfigurationClass 方法，点进去：</p>
<pre><code class="language-java">protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
   // 判断是否应该跳过解析
   if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
      return;
   }
   // 处理 Imported 的情况
   ConfigurationClass existingClass = this.configurationClasses.get(configClass);
   if (existingClass != null) {
      if (configClass.isImported()) {
         if (existingClass.isImported()) {
            existingClass.mergeImportedBy(configClass);
         }
         // Otherwise ignore new imported config class; existing non-imported class overrides it.
         return;
      }
      else {
         // Explicit bean definition found, probably replacing an import.
         // Let's remove the old one and go with the new one.
         this.configurationClasses.remove(configClass);
         this.knownSuperclasses.values().removeIf(configClass::equals);
      }
   }
   // Recursively process the configuration class and its superclass hierarchy.
   SourceClass sourceClass = asSourceClass(configClass);
   do {
      sourceClass = doProcessConfigurationClass(configClass, sourceClass);
   }
   while (sourceClass != null);
   
   // 一个 map，用来存放扫描出来的 bean（注意这里的 bean 不是对象，仅仅是 bean 的信息，因为还没到实例化）
   this.configurationClasses.put(configClass, configClass);
}
</code></pre>
<p>doProcessConfigurationClass</p>
<p>看上述第 28 行：</p>
<pre><code class="language-java">sourceClass = doProcessConfigurationClass(configClass, sourceClass);
</code></pre>
<p>点进这个 doProcessConfigurationClass 方法：</p>
<pre><code class="language-java">@Nullable
protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)
      throws IOException {
   // Recursively process any member (nested) classes first
   // 处理内部类
   processMemberClasses(configClass, sourceClass);
   // Process any @PropertySource annotations
   for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
         sourceClass.getMetadata(), PropertySources.class,
         org.springframework.context.annotation.PropertySource.class)) {
      if (this.environment instanceof ConfigurableEnvironment) {
         processPropertySource(propertySource);
      }
      else {
         logger.warn(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() +
               &quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;);
      }
   }
   // Process any @ComponentScan annotations
   Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(
         sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
   if (!componentScans.isEmpty() &amp;&amp;
         !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
      for (AnnotationAttributes componentScan : componentScans) {
         // The config class is annotated with @ComponentScan -&gt; perform the scan immediately
         Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =
               this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
         // Check the set of scanned definitions for any further config classes and parse recursively if needed
         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
            BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
            if (bdCand == null) {
               bdCand = holder.getBeanDefinition();
            }
            if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
               parse(bdCand.getBeanClassName(), holder.getBeanName());
            }
         }
      }
   }
   // Process any @Import annotations
   processImports(configClass, sourceClass, getImports(sourceClass), true);
   // Process any @ImportResource annotations
   AnnotationAttributes importResource =
         AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
   if (importResource != null) {
      String[] resources = importResource.getStringArray(&quot;locations&quot;);
      Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;);
      for (String resource : resources) {
         String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
         configClass.addImportedResource(resolvedResource, readerClass);
      }
   }
   // Process individual @Bean methods
   Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
   for (MethodMetadata methodMetadata : beanMethods) {
      configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
   }
   // Process default methods on interfaces
   processInterfaces(configClass, sourceClass);
   // Process superclass, if any
   if (sourceClass.getMetadata().hasSuperClass()) {
      String superclass = sourceClass.getMetadata().getSuperClassName();
      if (superclass != null &amp;&amp; !superclass.startsWith(&quot;java&quot;) &amp;&amp;
            !this.knownSuperclasses.containsKey(superclass)) {
         this.knownSuperclasses.put(superclass, configClass);
         // Superclass found, return its annotation metadata and recurse
         return sourceClass.getSuperClass();
      }
   }
   // No superclass -&gt; processing is complete
   return null;
}
</code></pre>
<p>上述代码第 23-24 行，获得带有 @ComponentScan 注解的类<br>
<img src="https://epitomm.github.io/post-images/ComponentScan.png" alt="图片" loading="lazy"></p>
<p>上述代码第 30 行：</p>
<pre><code class="language-java">this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
</code></pre>
<p>再点进去这个 parse 方法：真正解析扫描包的</p>
<pre><code class="language-java">public Set&lt;BeanDefinitionHolder&gt; parse(AnnotationAttributes componentScan, final String declaringClass) {
   ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,
         componentScan.getBoolean(&quot;useDefaultFilters&quot;), this.environment, this.resourceLoader);
   
   // 看有没有自定义外部 Bean 生命器
   Class&lt;? extends BeanNameGenerator&gt; generatorClass = componentScan.getClass(&quot;nameGenerator&quot;);
   boolean useInheritedGenerator = (BeanNameGenerator.class == generatorClass);
   scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator :
         BeanUtils.instantiateClass(generatorClass));
   // 判断这个类是不是代理的
   ScopedProxyMode scopedProxyMode = componentScan.getEnum(&quot;scopedProxy&quot;);
   if (scopedProxyMode != ScopedProxyMode.DEFAULT) {
      scanner.setScopedProxyMode(scopedProxyMode);
   }
   else {
      Class&lt;? extends ScopeMetadataResolver&gt; resolverClass = componentScan.getClass(&quot;scopeResolver&quot;);
      scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));
   }
   scanner.setResourcePattern(componentScan.getString(&quot;resourcePattern&quot;));
   for (AnnotationAttributes filter : componentScan.getAnnotationArray(&quot;includeFilters&quot;)) {
      for (TypeFilter typeFilter : typeFiltersFor(filter)) {
         scanner.addIncludeFilter(typeFilter);
      }
   }
   for (AnnotationAttributes filter : componentScan.getAnnotationArray(&quot;excludeFilters&quot;)) {
      for (TypeFilter typeFilter : typeFiltersFor(filter)) {
         scanner.addExcludeFilter(typeFilter);
      }
   }
   boolean lazyInit = componentScan.getBoolean(&quot;lazyInit&quot;);
   if (lazyInit) {
      scanner.getBeanDefinitionDefaults().setLazyInit(true);
   }
   Set&lt;String&gt; basePackages = new LinkedHashSet&lt;&gt;();
   String[] basePackagesArray = componentScan.getStringArray(&quot;basePackages&quot;);
   for (String pkg : basePackagesArray) {
      String[] tokenized = StringUtils.tokenizeToStringArray(this.environment.resolvePlaceholders(pkg),
            ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);
      Collections.addAll(basePackages, tokenized);
   }
   for (Class&lt;?&gt; clazz : componentScan.getClassArray(&quot;basePackageClasses&quot;)) {
      basePackages.add(ClassUtils.getPackageName(clazz));
   }
   if (basePackages.isEmpty()) {
      basePackages.add(ClassUtils.getPackageName(declaringClass));
   }
    
   // 得到 excludeFilter 设置的排除扫描的包
   scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {
      @Override
      protected boolean matchClassName(String className) {
         return declaringClass.equals(className);
      }
   });
   return scanner.doScan(StringUtils.toStringArray(basePackages));
}
</code></pre>
<p>上述代码第 60 行的 doScan 方法：</p>
<pre><code class="language-java">protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) {
   Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;);
   Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;&gt;();
   for (String basePackage : basePackages) {
      // 扫表 basePackage 路径下的 java 文件
      // 并把它转成 BeanDefinition 类型
      Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);
      for (BeanDefinition candidate : candidates) {
         // 解析 scope 属性
         ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
         candidate.setScope(scopeMetadata.getScopeName());
         String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
         if (candidate instanceof AbstractBeanDefinition) {
            // 如果这个类是 AbstractBeanDefinition 的子类
            // 则为它设置默认值，比如 alzy，init destroy
            postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
         }
         if (candidate instanceof AnnotatedBeanDefinition) {
            // 检查并且处理常用的注解
            // 这里的处理主要是指把常用注解的值设置到 AnnotatedBeanDefinition 当中
            // 当前前提是这个类必须是 AnnotatedBeanDefinition 类型的，说白了就是加了注解的类
            AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
         }
         if (checkCandidate(beanName, candidate)) {
            BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
            definitionHolder =
                  AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
            beanDefinitions.add(definitionHolder);
            // 就是在这个方法中，将扫描包的 Bean 添加到 map 中
            registerBeanDefinition(definitionHolder, this.registry);
         }
      }
   }
   return beanDefinitions;
}
</code></pre>
<p>上述代码第 7 行：</p>
<pre><code class="language-java">public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) {
   if (this.componentsIndex != null &amp;&amp; indexSupportsIncludeFilters()) {
      return addCandidateComponentsFromIndex(this.componentsIndex, basePackage);
   }
   else {
      return scanCandidateComponents(basePackage);
   }
}
</code></pre>
<p>上述代码第 6 行：</p>
<pre><code class="language-java">private Set&lt;BeanDefinition&gt; scanCandidateComponents(String basePackage) {
   Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;&gt;();
   try {
      String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
            resolveBasePackage(basePackage) + '/' + this.resourcePattern;
      Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);
      boolean traceEnabled = logger.isTraceEnabled();
      boolean debugEnabled = logger.isDebugEnabled();
      for (Resource resource : resources) {
         if (traceEnabled) {
            logger.trace(&quot;Scanning &quot; + resource);
         }
         if (resource.isReadable()) {
            try {
               MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);
               if (isCandidateComponent(metadataReader)) {
                  ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
                  sbd.setSource(resource);
                  if (isCandidateComponent(sbd)) {
                     if (debugEnabled) {
                        logger.debug(&quot;Identified candidate component class: &quot; + resource);
                     }
                     candidates.add(sbd);
                  }
                  else {
                     if (debugEnabled) {
                        logger.debug(&quot;Ignored because not a concrete top-level class: &quot; + resource);
                     }
                  }
               }
               else {
                  if (traceEnabled) {
                     logger.trace(&quot;Ignored because not matching any filter: &quot; + resource);
                  }
               }
            }
            catch (Throwable ex) {
               throw new BeanDefinitionStoreException(
                     &quot;Failed to read candidate component class: &quot; + resource, ex);
            }
         }
         else {
            if (traceEnabled) {
               logger.trace(&quot;Ignored because not readable: &quot; + resource);
            }
         }
      }
   }
   catch (IOException ex) {
      throw new BeanDefinitionStoreException(&quot;I/O failure during classpath scanning&quot;, ex);
   }
   return candidates;
}
</code></pre>
<p><img src="https://epitomm.github.io/post-images/parse%E5%89%8D.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/parse%E5%90%8E.png" alt="图片" loading="lazy"></p>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/bean%E5%B7%A5%E5%8E%82_3.png" alt="图片" loading="lazy"></figure>
<h1 id="spring-bean-的扩展">Spring Bean 的扩展</h1>
<h2 id="beandefinitionregistrypostprocessor">BeanDefinitionRegistryPostProcessor</h2>
<h1 id="总结">总结</h1>
<pre><code class="language-java">//实例化一个工厂DefaultListableBeanFactory

org.springframework.context.support.GenericApplicationContext-&gt;GenericApplicationContext()

  	1、实例化一个AnnotatedBeanDefinitionReader

	2、ClassPathBeanDefinitionScanner，能够扫描我们bd,能够扫描一个类，并且转换成bd
	
	org.springframework.context.annotation.AnnotationConfigApplicationContext#AnnotationConfigApplicationContext()
	
		委托AnnotationConfigUtils
	
		org.springframework.context.annotation.AnnotatedBeanDefinitionReader#AnnotatedBeanDefinitionReader()


​			

			org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors()


​			

				1、添加AnnotationAwareOrderComparator类的对象，主要去排序
	
				2、ContextAnnotationAutowireCandidateResolver
	
				3、往BeanDefinitionMap注册一个ConfigurationClassPostProcessor?  org.springframework.context.annotation.internalConfigurationAnnotationProcessor
	
					why?因为需要在invokeBeanFactoryPostProcessors
	
					invokeBeanFactoryPostProcessors主要是在spring的beanFactory初始化的过程中去做一些事情，怎么来做这些事情呢？
	
					委托了多个实现了BeanDefinitionRegistryPostProcessor或者BeanFactoryProcessor接口的类来做这些事情,有自定义的也有spring内部的
	
					其中ConfigurationClassPostProcessor就是一个spring内部的BeanDefinitionRegistryPostProcessor
	
					因为如果你不添加这里就没有办法委托ConfigurationClassPostProcessor做一些功能
	
					到底哪些功能？参考下面的注释
	
				4、RequiredAnnotationBeanPostProcessor
	
				.......
	
				org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors()
	
					//往BeanDefinitionMap注册
	
					org.springframework.context.annotation.AnnotationConfigUtils#registerPostProcessor
	
						//准备好bean工厂，实例化对象
	
						org.springframework.context.support.AbstractApplicationContext#refresh
	
						//准备工作包括设置启动时间，是否激活标识位， 初始化属性源(property source)配置
	
							org.springframework.context.support.AbstractApplicationContext#prepareRefresh
	
								//得到beanFactory?因为需要对beanFactory进行设置
	
								org.springframework.context.support.AbstractApplicationContext#obtainFreshBeanFactory
	
									//准备bean工厂
	
									1、添加一个类加载器
	
									2、添加bean表达式解释器，为了能够让我们的beanFactory去解析bean表达式
	
									3、添加一个后置处理器ApplicationContextAwareProcessor
	
									4、添加了自动注入别忽略的列表
	
									5、。。。。。。
	
									6、添加了一个ApplicationListenerDetector后置处理器（自行百度）
	
									org.springframework.context.support.AbstractApplicationContext#prepareBeanFactory
	
										目前没有任何实现
	
										org.springframework.context.support.AbstractApplicationContext#postProcessBeanFactory
	
											1、getBeanFactoryPostProcessors()得到自己定义的（就是程序员自己写的，并且没有交给spring管理，就是没有加上@Component）
	
											2、得到spring内部自己维护的BeanDefinitionRegistryPostProcessor
	
											org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors
	
												//调用这个方法
	
												//循环所有的BeanDefinitionRegistryPostProcessor
	
												//该方法内部postProcessor.postProcessBeanDefinitionRegistry
	
												org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanDefinitionRegistryPostProcessors
	
													//调用扩展方法postProcessBeanDefinitionRegistry
	
													org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry
	
														//拿出的所有bd，然后判断bd时候包含了@Configuration、@Import，@Compent。。。注解
	
														org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions
	
															1、的到bd当中描述的类的元数据（类的信息）
	
															2、判断是不是加了@Configuration   metadata.isAnnotated(Configuration.class.getName())
	
															3、如果加了@Configuration，添加到一个set当中,把这个set传给下面的方法去解析
	
															org.springframework.context.annotation.ConfigurationClassUtils#checkConfigurationClassCandidate
	
															//扫描包


​															

															org.springframework.context.annotation.ConfigurationClassParser#parse(java.util.Set&lt;org.springframework.beans.factory.config.BeanDefinitionHolder&gt;)


​																

																org.springframework.context.annotation.ConfigurationClassParser#parse(org.springframework.core.type.AnnotationMetadata, java.lang.String)
	
																	//就行了一个类型封装
	
																	org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass
	
																	1、处理内部类 一般不会写内部类
	
																	org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass
	
																		//解析扫描的一些基本信息，比如是否过滤，比如是否加入新的包。。。。。
	
																		org.springframework.context.annotation.ComponentScanAnnotationParser#parse
	
																			org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan
	
																			org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#findCandidateComponents
	
																				org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#scanCandidateComponents
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring系列（六）Spring源码解析]]></title>
        <id>https://epitomm.github.io/post/spring-xi-lie-liu-spring-yuan-ma-jie-xi/</id>
        <link href="https://epitomm.github.io/post/spring-xi-lie-liu-spring-yuan-ma-jie-xi/">
        </link>
        <updated>2020-05-06T14:11:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="先来写一个简单的-spring-案例">先来写一个简单的 spring 案例：</h1>
<p>1.准备一个接口和实现类</p>
<pre><code class="language-java">public interface IndexDao {
   void query();
}
</code></pre>
<p>接口实现类添加 @Reposity 表示把这个对象交给 Spring 管理</p>
<pre><code class="language-java">@Repository(&quot;indexDao&quot;)
public class IndexDaoImpl implements IndexDao {

   @Override
   public void query() {
      System.out.println(&quot;dao...模拟查询数据库&quot;);
   }
}
</code></pre>
<p>2.准备一个配置文件类</p>
<pre><code class="language-java">// 表名这是一个配置类
@Configuration
// 扫描包
@ComponentScan(&quot;com.ssm&quot;)
public class AppConfig {
}
</code></pre>
<p>3.准备一个简单的测试类：</p>
<ul>
<li>读取配置文件</li>
<li>通过 getBean(&quot;xxx&quot;) 获得 Bean 对象</li>
<li>调用 Bean 对象的方法</li>
</ul>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.读取配置文件
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext(AppConfig.class);
      // 2.获得 Bean 对象 
      IndexDao indexDao = context.getBean(IndexDao.class);
      // 3.调用方法
      indexDao.query();
   }
}
</code></pre>
<p>4.测试结果</p>
<pre><code>dao...模拟查询数据库
</code></pre>
<h1 id="new-annotationconfigapplicationcontextappconfigclass">new AnnotationConfigApplicationContext(AppConfig.class);</h1>
<p>从测试类 Test 开始看，测试类的第 5 行读取配置文件：</p>
<pre><code class="language-java">AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
</code></pre>
<p>于是点进 AnnotationConfigApplicationContext(AppConfig.class); 构造方法如下：</p>
<pre><code class="language-java">public AnnotationConfigApplicationContext(Class&lt;?&gt;... annotatedClasses) {
   // 这里由于它有父类，故而会先调用父类的构造方法，然后才会调用自己的构造方法
   // 在自己的构造方法中初始一个读取器和扫描器
   this();
   register(annotatedClasses);
   refresh();
}
</code></pre>
<p>AnnotationConfigApplicationContext 有父类：</p>
<pre><code class="language-java">public class AnnotationConfigApplicationContext extends GenericApplicationContext implements AnnotationConfigRegistry {
</code></pre>
<p>分析 AnnotationConfigApplicationContext 的有参 Class&lt;?&gt;... 构造方法，一行行看，先看第 4 行代码：this()：调用本类的构造方法，但是由于 AnnotationConfigApplicationContext  有父类，于是<strong>先调用父类的构造方法</strong>，我们这里先看本类的构造方法。</p>
<h2 id="11-annotationconfigapplicationcontext">1.1 AnnotationConfigApplicationContext()</h2>
<p>第 7 行，创建了一个 AnnotatedBeanDefinitionReader 并赋值给 reader，那这个 reader 是什么呢？</p>
<pre><code class="language-java">public AnnotationConfigApplicationContext() {
   /**
    * 父类的构造方法 super()
    * 创建一个读取注解的 Bean 定义读取器：reader 能读取被加了注解的类
    * 什么是 bean 定义？BeanDefinition
    */
   this.reader = new AnnotatedBeanDefinitionReader(this);
   // 定义扫描器
   this.scanner = new ClassPathBeanDefinitionScanner(this);
}
</code></pre>
<h3 id="111-annotatedbeandefinitionreader">1.1.1 AnnotatedBeanDefinitionReader</h3>
<p>reader 是一个 AnnotatedBeanDefinitionReader 类型的变量，顾名思义，reader 是一个读取器，并且 AnnotatedBeanDefinitionReader 是一个用来读取 “被加了注解的 BeanDefinition” 的读取器。那么 BeanDefinition 又是什么呢？</p>
<pre><code class="language-java">/**
 * 这个类顾名思义是一个 reader  读取器
 * 读取什么呢？顾名思义读取 AnnotatedBeanDefinition，意思是读取一个被加了注解的 bean
 * 这个类是构造方法中被实例化的
 */
private final AnnotatedBeanDefinitionReader reader;
</code></pre>
<p>从代码中也能看出：AnnotatedBeanDefinition（被注解的 BeanDefinition）继承了 BeanDefinition：</p>
<pre><code class="language-java">public interface AnnotatedBeanDefinition extends BeanDefinition {
</code></pre>
<h4 id="1111-beandefinition">1.1.1.1 BeanDefinition</h4>
<p>BeanDefinition描述了一个bean实例，它具有属性值，构造函数参数值以及具体实现所提供的更多信息。</p>
<pre><code class="language-java">// Spring 当中用来描述 Bean 的一个接口
public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement {
</code></pre>
<p>我们可以想象这样一个需求：有一个 Java 类 User</p>
<pre><code class="language-java">User{
  private String name;
  public void study(){
    
  }
}
</code></pre>
<p>Java 中一切皆对象，一个 User 类也是一个对象，定义一个什么类来描述 User 类对象呢？</p>
<p>答案就是 Class 类</p>
<pre><code class="language-java">Class{
  name;        // 全限定类名
  SimpleName;  // User类名
  Methods[];   // 类中的所有方法
  Fields[];    // 类中的所有属性
  
  // 方法...
  public Method[] getMethods(){
    
  }
  public String getName(){
    
  }
}
</code></pre>
<p>Java 中的类使用 Class 来描述；<strong>Spring 中的 Bean 使用 BeanDefinition 来描述</strong>。</p>
<h4 id="1112-bean-的四种体现方法">1.1.1.2 Bean 的四种体现方法：</h4>
<ul>
<li>@Annotation
<ul>
<li>给一个类添加 @Component、@Service、@Repository 注解，就代表把该类交给 Spring 管理，Spring 就会创建一个 Bean。</li>
</ul>
</li>
</ul>
<pre><code class="language-java">@Repository
public class IndexDaoImpl implements IndexDao{
</code></pre>
<ul>
<li>xml
<ul>
<li>使用 <bean> 标签同样声明一个 Bean</li>
</ul>
</li>
</ul>
<pre><code class="language-xml">&lt;bean id=&quot;dao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot; /&gt;
</code></pre>
<ul>
<li>@Bean
<ul>
<li>使用@Bean 注解也能声明一个 Bean</li>
</ul>
</li>
</ul>
<pre><code class="language-java">@Bean
public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){
    SqlSessionFactoryBean sqlSessionFactoryBean =  new SqlSessionFactoryBean();
    sqlSessionFactoryBean.setDataSource(dataSource);
    return sqlSessionFactoryBean;
}
</code></pre>
<ul>
<li>Spring 内部提供的 bean，因为自定义的 bean 是 Spring 扫描，然后把它放到容器中的，Spring 也会开发自己的 bean，不扫描也把它放到容器当中去。</li>
</ul>
<p>继续来看 AnnotationConfigApplicationContext 的这个带参 Class&lt;?&gt;... 构造方法，下面来看第 6 行，调用了 register 方法，并传参 annotatedClasses，在这个 Test 测试类中，这个 annotatedClasses 就是 AppConfig.class</p>
<pre><code class="language-java">// annotatedClasses 在这里代表 AppConfig.class：存放了配置信息
register(annotatedClasses);
</code></pre>
<h2 id="12-registerclass-annotatedclasses">1.2 register(Class&lt;?&gt;... annotatedClasses)</h2>
<p>接下来点进这个 register(annotatedClasses); 方法，这里的主要代码就是第 20 行：this.reader.register(annotatedClasses); 调用 reader（前面通过 new AnnotatedBeanDefinitionReader(this); 初始化过了） 的 register方法</p>
<pre><code class="language-java">/**
 * 注册一个或多个要处理的带注解的类。
 *     比如有新加的类可以用这个方法，但是注册之后需要手动调用 refresh() 方法去触发容器解析注解。
 *
 *   有两个意思：
 *     它可以注册一个配置类：AnnotationConfigApplicationContext context =
 *     new AnnotationConfigApplicationContext(AppConfig.class);
 *     它还可以单独注册一个 bean：context.register(IndexService.class);
 *
 * &lt;p&gt;请注意，必须调用{@link #refresh（）}才能使上下文完全处理新类
 * to fully process the new classes.
 * @param annotatedClasses 一个或多个带注解的类,
 * e.g. {@link Configuration @Configuration} classes
 * @see #scan(String...)
 * @see #refresh()
 */
public void register(Class&lt;?&gt;... annotatedClasses) {
   Assert.notEmpty(annotatedClasses, &quot;At least one annotated class must be specified&quot;);
   // 在this()构造方法中初始化了 reader，就是为了在这里调用
   this.reader.register(annotatedClasses);
}
</code></pre>
<p><strong>register(Class&lt;?&gt;... annotatedClasses)</strong></p>
<p>于是我们点进去 reader.register(annotatedClasses); 发现这个 register 就是一个空壳方法，它有调用了 registerBean(annotatedClass); 这个方法。</p>
<pre><code class="language-java">/**
 * 这是一个空壳方法
 *
 * Register one or more annotated classes to be processed.
 * &lt;p&gt;Calls to {@code register} are idempotent; adding the same
 * annotated class more than once has no additional effect.
 * @param annotatedClasses one or more annotated classes,
 * e.g. {@link Configuration @Configuration} classes
 */
public void register(Class&lt;?&gt;... annotatedClasses) {
   for (Class&lt;?&gt; annotatedClass : annotatedClasses) {
      registerBean(annotatedClass);
   }
}
</code></pre>
<p><strong>registerBean</strong></p>
<p>继续点进去 registerBean(annotatedClass);我们发现这个方法又调用了 doRegisterBean(annotatedClass, null, name, qualifiers); 这个方法，继续点进去</p>
<pre><code class="language-java">/**
 * Register a bean from the given bean class, deriving its metadata from
 * class-declared annotations.
 * @param annotatedClass the class of the bean
 * @param name an explicit name for the bean
 * @param qualifiers specific qualifier annotations to consider,
 * in addition to qualifiers at the bean class level
 */
@SuppressWarnings(&quot;unchecked&quot;)
public void registerBean(Class&lt;?&gt; annotatedClass, String name, Class&lt;? extends Annotation&gt;... qualifiers) {
   doRegisterBean(annotatedClass, null, name, qualifiers);
}
</code></pre>
<h3 id="121-doregisterbean">1.2.1 doRegisterBean</h3>
<p>当传参一个单独的 Bean 时： AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(IndexDao.class);</p>
<pre><code class="language-java">&lt;T&gt; void doRegisterBean(Class&lt;T&gt; annotatedClass, @Nullable Supplier&lt;T&gt; instanceSupplier, @Nullable String name,
      @Nullable Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers) {

   /**
    *
    * AnnotatedGenericBeanDefinition：被注解的 BeanDefinition(描述Bean)
    * 将 bean 放入 map 中，bean 的 name 是 map 的 key，
    * map 中的 value 为 AnnotatedGenericBeanDefinition 对象
    */
    // 因为 register 中传递过来的参数是带注解的 Bean，即此类的参数 annotatedClass，所以此处使用 AnnotatedGenericBeanDefinition（被注解的BeanDefinition）
   AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass);
   /**
     * 判断这个类是否需要跳过解析
     * 通过代码可以知道 Spring 判断是否跳过解析，主要判断有没有加注解
     */
    // 这个类如果没有加注解，就不需要解析。因为 AnnotatedGenericBeanDefinition 是为了注册被加了注解的；
    // 如果这个类没有被加注解，就跳过不解析
   if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) {
      return;
   }

   abd.setInstanceSupplier(instanceSupplier);
   /**
    * 得到类的作用域
    *     如果是 context.register(SpringConfig.class);则作用域没有什么作用
    *     注册单个类时需要，比如：context.register(IndexService.class);
    */
   ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);
   /**
    * 将类的作用域添加到数据结构中
    * 如果参数为一个Bean，而不是 AppConfig.class 如 new AnnotationConfigApplicationContext(IndexDao.class); 将Bean 内容解析出来放到 AnnotatedGenericBeanDefinition 中
    */
   abd.setScope(scopeMetadata.getScopeName());
   /**
    * 生成类的名字通过 beanNameGenerator
    */
   String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));

   /**
    * 处理类当中的其他通用注解
    * 分析源码可以知道它主要处理：Lazy、DependsOn、Primary、Role 等注解
    * 处理完成之后 processCommonDefinitionAnnotation 中依然是把它添加到数据结构 AnnotatedGenericBeanDefinition 当中
    */
   AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
   /**
     * 如果在向容器注册注解 @Bean定义时，使用了额外的限定符注解则解析
     * 关于 Qualifier 和 Primary 主要涉及到 Spring 的自动装配
     * 这里需要注意的
     *     beanName 和 qualifier 这个变量时 Annotation 类型的数组，里面不仅仅是 Qualifier 注解
     *     理论上里面存的是一切注解，所以可以看到下面的代码 Spring 去循环了这个数组
     *     然后依次判断注解当中是否包含了 Primary，是否包含了 Lazy
     */
   if (qualifiers != null) {
      for (Class&lt;? extends Annotation&gt; qualifier : qualifiers) {
         if (Primary.class == qualifier) {
            abd.setPrimary(true);
         }
         else if (Lazy.class == qualifier) {
            abd.setLazyInit(true);
         }
         else {
            abd.addQualifier(new AutowireCandidateQualifier(qualifier));
         }
      }
   }
   for (BeanDefinitionCustomizer customizer : definitionCustomizers) {
      customizer.customize(abd);
   }
    /**
     * 这个 BeanDefinitionHolder 也是一个数据结构
     * BeanDefinitionHolder 是一个 map，里面放了一个 (BeanDefinition，beanName)
     */
   BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);
   definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
   /**
     * 把上述的这个数据结构注册给 registry
     * registry 就是 AnnotationConfigApplicationContext
     * AnnotationConfigApplicationContext 在初始化的时候通过调用父类的构造方法实例化了一个 DefaultListableBeanFactory
     * registerBeanDefinition 里面就是把 definitionHolder 这个数据结构包含的信息注册到 DefaultListableBeanFactory 这个工厂
     */
   BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
}
</code></pre>
<p>上述 deRegisterBean 方法的第 28-33 行，</p>
<pre><code class="language-java">/**
 * 得到类的作用域
 *     如果是 context.register(SpringConfig.class);则作用域没有什么作用
 *     注册单个类时需要，比如：context.register(IndexService.class);
 */
ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);
/**
 * 将类的作用域添加到数据结构中
 */
abd.setScope(scopeMetadata.getScopeName());
</code></pre>
<p>获取 Bean 的作用域并添加到 adb 中：</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E8%8E%B7%E5%8F%96bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%B9%B6%E6%B7%BB%E5%8A%A0%E5%88%B0adb%E4%B8%AD.png" alt="图片" loading="lazy"></figure>
<h4 id="1211-processcommondefinitionannotations">1.2.1.1 processCommonDefinitionAnnotations</h4>
<p>上述 deRegisterBean 方法的第 44 行，调用了 processCommonDefinitionAnnotations 方法，</p>
<pre><code class="language-java">/**
 * 处理类当中的其他通用注解
 * 分析源码可以知道它主要处理：Lazy、DependsOn、Primary、Role 等注解
 * 处理完成之后 processCommonDefinitionAnnotation 中依然是把它添加到数据结构 AnnotatedGenericBeanDefinition 当中
 */
AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
</code></pre>
<p>点进去，又调用了 processCommonDefinitionAnnotations 的重载方法：</p>
<pre><code class="language-java">public static void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd) {
   // 通过 abd.getMetadata() 获取元数据：@Scope、@DependsOn、@Qualifier、@Primary
   processCommonDefinitionAnnotations(abd, abd.getMetadata());
}
</code></pre>
<p>通过 processCommonDefinitionAnnotations 方法解析元数据</p>
<pre><code class="language-java">static void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata) {
   AnnotationAttributes lazy = attributesFor(metadata, Lazy.class);
   // 如果 lazy 不为空
   if (lazy != null) {
      // 把 lazy 的值拿出来，放到 abd(描述 Bean 对象的) 里面去
      abd.setLazyInit(lazy.getBoolean(&quot;value&quot;));
   }
   else if (abd.getMetadata() != metadata) {
      lazy = attributesFor(abd.getMetadata(), Lazy.class);
      if (lazy != null) {
         abd.setLazyInit(lazy.getBoolean(&quot;value&quot;));
      }
   }
   
   // 判断是否有@Primary注解，如果有，放到 abd(描述 Bean 对象的) 里面去
   if (metadata.isAnnotated(Primary.class.getName())) {
      abd.setPrimary(true);
   }
   // 判断是否有@DependsOn注解，如果有，放到 abd(描述 Bean 对象的) 里面去
   AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);
   if (dependsOn != null) {
      abd.setDependsOn(dependsOn.getStringArray(&quot;value&quot;));
   }

   if (abd instanceof AbstractBeanDefinition) {
      AbstractBeanDefinition absBd = (AbstractBeanDefinition) abd;
      // 判断是否有@Role注解，如果有，放到 abd(描述 Bean 对象的) 里面去
      AnnotationAttributes role = attributesFor(metadata, Role.class);
      if (role != null) {
         absBd.setRole(role.getNumber(&quot;value&quot;).intValue());
      }
      // 判断是否有@Description注解，如果有，放到 abd(描述 Bean 对象的) 里面去
      AnnotationAttributes description = attributesFor(metadata, Description.class);
      if (description != null) {
         absBd.setDescription(description.getString(&quot;value&quot;));
      }
   }
}
</code></pre>
<h4 id="1212-beandefinitionholder">1.2.1.2 BeanDefinitionHolder</h4>
<p>上述 doRegisterBean 方法的73-74 行，定义了一个 BeanDefinitionHolder，BeanDefinitionHolder 类似一个 map，里面放了一个 (BeanDefinition，beanName)</p>
<pre><code class="language-java">/**
 * 这个 BeanDefinitionHolder 也是一个数据结构
 * BeanDefinitionHolder 类似一个 map，里面放了一个 (BeanDefinition，beanName)
 */
BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);
definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
</code></pre>
<p>顾名思义，BeanDefinitionRegistry 是用来注册 BeanDefinition（Bean的定义）的：</p>
<pre><code class="language-java">//用来注册Bean的定义 BeanDefinition
private final BeanDefinitionRegistry registry;
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/BeanDefinitionRegistry.png" alt="图片" loading="lazy"></figure>
<p>BeanDefinitionRegistry：将 BeanDifinition 放到 Spring 容器中</p>
<p>点进去 registerBeanDefinition 这个方法，发现就是拿出 BeanDefinitionHolder 中的 BeanName 和 BeanDefinition，并把它注册到 registry 中：</p>
<pre><code class="language-java">public static void registerBeanDefinition(
      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
      throws BeanDefinitionStoreException {

   // 拿出 BeanDefinitionHolder 中的 BeanName 和 BeanDefinition 
   String beanName = definitionHolder.getBeanName();
   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

   // 注册bean名称的别名（如果有）。
   String[] aliases = definitionHolder.getAliases();
   if (aliases != null) {
      for (String alias : aliases) {
         registry.registerAlias(beanName, alias);
      }
   }
}
</code></pre>
<p>我们看第 7 行，真正的将 BeanName 和 BeanDefinition 注册到 registry 中，</p>
<pre><code class="language-java">registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
</code></pre>
<p>点进去 registerBeanDefinition 方法：</p>
<h4 id="1213-registerbeandefinition">1.2.1.3 registerBeanDefinition</h4>
<p>上述 deRegisterBean 方法的第 81 行，把 <strong>BeanDefinitionHolder</strong>注册给 registry：</p>
<pre><code class="language-java">/**
 * 把上述的这个数据结构注册给 registry
 * registry 就是 AnnotationConfigApplicationContext
 * AnnotationConfigApplicationContext 在初始化的时候通过调用父类的构造方法实例化了一个 DefaultListableBeanFactory
 * registerBeanDefinition 里面就是把 definitionHolder 这个数据结构包含的信息注册到 DefaultListableBeanFactory 这个工厂
 */
BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
</code></pre>
<p>点进 registerBeanDefinition 方法代码如下：</p>
<pre><code class="language-java">public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
      throws BeanDefinitionStoreException {

   this.beanFactory.registerBeanDefinition(beanName, beanDefinition);
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/beanDefinitionMap_put.png" alt="图片" loading="lazy"></figure>
<p>this.beanDefinitionMap.put(beanName, beanDefinition);</p>
<p>点进 registerBeanDefinition 方法如下，主要操作是：将 (beanName,beanDefiniton)放到map中，将 beanName 加入到 list 中：</p>
<pre><code class="language-java">public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
      throws BeanDefinitionStoreException {

   Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);
   Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);

   if (beanDefinition instanceof AbstractBeanDefinition) {
      try {
         ((AbstractBeanDefinition) beanDefinition).validate();
      }
      catch (BeanDefinitionValidationException ex) {
         throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
               &quot;Validation of bean definition failed&quot;, ex);
      }
   }

   BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
   if (existingDefinition != null) {
      if (!isAllowBeanDefinitionOverriding()) {
         throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
               &quot;Cannot register bean definition [&quot; + beanDefinition + &quot;] for bean '&quot; + beanName +
               &quot;': There is already [&quot; + existingDefinition + &quot;] bound.&quot;);
      }
      else if (existingDefinition.getRole() &lt; beanDefinition.getRole()) {
         // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
         if (logger.isWarnEnabled()) {
            logger.warn(&quot;Overriding user-defined bean definition for bean '&quot; + beanName +
                  &quot;' with a framework-generated bean definition: replacing [&quot; +
                  existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;);
         }
      }
      else if (!beanDefinition.equals(existingDefinition)) {
         if (logger.isInfoEnabled()) {
            logger.info(&quot;Overriding bean definition for bean '&quot; + beanName +
                  &quot;' with a different definition: replacing [&quot; + existingDefinition +
                  &quot;] with [&quot; + beanDefinition + &quot;]&quot;);
         }
      }
      else {
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Overriding bean definition for bean '&quot; + beanName +
                  &quot;' with an equivalent definition: replacing [&quot; + existingDefinition +
                  &quot;] with [&quot; + beanDefinition + &quot;]&quot;);
         }
      }
      this.beanDefinitionMap.put(beanName, beanDefinition);
   }
   else {
      if (hasBeanCreationStarted()) {
         // Cannot modify startup-time collection elements anymore (for stable iteration)
         synchronized (this.beanDefinitionMap) {
            // DefaultListableBeanFactory.beanDefinitionMap.put(beanName, beanDefinition)
            this.beanDefinitionMap.put(beanName, beanDefinition);
            List&lt;String&gt; updatedDefinitions = new ArrayList&lt;&gt;(this.beanDefinitionNames.size() + 1);
            updatedDefinitions.addAll(this.beanDefinitionNames);
            updatedDefinitions.add(beanName);
            this.beanDefinitionNames = updatedDefinitions;
            if (this.manualSingletonNames.contains(beanName)) {
               Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;&gt;(this.manualSingletonNames);
               updatedSingletons.remove(beanName);
               this.manualSingletonNames = updatedSingletons;
            }
         }
      }
      else {
         // 将 (beanName,beanDefiniton)放到map中
         this.beanDefinitionMap.put(beanName, beanDefinition);
         // 将 beanName 加入到 list 中
         this.beanDefinitionNames.add(beanName);
         this.manualSingletonNames.remove(beanName);
      }
      this.frozenBeanDefinitionNames = null;
   }

   if (existingDefinition != null || containsSingleton(beanName)) {
      resetBeanDefinition(beanName);
   }
   else if (isConfigurationFrozen()) {
      clearByTypeCache();
   }
}
</code></pre>
<p>beanDefinitionNames 是一个 List 集合，将 Bean 定义的名字添加到这个 List 集合中：</p>
<pre><code class="language-java">/** List of bean definition names, in registration order */
private volatile List&lt;String&gt; beanDefinitionNames = new ArrayList&lt;&gt;(256);
</code></pre>
<p>上述第 67 行代码执行完毕</p>
<pre><code class="language-java">this.beanDefinitionMap.put(beanName, beanDefinition);
</code></pre>
<p>map 中添加了 7 个对象，一个是自定义的 indexDao，其余 6 个是 Spring 在启动过程中自动添加的</p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/map%E6%B7%BB%E5%8A%A07%E4%B8%AA%E5%AF%B9%E8%B1%A1.png" alt="图片" loading="lazy"></figure>
<h2 id="13-refresh">1.3 refresh()</h2>
<ul>
<li>初始化 Spring 的环境</li>
</ul>
<pre><code class="language-java">public void refresh() throws BeansException, IllegalStateException {
   synchronized (this.startupShutdownMonitor) {
      // Prepare this context for refreshing.
      // 准备工作包括设置启动时间、是否激活标识位，初始化属性源（property source）配置（这里不属于 Bean 的生命周期内）
      prepareRefresh();

      // Tell the subclass to refresh the internal bean factory.
      // 获取 DefaultListableBeanFactory
      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

      // Prepare the bean factory for use in this context.
      prepareBeanFactory(beanFactory);

      try {
         // Allows post-processing of the bean factory in context subclasses.
         postProcessBeanFactory(beanFactory);

         // Invoke factory processors registered as beans in the context.
         invokeBeanFactoryPostProcessors(beanFactory);

         // Register bean processors that intercept bean creation.
         registerBeanPostProcessors(beanFactory);

         // Initialize message source for this context.
         initMessageSource();

         // Initialize event multicaster for this context.
         initApplicationEventMulticaster();

         // Initialize other special beans in specific context subclasses.
         onRefresh();

         // Check for listener beans and register them.
         registerListeners();

         // Instantiate all remaining (non-lazy-init) singletons.
         finishBeanFactoryInitialization(beanFactory);

         // Last step: publish corresponding event.
         finishRefresh();
      }

      catch (BeansException ex) {
         if (logger.isWarnEnabled()) {
            logger.warn(&quot;Exception encountered during context initialization - &quot; +
                  &quot;cancelling refresh attempt: &quot; + ex);
         }

         // Destroy already created singletons to avoid dangling resources.
         destroyBeans();

         // Reset 'active' flag.
         cancelRefresh(ex);

         // Propagate exception to caller.
         throw ex;
      }

      finally {
         // Reset common introspection caches in Spring's core, since we
         // might not ever need metadata for singleton beans anymore...
         resetCommonCaches();
      }
   }
}
</code></pre>
<p>先看上述 refresh() 的第 5 行，调用了 prepareRefresh() 方法：</p>
<pre><code class="language-java">// 准备工作包括设置启动时间、是否激活标识位，初始化属性源（property source）配置（这里不属于 Bean 的生命周期内）
prepareRefresh();
</code></pre>
<h3 id="131-preparerefresh">1.3.1 prepareRefresh()</h3>
<pre><code class="language-java">protected void prepareRefresh() {
   // Switch to active.
   this.startupDate = System.currentTimeMillis();
   this.closed.set(false);
   this.active.set(true);

   if (logger.isInfoEnabled()) {
      logger.info(&quot;Refreshing &quot; + this);
   }

   // Initialize any placeholder property sources in the context environment.
   // 这个方法目前没有子类去实现
   // 估计 Spring 是期待后面的版本有子类去实现吧
   initPropertySources();

   // Validate that all properties marked as required are resolvable:
   // see ConfigurablePropertyResolver#setRequiredProperties
   // 获取 .properties 文件或者 @Profile 环境
   getEnvironment().validateRequiredProperties();

   // Store pre-refresh ApplicationListeners...
   if (this.earlyApplicationListeners == null) {
      this.earlyApplicationListeners = new LinkedHashSet&lt;&gt;(this.applicationListeners);
   }
   else {
      // Reset local application listeners to pre-refresh state.
      this.applicationListeners.clear();
      this.applicationListeners.addAll(this.earlyApplicationListeners);
   }

   // Allow for the collection of early ApplicationEvents,
   // to be published once the multicaster is available...
   this.earlyApplicationEvents = new LinkedHashSet&lt;&gt;();
}
</code></pre>
<p>看 prepareRefresh() 方法的第 14 行，调用了 initPropertySources()，这个方法目前没有子类去实现估计 Spring 是期待后面的版本有子类去实现吧：</p>
<pre><code class="language-java">protected void initPropertySources() {
   // For subclasses: do nothing by default.
}```
再来看 refresh() 的第 9 行
```java
// 告诉子类 refresh 内部 Bean工厂
ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
</code></pre>
<h3 id="132-obtainfreshbeanfactory">1.3.2 obtainFreshBeanFactory()</h3>
<pre><code class="language-java">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
   refreshBeanFactory();
   ConfigurableListableBeanFactory beanFactory = getBeanFactory();
   if (logger.isDebugEnabled()) {
      logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);
   }
   return beanFactory;
}
</code></pre>
<p>看 obtainFreshBeanFactory() 方法的第 3 行：</p>
<pre><code class="language-java">ConfigurableListableBeanFactory beanFactory = getBeanFactory();
</code></pre>
<h4 id="1321-getbeanfactory">1.3.2.1 getBeanFactory()</h4>
<p>返回 DefaultListableBeanFactory</p>
<pre><code class="language-java">public final ConfigurableListableBeanFactory getBeanFactory() {
   return this.beanFactory;
}
</code></pre>
<p>beanFactory 是 DefaultListableBeanFactory  类型变量：</p>
<pre><code class="language-java">/** Bean factory for this context */
private final DefaultListableBeanFactory beanFactory;
</code></pre>
<p>再看 refresh() 的第 19 行：</p>
<pre><code class="language-java">// Invoke factory processors registered as beans in the context.
// 调用在上下文中注册为bean的工厂处理器。
invokeBeanFactoryPostProcessors(beanFactory);
</code></pre>
<p>我们点进这个 invokeBeanFactoryPostProcessors(beanFactory); 方法看：</p>
<h3 id="133-invokebeanfactorypostprocessors">1.3.3 invokeBeanFactoryPostProcessors</h3>
<pre><code class="language-java">/**
  * 实例化并调用所有已注册的BeanFactoryPostProcessor Bean，
  * 遵循显式顺序（如果给定的话）。 
  * 必须在单例实例化之前调用。
  */
protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());

   // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
   // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
   if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
   }
}
</code></pre>
<p>我们看上述 invokeBeanFactoryPostProcessors 方法中的第 7 行代码：</p>
<pre><code class="language-java">PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
</code></pre>
<p>这个 invokeBeanFactoryPostProcessors 方法是非常重要的，也就是上面说的产生 7 个对象的过程，就是此段代码内实现的</p>
<h1 id="spring-bean-的扩展有哪些">Spring Bean 的扩展有哪些</h1>
<h2 id="aop">AOP</h2>
<p>IndexDao 配置了 AOP，AOP 与 IndexDao 没有任何耦合</p>
<p>AOP 通过 @AspectJ 配置通知、切点，与 IndexDao 没有任何耦合，那 AOP 是如何将 IndexDao 变成代理的呢？ ——Spring  Bean 的扩展（想让它成为 IndexDao，就成为 IndexDao；想让它成为代理类，就成为代理类）</p>
<h2 id="beanpostprocessor">BeanPostProcessor</h2>
<ul>
<li>Bean 后置处理器</li>
<li>BeanPostProcessor 接口，能够扩展 Spring</li>
<li>所有 BeanPostProcessor 接口的实现类，本质上都是通过 BeanPostProcessor 进行扩展，属于Spring 扩展的一种方式</li>
</ul>
<pre><code class="language-java">@Repository(&quot;indexDao&quot;)
public class IndexDaoImpl implements IndexDao {

   public IndexDaoImpl(){
      System.out.println(&quot;indexDao...constructor&quot;);
   }

   @PostConstruct
   public void init(){
      System.out.println(&quot;indexDao...init&quot;);
   }

   @Override
   public void query() {
      System.out.println(&quot;dao...模拟查询数据库&quot;);
   }
}
</code></pre>
<p>插手 Bean 的构建过程，将 Bean 变为代理对象并返回：</p>
<pre><code class="language-java">@Component
public class TestBeanPostProcessor implements BeanPostProcessor {
   @Override
   public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
      if(beanName.equals(&quot;indexDao&quot;)){
         System.out.println(&quot;BeforeInitialization...&quot;);
      }
      // 返回一个代理对象出去
//    Proxy.newProxyInstance()
      return bean;
   }

   @Override
   public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
      if(beanName.equals(&quot;indexDao&quot;)){
         System.out.println(&quot;AfterInitialization...&quot;);
      }
      return bean;
   }
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-java">indexDao...constructor
BeforeInitialization...
indexDao...init
AfterInitialization...
dao...模拟查询数据库
</code></pre>
<h3 id="如何控制多个后置处理器的顺序">如何控制多个后置处理器的顺序：</h3>
<ul>
<li>后置处理器实现 PriorityOrdered 接口，重写 getOrder() 方法，值越小就越先执行</li>
</ul>
<pre><code class="language-java">@Component
public class TestBeanPostProcessor implements BeanPostProcessor, PriorityOrdered {
   @Override
   public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
      if(beanName.equals(&quot;indexDao&quot;)){
         System.out.println(&quot;BeforeInitialization...&quot;);
      }
      // 返回一个代理对象出去
//    Proxy.newProxyInstance()
      return bean;
   }

   @Override
   public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
      if(beanName.equals(&quot;indexDao&quot;)){
         System.out.println(&quot;AfterInitialization...&quot;);
      }
      return bean;
   }

   @Override
   public int getOrder() {
      return 102;
   }
}
</code></pre>
<p>第二个后置处理器的定义，同样实现 PriorityOrdered 接口，重写 getOrder() 方法：</p>
<pre><code class="language-java">@Component
public class TestBeanPostProcessor2 implements BeanPostProcessor, PriorityOrdered {
   @Override
   public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
      if(beanName.equals(&quot;indexDao&quot;)){
         System.out.println(&quot;BeforeInitialization2...&quot;);
      }
      // 返回一个代理对象出去
//    Proxy.newProxyInstance()
      return bean;
   }

   @Override
   public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
      if(beanName.equals(&quot;indexDao&quot;)){
         System.out.println(&quot;AfterInitialization2...&quot;);
      }
      return bean;
   }

   @Override
   public int getOrder() {
      return 100;
   }
}
</code></pre>
<p>执行结果：</p>
<pre><code>indexDao...constructor
BeforeInitialization2...
BeforeInitialization...
indexDao...init
AfterInitialization2...
AfterInitialization...
dao...模拟查询数据库
</code></pre>
<h2 id="beanfactorypostprocessor">BeanFactoryPostProcessor</h2>
<p>Spring 工厂后置处理器</p>
<h2 id="beandefinitionregistrypostprocessor">BeanDefinitionRegistryPostProcessor</h2>
<h3 id="134-preparebeanfactorybeanfactory">1.3.4 prepareBeanFactory(beanFactory)</h3>
<p>再来看 refresh() 的第 12 行： prepareBeanFactory(beanFactory);</p>
<pre><code>// Prepare the bean factory for use in this context.
prepareBeanFactory(beanFactory);
</code></pre>
<p>点进去 prepareBeanFactory(beanFactory) 代码如下：</p>
<pre><code class="language-java">protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
   // Tell the internal bean factory to use the context's class loader etc.
   beanFactory.setBeanClassLoader(getClassLoader());
   // bean 表达式解析器
   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
   // 注册属性编辑器
   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));

   // Configure the bean factory with context callbacks.
   // 使用上下文回调配置Bean工厂。
   // 向 List 里面添加一个数据：添加一个后置管理器：ApplicationContextAwareProcessor 实现了 BeanPostProcessor接口：插手 Bean 的创建过程
   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);

   // BeanFactory interface not registered as resolvable type in a plain factory.
   // MessageSource registered (and found for autowiring) as a bean.
   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
   beanFactory.registerResolvableDependency(ResourceLoader.class, this);
   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
   beanFactory.registerResolvableDependency(ApplicationContext.class, this);

   // Register early post-processor for detecting inner beans as ApplicationListeners.
   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));

   // Detect a LoadTimeWeaver and prepare for weaving, if found.
   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
      // Set a temporary ClassLoader for type matching.
      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
   }

   // Register default environment beans.
   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
   }
   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
   }
   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
   }
}
</code></pre>
<p>看 prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) 的第 12 行内容如下：</p>
<pre><code class="language-java">// Configure the bean factory with context callbacks.
// 使用上下文回调配置Bean工厂。
// 向 List 里面添加一个数据：添加一个后置管理器：ApplicationContextAwareProcessor 实现了 BeanPostProcessor接口：插手 Bean 的创建过程
beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
</code></pre>
<p>向 List 里面添加一个数据：添加一个后置管理器：ApplicationContextAwareProcessor 实现了 BeanPostProcessor接口：插手 Bean 的创建过程：</p>
<pre><code class="language-java">class ApplicationContextAwareProcessor implements BeanPostProcessor {
</code></pre>
<p>如果想了解 ApplicationContextAwareProcessor 类，就先来看一下它实现的父接口 BeanPostProcessor 类。</p>
<h4 id="1341-beanpostprocessor">1.3.4.1 BeanPostProcessor</h4>
<p>先来看一下 BeanPostProcessor 接口的结构，一共有两个方法：</p>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/BeanPostProcessor.png" alt="图片" loading="lazy"></figure>
<pre><code class="language-java">/**
 * BeanPostProcessor 是 Spring 框架提供的一个扩展类点（Spring 扩展不止一个后置处理器，
 * Spring 能够扩展一个类，它提供了很多后置处理器，但这个后置处理器都属于一种，还有其他办法）
 * 通过实现 BeanPostProcessor 接口，程序员就可查收 bean 实例化的过程，从而减轻了 beanFactory 的负担
 * 值得说明的是这个接口可以设置多个，会形成一个列表， 然后依次执行
 * （自己写的后置处理器只需添加 @Component 即可，Spring就会自动扫描把它new出来然后添加到容器中。
 * 但是 Spring 默认的怎么办？Spring 手动 set 添加到容器中） 
 * 比如 AOP 就是在 bean 实例化后期间将切面逻辑织入 bean 实例中的
 * AOP 也正是通过 BeanPostProcessor 和 IOC 容器建立起了联系
 * （由 Spring 提供的默认的 PostProcessor，Spring 提供了很多默认的 PostProcessor，下面一一介绍这些实现类的功能）
 * 可以演示一下 BeanPostProcessor 的使用方式（把动态代理和 IOC、AOP 结合起来使用）
 *
 * 在演示之前先来熟悉一下这个接口，是这个接口本身特别简单，但是它的实现类特别复杂。
 * 可以看看 Spring 提供哪些默认的实现
 * 查看类的关系图就可以知道 Spring 提供了以下的默认实现，由于实现类是在太多，所以只是解释几个常用的
 * 1.ApplicationContextAwareProcessor（sacap）
 *        acap 后置处理器的作用是：当应用程序定义的 Bean 实现 ApplicationContextAware 接口时注入 ApplicationContext 对象
 *        当然这是他的第一个作业，它还有其他作用，这里就不一一举例了，可以参考源码
 *        我们可以针对 ApplicationContextAwareProcessor 写一个例子
 * 2.InitDestroyAnnotationBeanPostProcessor
 *     用来处理自定义的初始化方法和销毁方法
 *     Spring 中提供了三种自定义初始化和销毁方法分别是
 *     ① 通过 @Bean 指定 inti method 和 destroy-method 属性
 *     ② Ban 实现 InitializingBean 接口和显现 DisposableBean
 *     ③ @PostConstruct：@PreDestroy
 *     为什么 Spring 通过这三种方式都能完成对 bean 生命周期的回调呢？
 *     可以通过 InitDestroyAnnotationBeanPostProcessor 的源码来解释
 * 3.InstantiationAwareBeanPostProcessor
 * 4.CommonAnnotationBeanPostProcessor
 * 5.AutowiredAnnotationBeanPostProcessor
 * 6.RequiredAnnotationBeanPostProcessor
 * 7.BeanValidationPostProcessor
 * 8.AbstractAutoProxyCreator：抽象自动代理创建器：AOP 创建一个代理
 * ......
 *
 *
 * Factory hook that allows for custom modification of new bean instances,
 * e.g. checking for marker interfaces or wrapping them with proxies.
 *
 * &lt;p&gt;ApplicationContexts can autodetect BeanPostProcessor beans in their
 * bean definitions and apply them to any beans subsequently created.
 * Plain bean factories allow for programmatic registration of post-processors,
 * applying to all beans created through this factory.
 *
 * &lt;p&gt;Typically, post-processors that populate beans via marker interfaces
 * or the like will implement {@link #postProcessBeforeInitialization},
 * while post-processors that wrap beans with proxies will normally
 * implement {@link #postProcessAfterInitialization}.
 *
 * @author Juergen Hoeller
 * @since 10.10.2003
 * @see InstantiationAwareBeanPostProcessor
 * @see DestructionAwareBeanPostProcessor
 * @see ConfigurableBeanFactory#addBeanPostProcessor
 * @see BeanFactoryPostProcessor
 */
public interface BeanPostProcessor {

   /**
    *
    * 在 Bean 初始化之前执行
    * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;before&lt;/i&gt; any bean
    * initialization callbacks (like InitializingBean's {@code afterPropertiesSet}
    * or a custom init-method). The bean will already be populated with property values.
    * The returned bean instance may be a wrapper around the original.
    * &lt;p&gt;The default implementation returns the given {@code bean} as-is.
    * @param bean the new bean instance
    * @param beanName the name of the bean
    * @return the bean instance to use, either the original or a wrapped one;
    * if {@code null}, no subsequent BeanPostProcessors will be invoked
    * @throws org.springframework.beans.BeansException in case of errors
    * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet
    */
   @Nullable
   default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
      return bean;
   }

   /**
    * 在 Bean 初始化之后执行
    * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;after&lt;/i&gt; any bean
    * initialization callbacks (like InitializingBean's {@code afterPropertiesSet}
    * or a custom init-method). The bean will already be populated with property values.
    * The returned bean instance may be a wrapper around the original.
    * &lt;p&gt;In case of a FactoryBean, this callback will be invoked for both the FactoryBean
    * instance and the objects created by the FactoryBean (as of Spring 2.0). The
    * post-processor can decide whether to apply to either the FactoryBean or created
    * objects or both through corresponding {@code bean instanceof FactoryBean} checks.
    * &lt;p&gt;This callback will also be invoked after a short-circuiting triggered by a
    * {@link InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation} method,
    * in contrast to all other BeanPostProcessor callbacks.
    * &lt;p&gt;The default implementation returns the given {@code bean} as-is.
    * @param bean the new bean instance
    * @param beanName the name of the bean
    * @return the bean instance to use, either the original or a wrapped one;
    * if {@code null}, no subsequent BeanPostProcessors will be invoked
    * @throws org.springframework.beans.BeansException in case of errors
    * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet
    * @see org.springframework.beans.factory.FactoryBean
    */
   @Nullable
   default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
      return bean;
   }

}
</code></pre>
<p>AnnotationAwareAspectJAutoProxyCreator 并没有添加 @Component 注解，所以 Spring 不会扫描它</p>
<pre><code class="language-java">@SuppressWarnings(&quot;serial&quot;)public class AnnotationAwareAspectJAutoProxyCreator extends AspectJAwareAdvisorAutoProxyCreator {
</code></pre>
<p>接下来再回回到 prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) 的第 12 行内容如下：</p>
<pre><code class="language-java">beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
</code></pre>
<p>现在来看一下 addBeanPostProcessor() 方法的实现：</p>
<h4 id="1342-addbeanpostprocessorbeanpostprocessor-beanpostprocessor">1.3.4.2 addBeanPostProcessor(BeanPostProcessor beanPostProcessor)</h4>
<pre><code class="language-java">@Override
public void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) {
   Assert.notNull(beanPostProcessor, &quot;BeanPostProcessor must not be null&quot;);
   // Remove from old position, if any
   this.beanPostProcessors.remove(beanPostProcessor);
   // Track whether it is instantiation/destruction aware
   if (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) {
      this.hasInstantiationAwareBeanPostProcessors = true;
   }
   if (beanPostProcessor instanceof DestructionAwareBeanPostProcessor) {
      this.hasDestructionAwareBeanPostProcessors = true;
   }
   // Add to end of list
   this.beanPostProcessors.add(beanPostProcessor);
}
</code></pre>
<p>看一下上述 addBeanPostProcessor 方法的第 14 行，向 beanPostProcessors 中添加了一个 beanPostProcessor，那么 beanPostProcessors  是什么呢？List<BeanPostProcessor> 集合</p>
<pre><code class="language-java">/** BeanPostProcessors to apply in createBean */
private final List&lt;BeanPostProcessor&gt; beanPostProcessors = new CopyOnWriteArrayList&lt;&gt;();
</code></pre>
<p><strong>postProcessBeforeInitialization</strong></p>
<p>接下来看 ApplicationContextAwareProcessor 类是如何实现 postProcessBeforeInitialization 方法的：</p>
<pre><code class="language-java">@Override
@Nullable
public Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException {
   AccessControlContext acc = null;

   if (System.getSecurityManager() != null &amp;&amp;
         (bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||
               bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||
               bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)) {
      acc = this.applicationContext.getBeanFactory().getAccessControlContext();
   }

   if (acc != null) {
      AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
         invokeAwareInterfaces(bean);
         return null;
      }, acc);
   }
   else {
      invokeAwareInterfaces(bean);
   }

   return bean;
}
</code></pre>
<p>看上述 postProcessBeforeInitialization 方法的第 20 行，调用了 invokeAwareInterfaces(bean); 方法，具体实现如下：</p>
<pre><code class="language-java">private void invokeAwareInterfaces(Object bean) {
   // 判断这个 bean 是不是 Aware 接口
   if (bean instanceof Aware) {
      if (bean instanceof EnvironmentAware) {
         ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());
      }
      if (bean instanceof EmbeddedValueResolverAware) {
         ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);
      }
      // 判断这个 bean 是不是 ResourceLoaderAware 接口
      if (bean instanceof ResourceLoaderAware) {
         ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);
      }
      if (bean instanceof ApplicationEventPublisherAware) {
         ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);
      }
      if (bean instanceof MessageSourceAware) {
         ((MessageSourceAware) bean).setMessageSource(this.applicationContext);
      }
      // Spring 帮助我们 set 了一个 applicationContext 对象
      // 所以当我们自己的一个对象实现了 ApplicationContextAware 对象只需要提供 setter 就能得到 applicationContext
      if (bean instanceof ApplicationContextAware) {
         ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);
      }
   }
}
</code></pre>
<h1 id="单例对象中有一个-prototype-属性会有问题如何解决">单例对象中有一个 prototype 属性会有问题，如何解决：</h1>
<h2 id="repository">@Repository</h2>
<pre><code class="language-java">@Repository
@Scope(&quot;prototype&quot;)
public class IndexDaoImpl implements IndexDao {
</code></pre>
<h2 id="lookup">@Lookup</h2>
<pre><code class="language-java">@Service
@Scope(&quot;singleton&quot;)
public abstract class IndexService {
    @Lookup
    public abstract IndexDao getIndexDao() ;
    public void service(){
        System.out.println(this);
        System.out.println(getIndexDao());
    }
}
</code></pre>
<h2 id="applicationcontextaware">ApplicationContextAware</h2>
<p>implements ApplicationContextAware，重写 setApplicationContext 方法</p>
<pre><code class="language-java">@Service
@Scope(&quot;singleton&quot;)
public class IndexService implements ApplicationContextAware {
    @Autowired
    private IndexDao indexDao;
    private ApplicationContext applicationContext;
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
    public void service(){
        System.out.println(this);
        // 得到原型对象
       System.out.println(applicationContext.getBean(&quot;indexDaoImpl&quot;));
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring系列（五）BeanFactory和FactoryBean的区别]]></title>
        <id>https://epitomm.github.io/post/spring-xi-lie-wu-beanfactory-he-factorybean-de-qu-bie/</id>
        <link href="https://epitomm.github.io/post/spring-xi-lie-wu-beanfactory-he-factorybean-de-qu-bie/">
        </link>
        <updated>2020-05-05T03:37:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="beanfactory-和-factorybean-的区别">BeanFactory 和 FactoryBean 的区别？</h1>
<ul>
<li>BeanFactory 是 Spring 提供的一个工厂，能够产生对象。通过 getBean(&quot;xxx&quot;) 能够得到一个 Bean。</li>
<li>FactoryBean 是一个 Bean：把一个对象交给 Spring 管理，就可以称之为一个 Bean，就是一个对象，FactoryBean 就是一个受 Spring 管理的对象。
<ul>
<li>当一个类的依赖关系很复杂，而我们想对外提供简单的关系，就让外部可以使用时，就使用 FactoryBean，经典场景：MyBatis 中的 SqlSessionFactoryBean 对象。</li>
<li>如果类实现了 FactoryBean，那么 Spring 容器当中存在两个对象，一个是 getObject() 方法返回的对象（name=当前类名）；还有一个是当前对象（name=&amp;+当前类名）。</li>
</ul>
</li>
</ul>
<h1 id="spring-中声明一个-bean-的方式">Spring 中声明一个 Bean 的方式</h1>
<ul>
<li>
<bean>
</li>
<li>@Service</li>
<li>@Bean</li>
</ul>
<h1 id="factorybean">FactoryBean</h1>
<pre><code class="language-java">// 表明这是一个 xml 文件
@Configuration
// 注解扫描包
@ComponentScan(&quot;com.ssm&quot;)
public class SpringConfig {
}
</code></pre>
<p>如果类实现了 FactoryBean，那么 Spring 容器当中存在两个对象，一个是 getObject() 方法返回的对象 TempDaoFactoryBean；还有一个是当前对象 DaoFactoryBean。</p>
<p>在 Spring 容器中存储时，存储的 name 值是：</p>
<p>getObject() 得到对象：TempDaoFactoryBean 存的名字是当前类指定的名字：daoFactoryBean；</p>
<p>当前对象 DaoFactoryBean 是 &quot;&amp;&quot; + 当前类的名字：&amp;daoFactoryBean</p>
<pre><code class="language-java">@Component(&quot;daoFactoryBean&quot;)
public class DaoFactoryBean implements FactoryBean {

    public void testBean(){
        System.out.println(&quot;testBean...&quot;);
    }

    @Override
    public Object getObject() throws Exception {
        return new TempDaoFactoryBean();
    }

    @Override
    public Class&lt;?&gt; getObjectType() {
        return TempDaoFactoryBean.class;
    }

    @Override
    public boolean isSingleton() {
        return true;
    }
}
</code></pre>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        DaoFactoryBean daoFactoryBean = (DaoFactoryBean) context.getBean(&quot;daoFactoryBean&quot;);
        daoFactoryBean.testBean();
    }
}
</code></pre>
<pre><code>Exception in thread &quot;main&quot; java.lang.ClassCastException: com.ssm.dao.TempDaoFactoryBean cannot be cast to com.ssm.dao.DaoFactoryBean	at com.ssm.test.Test.main(Test.java:13)
</code></pre>
<p>ClassCastException：类型转换异常。将一个对象通过 @Component(&quot;daoFactoryBean&quot;) 放到 Spring 容器中，然后通过context.getBean(&quot;daoFactoryBean&quot;) 结果却类型转换异常。</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        TempDaoFactoryBean daoFactoryBean = (TempDaoFactoryBean) context.getBean(&quot;daoFactoryBean&quot;);
        daoFactoryBean.test();

    }
}
</code></pre>
<pre><code>FactoryBean...
</code></pre>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        TempDaoFactoryBean daoFactoryBean = (TempDaoFactoryBean) context.getBean(&quot;daoFactoryBean&quot;);
        daoFactoryBean.test();

        DaoFactoryBean bean = (DaoFactoryBean) context.getBean(&quot;&amp;daoFactoryBean&quot;);
        bean.testBean();

    }
}
</code></pre>
<pre><code>FactoryBean...
testBean...
</code></pre>
<h2 id="final-string-beanname-transformedbeannamename">final String beanName = transformedBeanName(name);</h2>
<ul>
<li>通过 name 获取 beanName</li>
</ul>
<p>通过 name 获取 beanName，这里不使用 name 直接作为 beanName 有两个原因：</p>
<p>1.name 可能会以 &amp; 字符开头，表名调用者想获取 FactoryBean 本身，而非 FactoryBean 实现类锁创建的 bean。在 Spring 工厂中，FactoryBean 的实现类和其他的普通 bean 存储方式是一致的，即&lt;beanName, bean&gt;，beanName 中是没有 &amp; 这个字符的。所以我们需要将 name 的首字符 &amp; 移除，这样才能从缓存里取到 FactoryBean 实例。</p>
<p>2.还是别名的问题 <alias>.，转换需要</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/transformedBeanName.png" alt="图片" loading="lazy"></figure>
<p>如果有一个类相当复杂，里面有很多依赖，就要配置很多 <property>，有可能有的依赖还得不到。</p>
<pre><code class="language-xml">&lt;bean id=&quot;temp&quot; class=&quot;com.ssm.dao.TempDaoFactoryBean&quot;&gt;
  &lt;!--假设这个类内有很多属性，就要配置很多 &lt;property&gt;--&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="language-java">public class TempDaoFactoryBean{
  Util util;
  Config config;
  String str1;
  String str2;
}
</code></pre>
<p>假如上述类是第三方框架写的，由于是第三方框架代码，不可能到它的源码上去添加@Component注解：</p>
<p>解决办法1.在 xml 配置这个类；</p>
<p>解决办法2.通过 JavConfig 把它 new 出来，然后添加一个 @Bean 标签</p>
<pre><code class="language-java">// 表明这是一个 xml 文件
@Configuration
// 注解扫描包
@ComponentScan(&quot;com.ssm&quot;)
public class SpringConfig {

    @Bean
    public DataSource dataSource(){
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
        dataSource.setUsername(&quot;root&quot;);
        dataSource.setPassword(&quot;123456&quot;);
        dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);
        return dataSource;
    }

    @Bean
    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){
        SqlSessionFactoryBean sqlSessionFactoryBean =  new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource);
        return sqlSessionFactoryBean;
    }
}
</code></pre>
<h1 id="比如在-spring-中引入第三方工具-mybatis">比如在 Spring 中引入第三方工具 Mybatis</h1>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7.png" alt="图片" loading="lazy"></figure>
<p>1.在 bean 中配置一个 SqlSessionFactory</p>
<pre><code class="language-xml">&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.apache.ibatis.session.defaults.DefaultSqlSessionFactory&quot;&gt;&lt;/bean&gt;
</code></pre>
<p>2.我们发现 SqlSessionFactory 依赖了 Configuration，于是在 <bean> 配置 Configuration</p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/SqlSessionFactory%E4%BE%9D%E8%B5%96Configuration.png" alt="图片" loading="lazy"></figure>
<pre><code class="language-xml">&lt;bean id=&quot;configuration&quot; class=&quot;org.apache.ibatis.session.Configuration&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.apache.ibatis.session.defaults.DefaultSqlSessionFactory&quot;&gt;
    &lt;constructor-arg ref=&quot;configuration&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre>
<p>3.Configuration 有超级多依赖，就需要在 <bean> 内添加很多 <property></p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/Configuration%E6%9C%89%E5%BE%88%E5%A4%9A%E4%BE%9D%E8%B5%96.png" alt="图片" loading="lazy"></figure>
<pre><code class="language-xml">&lt;bean id=&quot;configuration&quot; class=&quot;org.apache.ibatis.session.Configuration&quot;&gt;
  &lt;property&gt;&lt;/property&gt;
  &lt;property&gt;&lt;/property&gt;
  &lt;property&gt;&lt;/property&gt;
  &lt;property&gt;&lt;/property&gt;
  // ......
  &lt;property&gt;&lt;/property&gt;
  &lt;property&gt;&lt;/property&gt;
  &lt;property&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.apache.ibatis.session.defaults.DefaultSqlSessionFactory&quot;&gt;
    &lt;constructor-arg ref=&quot;configuration&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre>
<p>如此自己配置第三方依赖，操作太过复杂，最好的办法是 MyBatis 自己把 Configuration 这些复杂依赖关系都维护好，我们直接引入即可：</p>
<pre><code class="language-xml">&lt;bean id=&quot;dao&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/bean&gt;
</code></pre>
<p>但是 MyBatis 无法更改我们的配置文件，所以它没有地方去配置，于是它提供了一个 SqlSessionFactoryBean 类，在这个类中把这些依赖关系都维护好了。</p>
<h2 id="sqlsessionfactorybean">SqlSessionFactoryBean</h2>
<p>Mybatis在 SqlSessionFactoryBean 内部维护了各种依赖关系：</p>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/SqlSessionFactoryBean.png" alt="图片" loading="lazy"></figure>
<p>最终返回的对象是 SqlSessionFactory</p>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/SqlSessionFactoryBean%E8%BF%94%E5%9B%9ESqlSessionFactory.png" alt="图片" loading="lazy"></figure>
<p>afterPropertiesSet()</p>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/afterPropertiesSet.png" alt="图片" loading="lazy"></figure>
<p>buildSqlSessionFactory()</p>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/buildSqlSessionFactory.png" alt="图片" loading="lazy"></figure>
<p>MyBatis 内部通过 SqlSessionFactoryBean 维护了各种依赖关系，我们只需直接使用 SqlSessionFactoryBean 对象即可获得 SqlSessionFactory，无需再手动维护各种依赖。</p>
<h2 id="mybatis-通过-sqlsessionfactorybeansetdatasourcedatasource">MyBatis 通过 sqlSessionFactoryBean.setDataSource(dataSource);</h2>
<pre><code class="language-java">@Bean
public DataSource dataSource(){
    DriverManagerDataSource dataSource = new DriverManagerDataSource();
    dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
    dataSource.setUsername(&quot;root&quot;);
    dataSource.setPassword(&quot;123456&quot;);
    dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);
    return dataSource;
}
@Bean
public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){
    SqlSessionFactoryBean sqlSessionFactoryBean =  new SqlSessionFactoryBean();
    sqlSessionFactoryBean.setDataSource(dataSource);
    return sqlSessionFactoryBean;
}
</code></pre>
<h2 id="自定义通过-tempdaofactorybeansetmsg1str">自定义通过 TempDaoFactoryBean.setMsg1(str);</h2>
<p>1.JavaConfig 配置文件</p>
<pre><code class="language-java">// 表明这是一个 xml 文件
@Configuration
// 注解扫描包
@ComponentScan(&quot;com.ssm&quot;)
// 扫描 xml 配置文件
@ImportResource(&quot;classpath:spring.xml&quot;)
public class SpringConfig {
}
</code></pre>
<p>2.配置文件 xml 内配置 DaoFactoryBean 对象</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
       
    &lt;bean id=&quot;daoFactory&quot; class=&quot;com.ssm.dao.DaoFactoryBean&quot;&gt;
        &lt;property name=&quot;msg&quot; value=&quot;msg1,msg2,msg3&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>3.DaoFactoryBean 内有一属性 msg</p>
<pre><code class="language-java">public class DaoFactoryBean implements FactoryBean {
    private String msg;
    public void setMsg(String msg) {
        this.msg = msg;
    }
    @Override
    public Object getObject() throws Exception {
        TempDaoFactoryBean temp = new TempDaoFactoryBean();
        String[] msgArray = msg.split(&quot;,&quot;);
        temp.setMsg1(msgArray[0]);
        temp.setMsg2(msgArray[1]);
        temp.setMsg3(msgArray[2]);
        return temp;
    }
    @Override
    public Class&lt;?&gt; getObjectType() {
        return TempDaoFactoryBean.class;
    }
    @Override
    public boolean isSingleton() {
        return true;
    }
}
</code></pre>
<p>4.TempDaoFactoryBean 内有三个属性：msg1、msg2、msg3</p>
<pre><code class="language-java">public class TempDaoFactoryBean {

    private String msg1;
    private String msg2;
    private String msg3;

    public void test(){
        System.out.println(&quot;FactoryBean...&quot;);
    }

    public void setMsg1(String msg1) {
        this.msg1 = msg1;
    }

    public void setMsg2(String msg2) {
        this.msg2 = msg2;
    }

    public void setMsg3(String msg3) {
        this.msg3 = msg3;
    }

    public String getMsg1() {
        return msg1;
    }

    public String getMsg2() {
        return msg2;
    }

    public String getMsg3() {
        return msg3;
    }
}
</code></pre>
<p>5.测试类</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        TempDaoFactoryBean temp = (TempDaoFactoryBean) context.getBean(&quot;daoFactory&quot;);
        System.out.println(temp.getMsg1());

    }
}
</code></pre>
<p>6.测试结果：</p>
<pre><code>msg1
</code></pre>
<pre><code class="language-java">@PostConstruct // 当 bean 实例化时，回调这个注解修饰的方法，进行初始化操作，比如 Redis 预热场景。
public void init(){
}
</code></pre>
<h1 id="spring-如何完成扫描">Spring 如何完成扫描</h1>
<h2 id="如何初始化-spring-环境">如何初始化 Spring 环境？</h2>
<ul>
<li>xml：ClassPathXmlApplicationContext；
<ul>
<li>类的扫描</li>
<li>单独 bean 的注册：在 xml 中写一个<bean>，只要这个 xml 被解析，Spring 就帮助完成了 bean 的声明（定义<bean>）和注册（Spring 会自动创建一个对象放到容器中）</li>
</ul>
</li>
<li>注解 Annotation：必须借助 xml:&lt;context:component-scan base-package=&quot;com.ssm&quot;/&gt;或 JavaConfig:@ComponentScan 完成对类的扫描；</li>
<li>JavaConfig：AnnotationConfigApplicationContext。
<ul>
<li>类的扫描</li>
<li>类的定义：如果只是写了一个@Component，并没有扫描这个类，称为只是定义一个 bean，并没有类的注册（因为没有被扫描 ）</li>
</ul>
</li>
</ul>
<p>为什么要初始化 Spring 环境？</p>
<p>把我们交给 Spring 管理的类实例化</p>
<pre><code class="language-java">@Servicepublic class IndexService {}
</code></pre>
<pre><code class="language-java">// 表明这是一个 xml 文件
@Configuration
// 注解扫描包
@ComponentScan(&quot;com.ssm&quot;)
public class SpringConfig {
</code></pre>
<p>register() 可以注册两种类型的 bean：1.加了 @Configuration 的 bean；2.普通的 bean</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();

        context.register(SpringConfig.class);
        context.refresh();

        // register() 可以注册两种类型的 bean：加了 @Configuration 的 bean；普通的 bean
//        context.register(TestService.class);
        IndexService indexService = (IndexService) context.getBean(&quot;indexService&quot;);
        System.out.println(indexService);
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>com.ssm.service.IndexService@1a451d4d
</code></pre>
<p>AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);</p>
<p>![图片](https://epitomm.github.io/post-images/通过配置文件new AnnotationConfigApplicationContext.png)<br>
<img src="https://epitomm.github.io/post-images/register.png" alt="图片" loading="lazy"></p>
<p>context.register(SpringConfig.class);</p>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/register.png" alt="图片" loading="lazy"></figure>
<p>配置文件不扫描包，使用 register() 单独注册某个类</p>
<pre><code class="language-java">// 表明这是一个 xml 文件
@Configuration
// 注解扫描包
//@ComponentScan(&quot;com.ssm&quot;)
public class SpringConfig {
</code></pre>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
        // register() 注册加了 @Configuration 的 bean
        context.register(SpringConfig.class);
        // register() 注册普通的 bean
        context.register(IndexService.class);
        context.refresh();

        IndexService indexService = (IndexService) context.getBean(&quot;indexService&quot;);
        System.out.println(indexService);
    }
}
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/%E8%AF%BB%E5%8F%96JavaConfig%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/AnnotationConfigApplicationContext%E6%BA%90%E7%A0%81.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/register%E6%BA%90%E7%A0%81.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/register%E6%BA%90%E7%A0%81_2.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/registerBean%E6%BA%90%E7%A0%81.png" alt="图片" loading="lazy"></figure>
<p>context.scan(&quot;com.ssm&quot;); 也可以完成扫描：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();

        context.register(SpringConfig.class);
        context.scan(&quot;com.ssm&quot;);
        context.refresh();

        IndexService indexService = (IndexService) context.getBean(&quot;indexService&quot;);
        System.out.println(indexService);

    }
}
</code></pre>
<p><img src="https://epitomm.github.io/post-images/scan%E6%BA%90%E7%A0%81.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/scan%E6%BA%90%E7%A0%81_2.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/doScan.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/doScan%E6%89%AB%E6%8F%8F%E5%AE%8C%E6%88%90.png" alt="图片" loading="lazy"></p>
<p>进行类的扫描时，添加一个依赖，就可以按索引扫描，加快扫描速度。<br>
<img src="https://epitomm.github.io/post-images/findCandidateComponents.png" alt="图片" loading="lazy"></p>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/scanCandidateComponents.png" alt="图片" loading="lazy"></figure>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
public @interface Anno {
    public String value();
}
</code></pre>
<pre><code class="language-java">@Anno(&quot;userServiceImpl&quot;)
public class UserServiceImpl implements UserService {
</code></pre>
<pre><code class="language-java">public class AnnotationConfigApplicationContext {

    public void scan(String basePackage){
        // 1.通过文件名得到 .class 文件，然后去掉 .class 就是最终的类名
        // 得到根目录
        String rootPath = this.getClass().getResource(&quot;/&quot;).getPath();
        // 2. 将 com.ssm 变为 com/ssm/
        String basePackagePath = basePackage.replaceAll(&quot;\\.&quot;,&quot;\\\\&quot;);

        File file = new File(rootPath + &quot;//&quot; + basePackagePath);
        // 得到所有文件名的数组
        String[] names = file.list();
        for (String name : names) {
            // 去掉文件的 .class 就得到了类名
            name = name.replaceAll(&quot;.class&quot;,&quot;&quot;);
            // 得到所有的文件名
            try {
                Class&lt;?&gt; clazz = Class.forName(basePackage + &quot;.&quot; + name);
                // 判断是否属于 @Service、@Component...
                // 判断是否加了 @Anno 注解
                if(clazz.isAnnotationPresent(Anno.class)){
                    Anno annotation = (Anno)clazz.getAnnotation(Anno.class);
                    System.out.println(annotation.value());
                    System.out.println(clazz.newInstance());
                }
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            } catch (InstantiationException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<pre><code class="language-java">public class TestAnno {
    public static void main(String[] args) throws SpringException {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
        context.scan(&quot;com.ssm.service.impl&quot;);
    }
}
</code></pre>
<pre><code>userServiceImpl
com.ssm.service.impl.UserServiceImpl@1d44bcfa
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring系列（四）XML模拟SpringIOC]]></title>
        <id>https://epitomm.github.io/post/spring-xi-lie-si-xml-mo-ni-springioc/</id>
        <link href="https://epitomm.github.io/post/spring-xi-lie-si-xml-mo-ni-springioc/">
        </link>
        <updated>2020-05-05T03:28:50.000Z</updated>
        <content type="html"><![CDATA[<p>先来回顾一下自定义动态代理中获取对象的方法：</p>
<ul>
<li>获得代理对象：TestDao proxy = (TestDao) ProxyUtil.newInstance(TestDao.class, new TestCustomHandler(new TestDaoImpl()));</li>
<li>获得目标对象：TestDao target = new TestDaoImpl();<br>
以上方式耦合度过高</li>
</ul>
<h1 id="spring-ioc-的思想">Spring IOC 的思想</h1>
<p>工厂方法的好处，工厂方法控制了 proxy 对象的产生过程，现在这个对象的产生过程是由编码控制的，通过 newInstance() 控制的，但是如果使用工厂的话，工厂也可以控制类的产生过程：比如通过类名：TestDao proxy = Factory.getBean(&quot;testDao&quot;);由于可以做到自己控制，提出一种思想：注入，依赖查找查找名为 &quot;testDao&quot; 的 bean，<strong>对象的产生过程通过外部第三方容器注入给我</strong>，对于程序员来讲，编程的话，只需要写 TestDao testDao 即可，至于这个对象到底是什么东西，程序员无需关心，是由外部容器注入进来的，程序员正常编码即可，面向抽象编程这些方法都有，比如 testDao.query();</p>
<h1 id="模拟-springaop">模拟 SpringAOP</h1>
<p>实现将对象交给容器管理</p>
<h2 id="userdao">UserDao</h2>
<pre><code class="language-java">public interface UserDao {
    void query();
}
</code></pre>
<h2 id="userdaoimpl">UserDaoImpl</h2>
<pre><code class="language-java">public class UserDaoImpl implements UserDao {
    @Override
    public void query() {
        System.out.println(&quot;dao&quot;);
    }
}
</code></pre>
<h2 id="userservice">UserService</h2>
<pre><code class="language-java">public interface UserService {
    void find();
}
</code></pre>
<h2 id="userserviceimpl">UserServiceImpl</h2>
<pre><code class="language-java">public class UserServiceImpl implements UserService {

    private UserDao userDao;

    @Override
    public void find() {
        System.out.println(&quot;service...&quot;);
        userDao.query();
    }

    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}
</code></pre>
<h2 id="springxml">spring.xml</h2>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!--
    1.哪些类需要我（容器）来管理
    2.怎么告诉我这些类：&lt;bean&gt;
    3.怎么维护依赖关系：setter、constructor
    4.怎么体现 setter：&lt;property&gt; 或者 constructor：&lt;constructor&gt;
--&gt;
&lt;beans&gt;

    &lt;bean id=&quot;userDao&quot; class = &quot;com.ssm.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;

    &lt;bean id=&quot;userService&quot; class=&quot;com.ssm.service.impl.UserServiceImpl&quot;&gt;
        &lt;!-- 注入：1.构造方法；
        2.set方法：UserService 中有一个 setUserDao(UserDao userDao)  方法，
        只要提供了 UserDao，容器自动调用 setUserDao() 方法给 UserService 内的 UserDao 赋值--&gt;
        &lt;property name=&quot;userDao&quot; ref = &quot;userDao&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h2 id="解析-xml-的方式dom4j">解析 xml 的方式：dom4j。</h2>
<p>dom4j 官网：<a href="https://dom4j.github.io/">https://dom4j.github.io/</a><br>
导入 dom4j 依赖：</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/dom4j/dom4j --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;dom4j&lt;/groupId&gt;
  &lt;artifactId&gt;dom4j&lt;/artifactId&gt;
  &lt;version&gt;1.6.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="将对象交给容器管理setter-方法注入">将对象交给容器管理（setter 方法注入）</h2>
<p>解析 xml 文件，将 “对象名-对象类型” 放到 map 集合中。</p>
<pre><code class="language-java">import org.dom4j.Attribute;
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.Element;
import org.dom4j.io.SAXReader;

import java.io.File;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

public class BeanFactory {

    // 得到每个 bean 的 id、class 存到 map 中
    Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();

    public BeanFactory(String xml){
        parseXml(xml);
    }

    /**
     * 解析 XML
     */
    public void parseXml(String xml){
        // 获取要解析的 xml 的路径
        File file = new File(this.getClass().getResource(&quot;/&quot;).getPath() + &quot;//&quot; + xml);
        // 解析 xml
        SAXReader reader = new SAXReader();
        Document document = null;
        try {
            document = reader.read(file);
            // 得到根目录
            Element elementRoot = document.getRootElement();
            // 获取根目录下的所有子目录
            for (Iterator&lt;Element&gt; itFirst = elementRoot.elementIterator(); itFirst.hasNext();) {
                /**
                 * setup1.实例化对象
                 */
                // 得到第一个子元素：spring.xml 中的 &lt;bean&gt;
                Element elementFirstChild = itFirst.next();
                // 获得 bean 标签的 id 属性值
                Attribute attributeId = elementFirstChild.attribute(&quot;id&quot;);
                String beanName = attributeId.getValue();
                // 获得 bean 标签的 class 属性值
                Attribute attributeClass = elementFirstChild.attribute(&quot;class&quot;);
                String clazzName = attributeClass.getValue();
                Class clazz = Class.forName(clazzName);
                Object object = clazz.newInstance();
                /**
                 * setup2.维护依赖关系
                 *  (1)看这个对象有没有依赖（判断类是否有属性，然后再判断&lt;bean&gt;中是否有 name=&quot;属性值&quot;的&lt;property&gt;）
                 *      如果有，则注入
                 */
                // 得到&lt;bean&gt;的子标签
                for (Iterator&lt;Element&gt; itSecond = elementFirstChild.elementIterator(); itSecond.hasNext();) {
                    // 得到 &lt;property name=&quot;userDao&quot; ref = &quot;userDao&quot;&gt;&lt;/property&gt;
                    Element elementSecondChild = itSecond.next();
                    if(&quot;property&quot;.equals(elementSecondChild.getName())){
                        // 1.得到 ref 的 value（userDao），通过 value 得到对象（map中id=&quot;userDao&quot;）
                        String refValue = elementSecondChild.attribute(&quot;ref&quot;).getValue();
                        // 需要注入的对象 UserDao
                        Object injetObject = map.get(refValue);
                        // 2.得到 name 的值（userDao），然后根据它获取一个 Field 的对象（UserServiceImpl 中的 UserDao userDao）
                        String nameValue = elementSecondChild.attribute(&quot;name&quot;).getValue();
                        // 通过反射得到 Field 对象，即UserDao
                        Field field = clazz.getDeclaredField(nameValue);
                        field.setAccessible(true);
                        // 相等于 UserService.setUserDao(userDao)
                        // 两个参数：userService、UserDao
                        // 3.通过 Field 的set 方法 set 这个对象
                        field.set(object,injetObject);
                    }

                }
                // 放到 map 中
                map.put(beanName,object);
            }
        } catch (DocumentException | ClassNotFoundException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        }
        System.out.println(map);
    }
    public Object getBean(String beanName){
        return map.get(beanName);
    }
}

## 测试类
```java
public class Test {
    public static void main(String[] args) {
        BeanFactory beanFactory = new BeanFactory(&quot;spring.xml&quot;);
        UserService userService = (UserService) beanFactory.getBean(&quot;userService&quot;);
        userService.find();
    }
}
</code></pre>
<p>##运行结果：</p>
<pre><code>{userDao=com.ssm.dao.impl.UserDaoImpl@4dd8dc3, userService=com.ssm.service.impl.UserServiceImpl@6d03e736}
service...
dao
</code></pre>
<h2 id="构造方法注入">构造方法注入</h2>
<h3 id="userserviceimpluserdao-userdao-构造方法">UserServiceImpl(UserDao userDao) 构造方法</h3>
<pre><code class="language-java">public class UserServiceImpl implements UserService {
    private UserDao dao;
    public UserServiceImpl(UserDao userDao){
        this.dao = userDao;
    }

    @Override
    public void find() {
        System.out.println(&quot;service...&quot;);
        dao.query();
    }
}
</code></pre>
<p>###spring.xml</p>
<pre><code class="language-xml">    &lt;bean id=&quot;userService&quot; class=&quot;com.ssm.service.impl.UserServiceImpl&quot;&gt;
        &lt;!-- 注入：1.构造方法；
        2.set方法：UserService 中有一个 setUserDao(UserDao userDao)  方法，
        只要提供了 UserDao，容器自动调用 setUserDao() 方法给 UserService 内的 UserDao 赋值
        name=&quot;dao&quot; :private UserDao dao--&gt;
&lt;!--        &lt;property name=&quot;dao&quot; ref = &quot;userDao&quot;&gt;&lt;/property&gt;--&gt;

        &lt;!-- name=&quot;userDao&quot;：属性的名字：private UserDao dao;
            ref=&quot;userDao&quot;:引入&lt;bean&gt;的 id 为 userDao 的对象--&gt;
        &lt;constructor-arg name=&quot;dao&quot; ref=&quot;userDao&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;
</code></pre>
<p>###解析 xml 将对象放到 map 中</p>
<pre><code class="language-java">public class BeanFactory {

    // 得到每个 bean 的 id、class 存到 map 中
    Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();

    public BeanFactory(String xml){
        parseXml(xml);
    }

    /**
     * 解析 XML
     */
    public void parseXml(String xml){
        // 获取要解析的 xml 的路径
        File file = new File(this.getClass().getResource(&quot;/&quot;).getPath() + &quot;//&quot; + xml);
        // 解析 xml
        SAXReader reader = new SAXReader();
        Document document = null;
        try {
            document = reader.read(file);
            // 得到根目录
            Element elementRoot = document.getRootElement();
            // 获取根目录下的所有子目录
            for (Iterator&lt;Element&gt; itFirst = elementRoot.elementIterator(); itFirst.hasNext();) {
                /**
                 * setup1.实例化对象
                 */
                // 得到第一个子元素：spring.xml 中的 &lt;bean&gt;
                Element elementFirstChild = itFirst.next();
                // 获得 bean 标签的 id 属性值
                Attribute attributeId = elementFirstChild.attribute(&quot;id&quot;);
                String beanName = attributeId.getValue();
                // 获得 bean 标签的 class 属性值
                Attribute attributeClass = elementFirstChild.attribute(&quot;class&quot;);
                String clazzName = attributeClass.getValue();
                Class clazz = Class.forName(clazzName);
                // 当使用构造方法注入时，就不能在这里 newInstance 了，因为没有默认构造方法了
//                Object object = clazz.newInstance();
                Object object = null;
                /**
                 * setup2.维护依赖关系
                 *  (1)看这个对象有没有依赖（判断类是否有属性，然后再判断&lt;bean&gt;中是否有 name=&quot;属性值&quot;的&lt;property&gt;）
                 *      如果有，则注入
                 */
                // 得到&lt;bean&gt;的子标签
                for (Iterator&lt;Element&gt; itSecond = elementFirstChild.elementIterator(); itSecond.hasNext();) {
                    // 得到 &lt;property name=&quot;userDao&quot; ref = &quot;userDao&quot;&gt;&lt;/property&gt;
                    Element elementSecondChild = itSecond.next();
                    // 如果使用 setter 方法注入
                    if(&quot;property&quot;.equals(elementSecondChild.getName())){
                        // 由于是 setter 注入，有一个默认构造方法，可以 newInstance()
                        object = clazz.newInstance();
                        // 1.得到 ref 的 value（userDao），通过 value 得到对象（map中id=&quot;userDao&quot;）
                        String refValue = elementSecondChild.attribute(&quot;ref&quot;).getValue();
                        // 需要注入的对象 UserDao
                        Object injectObject = map.get(refValue);
                        // 2.得到 name 的值（userDao），然后根据它获取一个 Field 的对象（UserServiceImpl 中的 UserDao userDao）
                        String nameValue = elementSecondChild.attribute(&quot;name&quot;).getValue();

                        // 3.通过 Field 的set 方法 set 这个对象
                        // 通过反射得到 Field 对象，即UserDao
                        Field field = clazz.getDeclaredField(nameValue);
                        field.setAccessible(true);
                        // 相等于 UserService.setUserDao(userDao)
                        // 两个参数：userService、UserDao
                        field.set(object,injectObject);
                    }else {// 通过构造方法注入 UserDao
                        // &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/constructor-arg&gt;
                        // 由于没有默认构造方法了，所以不可以 clazz.newInstance() 了
                        // 1.得到 ref 的 value（userDao），通过 value 得到对象（map中id=&quot;userDao&quot;）
                        String refValue = elementSecondChild.attribute(&quot;ref&quot;).getValue();
                        // 需要注入的对象 UserDao
                        Object injectObject = map.get(refValue);
                        // 得到 UserDao 的类型
                        Class injectObjectClazz = injectObject.getClass();
                        // 2.得到 UserService 的构造方法
                        Constructor constructor = clazz.getConstructor(injectObjectClazz.getInterfaces()[0]);
                        //  public UserServiceImpl(UserDao userDao){
                        object = constructor.newInstance(injectObject);

                    }

                }
                // 放到 map 中
                if(object == null){ //没有子标签，比如  &lt;bean id=&quot;userDao&quot; class = &quot;com.ssm.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;
                    object = clazz.newInstance();
                }
                map.put(beanName,object);
            }
        } catch (DocumentException | ClassNotFoundException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
        System.out.println(map);
    }
    public Object getBean(String beanName){
        return map.get(beanName);
    }
}
</code></pre>
<h2 id="自动注入">自动注入</h2>
<pre><code class="language-java">public class UserDaoImpl implements UserDao {
    @Override
    public void query() {
        System.out.println(&quot;dao&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class UserDaoImpl2 implements UserDao {
    @Override
    public void query() {
        System.out.println(&quot;dao2&quot;);
    }
}
</code></pre>
<p>UserServiceImpl 依赖 UserDao，但是既不提供构造方法，也不提供 setter。使用 byType 自动注入。</p>
<pre><code class="language-java">public class UserServiceImpl implements UserService {
    private UserDao userDao;
    @Override
    public void find() {
        System.out.println(&quot;service...&quot;);
        userDao.query();
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans default-autowire=&quot;byType&quot;&gt;
    &lt;bean id=&quot;userDao&quot; class = &quot;com.ssm.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;userDao2&quot; class = &quot;com.ssm.dao.impl.UserDaoImpl2&quot;&gt;&lt;/bean&gt;

    &lt;bean id=&quot;userService&quot; class=&quot;com.ssm.service.impl.UserServiceImpl&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">public class BeanFactory {

    // 得到每个 bean 的 id、class 存到 map 中
    Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();

    public BeanFactory(String xml)throws  SpringException{
        parseXml(xml);
    }

    /**
     * 解析 XML
     */
    public void parseXml(String xml) throws SpringException{
        // 获取要解析的 xml 的路径
        File file = new File(this.getClass().getResource(&quot;/&quot;).getPath() + &quot;//&quot; + xml);
        // 解析 xml
        SAXReader reader = new SAXReader();
        Document document = null;
        try {
            document = reader.read(file);
            // 得到根目录
            Element elementRoot = document.getRootElement();
            Attribute attribute = elementRoot.attribute(&quot;default-autowire&quot;);
            // 记录是否有 default-autowire 自动注入属性
            boolean flag = false;
            if(attribute != null){
                flag = true;
            }
            // 获取根目录下的所有子目录
            for (Iterator&lt;Element&gt; itFirst = elementRoot.elementIterator(); itFirst.hasNext();) {
                /**
                 * setup1.实例化对象
                 */
                // 得到第一个子元素：spring.xml 中的 &lt;bean&gt;
                Element elementFirstChild = itFirst.next();
                // 获得 bean 标签的 id 属性值
                Attribute attributeId = elementFirstChild.attribute(&quot;id&quot;);
                String beanName = attributeId.getValue();
                // 获得 bean 标签的 class 属性值
                Attribute attributeClass = elementFirstChild.attribute(&quot;class&quot;);
                String clazzName = attributeClass.getValue();
                Class clazz = Class.forName(clazzName);
                // 当使用构造方法注入时，就不能在这里 newInstance 了，因为没有默认构造方法了
//                Object object = clazz.newInstance();
                Object object = null;
                /**
                 * setup2.维护依赖关系
                 *  (1)看这个对象有没有依赖（判断类是否有属性，然后再判断&lt;bean&gt;中是否有 name=&quot;属性值&quot;的&lt;property&gt;）
                 *      如果有，则注入
                 */
                // 得到&lt;bean&gt;的子标签
                for (Iterator&lt;Element&gt; itSecond = elementFirstChild.elementIterator(); itSecond.hasNext();) {
                    // 得到 &lt;property name=&quot;userDao&quot; ref = &quot;userDao&quot;&gt;&lt;/property&gt;
                    Element elementSecondChild = itSecond.next();
                    // 如果使用 setter 方法注入
                    if(&quot;property&quot;.equals(elementSecondChild.getName())){
                        // 由于是 setter 注入，有一个默认构造方法，可以 newInstance()
                        object = clazz.newInstance();
                        // 1.得到 ref 的 value（userDao），通过 value 得到对象（map中id=&quot;userDao&quot;）
                        String refValue = elementSecondChild.attribute(&quot;ref&quot;).getValue();
                        // 需要注入的对象 UserDao
                        Object injectObject = map.get(refValue);
                        // 2.得到 name 的值（userDao），然后根据它获取一个 Field 的对象（UserServiceImpl 中的 UserDao userDao）
                        String nameValue = elementSecondChild.attribute(&quot;name&quot;).getValue();

                        // 3.通过 Field 的set 方法 set 这个对象
                        // 通过反射得到 Field 对象，即UserDao
                        Field field = clazz.getDeclaredField(nameValue);
                        field.setAccessible(true);
                        // 相等于 UserService.setUserDao(userDao)
                        // 两个参数：userService、UserDao
                        field.set(object,injectObject);
                    }else {// 通过构造方法注入 UserDao
                        // &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/constructor-arg&gt;
                        // 由于没有默认构造方法了，所以不可以 clazz.newInstance() 了
                        // 1.得到 ref 的 value（userDao），通过 value 得到对象（map中id=&quot;userDao&quot;）
                        String refValue = elementSecondChild.attribute(&quot;ref&quot;).getValue();
                        // 需要注入的对象 UserDao
                        Object injectObject = map.get(refValue);
                        // 得到 UserDao 的类型
                        Class injectObjectClazz = injectObject.getClass();
                        // 2.得到 UserService 的构造方法
                        Constructor constructor = clazz.getConstructor(injectObjectClazz.getInterfaces()[0]);
                        //  public UserServiceImpl(UserDao userDao){
                        object = constructor.newInstance(injectObject);

                    }
                }

                // 手动装配 &gt; 自动装配。如果没有手动装配，就自动装配
                if(object == null){
                    // 如果配置了自动装配
                    if(flag){
                        if(&quot;byType&quot;.equals(attribute.getValue())){
                            // 1.判断是否有依赖
                            // 因为自动装配，所以&lt;bean&gt;没有&lt;property&gt;和&lt;constructor&gt;
                            // 就需要判断 UserServiceImpl 类中是否有属性 UserDao，
                            // 如果没有，就证明 UserServiceImpl 没有依赖；如果有，就证明 UserServiceImpl 有依赖
                            Field[] fields = clazz.getDeclaredFields();
                            for (Field field : fields) {
                                // 2.得到属性的类型，比如 private UserDao dao;那么field.getType()=UserDao.class
                                Class injectObjectClazz = field.getType();
                                /**
                                 * 由于是 byType，所以需要遍历 map 当中的所有对象，
                                 * 判断对象的类型是不是和这个 injectObjectClazz 类型相同
                                 */
                                // 记录 byType 找到的个数：比如找到多少个 UserDaoImpl
                                int count = 0;
                                Object injectObject = null;
                                for(String key : map.keySet()){
                                    Class&lt;?&gt; temp = map.get(key).getClass().getInterfaces()[0];
                                    if(temp.getName().equals(injectObjectClazz.getName())){
                                        injectObject = map.get(key);
                                        // 记录找到一个，因为可能找到多个
                                        count++;
                                    }
                                }
                                // 如果 byType 找到多个
                                if(count &gt; 1){
                                    throw new SpringException(&quot;需要一个对象，但是找到了两个对象&quot;);
                                }else {
                                    // 如果只找到一个 type，注入
                                    field.setAccessible(true);
                                    object = clazz.newInstance();
                                    field.set(object, injectObject);
                                }
                            }
                        }
                    }
                }

                // 放到 map 中
                if(object == null){ //没有子标签，比如  &lt;bean id=&quot;userDao&quot; class = &quot;com.ssm.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;
                    object = clazz.newInstance();
                }
                map.put(beanName,object);
            }
        } catch (DocumentException | ClassNotFoundException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
        System.out.println(map);
    }
    public Object getBean(String beanName){
        return map.get(beanName);
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>Exception in thread &quot;main&quot; com.ssm.org.spring.util.SpringException: 需要一个对象，但是找到了两个对象
	at com.ssm.org.spring.util.BeanFactory.parseXml(BeanFactory.java:137)
	at com.ssm.org.spring.util.BeanFactory.&lt;init&gt;(BeanFactory.java:25)
	at com.ssm.test.Test.main(Test.java:10)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring系列（三）一篇文章学会 JDK 动态代理并手动模拟一个动态代理]]></title>
        <id>https://epitomm.github.io/post/yi-pian-wen-zhang-xue-hui-jdk-dong-tai-dai-li-bing-shou-dong-mo-ni-yi-ge-dong-tai-dai-li/</id>
        <link href="https://epitomm.github.io/post/yi-pian-wen-zhang-xue-hui-jdk-dong-tai-dai-li-bing-shou-dong-mo-ni-yi-ge-dong-tai-dai-li/">
        </link>
        <updated>2020-05-03T14:34:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="什么是代理"><strong>什么是代理</strong></h1>
<p>增强一个对象的功能</p>
<p>买火车票，app就是一个代理，他代理了火车站；小区当中的代售窗口也是一个代理，代理了火车站。</p>
<h1 id="代理模式的引入">代理模式的引入</h1>
<p>1、UserDaoImpl 有一个查询数据库的方法：</p>
<pre><code class="language-java">public class UserDaoImpl{
    public void query(){
        System.out.println(&quot;假装查询数据库&quot;);
    }
}
</code></pre>
<p>2、测试类中调用这个方法</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        UserDaoImpl userDao = new UserDaoImpl();
        LogUtil.log();
        userDao.query();
    }
}
</code></pre>
<p>3、现在有一个这样的需求：想要在每次执行 query() 时记录当前操作写到日志里面。写一个公共的日志方法 log()，那么把 LogUtil.log() 代码写到哪里呢？</p>
<p>3.1 写到 query() 方法中：</p>
<p>3.1.1 缺点：可能 UserDoImpl 是一个 jar，根本没有它的源码，无法进行修改。</p>
<p>3.1.2 即使有源码，将 query() 改写成如下：破坏了单一职责。</p>
<pre><code class="language-java">public void query(){
  LogUtil.log();
  // 进行数据库查询操作...
  System.out.println(&quot;假装查询数据库&quot;); 
}
</code></pre>
<p>单一职责：只做一件事。将日志操作写到 query() 里面破坏了类的封装性，职责就不单一了 。</p>
<p>3.2 写到 Test 类中：  每次调用查询操作前记录当前时间。</p>
<p>缺点：会调用很多次 query 方法，也就要写很多次 Logutil.log() 大量重复代码。</p>
<p>3.3 引入代理模式</p>
<h1 id="java实现的代理的两种办法"><strong>java实现的代理的两种办法</strong></h1>
<h1 id="代理的名词">代理的名词</h1>
<p>代理对象——增强后的对象</p>
<p>目标对象——被增强的对象</p>
<p>他们不是绝对的，会根据情况发生变化</p>
<h1 id="静态代理">静态代理</h1>
<h2 id="继承">继承</h2>
<ul>
<li>代理对象继承目标对象，重写需要增强的方法</li>
<li>缺点：会代理类过多，非常复杂</li>
</ul>
<p>回到上襦代理模式引入的例子中：</p>
<p>3.3 继承：自定义一个类<strong>继承</strong>原来需要添加日志的类 UserDaoImpl，在执行业务操作前添加日志打印语句。既解决了 jar 包无法修改源码的问题，又没有破坏单一职责原则。</p>
<pre><code class="language-java">public class UserDaoLogImpl extends UserDaoImpl {
    @Override
    public void query() {
        LogUtil.log();
        super.query();
    }
}
</code></pre>
<p>测试类：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        UserDao userDao = new UserDaoLogImpl();
        userDao.query();
    }
}
</code></pre>
<p>分析：如此得到了被增强后的 UserDaoImpl，可实现在 query() 前进行日志打印。</p>
<p>UserDaoImpl：目标对象</p>
<p>UserDaoLogImpl ：代理对象。</p>
<p>代理对象和目标对象是相对而言的。UserDaoLogImpl 是代理对象，但是有一天它也有可能成为目标对象。</p>
<p>4、有一个新需求：在 query 方法前添加一个权限验证。</p>
<pre><code class="language-java">public class UserDaoPowerImpl extends UserDaoImpl {
    @Override
    public void query() {
        LogUtil.log(&quot;power...&quot;);
        super.query();
    }
}
</code></pre>
<p>5、有一个新需求：在 query 方法前添加一个时间记录。</p>
<pre><code class="language-java">public class UserDaoTimerImpl extends UserDaoImpl {
    @Override
    public void query() {
        LogUtil.log(&quot;timer...&quot;);
        super.query();
    }
}
</code></pre>
<p>6、有一个新需求：在 query() 方法被调用前既实现日志打印、又实现记录当前时间的功能</p>
<pre><code class="language-java">public class UserDaoTimeAndLogImpl extends UserDaoLogImpl {
    @Override
    public void query() {
        // timer
        LogUtil.log(&quot;timer...&quot;);
        // logger &amp; query
        super.query();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>timer...
logger...
假装查询数据库
</code></pre>
<p>7、新需求：在 query() 前先打印日志，然后再记录时间</p>
<pre><code class="language-java">public class UserDaoLogAndTimeImpl extends UserDaoTimerImpl {
    @Override
    public void query() {
        LogUtil.log(&quot;logger...&quot;);
        // logger
        super.query();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>logger...
timer...
假装查询数据库
</code></pre>
<p>只是改变了以一下日志记录顺序，就会增加一个新的类，不同的排列组合会造成代理类过多。</p>
<h2 id="聚合">聚合</h2>
<ul>
<li>目标对象和代理对象实现同一个接口，代理对象当中要包含目标对象。</li>
<li>缺点：也会产生类爆炸（UserDaoLog implements UserDao、OrderDaoLog implements OrderDao......），只不过比继承少一点点</li>
<li>总结:如果在不确定的情况下，尽量不要去使用静态代理。因为一旦你写代码，就会产生类，一旦产生类就爆炸。</li>
</ul>
<p>1、声明一个接口：</p>
<pre><code class="language-java">public interface UserDao {
    void query();
}
</code></pre>
<p>2、目标对象 UserDaoImpl 实现 UserDao 接口</p>
<pre><code class="language-java">public class UserDaoImpl implements UserDao {
    public void query(){
        System.out.println(&quot;假装查询数据库&quot;);
    }
}
</code></pre>
<p>3、代理对象实现 UserDao 接口，代理对象 UserDaoLog 中包含目标对象 UserDaoImpl（测试类传参为目标对象类）</p>
<pre><code class="language-java">public class UserDaoLog implements UserDao {
    // 装饰者模式：写一个构造方法，通过传入一个目标对象指定代理/ 装饰具体的对象
    UserDao dao;
    public UserDaoLog(UserDao userDao){
        this.dao = userDao;
    }
    @Override
    public void query() {
        LogUtil.log(&quot;logger...&quot;);
        dao.query();
        // 代理模式：new UserDaoImpl().query();UserDao不是传递进来的，是写死的。
    }
}
</code></pre>
<p>4、测试类</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        UserDao target = new UserDaoImpl();
        UserDao proxy = new UserDaoLog(target);
        proxy.query();
    }
}
</code></pre>
<p>测试结果：</p>
<pre><code>logger...
假装查询数据库 
</code></pre>
<p>5、新需求：记录时间</p>
<pre><code class="language-java">public class UserDaoTime implements UserDao {
    UserDao dao;
    public UserDaoTime(UserDao userDao){
        this.dao = userDao;
    }
    @Override
    public void query() {
        LogUtil.log(&quot;timer...&quot;);
        dao.query();
    }
}
</code></pre>
<p>测试类：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        UserDao target = new UserDaoImpl();
        UserDao proxy = new UserDaoTime(target);
        proxy.query();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>timer...
假装查询数据库
</code></pre>
<p>6、新需求：完成对日志和时间的代理，无需新增一个类。只需将时间的代理对象作为目标对象，传递给日志代理对象即可。</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // time + logic(业务逻辑)
        UserDao target = new UserDaoTime(new UserDaoImpl());
        // log + time + logic
        UserDao proxy = new UserDaoLog(target);
        proxy.query();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>logger...
timer...
假装查询数据库
</code></pre>
<p>6、新需求：完成先打印时间，再记录日志的操作。无需新增类，只需修改测试类即可。</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        UserDao target = new UserDaoLog(new UserDaoImpl());
        UserDao proxy = new UserDaoTime(target);
        proxy.query();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>timer...
logger...
假装查询数据库动态代理
</code></pre>
<h2 id="自己模拟的动态代理">自己模拟的动态代理</h2>
<p>如何拿到一个对象？</p>
<p>不需要手动 new 创 建类文件（因为一旦手动创建类文件，就会产生类爆炸），通过接口反射生成一个类文件，然后调用第三方的编译技术，动态编译这个产生的类文件成class文件，继而利用UrlclassLoader(因为这个动态产生的class不在工程当中所以需要使用UrlclassLoader)把这个动态编译的类加载到jvm当中，最后通过反射把这个类实例化。</p>
<p>缺点：首先要生成文件</p>
<p>缺点：动态编译文件 class</p>
<p>缺点：需要一个URLclassloader</p>
<p>软件性能的最终体现在IO操作</p>
<p>file(.java) ---&gt; .class ---&gt; byte[] ---&gt; object(Class 类对象)  ---&gt; object.newInstance()</p>
<h3 id="1准备一个接口">1.准备一个接口：</h3>
<pre><code class="language-java">public interface TestDao {
    String query(String s1, String s2);
}
</code></pre>
<h3 id="2准备一个接口实现类">2.准备一个接口实现类：</h3>
<pre><code class="language-java">public class TestDaoImpl implements TestDao {
    @Override
    public String query(String s1, String s2) {
        System.out.println(&quot;查询数据库&quot;);
        System.out.println(&quot;daoImpl...&quot; + s1 + &quot; &quot; + s2);
        return s1 + &quot; &quot; + s2;
    }
}
</code></pre>
<h3 id="3模拟动态代理">3.模拟动态代理：</h3>
<pre><code class="language-java">package com.ssm.util;

import javax.tools.JavaCompiler;
import javax.tools.StandardJavaFileManager;
import javax.tools.ToolProvider;
import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLClassLoader;
import com.sun.jndi.toolkit.url.UrlUtil;

public class ProxyUtil {

    /**
     * 如何产生一个对象？
     *  content ---&gt; String
     *  .java
     *  .class
     *  .new
     * @param target：目标对象
     * @return
     */
    public static Object newInstance(Object target) throws IOException, IllegalAccessException, InstantiationException, NoSuchMethodException, ClassNotFoundException, InvocationTargetException {
        // targetInterface：目标对象的接口
        Class targetInterface = target.getClass().getInterfaces()[0];

        // 声明最终要返回的代理对象
        Object proxy=null;
        /**
         * package com.ssm.proxyInter;
         *
         * import com.ssm.dao.UserDao;
         *
         * public class UserDaoLog implements UserDao {
         *
         *     private UserDao target;
         *     public UserDaoLog(UserDao target){
         *         this.target = target;
         *     }
         *     @Override
         *     public void query(String p0, String p1) {
         *         System.out.println(&quot;log...&quot;);
         *         target.query(p0,p1);
         *     }
         * }
         * 将上述代码逐行变成字符串
         */
        // 换行
        String line = &quot;\n&quot;;
        // 缩进
        String tab = &quot;\t&quot;;
        // 得到接口名 UserDao
        String interfaceName = targetInterface.getSimpleName();
        // 得到接口中的所有方法 query()
        Method[] methods = targetInterface.getDeclaredMethods();
        String content = &quot;&quot;;
        String packageContent = &quot;package com.ssm;&quot; + line;
        String importContent = &quot;import &quot; + targetInterface.getName() + &quot;;&quot; + line;
        String classFirstLineContent = &quot;public class $Proxy implements &quot; +interfaceName+ &quot;{&quot; + line;
        String fieldContent = tab + &quot;private &quot; + interfaceName + &quot; target;&quot; + line;
        String constructorContent = tab + &quot;public $Proxy (&quot; + interfaceName + &quot; target){&quot; + line
                + tab + tab + &quot;this.target = target; &quot;+ line
                + tab +&quot;}&quot; + line;

        // 参数内容：target.query(p0,p1);
        String paramsContent = &quot;&quot;;
        String methodContent = &quot;&quot;;
        for (Method method : methods){
            // 得到当前方法的返回类型
            String returnType = method.getReturnType().getSimpleName();
            // 得到当前方法的方法名
            String methodName = method.getName();
            // 得到方法的参数类型：如 String.class
            Class[] args = method.getParameterTypes();
            String argsContent = &quot;&quot;;
            for (int i = 0 ; i &lt; args.length ; i++){
                // 得到的是参数类型：如 String
                String temp = args[i].getSimpleName();
                // 最终构造成这个形式：String p0,String p1
                argsContent += temp + &quot; p&quot; + i + &quot;,&quot;;
                paramsContent += &quot;p&quot; + i + &quot;,&quot;;
            }
            // 截取掉最后一个多余的 ','
            if(argsContent.length() &gt; 0){
                argsContent = argsContent.substring(0,argsContent.lastIndexOf(&quot;,&quot;));
                paramsContent = paramsContent.substring(0,paramsContent.lastIndexOf(&quot;,&quot;));
            }
            methodContent += tab + &quot;public &quot; + returnType + &quot; &quot; + methodName + &quot;(&quot; + argsContent + &quot;) {&quot; + line
                    + tab + tab + &quot;System.out.println(\&quot;log\&quot;);&quot; + line;
            // 判断是否有返回值
            if(&quot;void&quot;.equals(returnType)){
                methodContent += tab + tab + &quot;target.&quot; + methodName + &quot;(&quot; + paramsContent + &quot;);&quot; + line
                        + tab + &quot;}&quot; + line;
            }else {
                methodContent += tab + tab + &quot; return target.&quot; + methodName + &quot;(&quot; + paramsContent + &quot;);&quot; + line
                        + tab + &quot;}&quot; + line;
            }

        }

        content = packageContent + importContent + classFirstLineContent + fieldContent + constructorContent + methodContent + &quot;}&quot;;

        File file = new File(&quot;C:\\Users\\Only\\com\\ssm\\$Proxy.java&quot;);
        if(!file.exists()){
            file.createNewFile();
        }
        FileWriter fw = new FileWriter(file);
        fw.write(content);
        fw.flush();
        fw.close();

        // .java ---&gt; .class
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null);
        Iterable units = fileMgr.getJavaFileObjects(file);
        JavaCompiler.CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units);
        t.call();
        fileMgr.close();

        // 通过反射得到构造函数 new 一个对象出来
        URL[] urls = new URL[]{new URL(&quot;file:C:\\Users\\Only\\\\&quot;)};
        URLClassLoader urlClassLoader = new URLClassLoader(urls);
        Class clazz = urlClassLoader.loadClass(&quot;com.ssm.$Proxy&quot;);
        Constructor constructor = clazz.getConstructor(targetInterface);
        proxy = constructor.newInstance(target);

        return proxy;
    }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E6%A8%A1%E6%8B%9F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.png" alt="图片" loading="lazy"></figure>
<h3 id="4测试类">4.测试类</h3>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws IOException, InvocationTargetException, NoSuchMethodException, ClassNotFoundException, InstantiationException, IllegalAccessException {
        TestDao proxy = (TestDao) ProxyUtil.newInstance(new TestDaoImpl());
        String res = proxy.query(&quot;hello&quot;, &quot;world&quot;);
        System.out.println(&quot;res = &quot; + res);
    }
}
</code></pre>
<p>最终运行效果：</p>
<pre><code class="language-java">log
查询数据库
daoImpl...hello world
res = hello world
</code></pre>
<h2 id="代理逻辑动态实现而不是写死的-sout">代理逻辑动态实现，而不是写死的 sout</h2>
<h3 id="1要代理的接口">1.要代理的接口</h3>
<pre><code class="language-java">public interface TestDao {
    String delete() throws Exception;
}
</code></pre>
<h3 id="2目标对象">2.目标对象</h3>
<pre><code class="language-java">public class TestDaoImpl implements TestDao {
    @Override
    public String delete() {
        System.out.println(&quot;dao...delete&quot;);
        return null;
    }
}
</code></pre>
<h3 id="3代理逻辑接口">3.代理逻辑接口</h3>
<pre><code class="language-java">public interface CustomInvocationHandler {
    Object invoke(Method method);
}
</code></pre>
<h3 id="4代理逻辑具体实现">4.代理逻辑具体实现</h3>
<pre><code class="language-java">package com.ssm.test;
import com.ssm.dao.CustomInvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
public class TestCustomHandler implements CustomInvocationHandler {
    private Object target;
    public TestCustomHandler(Object target){
        this.target = target;
    }
    @Override
    public Object invoke(Method method) {
        System.out.println(&quot;TestCustomHandler...&quot;);
        try {
            return method.invoke(target);
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
        return null;
    }
}
</code></pre>
<p>4.自定义动态代理</p>
<pre><code class="language-java">package com.ssm.util;

import javax.tools.JavaCompiler;
import javax.tools.StandardJavaFileManager;
import javax.tools.ToolProvider;
import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLClassLoader;
import com.ssm.dao.CustomInvocationHandler;
import com.sun.jndi.toolkit.url.UrlUtil;
public class ProxyUtil {
    /**
     * 如何产生一个对象？
     *  content ---&gt; String
     *  .java
     *  .class
     *  .new
     * @return
     */
    public static Object newInstance(Class targetInterface, CustomInvocationHandler h) throws IOException, IllegalAccessException, InstantiationException, NoSuchMethodException, ClassNotFoundException, InvocationTargetException {
        // targetInterface：目标对象的接口
//        Class targetInterface = target.getClass().getInterfaces()[0];

        // 声明最终要返回的代理对象
        Object proxy=null;
        /**
         * package com.ssm.proxyInter;
         *
         * import com.ssm.dao.UserDao;
         *
         * public class UserDaoLog implements UserDao {
         *
         *     private UserDao target;
         *     public UserDaoLog(UserDao target){
         *         this.target = target;
         *     }
         *     @Override
         *     public void query(String p0, String p1) {
         *         System.out.println(&quot;log...&quot;);
         *         target.query(p0,p1);
         *     }
         * }
         * 将上述代码逐行变成字符串
         */
        // 换行
        String line = &quot;\n&quot;;
        // 缩进
        String tab = &quot;\t&quot;;
        // 得到接口名 UserDao
        String interfaceName = targetInterface.getSimpleName();
        // 得到接口中的所有方法 query()
        Method[] methods = targetInterface.getDeclaredMethods();
        String content = &quot;&quot;;
        String packageContent = &quot;package com.ssm;&quot; + line;
        String importContent = &quot;import &quot; + targetInterface.getName() + &quot;;&quot; + line
                + &quot;import com.ssm.dao.CustomInvocationHandler;&quot; + line
                + &quot;import java.lang.reflect.Method;&quot; + line;
        String classFirstLineContent = &quot;public class $Proxy implements &quot; +interfaceName+ &quot;{&quot; + line;
        String fieldContent = tab + &quot;private  CustomInvocationHandler h;&quot; + line;
        String constructorContent = tab + &quot;public $Proxy (CustomInvocationHandler h){&quot; + line
                + tab + tab + &quot;this.h = h; &quot;+ line
                + tab +&quot;}&quot; + line;
                
        // 参数内容：target.query(p0,p1);
        String paramsContent = &quot;&quot;;
        String methodContent = &quot;&quot;;
        for (Method method : methods){
            // 得到当前方法的返回类型
            String returnType = method.getReturnType().getSimpleName();
            // 得到当前方法的方法名
            String methodName = method.getName();
            // 得到方法的参数类型：如 String.class
            Class[] args = method.getParameterTypes();
            String argsContent = &quot;&quot;;
            for (int i = 0 ; i &lt; args.length ; i++){
                // 得到的是参数类型：如 String
                String temp = args[i].getSimpleName();
                // 最终构造成这个形式：String p0,String p1
                argsContent += temp + &quot; p&quot; + i + &quot;,&quot;;
                paramsContent += &quot;p&quot; + i + &quot;,&quot;;
            }
            // 截取掉最后一个多余的 ','
            if(argsContent.length() &gt; 0){
                argsContent = argsContent.substring(0,argsContent.lastIndexOf(&quot;,&quot;));
                paramsContent = paramsContent.substring(0,paramsContent.lastIndexOf(&quot;,&quot;));
            }
            methodContent += tab + &quot;public &quot; + returnType + &quot; &quot; + methodName + &quot;(&quot; + argsContent + &quot;) throws Exception {&quot; + line
                    + tab + tab + &quot;Method method = Class.forName(\&quot;&quot; + targetInterface.getName() + &quot;\&quot;).getDeclaredMethod(\&quot;&quot; + methodName + &quot;\&quot;);&quot; + line
                    + tab + tab + &quot;return (&quot;+ returnType +&quot;)h.invoke(method);&quot; + line
                    + tab + &quot;}&quot; + line;
        }

        content = packageContent + importContent + classFirstLineContent + fieldContent + constructorContent + methodContent + &quot;}&quot;;

        File file = new File(&quot;C:\\Users\\Only\\com\\ssm\\$Proxy.java&quot;);
        if(!file.exists()){
            file.createNewFile();
        }
        FileWriter fw = new FileWriter(file);
        fw.write(content);
        fw.flush();
        fw.close();

        // .java ---&gt; .class
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null);
        Iterable units = fileMgr.getJavaFileObjects(file);
        JavaCompiler.CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units);
        t.call();
        fileMgr.close();

        // 通过反射得到构造函数 new 一个对象出来
        URL[] urls = new URL[]{new URL(&quot;file:C:\\Users\\Only\\\\&quot;)};
        URLClassLoader urlClassLoader = new URLClassLoader(urls);
        Class clazz = urlClassLoader.loadClass(&quot;com.ssm.$Proxy&quot;);
        Constructor constructor = clazz.getConstructor(CustomInvocationHandler.class);
        proxy = constructor.newInstance(h);

        return proxy;
    }
}
</code></pre>
<h3 id="5测试类">5.测试类</h3>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws Exception {
//         自定义动态代理
        TestDao proxy = (TestDao) ProxyUtil.newInstance(TestDao.class, new TestCustomHandler(new TestDaoImpl()));
        proxy.delete();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-java">TestCustomHandler...
dao...delete
</code></pre>
<h2 id="jdk动态代理">JDK动态代理</h2>
<p>通过接口反射得到字节码 byte[] ，然后把字节码转成 class：native方法  openJDK  c++</p>
<h3 id="1要代理的接口-2">1.要代理的接口</h3>
<pre><code class="language-java">public interface TestDao {
    String query(String s1, String s2) throws Exception;
}
</code></pre>
<h3 id="2目标对象-2">2.目标对象</h3>
<pre><code class="language-java">public class TestDaoImpl implements TestDao {
    @Override
    public String query(String s1, String s2) {
        System.out.println(&quot;查询数据库&quot;);
        System.out.println(&quot;daoImpl...&quot; + s1 + &quot; &quot; + s2);
        return s1 + &quot; &quot; + s2;
    } 
}
</code></pre>
<h3 id="3代理的逻辑">3.代理的逻辑</h3>
<pre><code class="language-java">package com.ssm.util;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class TestInvocationHandler implements InvocationHandler {
    Object target;

    /**
     *
     * @param target 目标对象
     */
    public TestInvocationHandler(Object target){
        this.target = target;
    }
    /**
     *
     * @param proxy 代理对象 $Proxy
     * @param method 目标对象 TestDao
     * @param args 目标方法的参数
     * @return
     * @throws Throwable
     *
     * 根据代理的逻辑执行：即打印 TestInvocationHandler...proxy
     * 执行目标对象的方法 ，即 TestDao 的 query()
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;TestInvocationHandler...proxy&quot;);
        return method.invoke(target,args);
    }
}
</code></pre>
<h3 id="4测试类-2">4.测试类</h3>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws Exception {

        /**
         * JDK 动态代理
         * 参数：要代理哪些接口；new Class[]{TestDao.class}：TestDao 下所有方法的代理。
         *       代理的逻辑：new TestInvocationHandler(new TestDaoImpl())：在每个方法前打印 TestInvocationHandler...proxy
         */
        TestDao jdkProxy = (TestDao) Proxy.newProxyInstance(Test.class.getClassLoader(),
                new Class[]{TestDao.class},
                new TestInvocationHandler(new TestDaoImpl()));
        String result = jdkProxy.query(&quot;hello&quot;, &quot;world&quot;);
        System.out.println(&quot;result = &quot; + result);

    }
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-java">TestInvocationHandler...proxy
查询数据库
daoImpl...hello world
result = hello world
</code></pre>
<h3 id="jdk-动态代理分析">JDK 动态代理分析</h3>
<p>JDK 动态代理：</p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1.png" alt="图片" loading="lazy"></figure>
<p>自定义动态代理：</p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1.png" alt="图片" loading="lazy"></figure>
<h4 id="代理类">代理类</h4>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E4%BB%A3%E7%90%86%E7%B1%BB.png" alt="图片" loading="lazy"></figure>
<h4 id="得到代理类的构造方法">得到代理类的构造方法</h4>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/%E5%BE%97%E5%88%B0%E4%BB%A3%E7%90%86%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png" alt="图片" loading="lazy"></figure>
<h4 id="使用代理类的构造方法-new-一个对象出来">使用代理类的构造方法 new 一个对象出来</h4>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95new%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%87%BA%E6%9D%A5.png" alt="图片" loading="lazy"></figure>
<h4 id="class-cl-getproxyclass0loader-intfs">Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</h4>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/getProxyClass0.png" alt="图片" loading="lazy"></figure>
<h4 id="public-v-getk-key-p-parameter">public V get(K key, P parameter) {</h4>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/get.png" alt="图片" loading="lazy"></figure>
<h4 id="debugger">debugger</h4>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/debugger.png" alt="图片" loading="lazy"></figure>
<h4 id="v-value-supplierget">V value = supplier.get();</h4>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/suppiler.get.png" alt="图片" loading="lazy"></figure>
<h4 id="public-synchronized-v-get">public synchronized V get() {</h4>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/%E8%BF%94%E5%9B%9Evalue.png" alt="图片" loading="lazy"></figure>
<h4 id="value-objectsrequirenonnullvaluefactoryapplykey-parameter">value = Objects.requireNonNull(valueFactory.apply(key, parameter))</h4>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/requireNonNull.png" alt="图片" loading="lazy"></figure>
<h4 id="public-class-applyclassloader-loader-class-interfaces">public Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {</h4>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/apply.png" alt="图片" loading="lazy"></figure>
<h4 id="使用类加载器判断是否是同一个对象">使用类加载器判断是否是同一个对象</h4>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1.png" alt="图片" loading="lazy"></figure>
<h4 id="判断接口的权限修饰符">判断接口的权限修饰符</h4>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/%E5%88%A4%E6%96%AD%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6.png" alt="图片" loading="lazy"></figure>
<h4 id="string-proxyname-proxypkg-proxyclassnameprefix-num">String proxyName = proxyPkg + proxyClassNamePrefix + num;</h4>
<figure data-type="image" tabindex="16"><img src="https://epitomm.github.io/post-images/proxyName.png" alt="图片" loading="lazy"></figure>
<p>类名加上标识0，是为了防止并发情况下产生问题。</p>
<h4 id="byte-proxyclassfile-proxygeneratorgenerateproxyclassproxyname-interfaces-accessflags">byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</h4>
<figure data-type="image" tabindex="17"><img src="https://epitomm.github.io/post-images/generateProxyClass.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="18"><img src="https://epitomm.github.io/post-images/JDK%E4%BB%A3%E7%90%86%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring系列（二）SpringAOP 应用]]></title>
        <id>https://epitomm.github.io/post/springaop-ying-yong/</id>
        <link href="https://epitomm.github.io/post/springaop-ying-yong/">
        </link>
        <updated>2020-05-02T07:55:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="自定义注解">自定义注解</h1>
<h2 id="xml-的作用">xml 的作用？</h2>
<p>答：<strong>描述数据</strong>。<br>
举例：数据库中有一张 user 表，项目中有一个 User 类，如何将 User 类与 user 表<strong>关联</strong>？<br>
答：使用 xml 来描述元数据。<br>
那为什么还要有自定义注解呢？因为xml 开发过程过于复杂。</p>
<h2 id="自定义注解-2">自定义注解</h2>
<h3 id="一-准备阶段">一、准备阶段</h3>
<h4 id="1定义实体类">1.定义实体类</h4>
<pre><code class="language-java">package com.ssm.entity;

import com.ssm.anno.Entity;

public class CityEntity {

    private Integer id;
    private String name;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
</code></pre>
<h4 id="2定义工具类">2.定义工具类</h4>
<pre><code class="language-java">package com.ssm.util;

public class CommonUtil {
    /**
     * 通过一个对象构建一条查询的 sql 语句
     * @param obj
     */
    public static String buildQuerySqlForEntity(Object obj){

        // 表名、字段应该根据传入的值动态变化，不应该写死
        // 办法：在实体类 CityEntity 中加入注解 @Table（需要导入JPA），我们使用自定义注解来实现
        String sql = &quot;select * from ? where id=? and name=?&quot;;

        return null;
    }
}
</code></pre>
<h4 id="3测试方法">3.测试方法</h4>
<pre><code class="language-java">package com.ssm.util;

public class CommonUtil {
    /**
     * 通过一个对象构建一条查询的 sql 语句
     * @param obj
     */
    public static String buildQuerySqlForEntity(Object obj){

        // 表名、字段应该根据传入的值动态变化，不应该写死
        // 办法：在实体类 CityEntity 中加入注解 @Table（需要导入JPA），我们使用自定义注解来实现
        String sql = &quot;select * from ? where id=? and name=?&quot;;

        return null;
    }
}
</code></pre>
<h3 id="二-自定义注解基本功能">二、自定义注解——基本功能</h3>
<h4 id="1自定义注解">1.自定义注解</h4>
<pre><code class="language-java">public @interface Entity {
    public String value();
}
</code></pre>
<h4 id="2实体类添加注解">2.实体类添加注解</h4>
<pre><code class="language-java">// 注解里面的 value 方法，返回值是 String 类型
@Entity(value = &quot;city&quot;)
public class CityEntity {
</code></pre>
<h3 id="三-自定义注解元注解">三、自定义注解——元注解</h3>
<h4 id="1实体类体会元注解">1.实体类体会元注解</h4>
<pre><code class="language-java">//@Override   
// @Override' not applicable to type：@Override 不适用修饰类
public class CityEntity {

// @Override   
// Method does not override method from its superclass：没有父类重写的方法。表名 @Override 注解可用于修饰方法
    public void setId(Integer id) {
        this.id = id;
    }    
</code></pre>
<p>分析得知：@Override 注解可用于修饰方法，不可用于修饰类。<br>
于是我们来改动一下我们的自定义注解 @Entity，让它只能用于修饰类，不能用于修饰方法。</p>
<h4 id="2修改自定义注解类">2.修改自定义注解类</h4>
<pre><code class="language-java">// @Entity 注解能够出现的目标位置：TYPE：类
@Target(ElementType.TYPE)
// @Target({ElementType.TYPE, ElementType.FIELD})：指定多个可以出现的位置：类、
public @interface Entity {
    public String value();
}
</code></pre>
<h3 id="四-获得注解内的值">四、获得注解内的值</h3>
<pre><code class="language-java">package com.ssm.util;

import com.ssm.anno.Entity;

import java.lang.annotation.Annotation;

public class CommonUtil {
    public static String buildQuerySqlForEntity(Object obj){
        // 得到类的类对象
        Class clazz = obj.getClass();
        // setup1 判断是否加了这个注解
        if(clazz.isAnnotationPresent(Entity.class)){
            // setup2 得到注解
            Entity entity = (Entity) clazz.getDeclaredAnnotation(Entity.class);
            // setup3 调用方法
            String value = entity.value();
            System.out.println(value);  // city
        }

        // 表名、字段应该根据传入的值动态变化，不应该写死
        // 办法：在实体类 CityEntity 中加入注解 @Table（需要导入JPA），我们使用自定义注解来实现
        String sql = &quot;select * from ? where id=? and name=?&quot;;

        return null;
    }
}
</code></pre>
<h2 id="注解生命周期">注解生命周期</h2>
<h3 id="retentionretentionpolicysource">@Retention(RetentionPolicy.SOURCE)</h3>
<p>注解的生命周期：默认情况下仅仅存在于 Java 源码中，即@Retention(RetentionPolicy.SOURCE)，当 JVM 一旦把它编译成字节码，注解会自动丢失。<br>
<img src="https://epitomm.github.io/post-images/%E6%B3%A8%E8%A7%A3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9FSOURCE.png" alt="图片" loading="lazy"></p>
<h3 id="retentionretentionpolicyclass">@Retention(RetentionPolicy.CLASS)</h3>
<p>会存在于 .class 文件中，但是在代码被运行时还是会被 JVM 忽略。<br>
<img src="https://epitomm.github.io/post-images/%E6%B3%A8%E8%A7%A3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9FCLASS.png" alt="图片" loading="lazy"><br>
测试：</p>
<pre><code class="language-java">package com.ssm.util;

import com.ssm.anno.Entity;

public class CommonUtil {

    public static String buildQuerySqlForEntity(Object obj){
        // 得到类的类对象
        Class clazz = obj.getClass();
        // setup1 判断是否加了这个注解
        boolean b = clazz.isAnnotationPresent(Entity.class); // false
        System.out.println(b);

        return null;
    }
}
</code></pre>
<h3 id="retentionretentionpolicyruntime">@Retention(RetentionPolicy.RUNTIME)</h3>
<p>只有当注解的生命周期声明为 RUNTIME 时，在执行时才会被 JVM 发觉到。<br>
boolean b = clazz.isAnnotationPresent(Entity.class);//true</p>
<h1 id="aop-是什么">AOP 是什么</h1>
<p>与OOP对比，面向切面，传统的OOP开发中的代码逻辑是自上而下的，而这些过程会产生一些横切性问题，这些横切性的问题和我们的主业务逻辑关系不大，这些横切性问题不会影响到主逻辑实现的，但是会散落到代码的各个部分，难以维护。AOP是处理一些横切性问题，AOP的编程思想就是把这些问题和主业务逻辑分开，达到与主业务逻辑解耦的目的。使代码的重用性和开发效率更高。<br>
<img src="https://epitomm.github.io/post-images/AOP%E6%98%AF%E4%BB%80%E4%B9%88.png" alt="图片" loading="lazy"></p>
<h2 id="aop-的应用场景">AOP 的应用场景</h2>
<ol>
<li>日志记录</li>
<li>权限验证</li>
<li>效率检查</li>
<li>事务管理</li>
<li>exception</li>
</ol>
<h2 id="springaop-的底层技术">SpringAOP 的底层技术</h2>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">JDK动态代理</th>
<th style="text-align:center">CGLIB代理</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">编译时期的织入还是运行时期的织入?</td>
<td style="text-align:center">运行时期织入</td>
<td style="text-align:center">运行时期织入</td>
</tr>
<tr>
<td style="text-align:center">初始化时期织入还是获取对象时期织入？</td>
<td style="text-align:center">初始化时期织入</td>
<td style="text-align:center">初始化时期织入</td>
</tr>
</tbody>
</table>
<h2 id="springaop-和-aspectj-的关系">SpringAOP 和 AspectJ 的关系</h2>
<p>AOP 是一种概念<br>
SpringAOP、AspectJ 都是 AOP 的实现，SpringAOP 有自己的语法，但是语法复杂，所以SpringAOP 借助了AspectJ 的注解，但是底层实现还是自己的<br>
AspectJ 是静态注入：编译（.java -&gt; .class）时就完成了注入，SpringAOP是动态注入：运行时才注入</p>
<pre><code>spring AOP提供两种编程风格
@AspectJ support         ------------&gt;利用aspectj的注解
Schema-based AOP support -----------&gt;xml aop:config 命名空间

证明:spring,通过源  码分析了,我们可以知道spring底层使用的是JDK或者CGLIB来完成的代理,并且在官网上spring给出了aspectj的文档,和springAOP是不同的
</code></pre>
<p>如果您只需要建议在Spring bean上执行操作，那么Spring AOP是正确的选择。如果需要通知Spring容器没有管理的对象(通常是域对象)，则需要使用AspectJ。<br>
Spring AOP的概念<br>
参考链接：<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-introduction-defn">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-introduction-defn</a></p>
<ul>
<li>aspect:一定要给spring去管理  抽象  aspectj-&gt;类</li>
<li>pointcut:切点表示连接点的集合  -----------------&gt;   表 （我的理解：PointCut是JoinPoint的谓语，这是一个动作，主要是告诉通知连接点在哪里，切点表达式决定 JoinPoint 的数量）</li>
<li>Joinpoint:连接点   目标对象中的方法 ----------------&gt;    记录（我的理解：JoinPoint是要关注和增强的方法，也就是我们要作用的点）</li>
<li>Weaving :把代理逻辑加入到目标对象上的过程叫做织入</li>
<li>target 目标对象 原始对象</li>
<li>aop Proxy 代理对象  包含了原始对象的代码和增加后的代码的那个对象</li>
<li>advice:通知    (位置 + logic)</li>
</ul>
<h2 id="aspect-切面">Aspect 切面</h2>
<blockquote>
<p>Aspect: A modularization of a concern that cuts across multiple classes. Transaction management is a good example of a crosscutting concern in enterprise Java applications. In Spring AOP, aspects are implemented by using regular classes (the schema-based approach) or regular classes annotated with the @Aspect annotation (the @AspectJ style).</p>
</blockquote>
<p>切面是：通知、切点、连接点的载体。通知、连接点要放到哪里去，好比 Java 中的属性、方法、构造方法，这些东西要放到哪里去？放到一个类里面，这个类就是方法以及参数属性的载体。切面就是连接点、切点、通知的载体，把这些连接点、切点、通知所在的位置称之为一个切面。</p>
<h2 id="join-point-连接点">Join point 连接点</h2>
<blockquote>
<p>Join point: A point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution.</p>
</blockquote>
<p>连接点：程序执行过程中的一个点，如方法的执行或异常的处理。在Spring AOP中，连接点总是表示方法执行。<br>
<img src="https://epitomm.github.io/post-images/AOP%E8%BF%9E%E6%8E%A5%E7%82%B9.png" alt="图片" loading="lazy"><br>
ProceedingJoinPoint 和 JoinPoint 的区别:<br>
ProceedingJoinPoint  继承了JoinPoint ,proceed()这个是aop代理链执行的方法。并扩充实现了proceed()方法，用于继续执行连接点。JoinPoint 仅能获取相关参数，无法执行连接点。<br>
JoinPoint 的方法：</p>
<ol>
<li>java.lang.Object[] getArgs()：获取连接点方法运行时的入参列表；</li>
<li>Signature getSignature() ：获取连接点的方法签名对象；</li>
<li>java.lang.Object getTarget() ：获取连接点所在的目标对象；</li>
<li>java.lang.Object getThis() ：获取代理对象本身；<br>
proceed()有重载,有个带参数的方法,可以修改目标方法的的参数</li>
</ol>
<p>Advice 通知<br>
Advice: Action taken by an aspect at a particular join point. Different types of advice include “around”, “before” and “after” advice. (Advice types are discussed later.) Many AOP frameworks, including Spring, model an advice as an interceptor and maintain a chain of interceptors around the join point.<br>
<img src="https://epitomm.github.io/post-images/AOP%E9%80%9A%E7%9F%A5.png" alt="图片" loading="lazy"></p>
<ul>
<li>advice通知类型:</li>
<li>Before 连接点执行之前，但是无法阻止连接点的正常执行，除非该段执行抛出异常</li>
<li>After  连接点正常执行之后，执行过程中正常执行返回退出，非异常退出</li>
<li>After throwing  执行抛出异常的时候</li>
<li>After (finally)  无论连接点是正常退出还是异常退出，都会执行</li>
<li>Around advice: 围绕连接点执行，例如方法调用。这是最有用的切面方式。around通知可以在方法调用之前和之后执行自定义行为。它还负责选择是继续加入点还是通过返回自己的返回值或抛出异常来快速建议的方法执行。</li>
</ul>
<h3 id="after">After</h3>
<pre><code class="language-java">@After(&quot;pointCutTarget()&quot;)
public void after(){
    System.out.println(&quot;after&quot;);
}
</code></pre>
<h3 id="before">Before</h3>
<pre><code class="language-java">@Before(&quot;pointCut()&quot;)
public void before(JoinPoint joinPoint){
    System.out.println(&quot;before&quot;);
    System.out.println(joinPoint.getThis());
    System.out.println(joinPoint.getTarget());
}
</code></pre>
<p>断点调试：<br>
1、joinPoint.getThis()<br>
<img src="https://epitomm.github.io/post-images/%E8%BF%9E%E6%8E%A5%E7%82%B9%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_1.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/%E8%BF%9E%E6%8E%A5%E7%82%B9%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_2.png" alt="图片" loading="lazy"><br>
2、joinPoint.getTarget()<br>
<img src="https://epitomm.github.io/post-images/%E8%BF%9E%E6%8E%A5%E7%82%B9%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_3.png" alt="图片" loading="lazy"></p>
<h3 id="around">Around</h3>
<p>在通知中拿到连接点，然后执行连接点。</p>
<pre><code class="language-java">@Around(&quot;pointCut()&quot;)
// ProceedingJoinPoint：正在进行的 JointPoint：正在增强的方法
public void around(ProceedingJoinPoint pjp) throws Throwable {
    System.out.println(&quot;around...before&quot;);
    // 拿到方法并执行它
    pjp.proceed();
    System.out.println(&quot;around...after&quot;);
}
</code></pre>
<p>测试结果：</p>
<pre><code>around...before
query
around...after
</code></pre>
<h3 id="xml-通知">XML 通知</h3>
<p>1、编写 xml，定义切面、连接点、通知</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                         http://www.springframework.org/schema/beans/spring-beans.xsd
                         http://www.springframework.org/schema/aop
                         http://www.springframework.org/schema/aop/spring-aop.xsd
                         http://www.springframework.org/schema/context
                         http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:component-scan base-package=&quot;com.ssm&quot;/&gt;
    &lt;!-- 定义一个切面 --&gt;
    &lt;aop:config&gt;
        &lt;!-- 定义一个连接点 --&gt;
        &lt;aop:pointcut id=&quot;allDao&quot; expression=&quot;execution(* com.ssm.dao.*.*(..))&quot;/&gt;
        &lt;!-- 通知包含两部分：位置 pointcut-ref 、逻辑 ref --&gt;
        &lt;aop:aspect id=&quot;aspect&quot; ref=&quot;xmlBean&quot;&gt;
            &lt;aop:before pointcut-ref=&quot;allDao&quot;
                    method=&quot;before&quot;/&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;

    &lt;bean id=&quot;xmlBean&quot; class=&quot;com.ssm.app.XMLAopBean&quot;/&gt;
    &lt;bean id=&quot;indexDao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p>2、编写通知的逻辑</p>
<pre><code class="language-java">public class XMLAopBean {
    public void before(){
        System.out.println(&quot;xml before...&quot;);
    }
}
</code></pre>
<p>3、测试</p>
<pre><code class="language-java">public class TestXML {
    public static void main(String[] args) throws IOException {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
        IndexDao dao = (IndexDao) context.getBean(&quot;indexDao&quot;);
        dao.query(&quot;hello&quot;);
    }
}
</code></pre>
<p>4、运行结果</p>
<pre><code>xml before...
query
hello
</code></pre>
<h4 id="环绕通知中改变参数值">环绕通知中改变参数值</h4>
<p>1、传递进来的参数为 &quot;hello&quot;</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws IOException {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        IndexDao dao = (IndexDao) context.getBean(&quot;indexDao&quot;);
        dao.query(&quot;hello&quot;);
    }
}
</code></pre>
<p>2、在环绕通知内将参数修改为  hello  world</p>
<pre><code class="language-java">@Around(&quot;pointCut()&quot;)
// ProceedingJoinPoint：正在进行的 JointPoint：正在增强的方法 
public void around(ProceedingJoinPoint pjp) throws Throwable {
    Object[] args = pjp.getArgs();
    if(args != null &amp;&amp; args.length &gt; 0){
        for (int i = 0; i &lt; args.length; i++) {
            args[i] += &quot; world&quot;;
        }
    }
    System.out.println(&quot;around...before&quot;);
    // 拿到方法并执行它
    pjp.proceed(args);
    System.out.println(&quot;around...after&quot;);
}
</code></pre>
<p>3、输出参数值</p>
<pre><code class="language-java">@Repository(&quot;indexDao&quot;)
public class IndexDaoImpl implements IndexDao {
    @Override
    public void query(String str){
        System.out.println(&quot;query&quot;);
        System.out.println(str);
    }
}
</code></pre>
<p>4、输出结果：</p>
<pre><code>around...before
query
hello world
around...after
</code></pre>
<h2 id="pointcut-切点">Pointcut 切点</h2>
<blockquote>
<p>Pointcut: A predicate that matches join points. Advice is associated with a pointcut expression and runs at any join point matched by the pointcut (for example, the execution of a method with a certain name). The concept of join points as matched by pointcut expressions is central to AOP, and Spring uses the AspectJ pointcut expression language by default.</p>
</blockquote>
<p>切点：连接点的集合。<br>
<img src="https://epitomm.github.io/post-images/AOP%E5%88%87%E7%82%B9.png" alt="图片" loading="lazy"></p>
<h2 id="introduction">Introduction</h2>
<blockquote>
<p>Introduction: Declaring additional methods or fields on behalf of a type. Spring AOP lets you introduce new interfaces (and a corresponding implementation) to any advised object. For example, you could use an introduction to make a bean implement an IsModified interface, to simplify caching. (An introduction is known as an inter-type declaration in the AspectJ community.)</p>
</blockquote>
<h3 id="实例">实例</h3>
<p>1、准备一个 IndexDao 接口</p>
<pre><code class="language-java">public interface IndexDao {
    void query(String str);
}
</code></pre>
<p>2、准备一个 IndexDao 接口的实现类</p>
<pre><code class="language-java">@Repository(&quot;indexDao&quot;)
public class IndexDaoImpl implements IndexDao {
    @Override
    public void query(String str){
        System.out.println(&quot;query&quot;);
        System.out.println(str);
    }
}
</code></pre>
<p>3、再准备一个接口 OrderDAO，并把它注入到 Spring 容器中</p>
<pre><code class="language-java">@Repository(&quot;orderDao&quot;)
public class OrderDao {
}
</code></pre>
<p>4、引入</p>
<pre><code class="language-java">@Component
// 切面
@Aspect
public class NotVeryUsefulAspect {
     // 找到 com.ssm.dao 下的所有类，让它引入 IndexDao 接口的 IndexDaoImpl 实现，
    // 即让 class OrderDao implements IndexDao，并且方法的具体实现与 IndexDaoImpl 相同
    @DeclareParents(value=&quot;com.ssm.dao.*&quot;, defaultImpl= IndexDaoImpl.class)
    public static IndexDao indexDao;
}
</code></pre>
<p>5、测试</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws IOException {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        IndexDao dao = (IndexDao) context.getBean(&quot;orderDao&quot;);
        dao.query(&quot;hello&quot;);
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>query
hello
</code></pre>
<p>6、分析：orderDao 内并没有方法，但是获得容器内的 OrderDao 对象后却可以正常调用  query() 方法，原因就是使用了 Introduction。</p>
<h2 id="aspect-instantiation-models">Aspect Instantiation Models</h2>
<p>使用方式如下：<br>
@Aspect(&quot;perthis(this(com.chenss.dao.IndexDaoImpl))&quot;)<br>
要求：</p>
<ol>
<li>AspectJ对象的注入类型为prototype</li>
<li>目标对象也必须是prototype的<br>
原因为：只有目标对象是原型模式的，每次getBean得到的对象才是不一样的，由此针对每个对象就会产生新的切面对象，才能产生不同的切面结果。</li>
</ol>
<h3 id="示例">示例</h3>
<p>1、多例的 IndexDaoImpl</p>
<pre><code class="language-java">@Repository(&quot;indexDao&quot;)
@Scope(&quot;prototype&quot;)
public class IndexDaoImpl implements IndexDao {
</code></pre>
<p>2、单例的切面</p>
<pre><code class="language-java">@Component
@Aspect
public class NotVeryUsefulAspect {
    // 切点 com.ssm.dao 下的子包下的任意类的任意方法 任意返回值 任意修饰符
    @Pointcut(&quot;execution(* com.ssm.dao.*.*(..))&quot;)
    public void pointCut(){
    }

    @Around(&quot;pointCut()&quot;)
    // ProceedingJoinPoint：正在进行的 JointPoint：正在增强的方法
    public void around(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println(&quot;this.hashCode = &quot; + this.hashCode());
        Object[] args = pjp.getArgs();
        if(args != null &amp;&amp; args.length &gt; 0){
            for (int i = 0; i &lt; args.length; i++) {
                args[i] += &quot; world&quot;;
            }
        }
        System.out.println(&quot;around...before&quot;);
        // 拿到方法并执行它
        pjp.proceed(args);
        System.out.println(&quot;around...after&quot;);
    }
}
</code></pre>
<p>3、测试类</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws IOException {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        IndexDao dao = (IndexDao) context.getBean(&quot;indexDao&quot;);
        IndexDao dao1 = (IndexDao) context.getBean(&quot;indexDao&quot;);
        // com.ssm.dao.impl.IndexDaoImpl@24aed80c : com.ssm.dao.impl.IndexDaoImpl@3a52dba3
        System.out.println(dao+&quot; : &quot;+dao1);
        dao.query(&quot;hello&quot;);
        System.out.println(&quot; - - - - - - - - - - - &quot;);
        dao1.query(&quot;hi&quot;);
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>com.ssm.dao.impl.IndexDaoImpl@24aed80c : com.ssm.dao.impl.IndexDaoImpl@3a52dba3
this.hashCode = 1792550665
around...before
query
hello world
around...after
 - - - - - - - - - - - 
this.hashCode = 1792550665
around...before
query
hi world
around...after
</code></pre>
<p>4、分析：<br>
当 IndexDaoImpl 设置为原型时，两次 context.getBean(&quot;indexDaoImpl&quot;) 得到的 IndexDaoImpl 是不同的对象。但是不同的 bean 对象得到的切面却是完全相同的。</p>
<p>更改：AspectJ 对象的注入类型为 prototype，为所有代理对象是 IndexDaoImpl 的单独创建一个切点出来</p>
<pre><code class="language-java">@Component
// 为所有代理对象是 IndexDaoImpl 的单独创建一个切点出来
@Aspect(&quot;perthis(this(com.ssm.dao.impl.IndexDaoImpl))&quot;)
@Scope(&quot;prototype&quot;)
public class NotVeryUsefulAspect {
</code></pre>
<p>CJLIB 动态代理</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
// 开启 AspectJ 语法支持
@EnableAspectJAutoProxy(proxyTargetClass=true)
public class AppConfig {
}
</code></pre>
<p>运行结果：</p>
<pre><code>com.ssm.dao.impl.IndexDaoImpl@672872e1 : com.ssm.dao.impl.IndexDaoImpl@32910148
this.hashCode = 254801937
around...before
query
hello world
around...after
 - - - - - - - - - - - 
this.hashCode = 90767234
around...before
query
hi world
around...after
</code></pre>
<h2 id="target-object目标对象">Target object：目标对象</h2>
<blockquote>
<p>Target object: An object being advised by one or more aspects. Also referred to as the “advised object”. Since Spring AOP is implemented by using runtime proxies, this object is always a proxied object.</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/AOP%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1.png" alt="图片" loading="lazy"></figure>
<h2 id="aop-proxy-代理对象">AOP proxy 代理对象</h2>
<blockquote>
<p>AOP proxy: An object created by the AOP framework in order to implement the aspect contracts (advise method executions and so on). In the Spring Framework, an AOP proxy is a JDK dynamic proxy or a CGLIB proxy.</p>
</blockquote>
<h2 id="weaving">Weaving</h2>
<blockquote>
<p>Weaving: linking aspects with other application types or objects to create an advised object. This can be done at compile time (using the AspectJ compiler, for example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks, performs weaving at runtime.</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/AOP%E7%BB%87%E5%85%A5.png" alt="图片" loading="lazy"></figure>
<h1 id="springaop-支持-aspectj">SpringAOP 支持 AspectJ</h1>
<p>AOP 和 SpringAOP 的 关系？SpringAOP 是 AOP 的一种实现。<br>
实现 AOP 的技术：AspectJ、SpringAOP<br>
SpringAOP 和 AspectJ 的关系？Spring 原先版本的 AOP 语法过于繁琐，于是 Spring 借助了 AspectJ 的语法，底层技术还是用的 Spring 底层的技术。<br>
参考资料：<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-ataspectj">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-ataspectj</a></p>
<h2 id="0-导入-spring-依赖">0、导入 Spring 依赖</h2>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
  &lt;version&gt;5.0.9.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>准备一个 IndexDao：</p>
<pre><code class="language-java">@Repository
public class IndexDao {
    public void query(){
        System.out.println(&quot;query&quot;);
    }
}
</code></pre>
<h2 id="1-启用aspectj支持">1、启用@AspectJ支持</h2>
<p>使用Java Configuration启用@AspectJ支持<br>
要使用Java @Configuration启用@AspectJ支持，请添加@EnableAspectJAutoProxy注释</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
@EnableAspectJAutoProxy
public class AppConfig {

}
</code></pre>
<p>使用XML配置启用@AspectJ支持<br>
要使用基于xml的配置启用@AspectJ支持，可以使用aop:aspectj-autoproxy元素</p>
<pre><code class="language-xml">&lt;aop:aspectj-autoproxy/&gt;
</code></pre>
<h2 id="2-声明一个aspect">2、声明一个Aspect</h2>
<p>引入 Aspect 依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
  &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
  &lt;version&gt;1.9.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>声明一个@Aspect注释类，并且定义成一个bean交给Spring管理。</p>
<pre><code class="language-java">@Component
@Aspect
public class UserAspect {
}
</code></pre>
<h2 id="3-声明一个pointcut">3、声明一个PointCut</h2>
<p>切入点表达式由@Pointcut注释表示。切入点声明由两部分组成:一个签名包含名称和任何参数，以及一个切入点表达式，该表达式确定我们对哪个方法执行感兴趣。</p>
<pre><code class="language-java">@Pointcut(&quot;execution(* transfer(..))&quot;)// 切入点表达式
private void anyOldTransfer() {}// 切入点签名
</code></pre>
<p>切入点确定感兴趣的 join points（连接点），从而使我们能够控制何时执行通知。Spring AOP只支持Spring bean的方法执行 join points（连接点），所以您可以将切入点看作是匹配Spring bean上方法的执行。</p>
<pre><code class="language-java">/**
 * 申明Aspect，并且交给spring容器管理
 */
@Component
@Aspect
public class UserAspect {
    /**
     * 申明切入点，匹配UserDao所有方法调用
     * execution匹配方法执行连接点
     * within:将匹配限制为特定类型中的连接点
     * args：参数
     * target：目标对象
     * this：代理对象
     */
    @Pointcut(&quot;execution(* com.yao.dao.UserDao.*(..))&quot;)
    public void pintCut(){
        System.out.println(&quot;point cut&quot;);
    }
</code></pre>
<h2 id="4-声明一个advice通知">4、声明一个Advice通知</h2>
<p>advice通知与pointcut切入点表达式相关联，并在切入点匹配的方法执行@Before之前、@After之后或前后运行。</p>
<pre><code class="language-java">/**
 * 申明Aspect，并且交给spring容器管理
 */
@Component
@Aspect
public class UserAspect {
    /**
     * 申明切入点，匹配UserDao所有方法调用
     * execution匹配方法执行连接点
     * within:将匹配限制为特定类型中的连接点
     * args：参数
     * target：目标对象
     * this：代理对象
     */
    @Pointcut(&quot;execution(* com.yao.dao.UserDao.*(..))&quot;)
    public void pintCut(){
        System.out.println(&quot;point cut&quot;);
    }
    /**
     * 申明before通知,在pintCut切入点前执行
     * 通知与切入点表达式相关联，
     * 并在切入点匹配的方法执行之前、之后或前后运行。
     * 切入点表达式可以是对指定切入点的简单引用，也可以是在适当位置声明的切入点表达式。
     */
    @Before(&quot;com.yao.aop.UserAspect.pintCut()&quot;)
    public void beforeAdvice(){
        System.out.println(&quot;before&quot;);
    }
}
</code></pre>
<p>测试类：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        IndexDao dao = context.getBean(IndexDao.class);
        dao.query();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>before
query
</code></pre>
<h1 id="各种连接点-joinpoint-的意义">各种连接点 JoinPoint 的意义:</h1>
<h2 id="execution">execution</h2>
<p>用于匹配方法执行连接点，最小粒度方法，在aop中主要使用。</p>
<pre><code class="language-java">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern)
          throws-pattern?)
</code></pre>
<p>这里问号表示当前项可以有也可以没有，其中各项的语义如下：<br>
modifiers-pattern：方法的可见性，如public，protected；<br>
ret-type-pattern：方法的返回值类型，如int，void等；<br>
declaring-type-pattern：方法所在类的全路径名，如com.spring.Aspect；<br>
name-pattern：方法名类型，如 buisinessService()；<br>
param-pattern：方法的参数类型，如java.lang.String；<br>
throws-pattern：方法抛出的异常类型，如java.lang.Exception；</p>
<h3 id="examples">Examples</h3>
<p>@Pointcut(&quot;execution(* com.chenss.dao.<em>.</em>(..))&quot;)//匹配com.chenss.dao包下的任意接口和类的任意方法【方法返回值类型任意，方法所在类的全路径名：com.chenss.dao，方法名类型任意，方法的参数类型任意】<br>
@Pointcut(&quot;execution(public * com.chenss.dao.<em>.</em>(..))&quot;)//匹配com.chenss.dao包下的任意接口和类的public方法<br>
@Pointcut(&quot;execution(public * com.chenss.dao.<em>.</em>())&quot;)//匹配com.chenss.dao包下的任意接口和类的public 无方法参数的方法<br>
@Pointcut(&quot;execution(* com.chenss.dao.<em>.</em>(java.lang.String, ..))&quot;)//匹配com.chenss.dao包下的任意接口和类的第一个参数为String类型的方法<br>
@Pointcut(&quot;execution(* com.chenss.dao.<em>.</em>(java.lang.String))&quot;)//匹配com.chenss.dao包下的任意接口和类的只有一个参数，且参数为String类型的方法<br>
@Pointcut(&quot;execution(* com.chenss.dao.<em>.</em>(java.lang.String))&quot;)//匹配com.chenss.dao包下的任意接口和类的只有一个参数，且参数为String类型的方法<br>
@Pointcut(&quot;execution(public * <em>(..))&quot;)//匹配任意的public方法<br>
@Pointcut(&quot;execution(</em> te*(..))&quot;)//匹配任意的以te开头的方法<br>
@Pointcut(&quot;execution(* com.chenss.dao.IndexDao.<em>(..))&quot;)//匹配com.chenss.dao.IndexDao接口中任意的方法<br>
@Pointcut(&quot;execution(</em> com.chenss.dao..<em>.</em>(..))&quot;)//匹配com.chenss.dao包及其子包中任意的方法</p>
<p>关于这个表达式的详细写法,可以脑补也可以参考官网很容易的,可以作为一个看spring官网文档的入门,打破你害怕看官方文档的心理,其实你会发觉官方文档也是很容易的<br>
<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-pointcuts-examples">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-pointcuts-examples</a></p>
<p>由于Spring切面粒度最小是达到方法级别，而execution表达式可以用于明确指定方法返回类型，类名，方法名和参数名等与方法相关的信息，并且在Spring中，大部分需要使用AOP的业务场景也只需要达到方法级别即可，因而execution表达式的使用是最为广泛的。</p>
<h2 id="within">within</h2>
<p>表达式的最小粒度为类<br>
within与execution相比，粒度更大，仅能实现到包和接口、类级别。而execution可以精确到方法的返回值，参数个数、修饰符、参数类型等</p>
<pre><code class="language-java">@Pointcut(&quot;within(com.chenss.dao.*)&quot;)//匹配com.chenss.dao包中的任意方法
@Pointcut(&quot;within(com.chenss.dao..*)&quot;)//匹配com.chenss.dao包及其子包中的任意方法
</code></pre>
<h2 id="args">args</h2>
<blockquote>
<p>args: Limits matching to join points (the execution of methods when using Spring AOP) where the arguments are instances of the given types.</p>
</blockquote>
<p>限制连接点的匹配(使用Spring AOP时方法的执行)，其中的参数是给定类型的实例。<br>
args表达式的作用是匹配指定参数类型和指定参数数量的方法,与包名和类名无关</p>
<pre><code class="language-java">/**
 * args同execution不同的地方在于：
 * args匹配的是运行时传递给方法的参数类型
 * execution(* *(java.io.Serializable))匹配的是方法在声明时指定的方法参数类型。
 */
@Pointcut(&quot;args(java.io.Serializable)&quot;)//匹配运行时传递的参数类型为指定类型的、且参数个数和顺序匹配
@Pointcut(&quot;@args(com.chenss.anno.Chenss)&quot;)//接受一个参数，并且传递的参数的运行时类型具有@Classified
</code></pre>
<h2 id="this">this</h2>
<blockquote>
<p>this: Limits matching to join points (the execution of methods when using Spring AOP) where the bean reference (Spring AOP proxy) is an instance of the given type.</p>
</blockquote>
<p>限制连接点(使用Spring AOP时方法的执行)的匹配，其中bean引用(Spring AOP代理)是给定类型的实例。<br>
<strong>this JDK代理时，指向接口和代理类proxy，cglib代理时 指向接口和子类(不使用proxy)</strong></p>
<h2 id="target">target</h2>
<p>target: Limits matching to join points (the execution of methods when using Spring AOP) where the target object (application object being proxied) is an instance of the given type.<br>
限制对连接点(使用Spring AOP时方法的执行)的匹配，其中目标对象(代理的应用程序对象)是给定类型的实例。<br>
<strong>target  指向接口和子类</strong>。</p>
<pre><code class="language-java">/**
 * 此处需要注意的是，如果配置设置proxyTargetClass=false，或默认为false，则是用JDK代理，否则使用的是CGLIB代理
 * JDK代理的实现方式是基于接口实现，代理类继承Proxy，实现接口。
 * 而CGLIB继承被代理的类来实现。
 * 所以使用target会保证目标不变，关联对象不会受到这个设置的影响。
 * 但是使用this对象时，会根据该选项的设置，判断是否能找到对象。
 */
@Pointcut(&quot;target(com.chenss.dao.IndexDaoImpl)&quot;)//目标对象，也就是被代理的对象。限制目标对象为com.chenss.dao.IndexDaoImpl类
@Pointcut(&quot;this(com.chenss.dao.IndexDaoImpl)&quot;)//当前对象，也就是代理对象，代理对象时通过代理目标对象的方式获取新的对象，与原值并非一个
@Pointcut(&quot;@target(com.chenss.anno.Chenss)&quot;)//具有@Chenss的目标对象中的任意方法
@Pointcut(&quot;@within(com.chenss.anno.Chenss)&quot;)//等同于@targ
</code></pre>
<p>这个比较难.......<br>
proxy模式里面有两个重要的术语<br>
proxy Class<br>
target Class<br>
CGLIB和JDK有区别    JDK是基于接口   cglib是基于继承，所有this可以在cglib作用</p>
<h2 id="annotation">@annotation</h2>
<p>这个很简单........<br>
作用<strong>方法</strong>级别<br>
上述所有表达式都有@ 比如@Target(里面是一个注解类xx,表示所有加了xx注解的类,和包名无关)<br>
注意:上述所有的表达式可以混合使用,|| &amp;&amp; !</p>
<pre><code class="language-java">@Before(&quot;pointCutWithin()&amp;&amp;!pointCutArgs()&quot;)
</code></pre>
<pre><code class="language-java">@Pointcut(&quot;@annotation(com.chenss.anno.Chenss)&quot;)//匹配带有com.chenss.anno.Chenss注解的方法
</code></pre>
<p>如下面这个方法：</p>
<pre><code class="language-java">@Chenss
public void query(String str){
</code></pre>
<h2 id="bean">bean</h2>
<pre><code class="language-java">@Pointcut(&quot;bean(dao1)&quot;)//名称为dao1的bean上的任意方法
@Pointcut(&quot;bean(dao*)&quot;)
</code></pre>
<h1 id="aop-proxies">AOP Proxies</h1>
<p>参考链接：<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-introduction-proxies">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-introduction-proxies</a></p>
<blockquote>
<p>Spring AOP defaults to using standard JDK dynamic proxies for AOP proxies. This enables any interface (or set of interfaces) to be proxied.</p>
</blockquote>
<p>Spring AOP 默认使用标准 JDK 动态代理来完成 AOP 代理。这允许代理任何接口(或一组接口)。</p>
<h2 id="问题引入">问题引入</h2>
<p>1、定义一个接口</p>
<pre><code class="language-java">public interface IndexDao {
    void query(String str);
}
</code></pre>
<p>2、自定义一个注解</p>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
public @interface Luban {
}
</code></pre>
<p>3、定义切面，@annotation 连接点</p>
<pre><code class="language-java">@Component
// 切面
@Aspect
public class NotVeryUsefulAspect {
    @Pointcut(&quot;@annotation(com.ssm.anno.Luban)&quot;)
    public void pointCutAnno(){
    }
    /**
     * 通知
     *  通知位置：pointCut() 的前面
     *  通知内容
     */
    @Before(&quot;pointCutAnno()&quot;)
    public void before(){
        System.out.println(&quot;before&quot;);
    }
}
</code></pre>
<p>4、接口实现类，使用注解增强 query 方法</p>
<pre><code class="language-java">@Repository(&quot;indexDao&quot;)
public class IndexDaoImpl implements IndexDao {
    @Override
    @Luban
    public void query(String str){
        System.out.println(&quot;query&quot;);
    }
}
</code></pre>
<p>5、配置文件类</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
// 开启 AspectJ 语法支持
@EnableAspectJAutoProxy
public class AppConfig {
}
</code></pre>
<p>6、测试类</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        IndexDao dao = (IndexDao) context.getBean(&quot;indexDao&quot;);
        System.out.println(dao instanceof IndexDaoImpl);
        dao.query(&quot;111&quot;);
    }
}
</code></pre>
<p>7、运行结果：</p>
<pre><code>false
before
query
</code></pre>
<p>8、分析：为什么我们将一个 IndexDaoImpl 放入 Spring 容器（@Repository），然后再从 Spring 容器内取出来（context.getBean(&quot;indexDao&quot;)）类型却不是 IndexDaoImpl 了呢？<br>
9、在配置类中加上：@EnableAspectJAutoProxy(proxyTargetClass = true) 后，设置代理方式为 cglib 代理：</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
// 开启 AspectJ 语法支持
@EnableAspectJAutoProxy(proxyTargetClass = true)
public class AppConfig {
}
</code></pre>
<p>System.out.println(dao instanceof IndexDaoImpl); 返回 true 了。<br>
注：proxyTargetClass 默认是 false，所以 dao instanceof IndexDaoImpl 返回 false。</p>
<pre><code class="language-java">boolean proxyTargetClass() default false;
</code></pre>
<h2 id="spring-aop-默认使用标准-jdk-动态代理来完成-aop-代理">Spring AOP 默认使用标准 JDK 动态代理来完成 AOP 代理</h2>
<p>当我们使用 JDK 动态代理时，即 @EnableAspectJAutoProxy(proxyTargetClass = false)，从 Spring 容器中取出来的对象与放进去的对象不一致：context.getBean(&quot;indexDao&quot;) instanceof IndexDaoImpl 返回 false。<br>
但是 context.getBean(&quot;indexDao&quot;) instanceof indexDao 返回 true，因为 JDK 动态代理底层用的是接口。<br>
context.getBean(&quot;indexDao&quot;) instanceof Proxy 也返回 true。<br>
实现代理的办法</p>
<ul>
<li>继承</li>
<li>聚合接口（JDK 动态代理基于聚合）</li>
<li>动态代理</li>
</ul>
<h3 id="jdk-动态代理为什么只能是基于接口不能用继承">JDK 动态代理为什么只能是基于接口，不能用继承？</h3>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws IOException {
        Class&lt;?&gt;[] interfaces = new Class[]{IndexDao.class};
        byte[] bytes = ProxyGenerator.generateProxyClass(&quot;SSM&quot;,interfaces);
        File file = new File(&quot;C:\\Users\\Only\\Test.class&quot;);
        FileOutputStream fw = new FileOutputStream(file);
        fw.write(bytes);
        fw.flush();
        fw.close();
    }
}
</code></pre>
<p>注意：ProxyGenerator 的使用是基于 JDK8 的，如果使用 JDK10 会报 “找不到符号” 错误，参考：<a href="https://blog.csdn.net/weixin_46034990/article/details/105892718">https://blog.csdn.net/weixin_46034990/article/details/105892718</a><br>
JDK 底层源码已经帮这个对象自动继承了一个 Proxy 对象了，由于 Java 是单继承，所以不可能再去继承目标对象，所以只能实现目标对象的接口。<br>
<img src="https://epitomm.github.io/post-images/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.png" alt="图片" loading="lazy"><br>
基于上图可以看出，这个代理对象等于 IndexDao、也等于 Proxy，但是不等于 IndexDaoImpl，这也就解释了上述 【context.getBean(&quot;indexDao&quot;) instanceof IndexDaoImpl 返回 false。context.getBean(&quot;indexDao&quot;) instanceof indexDao 返回 true、context.getBean(&quot;indexDao&quot;) instanceof Proxy 也返回 true。】的原因。</p>
<h2 id="this-切点">this 切点</h2>
<p>this 表示<strong>代理对象</strong>的匹配类型<br>
前提：使用 JDK 动态代理，即 @EnableAspectJAutoProxy(proxyTargetClass = false)</p>
<pre><code class="language-java">@Component
// 切面
@Aspect
public class NotVeryUsefulAspect {
    // this 表示代理对象的匹配类型，使用 JDK 动态代理后，代理对象的类型是：Proxy、IndexDao，但不是 IndexDaoImpl
    @Pointcut(&quot;this(com.ssm.dao.IndexDao)&quot;)
    public void pointCutThis(){
        System.out.println(&quot;point cut&quot;);
    }
    /**
     * 通知
     *  通知位置：pointCut() 的前面
     *  通知内容
     */
    @Before(&quot;pointCutThis()&quot;)
    public void before(){
        System.out.println(&quot;before&quot;);
    }
}
</code></pre>
<p>增强成功：</p>
<pre><code>before
query
</code></pre>
<pre><code class="language-java">// this 表示代理对象的匹配类型，使用 JDK 动态代理后，代理对象的类型是：Proxy、IndexDao，但不是 IndexDaoImpl
@Pointcut(&quot;this(com.ssm.dao.impl.IndexDaoImpl)&quot;)
public void pointCutThis(){
    System.out.println(&quot;point cut&quot;);
}

@Before(&quot;pointCutThis()&quot;)
public void before(){
    System.out.println(&quot;before&quot;);
}
</code></pre>
<p>增强失败：</p>
<pre><code>query
</code></pre>
<h1 id="spring-aop-xml实现方式的注意事项">Spring AOP XML实现方式的注意事项:</h1>
<ol>
<li>在aop:config中定义切面逻辑，允许重复出现，重复多次，以最后出现的逻辑为准，但是次数以出现的次数为准</li>
<li>aop:aspect ID重复不影响正常运行，依然能够有正确结果</li>
<li>aop:pointcut ID重复会出现覆盖，以最后出现的为准。不同aop:aspect内出现的pointcut配置，可以相互引用</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/aop
                           http://www.springframework.org/schema/aop/spring-aop.xsd
                           http://www.springframework.org/schema/context
                           http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!-- 定义开始进行注解扫描 --&gt;
    &lt;context:component-scan base-package=&quot;com.chenss&quot;&gt;&lt;/context:component-scan&gt;

    &lt;!-- 定义AspectJ对象使用的逻辑类，类中提供切面之后执行的逻辑方法 --&gt;
    &lt;bean id=&quot;aspectAop&quot; class=&quot;com.chenss.aspectj.Aspect&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;aspectAop2&quot; class=&quot;com.chenss.aspectj.Aspect2&quot;&gt;&lt;/bean&gt;

    &lt;bean id=&quot;indexDao&quot; class=&quot;com.chenss.entity.IndexDao&quot;&gt;&lt;/bean&gt;

    &lt;!--在Config中定义切面逻辑，允许重复出现，重复多次，以最后出现的逻辑为准，但是次数以出现的次数为准--&gt;
    &lt;aop:config&gt;
        &lt;!-- aop:aspect ID重复不影响正常运行，依然能够有正确结果 --&gt;
        &lt;!-- aop:pointcut ID重复会出现覆盖，以最后出现的为准。不同aop:aspect内出现的pointcut配置，可以相互引用 --&gt;
        &lt;aop:aspect id=&quot;aspect&quot; ref=&quot;aspectAop&quot;&gt;
            &lt;aop:pointcut id=&quot;aspectCut&quot; expression=&quot;execution(* com.chenss.entity.*.*())&quot;/&gt;
            &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;aspectCut&quot;&gt;&lt;/aop:before&gt;
      
            &lt;aop:pointcut id=&quot;aspectNameCut&quot; expression=&quot;execution(* com.chenss.entity.*.*(java.lang.String, ..))&quot;/&gt;
            &lt;aop:before method=&quot;before2&quot; pointcut-ref=&quot;aspectNameCut&quot;&gt;&lt;/aop:before&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
]]></content>
    </entry>
</feed>