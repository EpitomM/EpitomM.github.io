<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://epitomm.github.io</id>
    <title>SSM</title>
    <updated>2020-05-10T15:46:41.006Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://epitomm.github.io"/>
    <link rel="self" href="https://epitomm.github.io/atom.xml"/>
    <subtitle>热心善良的老学姐</subtitle>
    <logo>https://epitomm.github.io/images/avatar.png</logo>
    <icon>https://epitomm.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, SSM</rights>
    <entry>
        <title type="html"><![CDATA[Spring系列（九）Spring源码解析]]></title>
        <id>https://epitomm.github.io/post/spring-xi-lie-jiu-yuan-ma-jie-xi/</id>
        <link href="https://epitomm.github.io/post/spring-xi-lie-jiu-yuan-ma-jie-xi/">
        </link>
        <updated>2020-05-10T13:08:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="spring-bean-的生命周期">Spring Bean 的生命周期</h1>
<h2 id="1得到用户自定义的-beandefinitionregistrypostprocessor">1.得到用户自定义的 BeanDefinitionRegistryPostProcessor</h2>
<p>具体流程：</p>
<p>context.<em>refresh</em>(); ---&gt; invokeBeanFactoryPostProcessors(beanFactory); ---&gt; 		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); ---&gt; 其中 getBeanFactoryPostProcessors() 方法返回值是BeanFactoryPostProcessor ---&gt; ConfigurationClassPostProcessor 实现了 BeanDefinitionRegistryPostProcessor，而 BeanDefinitionRegistryPostProcessor 继承了 BeanFactoryPostProcessor。</p>
<h2 id="2得到-spring-内置的-beandefinitionregistrypostprocessor">2.得到 Spring 内置的 BeanDefinitionRegistryPostProcessor</h2>
<p><em>目前 Spring 只内置了一个 <em>BeanDefinitionRegistryPostProcessor，也就是</em>ConfigurationClassPostProcessor</em></p>
<p>具体流程：</p>
<p>context.<em>refresh</em>(); ---&gt; <em>invokeBeanFactoryPostProcessors</em>(beanFactory); ---&gt; PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); ---&gt; List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList&lt;&gt;(); 这个 currentRegistryProcessors 中放的就是 Spring 内部自己实现了 BeanDefinitionRegistryPostProcessor 接口的对象</p>
<h2 id="3处理-beandefinitionregistrypostprocessor">3.处理 BeanDefinitionRegistryPostProcessor</h2>
<pre><code class="language-java">private static void invokeBeanDefinitionRegistryPostProcessors(
      Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry) {
   // 遍历所有 &quot;用户自定义+Spirng内置&quot; 的 BeanDefinitionRegistryPostProcessor 
   for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
      // 调用 postProcessBeanDefinitionRegistry 方法处理每一个 postProcessor
      postProcessor.postProcessBeanDefinitionRegistry(registry);
   }
}
</code></pre>
<p>具体流程：<br>
context.<em>refresh</em>(); ---&gt; <em>invokeBeanFactoryPostProcessors</em>(beanFactory); ---&gt; PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); ---&gt;invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors**, <strong>registry)</strong>; ****---&gt; **postProcessor.<em>postProcessBeanDefinitionRegistry</em>(registry); ---&gt; <em>processConfigBeanDefinitions</em>(registry);处理@Configuration ---&gt; parser.parse(candidates); 解析注解对象---&gt; parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName()); ---&gt; processConfigurationClass(new ConfigurationClass(metadata, beanName)); 处理Import---&gt; sourceClass = doProcessConfigurationClass(configClass, sourceClass); ---&gt; this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()); ---&gt; scanner.doScan(StringUtils.toStringArray(basePackages));扫描包</p>
<h1 id="spring-源码解析">Spring 源码解析</h1>
<h2 id="配置类只扫描包没有添加-configuration注解">配置类只扫描包，没有添加 @Configuration注解</h2>
<pre><code class="language-java">@ComponentScan(&quot;com.ssm&quot;)
public class AppConfig {
}
</code></pre>
<pre><code class="language-java">@Repository(&quot;indexDao&quot;)
public class IndexDaoImpl implements IndexDao{
   @Override
   public void query() {
      System.out.println(&quot;dao...模拟查询数据库&quot;);
   }
}
</code></pre>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
//    context.addBeanFactoryPostProcessor(new MyBeanFactoryProcessor());
      // 初始化 Spring 的环境
      context.refresh();
      IndexDao indexDao = context.getBean(IndexDaoImpl.class);
      indexDao.query();
   }
}
</code></pre>
<p>运行结果：</p>
<pre><code>dao...模拟查询数据库
</code></pre>
<p>总结：即使没有添加 @Configuration 注解，也能正确完成对 AppConfig 类的扫描：扫描包 com.ssm。那么 @Configuration 到底有什么用呢？</p>
<h1 id="1processconfigbeandefinitions">1.processConfigBeanDefinitions</h1>
<p>context.<em>refresh</em>(); ---&gt; invokeBeanFactoryPostProcessors(beanFactory); ---&gt; 		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); ---&gt; invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); ---&gt; postProcessor.postProcessBeanDefinitionRegistry(registry); ---&gt; processConfigBeanDefinitions(registry);</p>
<pre><code class="language-java">public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
   //定义一个 list 存放 app 提供的 bd：项目当中提供了 @Component
   List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;();
   // 获取容器中注册的所有 bd 名字
   // 7 个
   String[] candidateNames = registry.getBeanDefinitionNames();
   // 依次取出每个&lt;beanName,beanDefinition&gt;
   /**
    * full
    * lite
    */
   for (String beanName : candidateNames) {
      BeanDefinition beanDef = registry.getBeanDefinition(beanName);
      // 判断当前 bean 是否被处理过：使用 isFullConfigurationClass 来标识
      if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
            ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {
         // 如果 BeanDefinition 中的 configurationClass 属性为 full 或者 lite，则意味着已经处理过了，直接跳过
         // 这里需要结合下面的代码才能理解
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Bean definition has already been processed as a configuration class: &quot; + beanDef);
         }
      }
      // 判断这个 BeanDefinition 是否是 Configuration类，如果加了 Configuration 下面的这几个注解就不再判断了
      // 还有  add(Component.class.getName())
      //         candidateIndicators.add(ComponentScan.class.getName())
      //         candidateIndicators.add(Import.class.getName())
      //         candidateIndicators.add(ImportResource.class.getName())
      else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
         configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
      }
   }
   // Return immediately if no @Configuration classes were found
   if (configCandidates.isEmpty()) {
      return;
   }
   // 排序，根据 order，不重要
   // Sort by previously determined @Order value, if applicable
   configCandidates.sort((bd1, bd2) -&gt; {
      int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
      int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
      return Integer.compare(i1, i2);
   });
   // Detect any custom bean name generation strategy supplied through the enclosing application context
   SingletonBeanRegistry sbr = null;
   // 如果 BeanDefinitionRegistry 是 SingletonBeanRegistry 子类的话
   // 由于会将 registry 强转为 SingletonBeanRegistry
   if (registry instanceof SingletonBeanRegistry) {
      sbr = (SingletonBeanRegistry) registry;
      if (!this.localBeanNameGeneratorSet) {//是否有自定义的
         BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);
         // SingletonBeanRegistry 中有 id 为 org.springframework.context.annotation.internalConfigurationBeanNameGenerator
         // 如果有则利用它的，否则则使用 Spring 默认的
         if (generator != null) {
            this.componentScanBeanNameGenerator = generator;
            this.importBeanNameGenerator = generator;
         }
      }
   }
   if (this.environment == null) {
      this.environment = new StandardEnvironment();
   }
   // Parse each @Configuration class
   // 实例化 ConfigurationClassParser 为了解析各个配置类
   ConfigurationClassParser parser = new ConfigurationClassParser(
         this.metadataReaderFactory, this.problemReporter, this.environment,
         this.resourceLoader, this.componentScanBeanNameGenerator, registry);
   // 实例化 2 个 set，candidates 用于将之前加入的 configCandidates 进行去重
   // 因为可能有多个配置类重复了
   // alreadyParsed 用户判断是否处理过
   Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates);
   Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size());
   do {
      parser.parse(candidates);
      parser.validate();
      Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());
      configClasses.removeAll(alreadyParsed);
      // Read the model and create bean definitions based on its content
      if (this.reader == null) {
         this.reader = new ConfigurationClassBeanDefinitionReader(
               registry, this.sourceExtractor, this.resourceLoader, this.environment,
               this.importBeanNameGenerator, parser.getImportRegistry());
      }
      // 把扫描出来的 bean 对应的 beanDefinitions 添加到 factory 的 map 当中
      this.reader.loadBeanDefinitions(configClasses);
      alreadyParsed.addAll(configClasses);
      candidates.clear();
      if (registry.getBeanDefinitionCount() &gt; candidateNames.length) {
         String[] newCandidateNames = registry.getBeanDefinitionNames();
         Set&lt;String&gt; oldCandidateNames = new HashSet&lt;&gt;(Arrays.asList(candidateNames));
         Set&lt;String&gt; alreadyParsedClasses = new HashSet&lt;&gt;();
         for (ConfigurationClass configurationClass : alreadyParsed) {
            alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
         }
         for (String candidateName : newCandidateNames) {
            if (!oldCandidateNames.contains(candidateName)) {
               BeanDefinition bd = registry.getBeanDefinition(candidateName);
               if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp;
                     !alreadyParsedClasses.contains(bd.getBeanClassName())) {
                  candidates.add(new BeanDefinitionHolder(bd, candidateName));
               }
            }
         }
         candidateNames = newCandidateNames;
      }
   }
   while (!candidates.isEmpty());
   // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes
   if (sbr != null &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {
      sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
   }
   if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {
      // Clear cache in externally provided MetadataReaderFactory; this is a no-op
      // for a shared cache since it'll be cleared by the ApplicationContext.
      ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();
   }
}
</code></pre>
<p>上述代码第 28 行判断这个 bd 是否加了 @Configuration 注解</p>
<pre><code class="language-java">// 判断这个 BeanDefinition 是否是 Configuration类，如果加了 Configuration 下面的这几个注解就不再判断了
// 还有  add(Component.class.getName())
//         candidateIndicators.add(ComponentScan.class.getName())
//         candidateIndicators.add(Import.class.getName())
//         candidateIndicators.add(ImportResource.class.getName())
else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
   configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
}
</code></pre>
<p>我们点进 ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) 这个方法</p>
<h2 id="11-checkconfigurationclasscandidate">1.1 checkConfigurationClassCandidate</h2>
<pre><code class="language-java">    public static boolean checkConfigurationClassCandidate(BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) {
      String className = beanDef.getBeanClassName();
      if (className == null || beanDef.getFactoryMethodName() != null) {
         return false;
      }
      AnnotationMetadata metadata;
      if (beanDef instanceof AnnotatedBeanDefinition &amp;&amp;
            className.equals(((AnnotatedBeanDefinition) beanDef).getMetadata().getClassName())) {
         // Can reuse the pre-parsed metadata from the given BeanDefinition...
         // 如果 BeanDefinition 是 AnnotatedBeanDefinition 的实例，并且 className 和 BeanDefinition 中的元数据的类名相同
         // 则直接从 BeanDefinition 获得元数据Metadata
         metadata = ((AnnotatedBeanDefinition) beanDef).getMetadata();
      }
      else if (beanDef instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) beanDef).hasBeanClass()) {
         // Check already loaded Class if present...
         // since we possibly can't even load the class file for this Class.
         // 如果 BeanDefinition 是 AbstractBeanDefinition 的实例，并且 beanDef 有 beanClass 属性存在
         // 则实例化 StandardAnnotationMetadata
         Class&lt;?&gt; beanClass = ((AbstractBeanDefinition) beanDef).getBeanClass();
         metadata = new StandardAnnotationMetadata(beanClass, true);
      }
      else {
         try {
            MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);
            metadata = metadataReader.getAnnotationMetadata();
         }
         catch (IOException ex) {
            if (logger.isDebugEnabled()) {
               logger.debug(&quot;Could not find class file for introspecting configuration annotations: &quot; + className, ex);
            }
            return false;
         }
      }
      // 判断当前这个 bd 中存在的类是不是加了 @Configuration 注解，但是如果加了 @Configuration，下面的这几个注解就不再判断，因为这是一个 if-else if 分支
      // 只有满足了 &quot;没有加 @Configuration注解&quot;，才会走 else 分支去判断是否添加了其他注解
      // 如果存在则 Spring 认为它是一个全注解 FULL 的类
      if (isFullConfigurationCandidate(metadata)) {
         // 如果存在 Configuration 注解，则为 BeanDefinition 设置 configurationClass 属性为 FULL
         beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);
      }
      // 判断是否加了以下注解，摘录 isLiteConfigurationCandidate 的源码
//    candidateIndicators.add(Component.class.getName());
//    candidateIndicators.add(ComponentScan.class.getName());
//    candidateIndicators.add(Import.class.getName());
//    candidateIndicators.add(ImportResource.class.getName());
//    如果不存在 @Configuration 注解，Spring 则认为是一个部分注解 LITE 类
      else if (isLiteConfigurationCandidate(metadata)) {
         beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
      }
      else {
         return false;
      }
      // It's a full or lite configuration candidate... Let's determine the order value, if any.
      Integer order = getOrder(metadata);
      if ( order != null) {
         beanDef.setAttribute(ORDER_ATTRIBUTE, order);
      }
      return true;
   }
</code></pre>
<h3 id="111-isfullconfigurationcandidate">1.1.1 isFullConfigurationCandidate</h3>
<p>上述代码第 39 行：</p>
<pre><code class="language-java">public static boolean isFullConfigurationCandidate(AnnotationMetadata metadata) {
   return metadata.isAnnotated(Configuration.class.getName());
}
</code></pre>
<h3 id="112-isliteconfigurationcandidate">1.1.2 isLiteConfigurationCandidate</h3>
<p>上述代码第 49 行：</p>
<pre><code class="language-java">public static boolean isLiteConfigurationCandidate(AnnotationMetadata metadata) {
   // Do not consider an interface or an annotation...
   if (metadata.isInterface()) {
      return false;
   }
   // Any of the typical annotations found?
   for (String indicator : candidateIndicators) {
      if (metadata.isAnnotated(indicator)) {
         return true;
      }
   }
   // Finally, let's look for @Bean methods...
   try {
      return metadata.hasAnnotatedMethods(Bean.class.getName());
   }
   catch (Throwable ex) {
      if (logger.isDebugEnabled()) {
         logger.debug(&quot;Failed to introspect @Bean methods on class [&quot; + metadata.getClassName() + &quot;]: &quot; + ex);
      }
      return false;
   }
}
</code></pre>
<p>上述第 8 行：</p>
<pre><code class="language-java">private static final Set&lt;String&gt; candidateIndicators = new HashSet&lt;&gt;(8);
static {
   candidateIndicators.add(Component.class.getName());
   candidateIndicators.add(ComponentScan.class.getName());
   candidateIndicators.add(Import.class.getName());
   candidateIndicators.add(ImportResource.class.getName());
}
</code></pre>
<p>上述 checkConfigurationClassCandidate 方法的第 39-51 行：</p>
<pre><code class="language-java">      // 判断当前这个 bd 中存在的类是不是加了 @Configuration 注解，但是如果加了 @Configuration，下面的这几个注解就不再判断，因为这是一个 if-else if 分支
      // 只有满足了 &quot;没有加 @Configuration注解&quot;，才会走 else 分支去判断是否添加了其他注解
      if (isFullConfigurationCandidate(metadata)) {
         // 如果存在 Configuration 注解，则为 BeanDefinition 设置 configurationClass 属性为 FULL
         beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);
      }
      // 判断是否加了以下注解，摘录 isLiteConfigurationCandidate 的源码
/nss/    candidateIndicators.add(Component.class.getName());
//    candidateIndicators.add(ComponentScan.class.getName());
//    candidateIndicators.add(Import.class.getName());
//    candidateIndicators.add(ImportResource.class.getName());
      else if (isLiteConfigurationCandidate(metadata)) {
         beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
</code></pre>
<p>如果一个类加了 @Configuration 注解，BeanDefinition 中的 attribute =  CONFIGURATION_CLASS_FULL；否则，BeanDefinition 中的 attribute =   CONFIGURATION_CLASS_LITE</p>
<h3 id="113-parse">1.1.3 parse</h3>
<p>上述 checkConfigurationClassCandidate 方法的第 79 行：</p>
<pre><code class="language-java"> parser.parse(candidates);
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/parse%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AAappConfig%E9%9C%80%E8%A6%81%E6%9B%B4%E6%96%B0.png" alt="图片" loading="lazy"></figure>
<pre><code class="language-java">public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) {
   // deferred：延迟的
   this.deferredImportSelectors = new LinkedList&lt;&gt;();
   // 根据 BeanDefinition 的类型做不同的处理，一般都会调用 ConfigurationClassParse#parse 进行解析
   for (BeanDefinitionHolder holder : configCandidates) {
      BeanDefinition bd = holder.getBeanDefinition();
      try {
         // 判断这个 bd 是否被加了注解
         if (bd instanceof AnnotatedBeanDefinition) {
            // 解析注解对象，并且把解析出来的 bd 放到 map，但是这里的 bd 指的是普通的
            // 何为不普通的呢？比如 @Bean 和 beanFactoryPostProcessor 得到的 bean 不在
            // 但是是这里解析，只是不 put 而已
            parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
         }
         else if (bd instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) {
            parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
         }
         else {
            parse(bd.getBeanClassName(), holder.getBeanName());
         }
      }
      catch (BeanDefinitionStoreException ex) {
         throw ex;
      }
      catch (Throwable ex) {
         throw new BeanDefinitionStoreException(
               &quot;Failed to parse configuration class [&quot; + bd.getBeanClassName() + &quot;]&quot;, ex);
      }
   }
   processDeferredImportSelectors();
}
</code></pre>
<p>上述代码第 13 行：</p>
<pre><code class="language-java">protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {
   processConfigurationClass(new ConfigurationClass(metadata, beanName));
}
</code></pre>
<p>上述代码第 2 行：</p>
<pre><code class="language-java">protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
   // 判断是否应该跳过解析
   if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
      return;
   }
   // 处理 Imported 的情况
   // 就是当前这个类有没有被别的类 @Import
   ConfigurationClass existingClass = this.configurationClasses.get(configClass);
   if (existingClass != null) {
      if (configClass.isImported()) {
         if (existingClass.isImported()) {
            existingClass.mergeImportedBy(configClass);
         }
         // Otherwise ignore new imported config class; existing non-imported class overrides it.
         return;
      }
      else {
         // Explicit bean definition found, probably replacing an import.
         // Let's remove the old one and go with the new one.
         this.configurationClasses.remove(configClass);
         this.knownSuperclasses.values().removeIf(configClass::equals);
      }
   }
   // Recursively process the configuration class and its superclass hierarchy.
   // 将 AppConfig 这个类转化成 SourceClass 
   SourceClass sourceClass = asSourceClass(configClass);
   do {
      sourceClass = doProcessConfigurationClass(configClass, sourceClass);
   }
   while (sourceClass != null);
   // 一个 map，用来存放扫描出来的 bean（注意这里的 bean 不是对象，仅仅是 bean 的信息，因为还没到实例化）
   this.configurationClasses.put(configClass, configClass);
}
</code></pre>
<h4 id="1131-doprocessconfigurationclass">1.1.3.1  doProcessConfigurationClass</h4>
<p>上述代码第 30 行：</p>
<pre><code class="language-java">protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)
      throws IOException {
   // Recursively process any member (nested) classes first
   // 处理内部类
   processMemberClasses(configClass, sourceClass);
   // 处理 @PropertySource 注解
   for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
         sourceClass.getMetadata(), PropertySources.class,
         org.springframework.context.annotation.PropertySource.class)) {
      if (this.environment instanceof ConfigurableEnvironment) {
         processPropertySource(propertySource);
      }
      else {
         logger.warn(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() +
               &quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;);
      }
   }
   // 处理 @ComponentScan 注解
   Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(
         sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
   if (!componentScans.isEmpty() &amp;&amp;
         !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
      for (AnnotationAttributes componentScan : componentScans) {
         // The config class is annotated with @ComponentScan -&gt; perform the scan immediately
         // 扫描普通类 componentScan=com.ssm 
         // 这里扫描出来所有 @Component
         Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =
               this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
         // Check the set of scanned definitions for any further config classes and parse recursively if needed
         // 检查扫描出来的类当中是否还有 Configuration
         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
            BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
            if (bdCand == null) {
               bdCand = holder.getBeanDefinition();
            }
            if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
               parse(bdCand.getBeanClassName(), holder.getBeanName());
            }
         }
      }
   }
   // Process any @Import annotations
   // 处理 @Import
   processImports(configClass, sourceClass, getImports(sourceClass), true);
   // Process any @ImportResource annotations
   AnnotationAttributes importResource =
         AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
   if (importResource != null) {
      String[] resources = importResource.getStringArray(&quot;locations&quot;);
      Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;);
      for (String resource : resources) {
         String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
         configClass.addImportedResource(resolvedResource, readerClass);
      }
   }
   // Process individual @Bean methods
   Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
   for (MethodMetadata methodMetadata : beanMethods) {
      configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
   }
   // Process default methods on interfaces
   processInterfaces(configClass, sourceClass);
   // Process superclass, if any
   if (sourceClass.getMetadata().hasSuperClass()) {
      String superclass = sourceClass.getMetadata().getSuperClassName();
      if (superclass != null &amp;&amp; !superclass.startsWith(&quot;java&quot;) &amp;&amp;
            !this.knownSuperclasses.containsKey(superclass)) {
         this.knownSuperclasses.put(superclass, configClass);
         // Superclass found, return its annotation metadata and recurse
         return sourceClass.getSuperClass();
      }
   }
   // No superclass -&gt; processing is complete
   return null;
}
</code></pre>
<p>上述代码第 30 行：</p>
<pre><code class="language-java">public Set&lt;BeanDefinitionHolder&gt; parse(AnnotationAttributes componentScan, final String declaringClass) {
   ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,
         componentScan.getBoolean(&quot;useDefaultFilters&quot;), this.environment, this.resourceLoader);
   
   // BeanNameGenerator：Bean名字生成器
   Class&lt;? extends BeanNameGenerator&gt; generatorClass = componentScan.getClass(&quot;nameGenerator&quot;);
   boolean useInheritedGenerator = (BeanNameGenerator.class == generatorClass);
   scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator :
         BeanUtils.instantiateClass(generatorClass));
   ScopedProxyMode scopedProxyMode = componentScan.getEnum(&quot;scopedProxy&quot;);
   if (scopedProxyMode != ScopedProxyMode.DEFAULT) {
      scanner.setScopedProxyMode(scopedProxyMode);
   }
   else {
      Class&lt;? extends ScopeMetadataResolver&gt; resolverClass = componentScan.getClass(&quot;scopeResolver&quot;);
      scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));
   }
   scanner.setResourcePattern(componentScan.getString(&quot;resourcePattern&quot;));
   for (AnnotationAttributes filter : componentScan.getAnnotationArray(&quot;includeFilters&quot;)) {
      for (TypeFilter typeFilter : typeFiltersFor(filter)) {
         scanner.addIncludeFilter(typeFilter);
      }
   }
   for (AnnotationAttributes filter : componentScan.getAnnotationArray(&quot;excludeFilters&quot;)) {
      for (TypeFilter typeFilter : typeFiltersFor(filter)) {
         scanner.addExcludeFilter(typeFilter);
      }
   }
  
    // 扫描出来的这个类是否需要懒加载：默认 false
   // xml 配置懒加载：&lt;beans lazy=&quot;true&quot;&gt;&lt;bean&gt;&lt;/bean&gt;&lt;/beans&gt;
   // JavaConfig配置懒加载：@Lazy   public class AppConfig{
   boolean lazyInit = componentScan.getBoolean(&quot;lazyInit&quot;);
   if (lazyInit) {
      scanner.getBeanDefinitionDefaults().setLazyInit(true);
   }
   Set&lt;String&gt; basePackages = new LinkedHashSet&lt;&gt;();
   String[] basePackagesArray = componentScan.getStringArray(&quot;basePackages&quot;);
   for (String pkg : basePackagesArray) {
      String[] tokenized = StringUtils.tokenizeToStringArray(this.environment.resolvePlaceholders(pkg),
            ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);
      Collections.addAll(basePackages, tokenized);
   }
   for (Class&lt;?&gt; clazz : componentScan.getClassArray(&quot;basePackageClasses&quot;)) {
      basePackages.add(ClassUtils.getPackageName(clazz));
   }
   if (basePackages.isEmpty()) {
      basePackages.add(ClassUtils.getPackageName(declaringClass));
   }
   scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {
      @Override
      protected boolean matchClassName(String className) {
         return declaringClass.equals(className);
      }
   });
   return scanner.doScan(StringUtils.toStringArray(basePackages));
}
</code></pre>
<p>上述代码第  12 行：</p>
<pre><code class="language-java">   ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,
         componentScan.getBoolean(&quot;useDefaultFilters&quot;), this.environment, this.resourceLoader);
</code></pre>
<p>这里 new 了一个 ClassPathBeanDefinitionScanner 真正去扫描包的类。<br>
我们再来看一下构造方法中的 scanner：</p>
<pre><code class="language-java">public AnnotationConfigApplicationContext() {
   /**
    * 父类的构造方法 super()
    *创建一个读取注解的 Bean 定义读取器：reader 能读取被加了注解的类
    * 什么是 bean 定义？BeanDefinition
    */
   this.reader = new AnnotatedBeanDefinitionReader(this);
   // 定义扫描器
   // 可以用来扫描包，继而转换成 bd
   // 但是实际上我们扫描包工作不是 scanner 这个对象
   // 是 Spring 自己 new 的一个 ClasspathBeanDefinitionScanner
   // 这里的 scanner 仅仅是为了程序员能够在外部调用 AnnotationConfigApplicationContext 对象的 scan 方法用的。
   this.scanner = new ClassPathBeanDefinitionScanner(this);
}
</code></pre>
<p>这里的 scanner 仅仅是为了程序员能够在外部调用 AnnotationConfigApplicationContext 对象的 scan 方法用的，而不是真正的扫描包。<br>
上述 parse 方法的第 36-39 行：</p>
<pre><code class="language-java">// 扫描出来的这个类是否需要懒加载：默认 false
// xml 配置懒加载：&lt;beans lazy=&quot;true&quot;&gt;&lt;bean&gt;&lt;/bean&gt;&lt;/beans&gt;
// JavaConfig配置懒加载：@Lazy   public class AppConfig{
boolean lazyInit = componentScan.getBoolean(&quot;lazyInit&quot;);   
if (lazyInit) {
  scanner.getBeanDefinitionDefaults().setLazyInit(true);
}
</code></pre>
<p>这里设置懒加载时，将 isLazyInit 设置为 true，而不是将 BeanDefinition 内的 lazy 设置为 true，因为这个时候还没有 BeanDefinition。<br>
上述 parse 方法第 61 行：</p>
<pre><code class="language-java">return scanner.doScan(StringUtils.toStringArray(basePackages));
</code></pre>
<h4 id="doscan">doScan</h4>
<p>点进去 doScan 方法：</p>
<pre><code class="language-java">protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) {
   Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;);
   Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;&gt;();
   // 循环所有 basePackages，因为@ComponentScan({&quot;com.ssm.dao&quot;},{&quot;com.ssm.service&quot;})可以写多个
   for (String basePackage : basePackages) {
      // 扫表 basePackage 路径下的 java 文件
      // 并把它转成 BeanDefinition 类型
      Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);
      for (BeanDefinition candidate : candidates) {
         // 解析 scope 属性
         ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
         candidate.setScope(scopeMetadata.getScopeName());
         String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
         if (candidate instanceof AbstractBeanDefinition) {
            // 如果这个类是 AbstractBeanDefinition 的子类
            // 则为它设置默认值，比如 lazy，init destroy
            postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
         }
         if (candidate instanceof AnnotatedBeanDefinition) {
            // 检查并且处理常用的注解
            // 这里的处理主要是指把常用注解的值设置到 AnnotatedBeanDefinition 当中
            // 当前前提是这个类必须是 AnnotatedBeanDefinition 类型的，说白了就是加了注解的类
            AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
         }
         if (checkCandidate(beanName, candidate)) {
            BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
            definitionHolder =
                  AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
            beanDefinitions.add(definitionHolder);
            registerBeanDefinition(definitionHolder, this.registry);
         }
      }
   }
   return beanDefinitions;
}
</code></pre>
<p>上述第 8 行代码：</p>
<pre><code class="language-java">public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) {
   if (this.componentsIndex != null &amp;&amp; indexSupportsIncludeFilters()) {
      return addCandidateComponentsFromIndex(this.componentsIndex, basePackage);
   }
   else {
      return scanCandidateComponents(basePackage);
   }
}
</code></pre>
<p>上述第 6 行，asm 读取 class 文件：</p>
<pre><code class="language-java">private Set&lt;BeanDefinition&gt; scanCandidateComponents(String basePackage) {
   Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;&gt;();
   try {
      String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
            resolveBasePackage(basePackage) + '/' + this.resourcePattern;
      // asm 读取 class 文件
      Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);
      boolean traceEnabled = logger.isTraceEnabled();
      boolean debugEnabled = logger.isDebugEnabled();
      for (Resource resource : resources) {
         if (traceEnabled) {
            logger.trace(&quot;Scanning &quot; + resource);
         }
         if (resource.isReadable()) {
            try {
               MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);
               if (isCandidateComponent(metadataReader)) {
                  // 通过 Spring 扫描出来的 BeanDefinition 叫 ScannedGenericBeanDefinition 
                  ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
                  sbd.setSource(resource);
                  if (isCandidateComponent(sbd)) {
                     if (debugEnabled) {
                        logger.debug(&quot;Identified candidate component class: &quot; + resource);
                     }
                     candidates.add(sbd);
                  }
                  else {
                     if (debugEnabled) {
                        logger.debug(&quot;Ignored because not a concrete top-level class: &quot; + resource);
                     }
                  }
               }
               else {
                  if (traceEnabled) {
                     logger.trace(&quot;Ignored because not matching any filter: &quot; + resource);
                  }
               }
            }
            catch (Throwable ex) {
               throw new BeanDefinitionStoreException(
                     &quot;Failed to read candidate component class: &quot; + resource, ex);
            }
         }
         else {
            if (traceEnabled) {
               logger.trace(&quot;Ignored because not readable: &quot; + resource);
            }
         }
      }
   }
   catch (IOException ex) {
      throw new BeanDefinitionStoreException(&quot;I/O failure during classpath scanning&quot;, ex);
   }
   return candidates;
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/asm%E6%89%AB%E6%8F%8F%E6%96%87%E4%BB%B6.png" alt="图片" loading="lazy"></figure>
<p>上述代码第 17 行：</p>
<pre><code class="language-java">protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException {
   // 当前这个类是否在 excludeFilters 当中
   for (TypeFilter tf : this.excludeFilters) {
      if (tf.match(metadataReader, getMetadataReaderFactory())) {
         // 如果当前类在排除条件中，返回 false
         return false;
      }
   }
   // 当前这个类是否在 includeFilters当中
   for (TypeFilter tf : this.includeFilters) {
      if (tf.match(metadataReader, getMetadataReaderFactory())) {
         return isConditionMatch(metadataReader);
      }
   }
   return false;
}
</code></pre>
<p>上述代码第 19 行：</p>
<pre><code class="language-java">// 通过 Spring 扫描出来的 BeanDefinition 叫 ScannedGenericBeanDefinition 
ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
</code></pre>
<p>来看一下这个类 ScannedGenericBeanDefinition：</p>
<pre><code class="language-java">public class ScannedGenericBeanDefinition extends GenericBeanDefinition implements AnnotatedBeanDefinition {
</code></pre>
<p>而 GenericBeanDefinition 类：</p>
<pre><code class="language-java">public class GenericBeanDefinition extends AbstractBeanDefinition {
</code></pre>
<p>所以：所有扫描出来的类都 instanceof AbstractBeanDefinition <br>
上述代码第 21 行：</p>
<pre><code class="language-java">protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) {
   AnnotationMetadata metadata = beanDefinition.getMetadata();
   return (metadata.isIndependent() &amp;&amp; (metadata.isConcrete() ||
         (metadata.isAbstract() &amp;&amp; metadata.hasAnnotatedMethods(Lookup.class.getName()))));
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/candidates.png" alt="图片" loading="lazy"></figure>
<p>doScan 方法第 14-24 行</p>
<pre><code class="language-java">// 所有扫描出来的类都 instanceof AbstractBeanDefinition 
if (candidate instanceof AbstractBeanDefinition) {
    // 如果这个类是 AbstractBeanDefinition 的子类
    // 则为它设置默认值，比如 lazy，init destroy
    postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
}
// 如果这个类是被加了注解的
if (candidate instanceof AnnotatedBeanDefinition) {
    // 检查并且处理常用的注解
    // 这里的处理主要是指把常用注解的值设置到 AnnotatedBeanDefinition 当中
    // 当前前提是这个类必须是 AnnotatedBeanDefinition 类型的，说白了就是加了注解的类
          AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
}
</code></pre>
<p>由于上面的分析，上述判断的第 1 行的 if 分支成立<br>
把一个类扫描出来后，需要填充 BeanDefinition，postProcessBeanDefinition 就是填充这个 BeanDefinition，为它设置默认值。</p>
<pre><code class="language-java">protected void postProcessBeanDefinition(AbstractBeanDefinition beanDefinition, String beanName) {
   beanDefinition.applyDefaults(this.beanDefinitionDefaults);
   if (this.autowireCandidatePatterns != null) {
      beanDefinition.setAutowireCandidate(PatternMatchUtils.simpleMatch(this.autowireCandidatePatterns, beanName));
   }
}
</code></pre>
<p>上述代码第 2 行：</p>
<pre><code class="language-java">// 为 BeanDefinition 设置默认值
public void applyDefaults(BeanDefinitionDefaults defaults) {
   // 默认设置懒加载
   setLazyInit(defaults.isLazyInit());
   setAutowireMode(defaults.getAutowireMode());
   setDependencyCheck(defaults.getDependencyCheck());
   setInitMethodName(defaults.getInitMethodName());
   setEnforceInitMethod(false);
   setDestroyMethodName(defaults.getDestroyMethodName());
   setEnforceDestroyMethod(false);
}
</code></pre>
<p>上述判断懒加载时，将 isLazyInit 设置为 true，而不是将 BeanDefinition 内的 lazy 设置为 true，因为那时候还没有 BeanDefinition。<br>
看一下第 12 行的判断：</p>
<pre><code class="language-java">AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
</code></pre>
<p>点进去这个 processCommonDefinitionAnnotations 方法</p>
<pre><code class="language-java">public static void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd) {
   processCommonDefinitionAnnotations(abd, abd.getMetadata());
}
</code></pre>
<p>点进去这个 processCommonDefinitionAnnotations 方法</p>
<pre><code class="language-java">static void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata) {
   AnnotationAttributes lazy = attributesFor(metadata, Lazy.class);
   if (lazy != null) {
      abd.setLazyInit(lazy.getBoolean(&quot;value&quot;));
   }
   else if (abd.getMetadata() != metadata) {
      lazy = attributesFor(abd.getMetadata(), Lazy.class);
      if (lazy != null) {
         abd.setLazyInit(lazy.getBoolean(&quot;value&quot;));
      }
   }
   if (metadata.isAnnotated(Primary.class.getName())) {
      abd.setPrimary(true);
   }
   AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);
   if (dependsOn != null) {
      abd.setDependsOn(dependsOn.getStringArray(&quot;value&quot;));
   }
   if (abd instanceof AbstractBeanDefinition) {
      AbstractBeanDefinition absBd = (AbstractBeanDefinition) abd;
      AnnotationAttributes role = attributesFor(metadata, Role.class);
      if (role != null) {
         absBd.setRole(role.getNumber(&quot;value&quot;).intValue());
      }
      AnnotationAttributes description = attributesFor(metadata, Description.class);
      if (description != null) {
         absBd.setDescription(description.getString(&quot;value&quot;));
      }
   }
}
</code></pre>
<p>doScan 方法的第 30 行：</p>
<pre><code class="language-java">// 加入到 map 中
registerBeanDefinition(definitionHolder, this.registry);
</code></pre>
<p>点进去 registerBeanDefinition：</p>
<pre><code class="language-java">protected void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) {
   BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry);
}
</code></pre>
<p>在点进去 registerBeanDefinition：</p>
<pre><code class="language-java">public static void registerBeanDefinition(
      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
      throws BeanDefinitionStoreException {
   // Register bean definition under primary name.
   String beanName = definitionHolder.getBeanName();
   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
   // Register aliases for bean name, if any.
   String[] aliases = definitionHolder.getAliases();
   if (aliases != null) {
      for (String alias : aliases) {
         registry.registerAlias(beanName, alias);
      }
   }
}
</code></pre>
<p>doProcessConfigurationClass 代码的第 48 行</p>
<pre><code class="language-java">// 处理 @Import
processImports(configClass, sourceClass,getImports(sourceClass), true);
</code></pre>
<p>点进去这个 processImports 方法：</p>
<pre><code class="language-java">private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,
      Collection&lt;SourceClass&gt; importCandidates, boolean checkForCircularImports) {
   // 如果没有加@Import，直接返回
   if (importCandidates.isEmpty()) {
      return;
   }
   if (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) {
      this.problemReporter.error(new CircularImportProblem(configClass, this.importStack));
   }
   else {
      this.importStack.push(configClass);
      try {
         for (SourceClass candidate : importCandidates) {
            // @Import(IndexDao.class)、@Import(ImportSelector)、@Import(ImportBeanDefinitionRegistrar)
            // 判断是不是 ImportSelector
            if (candidate.isAssignable(ImportSelector.class)) {
               // Candidate class is an ImportSelector -&gt; delegate to it to determine imports
               Class&lt;?&gt; candidateClass = candidate.loadClass();
               // 通过反射实现一个对象 
               ImportSelector selector = BeanUtils.instantiateClass(candidateClass, ImportSelector.class);
               ParserStrategyUtils.invokeAwareMethods(
                     selector, this.environment, this.resourceLoader, this.registry);
               if (this.deferredImportSelectors != null &amp;&amp; selector instanceof DeferredImportSelector) {
                  this.deferredImportSelectors.add(
                        new DeferredImportSelectorHolder(configClass, (DeferredImportSelector) selector));
               }
               else {
                  String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
                  Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames);
                  processImports(configClass, currentSourceClass, importSourceClasses, false);
               }
            }
            // 判断是不是 ImportBeanDefinitionRegistrar
            else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
               // Candidate class is an ImportBeanDefinitionRegistrar -&gt;
               // delegate to it to register additional bean definitions
               Class&lt;?&gt; candidateClass = candidate.loadClass();
               ImportBeanDefinitionRegistrar registrar =
                     BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);
               ParserStrategyUtils.invokeAwareMethods(
                     registrar, this.environment, this.resourceLoader, this.registry);
               configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
            }
            // 普通类：@Import(IndexDao.class)
            else {
               // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt;
               // process it as an @Configuration class
               this.importStack.registerImport(
                     currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
               processConfigurationClass(candidate.asConfigClass(configClass));
            }
         }
      }
      catch (BeanDefinitionStoreException ex) {
         throw ex;
      }
      catch (Throwable ex) {
         throw new BeanDefinitionStoreException(
               &quot;Failed to process import candidates for configuration class [&quot; +
               configClass.getMetadata().getClassName() + &quot;]&quot;, ex);
      }
      finally {
         this.importStack.pop();
      }
   }
}
</code></pre>
<h1 id="import">Import</h1>
<h2 id="importselector">ImportSelector</h2>
<pre><code class="language-java">public class MyImportSelector implements ImportSelector {
   @Override
   public String[] selectImports(AnnotationMetadata importingClassMetadata) {
      return new String[]{IndexDaoImpl3.class.getName()};
   }
}
</code></pre>
<pre><code class="language-java">@ComponentScan(&quot;com.ssm&quot;)
@Import(MyImportSelector.class)
public class AppConfig {
</code></pre>
<pre><code class="language-java">public class IndexDaoImpl3 implements IndexDao{
   @Override
   public void query() {
      System.out.println(&quot;dao3...模拟查询数据库&quot;);
   }
}
</code></pre>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      // 初始化 Spring 的环境
      context. refresh();
      IndexDao dao = context.getBean(IndexDaoImpl3.class);
      dao.query();
   }
}
</code></pre>
<p>运行结果：</p>
<pre><code>dao3...模拟查询数据库
</code></pre>
<p>直接在 IndexDaoImpl3 添加 @Component 注解也能实现将 对象注入到 Spring 容器中，为什么要使用一个 MyImportSelector implements ImportSelector 类呢？<br>
因为有的功能需要 Spring 动态帮我们加载，比如 IndexDaoImpl3 是我开发的程序，我开发的程序并不一定在我的项目中，可以在 AppConfig 中修改扫描包，但是如果只有一个类需要引用，修改扫描包 @ComponentScan 不是好的办法。可以开关闭某些功能。</p>
<p>动态代理：</p>
<p>Spring 底层的 AOP 提供一个开关来开启是否要对 AOP 的支持</p>
<pre><code class="language-java">public class IndexDaoImpl3 implements IndexDao, BeanPostProcessor {
   @Override
   public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
      if(beanName.equals(&quot;indexDao&quot;)){
         bean = Proxy.newProxyInstance(this.getClass().getClassLoader(), new Class[]{IndexDao.class},new MyInvocationHandler(bean));
      }
      return bean;
   }
   @Override
   public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
      return null;
   }
   @Override
   public void query() {
      System.out.println(&quot;dao3...模拟查询数据库&quot;);
   }
}
</code></pre>
<p>怎样实现 Spring 动态加载？</p>
<pre><code class="language-java">public class MyImportSelector implements ImportSelector {
   @Override
   public String[] selectImports(AnnotationMetadata importingClassMetadata) {
      // 得到 @EnableLuban 注解的值
      // int value = importingClassMetadata.getAnnotationTypes().value
      // if(value)   return new String[]{IndexDaoImpl3.class.getName()};
      return new String[]{IndexDaoImpl3.class.getName()};
   }
}
</code></pre>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
@Import(MyImportSelector.class)
public @interface EnableLuban {
}
</code></pre>
<pre><code class="language-java">@ComponentScan(&quot;com.ssm&quot;)
@EnableLuban
public class AppConfig {
</code></pre>
<p>如果配置类有 @EnableLuban 注解，运行结果：</p>
<pre><code>dao3...模拟查询数据库
</code></pre>
<p>如果配置类没有 @EnableLuban 注解，运行结果：</p>
<pre><code>Exception in thread &quot;main&quot; org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'com.ssm.dao.impl.IndexDaoImpl3' available
</code></pre>
<pre><code class="language-java">public class MyInvocationHandler implements InvocationHandler {
   Object target;
   public MyInvocationHandler(Object target){
      this.target = target;
   }
   @Override
   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
      System.out.println(&quot;代理方法...&quot;);
      return method.invoke(target,args);
   }
}
</code></pre>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      // 初始化 Spring 的环境
      context. refresh();
      IndexDao dao = (IndexDao) context.getBean(&quot;indexDao&quot;);
      dao.query();
   }
}
</code></pre>
<p>运行结果：</p>
<pre><code>代理方法...
dao...模拟查询数据库
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring系列（八）Spring源码解析]]></title>
        <id>https://epitomm.github.io/post/spring-xi-lie-ba-spring-yuan-ma-jie-xi/</id>
        <link href="https://epitomm.github.io/post/spring-xi-lie-ba-spring-yuan-ma-jie-xi/">
        </link>
        <updated>2020-05-09T07:58:17.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      // 初始化 Spring 环境
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // 注册 AppConfig.class
      context.register(AppConfig.class);
      // 解析 AppConfig.class
      context.refresh();
      IndexDao indexDao = context.getBean(IndexDaoImpl.class);
      indexDao.query();
   }
}
</code></pre>
<h1 id="1new-annotationconfigapplicationcontext">1.new AnnotationConfigApplicationContext();</h1>
<p>第 6-7 行代码：由于 AnnotationConfigApplicationContext 有父类，所以会先调用父类构造方法。</p>
<pre><code class="language-java">public class AnnotationConfigApplicationContext extends GenericApplicationContext implements AnnotationConfigRegistry {
</code></pre>
<p>父类构造方法 GenericApplicationContext() 中创建一个 DefaultListableBeanFactory 工厂：</p>
<pre><code class="language-java">public GenericApplicationContext() {
   this.beanFactory = new DefaultListableBeanFactory();
}
</code></pre>
<p>父类构造方法调用完成后，调用本类构造方法，初始化读取器 AnnotatedBeanDefinitionReader 和扫描器 ClassPathBeanDefinitionScanner：</p>
<pre><code class="language-java">public AnnotationConfigApplicationContext() {
   /**
    * 父类的构造方法 super()
    *创建一个读取注解的 Bean 定义读取器：reader 能读取被加了注解的类
    * 什么是 bean 定义？BeanDefinition
    */
   this.reader = new AnnotatedBeanDefinitionReader(this);
   // 定义扫描器
   // 可以用来扫描包，继而转换成 bd
   // 但是实际上我们扫描包工作不是 scanner 这个对象
   // 是 Spring 自己 new 的一个 ClasspathBeanDefinitionScanner
   // 这里的 scanner 仅仅是为了程序员能够在外部调用 AnnotationConfigApplicationContext 对象的 scan 方法用的。
   this.scanner = new ClassPathBeanDefinitionScanner(this);
}
</code></pre>
<h2 id="11-new-annotatedbeandefinitionreaderthis">1.1 new AnnotatedBeanDefinitionReader(this)</h2>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/7%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B.png" alt="图片" loading="lazy"></figure>
<h1 id="2contextrefresh">2.context.refresh();</h1>
<p>Test 类第 12 行代码：</p>
<pre><code class="language-java">context.refresh();
</code></pre>
<p>点进去如下：</p>
<pre><code class="language-java">public void refresh() throws BeansException, IllegalStateException {
   synchronized (this.startupShutdownMonitor) {
      // Prepare this context for refreshing.
      // 准备工作包括设置启动时间、是否激活标识位，初始化属性源（property source）配置
      prepareRefresh();
      // Tell the subclass to refresh the internal bean factory.
      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
      // Prepare the bean factory for use in this context.
      // 准备 Bean 工厂
      prepareBeanFactory(beanFactory);
      try {
         // Allows post-processing of the bean factory in context subclasses.
         // 这个方法在当前版本的 spring 是没有任何代码的
         // 可能 Spring 期待在后面的版本中去扩展吧
         postProcessBeanFactory(beanFactory);
         // Invoke factory processors registered as beans in the context.
         // 在 Spring 的环境中执行已经被注册的 factory processors
         // 设置执行自定义的 ProcessBeanFactory 和 Spring 内部自己定义的，比如 ConfigurationClassPostProcessor
         invokeBeanFactoryPostProcessors(beanFactory);
         // Register bean processors that intercept bean creation.
         registerBeanPostProcessors(beanFactory);
         // Initialize message source for this context.
         initMessageSource();
         // Initialize event multicaster for this context.
         initApplicationEventMulticaster();
         // Initialize other special beans in specific context subclasses.
         onRefresh();
         // Check for listener beans and register them.
         registerListeners();
         // Instantiate all remaining (non-lazy-init) singletons.
         finishBeanFactoryInitialization(beanFactory);
         // Last step: publish corresponding event.
         finishRefresh();
      }
      catch (BeansException ex) {
         if (logger.isWarnEnabled()) {
            logger.warn(&quot;Exception encountered during context initialization - &quot; +
                  &quot;cancelling refresh attempt: &quot; + ex);
         }
         // Destroy already created singletons to avoid dangling resources.
         destroyBeans();
         // Reset 'active' flag.
         cancelRefresh(ex);
         // Propagate exception to caller.
         throw ex;
      }
      finally {
         // Reset common introspection caches in Spring's core, since we
         // might not ever need metadata for singleton beans anymore...
         resetCommonCaches();
      }
   }
}
</code></pre>
<h2 id="21-preparebeanfactory">2.1 prepareBeanFactory</h2>
<p>上述代码第 12 行准备 Bean 工厂：</p>
<pre><code class="language-java">/**
 * 配置工厂标准的特征，比如上下文的加载器 ClassLoader 和 post-processors 回调
 * Configure the factory's standard context characteristics,
 * such as the context's ClassLoader and post-processors.
 * @param beanFactory the BeanFactory to configure
 */
protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
   // Tell the internal bean factory to use the context's class loader etc.
   beanFactory.setBeanClassLoader(getClassLoader());
   // bean 表达式解析器，能够在前台页面获取 bean 当中的属性
   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
   // 对象与 string 类型的转换 &lt;property ref=&quot;dao&quot;&gt; 将dao转为对象
   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));
   // Configure the bean factory with context callbacks.
   // 添加一个后置管理器：ApplicationContextAwareProcessor 实现了 BeanPostProcessor接口：插手 Bean 的创建过程
   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
   // 忽略接口
   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);
   // BeanFactory interface not registered as resolvable type in a plain factory.
   // MessageSource registered (and found for autowiring) as a bean.
   // 依赖替换：如果注入的是 BeanFactory，就用 beanFactory 替代
   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
   beanFactory.registerResolvableDependency(ResourceLoader.class, this);
   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
   beanFactory.registerResolvableDependency(ApplicationContext.class, this);
   // Register early post-processor for detecting inner beans as ApplicationListeners.
   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));
   // Detect a LoadTimeWeaver and prepare for weaving, if found.
   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
      // Set a temporary ClassLoader for type matching.
      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
   }
   // 意思是如果自定义的 Bean 中没有名为 &quot;systemProperties&quot; 和 &quot;systemEnvironment&quot; 的 Bean
   // 则注册两个 Bean，key 为 &quot;systemProperties&quot; 和 &quot;systemEnvironment&quot;, value 为 map
   // 这两个 Bean 就是一些系统配置和系统环境信息
   // Register default environment beans.
   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
   }
   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
   }
   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
   }
}
</code></pre>
<h2 id="22-invokebeanfactorypostprocessors">2.2 invokeBeanFactoryPostProcessors</h2>
<p>看 refresh 方法的第 23 行 ：</p>
<pre><code class="language-java">invokeBeanFactoryPostProcessors(beanFactory);
</code></pre>
<p>点进去这个方法：</p>
<pre><code class="language-java">protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
   // 这个地方需要注意 getBeanFactoryPostProcessors() 是获取手动给 Spring 的 BeanFactoryPostProcessor
   // 自定义的并不仅仅是程序员自己写的
   // 自己写的可以加 @Component,也可以不加，
   // 如果加了@Component这个getBeanFactoryPostProcessors()方法得不到，应该是 Spring 自己扫描的
   // 为什么得不到？因为 getBeanFactoryPostProcessors() 这个方法是直接获取一个 list，
   // 这个 list 是在 AnnotationConfigApplicationContext被定义
   // 所谓的自定义的就是你手动调用 AnnotationConfigApplicationContext.addBeanFactoryPostProcessor(new XxxBeanFactoryPostProcessor());
   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
   // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
   // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
   if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
   }
}
</code></pre>
<h3 id="221-getbeanfactorypostprocessors">2.2.1 getBeanFactoryPostProcessors</h3>
<p>上述代码第 9 行中的 getBeanFactoryPostProcessors()：</p>
<pre><code class="language-java">public List&lt;BeanFactoryPostProcessor&gt; getBeanFactoryPostProcessors() {
   return this.beanFactoryPostProcessors;
}
</code></pre>
<p>beanFactoryPostProcessors 变量的定义如下：</p>
<pre><code class="language-java">private final List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors = new ArrayList&lt;&gt;();
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E8%87%AA%E5%AE%9A%E4%B9%89beanFactoryPostProcessor.png" alt="图片" loading="lazy"></figure>
<h3 id="222-invokebeanfactorypostprocessors">2.2.2 invokeBeanFactoryPostProcessors</h3>
<p>同样的 invokeBeanFactoryPostProcessors 方法的第 9 行：</p>
<pre><code class="language-java">public static void invokeBeanFactoryPostProcessors(
      ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) {
   // Invoke BeanDefinitionRegistryPostProcessors first, if any.
   Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;();
   if (beanFactory instanceof BeanDefinitionRegistry) {
      BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
      // 定义两个 list， BeanDefinitionRegistryPostProcessor 实现了 BeanFactoryPostProcessor 接口
      // 因为 bdrp 是子类，子类扩展了父类中的功能。
      List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;();
      List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;(); 
      // 自定义的 beanFactoryPostProcessors
      // 因为传参，所以 beanFactoryPostProcessors 是 BeanFactoryPostProcessor 类型
      // 这里因为 beanFactoryPostProcessors长度为0，所以不会进入 for 循环 
      for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
         // 判断 postProcessor 是否是 BeanFactoryPostProcessor 的子类 BeanDefinitionRegistryPostProcessor
         if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
            BeanDefinitionRegistryPostProcessor registryProcessor =
                  (BeanDefinitionRegistryPostProcessor) postProcessor;
            registryProcessor.postProcessBeanDefinitionRegistry(registry);
            registryProcessors.add(registryProcessor);
         }
         else {
         // 如果 postProcessor 不是 BeanFactoryPostProcessor 的子类 BeanDefinitionRegistryPostProcessor，那 postProcessor 就一定是 BeanFactoryPostProcessor 类型，添加到 List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors 中
            regularPostProcessors.add(postProcessor);
         }
      }
      
      // 这个 currentRegistryProcessors 放的是 Spring 内部自己实现了 BeanDefinitionRegistryPostProcessor 接口的对象
      List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;();
      // BeanDefinitionRegistryPostProcessor 等于 BeanFactoryPostProcessor
      String[] postProcessorNames =
            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
      // 这个地方可以得到一个 BeanFactoryPostProcessor，因为是 Spring 默认在最开始自己注册的
      // 为什么要在最开始注册这个呢？
      // 因为 Spring 的工厂需要注解去扫描等等功能
      // 而这些功能都是需要在 Spring 工厂初始化完成之前就执行
      // 要么在工厂最开始的时候，要么在工厂初始化之中，反正不能在之后
      // 因为如果在之后就没有意义，因为那个时候已经需要使用工厂了
      // 所以这里 Spring 在一开始就注册了一个 BeanFactoryPostProcessor，用来插手 springFactory 的实例化过程
      // 在这个地方断点可以知道这个类叫做 ConfigurationClassPostProcessor
      // ConfigurationClassPostProcessor 那么这个类能干嘛呢？可以参考源码
      // 下面对这个“插手 Spring 工厂实例化过程”的类重点解释
      for (String ppName : postProcessorNames) {
         if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
         }
      }
      // 排序不重要，况且 currentRegistryProcessor 这里也只有一个数据
      sortPostProcessors(currentRegistryProcessors, beanFactory);
      // 合并 List，不重要（为什么要合并，因为有自定义的Spring自己的）
      registryProcessors.addAll(currentRegistryProcessors);
      // 最重要。注意这里是方法调用
      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
      currentRegistryProcessors.clear();
      // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
      for (String ppName : postProcessorNames) {
         if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
         }
      }
      sortPostProcessors(currentRegistryProcessors, beanFactory);
      registryProcessors.addAll(currentRegistryProcessors);
      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
      currentRegistryProcessors.clear();
      // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
      boolean reiterate = true;
      while (reiterate) {
         reiterate = false;
         postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
         for (String ppName : postProcessorNames) {
            if (!processedBeans.contains(ppName)) {
               currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
               processedBeans.add(ppName);
               reiterate = true;
            }
         }
         sortPostProcessors(currentRegistryProcessors, beanFactory);
         registryProcessors.addAll(currentRegistryProcessors);
         invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
         currentRegistryProcessors.clear();
      }
      // Now, invoke the postProcessBeanFactory callback of all processors handled so far.
      invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
      invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
   }
   else {
      // Invoke factory processors registered with the context instance.
      invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
   }
   // Do not initialize FactoryBeans here: We need to leave all regular beans
   // uninitialized to let the bean factory post-processors apply to them!
   String[] postProcessorNames =
         beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);
   // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
   // Ordered, and the rest.
   List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();
   List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();
   List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();
   for (String ppName : postProcessorNames) {
      if (processedBeans.contains(ppName)) {
         // skip - already processed in first phase above
      }
      else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
         priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
      }
      else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
         orderedPostProcessorNames.add(ppName);
      }
      else {
         nonOrderedPostProcessorNames.add(ppName);
      }
   }
   // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
   invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);
   // Next, invoke the BeanFactoryPostProcessors that implement Ordered.
   List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();
   for (String postProcessorName : orderedPostProcessorNames) {
      orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
   }
   sortPostProcessors(orderedPostProcessors, beanFactory);
   invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);
   // Finally, invoke all other BeanFactoryPostProcessors.
   List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();
   for (String postProcessorName : nonOrderedPostProcessorNames) {
      nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
   }
   invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);
   // Clear cached merged bean definitions since the post-processors might have
   // modified the original metadata, e.g. replacing placeholders in values...
   beanFactory.clearMetadataCache();
}
</code></pre>
<p>上述第 11、12、31 行分别定义了一个 List：</p>
<ul>
<li>List<BeanFactoryPostProcessor> regularPostProcessors：放程序员手动添加的 BeanFactoryPostProcessor</li>
<li>List<BeanDefinitionRegistryPostProcessor> registryProcessors：放程序员手动添加的 BeanDefinitionRegistryPostProcessor</li>
<li>List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors：放 Spring 内部自己的 BeanDefinitionRegistryPostProcessor</li>
</ul>
<p>上述第 35-36 行代码：</p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/currentRegistryProcessors.png" alt="图片" loading="lazy"></figure>
<p>上述第 47-51 行代码：</p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/postProcessorNames.png" alt="图片" loading="lazy"></figure>
<p>上述代码第 58 行：</p>
<pre><code class="language-java">private static void invokeBeanDefinitionRegistryPostProcessors(
      Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry) {
   for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
      postProcessor.postProcessBeanDefinitionRegistry(registry);
   }
}
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/postProcessors.png" alt="图片" loading="lazy"></figure>
<p>点进去上述第  5 行代码：</p>
<pre><code class="language-java">@Override
public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
   int registryId = System.identityHashCode(registry);
   if (this.registriesPostProcessed.contains(registryId)) {
      throw new IllegalStateException(
            &quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot; + registry);
   }
   if (this.factoriesPostProcessed.contains(registryId)) {
      throw new IllegalStateException(
            &quot;postProcessBeanFactory already called on this post-processor against &quot; + registry);
   }
   this.registriesPostProcessed.add(registryId);
   processConfigBeanDefinitions(registry);
}
</code></pre>
<h4 id="2221-processconfigbeandefinitions">2.2.2.1 processConfigBeanDefinitions</h4>
<p>点进上述第 14 行代码：</p>
<pre><code class="language-java">public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
   // app 提供的 bean：每扫描到添加了 @Configuraion 注解的类就添加到这个 set 集合中
   List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;();
   // 获取容器中注册的所有 bean 名字
   String[] candidateNames = registry.getBeanDefinitionNames();
   // 依次取出每个&lt;beanName,beanDefinition&gt;
   for (String beanName : candidateNames) {
      BeanDefinition beanDef = registry.getBeanDefinition(beanName);
      // 判断当前 bean 是否被处理过：使用 isFullConfigurationClass 来标识
      if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
            ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {
         // 如果 BeanDefinition 中的 configurationClass 属性为 full 或者 lite，则意味着已经处理过了，直接跳过
         // 这里需要结合下面的代码才能理解
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Bean definition has already been processed as a configuration class: &quot; + beanDef);
         }
      }
      // 判断这个 BeanDefinition 是否是 Configuration类，这其实主要是看是否有
      else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
         configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
      }
   }
   // Return immediately if no @Configuration classes were found
   if (configCandidates.isEmpty()) {
      return;
   }
   // 排序，根据 order，不重要
   // Sort by previously determined @Order value, if applicable
   configCandidates.sort((bd1, bd2) -&gt; {
      int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
      int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
      return Integer.compare(i1, i2);
   });
   // Detect any custom bean name generation strategy supplied through the enclosing application context
   SingletonBeanRegistry sbr = null;
   // 如果 BeanDefinitionRegistry 是 SingletonBeanRegistry 子类的话
   // 由于会将 registry 强转为 SingletonBeanRegistry
   if (registry instanceof SingletonBeanRegistry) {
      sbr = (SingletonBeanRegistry) registry;
      if (!this.localBeanNameGeneratorSet) {//是否有自定义的
         BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);
         // SingletonBeanRegistry 中有 id 为 org.springframework.context.annotation.internalConfigurationBeanNameGenerator
         // 如果有则利用它的，否则则使用 Spring 默认的
         if (generator != null) {
            this.componentScanBeanNameGenerator = generator;
            this.importBeanNameGenerator = generator;
         }
      }
   }
   if (this.environment == null) {
      this.environment = new StandardEnvironment();
   }
   // Parse each @Configuration class
   // 实例化 ConfigurationClassParser 为了解析各个配置类
   ConfigurationClassParser parser = new ConfigurationClassParser(
         this.metadataReaderFactory, this.problemReporter, this.environment,
         this.resourceLoader, this.componentScanBeanNameGenerator, registry);
   // 实例化 2 个 set，candidates 用于将之前加入的 configCandidates 进行去重
   // 因为可能有多个配置类重复了
   // alreadyParsed 用户判断是否处理过
   Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates);
   Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size());
   do {
      parser.parse(candidates);
      parser.validate();
      Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());
      configClasses.removeAll(alreadyParsed);
      // Read the model and create bean definitions based on its content
      if (this.reader == null) {
         this.reader = new ConfigurationClassBeanDefinitionReader(
               registry, this.sourceExtractor, this.resourceLoader, this.environment,
               this.importBeanNameGenerator, parser.getImportRegistry());
      }
      // 把扫描出来的 bean 对应的 beanDefinitions 添加到 factory 的 map 当中
      this.reader.loadBeanDefinitions(configClasses);
      alreadyParsed.addAll(configClasses);
      candidates.clear();
      if (registry.getBeanDefinitionCount() &gt; candidateNames.length) {
         String[] newCandidateNames = registry.getBeanDefinitionNames();
         Set&lt;String&gt; oldCandidateNames = new HashSet&lt;&gt;(Arrays.asList(candidateNames));
         Set&lt;String&gt; alreadyParsedClasses = new HashSet&lt;&gt;();
         for (ConfigurationClass configurationClass : alreadyParsed) {
            alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
         }
         for (String candidateName : newCandidateNames) {
            if (!oldCandidateNames.contains(candidateName)) {
               BeanDefinition bd = registry.getBeanDefinition(candidateName);
               if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp;
                     !alreadyParsedClasses.contains(bd.getBeanClassName())) {
                  candidates.add(new BeanDefinitionHolder(bd, candidateName));
               }
            }
         }
         candidateNames = newCandidateNames;
      }
   }
   while (!candidates.isEmpty());
   // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes
   if (sbr != null &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {
      sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
   }
   if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {
      // Clear cache in externally provided MetadataReaderFactory; this is a no-op
      // for a shared cache since it'll be cleared by the ApplicationContext.
      ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();
   }
}
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/getBeanDefinitionNames.png" alt="图片" loading="lazy"></figure>
<h5 id="22211-checkconfigurationclasscandidate">2.2.2.1.1 checkConfigurationClassCandidate</h5>
<p>上述代码第 19 行：</p>
<pre><code class="language-java">else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
</code></pre>
<p>refresh() 的主要功能是要解析类：Spring 认为添加了@Configuration、@Component、@Import...注解的类都是需要解析的类。<br>
如何将一个 User 类变成 BeanDefinition：XxxBeanDefinition bd = new XxxBeanDefinition(user);</p>
<p>Spring 如何判断一个类是否是应该解析的类？</p>
<p>①判断一个 bd 是否被加了注解（AnnotatedBeanDefinition abd = new AnnotatedBeanDefinition(AppConfig.class); register.regisyBD(abd); ）；②把信息（元数据）拿出来；③根据信息判断加了什么注解</p>
<pre><code class="language-java">public static boolean checkConfigurationClassCandidate(BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) {
   String className = beanDef.getBeanClassName();
   if (className == null || beanDef.getFactoryMethodName() != null) {
      return false;
   }
   AnnotationMetadata metadata;
   // 判断这个 bd 是否被加了注解
   if (beanDef instanceof AnnotatedBeanDefinition &amp;&amp;
         className.equals(((AnnotatedBeanDefinition) beanDef).getMetadata().getClassName())) {
      // Can reuse the pre-parsed metadata from the given BeanDefinition...
      // 如果 BeanDefinition 是 AnnotatedBeanDefinition 的实例，并且 className 和 BeanDefinition 中的元数据的类名相同
      // 则直接从 BeanDefinition 获得元数据Metadata
      metadata = ((AnnotatedBeanDefinition) beanDef).getMetadata();
   }
   else if (beanDef instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) beanDef).hasBeanClass()) {
      // Check already loaded Class if present...
      // since we possibly can't even load the class file for this Class.
      // 如果 BeanDefinition 是 AbstractBeanDefinition 的实例，并且 beanDef 有 beanClass 属性存在
      // 则实例化 StandardAnnotationMetadata
      Class&lt;?&gt; beanClass = ((AbstractBeanDefinition) beanDef).getBeanClass();
      metadata = new StandardAnnotationMetadata(beanClass, true);
   }
   else {
      try {
         MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);
         metadata = metadataReader.getAnnotationMetadata();
      }
      catch (IOException ex) {
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Could not find class file for introspecting configuration annotations: &quot; + className, ex);
         }
         return false;
      }
   }
   // 判断当前这个 bd 中存在的类是不是加了 @Configuration 注解，但是如果加了 @Configuration，下面的这几个注解就不再判断，因为这是一个 if-else if 分支
   // 只有满足了 &quot;没有加 @Configuration注解&quot;，才会走 else 分支去判断是否添加了其他注解
   if (isFullConfigurationCandidate(metadata)) {
      // 如果存在 Configuration 注解，则为 BeanDefinition 设置 configurationClass 属性为 FULL
      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);
   }
   // 判断是否加了以下注解，摘录 isLiteConfigurationCandidate 的源码
   // candidateIndicators.add(Component.class.getName());
   // candidateIndicators.add(ComponentScan.class.getName());
   // candidateIndicators.add(Import.class.getName());
   // candidateIndicators.add(ImportResource.class.getName());
   else if (isLiteConfigurationCandidate(metadata)) {
      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
   }
   else {
      return false;
   }
   // It's a full or lite configuration candidate... Let's determine the order value, if any.
   Integer order = getOrder(metadata);
   if (order != null) {
      beanDef.setAttribute(ORDER_ATTRIBUTE, order);
   }
   return true;
}
</code></pre>
<p>上述代码第 39 行，判断是否加了 @Configuration 注解</p>
<pre><code class="language-java">public static boolean isFullConfigurationCandidate(AnnotationMetadata metadata) {
   return metadata.isAnnotated(Configuration.class.getName());
}
</code></pre>
<p>上述代码第 48 行，判断是否加了其他注解：</p>
<pre><code class="language-java">public static boolean isLiteConfigurationCandidate(AnnotationMetadata metadata) {
   // Do not consider an interface or an annotation...
   if (metadata.isInterface()) {
      return false;
   }
   // Any of the typical annotations found?
   for (String indicator : candidateIndicators) {
      if (metadata.isAnnotated(indicator)) {
         return true;
      }
   }
   // Finally, let's look for @Bean methods...
   try {
      return metadata.hasAnnotatedMethods(Bean.class.getName());
   }
   catch (Throwable ex) {
      if (logger.isDebugEnabled()) {
         logger.debug(&quot;Failed to introspect @Bean methods on class [&quot; + metadata.getClassName() + &quot;]: &quot; + ex);
      }
      return false;
   }
}
</code></pre>
<p>上述代码第 8 行中提到的 candidateIndicators</p>
<pre><code class="language-java">private static final Set&lt;String&gt; candidateIndicators = new HashSet&lt;&gt;(8);
static {
   candidateIndicators.add(Component.class.getName());
   candidateIndicators.add(ComponentScan.class.getName());
   candidateIndicators.add(Import.class.getName());
   candidateIndicators.add(ImportResource.class.getName());
}
</code></pre>
<p>关于 39-48 行的 if-else if 判断是否添加注解，其中 &quot;eles if&quot; 分支的作用，补充说明：</p>
<ul>
<li>如果一个类添加了 @Configuration，Spring 把它扫描出来，知道它是一个配置类，然后再去解析这个类，就可以依次扫描到其他注解：@ComponentScan、@Import</li>
<li>但是如果一个类没有添加 @Configuration 注解，只加入了 @ImportResource(&quot;spring.xml&quot;) 注解，这时候就需要使用到上述的 eles if 分支单独进行处理。</li>
</ul>
<p>上述 processConfigBeanDefinitions 方法的第 79 行：</p>
<pre><code class="language-java">parser.parse(candidates);
</code></pre>
<p>点进这个方法：</p>
<pre><code class="language-java">public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) {
   this.deferredImportSelectors = new LinkedList&lt;&gt;();
   // 根据 BeanDefinition 的类型做不同的处理，一般都会调用 ConfigurationClassParse#parse 进行解析
   for (BeanDefinitionHolder holder : configCandidates) {
      BeanDefinition bd = holder.getBeanDefinition();
      try {
         // 判断这个 bd 是否被加了注解
         if (bd instanceof AnnotatedBeanDefinition) {
            parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
         }
         else if (bd instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) {
            parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
         }
         else {
            parse(bd.getBeanClassName(), holder.getBeanName());
         }
      }
      catch (BeanDefinitionStoreException ex) {
         throw ex;
      }
      catch (Throwable ex) {
         throw new BeanDefinitionStoreException(
               &quot;Failed to parse configuration class [&quot; + bd.getBeanClassName() + &quot;]&quot;, ex);
      }
   }
   processDeferredImportSelectors();
}
</code></pre>
<p>上述代码第 9 行：</p>
<pre><code class="language-java">parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
</code></pre>
<p>点进这个方法：</p>
<pre><code class="language-java">protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {
   processConfigurationClass(new ConfigurationClass(metadata, beanName));
}
</code></pre>
<p>点进第 2 行这个方法：</p>
<pre><code class="language-java">protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
   // 判断是否应该跳过解析
   if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
      return;
   }
   // 处理 Imported 的情况
   ConfigurationClass existingClass = this.configurationClasses.get(configClass);
   if (existingClass != null) {
      if (configClass.isImported()) {
         if (existingClass.isImported()) {
            existingClass.mergeImportedBy(configClass);
         }
         // Otherwise ignore new imported config class; existing non-imported class overrides it.
         return;
      }
      else {
         // Explicit bean definition found, probably replacing an import.
         // Let's remove the old one and go with the new one.
         this.configurationClasses.remove(configClass);
         this.knownSuperclasses.values().removeIf(configClass::equals);
      }
   }
   // Recursively process the configuration class and its superclass hierarchy.
   SourceClass sourceClass = asSourceClass(configClass);
   do {
      sourceClass = doProcessConfigurationClass(configClass, sourceClass);
   }
   while (sourceClass != null);
   // 一个 map，用来存放扫描出来的 bean（注意这里的 bean 不是对象，仅仅是 bean 的信息，因为还没到实例化）
   this.configurationClasses.put(configClass, configClass);
}
</code></pre>
<p>上述代码第 28 行：</p>
<pre><code class="language-java">@Nullable
protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)
      throws IOException {
   // Recursively process any member (nested) classes first
   // 处理内部类
   processMemberClasses(configClass, sourceClass);
   // Process any @PropertySource annotations
   for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
         sourceClass.getMetadata(), PropertySources.class,
         org.springframework.context.annotation.PropertySource.class)) {
      if (this.environment instanceof ConfigurableEnvironment) {
         processPropertySource(propertySource);
      }
      else {
         logger.warn(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() +
               &quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;);
      }
   }
   // Process any @ComponentScan annotations
   Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(
         sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
   if (!componentScans.isEmpty() &amp;&amp;
         !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
      for (AnnotationAttributes componentScan : componentScans) {
         // The config class is annotated with @ComponentScan -&gt; perform the scan immediately
         Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =
               this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
         // Check the set of scanned definitions for any further config classes and parse recursively if needed
         // 检查扫描出来的类当中是否还有 Configuration
         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
            BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
            if (bdCand == null) {
               bdCand = holder.getBeanDefinition();
            }
            if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
               parse(bdCand.getBeanClassName(), holder.getBeanName());
            }
         }
      }
   }
   // Process any @Import annotations
   // 处理 @Import
   processImports(configClass, sourceClass, getImports(sourceClass), true);
   // Process any @ImportResource annotations
   AnnotationAttributes importResource =
         AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
   if (importResource != null) {
      String[] resources = importResource.getStringArray(&quot;locations&quot;);
      Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;);
      for (String resource : resources) {
         String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
         configClass.addImportedResource(resolvedResource, readerClass);
      }
   }
   // Process individual @Bean methods
   Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
   for (MethodMetadata methodMetadata : beanMethods) {
      configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
   }
   // Process default methods on interfaces
   processInterfaces(configClass, sourceClass);
   // Process superclass, if any
   if (sourceClass.getMetadata().hasSuperClass()) {
      String superclass = sourceClass.getMetadata().getSuperClassName();
      if (superclass != null &amp;&amp; !superclass.startsWith(&quot;java&quot;) &amp;&amp;
            !this.knownSuperclasses.containsKey(superclass)) {
         this.knownSuperclasses.put(superclass, configClass);
         // Superclass found, return its annotation metadata and recurse
         return sourceClass.getSuperClass();
      }
   }
   // No superclass -&gt; processing is complete
   return null;
}
</code></pre>
<p>上述代码第 47 行，判断有没有加 Import 标签</p>
<pre><code class="language-java">private Set&lt;SourceClass&gt; getImports(SourceClass sourceClass) throws IOException {
   Set&lt;SourceClass&gt; imports = new LinkedHashSet&lt;&gt;();
   Set&lt;SourceClass&gt; visited = new LinkedHashSet&lt;&gt;();
   collectImports(sourceClass, imports, visited);
   return imports;
}
</code></pre>
<p>@Import 注解：</p>
<ul>
<li>@Import(IndexDao.class)、</li>
<li>@Import(ImportSelector)、</li>
<li>@Import(ImportBeanDefinitionRegistrar)</li>
</ul>
<p>同样的上述代码第 47 行：</p>
<pre><code class="language-java">private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,
      Collection&lt;SourceClass&gt; importCandidates, boolean checkForCircularImports) {
   // 如果没有加@Import，直接返回
   if (importCandidates.isEmpty()) {
      return;
   }
   if (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) {
      this.problemReporter.error(new CircularImportProblem(configClass, this.importStack));
   }
   else {
      this.importStack.push(configClass);
      try {
         for (SourceClass candidate : importCandidates) {
            // @Import(IndexDao.class)、@Import(ImportSelector)、@Import(ImportBeanDefinitionRegistrar)
            // 判断是不是 ImportSelector
            if (candidate.isAssignable(ImportSelector.class)) {
               // Candidate class is an ImportSelector -&gt; delegate to it to determine imports
               Class&lt;?&gt; candidateClass = candidate.loadClass();
               ImportSelector selector = BeanUtils.instantiateClass(candidateClass, ImportSelector.class);
               ParserStrategyUtils.invokeAwareMethods(
                     selector, this.environment, this.resourceLoader, this.registry);
               if (this.deferredImportSelectors != null &amp;&amp; selector instanceof DeferredImportSelector) {
                  this.deferredImportSelectors.add(
                        new DeferredImportSelectorHolder(configClass, (DeferredImportSelector) selector));
               }
               else {
                  String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
                  Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames);
                  processImports(configClass, currentSourceClass, importSourceClasses, false);
               }
            }
            // 判断是不是 ImportBeanDefinitionRegistrar
            else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
               // Candidate class is an ImportBeanDefinitionRegistrar -&gt;
               // delegate to it to register additional bean definitions
               Class&lt;?&gt; candidateClass = candidate.loadClass();
               ImportBeanDefinitionRegistrar registrar =
                     BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);
               ParserStrategyUtils.invokeAwareMethods(
                     registrar, this.environment, this.resourceLoader, this.registry);
               configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
            }
            // 普通类：@Import(IndexDao.class)
            else {
               // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt;
               // process it as an @Configuration class
               this.importStack.registerImport(
                     currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
               processConfigurationClass(candidate.asConfigClass(configClass));
            }
         }
      }
      catch (BeanDefinitionStoreException ex) {
         throw ex;
      }
      catch (Throwable ex) {
         throw new BeanDefinitionStoreException(
               &quot;Failed to process import candidates for configuration class [&quot; +
               configClass.getMetadata().getClassName() + &quot;]&quot;, ex);
      }
      finally {
         this.importStack.pop();
      }
   }
}
</code></pre>
<p>插手 Spring 中 Bean 工厂的建设：<br>
BeanFactoryPostProcessor：把它设置为一个 Bean 的属性。</p>
<p>ImportBeanDefinitionRegistrar：把 map 暴露出来，用户就可以向 map 中动态添加 bean 了。</p>
<h1 id="注册-bean-的方法">注册 Bean 的方法</h1>
<h2 id="registerindexdaoimplclass">register(IndexDaoImpl.class);</h2>
<ul>
<li>bdmap.put()</li>
<li>需要的是一个类，一个类变成 BeanDefinition 的过程是没办法参与的</li>
</ul>
<h2 id="scancomssm">scan(&quot;com.ssm&quot;)</h2>
<ul>
<li>需要的是一个类，一个类变成 BeanDefinition 的过程是没办法参与的</li>
</ul>
<h2 id="importbeandefinitionregistrar">ImportBeanDefinitionRegistrar</h2>
<ul>
<li>向 map 中添加一个 bd</li>
<li>好处：可以参与一个类变成 BeanDefinition 的过程</li>
</ul>
<p>@MapperScan() 的作用：扫描 mapper</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
@MapperScan(&quot;com.ssm.dao&quot;)
public class AppConfig{
    @Bean
    public DataSource dataSource(){
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
        dataSource.setUsername(&quot;root&quot;);
        dataSource.setPassword(&quot;123456&quot;);
        dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/card&quot;);
        return dataSource;
    }
    @Bean
    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){
        SqlSessionFactoryBean sqlSessionFactoryBean =  new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource);
        return sqlSessionFactoryBean;
    }
}
</code></pre>
<pre><code class="language-java">@Component
public class CardService{
  @Autowired
  CardDao cardDao;
  public void list(){
    System.out.println(cardDao.list(&quot;xxx&quot;));
  }
}
</code></pre>
<pre><code class="language-java">public interface CardDao{
  @Select(&quot;select * from card where card_number like '%s{number}%'&quot;)
  public List&lt;Map&lt;Integer,String&gt;&gt; list(@Param(&quot;number&quot;) String number);
}
</code></pre>
<p>CardDao 是一个接口，一个接口如何变成一个对象？</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        context.getBean(CardService.class).list();
    }
}
</code></pre>
<p>@MapperScan() ：将一个接口变成一个对象，且把变成的这个对象放到 Spring 容器中。</p>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Import(MapperScannerRegistrar.class)
public @interface MapperScan {
</code></pre>
<p>Spring 在解析到 @MapperScan 后，又会去解析 @Import，然后再解析 MapperScannerRegistrar<br>
MapperScannerRegistrar 类中有一个 registerBeanDefinitions 方法，此方法有一个参数是 BeanDefinitionRegistry，即把注册器暴露出来，就可以向容器中添加 Bean 了，这个方法是在所有 Bean 执行之前执行的：</p>
<pre><code class="language-java">public class MapperScannerRegistrar implements ImportBeanDefinitionRegistrar, ResourceLoaderAware {
  private ResourceLoader resourceLoader;
  /**
   * {@inheritDoc}
   */
  @Override
  public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
</code></pre>
<p>@Autowired<br>
CardDao cardDao;</p>
<p>如果有一个类 A extends CardService，不会将类 A 自动注入给 CardDao。如果有一个类 A implements CardDao，会将类 A 注入给 CardDao。</p>
<p>模拟 Mybatis：在现在的基础上完成：① 创建一个对象；② 对象实现 CardDao 接口； ③这个对象在 Spring 容器中。</p>
<h3 id="让一个接口变成对象代理">让一个接口变成对象：代理</h3>
<p>1.测试类</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        CardDao cardDao = (CardDao) Proxy.newProxyInstance(Test.class.getClassLoader(), new Class[]{CardDao.class}, new MyInvocationHandler());
        cardDao.list(&quot;1&quot;);
    }
}
</code></pre>
<p>2.MyInvocationHandler</p>
<pre><code class="language-java">public class MyInvocationHandler implements InvocationHandler {
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;handler...&quot;);
        return null;
    }
}
</code></pre>
<p>3.输出结果：</p>
<pre><code>handler...
</code></pre>
<p>4.分析：<br>
通过 JDK 动态代理生成一个对象，执行代理方法时打印了 handler...</p>
<p>上述步骤 1、2、3、4 已经实现了① 创建一个对象；② 对象实现 CardDao 接口，接下来实现步骤 ③将这个对象放到 Spring 容器中</p>
<h3 id="将对象放到-spring-容器中">将对象放到 Spring 容器中</h3>
<h4 id="方法一实现-beanfactorypostprocessor-接口">方法一：实现 BeanFactoryPostProcessor 接口</h4>
<pre><code class="language-java">// 对 Bean 工厂进行插手，只能对 Bean 工厂进行初始化，不能将对象放入到 map 中，没有对应API
public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
    }
}
</code></pre>
<h4 id="方法二实现-importselector-接口">方法二：实现 ImportSelector  接口</h4>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
@MapperScan(&quot;com.ssm&quot;)
// Spring 把 MyImportSelect 类中 invoke 方法返回的字符串数组类名 new 出对象放到 Spring 工厂中
@Import(MyImportSelect.class) 
public class AppConfig{
</code></pre>
<pre><code class="language-java">public class MyImportSelect implements ImportSelector {
    @Override
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        // 因为是要将代理对象放到Spring工厂中，但是这里得不到代理对象的类名
        return new String[]{CardDaoProxy.class.getSimpleName()};
    }
}
</code></pre>
<p>必须先产生代理对象出来，然后再来执行：Spring 扫描 @Import 注解，将 MyImportSelect 类中 invoke 方法返回的字符串数组类名 new 出对象放到 Spring 工厂中。</p>
<h4 id="方法三实现-importbeandefinitionregistrar-接口">方法三：实现 ImportBeanDefinitionRegistrar  接口</h4>
<p>1、实现 ImportBeanDefinitionRegistrar  接口：创建代理对象，并添加到 Spring 容器中</p>
<pre><code class="language-java">public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        // 1.得到 BeanDefinition
            // 扫描所有接口：扫描 com.ssm.dao 下所有接口。这里为了方便写死，不模拟动态了
        // carDao：代理对象
        CardDao cardDao = (CardDao) Proxy.newProxyInstance(Test.class.getClassLoader(), new Class[]{CardDao.class}, new MyInvocationHandler());
        cardDao.list(&quot;2&quot;);
        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(cardDao.getClass());
        GenericBeanDefinition beanDefinition = (GenericBeanDefinition) builder.getBeanDefinition();
        registry.registerBeanDefinition(&quot;cardDao&quot;,beanDefinition);
    }
}
</code></pre>
<p>2、配置类扫描 MyImportBeanDefinitionRegistrar</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
@MapperScan(&quot;com.ssm&quot;)
@Import(MyImportBeanDefinitionRegistrar.class)
public class AppConfig{
</code></pre>
<p>3、测试类：初始化 Spring 容器</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
    }
}
</code></pre>
<p>5、测试结果：</p>
<pre><code>handler...
Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'cardDao': Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'java.lang.reflect.InvocationHandler' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {}
</code></pre>
<p>6、分析<br>
代理对象的代理方法执行了（证明 cardDao.list(&quot;2&quot;) 执行到了），但是代理对象注入不进来，因为 Spring 没有办法这样处理一个类，这个 dao 中的某些属性 Spring 没有注入进来。</p>
<pre><code class="language-java">public class MyInvocationHandler implements InvocationHandler {
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;proxy...&quot;);
        return null;
    }
}
</code></pre>
<p>7、接口不能实例化</p>
<pre><code class="language-java">public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        // 得到 BeanDefinition(扫描所有接口：扫描 com.ssm.dao 下所有接口。这里为了方便写死，不模拟动态了)
        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(CardDao.class);
        // 得到 BeanDefinition，BeanDefinition 有一个属性 beanClass 表示类型 CardDao.class
        GenericBeanDefinition beanDefinition = (GenericBeanDefinition) builder.getBeanDefinition();
        registry.registerBeanDefinition(&quot;cardDao&quot;,beanDefinition);
    }
}
</code></pre>
<pre><code>Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.ssm.dao.CardDao]: Specified class is an interface
</code></pre>
<p>根据 beanName=&quot;cardDao&quot; 取出 BeanDefinition，当执行完上述第 5 行代码后，取出的 BeanDefinition 类型为 CardDao 接口，接口不能实例化。<br>
所以需要将一个代理对象放入 map 中，{ beanName=&quot;dao&quot;, BeanDefinition={beanClass=$Proxy01.class; ...} }</p>
<p>8、引入 FactoryBean</p>
<pre><code class="language-java">public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        // 得到 BeanDefinition(扫描所有接口：扫描 com.ssm.dao 下所有接口。这里为了方便写死，不模拟动态了)
        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(CardDao.class);
        // 得到 BeanDefinition，BeanDefinition 有一个属性 beanClass 表示类型 CardDao
        GenericBeanDefinition beanDefinition = (GenericBeanDefinition) builder.getBeanDefinition();
        // 给 BeanDefinition 添加构造方法，因为 public MyFactoryBean(Class clazz) { 构造方法有参数
        beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(&quot;com.ssm.dao.CardDao&quot;);
        // 设置 BeanDefinition 的 beanClass 为代理对象
        beanDefinition.setBeanClass(MyFactoryBean.class);
        registry.registerBeanDefinition(&quot;cardDao&quot;,beanDefinition);
    }
}
</code></pre>
<p>如果类实现了 FactoryBean，那么 Spring 容器当中存在两个对象，一个是 getObject() 方法返回的代理对象（name=&quot;myFactoryBean &quot;）；还有一个是当前对象 MyFactoryBean（name=&amp;myFactoryBean ） 。</p>
<pre><code class="language-java">public class MyFactoryBean implements FactoryBean, InvocationHandler {
    Class clazz;
    public MyFactoryBean(Class clazz) {
        this.clazz = clazz;
    }
    @Override
    public Object getObject() throws Exception {
        Class[] clazzs = new Class[]{clazz};
        Object proxy = Proxy.newProxyInstance(this.getClass().getClassLoader(),clazzs,this);
        return proxy;
    }
    @Override
    public Class&lt;?&gt; getObjectType() {
        return clazz;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 得到代理对象的接口，通过名字去拿方法
        Method method1 = proxy.getClass().getInterfaces()[0].getMethod(method.getName(), String.class);
        // 拿到这个方法的注解
        Select select = method1.getDeclaredAnnotation(Select.class);
        System.out.println(String.valueOf(select.value()[0]));
        System.out.println(&quot;proxy&quot;);
        return null;
    }
}
</code></pre>
<p>自定义注解：</p>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
@Import(MyImportBeanDefinitionRegistrar.class)
public @interface LuBanScan {
    String value();
}
</code></pre>
<p>配置类：</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
@LuBanScan(&quot;com.ssm&quot;)
@Import(MyImportBeanDefinitionRegistrar.class)
public class AppConfig{
</code></pre>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        CardDao cardDao = (CardDao) context.getBean(&quot;cardDao&quot;);
        cardDao.list(&quot;2&quot;);
    }
}
</code></pre>
<p>测试结果：</p>
<pre><code>select * from t1 where a=#{number}
proxy
</code></pre>
<h1 id="mybatis">MyBatis</h1>
<pre><code class="language-xml">&lt;bean id=&quot;userMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;
  &lt;property name=&quot;mapperInterface&quot; value=&quot;org.mybatis.spring.sample.mapper.UserMapper&quot; /&gt;
  &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p>如果不想使用 @MapperScan，采用上述代码同样可以完成扫描 mapper 的功能。上述代码不是将 UserMapper 注册给 MapperFactoryBean。<br>
正确含义：MapperFactoryBean 就是前面手动模拟的 MyFactoryBean：</p>
<pre><code class="language-java">public class MyFactoryBean implements FactoryBean, InvocationHandler {
    Class clazz;
    public MyFactoryBean(Class clazz) {
        this.clazz = clazz;
    }
</code></pre>
<p>上述的 xml 代码含义：将 UserMapper 作为 Class 参数传递给 MapperFactoryBean，MapperFactoryBean 得到接口后，内部动态生成代理对象。<br>
Mybatis 源码：MapperFactoryBean 内部同样有一个 Class，构造方法 MapperFactoryBean(Class<T> mapperInterface)，是不是与我们模拟的 MyFactoryBean 几乎一样呢？</p>
<pre><code class="language-java">public class MapperFactoryBean&lt;T&gt; extends SqlSessionDaoSupport implements FactoryBean&lt;T&gt; {
  private Class&lt;T&gt; mapperInterface;
  private boolean addToConfig = true;
  public MapperFactoryBean() {
    //intentionally empty 
  }
  
  public MapperFactoryBean(Class&lt;T&gt; mapperInterface) {
    this.mapperInterface = mapperInterface;
  }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring系列（七）Spring源码解析]]></title>
        <id>https://epitomm.github.io/post/spring-xi-lie-qi-spring-yuan-ma-jie-xi/</id>
        <link href="https://epitomm.github.io/post/spring-xi-lie-qi-spring-yuan-ma-jie-xi/">
        </link>
        <updated>2020-05-08T08:47:27.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      // 初始化 Spring 的环境
      context.refresh();
      IndexDao indexDao = context.getBean(IndexDaoImpl.class);
      indexDao.query();
   }
}
</code></pre>
<h1 id="1new-annotationconfigapplicationcontext">1.new AnnotationConfigApplicationContext();</h1>
<p>第 6 行代码，new AnnotationConfigApplicationContext(); 时，由于 AnnotationConfigApplicationContext 有父类</p>
<pre><code class="language-java">public class AnnotationConfigApplicationContext extends GenericApplicationContext implements AnnotationConfigRegistry {
</code></pre>
<h2 id="11-genericapplicationcontext">1.1 GenericApplicationContext()</h2>
<p>所以会先调用父类 GenericApplicationContext  的构造方法（上一篇文章中提到过），今天就从它父类的构造方法说起：实例化了一个 Bean 工厂，</p>
<pre><code class="language-java">/**
 * Create a new GenericApplicationContext.
 * @see #registerBeanDefinition
 * @see #refresh
 */
public GenericApplicationContext() {
   // 实例化一个 Bean 工厂
   this.beanFactory = new DefaultListableBeanFactory();
}
</code></pre>
<h3 id="111-defaultlistablebeanfactory">1.1.1 DefaultListableBeanFactory</h3>
<p>这个 Bean 工厂内到底有些什么属性呢，这里列举出几个常用重要属性：</p>
<pre><code class="language-java">/** 从序列化ID映射到工厂实例 */
private static final Map&lt;String, Reference&lt;DefaultListableBeanFactory&gt;&gt; serializableFactories =
      new ConcurrentHashMap&lt;&gt;(8);
/** 该工厂的可选ID，用于序列化 */
// 可以理解为身份证号
@Nullable
private String serializationId;
// 工厂中能够处理类的实例化顺序
@Nullable
private Comparator&lt;Object&gt; dependencyComparator;
// map&lt;beanName,beanDefinition&gt;
private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);
/** List of bean definition names, in registration order */
private volatile List&lt;String&gt; beanDefinitionNames = new ArrayList&lt;&gt;(256);
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/bean%E5%B7%A5%E5%8E%82.png" alt="图片" loading="lazy"></figure>
<h2 id="12-annotationconfigapplicationcontext">1.2 AnnotationConfigApplicationContext()</h2>
<p>调用完父类构造方法后，调用本类构造方法，即</p>
<pre><code class="language-java">public AnnotationConfigApplicationContext() {
   /**
    * 父类的构造方法 super()
    *创建一个读取注解的 Bean 定义读取器：reader 能读取被加了注解的类
    * 什么是 bean 定义？BeanDefinition
    */
   this.reader = new AnnotatedBeanDefinitionReader(this);
   // 定义扫描器
   this.scanner = new ClassPathBeanDefinitionScanner(this);
}
</code></pre>
<h3 id="121-thisreader-new-annotatedbeandefinitionreaderthis">1.2.1 this.reader = new AnnotatedBeanDefinitionReader(this);</h3>
<p>我们来看上述代码第 7 行的参数为 this（AnnotatedBeanDefinitionReader），点进这个方法看到参数类型为 BeanDefinitionRegistry，也就是意味着 AnnotatedBeanDefinitionReader = BeanDefinitionRegistry</p>
<pre><code class="language-java">public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry) {
   this(registry, getOrCreateEnvironment(registry));
}
</code></pre>
<h4 id="1211-annotatedbeandefinitionreaderbeandefinitionregistry-registry-environment-environment">1.2.1.1 AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment)</h4>
<p>这里调用了一个重载的构造方法</p>
<pre><code class="language-java">public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) {
   Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;);
   Assert.notNull(environment, &quot;Environment must not be null&quot;);
   this.registry = registry;
   this.conditionEvaluator = new ConditionEvaluator(registry, environment, null);
   AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
}
</code></pre>
<p>看第 6 行点进去</p>
<pre><code class="language-java">public static void registerAnnotationConfigProcessors(BeanDefinitionRegistry registry) {
   registerAnnotationConfigProcessors(registry, null);
}
</code></pre>
<p>在点进去第 2 行这个方法：</p>
<pre><code class="language-java">public static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors(
      BeanDefinitionRegistry registry, @Nullable Object source) {
   // 通过 registry 得到 Bean 工厂
   DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);
   if (beanFactory != null) {
      // AnnotationAwareOrderComparator 主要能解析 @Order 注解和 @Priority
      if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {
         // ContextAnnotationAutowireCandidateResolver 提供处理器延迟加载的功能
         beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);
      }
      if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) {
         beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());
      }
   }
   Set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;&gt;(8);
   // BeanDefinition的注册，这里很重要，需要理解注册每个 bean 的类型
   if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {
      // 需要注意的是 ConfigurationClassPostProcessor 的类型是 BeanDefinitionRegistryPostProcessor
      // 而 BeanDefinitionRegistryPostProcessor 最终实现 BeanFactoryPostProcess
      RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);
      def.setSource(source);
      beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
   }
   if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {
      RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);
      def.setSource(source);
      beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
   }
   if (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {
      RootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);
      def.setSource(source);
      beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
   }
   // Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.
   if (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {
      RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);
      def.setSource(source);
      beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));
   }
   // Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.
   if (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {
      RootBeanDefinition def = new RootBeanDefinition();
      try {
         def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,
               AnnotationConfigUtils.class.getClassLoader()));
      }
      catch (ClassNotFoundException ex) {
         throw new IllegalStateException(
               &quot;Cannot load optional framework class: &quot; + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);
      }
      def.setSource(source);
      beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));
   }
   
   if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {
      RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);
      def.setSource(source);
      beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));
   }
   if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {
      RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);
      def.setSource(source);
      beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));
   }
   return beanDefs;
}
</code></pre>
<p>上述代码第 24 行</p>
<pre><code class="language-java">beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
</code></pre>
<pre><code class="language-java">private static BeanDefinitionHolder registerPostProcessor(
      BeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName) {
   definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
   registry.registerBeanDefinition(beanName, definition);
   return new BeanDefinitionHolder(definition, beanName);
}
</code></pre>
<p>上述第 6 行代码：通过 registry 的 registerBeanDefinition 方法将 &lt;beanName,definition&gt; 放到 map 中：</p>
<h3 id="122-thisscanner-new-classpathbeandefinitionscannerthis">1.2.2 this.scanner = new ClassPathBeanDefinitionScanner(this);</h3>
<p>继续看本类构造方法的第 9 行，能够扫描一个类，并且转换成 BeanDefinition</p>
<pre><code class="language-java">public AnnotationConfigApplicationContext() {
   /**
    * 父类的构造方法 super()
    *创建一个读取注解的 Bean 定义读取器：reader 能读取被加了注解的类
    * 什么是 bean 定义？BeanDefinition
    */
   this.reader = new AnnotatedBeanDefinitionReader(this);
   // 定义扫描器
   this.scanner = new ClassPathBeanDefinitionScanner(this);
}
</code></pre>
<h1 id="2contextregisterappconfigclass">2.context.register(AppConfig.class);</h1>
<p>接下来看 Test 测试类的第 10 行：</p>
<pre><code class="language-java">context.register(AppConfig.class);
</code></pre>
<p>点进 register 方法如下：</p>
<pre><code class="language-java">public void register(Class&lt;?&gt;... annotatedClasses) {
   Assert.notEmpty(annotatedClasses, &quot;At least one annotated class must be specified&quot;);
   this.reader.register(annotatedClasses);
}
</code></pre>
<p>第 3 行：调用 reader 的 register() 方法，将  AppConfig.class 这个普通的类交给 reader，由 reader 将它转化成 BeanDefinition。那么这个具体的 register 方法是如何实现的呢？点进去这个 register() 方法</p>
<h2 id="21-doregisterbean">2.1 doRegisterBean</h2>
<p>(中间省略两步代码)最终会到 doRegisterBean 方法：</p>
<pre><code class="language-java">&lt;T&gt; void doRegisterBean(Class&lt;T&gt; annotatedClass, @Nullable Supplier&lt;T&gt; instanceSupplier, @Nullable String name,
      @Nullable Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers) {
   /**
    *
    * AnnotatedGenericBeanDefinition：被注解的 BeanDefinition(描述Bean)
    * 将 bean 放入 map 中，bean 的 name 是 map 的 key，
    * map 中的 value 为 AnnotatedGenericBeanDefinition 对象
    */
   AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass);
   /**
    * 判断这个类是否需要跳过解析
    * 通过代码可以知道 Spring 判断是否跳过解析，主要判断有没有加注解
    */
   // 这个类如果没有加注解，就不需要解析。因为 AnnotatedGenericBeanDefinition 是为了注册被加了注解的；
   // 如果这个类没有被加注解，就跳过不解析
   if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) {
      return;
   }
   abd.setInstanceSupplier(instanceSupplier);
   /**
    * 得到类的作用域
    *     如果是 context.register(SpringConfig.class);则作用域没有什么作用
    *     注册单个类时需要，比如：context.register(IndexService.class);
    */
   ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);
   /**
    * 将类的作用域添加到数据结构中
    */
   abd.setScope(scopeMetadata.getScopeName());
   /**
    * 生成类的名字通过 beanNameGenerator
    */
   String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));
   /**
    * 处理类当中的其他通用注解
    * 分析源码可以知道它主要处理：Lazy、DependsOn、Primary、Role 等注解
    * 处理完成之后 processCommonDefinitionAnnotation 中依然是把它添加到数据结构 AnnotatedGenericBeanDefinition 当中
    */
   AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
   /**
    * 如果在向容器注册注解 @Bean定义时，使用了额外的限定符注解则解析
    * 关于 Qualifier 和 Primary 主要涉及到 Spring 的自动装配
    * 这里需要注意的
    *     beanName 和 qualifier 这个变量时 Annotation 类型的数组，里面不仅仅是 Qualifier 注解
    *     理论上里面存的是一切注解，所以可以看到下面的代码 Spring 去循环了这个数组
    *     然后依次判断注解当中是否包含了 Primary，是否包含了 Lazy
    */
   if (qualifiers != null) {
      for (Class&lt;? extends Annotation&gt; qualifier : qualifiers) {
         if (Primary.class == qualifier) {
            abd.setPrimary(true);
         }
         else if (Lazy.class == qualifier) {
            abd.setLazyInit(true);
         }
         else {
            abd.addQualifier(new AutowireCandidateQualifier(qualifier));
         }
      }
   }
   for (BeanDefinitionCustomizer customizer : definitionCustomizers) {
      customizer.customize(abd);
   }
   /**
    * 这个 BeanDefinitionHolder 也是一个数据结构
    * BeanDefinitionHolder 是一个 map，里面放了一个 (BeanDefinition，beanName)
    */
   BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);
   definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
   /**
    * 把上述的这个数据结构注册给 registry
    * registry 就是 AnnotationConfigApplicationContext
    * AnnotationConfigApplicationContext 在初始化的时候通过调用父类的构造方法实例化了一个 DefaultListableBeanFactory
    * registerBeanDefinition 里面就是把 definitionHolder 这个数据结构包含的信息注册到 DefaultListableBeanFactory 这个工厂
    */
   BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
}
</code></pre>
<p>为什么 deoRegisterBean 方法中要解析作用域、其他通用注解等信息？<br>
因为如果 context.register(IndexServiceImpl.class); 参数是 Bean 时，则需要获取 Bean 具体信息然后封装成 BeanDefinition，注册进 map 中。</p>
<h3 id="211-new-annotatedgenericbeandefinitionannotatedclass">2.1.1 new AnnotatedGenericBeanDefinition(annotatedClass);</h3>
<p>上述第 10 行代码，使用 new AnnotatedGenericBeanDefinition(annotatedClass); 的方式将一个普通的 annotatedClass(AppConfig.class) 转化成 AnnotatedGenericBeanDefinition。</p>
<h3 id="212-registerbeandefinitiondefinitionholder-thisregistry">2.1.2 registerBeanDefinition(definitionHolder, this.registry);</h3>
<p>上述代码第 80 行：</p>
<pre><code class="language-java">BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
</code></pre>
<p>点进 registerBeanDefinition 方法：</p>
<pre><code class="language-java">public static void registerBeanDefinition(
      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
      throws BeanDefinitionStoreException {
   // Register bean definition under primary name.
   String beanName = definitionHolder.getBeanName();
   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
   // Register aliases for bean name, if any.
   String[] aliases = definitionHolder.getAliases();
   if (aliases != null) {
      for (String alias : aliases) {
         registry.registerAlias(beanName, alias);
      }
   }
}
</code></pre>
<p>上述代码第 7 行，使用 registry 的 registerBeanDefinition 方法将 &lt;beanName,BeanDefinition&gt;注册到 map 中。<br>
<img src="https://epitomm.github.io/post-images/registerBeanDefinition.png" alt="图片" loading="lazy"></p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/bean%E5%B7%A5%E5%8E%82_2.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/register_2.png" alt="图片" loading="lazy"></figure>
<h1 id="3contextrefresh">3.context.refresh()</h1>
<pre><code class="language-java">@Override
public void refresh() throws BeansException, IllegalStateException {
   synchronized (this.startupShutdownMonitor) {
      // Prepare this context for refreshing.
      // 准备工作包括设置启动时间、是否激活标识位，初始化属性源（property source）配置
      prepareRefresh();
      // 告诉子类 refresh Bean 工厂
      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
      // 用这个上下文准备 Bean 工厂
      prepareBeanFactory(beanFactory);
      try {
         // Allows post-processing of the bean factory in context subclasses.
         postProcessBeanFactory(beanFactory);
         // Invoke factory processors registered as beans in the context.
         invokeBeanFactoryPostProcessors(beanFactory);
         // Register bean processors that intercept bean creation.
         registerBeanPostProcessors(beanFactory);
         // Initialize message source for this context.
         initMessageSource();
         // Initialize event multicaster for this context.
         initApplicationEventMulticaster();
         // Initialize other special beans in specific context subclasses.
         onRefresh();
         // Check for listener beans and register them.
         registerListeners();
         // Instantiate all remaining (non-lazy-init) singletons.
         finishBeanFactoryInitialization(beanFactory);
         // Last step: publish corresponding event.
         finishRefresh();
      }
      catch (BeansException ex) {
         if (logger.isWarnEnabled()) {
            logger.warn(&quot;Exception encountered during context initialization - &quot; +
                  &quot;cancelling refresh attempt: &quot; + ex);
         }
         // Destroy already created singletons to avoid dangling resources.
         destroyBeans();
         // Reset 'active' flag.
         cancelRefresh(ex);
         // Propagate exception to caller.
         throw ex;
      }
      finally {
         // Reset common introspection caches in Spring's core, since we
         // might not ever need metadata for singleton beans anymore...
         resetCommonCaches();
      }
   }
}
</code></pre>
<h2 id="31-preparerefresh">3.1 prepareRefresh();</h2>
<p>上述第6 行代码：<strong>准备工作包括设置启动时间、是否激活标识位，初始化属性源（property source）配置</strong></p>
<h2 id="32-obtainfreshbeanfactory">3.2 obtainFreshBeanFactory();</h2>
<p>上述第 9 行代码：得到 BeanFactory，因为需要对 BeanFactory 进行设置</p>
<pre><code class="language-java">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
</code></pre>
<h2 id="33-preparebeanfactorybeanfactory">3.3 prepareBeanFactory(beanFactory);</h2>
<p>上述第 12 行代码：准备 Bean 工厂</p>
<pre><code class="language-java">prepareBeanFactory(beanFactory);
</code></pre>
<p>点进这个 prepareBeanFactory 方法：</p>
<pre><code class="language-java">protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
   // Tell the internal bean factory to use the context's class loader etc.
   beanFactory.setBeanClassLoader(getClassLoader());
   // bean 表达式解析器
   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
   // 注册属性编辑器
   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));
   // Configure the bean factory with context callbacks.
   // 添加一个后置管理器：ApplicationContextAwareProcessor 实现了 BeanPostProcessor接口：插手 Bean 的创建过程
   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);
   // BeanFactory interface not registered as resolvable type in a plain factory.
   // MessageSource registered (and found for autowiring) as a bean.
   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
   beanFactory.registerResolvableDependency(ResourceLoader.class, this);
   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
   beanFactory.registerResolvableDependency(ApplicationContext.class, this);
   // Register early post-processor for detecting inner beans as ApplicationListeners.
   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));
   // Detect a LoadTimeWeaver and prepare for weaving, if found.
   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
      // Set a temporary ClassLoader for type matching.
      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
   }
   // Register default environment beans.
   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
   }
   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
   }
   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
   }
}
</code></pre>
<p>上述代码第 3 行，添加一个类加载器：</p>
<pre><code class="language-java">beanFactory.setBeanClassLoader(getClassLoader());
</code></pre>
<p>上述代码第 5 行，添加 bean 表达式解析器，为了能够让 BeanFactory 去解析 bean 表达式</p>
<pre><code class="language-java">//bean 表达式解析器
beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
// 注册属性编辑器
</code></pre>
<p>上述 12-17 行，添加了自动注入被忽略的列表：</p>
<pre><code class="language-java">  beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);   
</code></pre>
<p>上述代码第 27 行，添加了一个 ApplicationListenerDetector 后置处理器</p>
<pre><code class="language-java">beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));
</code></pre>
<h3 id="331-beanfactoryaddbeanpostprocessornew-applicationcontextawareprocessorthis">3.3.1 beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</h3>
<p>上述代码第 11 行，</p>
<pre><code class="language-java">// 添加一个后置管理器：ApplicationContextAwareProcessor 实现了 BeanPostProcessor接口：插手 Bean 的创建过程
beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
</code></pre>
<p>点进去 (new ApplicationContextAwareProcessor(this)：</p>
<pre><code class="language-java">public ApplicationContextAwareProcessor(ConfigurableApplicationContext applicationContext) {
   this.applicationContext = applicationContext;
   this.embeddedValueResolver = new EmbeddedValueResolver(applicationContext.getBeanFactory());
}
</code></pre>
<p>在点进去看 beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</p>
<pre><code class="language-java">@Override
public void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) {
   Assert.notNull(beanPostProcessor, &quot;BeanPostProcessor must not be null&quot;);
   // Remove from old position, if any
   this.beanPostProcessors.remove(beanPostProcessor);
   // Track whether it is instantiation/destruction aware
   if (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) {
      this.hasInstantiationAwareBeanPostProcessors = true;
   }
   if (beanPostProcessor instanceof DestructionAwareBeanPostProcessor) {
      this.hasDestructionAwareBeanPostProcessors = true;
   }
   // Add to end of list
   this.beanPostProcessors.add(beanPostProcessor);
}
</code></pre>
<p>上述 14 行 提到的 beanPostProcessors，是一个 List<BeanPostProcessor></p>
<pre><code class="language-java">/** BeanPostProcessors to apply in createBean */
private final List&lt;BeanPostProcessor&gt; beanPostProcessors = new CopyOnWriteArrayList&lt;&gt;();
</code></pre>
<h2 id="34-postprocessbeanfactorybeanfactory">3.4 postProcessBeanFactory(beanFactory);</h2>
<p>看 refresh() 看 的第 16 行代码：</p>
<pre><code class="language-java">// 这个方法在当前版本的 spring 是没有任何代码的
// 可能 Spring 期待在后面的版本中去扩展吧
postProcessBeanFactory(beanFactory);
</code></pre>
<h2 id="35-invokebeanfactorypostprocessorsbeanfactory">3.5 invokeBeanFactoryPostProcessors(beanFactory);</h2>
<p>看 refresh() 看 的第 19 行代码：</p>
<pre><code class="language-java">invokeBeanFactoryPostProcessors(beanFactory);
</code></pre>
<p>点进去这个代码：</p>
<pre><code class="language-java">protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
   // 这个地方需要注意 getBeanFactoryPostProcessors() 是获取自定义的
   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
   // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
   // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
   if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
   }
}
</code></pre>
<h3 id="351-getbeanfactorypostprocessors">3.5.1 getBeanFactoryPostProcessors()</h3>
<p>看上述第 3 行代码中的 getBeanFactoryPostProcessors()：是获取自定义的（程序员自己写的，并且没有交给 Spring 管理的，就是没有加上 @Component 注解的）</p>
<p>此时的代码 getBeanFactoryPostProcessors() 运行的结果 size=0。</p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/getBeanFactoryPostProcessors.png" alt="图片" loading="lazy"></figure>
<p>接下来我们看看什么叫做自定义的？</p>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      // 初始化 Spring 的环境
      context.refresh();
      IndexDao indexDao = context.getBean(IndexDaoImpl.class);
      indexDao.query();
      System.out.println(indexDao);
      System.out.println(context.getBean(IndexDaoImpl.class));
   }
}
</code></pre>
<p>因为 bean 默认是单例的，所以两次 context.getBean()获取的是同一个对象</p>
<pre><code class="language-java">dao...模拟查询数据库
com.ssm.dao.impl.IndexDaoImpl@47fd17e3
com.ssm.dao.impl.IndexDaoImpl@47fd17e3
</code></pre>
<p>插手 Bean 的初始化过程，将作用域设置为原型的：</p>
<p>但由于代码未添加 @Component 注解，所以这个类不会生效</p>
<pre><code class="language-java">public class MyBeanFactoryProcessor implements BeanFactoryPostProcessor {
   @Override
   public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
      AnnotatedBeanDefinition annotatedBeanDefinition = (AnnotatedBeanDefinition) beanFactory.getBeanDefinition(&quot;indexDao&quot;);
      annotatedBeanDefinition.setScope(&quot;prototype&quot;);
   }
}
</code></pre>
<p>打印效果：</p>
<pre><code class="language-java">dao...模拟查询数据库
com.ssm.dao.impl.IndexDaoImpl@47fd17e3
com.ssm.dao.impl.IndexDaoImpl@47fd17e3
</code></pre>
<p>在 refresh() 前 context.addBeanFactoryPostProcessor( new MyBeanFactoryProcessor());</p>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      context.addBeanFactoryPostProcessor( new MyBeanFactoryProcessor());
      // 初始化 Spring 的环境
      context.refresh();
      IndexDao indexDao = context.getBean(IndexDaoImpl.class);
      indexDao.query();
      System.out.println(indexDao);
      System.out.println(context.getBean(IndexDaoImpl.class));
   }
}
</code></pre>
<p>即使 MyBeanFactoryProcessor 类并没有添加注解，但是通过 addBeanFactoryPostProcessor 结果显示 IndexDao 对象为原型的了：</p>
<pre><code class="language-java">dao...模拟查询数据库
com.ssm.dao.impl.IndexDaoImpl@47fd17e3
com.ssm.dao.impl.IndexDaoImpl@7cdbc5d3
</code></pre>
<p>结论：<strong>context.addBeanFactoryPostProcessor( new MyBeanFactoryProcessor()); 就称之为自定义的</strong>。<br>
此时 getBeanFactoryPostProcessors() 执行后的结果 size 不为 0 了。</p>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/getBeanFactoryPostProcessors_2.png" alt="图片" loading="lazy"></figure>
<h3 id="352-invokebeanfactorypostprocessorsbeanfactory-getbeanfactorypostprocessors">3.5.2 invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</h3>
<pre><code class="language-java">public static void invokeBeanFactoryPostProcessors(
      ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) {
   // Invoke BeanDefinitionRegistryPostProcessors first, if any.
   Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;();
   if (beanFactory instanceof BeanDefinitionRegistry) {
      BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
      // 定义 List&lt;BeanFactoryPostProcessor&gt;
      List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;();
       // 定义 List&lt;BeanDefinitionRegistryPostProcessor&gt;
      List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;();
      // 遍历 beanFactoryPostProcessors
      for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
         // 判断如果 postProcessor 是 BeanDefinitionRegistryPostProcessor 类型，就添加到 registryProcessors 中
         if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
            BeanDefinitionRegistryPostProcessor registryProcessor =
                  (BeanDefinitionRegistryPostProcessor) postProcessor;
            registryProcessor.postProcessBeanDefinitionRegistry(registry);
            registryProcessors.add(registryProcessor);
         }
         // 否则，添加到 regularPostProcessors中
         else {
            regularPostProcessors.add(postProcessor);
         }
      }
      // Do not initialize FactoryBeans here: We need to leave all regular beans
      // uninitialized to let the bean factory post-processors apply to them!
      // Separate between BeanDefinitionRegistryPostProcessors that implement
      // PriorityOrdered, Ordered, and the rest.
      // 这个 currentRegistryProcessors 放的是 Spring 内部自己实现了 BeanDefinitionRegistryPostProcessor 接口的对象
      List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;();
      // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
      String[] postProcessorNames =
            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
            // 这个地方可以得到一个 BeanFactoryPostProcessor，因为是 Spring 默认在最开始自己注册的
            // 为什么要在最开始注册这个呢？
            // 因为 Spring 的工厂需要注解去扫描等等功能
            // 而这些功能都是需要在 Spring 工厂初始化完成之前就执行
            // 要么在工厂最开始的时候，要么在工厂初始化之中，反正不能在之后
            // 因为如果在之后就没有意义，因为那个时候已经需要使用工厂了
            // 所以这里 Spring 在一开始就注册了一个 BeanFactoryPostProcessor，用来插手 springFactory 的实例化过程
            // 在这个地方断点可以知道这个类叫做 ConfigurationClassPostProcessor
            // ConfigurationClassPostProcessor 那么这个类能干嘛呢？可以参考源码
            // 下面对这个“插手 Spirng 工厂实例化过程”的类重点解释
      for (String ppName : postProcessorNames) {
         if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
         }
      }
      // 排序不重要，况且 currentRegistryProcessor 这里也只有一个数据
      sortPostProcessors(currentRegistryProcessors, beanFactory);
      // 合并 List，不重要（为什么要合并，因为有自定义的Spring自己的）
      registryProcessors.addAll(currentRegistryProcessors);
      // 最重要。注意这里是方法调用
      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
      currentRegistryProcessors.clear();
      // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
      for (String ppName : postProcessorNames) {
         if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
         }
      }
      sortPostProcessors(currentRegistryProcessors, beanFactory);
      registryProcessors.addAll(currentRegistryProcessors);
      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
      currentRegistryProcessors.clear();
      // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
      boolean reiterate = true;
      while (reiterate) {
         reiterate = false;
         postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
         for (String ppName : postProcessorNames) {
            if (!processedBeans.contains(ppName)) {
               currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
               processedBeans.add(ppName);
               reiterate = true;
            }
         }
         sortPostProcessors(currentRegistryProcessors, beanFactory);
         registryProcessors.addAll(currentRegistryProcessors);
         invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
         currentRegistryProcessors.clear();
      }
      // Now, invoke the postProcessBeanFactory callback of all processors handled so far.
      invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
      invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
   }
   else {
      // Invoke factory processors registered with the context instance.
      invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
   }
   // Do not initialize FactoryBeans here: We need to leave all regular beans
   // uninitialized to let the bean factory post-processors apply to them!
   String[] postProcessorNames =
         beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);
   // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
   // Ordered, and the rest.
   List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();
   List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();
   List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();
   for (String ppName : postProcessorNames) {
      if (processedBeans.contains(ppName)) {
         // skip - already processed in first phase above
      }
      else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
         priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
      }
      else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
         orderedPostProcessorNames.add(ppName);
      }
      else {
         nonOrderedPostProcessorNames.add(ppName);
      }
   }
   // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
   invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);
   // Next, invoke the BeanFactoryPostProcessors that implement Ordered.
   List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();
   for (String postProcessorName : orderedPostProcessorNames) {
      orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
   }
   sortPostProcessors(orderedPostProcessors, beanFactory);
   invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);
   // Finally, invoke all other BeanFactoryPostProcessors.
   List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();
   for (String postProcessorName : nonOrderedPostProcessorNames) {
      nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
   }
   invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);
   // Clear cached merged bean definitions since the post-processors might have
   // modified the original metadata, e.g. replacing placeholders in values...
   beanFactory.clearMetadataCache();
}
</code></pre>
<h4 id="3521-listbeanfactorypostprocessor-listbeandefinitionregistrypostprocessor">3.5.2.1  List<BeanFactoryPostProcessor>、List<BeanDefinitionRegistryPostProcessor></h4>
<p>看一下上述 10-12 行：</p>
<pre><code class="language-java">// 定义 List&lt;BeanFactoryPostProcessor&gt;
List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;();
// 定义 List&lt;BeanDefinitionRegistryPostProcessor&gt;
List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;();
</code></pre>
<p>为什么定义两个 List？<br>
自己定义的 BeanFactoryProcessor可以有两种方式：</p>
<p>1.实现 BeanFactoryPostProcessor 接口</p>
<p>2.实现BeanDefinitionRegistryPostProcessor接口</p>
<p>因为 BeanDefinitionRegistryPostProcessor 实现了 BeanFactoryPostProcessor 接口</p>
<p>于是可以猜想实现 bdrp 和实现 bfp 是能够完成不同的功能，</p>
<p>因为 bdrp 是子类，子类肯定扩展了父类中的功能。</p>
<p>父类 BeanFactoryPostProcessor  中有一个 postProcessBeanFactory 方法：</p>
<pre><code class="language-java">@FunctionalInterface
public interface BeanFactoryPostProcessor {
   void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;
}
</code></pre>
<p>子类 BeanDefinitionRegistryPostProcessor  扩展了一个 postProcessBeanDefinitionRegistry() 方法：</p>
<pre><code class="language-java">public interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor {
   void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException;
}
</code></pre>
<h4 id="3522-getbeannamesfortype">3.5.2.2 getBeanNamesForType</h4>
<p>上述 invokeBeanFactoryPostProcessors 方法的第 37-54 行：</p>
<pre><code class="language-java">String[] postProcessorNames =
      beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
for (String ppName : postProcessorNames) {
   if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
      currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
      processedBeans.add(ppName);
   }
}
</code></pre>
<p>getBeanNamesForType：这个方法是 beanFactory 中的方法，顾名思义，这个方法能够得到通过类得到 bean名字，这里的 Type 指的是 bd 当中描述当前类的 Class 类型。<br>
beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false)：获取 Type 为 BeanDefinitionRegistryPostProcessor 对应的 bean 名字。</p>
<p>我们先来查看当前工厂的 map 中有哪些&lt;beanName, beanDefinition&gt;，之前说过在执行 register() 时向容器内添加了 7 个对象，我们看到有一个 BeanClass 为 ConfigurationClassPostProcessor 的类</p>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/ConfigurationClassPostProcessor.png" alt="图片" loading="lazy"></figure>
<p>我们发现 ConfigurationClassPostProcessor 类实现了 BeanDefinitionRegistryPostProcessor 接口：</p>
<pre><code class="language-java">public class ConfigurationClassPostProcessor implements BeanDefinitionRegistryPostProcessor,
      PriorityOrdered, ResourceLoaderAware, BeanClassLoaderAware, EnvironmentAware {
</code></pre>
<p>所以 beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); 就把 ConfigurationClassPostProcessor  类（Spring 内部自己定义的）拿出来了。</p>
<h4 id="3523-invokebeandefinitionregistrypostprocessors">3.5.2.3 invokeBeanDefinitionRegistryPostProcessors</h4>
<p>上述 invokeBeanFactoryPostProcessors 方法的第 60 行：</p>
<pre><code class="language-java">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
</code></pre>
<p>我们点进这个 invokeBeanDefinitionRegistryPostProcessors 方法：</p>
<pre><code class="language-java">private static void invokeBeanDefinitionRegistryPostProcessors(
      Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry) {
   // 循环所有的 BeanDefinitionRegistryPostProcessor
   for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
      postProcessor.postProcessBeanDefinitionRegistry(registry);
   }
}
</code></pre>
<p>上述代码第 5 行点进去：调用 BeanDefinitionRegistryPostProcessor<br>
扩展父类的方法 postProcessBeanDefinitionRegistry()：</p>
<pre><code class="language-java">@Override
public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
   int registryId = System.identityHashCode(registry);
   if (this.registriesPostProcessed.contains(registryId)) {
      throw new IllegalStateException(
            &quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot; + registry);
   }
   if (this.factoriesPostProcessed.contains(registryId)) {
      throw new IllegalStateException(
            &quot;postProcessBeanFactory already called on this post-processor against &quot; + registry);
   }
   this.registriesPostProcessed.add(registryId);
   processConfigBeanDefinitions(registry);
}
</code></pre>
<p>上述代码第 14 行点进去：</p>
<pre><code class="language-java">public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
   // app 提供的 bean
   List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;();
   // 获取容器中注册的所有 bean 名字
   String[] candidateNames = registry.getBeanDefinitionNames();
   // 依次取出每个&lt;beanName,beanDefinition&gt;
   for (String beanName : candidateNames) {
      BeanDefinition beanDef = registry.getBeanDefinition(beanName);
      // 判断当前 bean 是否被处理过：使用 isFullConfigurationClass 来标识
      if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
            ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {
         // 如果 BeanDefinition 中的 configurationClass 属性为 full 或者 lite，则意味着已经处理过了，直接跳过
         // 这里需要结合下面的代码才能理解
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Bean definition has already been processed as a configuration class: &quot; + beanDef);
         }
      }
      // 判断这个 BeanDefinition 是否包含了 @Configuration、@Service 注解
      else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
         configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
      }
   }
   // Return immediately if no @Configuration classes were found
   if (configCandidates.isEmpty()) {
      return;
   }
    
   // 排序，根据 order，不重要
   // Sort by previously determined @Order value, if applicable
   configCandidates.sort((bd1, bd2) -&gt; {
      int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
      int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
      return Integer.compare(i1, i2);
   });
   // Detect any custom bean name generation strategy supplied through the enclosing application context
   SingletonBeanRegistry sbr = null;
   // 如果 BeanDefinitionRegistry 是 SingletonBeanRegistry 子类的话
   // 由于会将 registry 强转为 SingletonBeanRegistry
   if (registry instanceof SingletonBeanRegistry) {
      sbr = (SingletonBeanRegistry) registry;
      if (!this.localBeanNameGeneratorSet) {
         BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);
         // SingletonBeanRegistry 中有 id 为 org.springframework.context.annotation.internalConfigurationBeanNameGenerator
         // 如果有则利用它的，否则则使用 Spring 默认的
         if (generator != null) {
            this.componentScanBeanNameGenerator = generator;
            this.importBeanNameGenerator = generator;
         }
      }
   }
   if (this.environment == null) {
      this.environment = new StandardEnvironment();
   }
   // Parse each @Configuration class
   // 实例化 ConfigurationClassParser 为了解析各个配置类
   ConfigurationClassParser parser = new ConfigurationClassParser(
         this.metadataReaderFactory, this.problemReporter, this.environment,
         this.resourceLoader, this.componentScanBeanNameGenerator, registry);
         
   // 实例化 2 个 set，candidates 用于将之前加入的 configCandidates 进行去重
   // 因为可能有多个配置类重复了
   // alreadyParsed 用户判断是否处理过
   Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates);
   Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size());
   do {
      parser.parse(candidates);
      parser.validate();
      Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());
      configClasses.removeAll(alreadyParsed);
      // Read the model and create bean definitions based on its content
      if (this.reader == null) {
         this.reader = new ConfigurationClassBeanDefinitionReader(
               registry, this.sourceExtractor, this.resourceLoader, this.environment,
               this.importBeanNameGenerator, parser.getImportRegistry());
      }
      // 把扫描出来的 bean 对应的 beanDefinitions 添加到 factory 的 map 当中
      this.reader.loadBeanDefinitions(configClasses);
      alreadyParsed.addAll(configClasses);
      candidates.clear();
      if (registry.getBeanDefinitionCount() &gt; candidateNames.length) {
         String[] newCandidateNames = registry.getBeanDefinitionNames();
         Set&lt;String&gt; oldCandidateNames = new HashSet&lt;&gt;(Arrays.asList(candidateNames));
         Set&lt;String&gt; alreadyParsedClasses = new HashSet&lt;&gt;();
         for (ConfigurationClass configurationClass : alreadyParsed) {
            alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
         }
         for (String candidateName : newCandidateNames) {
            if (!oldCandidateNames.contains(candidateName)) {
               BeanDefinition bd = registry.getBeanDefinition(candidateName);
               if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp;
                     !alreadyParsedClasses.contains(bd.getBeanClassName())) {
                  candidates.add(new BeanDefinitionHolder(bd, candidateName));
               }
            }
         }
         candidateNames = newCandidateNames;
      }
   }
   while (!candidates.isEmpty());
   // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes
   if (sbr != null &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {
      sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
   }
   if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {
      // Clear cache in externally provided MetadataReaderFactory; this is a no-op
      // for a shared cache since it'll be cleared by the ApplicationContext.
      ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();
   }
}
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/candidateNames.png" alt="图片" loading="lazy"></figure>
<p>上述 processConfigBeanDefinitions 方法第 18-21 行：</p>
<pre><code class="language-java">      // 判断这个 BeanDefinition 是否包含了 @Configuration、@Service 注解
      else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
         configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
      }      
</code></pre>
<p>checkConfigurationClassCandidate<br>
先来看上述第二行调用 checkConfigurationClassCandidate 方法判断是否加了 @Configuration 注解，checkConfigurationClassCandidate 方法如下：</p>
<pre><code class="language-java">public static boolean checkConfigurationClassCandidate(BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) {
   String className = beanDef.getBeanClassName();
   if (className == null || beanDef.getFactoryMethodName() != null) {
      return false;
   }
   AnnotationMetadata metadata;
   if (beanDef instanceof AnnotatedBeanDefinition &amp;&amp;
         className.equals(((AnnotatedBeanDefinition) beanDef).getMetadata().getClassName())) {
      // Can reuse the pre-parsed metadata from the given BeanDefinition...
      // 如果 BeanDefinition 是 AnnotatedBeanDefinition 的实例，并且 className 和 BeanDefinition 中的元数据的类名相同
      // 则直接从 BeanDefinition 获得元数据Metadata
      metadata = ((AnnotatedBeanDefinition) beanDef).getMetadata();
   }
   else if (beanDef instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) beanDef).hasBeanClass()) {
      // Check already loaded Class if present...
      // since we possibly can't even load the class file for this Class.
      Class&lt;?&gt; beanClass = ((AbstractBeanDefinition) beanDef).getBeanClass();
      metadata = new StandardAnnotationMetadata(beanClass, true);
   }
   else {
      try {
         MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);
         metadata = metadataReader.getAnnotationMetadata();
      }
      catch (IOException ex) {
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Could not find class file for introspecting configuration annotations: &quot; + className, ex);
         }
         return false;
      }
   }
  
   // 判断当前这个 bd 中存在的类是不是加了 @Configuration 注解
   if (isFullConfigurationCandidate(metadata)) {
      // 如果存在 Configuration 注解，则为 BeanDefinition 设置 configurationClass 属性为 FULL，结合 processConfigBeanDefinitions 方法的第 10 行，使用 isFullConfigurationClass 判断是否处理过
      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);
   }
   // 判断是否加了以下注解，摘录 isLiteConfigurationCandidate 的源码
   // candidateIndicators.add(Component.class.getName());
   // candidateIndicators.add(ComponentScan.class.getName());
   // candidateIndicators.add(Import.class.getName());
   // candidateIndicators.add(ImportResource.class.getName());
   else if (isLiteConfigurationCandidate(metadata)) {
      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
   }
   else {
      return false;
   }
   // It's a full or lite configuration candidate... Let's determine the order value, if any.
   // 得到排序：如果有多个加了 @Configuration 的类，根据 @Order进行排序决定解析顺序
   Integer order = getOrder(metadata);
   if (order != null) {
      beanDef.setAttribute(ORDER_ATTRIBUTE, order);
   }
   return true;
}
</code></pre>
<p>上述代码第 35 行，判断当前这个 bd 中存在的类是不是加了 @Configuration 注解：</p>
<pre><code class="language-java">public static boolean isFullConfigurationCandidate(AnnotationMetadata metadata) {
   return metadata.isAnnotated(Configuration.class.getName());
}
</code></pre>
<p>上述 checkConfigurationClassCandidate 方法第 44-46 行，判断是否加了其他注解</p>
<pre><code class="language-java">// 判断是否加了以下注解，摘录 isLiteConfigurationCandidate 的源码
// candidateIndicators.add(Component.class.getName());
// candidateIndicators.add(ComponentScan.class.getName());
// candidateIndicators.add(Import.class.getName());
// candidateIndicators.add(ImportResource.class.getName());
  else if (isLiteConfigurationCandidate(metadata)) {
      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
  }
</code></pre>
<p>点进 isLiteConfigurationCandidate 方法如下：</p>
<pre><code class="language-java">public static boolean isLiteConfigurationCandidate(AnnotationMetadata metadata) {
   // Do not consider an interface or an annotation...
   if (metadata.isInterface()) {
      return false;
   }
   // Any of the typical annotations found?
   for (String indicator : candidateIndicators) {
      if (metadata.isAnnotated(indicator)) {
         return true;
      }
   }
   // Finally, let's look for @Bean methods...
   try {
      return metadata.hasAnnotatedMethods(Bean.class.getName());
   }
   catch (Throwable ex) {
      if (logger.isDebugEnabled()) {
         logger.debug(&quot;Failed to introspect @Bean methods on class [&quot; + metadata.getClassName() + &quot;]: &quot; + ex);
      }
      return false;
   }
}
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/candidateIndicators.png" alt="图片" loading="lazy"></figure>
<p>processConfigBeanDefinitions 方法的第 62 行：</p>
<pre><code class="language-java">parser.parse(candidates);
</code></pre>
<p>点进这个 parse 方法：</p>
<pre><code class="language-java">public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) {
   this.deferredImportSelectors = new LinkedList&lt;&gt;();
   // 根据 BeanDefinition 的类型做不同的处理，一般都会调用 ConfigurationClassParse#parse 进行解析
   for (BeanDefinitionHolder holder : configCandidates) {
      BeanDefinition bd = holder.getBeanDefinition();
      try {
         // 判断这个 bd 是否被加了注解
         if (bd instanceof AnnotatedBeanDefinition) {
            parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
         }
         else if (bd instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) {
            parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
         }
         else {
            parse(bd.getBeanClassName(), holder.getBeanName());
         }
      }
      catch (BeanDefinitionStoreException ex) {
         throw ex;
      }
      catch (Throwable ex) {
         throw new BeanDefinitionStoreException(
               &quot;Failed to parse configuration class [&quot; + bd.getBeanClassName() + &quot;]&quot;, ex);
      }
   }
   processDeferredImportSelectors();
}
</code></pre>
<p>再点进上述代码第 9 行的 parse 方法：</p>
<pre><code class="language-java">protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {
   processConfigurationClass(new ConfigurationClass(metadata, beanName));
}
</code></pre>
<p>上述代码第二行调用了 processConfigurationClass 方法，点进去：</p>
<pre><code class="language-java">protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
   // 判断是否应该跳过解析
   if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
      return;
   }
   // 处理 Imported 的情况
   ConfigurationClass existingClass = this.configurationClasses.get(configClass);
   if (existingClass != null) {
      if (configClass.isImported()) {
         if (existingClass.isImported()) {
            existingClass.mergeImportedBy(configClass);
         }
         // Otherwise ignore new imported config class; existing non-imported class overrides it.
         return;
      }
      else {
         // Explicit bean definition found, probably replacing an import.
         // Let's remove the old one and go with the new one.
         this.configurationClasses.remove(configClass);
         this.knownSuperclasses.values().removeIf(configClass::equals);
      }
   }
   // Recursively process the configuration class and its superclass hierarchy.
   SourceClass sourceClass = asSourceClass(configClass);
   do {
      sourceClass = doProcessConfigurationClass(configClass, sourceClass);
   }
   while (sourceClass != null);
   
   // 一个 map，用来存放扫描出来的 bean（注意这里的 bean 不是对象，仅仅是 bean 的信息，因为还没到实例化）
   this.configurationClasses.put(configClass, configClass);
}
</code></pre>
<p>doProcessConfigurationClass</p>
<p>看上述第 28 行：</p>
<pre><code class="language-java">sourceClass = doProcessConfigurationClass(configClass, sourceClass);
</code></pre>
<p>点进这个 doProcessConfigurationClass 方法：</p>
<pre><code class="language-java">@Nullable
protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)
      throws IOException {
   // Recursively process any member (nested) classes first
   // 处理内部类
   processMemberClasses(configClass, sourceClass);
   // Process any @PropertySource annotations
   for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
         sourceClass.getMetadata(), PropertySources.class,
         org.springframework.context.annotation.PropertySource.class)) {
      if (this.environment instanceof ConfigurableEnvironment) {
         processPropertySource(propertySource);
      }
      else {
         logger.warn(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() +
               &quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;);
      }
   }
   // Process any @ComponentScan annotations
   Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(
         sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
   if (!componentScans.isEmpty() &amp;&amp;
         !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
      for (AnnotationAttributes componentScan : componentScans) {
         // The config class is annotated with @ComponentScan -&gt; perform the scan immediately
         Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =
               this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
         // Check the set of scanned definitions for any further config classes and parse recursively if needed
         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
            BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
            if (bdCand == null) {
               bdCand = holder.getBeanDefinition();
            }
            if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
               parse(bdCand.getBeanClassName(), holder.getBeanName());
            }
         }
      }
   }
   // Process any @Import annotations
   processImports(configClass, sourceClass, getImports(sourceClass), true);
   // Process any @ImportResource annotations
   AnnotationAttributes importResource =
         AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
   if (importResource != null) {
      String[] resources = importResource.getStringArray(&quot;locations&quot;);
      Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;);
      for (String resource : resources) {
         String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
         configClass.addImportedResource(resolvedResource, readerClass);
      }
   }
   // Process individual @Bean methods
   Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
   for (MethodMetadata methodMetadata : beanMethods) {
      configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
   }
   // Process default methods on interfaces
   processInterfaces(configClass, sourceClass);
   // Process superclass, if any
   if (sourceClass.getMetadata().hasSuperClass()) {
      String superclass = sourceClass.getMetadata().getSuperClassName();
      if (superclass != null &amp;&amp; !superclass.startsWith(&quot;java&quot;) &amp;&amp;
            !this.knownSuperclasses.containsKey(superclass)) {
         this.knownSuperclasses.put(superclass, configClass);
         // Superclass found, return its annotation metadata and recurse
         return sourceClass.getSuperClass();
      }
   }
   // No superclass -&gt; processing is complete
   return null;
}
</code></pre>
<p>上述代码第 23-24 行，获得带有 @ComponentScan 注解的类<br>
<img src="https://epitomm.github.io/post-images/ComponentScan.png" alt="图片" loading="lazy"></p>
<p>上述代码第 30 行：</p>
<pre><code class="language-java">this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
</code></pre>
<p>再点进去这个 parse 方法：真正解析扫描包的</p>
<pre><code class="language-java">public Set&lt;BeanDefinitionHolder&gt; parse(AnnotationAttributes componentScan, final String declaringClass) {
   ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,
         componentScan.getBoolean(&quot;useDefaultFilters&quot;), this.environment, this.resourceLoader);
   
   // 看有没有自定义外部 Bean 生命器
   Class&lt;? extends BeanNameGenerator&gt; generatorClass = componentScan.getClass(&quot;nameGenerator&quot;);
   boolean useInheritedGenerator = (BeanNameGenerator.class == generatorClass);
   scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator :
         BeanUtils.instantiateClass(generatorClass));
   // 判断这个类是不是代理的
   ScopedProxyMode scopedProxyMode = componentScan.getEnum(&quot;scopedProxy&quot;);
   if (scopedProxyMode != ScopedProxyMode.DEFAULT) {
      scanner.setScopedProxyMode(scopedProxyMode);
   }
   else {
      Class&lt;? extends ScopeMetadataResolver&gt; resolverClass = componentScan.getClass(&quot;scopeResolver&quot;);
      scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));
   }
   scanner.setResourcePattern(componentScan.getString(&quot;resourcePattern&quot;));
   for (AnnotationAttributes filter : componentScan.getAnnotationArray(&quot;includeFilters&quot;)) {
      for (TypeFilter typeFilter : typeFiltersFor(filter)) {
         scanner.addIncludeFilter(typeFilter);
      }
   }
   for (AnnotationAttributes filter : componentScan.getAnnotationArray(&quot;excludeFilters&quot;)) {
      for (TypeFilter typeFilter : typeFiltersFor(filter)) {
         scanner.addExcludeFilter(typeFilter);
      }
   }
   boolean lazyInit = componentScan.getBoolean(&quot;lazyInit&quot;);
   if (lazyInit) {
      scanner.getBeanDefinitionDefaults().setLazyInit(true);
   }
   Set&lt;String&gt; basePackages = new LinkedHashSet&lt;&gt;();
   String[] basePackagesArray = componentScan.getStringArray(&quot;basePackages&quot;);
   for (String pkg : basePackagesArray) {
      String[] tokenized = StringUtils.tokenizeToStringArray(this.environment.resolvePlaceholders(pkg),
            ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);
      Collections.addAll(basePackages, tokenized);
   }
   for (Class&lt;?&gt; clazz : componentScan.getClassArray(&quot;basePackageClasses&quot;)) {
      basePackages.add(ClassUtils.getPackageName(clazz));
   }
   if (basePackages.isEmpty()) {
      basePackages.add(ClassUtils.getPackageName(declaringClass));
   }
    
   // 得到 excludeFilter 设置的排除扫描的包
   scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {
      @Override
      protected boolean matchClassName(String className) {
         return declaringClass.equals(className);
      }
   });
   return scanner.doScan(StringUtils.toStringArray(basePackages));
}
</code></pre>
<p>上述代码第 60 行的 doScan 方法：</p>
<pre><code class="language-java">protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) {
   Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;);
   Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;&gt;();
   for (String basePackage : basePackages) {
      // 扫表 basePackage 路径下的 java 文件
      // 并把它转成 BeanDefinition 类型
      Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);
      for (BeanDefinition candidate : candidates) {
         // 解析 scope 属性
         ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
         candidate.setScope(scopeMetadata.getScopeName());
         String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
         if (candidate instanceof AbstractBeanDefinition) {
            // 如果这个类是 AbstractBeanDefinition 的子类
            // 则为它设置默认值，比如 alzy，init destroy
            postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
         }
         if (candidate instanceof AnnotatedBeanDefinition) {
            // 检查并且处理常用的注解
            // 这里的处理主要是指把常用注解的值设置到 AnnotatedBeanDefinition 当中
            // 当前前提是这个类必须是 AnnotatedBeanDefinition 类型的，说白了就是加了注解的类
            AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
         }
         if (checkCandidate(beanName, candidate)) {
            BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
            definitionHolder =
                  AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
            beanDefinitions.add(definitionHolder);
            // 就是在这个方法中，将扫描包的 Bean 添加到 map 中
            registerBeanDefinition(definitionHolder, this.registry);
         }
      }
   }
   return beanDefinitions;
}
</code></pre>
<p>上述代码第 7 行：</p>
<pre><code class="language-java">public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) {
   if (this.componentsIndex != null &amp;&amp; indexSupportsIncludeFilters()) {
      return addCandidateComponentsFromIndex(this.componentsIndex, basePackage);
   }
   else {
      return scanCandidateComponents(basePackage);
   }
}
</code></pre>
<p>上述代码第 6 行：</p>
<pre><code class="language-java">private Set&lt;BeanDefinition&gt; scanCandidateComponents(String basePackage) {
   Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;&gt;();
   try {
      String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
            resolveBasePackage(basePackage) + '/' + this.resourcePattern;
      Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);
      boolean traceEnabled = logger.isTraceEnabled();
      boolean debugEnabled = logger.isDebugEnabled();
      for (Resource resource : resources) {
         if (traceEnabled) {
            logger.trace(&quot;Scanning &quot; + resource);
         }
         if (resource.isReadable()) {
            try {
               MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);
               if (isCandidateComponent(metadataReader)) {
                  ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
                  sbd.setSource(resource);
                  if (isCandidateComponent(sbd)) {
                     if (debugEnabled) {
                        logger.debug(&quot;Identified candidate component class: &quot; + resource);
                     }
                     candidates.add(sbd);
                  }
                  else {
                     if (debugEnabled) {
                        logger.debug(&quot;Ignored because not a concrete top-level class: &quot; + resource);
                     }
                  }
               }
               else {
                  if (traceEnabled) {
                     logger.trace(&quot;Ignored because not matching any filter: &quot; + resource);
                  }
               }
            }
            catch (Throwable ex) {
               throw new BeanDefinitionStoreException(
                     &quot;Failed to read candidate component class: &quot; + resource, ex);
            }
         }
         else {
            if (traceEnabled) {
               logger.trace(&quot;Ignored because not readable: &quot; + resource);
            }
         }
      }
   }
   catch (IOException ex) {
      throw new BeanDefinitionStoreException(&quot;I/O failure during classpath scanning&quot;, ex);
   }
   return candidates;
}
</code></pre>
<p><img src="https://epitomm.github.io/post-images/parse%E5%89%8D.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/parse%E5%90%8E.png" alt="图片" loading="lazy"></p>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/bean%E5%B7%A5%E5%8E%82_3.png" alt="图片" loading="lazy"></figure>
<h1 id="spring-bean-的扩展">Spring Bean 的扩展</h1>
<h2 id="beandefinitionregistrypostprocessor">BeanDefinitionRegistryPostProcessor</h2>
<h1 id="总结">总结</h1>
<pre><code class="language-java">//实例化一个工厂DefaultListableBeanFactory

org.springframework.context.support.GenericApplicationContext-&gt;GenericApplicationContext()

  	1、实例化一个AnnotatedBeanDefinitionReader

	2、ClassPathBeanDefinitionScanner，能够扫描我们bd,能够扫描一个类，并且转换成bd
	
	org.springframework.context.annotation.AnnotationConfigApplicationContext#AnnotationConfigApplicationContext()
	
		委托AnnotationConfigUtils
	
		org.springframework.context.annotation.AnnotatedBeanDefinitionReader#AnnotatedBeanDefinitionReader()


​			

			org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors()


​			

				1、添加AnnotationAwareOrderComparator类的对象，主要去排序
	
				2、ContextAnnotationAutowireCandidateResolver
	
				3、往BeanDefinitionMap注册一个ConfigurationClassPostProcessor?  org.springframework.context.annotation.internalConfigurationAnnotationProcessor
	
					why?因为需要在invokeBeanFactoryPostProcessors
	
					invokeBeanFactoryPostProcessors主要是在spring的beanFactory初始化的过程中去做一些事情，怎么来做这些事情呢？
	
					委托了多个实现了BeanDefinitionRegistryPostProcessor或者BeanFactoryProcessor接口的类来做这些事情,有自定义的也有spring内部的
	
					其中ConfigurationClassPostProcessor就是一个spring内部的BeanDefinitionRegistryPostProcessor
	
					因为如果你不添加这里就没有办法委托ConfigurationClassPostProcessor做一些功能
	
					到底哪些功能？参考下面的注释
	
				4、RequiredAnnotationBeanPostProcessor
	
				.......
	
				org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors()
	
					//往BeanDefinitionMap注册
	
					org.springframework.context.annotation.AnnotationConfigUtils#registerPostProcessor
	
						//准备好bean工厂，实例化对象
	
						org.springframework.context.support.AbstractApplicationContext#refresh
	
						//准备工作包括设置启动时间，是否激活标识位， 初始化属性源(property source)配置
	
							org.springframework.context.support.AbstractApplicationContext#prepareRefresh
	
								//得到beanFactory?因为需要对beanFactory进行设置
	
								org.springframework.context.support.AbstractApplicationContext#obtainFreshBeanFactory
	
									//准备bean工厂
	
									1、添加一个类加载器
	
									2、添加bean表达式解释器，为了能够让我们的beanFactory去解析bean表达式
	
									3、添加一个后置处理器ApplicationContextAwareProcessor
	
									4、添加了自动注入别忽略的列表
	
									5、。。。。。。
	
									6、添加了一个ApplicationListenerDetector后置处理器（自行百度）
	
									org.springframework.context.support.AbstractApplicationContext#prepareBeanFactory
	
										目前没有任何实现
	
										org.springframework.context.support.AbstractApplicationContext#postProcessBeanFactory
	
											1、getBeanFactoryPostProcessors()得到自己定义的（就是程序员自己写的，并且没有交给spring管理，就是没有加上@Component）
	
											2、得到spring内部自己维护的BeanDefinitionRegistryPostProcessor
	
											org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors
	
												//调用这个方法
	
												//循环所有的BeanDefinitionRegistryPostProcessor
	
												//该方法内部postProcessor.postProcessBeanDefinitionRegistry
	
												org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanDefinitionRegistryPostProcessors
	
													//调用扩展方法postProcessBeanDefinitionRegistry
	
													org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry
	
														//拿出的所有bd，然后判断bd时候包含了@Configuration、@Import，@Compent。。。注解
	
														org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions
	
															1、的到bd当中描述的类的元数据（类的信息）
	
															2、判断是不是加了@Configuration   metadata.isAnnotated(Configuration.class.getName())
	
															3、如果加了@Configuration，添加到一个set当中,把这个set传给下面的方法去解析
	
															org.springframework.context.annotation.ConfigurationClassUtils#checkConfigurationClassCandidate
	
															//扫描包


​															

															org.springframework.context.annotation.ConfigurationClassParser#parse(java.util.Set&lt;org.springframework.beans.factory.config.BeanDefinitionHolder&gt;)


​																

																org.springframework.context.annotation.ConfigurationClassParser#parse(org.springframework.core.type.AnnotationMetadata, java.lang.String)
	
																	//就行了一个类型封装
	
																	org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass
	
																	1、处理内部类 一般不会写内部类
	
																	org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass
	
																		//解析扫描的一些基本信息，比如是否过滤，比如是否加入新的包。。。。。
	
																		org.springframework.context.annotation.ComponentScanAnnotationParser#parse
	
																			org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan
	
																			org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#findCandidateComponents
	
																				org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#scanCandidateComponents
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring系列（六）Spring源码解析]]></title>
        <id>https://epitomm.github.io/post/spring-xi-lie-liu-spring-yuan-ma-jie-xi/</id>
        <link href="https://epitomm.github.io/post/spring-xi-lie-liu-spring-yuan-ma-jie-xi/">
        </link>
        <updated>2020-05-06T14:11:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="先来写一个简单的-spring-案例">先来写一个简单的 spring 案例：</h1>
<p>1.准备一个接口和实现类</p>
<pre><code class="language-java">public interface IndexDao {
   void query();
}
</code></pre>
<p>接口实现类添加 @Reposity 表示把这个对象交给 Spring 管理</p>
<pre><code class="language-java">@Repository(&quot;indexDao&quot;)
public class IndexDaoImpl implements IndexDao {

   @Override
   public void query() {
      System.out.println(&quot;dao...模拟查询数据库&quot;);
   }
}
</code></pre>
<p>2.准备一个配置文件类</p>
<pre><code class="language-java">// 表名这是一个配置类
@Configuration
// 扫描包
@ComponentScan(&quot;com.ssm&quot;)
public class AppConfig {
}
</code></pre>
<p>3.准备一个简单的测试类：</p>
<ul>
<li>读取配置文件</li>
<li>通过 getBean(&quot;xxx&quot;) 获得 Bean 对象</li>
<li>调用 Bean 对象的方法</li>
</ul>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.读取配置文件
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext(AppConfig.class);
      // 2.获得 Bean 对象 
      IndexDao indexDao = context.getBean(IndexDao.class);
      // 3.调用方法
      indexDao.query();
   }
}
</code></pre>
<p>4.测试结果</p>
<pre><code>dao...模拟查询数据库
</code></pre>
<h1 id="new-annotationconfigapplicationcontextappconfigclass">new AnnotationConfigApplicationContext(AppConfig.class);</h1>
<p>从测试类 Test 开始看，测试类的第 5 行读取配置文件：</p>
<pre><code class="language-java">AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
</code></pre>
<p>于是点进 AnnotationConfigApplicationContext(AppConfig.class); 构造方法如下：</p>
<pre><code class="language-java">public AnnotationConfigApplicationContext(Class&lt;?&gt;... annotatedClasses) {
   // 这里由于它有父类，故而会先调用父类的构造方法，然后才会调用自己的构造方法
   // 在自己的构造方法中初始一个读取器和扫描器
   this();
   register(annotatedClasses);
   refresh();
}
</code></pre>
<p>AnnotationConfigApplicationContext 有父类：</p>
<pre><code class="language-java">public class AnnotationConfigApplicationContext extends GenericApplicationContext implements AnnotationConfigRegistry {
</code></pre>
<p>分析 AnnotationConfigApplicationContext 的有参 Class&lt;?&gt;... 构造方法，一行行看，先看第 4 行代码：this()：调用本类的构造方法，但是由于 AnnotationConfigApplicationContext  有父类，于是<strong>先调用父类的构造方法</strong>，我们这里先看本类的构造方法。</p>
<h2 id="11-annotationconfigapplicationcontext">1.1 AnnotationConfigApplicationContext()</h2>
<p>第 7 行，创建了一个 AnnotatedBeanDefinitionReader 并赋值给 reader，那这个 reader 是什么呢？</p>
<pre><code class="language-java">public AnnotationConfigApplicationContext() {
   /**
    * 父类的构造方法 super()
    * 创建一个读取注解的 Bean 定义读取器：reader 能读取被加了注解的类
    * 什么是 bean 定义？BeanDefinition
    */
   this.reader = new AnnotatedBeanDefinitionReader(this);
   // 定义扫描器
   this.scanner = new ClassPathBeanDefinitionScanner(this);
}
</code></pre>
<h3 id="111-annotatedbeandefinitionreader">1.1.1 AnnotatedBeanDefinitionReader</h3>
<p>reader 是一个 AnnotatedBeanDefinitionReader 类型的变量，顾名思义，reader 是一个读取器，并且 AnnotatedBeanDefinitionReader 是一个用来读取 “被加了注解的 BeanDefinition” 的读取器。那么 BeanDefinition 又是什么呢？</p>
<pre><code class="language-java">/**
 * 这个类顾名思义是一个 reader  读取器
 * 读取什么呢？顾名思义读取 AnnotatedBeanDefinition，意思是读取一个被加了注解的 bean
 * 这个类是构造方法中被实例化的
 */
private final AnnotatedBeanDefinitionReader reader;
</code></pre>
<p>从代码中也能看出：AnnotatedBeanDefinition（被注解的 BeanDefinition）继承了 BeanDefinition：</p>
<pre><code class="language-java">public interface AnnotatedBeanDefinition extends BeanDefinition {
</code></pre>
<h4 id="1111-beandefinition">1.1.1.1 BeanDefinition</h4>
<p>BeanDefinition描述了一个bean实例，它具有属性值，构造函数参数值以及具体实现所提供的更多信息。</p>
<pre><code class="language-java">// Spring 当中用来描述 Bean 的一个接口
public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement {
</code></pre>
<p>我们可以想象这样一个需求：有一个 Java 类 User</p>
<pre><code class="language-java">User{
  private String name;
  public void study(){
    
  }
}
</code></pre>
<p>Java 中一切皆对象，一个 User 类也是一个对象，定义一个什么类来描述 User 类对象呢？</p>
<p>答案就是 Class 类</p>
<pre><code class="language-java">Class{
  name;        // 全限定类名
  SimpleName;  // User类名
  Methods[];   // 类中的所有方法
  Fields[];    // 类中的所有属性
  
  // 方法...
  public Method[] getMethods(){
    
  }
  public String getName(){
    
  }
}
</code></pre>
<p>Java 中的类使用 Class 来描述；<strong>Spring 中的 Bean 使用 BeanDefinition 来描述</strong>。</p>
<h4 id="1112-bean-的四种体现方法">1.1.1.2 Bean 的四种体现方法：</h4>
<ul>
<li>@Annotation
<ul>
<li>给一个类添加 @Component、@Service、@Repository 注解，就代表把该类交给 Spring 管理，Spring 就会创建一个 Bean。</li>
</ul>
</li>
</ul>
<pre><code class="language-java">@Repository
public class IndexDaoImpl implements IndexDao{
</code></pre>
<ul>
<li>xml
<ul>
<li>使用 <bean> 标签同样声明一个 Bean</li>
</ul>
</li>
</ul>
<pre><code class="language-xml">&lt;bean id=&quot;dao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot; /&gt;
</code></pre>
<ul>
<li>@Bean
<ul>
<li>使用@Bean 注解也能声明一个 Bean</li>
</ul>
</li>
</ul>
<pre><code class="language-java">@Bean
public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){
    SqlSessionFactoryBean sqlSessionFactoryBean =  new SqlSessionFactoryBean();
    sqlSessionFactoryBean.setDataSource(dataSource);
    return sqlSessionFactoryBean;
}
</code></pre>
<ul>
<li>Spring 内部提供的 bean，因为自定义的 bean 是 Spring 扫描，然后把它放到容器中的，Spring 也会开发自己的 bean，不扫描也把它放到容器当中去。</li>
</ul>
<p>继续来看 AnnotationConfigApplicationContext 的这个带参 Class&lt;?&gt;... 构造方法，下面来看第 6 行，调用了 register 方法，并传参 annotatedClasses，在这个 Test 测试类中，这个 annotatedClasses 就是 AppConfig.class</p>
<pre><code class="language-java">// annotatedClasses 在这里代表 AppConfig.class：存放了配置信息
register(annotatedClasses);
</code></pre>
<h2 id="12-registerclass-annotatedclasses">1.2 register(Class&lt;?&gt;... annotatedClasses)</h2>
<p>接下来点进这个 register(annotatedClasses); 方法，这里的主要代码就是第 20 行：this.reader.register(annotatedClasses); 调用 reader（前面通过 new AnnotatedBeanDefinitionReader(this); 初始化过了） 的 register方法</p>
<pre><code class="language-java">/**
 * 注册一个或多个要处理的带注解的类。
 *     比如有新加的类可以用这个方法，但是注册之后需要手动调用 refresh() 方法去触发容器解析注解。
 *
 *   有两个意思：
 *     它可以注册一个配置类：AnnotationConfigApplicationContext context =
 *     new AnnotationConfigApplicationContext(AppConfig.class);
 *     它还可以单独注册一个 bean：context.register(IndexService.class);
 *
 * &lt;p&gt;请注意，必须调用{@link #refresh（）}才能使上下文完全处理新类
 * to fully process the new classes.
 * @param annotatedClasses 一个或多个带注解的类,
 * e.g. {@link Configuration @Configuration} classes
 * @see #scan(String...)
 * @see #refresh()
 */
public void register(Class&lt;?&gt;... annotatedClasses) {
   Assert.notEmpty(annotatedClasses, &quot;At least one annotated class must be specified&quot;);
   // 在this()构造方法中初始化了 reader，就是为了在这里调用
   this.reader.register(annotatedClasses);
}
</code></pre>
<p><strong>register(Class&lt;?&gt;... annotatedClasses)</strong></p>
<p>于是我们点进去 reader.register(annotatedClasses); 发现这个 register 就是一个空壳方法，它有调用了 registerBean(annotatedClass); 这个方法。</p>
<pre><code class="language-java">/**
 * 这是一个空壳方法
 *
 * Register one or more annotated classes to be processed.
 * &lt;p&gt;Calls to {@code register} are idempotent; adding the same
 * annotated class more than once has no additional effect.
 * @param annotatedClasses one or more annotated classes,
 * e.g. {@link Configuration @Configuration} classes
 */
public void register(Class&lt;?&gt;... annotatedClasses) {
   for (Class&lt;?&gt; annotatedClass : annotatedClasses) {
      registerBean(annotatedClass);
   }
}
</code></pre>
<p><strong>registerBean</strong></p>
<p>继续点进去 registerBean(annotatedClass);我们发现这个方法又调用了 doRegisterBean(annotatedClass, null, name, qualifiers); 这个方法，继续点进去</p>
<pre><code class="language-java">/**
 * Register a bean from the given bean class, deriving its metadata from
 * class-declared annotations.
 * @param annotatedClass the class of the bean
 * @param name an explicit name for the bean
 * @param qualifiers specific qualifier annotations to consider,
 * in addition to qualifiers at the bean class level
 */
@SuppressWarnings(&quot;unchecked&quot;)
public void registerBean(Class&lt;?&gt; annotatedClass, String name, Class&lt;? extends Annotation&gt;... qualifiers) {
   doRegisterBean(annotatedClass, null, name, qualifiers);
}
</code></pre>
<h3 id="121-doregisterbean">1.2.1 doRegisterBean</h3>
<p>当传参一个单独的 Bean 时： AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(IndexDao.class);</p>
<pre><code class="language-java">&lt;T&gt; void doRegisterBean(Class&lt;T&gt; annotatedClass, @Nullable Supplier&lt;T&gt; instanceSupplier, @Nullable String name,
      @Nullable Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers) {

   /**
    *
    * AnnotatedGenericBeanDefinition：被注解的 BeanDefinition(描述Bean)
    * 将 bean 放入 map 中，bean 的 name 是 map 的 key，
    * map 中的 value 为 AnnotatedGenericBeanDefinition 对象
    */
    // 因为 register 中传递过来的参数是带注解的 Bean，即此类的参数 annotatedClass，所以此处使用 AnnotatedGenericBeanDefinition（被注解的BeanDefinition）
   AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass);
   /**
     * 判断这个类是否需要跳过解析
     * 通过代码可以知道 Spring 判断是否跳过解析，主要判断有没有加注解
     */
    // 这个类如果没有加注解，就不需要解析。因为 AnnotatedGenericBeanDefinition 是为了注册被加了注解的；
    // 如果这个类没有被加注解，就跳过不解析
   if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) {
      return;
   }

   abd.setInstanceSupplier(instanceSupplier);
   /**
    * 得到类的作用域
    *     如果是 context.register(SpringConfig.class);则作用域没有什么作用
    *     注册单个类时需要，比如：context.register(IndexService.class);
    */
   ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);
   /**
    * 将类的作用域添加到数据结构中
    * 如果参数为一个Bean，而不是 AppConfig.class 如 new AnnotationConfigApplicationContext(IndexDao.class); 将Bean 内容解析出来放到 AnnotatedGenericBeanDefinition 中
    */
   abd.setScope(scopeMetadata.getScopeName());
   /**
    * 生成类的名字通过 beanNameGenerator
    */
   String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));

   /**
    * 处理类当中的其他通用注解
    * 分析源码可以知道它主要处理：Lazy、DependsOn、Primary、Role 等注解
    * 处理完成之后 processCommonDefinitionAnnotation 中依然是把它添加到数据结构 AnnotatedGenericBeanDefinition 当中
    */
   AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
   /**
     * 如果在向容器注册注解 @Bean定义时，使用了额外的限定符注解则解析
     * 关于 Qualifier 和 Primary 主要涉及到 Spring 的自动装配
     * 这里需要注意的
     *     beanName 和 qualifier 这个变量时 Annotation 类型的数组，里面不仅仅是 Qualifier 注解
     *     理论上里面存的是一切注解，所以可以看到下面的代码 Spring 去循环了这个数组
     *     然后依次判断注解当中是否包含了 Primary，是否包含了 Lazy
     */
   if (qualifiers != null) {
      for (Class&lt;? extends Annotation&gt; qualifier : qualifiers) {
         if (Primary.class == qualifier) {
            abd.setPrimary(true);
         }
         else if (Lazy.class == qualifier) {
            abd.setLazyInit(true);
         }
         else {
            abd.addQualifier(new AutowireCandidateQualifier(qualifier));
         }
      }
   }
   for (BeanDefinitionCustomizer customizer : definitionCustomizers) {
      customizer.customize(abd);
   }
    /**
     * 这个 BeanDefinitionHolder 也是一个数据结构
     * BeanDefinitionHolder 是一个 map，里面放了一个 (BeanDefinition，beanName)
     */
   BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);
   definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
   /**
     * 把上述的这个数据结构注册给 registry
     * registry 就是 AnnotationConfigApplicationContext
     * AnnotationConfigApplicationContext 在初始化的时候通过调用父类的构造方法实例化了一个 DefaultListableBeanFactory
     * registerBeanDefinition 里面就是把 definitionHolder 这个数据结构包含的信息注册到 DefaultListableBeanFactory 这个工厂
     */
   BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
}
</code></pre>
<p>上述 deRegisterBean 方法的第 28-33 行，</p>
<pre><code class="language-java">/**
 * 得到类的作用域
 *     如果是 context.register(SpringConfig.class);则作用域没有什么作用
 *     注册单个类时需要，比如：context.register(IndexService.class);
 */
ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);
/**
 * 将类的作用域添加到数据结构中
 */
abd.setScope(scopeMetadata.getScopeName());
</code></pre>
<p>获取 Bean 的作用域并添加到 adb 中：</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E8%8E%B7%E5%8F%96bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%B9%B6%E6%B7%BB%E5%8A%A0%E5%88%B0adb%E4%B8%AD.png" alt="图片" loading="lazy"></figure>
<h4 id="1211-processcommondefinitionannotations">1.2.1.1 processCommonDefinitionAnnotations</h4>
<p>上述 deRegisterBean 方法的第 44 行，调用了 processCommonDefinitionAnnotations 方法，</p>
<pre><code class="language-java">/**
 * 处理类当中的其他通用注解
 * 分析源码可以知道它主要处理：Lazy、DependsOn、Primary、Role 等注解
 * 处理完成之后 processCommonDefinitionAnnotation 中依然是把它添加到数据结构 AnnotatedGenericBeanDefinition 当中
 */
AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
</code></pre>
<p>点进去，又调用了 processCommonDefinitionAnnotations 的重载方法：</p>
<pre><code class="language-java">public static void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd) {
   // 通过 abd.getMetadata() 获取元数据：@Scope、@DependsOn、@Qualifier、@Primary
   processCommonDefinitionAnnotations(abd, abd.getMetadata());
}
</code></pre>
<p>通过 processCommonDefinitionAnnotations 方法解析元数据</p>
<pre><code class="language-java">static void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata) {
   AnnotationAttributes lazy = attributesFor(metadata, Lazy.class);
   // 如果 lazy 不为空
   if (lazy != null) {
      // 把 lazy 的值拿出来，放到 abd(描述 Bean 对象的) 里面去
      abd.setLazyInit(lazy.getBoolean(&quot;value&quot;));
   }
   else if (abd.getMetadata() != metadata) {
      lazy = attributesFor(abd.getMetadata(), Lazy.class);
      if (lazy != null) {
         abd.setLazyInit(lazy.getBoolean(&quot;value&quot;));
      }
   }
   
   // 判断是否有@Primary注解，如果有，放到 abd(描述 Bean 对象的) 里面去
   if (metadata.isAnnotated(Primary.class.getName())) {
      abd.setPrimary(true);
   }
   // 判断是否有@DependsOn注解，如果有，放到 abd(描述 Bean 对象的) 里面去
   AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);
   if (dependsOn != null) {
      abd.setDependsOn(dependsOn.getStringArray(&quot;value&quot;));
   }

   if (abd instanceof AbstractBeanDefinition) {
      AbstractBeanDefinition absBd = (AbstractBeanDefinition) abd;
      // 判断是否有@Role注解，如果有，放到 abd(描述 Bean 对象的) 里面去
      AnnotationAttributes role = attributesFor(metadata, Role.class);
      if (role != null) {
         absBd.setRole(role.getNumber(&quot;value&quot;).intValue());
      }
      // 判断是否有@Description注解，如果有，放到 abd(描述 Bean 对象的) 里面去
      AnnotationAttributes description = attributesFor(metadata, Description.class);
      if (description != null) {
         absBd.setDescription(description.getString(&quot;value&quot;));
      }
   }
}
</code></pre>
<h4 id="1212-beandefinitionholder">1.2.1.2 BeanDefinitionHolder</h4>
<p>上述 doRegisterBean 方法的73-74 行，定义了一个 BeanDefinitionHolder，BeanDefinitionHolder 类似一个 map，里面放了一个 (BeanDefinition，beanName)</p>
<pre><code class="language-java">/**
 * 这个 BeanDefinitionHolder 也是一个数据结构
 * BeanDefinitionHolder 类似一个 map，里面放了一个 (BeanDefinition，beanName)
 */
BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);
definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
</code></pre>
<p>顾名思义，BeanDefinitionRegistry 是用来注册 BeanDefinition（Bean的定义）的：</p>
<pre><code class="language-java">//用来注册Bean的定义 BeanDefinition
private final BeanDefinitionRegistry registry;
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/BeanDefinitionRegistry.png" alt="图片" loading="lazy"></figure>
<p>BeanDefinitionRegistry：将 BeanDifinition 放到 Spring 容器中</p>
<p>点进去 registerBeanDefinition 这个方法，发现就是拿出 BeanDefinitionHolder 中的 BeanName 和 BeanDefinition，并把它注册到 registry 中：</p>
<pre><code class="language-java">public static void registerBeanDefinition(
      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
      throws BeanDefinitionStoreException {

   // 拿出 BeanDefinitionHolder 中的 BeanName 和 BeanDefinition 
   String beanName = definitionHolder.getBeanName();
   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

   // 注册bean名称的别名（如果有）。
   String[] aliases = definitionHolder.getAliases();
   if (aliases != null) {
      for (String alias : aliases) {
         registry.registerAlias(beanName, alias);
      }
   }
}
</code></pre>
<p>我们看第 7 行，真正的将 BeanName 和 BeanDefinition 注册到 registry 中，</p>
<pre><code class="language-java">registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
</code></pre>
<p>点进去 registerBeanDefinition 方法：</p>
<h4 id="1213-registerbeandefinition">1.2.1.3 registerBeanDefinition</h4>
<p>上述 deRegisterBean 方法的第 81 行，把 <strong>BeanDefinitionHolder</strong>注册给 registry：</p>
<pre><code class="language-java">/**
 * 把上述的这个数据结构注册给 registry
 * registry 就是 AnnotationConfigApplicationContext
 * AnnotationConfigApplicationContext 在初始化的时候通过调用父类的构造方法实例化了一个 DefaultListableBeanFactory
 * registerBeanDefinition 里面就是把 definitionHolder 这个数据结构包含的信息注册到 DefaultListableBeanFactory 这个工厂
 */
BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
</code></pre>
<p>点进 registerBeanDefinition 方法代码如下：</p>
<pre><code class="language-java">public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
      throws BeanDefinitionStoreException {

   this.beanFactory.registerBeanDefinition(beanName, beanDefinition);
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/beanDefinitionMap_put.png" alt="图片" loading="lazy"></figure>
<p>this.beanDefinitionMap.put(beanName, beanDefinition);</p>
<p>点进 registerBeanDefinition 方法如下，主要操作是：将 (beanName,beanDefiniton)放到map中，将 beanName 加入到 list 中：</p>
<pre><code class="language-java">public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
      throws BeanDefinitionStoreException {

   Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);
   Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);

   if (beanDefinition instanceof AbstractBeanDefinition) {
      try {
         ((AbstractBeanDefinition) beanDefinition).validate();
      }
      catch (BeanDefinitionValidationException ex) {
         throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
               &quot;Validation of bean definition failed&quot;, ex);
      }
   }

   BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
   if (existingDefinition != null) {
      if (!isAllowBeanDefinitionOverriding()) {
         throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
               &quot;Cannot register bean definition [&quot; + beanDefinition + &quot;] for bean '&quot; + beanName +
               &quot;': There is already [&quot; + existingDefinition + &quot;] bound.&quot;);
      }
      else if (existingDefinition.getRole() &lt; beanDefinition.getRole()) {
         // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
         if (logger.isWarnEnabled()) {
            logger.warn(&quot;Overriding user-defined bean definition for bean '&quot; + beanName +
                  &quot;' with a framework-generated bean definition: replacing [&quot; +
                  existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;);
         }
      }
      else if (!beanDefinition.equals(existingDefinition)) {
         if (logger.isInfoEnabled()) {
            logger.info(&quot;Overriding bean definition for bean '&quot; + beanName +
                  &quot;' with a different definition: replacing [&quot; + existingDefinition +
                  &quot;] with [&quot; + beanDefinition + &quot;]&quot;);
         }
      }
      else {
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Overriding bean definition for bean '&quot; + beanName +
                  &quot;' with an equivalent definition: replacing [&quot; + existingDefinition +
                  &quot;] with [&quot; + beanDefinition + &quot;]&quot;);
         }
      }
      this.beanDefinitionMap.put(beanName, beanDefinition);
   }
   else {
      if (hasBeanCreationStarted()) {
         // Cannot modify startup-time collection elements anymore (for stable iteration)
         synchronized (this.beanDefinitionMap) {
            // DefaultListableBeanFactory.beanDefinitionMap.put(beanName, beanDefinition)
            this.beanDefinitionMap.put(beanName, beanDefinition);
            List&lt;String&gt; updatedDefinitions = new ArrayList&lt;&gt;(this.beanDefinitionNames.size() + 1);
            updatedDefinitions.addAll(this.beanDefinitionNames);
            updatedDefinitions.add(beanName);
            this.beanDefinitionNames = updatedDefinitions;
            if (this.manualSingletonNames.contains(beanName)) {
               Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;&gt;(this.manualSingletonNames);
               updatedSingletons.remove(beanName);
               this.manualSingletonNames = updatedSingletons;
            }
         }
      }
      else {
         // 将 (beanName,beanDefiniton)放到map中
         this.beanDefinitionMap.put(beanName, beanDefinition);
         // 将 beanName 加入到 list 中
         this.beanDefinitionNames.add(beanName);
         this.manualSingletonNames.remove(beanName);
      }
      this.frozenBeanDefinitionNames = null;
   }

   if (existingDefinition != null || containsSingleton(beanName)) {
      resetBeanDefinition(beanName);
   }
   else if (isConfigurationFrozen()) {
      clearByTypeCache();
   }
}
</code></pre>
<p>beanDefinitionNames 是一个 List 集合，将 Bean 定义的名字添加到这个 List 集合中：</p>
<pre><code class="language-java">/** List of bean definition names, in registration order */
private volatile List&lt;String&gt; beanDefinitionNames = new ArrayList&lt;&gt;(256);
</code></pre>
<p>上述第 67 行代码执行完毕</p>
<pre><code class="language-java">this.beanDefinitionMap.put(beanName, beanDefinition);
</code></pre>
<p>map 中添加了 7 个对象，一个是自定义的 indexDao，其余 6 个是 Spring 在启动过程中自动添加的</p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/map%E6%B7%BB%E5%8A%A07%E4%B8%AA%E5%AF%B9%E8%B1%A1.png" alt="图片" loading="lazy"></figure>
<h2 id="13-refresh">1.3 refresh()</h2>
<ul>
<li>初始化 Spring 的环境</li>
</ul>
<pre><code class="language-java">public void refresh() throws BeansException, IllegalStateException {
   synchronized (this.startupShutdownMonitor) {
      // Prepare this context for refreshing.
      // 准备工作包括设置启动时间、是否激活标识位，初始化属性源（property source）配置（这里不属于 Bean 的生命周期内）
      prepareRefresh();

      // Tell the subclass to refresh the internal bean factory.
      // 获取 DefaultListableBeanFactory
      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

      // Prepare the bean factory for use in this context.
      prepareBeanFactory(beanFactory);

      try {
         // Allows post-processing of the bean factory in context subclasses.
         postProcessBeanFactory(beanFactory);

         // Invoke factory processors registered as beans in the context.
         invokeBeanFactoryPostProcessors(beanFactory);

         // Register bean processors that intercept bean creation.
         registerBeanPostProcessors(beanFactory);

         // Initialize message source for this context.
         initMessageSource();

         // Initialize event multicaster for this context.
         initApplicationEventMulticaster();

         // Initialize other special beans in specific context subclasses.
         onRefresh();

         // Check for listener beans and register them.
         registerListeners();

         // Instantiate all remaining (non-lazy-init) singletons.
         finishBeanFactoryInitialization(beanFactory);

         // Last step: publish corresponding event.
         finishRefresh();
      }

      catch (BeansException ex) {
         if (logger.isWarnEnabled()) {
            logger.warn(&quot;Exception encountered during context initialization - &quot; +
                  &quot;cancelling refresh attempt: &quot; + ex);
         }

         // Destroy already created singletons to avoid dangling resources.
         destroyBeans();

         // Reset 'active' flag.
         cancelRefresh(ex);

         // Propagate exception to caller.
         throw ex;
      }

      finally {
         // Reset common introspection caches in Spring's core, since we
         // might not ever need metadata for singleton beans anymore...
         resetCommonCaches();
      }
   }
}
</code></pre>
<p>先看上述 refresh() 的第 5 行，调用了 prepareRefresh() 方法：</p>
<pre><code class="language-java">// 准备工作包括设置启动时间、是否激活标识位，初始化属性源（property source）配置（这里不属于 Bean 的生命周期内）
prepareRefresh();
</code></pre>
<h3 id="131-preparerefresh">1.3.1 prepareRefresh()</h3>
<pre><code class="language-java">protected void prepareRefresh() {
   // Switch to active.
   this.startupDate = System.currentTimeMillis();
   this.closed.set(false);
   this.active.set(true);

   if (logger.isInfoEnabled()) {
      logger.info(&quot;Refreshing &quot; + this);
   }

   // Initialize any placeholder property sources in the context environment.
   // 这个方法目前没有子类去实现
   // 估计 Spring 是期待后面的版本有子类去实现吧
   initPropertySources();

   // Validate that all properties marked as required are resolvable:
   // see ConfigurablePropertyResolver#setRequiredProperties
   // 获取 .properties 文件或者 @Profile 环境
   getEnvironment().validateRequiredProperties();

   // Store pre-refresh ApplicationListeners...
   if (this.earlyApplicationListeners == null) {
      this.earlyApplicationListeners = new LinkedHashSet&lt;&gt;(this.applicationListeners);
   }
   else {
      // Reset local application listeners to pre-refresh state.
      this.applicationListeners.clear();
      this.applicationListeners.addAll(this.earlyApplicationListeners);
   }

   // Allow for the collection of early ApplicationEvents,
   // to be published once the multicaster is available...
   this.earlyApplicationEvents = new LinkedHashSet&lt;&gt;();
}
</code></pre>
<p>看 prepareRefresh() 方法的第 14 行，调用了 initPropertySources()，这个方法目前没有子类去实现估计 Spring 是期待后面的版本有子类去实现吧：</p>
<pre><code class="language-java">protected void initPropertySources() {
   // For subclasses: do nothing by default.
}```
再来看 refresh() 的第 9 行
```java
// 告诉子类 refresh 内部 Bean工厂
ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
</code></pre>
<h3 id="132-obtainfreshbeanfactory">1.3.2 obtainFreshBeanFactory()</h3>
<pre><code class="language-java">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
   refreshBeanFactory();
   ConfigurableListableBeanFactory beanFactory = getBeanFactory();
   if (logger.isDebugEnabled()) {
      logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);
   }
   return beanFactory;
}
</code></pre>
<p>看 obtainFreshBeanFactory() 方法的第 3 行：</p>
<pre><code class="language-java">ConfigurableListableBeanFactory beanFactory = getBeanFactory();
</code></pre>
<h4 id="1321-getbeanfactory">1.3.2.1 getBeanFactory()</h4>
<p>返回 DefaultListableBeanFactory</p>
<pre><code class="language-java">public final ConfigurableListableBeanFactory getBeanFactory() {
   return this.beanFactory;
}
</code></pre>
<p>beanFactory 是 DefaultListableBeanFactory  类型变量：</p>
<pre><code class="language-java">/** Bean factory for this context */
private final DefaultListableBeanFactory beanFactory;
</code></pre>
<p>再看 refresh() 的第 19 行：</p>
<pre><code class="language-java">// Invoke factory processors registered as beans in the context.
// 调用在上下文中注册为bean的工厂处理器。
invokeBeanFactoryPostProcessors(beanFactory);
</code></pre>
<p>我们点进这个 invokeBeanFactoryPostProcessors(beanFactory); 方法看：</p>
<h3 id="133-invokebeanfactorypostprocessors">1.3.3 invokeBeanFactoryPostProcessors</h3>
<pre><code class="language-java">/**
  * 实例化并调用所有已注册的BeanFactoryPostProcessor Bean，
  * 遵循显式顺序（如果给定的话）。 
  * 必须在单例实例化之前调用。
  */
protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());

   // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
   // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
   if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
   }
}
</code></pre>
<p>我们看上述 invokeBeanFactoryPostProcessors 方法中的第 7 行代码：</p>
<pre><code class="language-java">PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
</code></pre>
<p>这个 invokeBeanFactoryPostProcessors 方法是非常重要的，也就是上面说的产生 7 个对象的过程，就是此段代码内实现的</p>
<h1 id="spring-bean-的扩展有哪些">Spring Bean 的扩展有哪些</h1>
<h2 id="aop">AOP</h2>
<p>IndexDao 配置了 AOP，AOP 与 IndexDao 没有任何耦合</p>
<p>AOP 通过 @AspectJ 配置通知、切点，与 IndexDao 没有任何耦合，那 AOP 是如何将 IndexDao 变成代理的呢？ ——Spring  Bean 的扩展（想让它成为 IndexDao，就成为 IndexDao；想让它成为代理类，就成为代理类）</p>
<h2 id="beanpostprocessor">BeanPostProcessor</h2>
<ul>
<li>Bean 后置处理器</li>
<li>BeanPostProcessor 接口，能够扩展 Spring</li>
<li>所有 BeanPostProcessor 接口的实现类，本质上都是通过 BeanPostProcessor 进行扩展，属于Spring 扩展的一种方式</li>
</ul>
<pre><code class="language-java">@Repository(&quot;indexDao&quot;)
public class IndexDaoImpl implements IndexDao {

   public IndexDaoImpl(){
      System.out.println(&quot;indexDao...constructor&quot;);
   }

   @PostConstruct
   public void init(){
      System.out.println(&quot;indexDao...init&quot;);
   }

   @Override
   public void query() {
      System.out.println(&quot;dao...模拟查询数据库&quot;);
   }
}
</code></pre>
<p>插手 Bean 的构建过程，将 Bean 变为代理对象并返回：</p>
<pre><code class="language-java">@Component
public class TestBeanPostProcessor implements BeanPostProcessor {
   @Override
   public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
      if(beanName.equals(&quot;indexDao&quot;)){
         System.out.println(&quot;BeforeInitialization...&quot;);
      }
      // 返回一个代理对象出去
//    Proxy.newProxyInstance()
      return bean;
   }

   @Override
   public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
      if(beanName.equals(&quot;indexDao&quot;)){
         System.out.println(&quot;AfterInitialization...&quot;);
      }
      return bean;
   }
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-java">indexDao...constructor
BeforeInitialization...
indexDao...init
AfterInitialization...
dao...模拟查询数据库
</code></pre>
<h3 id="如何控制多个后置处理器的顺序">如何控制多个后置处理器的顺序：</h3>
<ul>
<li>后置处理器实现 PriorityOrdered 接口，重写 getOrder() 方法，值越小就越先执行</li>
</ul>
<pre><code class="language-java">@Component
public class TestBeanPostProcessor implements BeanPostProcessor, PriorityOrdered {
   @Override
   public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
      if(beanName.equals(&quot;indexDao&quot;)){
         System.out.println(&quot;BeforeInitialization...&quot;);
      }
      // 返回一个代理对象出去
//    Proxy.newProxyInstance()
      return bean;
   }

   @Override
   public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
      if(beanName.equals(&quot;indexDao&quot;)){
         System.out.println(&quot;AfterInitialization...&quot;);
      }
      return bean;
   }

   @Override
   public int getOrder() {
      return 102;
   }
}
</code></pre>
<p>第二个后置处理器的定义，同样实现 PriorityOrdered 接口，重写 getOrder() 方法：</p>
<pre><code class="language-java">@Component
public class TestBeanPostProcessor2 implements BeanPostProcessor, PriorityOrdered {
   @Override
   public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
      if(beanName.equals(&quot;indexDao&quot;)){
         System.out.println(&quot;BeforeInitialization2...&quot;);
      }
      // 返回一个代理对象出去
//    Proxy.newProxyInstance()
      return bean;
   }

   @Override
   public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
      if(beanName.equals(&quot;indexDao&quot;)){
         System.out.println(&quot;AfterInitialization2...&quot;);
      }
      return bean;
   }

   @Override
   public int getOrder() {
      return 100;
   }
}
</code></pre>
<p>执行结果：</p>
<pre><code>indexDao...constructor
BeforeInitialization2...
BeforeInitialization...
indexDao...init
AfterInitialization2...
AfterInitialization...
dao...模拟查询数据库
</code></pre>
<h2 id="beanfactorypostprocessor">BeanFactoryPostProcessor</h2>
<p>Spring 工厂后置处理器</p>
<h2 id="beandefinitionregistrypostprocessor">BeanDefinitionRegistryPostProcessor</h2>
<h3 id="134-preparebeanfactorybeanfactory">1.3.4 prepareBeanFactory(beanFactory)</h3>
<p>再来看 refresh() 的第 12 行： prepareBeanFactory(beanFactory);</p>
<pre><code>// Prepare the bean factory for use in this context.
prepareBeanFactory(beanFactory);
</code></pre>
<p>点进去 prepareBeanFactory(beanFactory) 代码如下：</p>
<pre><code class="language-java">protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
   // Tell the internal bean factory to use the context's class loader etc.
   beanFactory.setBeanClassLoader(getClassLoader());
   // bean 表达式解析器
   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
   // 注册属性编辑器
   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));

   // Configure the bean factory with context callbacks.
   // 使用上下文回调配置Bean工厂。
   // 向 List 里面添加一个数据：添加一个后置管理器：ApplicationContextAwareProcessor 实现了 BeanPostProcessor接口：插手 Bean 的创建过程
   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);

   // BeanFactory interface not registered as resolvable type in a plain factory.
   // MessageSource registered (and found for autowiring) as a bean.
   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
   beanFactory.registerResolvableDependency(ResourceLoader.class, this);
   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
   beanFactory.registerResolvableDependency(ApplicationContext.class, this);

   // Register early post-processor for detecting inner beans as ApplicationListeners.
   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));

   // Detect a LoadTimeWeaver and prepare for weaving, if found.
   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
      // Set a temporary ClassLoader for type matching.
      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
   }

   // Register default environment beans.
   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
   }
   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
   }
   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
   }
}
</code></pre>
<p>看 prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) 的第 12 行内容如下：</p>
<pre><code class="language-java">// Configure the bean factory with context callbacks.
// 使用上下文回调配置Bean工厂。
// 向 List 里面添加一个数据：添加一个后置管理器：ApplicationContextAwareProcessor 实现了 BeanPostProcessor接口：插手 Bean 的创建过程
beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
</code></pre>
<p>向 List 里面添加一个数据：添加一个后置管理器：ApplicationContextAwareProcessor 实现了 BeanPostProcessor接口：插手 Bean 的创建过程：</p>
<pre><code class="language-java">class ApplicationContextAwareProcessor implements BeanPostProcessor {
</code></pre>
<p>如果想了解 ApplicationContextAwareProcessor 类，就先来看一下它实现的父接口 BeanPostProcessor 类。</p>
<h4 id="1341-beanpostprocessor">1.3.4.1 BeanPostProcessor</h4>
<p>先来看一下 BeanPostProcessor 接口的结构，一共有两个方法：</p>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/BeanPostProcessor.png" alt="图片" loading="lazy"></figure>
<pre><code class="language-java">/**
 * BeanPostProcessor 是 Spring 框架提供的一个扩展类点（Spring 扩展不止一个后置处理器，
 * Spring 能够扩展一个类，它提供了很多后置处理器，但这个后置处理器都属于一种，还有其他办法）
 * 通过实现 BeanPostProcessor 接口，程序员就可查收 bean 实例化的过程，从而减轻了 beanFactory 的负担
 * 值得说明的是这个接口可以设置多个，会形成一个列表， 然后依次执行
 * （自己写的后置处理器只需添加 @Component 即可，Spring就会自动扫描把它new出来然后添加到容器中。
 * 但是 Spring 默认的怎么办？Spring 手动 set 添加到容器中） 
 * 比如 AOP 就是在 bean 实例化后期间将切面逻辑织入 bean 实例中的
 * AOP 也正是通过 BeanPostProcessor 和 IOC 容器建立起了联系
 * （由 Spring 提供的默认的 PostProcessor，Spring 提供了很多默认的 PostProcessor，下面一一介绍这些实现类的功能）
 * 可以演示一下 BeanPostProcessor 的使用方式（把动态代理和 IOC、AOP 结合起来使用）
 *
 * 在演示之前先来熟悉一下这个接口，是这个接口本身特别简单，但是它的实现类特别复杂。
 * 可以看看 Spring 提供哪些默认的实现
 * 查看类的关系图就可以知道 Spring 提供了以下的默认实现，由于实现类是在太多，所以只是解释几个常用的
 * 1.ApplicationContextAwareProcessor（sacap）
 *        acap 后置处理器的作用是：当应用程序定义的 Bean 实现 ApplicationContextAware 接口时注入 ApplicationContext 对象
 *        当然这是他的第一个作业，它还有其他作用，这里就不一一举例了，可以参考源码
 *        我们可以针对 ApplicationContextAwareProcessor 写一个例子
 * 2.InitDestroyAnnotationBeanPostProcessor
 *     用来处理自定义的初始化方法和销毁方法
 *     Spring 中提供了三种自定义初始化和销毁方法分别是
 *     ① 通过 @Bean 指定 inti method 和 destroy-method 属性
 *     ② Ban 实现 InitializingBean 接口和显现 DisposableBean
 *     ③ @PostConstruct：@PreDestroy
 *     为什么 Spring 通过这三种方式都能完成对 bean 生命周期的回调呢？
 *     可以通过 InitDestroyAnnotationBeanPostProcessor 的源码来解释
 * 3.InstantiationAwareBeanPostProcessor
 * 4.CommonAnnotationBeanPostProcessor
 * 5.AutowiredAnnotationBeanPostProcessor
 * 6.RequiredAnnotationBeanPostProcessor
 * 7.BeanValidationPostProcessor
 * 8.AbstractAutoProxyCreator：抽象自动代理创建器：AOP 创建一个代理
 * ......
 *
 *
 * Factory hook that allows for custom modification of new bean instances,
 * e.g. checking for marker interfaces or wrapping them with proxies.
 *
 * &lt;p&gt;ApplicationContexts can autodetect BeanPostProcessor beans in their
 * bean definitions and apply them to any beans subsequently created.
 * Plain bean factories allow for programmatic registration of post-processors,
 * applying to all beans created through this factory.
 *
 * &lt;p&gt;Typically, post-processors that populate beans via marker interfaces
 * or the like will implement {@link #postProcessBeforeInitialization},
 * while post-processors that wrap beans with proxies will normally
 * implement {@link #postProcessAfterInitialization}.
 *
 * @author Juergen Hoeller
 * @since 10.10.2003
 * @see InstantiationAwareBeanPostProcessor
 * @see DestructionAwareBeanPostProcessor
 * @see ConfigurableBeanFactory#addBeanPostProcessor
 * @see BeanFactoryPostProcessor
 */
public interface BeanPostProcessor {

   /**
    *
    * 在 Bean 初始化之前执行
    * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;before&lt;/i&gt; any bean
    * initialization callbacks (like InitializingBean's {@code afterPropertiesSet}
    * or a custom init-method). The bean will already be populated with property values.
    * The returned bean instance may be a wrapper around the original.
    * &lt;p&gt;The default implementation returns the given {@code bean} as-is.
    * @param bean the new bean instance
    * @param beanName the name of the bean
    * @return the bean instance to use, either the original or a wrapped one;
    * if {@code null}, no subsequent BeanPostProcessors will be invoked
    * @throws org.springframework.beans.BeansException in case of errors
    * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet
    */
   @Nullable
   default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
      return bean;
   }

   /**
    * 在 Bean 初始化之后执行
    * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;after&lt;/i&gt; any bean
    * initialization callbacks (like InitializingBean's {@code afterPropertiesSet}
    * or a custom init-method). The bean will already be populated with property values.
    * The returned bean instance may be a wrapper around the original.
    * &lt;p&gt;In case of a FactoryBean, this callback will be invoked for both the FactoryBean
    * instance and the objects created by the FactoryBean (as of Spring 2.0). The
    * post-processor can decide whether to apply to either the FactoryBean or created
    * objects or both through corresponding {@code bean instanceof FactoryBean} checks.
    * &lt;p&gt;This callback will also be invoked after a short-circuiting triggered by a
    * {@link InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation} method,
    * in contrast to all other BeanPostProcessor callbacks.
    * &lt;p&gt;The default implementation returns the given {@code bean} as-is.
    * @param bean the new bean instance
    * @param beanName the name of the bean
    * @return the bean instance to use, either the original or a wrapped one;
    * if {@code null}, no subsequent BeanPostProcessors will be invoked
    * @throws org.springframework.beans.BeansException in case of errors
    * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet
    * @see org.springframework.beans.factory.FactoryBean
    */
   @Nullable
   default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
      return bean;
   }

}
</code></pre>
<p>AnnotationAwareAspectJAutoProxyCreator 并没有添加 @Component 注解，所以 Spring 不会扫描它</p>
<pre><code class="language-java">@SuppressWarnings(&quot;serial&quot;)public class AnnotationAwareAspectJAutoProxyCreator extends AspectJAwareAdvisorAutoProxyCreator {
</code></pre>
<p>接下来再回回到 prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) 的第 12 行内容如下：</p>
<pre><code class="language-java">beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
</code></pre>
<p>现在来看一下 addBeanPostProcessor() 方法的实现：</p>
<h4 id="1342-addbeanpostprocessorbeanpostprocessor-beanpostprocessor">1.3.4.2 addBeanPostProcessor(BeanPostProcessor beanPostProcessor)</h4>
<pre><code class="language-java">@Override
public void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) {
   Assert.notNull(beanPostProcessor, &quot;BeanPostProcessor must not be null&quot;);
   // Remove from old position, if any
   this.beanPostProcessors.remove(beanPostProcessor);
   // Track whether it is instantiation/destruction aware
   if (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) {
      this.hasInstantiationAwareBeanPostProcessors = true;
   }
   if (beanPostProcessor instanceof DestructionAwareBeanPostProcessor) {
      this.hasDestructionAwareBeanPostProcessors = true;
   }
   // Add to end of list
   this.beanPostProcessors.add(beanPostProcessor);
}
</code></pre>
<p>看一下上述 addBeanPostProcessor 方法的第 14 行，向 beanPostProcessors 中添加了一个 beanPostProcessor，那么 beanPostProcessors  是什么呢？List<BeanPostProcessor> 集合</p>
<pre><code class="language-java">/** BeanPostProcessors to apply in createBean */
private final List&lt;BeanPostProcessor&gt; beanPostProcessors = new CopyOnWriteArrayList&lt;&gt;();
</code></pre>
<p><strong>postProcessBeforeInitialization</strong></p>
<p>接下来看 ApplicationContextAwareProcessor 类是如何实现 postProcessBeforeInitialization 方法的：</p>
<pre><code class="language-java">@Override
@Nullable
public Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException {
   AccessControlContext acc = null;

   if (System.getSecurityManager() != null &amp;&amp;
         (bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||
               bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||
               bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)) {
      acc = this.applicationContext.getBeanFactory().getAccessControlContext();
   }

   if (acc != null) {
      AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
         invokeAwareInterfaces(bean);
         return null;
      }, acc);
   }
   else {
      invokeAwareInterfaces(bean);
   }

   return bean;
}
</code></pre>
<p>看上述 postProcessBeforeInitialization 方法的第 20 行，调用了 invokeAwareInterfaces(bean); 方法，具体实现如下：</p>
<pre><code class="language-java">private void invokeAwareInterfaces(Object bean) {
   // 判断这个 bean 是不是 Aware 接口
   if (bean instanceof Aware) {
      if (bean instanceof EnvironmentAware) {
         ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());
      }
      if (bean instanceof EmbeddedValueResolverAware) {
         ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);
      }
      // 判断这个 bean 是不是 ResourceLoaderAware 接口
      if (bean instanceof ResourceLoaderAware) {
         ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);
      }
      if (bean instanceof ApplicationEventPublisherAware) {
         ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);
      }
      if (bean instanceof MessageSourceAware) {
         ((MessageSourceAware) bean).setMessageSource(this.applicationContext);
      }
      // Spring 帮助我们 set 了一个 applicationContext 对象
      // 所以当我们自己的一个对象实现了 ApplicationContextAware 对象只需要提供 setter 就能得到 applicationContext
      if (bean instanceof ApplicationContextAware) {
         ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);
      }
   }
}
</code></pre>
<h1 id="单例对象中有一个-prototype-属性会有问题如何解决">单例对象中有一个 prototype 属性会有问题，如何解决：</h1>
<h2 id="repository">@Repository</h2>
<pre><code class="language-java">@Repository
@Scope(&quot;prototype&quot;)
public class IndexDaoImpl implements IndexDao {
</code></pre>
<h2 id="lookup">@Lookup</h2>
<pre><code class="language-java">@Service
@Scope(&quot;singleton&quot;)
public abstract class IndexService {
    @Lookup
    public abstract IndexDao getIndexDao() ;
    public void service(){
        System.out.println(this);
        System.out.println(getIndexDao());
    }
}
</code></pre>
<h2 id="applicationcontextaware">ApplicationContextAware</h2>
<p>implements ApplicationContextAware，重写 setApplicationContext 方法</p>
<pre><code class="language-java">@Service
@Scope(&quot;singleton&quot;)
public class IndexService implements ApplicationContextAware {
    @Autowired
    private IndexDao indexDao;
    private ApplicationContext applicationContext;
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
    public void service(){
        System.out.println(this);
        // 得到原型对象
       System.out.println(applicationContext.getBean(&quot;indexDaoImpl&quot;));
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring系列（五）BeanFactory和FactoryBean的区别]]></title>
        <id>https://epitomm.github.io/post/spring-xi-lie-wu-beanfactory-he-factorybean-de-qu-bie/</id>
        <link href="https://epitomm.github.io/post/spring-xi-lie-wu-beanfactory-he-factorybean-de-qu-bie/">
        </link>
        <updated>2020-05-05T03:37:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="beanfactory-和-factorybean-的区别">BeanFactory 和 FactoryBean 的区别？</h1>
<ul>
<li>BeanFactory 是 Spring 提供的一个工厂，能够产生对象。通过 getBean(&quot;xxx&quot;) 能够得到一个 Bean。</li>
<li>FactoryBean 是一个 Bean：把一个对象交给 Spring 管理，就可以称之为一个 Bean，就是一个对象，FactoryBean 就是一个受 Spring 管理的对象。
<ul>
<li>当一个类的依赖关系很复杂，而我们想对外提供简单的关系，就让外部可以使用时，就使用 FactoryBean，经典场景：MyBatis 中的 SqlSessionFactoryBean 对象。</li>
<li>如果类实现了 FactoryBean，那么 Spring 容器当中存在两个对象，一个是 getObject() 方法返回的对象（name=当前类名）；还有一个是当前对象（name=&amp;+当前类名）。</li>
</ul>
</li>
</ul>
<h1 id="spring-中声明一个-bean-的方式">Spring 中声明一个 Bean 的方式</h1>
<ul>
<li>
<bean>
</li>
<li>@Service</li>
<li>@Bean</li>
</ul>
<h1 id="factorybean">FactoryBean</h1>
<pre><code class="language-java">// 表明这是一个 xml 文件
@Configuration
// 注解扫描包
@ComponentScan(&quot;com.ssm&quot;)
public class SpringConfig {
}
</code></pre>
<p>如果类实现了 FactoryBean，那么 Spring 容器当中存在两个对象，一个是 getObject() 方法返回的对象 TempDaoFactoryBean；还有一个是当前对象 DaoFactoryBean。</p>
<p>在 Spring 容器中存储时，存储的 name 值是：</p>
<p>getObject() 得到对象：TempDaoFactoryBean 存的名字是当前类指定的名字：daoFactoryBean；</p>
<p>当前对象 DaoFactoryBean 是 &quot;&amp;&quot; + 当前类的名字：&amp;daoFactoryBean</p>
<pre><code class="language-java">@Component(&quot;daoFactoryBean&quot;)
public class DaoFactoryBean implements FactoryBean {

    public void testBean(){
        System.out.println(&quot;testBean...&quot;);
    }

    @Override
    public Object getObject() throws Exception {
        return new TempDaoFactoryBean();
    }

    @Override
    public Class&lt;?&gt; getObjectType() {
        return TempDaoFactoryBean.class;
    }

    @Override
    public boolean isSingleton() {
        return true;
    }
}
</code></pre>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        DaoFactoryBean daoFactoryBean = (DaoFactoryBean) context.getBean(&quot;daoFactoryBean&quot;);
        daoFactoryBean.testBean();
    }
}
</code></pre>
<pre><code>Exception in thread &quot;main&quot; java.lang.ClassCastException: com.ssm.dao.TempDaoFactoryBean cannot be cast to com.ssm.dao.DaoFactoryBean	at com.ssm.test.Test.main(Test.java:13)
</code></pre>
<p>ClassCastException：类型转换异常。将一个对象通过 @Component(&quot;daoFactoryBean&quot;) 放到 Spring 容器中，然后通过context.getBean(&quot;daoFactoryBean&quot;) 结果却类型转换异常。</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        TempDaoFactoryBean daoFactoryBean = (TempDaoFactoryBean) context.getBean(&quot;daoFactoryBean&quot;);
        daoFactoryBean.test();

    }
}
</code></pre>
<pre><code>FactoryBean...
</code></pre>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        TempDaoFactoryBean daoFactoryBean = (TempDaoFactoryBean) context.getBean(&quot;daoFactoryBean&quot;);
        daoFactoryBean.test();

        DaoFactoryBean bean = (DaoFactoryBean) context.getBean(&quot;&amp;daoFactoryBean&quot;);
        bean.testBean();

    }
}
</code></pre>
<pre><code>FactoryBean...
testBean...
</code></pre>
<h2 id="final-string-beanname-transformedbeannamename">final String beanName = transformedBeanName(name);</h2>
<ul>
<li>通过 name 获取 beanName</li>
</ul>
<p>通过 name 获取 beanName，这里不使用 name 直接作为 beanName 有两个原因：</p>
<p>1.name 可能会以 &amp; 字符开头，表名调用者想获取 FactoryBean 本身，而非 FactoryBean 实现类锁创建的 bean。在 Spring 工厂中，FactoryBean 的实现类和其他的普通 bean 存储方式是一致的，即&lt;beanName, bean&gt;，beanName 中是没有 &amp; 这个字符的。所以我们需要将 name 的首字符 &amp; 移除，这样才能从缓存里取到 FactoryBean 实例。</p>
<p>2.还是别名的问题 <alias>.，转换需要</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/transformedBeanName.png" alt="图片" loading="lazy"></figure>
<p>如果有一个类相当复杂，里面有很多依赖，就要配置很多 <property>，有可能有的依赖还得不到。</p>
<pre><code class="language-xml">&lt;bean id=&quot;temp&quot; class=&quot;com.ssm.dao.TempDaoFactoryBean&quot;&gt;
  &lt;!--假设这个类内有很多属性，就要配置很多 &lt;property&gt;--&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="language-java">public class TempDaoFactoryBean{
  Util util;
  Config config;
  String str1;
  String str2;
}
</code></pre>
<p>假如上述类是第三方框架写的，由于是第三方框架代码，不可能到它的源码上去添加@Component注解：</p>
<p>解决办法1.在 xml 配置这个类；</p>
<p>解决办法2.通过 JavConfig 把它 new 出来，然后添加一个 @Bean 标签</p>
<pre><code class="language-java">// 表明这是一个 xml 文件
@Configuration
// 注解扫描包
@ComponentScan(&quot;com.ssm&quot;)
public class SpringConfig {

    @Bean
    public DataSource dataSource(){
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
        dataSource.setUsername(&quot;root&quot;);
        dataSource.setPassword(&quot;123456&quot;);
        dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);
        return dataSource;
    }

    @Bean
    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){
        SqlSessionFactoryBean sqlSessionFactoryBean =  new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource);
        return sqlSessionFactoryBean;
    }
}
</code></pre>
<h1 id="比如在-spring-中引入第三方工具-mybatis">比如在 Spring 中引入第三方工具 Mybatis</h1>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7.png" alt="图片" loading="lazy"></figure>
<p>1.在 bean 中配置一个 SqlSessionFactory</p>
<pre><code class="language-xml">&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.apache.ibatis.session.defaults.DefaultSqlSessionFactory&quot;&gt;&lt;/bean&gt;
</code></pre>
<p>2.我们发现 SqlSessionFactory 依赖了 Configuration，于是在 <bean> 配置 Configuration</p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/SqlSessionFactory%E4%BE%9D%E8%B5%96Configuration.png" alt="图片" loading="lazy"></figure>
<pre><code class="language-xml">&lt;bean id=&quot;configuration&quot; class=&quot;org.apache.ibatis.session.Configuration&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.apache.ibatis.session.defaults.DefaultSqlSessionFactory&quot;&gt;
    &lt;constructor-arg ref=&quot;configuration&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre>
<p>3.Configuration 有超级多依赖，就需要在 <bean> 内添加很多 <property></p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/Configuration%E6%9C%89%E5%BE%88%E5%A4%9A%E4%BE%9D%E8%B5%96.png" alt="图片" loading="lazy"></figure>
<pre><code class="language-xml">&lt;bean id=&quot;configuration&quot; class=&quot;org.apache.ibatis.session.Configuration&quot;&gt;
  &lt;property&gt;&lt;/property&gt;
  &lt;property&gt;&lt;/property&gt;
  &lt;property&gt;&lt;/property&gt;
  &lt;property&gt;&lt;/property&gt;
  // ......
  &lt;property&gt;&lt;/property&gt;
  &lt;property&gt;&lt;/property&gt;
  &lt;property&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.apache.ibatis.session.defaults.DefaultSqlSessionFactory&quot;&gt;
    &lt;constructor-arg ref=&quot;configuration&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre>
<p>如此自己配置第三方依赖，操作太过复杂，最好的办法是 MyBatis 自己把 Configuration 这些复杂依赖关系都维护好，我们直接引入即可：</p>
<pre><code class="language-xml">&lt;bean id=&quot;dao&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/bean&gt;
</code></pre>
<p>但是 MyBatis 无法更改我们的配置文件，所以它没有地方去配置，于是它提供了一个 SqlSessionFactoryBean 类，在这个类中把这些依赖关系都维护好了。</p>
<h2 id="sqlsessionfactorybean">SqlSessionFactoryBean</h2>
<p>Mybatis在 SqlSessionFactoryBean 内部维护了各种依赖关系：</p>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/SqlSessionFactoryBean.png" alt="图片" loading="lazy"></figure>
<p>最终返回的对象是 SqlSessionFactory</p>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/SqlSessionFactoryBean%E8%BF%94%E5%9B%9ESqlSessionFactory.png" alt="图片" loading="lazy"></figure>
<p>afterPropertiesSet()</p>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/afterPropertiesSet.png" alt="图片" loading="lazy"></figure>
<p>buildSqlSessionFactory()</p>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/buildSqlSessionFactory.png" alt="图片" loading="lazy"></figure>
<p>MyBatis 内部通过 SqlSessionFactoryBean 维护了各种依赖关系，我们只需直接使用 SqlSessionFactoryBean 对象即可获得 SqlSessionFactory，无需再手动维护各种依赖。</p>
<h2 id="mybatis-通过-sqlsessionfactorybeansetdatasourcedatasource">MyBatis 通过 sqlSessionFactoryBean.setDataSource(dataSource);</h2>
<pre><code class="language-java">@Bean
public DataSource dataSource(){
    DriverManagerDataSource dataSource = new DriverManagerDataSource();
    dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
    dataSource.setUsername(&quot;root&quot;);
    dataSource.setPassword(&quot;123456&quot;);
    dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);
    return dataSource;
}
@Bean
public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){
    SqlSessionFactoryBean sqlSessionFactoryBean =  new SqlSessionFactoryBean();
    sqlSessionFactoryBean.setDataSource(dataSource);
    return sqlSessionFactoryBean;
}
</code></pre>
<h2 id="自定义通过-tempdaofactorybeansetmsg1str">自定义通过 TempDaoFactoryBean.setMsg1(str);</h2>
<p>1.JavaConfig 配置文件</p>
<pre><code class="language-java">// 表明这是一个 xml 文件
@Configuration
// 注解扫描包
@ComponentScan(&quot;com.ssm&quot;)
// 扫描 xml 配置文件
@ImportResource(&quot;classpath:spring.xml&quot;)
public class SpringConfig {
}
</code></pre>
<p>2.配置文件 xml 内配置 DaoFactoryBean 对象</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
       
    &lt;bean id=&quot;daoFactory&quot; class=&quot;com.ssm.dao.DaoFactoryBean&quot;&gt;
        &lt;property name=&quot;msg&quot; value=&quot;msg1,msg2,msg3&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>3.DaoFactoryBean 内有一属性 msg</p>
<pre><code class="language-java">public class DaoFactoryBean implements FactoryBean {
    private String msg;
    public void setMsg(String msg) {
        this.msg = msg;
    }
    @Override
    public Object getObject() throws Exception {
        TempDaoFactoryBean temp = new TempDaoFactoryBean();
        String[] msgArray = msg.split(&quot;,&quot;);
        temp.setMsg1(msgArray[0]);
        temp.setMsg2(msgArray[1]);
        temp.setMsg3(msgArray[2]);
        return temp;
    }
    @Override
    public Class&lt;?&gt; getObjectType() {
        return TempDaoFactoryBean.class;
    }
    @Override
    public boolean isSingleton() {
        return true;
    }
}
</code></pre>
<p>4.TempDaoFactoryBean 内有三个属性：msg1、msg2、msg3</p>
<pre><code class="language-java">public class TempDaoFactoryBean {

    private String msg1;
    private String msg2;
    private String msg3;

    public void test(){
        System.out.println(&quot;FactoryBean...&quot;);
    }

    public void setMsg1(String msg1) {
        this.msg1 = msg1;
    }

    public void setMsg2(String msg2) {
        this.msg2 = msg2;
    }

    public void setMsg3(String msg3) {
        this.msg3 = msg3;
    }

    public String getMsg1() {
        return msg1;
    }

    public String getMsg2() {
        return msg2;
    }

    public String getMsg3() {
        return msg3;
    }
}
</code></pre>
<p>5.测试类</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        TempDaoFactoryBean temp = (TempDaoFactoryBean) context.getBean(&quot;daoFactory&quot;);
        System.out.println(temp.getMsg1());

    }
}
</code></pre>
<p>6.测试结果：</p>
<pre><code>msg1
</code></pre>
<pre><code class="language-java">@PostConstruct // 当 bean 实例化时，回调这个注解修饰的方法，进行初始化操作，比如 Redis 预热场景。
public void init(){
}
</code></pre>
<h1 id="spring-如何完成扫描">Spring 如何完成扫描</h1>
<h2 id="如何初始化-spring-环境">如何初始化 Spring 环境？</h2>
<ul>
<li>xml：ClassPathXmlApplicationContext；
<ul>
<li>类的扫描</li>
<li>单独 bean 的注册：在 xml 中写一个<bean>，只要这个 xml 被解析，Spring 就帮助完成了 bean 的声明（定义<bean>）和注册（Spring 会自动创建一个对象放到容器中）</li>
</ul>
</li>
<li>注解 Annotation：必须借助 xml:&lt;context:component-scan base-package=&quot;com.ssm&quot;/&gt;或 JavaConfig:@ComponentScan 完成对类的扫描；</li>
<li>JavaConfig：AnnotationConfigApplicationContext。
<ul>
<li>类的扫描</li>
<li>类的定义：如果只是写了一个@Component，并没有扫描这个类，称为只是定义一个 bean，并没有类的注册（因为没有被扫描 ）</li>
</ul>
</li>
</ul>
<p>为什么要初始化 Spring 环境？</p>
<p>把我们交给 Spring 管理的类实例化</p>
<pre><code class="language-java">@Servicepublic class IndexService {}
</code></pre>
<pre><code class="language-java">// 表明这是一个 xml 文件
@Configuration
// 注解扫描包
@ComponentScan(&quot;com.ssm&quot;)
public class SpringConfig {
</code></pre>
<p>register() 可以注册两种类型的 bean：1.加了 @Configuration 的 bean；2.普通的 bean</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();

        context.register(SpringConfig.class);
        context.refresh();

        // register() 可以注册两种类型的 bean：加了 @Configuration 的 bean；普通的 bean
//        context.register(TestService.class);
        IndexService indexService = (IndexService) context.getBean(&quot;indexService&quot;);
        System.out.println(indexService);
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>com.ssm.service.IndexService@1a451d4d
</code></pre>
<p>AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);</p>
<p>![图片](https://epitomm.github.io/post-images/通过配置文件new AnnotationConfigApplicationContext.png)<br>
<img src="https://epitomm.github.io/post-images/register.png" alt="图片" loading="lazy"></p>
<p>context.register(SpringConfig.class);</p>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/register.png" alt="图片" loading="lazy"></figure>
<p>配置文件不扫描包，使用 register() 单独注册某个类</p>
<pre><code class="language-java">// 表明这是一个 xml 文件
@Configuration
// 注解扫描包
//@ComponentScan(&quot;com.ssm&quot;)
public class SpringConfig {
</code></pre>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
        // register() 注册加了 @Configuration 的 bean
        context.register(SpringConfig.class);
        // register() 注册普通的 bean
        context.register(IndexService.class);
        context.refresh();

        IndexService indexService = (IndexService) context.getBean(&quot;indexService&quot;);
        System.out.println(indexService);
    }
}
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/%E8%AF%BB%E5%8F%96JavaConfig%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/AnnotationConfigApplicationContext%E6%BA%90%E7%A0%81.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/register%E6%BA%90%E7%A0%81.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/register%E6%BA%90%E7%A0%81_2.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/registerBean%E6%BA%90%E7%A0%81.png" alt="图片" loading="lazy"></figure>
<p>context.scan(&quot;com.ssm&quot;); 也可以完成扫描：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();

        context.register(SpringConfig.class);
        context.scan(&quot;com.ssm&quot;);
        context.refresh();

        IndexService indexService = (IndexService) context.getBean(&quot;indexService&quot;);
        System.out.println(indexService);

    }
}
</code></pre>
<p><img src="https://epitomm.github.io/post-images/scan%E6%BA%90%E7%A0%81.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/scan%E6%BA%90%E7%A0%81_2.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/doScan.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/doScan%E6%89%AB%E6%8F%8F%E5%AE%8C%E6%88%90.png" alt="图片" loading="lazy"></p>
<p>进行类的扫描时，添加一个依赖，就可以按索引扫描，加快扫描速度。<br>
<img src="https://epitomm.github.io/post-images/findCandidateComponents.png" alt="图片" loading="lazy"></p>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/scanCandidateComponents.png" alt="图片" loading="lazy"></figure>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
public @interface Anno {
    public String value();
}
</code></pre>
<pre><code class="language-java">@Anno(&quot;userServiceImpl&quot;)
public class UserServiceImpl implements UserService {
</code></pre>
<pre><code class="language-java">public class AnnotationConfigApplicationContext {

    public void scan(String basePackage){
        // 1.通过文件名得到 .class 文件，然后去掉 .class 就是最终的类名
        // 得到根目录
        String rootPath = this.getClass().getResource(&quot;/&quot;).getPath();
        // 2. 将 com.ssm 变为 com/ssm/
        String basePackagePath = basePackage.replaceAll(&quot;\\.&quot;,&quot;\\\\&quot;);

        File file = new File(rootPath + &quot;//&quot; + basePackagePath);
        // 得到所有文件名的数组
        String[] names = file.list();
        for (String name : names) {
            // 去掉文件的 .class 就得到了类名
            name = name.replaceAll(&quot;.class&quot;,&quot;&quot;);
            // 得到所有的文件名
            try {
                Class&lt;?&gt; clazz = Class.forName(basePackage + &quot;.&quot; + name);
                // 判断是否属于 @Service、@Component...
                // 判断是否加了 @Anno 注解
                if(clazz.isAnnotationPresent(Anno.class)){
                    Anno annotation = (Anno)clazz.getAnnotation(Anno.class);
                    System.out.println(annotation.value());
                    System.out.println(clazz.newInstance());
                }
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            } catch (InstantiationException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<pre><code class="language-java">public class TestAnno {
    public static void main(String[] args) throws SpringException {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
        context.scan(&quot;com.ssm.service.impl&quot;);
    }
}
</code></pre>
<pre><code>userServiceImpl
com.ssm.service.impl.UserServiceImpl@1d44bcfa
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring系列（四）XML模拟SpringIOC]]></title>
        <id>https://epitomm.github.io/post/spring-xi-lie-si-xml-mo-ni-springioc/</id>
        <link href="https://epitomm.github.io/post/spring-xi-lie-si-xml-mo-ni-springioc/">
        </link>
        <updated>2020-05-05T03:28:50.000Z</updated>
        <content type="html"><![CDATA[<p>先来回顾一下自定义动态代理中获取对象的方法：</p>
<ul>
<li>获得代理对象：TestDao proxy = (TestDao) ProxyUtil.newInstance(TestDao.class, new TestCustomHandler(new TestDaoImpl()));</li>
<li>获得目标对象：TestDao target = new TestDaoImpl();<br>
以上方式耦合度过高</li>
</ul>
<h1 id="spring-ioc-的思想">Spring IOC 的思想</h1>
<p>工厂方法的好处，工厂方法控制了 proxy 对象的产生过程，现在这个对象的产生过程是由编码控制的，通过 newInstance() 控制的，但是如果使用工厂的话，工厂也可以控制类的产生过程：比如通过类名：TestDao proxy = Factory.getBean(&quot;testDao&quot;);由于可以做到自己控制，提出一种思想：注入，依赖查找查找名为 &quot;testDao&quot; 的 bean，<strong>对象的产生过程通过外部第三方容器注入给我</strong>，对于程序员来讲，编程的话，只需要写 TestDao testDao 即可，至于这个对象到底是什么东西，程序员无需关心，是由外部容器注入进来的，程序员正常编码即可，面向抽象编程这些方法都有，比如 testDao.query();</p>
<h1 id="模拟-springaop">模拟 SpringAOP</h1>
<p>实现将对象交给容器管理</p>
<h2 id="userdao">UserDao</h2>
<pre><code class="language-java">public interface UserDao {
    void query();
}
</code></pre>
<h2 id="userdaoimpl">UserDaoImpl</h2>
<pre><code class="language-java">public class UserDaoImpl implements UserDao {
    @Override
    public void query() {
        System.out.println(&quot;dao&quot;);
    }
}
</code></pre>
<h2 id="userservice">UserService</h2>
<pre><code class="language-java">public interface UserService {
    void find();
}
</code></pre>
<h2 id="userserviceimpl">UserServiceImpl</h2>
<pre><code class="language-java">public class UserServiceImpl implements UserService {

    private UserDao userDao;

    @Override
    public void find() {
        System.out.println(&quot;service...&quot;);
        userDao.query();
    }

    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}
</code></pre>
<h2 id="springxml">spring.xml</h2>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!--
    1.哪些类需要我（容器）来管理
    2.怎么告诉我这些类：&lt;bean&gt;
    3.怎么维护依赖关系：setter、constructor
    4.怎么体现 setter：&lt;property&gt; 或者 constructor：&lt;constructor&gt;
--&gt;
&lt;beans&gt;

    &lt;bean id=&quot;userDao&quot; class = &quot;com.ssm.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;

    &lt;bean id=&quot;userService&quot; class=&quot;com.ssm.service.impl.UserServiceImpl&quot;&gt;
        &lt;!-- 注入：1.构造方法；
        2.set方法：UserService 中有一个 setUserDao(UserDao userDao)  方法，
        只要提供了 UserDao，容器自动调用 setUserDao() 方法给 UserService 内的 UserDao 赋值--&gt;
        &lt;property name=&quot;userDao&quot; ref = &quot;userDao&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h2 id="解析-xml-的方式dom4j">解析 xml 的方式：dom4j。</h2>
<p>dom4j 官网：<a href="https://dom4j.github.io/">https://dom4j.github.io/</a><br>
导入 dom4j 依赖：</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/dom4j/dom4j --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;dom4j&lt;/groupId&gt;
  &lt;artifactId&gt;dom4j&lt;/artifactId&gt;
  &lt;version&gt;1.6.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="将对象交给容器管理setter-方法注入">将对象交给容器管理（setter 方法注入）</h2>
<p>解析 xml 文件，将 “对象名-对象类型” 放到 map 集合中。</p>
<pre><code class="language-java">import org.dom4j.Attribute;
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.Element;
import org.dom4j.io.SAXReader;

import java.io.File;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

public class BeanFactory {

    // 得到每个 bean 的 id、class 存到 map 中
    Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();

    public BeanFactory(String xml){
        parseXml(xml);
    }

    /**
     * 解析 XML
     */
    public void parseXml(String xml){
        // 获取要解析的 xml 的路径
        File file = new File(this.getClass().getResource(&quot;/&quot;).getPath() + &quot;//&quot; + xml);
        // 解析 xml
        SAXReader reader = new SAXReader();
        Document document = null;
        try {
            document = reader.read(file);
            // 得到根目录
            Element elementRoot = document.getRootElement();
            // 获取根目录下的所有子目录
            for (Iterator&lt;Element&gt; itFirst = elementRoot.elementIterator(); itFirst.hasNext();) {
                /**
                 * setup1.实例化对象
                 */
                // 得到第一个子元素：spring.xml 中的 &lt;bean&gt;
                Element elementFirstChild = itFirst.next();
                // 获得 bean 标签的 id 属性值
                Attribute attributeId = elementFirstChild.attribute(&quot;id&quot;);
                String beanName = attributeId.getValue();
                // 获得 bean 标签的 class 属性值
                Attribute attributeClass = elementFirstChild.attribute(&quot;class&quot;);
                String clazzName = attributeClass.getValue();
                Class clazz = Class.forName(clazzName);
                Object object = clazz.newInstance();
                /**
                 * setup2.维护依赖关系
                 *  (1)看这个对象有没有依赖（判断类是否有属性，然后再判断&lt;bean&gt;中是否有 name=&quot;属性值&quot;的&lt;property&gt;）
                 *      如果有，则注入
                 */
                // 得到&lt;bean&gt;的子标签
                for (Iterator&lt;Element&gt; itSecond = elementFirstChild.elementIterator(); itSecond.hasNext();) {
                    // 得到 &lt;property name=&quot;userDao&quot; ref = &quot;userDao&quot;&gt;&lt;/property&gt;
                    Element elementSecondChild = itSecond.next();
                    if(&quot;property&quot;.equals(elementSecondChild.getName())){
                        // 1.得到 ref 的 value（userDao），通过 value 得到对象（map中id=&quot;userDao&quot;）
                        String refValue = elementSecondChild.attribute(&quot;ref&quot;).getValue();
                        // 需要注入的对象 UserDao
                        Object injetObject = map.get(refValue);
                        // 2.得到 name 的值（userDao），然后根据它获取一个 Field 的对象（UserServiceImpl 中的 UserDao userDao）
                        String nameValue = elementSecondChild.attribute(&quot;name&quot;).getValue();
                        // 通过反射得到 Field 对象，即UserDao
                        Field field = clazz.getDeclaredField(nameValue);
                        field.setAccessible(true);
                        // 相等于 UserService.setUserDao(userDao)
                        // 两个参数：userService、UserDao
                        // 3.通过 Field 的set 方法 set 这个对象
                        field.set(object,injetObject);
                    }

                }
                // 放到 map 中
                map.put(beanName,object);
            }
        } catch (DocumentException | ClassNotFoundException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        }
        System.out.println(map);
    }
    public Object getBean(String beanName){
        return map.get(beanName);
    }
}

## 测试类
```java
public class Test {
    public static void main(String[] args) {
        BeanFactory beanFactory = new BeanFactory(&quot;spring.xml&quot;);
        UserService userService = (UserService) beanFactory.getBean(&quot;userService&quot;);
        userService.find();
    }
}
</code></pre>
<p>##运行结果：</p>
<pre><code>{userDao=com.ssm.dao.impl.UserDaoImpl@4dd8dc3, userService=com.ssm.service.impl.UserServiceImpl@6d03e736}
service...
dao
</code></pre>
<h2 id="构造方法注入">构造方法注入</h2>
<h3 id="userserviceimpluserdao-userdao-构造方法">UserServiceImpl(UserDao userDao) 构造方法</h3>
<pre><code class="language-java">public class UserServiceImpl implements UserService {
    private UserDao dao;
    public UserServiceImpl(UserDao userDao){
        this.dao = userDao;
    }

    @Override
    public void find() {
        System.out.println(&quot;service...&quot;);
        dao.query();
    }
}
</code></pre>
<p>###spring.xml</p>
<pre><code class="language-xml">    &lt;bean id=&quot;userService&quot; class=&quot;com.ssm.service.impl.UserServiceImpl&quot;&gt;
        &lt;!-- 注入：1.构造方法；
        2.set方法：UserService 中有一个 setUserDao(UserDao userDao)  方法，
        只要提供了 UserDao，容器自动调用 setUserDao() 方法给 UserService 内的 UserDao 赋值
        name=&quot;dao&quot; :private UserDao dao--&gt;
&lt;!--        &lt;property name=&quot;dao&quot; ref = &quot;userDao&quot;&gt;&lt;/property&gt;--&gt;

        &lt;!-- name=&quot;userDao&quot;：属性的名字：private UserDao dao;
            ref=&quot;userDao&quot;:引入&lt;bean&gt;的 id 为 userDao 的对象--&gt;
        &lt;constructor-arg name=&quot;dao&quot; ref=&quot;userDao&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;
</code></pre>
<p>###解析 xml 将对象放到 map 中</p>
<pre><code class="language-java">public class BeanFactory {

    // 得到每个 bean 的 id、class 存到 map 中
    Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();

    public BeanFactory(String xml){
        parseXml(xml);
    }

    /**
     * 解析 XML
     */
    public void parseXml(String xml){
        // 获取要解析的 xml 的路径
        File file = new File(this.getClass().getResource(&quot;/&quot;).getPath() + &quot;//&quot; + xml);
        // 解析 xml
        SAXReader reader = new SAXReader();
        Document document = null;
        try {
            document = reader.read(file);
            // 得到根目录
            Element elementRoot = document.getRootElement();
            // 获取根目录下的所有子目录
            for (Iterator&lt;Element&gt; itFirst = elementRoot.elementIterator(); itFirst.hasNext();) {
                /**
                 * setup1.实例化对象
                 */
                // 得到第一个子元素：spring.xml 中的 &lt;bean&gt;
                Element elementFirstChild = itFirst.next();
                // 获得 bean 标签的 id 属性值
                Attribute attributeId = elementFirstChild.attribute(&quot;id&quot;);
                String beanName = attributeId.getValue();
                // 获得 bean 标签的 class 属性值
                Attribute attributeClass = elementFirstChild.attribute(&quot;class&quot;);
                String clazzName = attributeClass.getValue();
                Class clazz = Class.forName(clazzName);
                // 当使用构造方法注入时，就不能在这里 newInstance 了，因为没有默认构造方法了
//                Object object = clazz.newInstance();
                Object object = null;
                /**
                 * setup2.维护依赖关系
                 *  (1)看这个对象有没有依赖（判断类是否有属性，然后再判断&lt;bean&gt;中是否有 name=&quot;属性值&quot;的&lt;property&gt;）
                 *      如果有，则注入
                 */
                // 得到&lt;bean&gt;的子标签
                for (Iterator&lt;Element&gt; itSecond = elementFirstChild.elementIterator(); itSecond.hasNext();) {
                    // 得到 &lt;property name=&quot;userDao&quot; ref = &quot;userDao&quot;&gt;&lt;/property&gt;
                    Element elementSecondChild = itSecond.next();
                    // 如果使用 setter 方法注入
                    if(&quot;property&quot;.equals(elementSecondChild.getName())){
                        // 由于是 setter 注入，有一个默认构造方法，可以 newInstance()
                        object = clazz.newInstance();
                        // 1.得到 ref 的 value（userDao），通过 value 得到对象（map中id=&quot;userDao&quot;）
                        String refValue = elementSecondChild.attribute(&quot;ref&quot;).getValue();
                        // 需要注入的对象 UserDao
                        Object injectObject = map.get(refValue);
                        // 2.得到 name 的值（userDao），然后根据它获取一个 Field 的对象（UserServiceImpl 中的 UserDao userDao）
                        String nameValue = elementSecondChild.attribute(&quot;name&quot;).getValue();

                        // 3.通过 Field 的set 方法 set 这个对象
                        // 通过反射得到 Field 对象，即UserDao
                        Field field = clazz.getDeclaredField(nameValue);
                        field.setAccessible(true);
                        // 相等于 UserService.setUserDao(userDao)
                        // 两个参数：userService、UserDao
                        field.set(object,injectObject);
                    }else {// 通过构造方法注入 UserDao
                        // &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/constructor-arg&gt;
                        // 由于没有默认构造方法了，所以不可以 clazz.newInstance() 了
                        // 1.得到 ref 的 value（userDao），通过 value 得到对象（map中id=&quot;userDao&quot;）
                        String refValue = elementSecondChild.attribute(&quot;ref&quot;).getValue();
                        // 需要注入的对象 UserDao
                        Object injectObject = map.get(refValue);
                        // 得到 UserDao 的类型
                        Class injectObjectClazz = injectObject.getClass();
                        // 2.得到 UserService 的构造方法
                        Constructor constructor = clazz.getConstructor(injectObjectClazz.getInterfaces()[0]);
                        //  public UserServiceImpl(UserDao userDao){
                        object = constructor.newInstance(injectObject);

                    }

                }
                // 放到 map 中
                if(object == null){ //没有子标签，比如  &lt;bean id=&quot;userDao&quot; class = &quot;com.ssm.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;
                    object = clazz.newInstance();
                }
                map.put(beanName,object);
            }
        } catch (DocumentException | ClassNotFoundException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
        System.out.println(map);
    }
    public Object getBean(String beanName){
        return map.get(beanName);
    }
}
</code></pre>
<h2 id="自动注入">自动注入</h2>
<pre><code class="language-java">public class UserDaoImpl implements UserDao {
    @Override
    public void query() {
        System.out.println(&quot;dao&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class UserDaoImpl2 implements UserDao {
    @Override
    public void query() {
        System.out.println(&quot;dao2&quot;);
    }
}
</code></pre>
<p>UserServiceImpl 依赖 UserDao，但是既不提供构造方法，也不提供 setter。使用 byType 自动注入。</p>
<pre><code class="language-java">public class UserServiceImpl implements UserService {
    private UserDao userDao;
    @Override
    public void find() {
        System.out.println(&quot;service...&quot;);
        userDao.query();
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans default-autowire=&quot;byType&quot;&gt;
    &lt;bean id=&quot;userDao&quot; class = &quot;com.ssm.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;userDao2&quot; class = &quot;com.ssm.dao.impl.UserDaoImpl2&quot;&gt;&lt;/bean&gt;

    &lt;bean id=&quot;userService&quot; class=&quot;com.ssm.service.impl.UserServiceImpl&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">public class BeanFactory {

    // 得到每个 bean 的 id、class 存到 map 中
    Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();

    public BeanFactory(String xml)throws  SpringException{
        parseXml(xml);
    }

    /**
     * 解析 XML
     */
    public void parseXml(String xml) throws SpringException{
        // 获取要解析的 xml 的路径
        File file = new File(this.getClass().getResource(&quot;/&quot;).getPath() + &quot;//&quot; + xml);
        // 解析 xml
        SAXReader reader = new SAXReader();
        Document document = null;
        try {
            document = reader.read(file);
            // 得到根目录
            Element elementRoot = document.getRootElement();
            Attribute attribute = elementRoot.attribute(&quot;default-autowire&quot;);
            // 记录是否有 default-autowire 自动注入属性
            boolean flag = false;
            if(attribute != null){
                flag = true;
            }
            // 获取根目录下的所有子目录
            for (Iterator&lt;Element&gt; itFirst = elementRoot.elementIterator(); itFirst.hasNext();) {
                /**
                 * setup1.实例化对象
                 */
                // 得到第一个子元素：spring.xml 中的 &lt;bean&gt;
                Element elementFirstChild = itFirst.next();
                // 获得 bean 标签的 id 属性值
                Attribute attributeId = elementFirstChild.attribute(&quot;id&quot;);
                String beanName = attributeId.getValue();
                // 获得 bean 标签的 class 属性值
                Attribute attributeClass = elementFirstChild.attribute(&quot;class&quot;);
                String clazzName = attributeClass.getValue();
                Class clazz = Class.forName(clazzName);
                // 当使用构造方法注入时，就不能在这里 newInstance 了，因为没有默认构造方法了
//                Object object = clazz.newInstance();
                Object object = null;
                /**
                 * setup2.维护依赖关系
                 *  (1)看这个对象有没有依赖（判断类是否有属性，然后再判断&lt;bean&gt;中是否有 name=&quot;属性值&quot;的&lt;property&gt;）
                 *      如果有，则注入
                 */
                // 得到&lt;bean&gt;的子标签
                for (Iterator&lt;Element&gt; itSecond = elementFirstChild.elementIterator(); itSecond.hasNext();) {
                    // 得到 &lt;property name=&quot;userDao&quot; ref = &quot;userDao&quot;&gt;&lt;/property&gt;
                    Element elementSecondChild = itSecond.next();
                    // 如果使用 setter 方法注入
                    if(&quot;property&quot;.equals(elementSecondChild.getName())){
                        // 由于是 setter 注入，有一个默认构造方法，可以 newInstance()
                        object = clazz.newInstance();
                        // 1.得到 ref 的 value（userDao），通过 value 得到对象（map中id=&quot;userDao&quot;）
                        String refValue = elementSecondChild.attribute(&quot;ref&quot;).getValue();
                        // 需要注入的对象 UserDao
                        Object injectObject = map.get(refValue);
                        // 2.得到 name 的值（userDao），然后根据它获取一个 Field 的对象（UserServiceImpl 中的 UserDao userDao）
                        String nameValue = elementSecondChild.attribute(&quot;name&quot;).getValue();

                        // 3.通过 Field 的set 方法 set 这个对象
                        // 通过反射得到 Field 对象，即UserDao
                        Field field = clazz.getDeclaredField(nameValue);
                        field.setAccessible(true);
                        // 相等于 UserService.setUserDao(userDao)
                        // 两个参数：userService、UserDao
                        field.set(object,injectObject);
                    }else {// 通过构造方法注入 UserDao
                        // &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/constructor-arg&gt;
                        // 由于没有默认构造方法了，所以不可以 clazz.newInstance() 了
                        // 1.得到 ref 的 value（userDao），通过 value 得到对象（map中id=&quot;userDao&quot;）
                        String refValue = elementSecondChild.attribute(&quot;ref&quot;).getValue();
                        // 需要注入的对象 UserDao
                        Object injectObject = map.get(refValue);
                        // 得到 UserDao 的类型
                        Class injectObjectClazz = injectObject.getClass();
                        // 2.得到 UserService 的构造方法
                        Constructor constructor = clazz.getConstructor(injectObjectClazz.getInterfaces()[0]);
                        //  public UserServiceImpl(UserDao userDao){
                        object = constructor.newInstance(injectObject);

                    }
                }

                // 手动装配 &gt; 自动装配。如果没有手动装配，就自动装配
                if(object == null){
                    // 如果配置了自动装配
                    if(flag){
                        if(&quot;byType&quot;.equals(attribute.getValue())){
                            // 1.判断是否有依赖
                            // 因为自动装配，所以&lt;bean&gt;没有&lt;property&gt;和&lt;constructor&gt;
                            // 就需要判断 UserServiceImpl 类中是否有属性 UserDao，
                            // 如果没有，就证明 UserServiceImpl 没有依赖；如果有，就证明 UserServiceImpl 有依赖
                            Field[] fields = clazz.getDeclaredFields();
                            for (Field field : fields) {
                                // 2.得到属性的类型，比如 private UserDao dao;那么field.getType()=UserDao.class
                                Class injectObjectClazz = field.getType();
                                /**
                                 * 由于是 byType，所以需要遍历 map 当中的所有对象，
                                 * 判断对象的类型是不是和这个 injectObjectClazz 类型相同
                                 */
                                // 记录 byType 找到的个数：比如找到多少个 UserDaoImpl
                                int count = 0;
                                Object injectObject = null;
                                for(String key : map.keySet()){
                                    Class&lt;?&gt; temp = map.get(key).getClass().getInterfaces()[0];
                                    if(temp.getName().equals(injectObjectClazz.getName())){
                                        injectObject = map.get(key);
                                        // 记录找到一个，因为可能找到多个
                                        count++;
                                    }
                                }
                                // 如果 byType 找到多个
                                if(count &gt; 1){
                                    throw new SpringException(&quot;需要一个对象，但是找到了两个对象&quot;);
                                }else {
                                    // 如果只找到一个 type，注入
                                    field.setAccessible(true);
                                    object = clazz.newInstance();
                                    field.set(object, injectObject);
                                }
                            }
                        }
                    }
                }

                // 放到 map 中
                if(object == null){ //没有子标签，比如  &lt;bean id=&quot;userDao&quot; class = &quot;com.ssm.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;
                    object = clazz.newInstance();
                }
                map.put(beanName,object);
            }
        } catch (DocumentException | ClassNotFoundException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
        System.out.println(map);
    }
    public Object getBean(String beanName){
        return map.get(beanName);
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>Exception in thread &quot;main&quot; com.ssm.org.spring.util.SpringException: 需要一个对象，但是找到了两个对象
	at com.ssm.org.spring.util.BeanFactory.parseXml(BeanFactory.java:137)
	at com.ssm.org.spring.util.BeanFactory.&lt;init&gt;(BeanFactory.java:25)
	at com.ssm.test.Test.main(Test.java:10)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring系列（三）一篇文章学会 JDK 动态代理并手动模拟一个动态代理]]></title>
        <id>https://epitomm.github.io/post/yi-pian-wen-zhang-xue-hui-jdk-dong-tai-dai-li-bing-shou-dong-mo-ni-yi-ge-dong-tai-dai-li/</id>
        <link href="https://epitomm.github.io/post/yi-pian-wen-zhang-xue-hui-jdk-dong-tai-dai-li-bing-shou-dong-mo-ni-yi-ge-dong-tai-dai-li/">
        </link>
        <updated>2020-05-03T14:34:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="什么是代理"><strong>什么是代理</strong></h1>
<p>增强一个对象的功能</p>
<p>买火车票，app就是一个代理，他代理了火车站；小区当中的代售窗口也是一个代理，代理了火车站。</p>
<h1 id="代理模式的引入">代理模式的引入</h1>
<p>1、UserDaoImpl 有一个查询数据库的方法：</p>
<pre><code class="language-java">public class UserDaoImpl{
    public void query(){
        System.out.println(&quot;假装查询数据库&quot;);
    }
}
</code></pre>
<p>2、测试类中调用这个方法</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        UserDaoImpl userDao = new UserDaoImpl();
        LogUtil.log();
        userDao.query();
    }
}
</code></pre>
<p>3、现在有一个这样的需求：想要在每次执行 query() 时记录当前操作写到日志里面。写一个公共的日志方法 log()，那么把 LogUtil.log() 代码写到哪里呢？</p>
<p>3.1 写到 query() 方法中：</p>
<p>3.1.1 缺点：可能 UserDoImpl 是一个 jar，根本没有它的源码，无法进行修改。</p>
<p>3.1.2 即使有源码，将 query() 改写成如下：破坏了单一职责。</p>
<pre><code class="language-java">public void query(){
  LogUtil.log();
  // 进行数据库查询操作...
  System.out.println(&quot;假装查询数据库&quot;); 
}
</code></pre>
<p>单一职责：只做一件事。将日志操作写到 query() 里面破坏了类的封装性，职责就不单一了 。</p>
<p>3.2 写到 Test 类中：  每次调用查询操作前记录当前时间。</p>
<p>缺点：会调用很多次 query 方法，也就要写很多次 Logutil.log() 大量重复代码。</p>
<p>3.3 引入代理模式</p>
<h1 id="java实现的代理的两种办法"><strong>java实现的代理的两种办法</strong></h1>
<h1 id="代理的名词">代理的名词</h1>
<p>代理对象——增强后的对象</p>
<p>目标对象——被增强的对象</p>
<p>他们不是绝对的，会根据情况发生变化</p>
<h1 id="静态代理">静态代理</h1>
<h2 id="继承">继承</h2>
<ul>
<li>代理对象继承目标对象，重写需要增强的方法</li>
<li>缺点：会代理类过多，非常复杂</li>
</ul>
<p>回到上襦代理模式引入的例子中：</p>
<p>3.3 继承：自定义一个类<strong>继承</strong>原来需要添加日志的类 UserDaoImpl，在执行业务操作前添加日志打印语句。既解决了 jar 包无法修改源码的问题，又没有破坏单一职责原则。</p>
<pre><code class="language-java">public class UserDaoLogImpl extends UserDaoImpl {
    @Override
    public void query() {
        LogUtil.log();
        super.query();
    }
}
</code></pre>
<p>测试类：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        UserDao userDao = new UserDaoLogImpl();
        userDao.query();
    }
}
</code></pre>
<p>分析：如此得到了被增强后的 UserDaoImpl，可实现在 query() 前进行日志打印。</p>
<p>UserDaoImpl：目标对象</p>
<p>UserDaoLogImpl ：代理对象。</p>
<p>代理对象和目标对象是相对而言的。UserDaoLogImpl 是代理对象，但是有一天它也有可能成为目标对象。</p>
<p>4、有一个新需求：在 query 方法前添加一个权限验证。</p>
<pre><code class="language-java">public class UserDaoPowerImpl extends UserDaoImpl {
    @Override
    public void query() {
        LogUtil.log(&quot;power...&quot;);
        super.query();
    }
}
</code></pre>
<p>5、有一个新需求：在 query 方法前添加一个时间记录。</p>
<pre><code class="language-java">public class UserDaoTimerImpl extends UserDaoImpl {
    @Override
    public void query() {
        LogUtil.log(&quot;timer...&quot;);
        super.query();
    }
}
</code></pre>
<p>6、有一个新需求：在 query() 方法被调用前既实现日志打印、又实现记录当前时间的功能</p>
<pre><code class="language-java">public class UserDaoTimeAndLogImpl extends UserDaoLogImpl {
    @Override
    public void query() {
        // timer
        LogUtil.log(&quot;timer...&quot;);
        // logger &amp; query
        super.query();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>timer...
logger...
假装查询数据库
</code></pre>
<p>7、新需求：在 query() 前先打印日志，然后再记录时间</p>
<pre><code class="language-java">public class UserDaoLogAndTimeImpl extends UserDaoTimerImpl {
    @Override
    public void query() {
        LogUtil.log(&quot;logger...&quot;);
        // logger
        super.query();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>logger...
timer...
假装查询数据库
</code></pre>
<p>只是改变了以一下日志记录顺序，就会增加一个新的类，不同的排列组合会造成代理类过多。</p>
<h2 id="聚合">聚合</h2>
<ul>
<li>目标对象和代理对象实现同一个接口，代理对象当中要包含目标对象。</li>
<li>缺点：也会产生类爆炸（UserDaoLog implements UserDao、OrderDaoLog implements OrderDao......），只不过比继承少一点点</li>
<li>总结:如果在不确定的情况下，尽量不要去使用静态代理。因为一旦你写代码，就会产生类，一旦产生类就爆炸。</li>
</ul>
<p>1、声明一个接口：</p>
<pre><code class="language-java">public interface UserDao {
    void query();
}
</code></pre>
<p>2、目标对象 UserDaoImpl 实现 UserDao 接口</p>
<pre><code class="language-java">public class UserDaoImpl implements UserDao {
    public void query(){
        System.out.println(&quot;假装查询数据库&quot;);
    }
}
</code></pre>
<p>3、代理对象实现 UserDao 接口，代理对象 UserDaoLog 中包含目标对象 UserDaoImpl（测试类传参为目标对象类）</p>
<pre><code class="language-java">public class UserDaoLog implements UserDao {
    // 装饰者模式：写一个构造方法，通过传入一个目标对象指定代理/ 装饰具体的对象
    UserDao dao;
    public UserDaoLog(UserDao userDao){
        this.dao = userDao;
    }
    @Override
    public void query() {
        LogUtil.log(&quot;logger...&quot;);
        dao.query();
        // 代理模式：new UserDaoImpl().query();UserDao不是传递进来的，是写死的。
    }
}
</code></pre>
<p>4、测试类</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        UserDao target = new UserDaoImpl();
        UserDao proxy = new UserDaoLog(target);
        proxy.query();
    }
}
</code></pre>
<p>测试结果：</p>
<pre><code>logger...
假装查询数据库 
</code></pre>
<p>5、新需求：记录时间</p>
<pre><code class="language-java">public class UserDaoTime implements UserDao {
    UserDao dao;
    public UserDaoTime(UserDao userDao){
        this.dao = userDao;
    }
    @Override
    public void query() {
        LogUtil.log(&quot;timer...&quot;);
        dao.query();
    }
}
</code></pre>
<p>测试类：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        UserDao target = new UserDaoImpl();
        UserDao proxy = new UserDaoTime(target);
        proxy.query();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>timer...
假装查询数据库
</code></pre>
<p>6、新需求：完成对日志和时间的代理，无需新增一个类。只需将时间的代理对象作为目标对象，传递给日志代理对象即可。</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // time + logic(业务逻辑)
        UserDao target = new UserDaoTime(new UserDaoImpl());
        // log + time + logic
        UserDao proxy = new UserDaoLog(target);
        proxy.query();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>logger...
timer...
假装查询数据库
</code></pre>
<p>6、新需求：完成先打印时间，再记录日志的操作。无需新增类，只需修改测试类即可。</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        UserDao target = new UserDaoLog(new UserDaoImpl());
        UserDao proxy = new UserDaoTime(target);
        proxy.query();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>timer...
logger...
假装查询数据库动态代理
</code></pre>
<h2 id="自己模拟的动态代理">自己模拟的动态代理</h2>
<p>如何拿到一个对象？</p>
<p>不需要手动 new 创 建类文件（因为一旦手动创建类文件，就会产生类爆炸），通过接口反射生成一个类文件，然后调用第三方的编译技术，动态编译这个产生的类文件成class文件，继而利用UrlclassLoader(因为这个动态产生的class不在工程当中所以需要使用UrlclassLoader)把这个动态编译的类加载到jvm当中，最后通过反射把这个类实例化。</p>
<p>缺点：首先要生成文件</p>
<p>缺点：动态编译文件 class</p>
<p>缺点：需要一个URLclassloader</p>
<p>软件性能的最终体现在IO操作</p>
<p>file(.java) ---&gt; .class ---&gt; byte[] ---&gt; object(Class 类对象)  ---&gt; object.newInstance()</p>
<h3 id="1准备一个接口">1.准备一个接口：</h3>
<pre><code class="language-java">public interface TestDao {
    String query(String s1, String s2);
}
</code></pre>
<h3 id="2准备一个接口实现类">2.准备一个接口实现类：</h3>
<pre><code class="language-java">public class TestDaoImpl implements TestDao {
    @Override
    public String query(String s1, String s2) {
        System.out.println(&quot;查询数据库&quot;);
        System.out.println(&quot;daoImpl...&quot; + s1 + &quot; &quot; + s2);
        return s1 + &quot; &quot; + s2;
    }
}
</code></pre>
<h3 id="3模拟动态代理">3.模拟动态代理：</h3>
<pre><code class="language-java">package com.ssm.util;

import javax.tools.JavaCompiler;
import javax.tools.StandardJavaFileManager;
import javax.tools.ToolProvider;
import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLClassLoader;
import com.sun.jndi.toolkit.url.UrlUtil;

public class ProxyUtil {

    /**
     * 如何产生一个对象？
     *  content ---&gt; String
     *  .java
     *  .class
     *  .new
     * @param target：目标对象
     * @return
     */
    public static Object newInstance(Object target) throws IOException, IllegalAccessException, InstantiationException, NoSuchMethodException, ClassNotFoundException, InvocationTargetException {
        // targetInterface：目标对象的接口
        Class targetInterface = target.getClass().getInterfaces()[0];

        // 声明最终要返回的代理对象
        Object proxy=null;
        /**
         * package com.ssm.proxyInter;
         *
         * import com.ssm.dao.UserDao;
         *
         * public class UserDaoLog implements UserDao {
         *
         *     private UserDao target;
         *     public UserDaoLog(UserDao target){
         *         this.target = target;
         *     }
         *     @Override
         *     public void query(String p0, String p1) {
         *         System.out.println(&quot;log...&quot;);
         *         target.query(p0,p1);
         *     }
         * }
         * 将上述代码逐行变成字符串
         */
        // 换行
        String line = &quot;\n&quot;;
        // 缩进
        String tab = &quot;\t&quot;;
        // 得到接口名 UserDao
        String interfaceName = targetInterface.getSimpleName();
        // 得到接口中的所有方法 query()
        Method[] methods = targetInterface.getDeclaredMethods();
        String content = &quot;&quot;;
        String packageContent = &quot;package com.ssm;&quot; + line;
        String importContent = &quot;import &quot; + targetInterface.getName() + &quot;;&quot; + line;
        String classFirstLineContent = &quot;public class $Proxy implements &quot; +interfaceName+ &quot;{&quot; + line;
        String fieldContent = tab + &quot;private &quot; + interfaceName + &quot; target;&quot; + line;
        String constructorContent = tab + &quot;public $Proxy (&quot; + interfaceName + &quot; target){&quot; + line
                + tab + tab + &quot;this.target = target; &quot;+ line
                + tab +&quot;}&quot; + line;

        // 参数内容：target.query(p0,p1);
        String paramsContent = &quot;&quot;;
        String methodContent = &quot;&quot;;
        for (Method method : methods){
            // 得到当前方法的返回类型
            String returnType = method.getReturnType().getSimpleName();
            // 得到当前方法的方法名
            String methodName = method.getName();
            // 得到方法的参数类型：如 String.class
            Class[] args = method.getParameterTypes();
            String argsContent = &quot;&quot;;
            for (int i = 0 ; i &lt; args.length ; i++){
                // 得到的是参数类型：如 String
                String temp = args[i].getSimpleName();
                // 最终构造成这个形式：String p0,String p1
                argsContent += temp + &quot; p&quot; + i + &quot;,&quot;;
                paramsContent += &quot;p&quot; + i + &quot;,&quot;;
            }
            // 截取掉最后一个多余的 ','
            if(argsContent.length() &gt; 0){
                argsContent = argsContent.substring(0,argsContent.lastIndexOf(&quot;,&quot;));
                paramsContent = paramsContent.substring(0,paramsContent.lastIndexOf(&quot;,&quot;));
            }
            methodContent += tab + &quot;public &quot; + returnType + &quot; &quot; + methodName + &quot;(&quot; + argsContent + &quot;) {&quot; + line
                    + tab + tab + &quot;System.out.println(\&quot;log\&quot;);&quot; + line;
            // 判断是否有返回值
            if(&quot;void&quot;.equals(returnType)){
                methodContent += tab + tab + &quot;target.&quot; + methodName + &quot;(&quot; + paramsContent + &quot;);&quot; + line
                        + tab + &quot;}&quot; + line;
            }else {
                methodContent += tab + tab + &quot; return target.&quot; + methodName + &quot;(&quot; + paramsContent + &quot;);&quot; + line
                        + tab + &quot;}&quot; + line;
            }

        }

        content = packageContent + importContent + classFirstLineContent + fieldContent + constructorContent + methodContent + &quot;}&quot;;

        File file = new File(&quot;C:\\Users\\Only\\com\\ssm\\$Proxy.java&quot;);
        if(!file.exists()){
            file.createNewFile();
        }
        FileWriter fw = new FileWriter(file);
        fw.write(content);
        fw.flush();
        fw.close();

        // .java ---&gt; .class
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null);
        Iterable units = fileMgr.getJavaFileObjects(file);
        JavaCompiler.CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units);
        t.call();
        fileMgr.close();

        // 通过反射得到构造函数 new 一个对象出来
        URL[] urls = new URL[]{new URL(&quot;file:C:\\Users\\Only\\\\&quot;)};
        URLClassLoader urlClassLoader = new URLClassLoader(urls);
        Class clazz = urlClassLoader.loadClass(&quot;com.ssm.$Proxy&quot;);
        Constructor constructor = clazz.getConstructor(targetInterface);
        proxy = constructor.newInstance(target);

        return proxy;
    }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E6%A8%A1%E6%8B%9F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.png" alt="图片" loading="lazy"></figure>
<h3 id="4测试类">4.测试类</h3>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws IOException, InvocationTargetException, NoSuchMethodException, ClassNotFoundException, InstantiationException, IllegalAccessException {
        TestDao proxy = (TestDao) ProxyUtil.newInstance(new TestDaoImpl());
        String res = proxy.query(&quot;hello&quot;, &quot;world&quot;);
        System.out.println(&quot;res = &quot; + res);
    }
}
</code></pre>
<p>最终运行效果：</p>
<pre><code class="language-java">log
查询数据库
daoImpl...hello world
res = hello world
</code></pre>
<h2 id="代理逻辑动态实现而不是写死的-sout">代理逻辑动态实现，而不是写死的 sout</h2>
<h3 id="1要代理的接口">1.要代理的接口</h3>
<pre><code class="language-java">public interface TestDao {
    String delete() throws Exception;
}
</code></pre>
<h3 id="2目标对象">2.目标对象</h3>
<pre><code class="language-java">public class TestDaoImpl implements TestDao {
    @Override
    public String delete() {
        System.out.println(&quot;dao...delete&quot;);
        return null;
    }
}
</code></pre>
<h3 id="3代理逻辑接口">3.代理逻辑接口</h3>
<pre><code class="language-java">public interface CustomInvocationHandler {
    Object invoke(Method method);
}
</code></pre>
<h3 id="4代理逻辑具体实现">4.代理逻辑具体实现</h3>
<pre><code class="language-java">package com.ssm.test;
import com.ssm.dao.CustomInvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
public class TestCustomHandler implements CustomInvocationHandler {
    private Object target;
    public TestCustomHandler(Object target){
        this.target = target;
    }
    @Override
    public Object invoke(Method method) {
        System.out.println(&quot;TestCustomHandler...&quot;);
        try {
            return method.invoke(target);
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
        return null;
    }
}
</code></pre>
<p>4.自定义动态代理</p>
<pre><code class="language-java">package com.ssm.util;

import javax.tools.JavaCompiler;
import javax.tools.StandardJavaFileManager;
import javax.tools.ToolProvider;
import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLClassLoader;
import com.ssm.dao.CustomInvocationHandler;
import com.sun.jndi.toolkit.url.UrlUtil;
public class ProxyUtil {
    /**
     * 如何产生一个对象？
     *  content ---&gt; String
     *  .java
     *  .class
     *  .new
     * @return
     */
    public static Object newInstance(Class targetInterface, CustomInvocationHandler h) throws IOException, IllegalAccessException, InstantiationException, NoSuchMethodException, ClassNotFoundException, InvocationTargetException {
        // targetInterface：目标对象的接口
//        Class targetInterface = target.getClass().getInterfaces()[0];

        // 声明最终要返回的代理对象
        Object proxy=null;
        /**
         * package com.ssm.proxyInter;
         *
         * import com.ssm.dao.UserDao;
         *
         * public class UserDaoLog implements UserDao {
         *
         *     private UserDao target;
         *     public UserDaoLog(UserDao target){
         *         this.target = target;
         *     }
         *     @Override
         *     public void query(String p0, String p1) {
         *         System.out.println(&quot;log...&quot;);
         *         target.query(p0,p1);
         *     }
         * }
         * 将上述代码逐行变成字符串
         */
        // 换行
        String line = &quot;\n&quot;;
        // 缩进
        String tab = &quot;\t&quot;;
        // 得到接口名 UserDao
        String interfaceName = targetInterface.getSimpleName();
        // 得到接口中的所有方法 query()
        Method[] methods = targetInterface.getDeclaredMethods();
        String content = &quot;&quot;;
        String packageContent = &quot;package com.ssm;&quot; + line;
        String importContent = &quot;import &quot; + targetInterface.getName() + &quot;;&quot; + line
                + &quot;import com.ssm.dao.CustomInvocationHandler;&quot; + line
                + &quot;import java.lang.reflect.Method;&quot; + line;
        String classFirstLineContent = &quot;public class $Proxy implements &quot; +interfaceName+ &quot;{&quot; + line;
        String fieldContent = tab + &quot;private  CustomInvocationHandler h;&quot; + line;
        String constructorContent = tab + &quot;public $Proxy (CustomInvocationHandler h){&quot; + line
                + tab + tab + &quot;this.h = h; &quot;+ line
                + tab +&quot;}&quot; + line;
                
        // 参数内容：target.query(p0,p1);
        String paramsContent = &quot;&quot;;
        String methodContent = &quot;&quot;;
        for (Method method : methods){
            // 得到当前方法的返回类型
            String returnType = method.getReturnType().getSimpleName();
            // 得到当前方法的方法名
            String methodName = method.getName();
            // 得到方法的参数类型：如 String.class
            Class[] args = method.getParameterTypes();
            String argsContent = &quot;&quot;;
            for (int i = 0 ; i &lt; args.length ; i++){
                // 得到的是参数类型：如 String
                String temp = args[i].getSimpleName();
                // 最终构造成这个形式：String p0,String p1
                argsContent += temp + &quot; p&quot; + i + &quot;,&quot;;
                paramsContent += &quot;p&quot; + i + &quot;,&quot;;
            }
            // 截取掉最后一个多余的 ','
            if(argsContent.length() &gt; 0){
                argsContent = argsContent.substring(0,argsContent.lastIndexOf(&quot;,&quot;));
                paramsContent = paramsContent.substring(0,paramsContent.lastIndexOf(&quot;,&quot;));
            }
            methodContent += tab + &quot;public &quot; + returnType + &quot; &quot; + methodName + &quot;(&quot; + argsContent + &quot;) throws Exception {&quot; + line
                    + tab + tab + &quot;Method method = Class.forName(\&quot;&quot; + targetInterface.getName() + &quot;\&quot;).getDeclaredMethod(\&quot;&quot; + methodName + &quot;\&quot;);&quot; + line
                    + tab + tab + &quot;return (&quot;+ returnType +&quot;)h.invoke(method);&quot; + line
                    + tab + &quot;}&quot; + line;
        }

        content = packageContent + importContent + classFirstLineContent + fieldContent + constructorContent + methodContent + &quot;}&quot;;

        File file = new File(&quot;C:\\Users\\Only\\com\\ssm\\$Proxy.java&quot;);
        if(!file.exists()){
            file.createNewFile();
        }
        FileWriter fw = new FileWriter(file);
        fw.write(content);
        fw.flush();
        fw.close();

        // .java ---&gt; .class
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null);
        Iterable units = fileMgr.getJavaFileObjects(file);
        JavaCompiler.CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units);
        t.call();
        fileMgr.close();

        // 通过反射得到构造函数 new 一个对象出来
        URL[] urls = new URL[]{new URL(&quot;file:C:\\Users\\Only\\\\&quot;)};
        URLClassLoader urlClassLoader = new URLClassLoader(urls);
        Class clazz = urlClassLoader.loadClass(&quot;com.ssm.$Proxy&quot;);
        Constructor constructor = clazz.getConstructor(CustomInvocationHandler.class);
        proxy = constructor.newInstance(h);

        return proxy;
    }
}
</code></pre>
<h3 id="5测试类">5.测试类</h3>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws Exception {
//         自定义动态代理
        TestDao proxy = (TestDao) ProxyUtil.newInstance(TestDao.class, new TestCustomHandler(new TestDaoImpl()));
        proxy.delete();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-java">TestCustomHandler...
dao...delete
</code></pre>
<h2 id="jdk动态代理">JDK动态代理</h2>
<p>通过接口反射得到字节码 byte[] ，然后把字节码转成 class：native方法  openJDK  c++</p>
<h3 id="1要代理的接口-2">1.要代理的接口</h3>
<pre><code class="language-java">public interface TestDao {
    String query(String s1, String s2) throws Exception;
}
</code></pre>
<h3 id="2目标对象-2">2.目标对象</h3>
<pre><code class="language-java">public class TestDaoImpl implements TestDao {
    @Override
    public String query(String s1, String s2) {
        System.out.println(&quot;查询数据库&quot;);
        System.out.println(&quot;daoImpl...&quot; + s1 + &quot; &quot; + s2);
        return s1 + &quot; &quot; + s2;
    } 
}
</code></pre>
<h3 id="3代理的逻辑">3.代理的逻辑</h3>
<pre><code class="language-java">package com.ssm.util;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class TestInvocationHandler implements InvocationHandler {
    Object target;

    /**
     *
     * @param target 目标对象
     */
    public TestInvocationHandler(Object target){
        this.target = target;
    }
    /**
     *
     * @param proxy 代理对象 $Proxy
     * @param method 目标对象 TestDao
     * @param args 目标方法的参数
     * @return
     * @throws Throwable
     *
     * 根据代理的逻辑执行：即打印 TestInvocationHandler...proxy
     * 执行目标对象的方法 ，即 TestDao 的 query()
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;TestInvocationHandler...proxy&quot;);
        return method.invoke(target,args);
    }
}
</code></pre>
<h3 id="4测试类-2">4.测试类</h3>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws Exception {

        /**
         * JDK 动态代理
         * 参数：要代理哪些接口；new Class[]{TestDao.class}：TestDao 下所有方法的代理。
         *       代理的逻辑：new TestInvocationHandler(new TestDaoImpl())：在每个方法前打印 TestInvocationHandler...proxy
         */
        TestDao jdkProxy = (TestDao) Proxy.newProxyInstance(Test.class.getClassLoader(),
                new Class[]{TestDao.class},
                new TestInvocationHandler(new TestDaoImpl()));
        String result = jdkProxy.query(&quot;hello&quot;, &quot;world&quot;);
        System.out.println(&quot;result = &quot; + result);

    }
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-java">TestInvocationHandler...proxy
查询数据库
daoImpl...hello world
result = hello world
</code></pre>
<h3 id="jdk-动态代理分析">JDK 动态代理分析</h3>
<p>JDK 动态代理：</p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1.png" alt="图片" loading="lazy"></figure>
<p>自定义动态代理：</p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1.png" alt="图片" loading="lazy"></figure>
<h4 id="代理类">代理类</h4>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E4%BB%A3%E7%90%86%E7%B1%BB.png" alt="图片" loading="lazy"></figure>
<h4 id="得到代理类的构造方法">得到代理类的构造方法</h4>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/%E5%BE%97%E5%88%B0%E4%BB%A3%E7%90%86%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png" alt="图片" loading="lazy"></figure>
<h4 id="使用代理类的构造方法-new-一个对象出来">使用代理类的构造方法 new 一个对象出来</h4>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95new%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%87%BA%E6%9D%A5.png" alt="图片" loading="lazy"></figure>
<h4 id="class-cl-getproxyclass0loader-intfs">Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</h4>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/getProxyClass0.png" alt="图片" loading="lazy"></figure>
<h4 id="public-v-getk-key-p-parameter">public V get(K key, P parameter) {</h4>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/get.png" alt="图片" loading="lazy"></figure>
<h4 id="debugger">debugger</h4>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/debugger.png" alt="图片" loading="lazy"></figure>
<h4 id="v-value-supplierget">V value = supplier.get();</h4>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/suppiler.get.png" alt="图片" loading="lazy"></figure>
<h4 id="public-synchronized-v-get">public synchronized V get() {</h4>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/%E8%BF%94%E5%9B%9Evalue.png" alt="图片" loading="lazy"></figure>
<h4 id="value-objectsrequirenonnullvaluefactoryapplykey-parameter">value = Objects.requireNonNull(valueFactory.apply(key, parameter))</h4>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/requireNonNull.png" alt="图片" loading="lazy"></figure>
<h4 id="public-class-applyclassloader-loader-class-interfaces">public Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {</h4>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/apply.png" alt="图片" loading="lazy"></figure>
<h4 id="使用类加载器判断是否是同一个对象">使用类加载器判断是否是同一个对象</h4>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1.png" alt="图片" loading="lazy"></figure>
<h4 id="判断接口的权限修饰符">判断接口的权限修饰符</h4>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/%E5%88%A4%E6%96%AD%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6.png" alt="图片" loading="lazy"></figure>
<h4 id="string-proxyname-proxypkg-proxyclassnameprefix-num">String proxyName = proxyPkg + proxyClassNamePrefix + num;</h4>
<figure data-type="image" tabindex="16"><img src="https://epitomm.github.io/post-images/proxyName.png" alt="图片" loading="lazy"></figure>
<p>类名加上标识0，是为了防止并发情况下产生问题。</p>
<h4 id="byte-proxyclassfile-proxygeneratorgenerateproxyclassproxyname-interfaces-accessflags">byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</h4>
<figure data-type="image" tabindex="17"><img src="https://epitomm.github.io/post-images/generateProxyClass.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="18"><img src="https://epitomm.github.io/post-images/JDK%E4%BB%A3%E7%90%86%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring系列（二）SpringAOP 应用]]></title>
        <id>https://epitomm.github.io/post/springaop-ying-yong/</id>
        <link href="https://epitomm.github.io/post/springaop-ying-yong/">
        </link>
        <updated>2020-05-02T07:55:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="自定义注解">自定义注解</h1>
<h2 id="xml-的作用">xml 的作用？</h2>
<p>答：<strong>描述数据</strong>。<br>
举例：数据库中有一张 user 表，项目中有一个 User 类，如何将 User 类与 user 表<strong>关联</strong>？<br>
答：使用 xml 来描述元数据。<br>
那为什么还要有自定义注解呢？因为xml 开发过程过于复杂。</p>
<h2 id="自定义注解-2">自定义注解</h2>
<h3 id="一-准备阶段">一、准备阶段</h3>
<h4 id="1定义实体类">1.定义实体类</h4>
<pre><code class="language-java">package com.ssm.entity;

import com.ssm.anno.Entity;

public class CityEntity {

    private Integer id;
    private String name;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
</code></pre>
<h4 id="2定义工具类">2.定义工具类</h4>
<pre><code class="language-java">package com.ssm.util;

public class CommonUtil {
    /**
     * 通过一个对象构建一条查询的 sql 语句
     * @param obj
     */
    public static String buildQuerySqlForEntity(Object obj){

        // 表名、字段应该根据传入的值动态变化，不应该写死
        // 办法：在实体类 CityEntity 中加入注解 @Table（需要导入JPA），我们使用自定义注解来实现
        String sql = &quot;select * from ? where id=? and name=?&quot;;

        return null;
    }
}
</code></pre>
<h4 id="3测试方法">3.测试方法</h4>
<pre><code class="language-java">package com.ssm.util;

public class CommonUtil {
    /**
     * 通过一个对象构建一条查询的 sql 语句
     * @param obj
     */
    public static String buildQuerySqlForEntity(Object obj){

        // 表名、字段应该根据传入的值动态变化，不应该写死
        // 办法：在实体类 CityEntity 中加入注解 @Table（需要导入JPA），我们使用自定义注解来实现
        String sql = &quot;select * from ? where id=? and name=?&quot;;

        return null;
    }
}
</code></pre>
<h3 id="二-自定义注解基本功能">二、自定义注解——基本功能</h3>
<h4 id="1自定义注解">1.自定义注解</h4>
<pre><code class="language-java">public @interface Entity {
    public String value();
}
</code></pre>
<h4 id="2实体类添加注解">2.实体类添加注解</h4>
<pre><code class="language-java">// 注解里面的 value 方法，返回值是 String 类型
@Entity(value = &quot;city&quot;)
public class CityEntity {
</code></pre>
<h3 id="三-自定义注解元注解">三、自定义注解——元注解</h3>
<h4 id="1实体类体会元注解">1.实体类体会元注解</h4>
<pre><code class="language-java">//@Override   
// @Override' not applicable to type：@Override 不适用修饰类
public class CityEntity {

// @Override   
// Method does not override method from its superclass：没有父类重写的方法。表名 @Override 注解可用于修饰方法
    public void setId(Integer id) {
        this.id = id;
    }    
</code></pre>
<p>分析得知：@Override 注解可用于修饰方法，不可用于修饰类。<br>
于是我们来改动一下我们的自定义注解 @Entity，让它只能用于修饰类，不能用于修饰方法。</p>
<h4 id="2修改自定义注解类">2.修改自定义注解类</h4>
<pre><code class="language-java">// @Entity 注解能够出现的目标位置：TYPE：类
@Target(ElementType.TYPE)
// @Target({ElementType.TYPE, ElementType.FIELD})：指定多个可以出现的位置：类、
public @interface Entity {
    public String value();
}
</code></pre>
<h3 id="四-获得注解内的值">四、获得注解内的值</h3>
<pre><code class="language-java">package com.ssm.util;

import com.ssm.anno.Entity;

import java.lang.annotation.Annotation;

public class CommonUtil {
    public static String buildQuerySqlForEntity(Object obj){
        // 得到类的类对象
        Class clazz = obj.getClass();
        // setup1 判断是否加了这个注解
        if(clazz.isAnnotationPresent(Entity.class)){
            // setup2 得到注解
            Entity entity = (Entity) clazz.getDeclaredAnnotation(Entity.class);
            // setup3 调用方法
            String value = entity.value();
            System.out.println(value);  // city
        }

        // 表名、字段应该根据传入的值动态变化，不应该写死
        // 办法：在实体类 CityEntity 中加入注解 @Table（需要导入JPA），我们使用自定义注解来实现
        String sql = &quot;select * from ? where id=? and name=?&quot;;

        return null;
    }
}
</code></pre>
<h2 id="注解生命周期">注解生命周期</h2>
<h3 id="retentionretentionpolicysource">@Retention(RetentionPolicy.SOURCE)</h3>
<p>注解的生命周期：默认情况下仅仅存在于 Java 源码中，即@Retention(RetentionPolicy.SOURCE)，当 JVM 一旦把它编译成字节码，注解会自动丢失。<br>
<img src="https://epitomm.github.io/post-images/%E6%B3%A8%E8%A7%A3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9FSOURCE.png" alt="图片" loading="lazy"></p>
<h3 id="retentionretentionpolicyclass">@Retention(RetentionPolicy.CLASS)</h3>
<p>会存在于 .class 文件中，但是在代码被运行时还是会被 JVM 忽略。<br>
<img src="https://epitomm.github.io/post-images/%E6%B3%A8%E8%A7%A3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9FCLASS.png" alt="图片" loading="lazy"><br>
测试：</p>
<pre><code class="language-java">package com.ssm.util;

import com.ssm.anno.Entity;

public class CommonUtil {

    public static String buildQuerySqlForEntity(Object obj){
        // 得到类的类对象
        Class clazz = obj.getClass();
        // setup1 判断是否加了这个注解
        boolean b = clazz.isAnnotationPresent(Entity.class); // false
        System.out.println(b);

        return null;
    }
}
</code></pre>
<h3 id="retentionretentionpolicyruntime">@Retention(RetentionPolicy.RUNTIME)</h3>
<p>只有当注解的生命周期声明为 RUNTIME 时，在执行时才会被 JVM 发觉到。<br>
boolean b = clazz.isAnnotationPresent(Entity.class);//true</p>
<h1 id="aop-是什么">AOP 是什么</h1>
<p>与OOP对比，面向切面，传统的OOP开发中的代码逻辑是自上而下的，而这些过程会产生一些横切性问题，这些横切性的问题和我们的主业务逻辑关系不大，这些横切性问题不会影响到主逻辑实现的，但是会散落到代码的各个部分，难以维护。AOP是处理一些横切性问题，AOP的编程思想就是把这些问题和主业务逻辑分开，达到与主业务逻辑解耦的目的。使代码的重用性和开发效率更高。<br>
<img src="https://epitomm.github.io/post-images/AOP%E6%98%AF%E4%BB%80%E4%B9%88.png" alt="图片" loading="lazy"></p>
<h2 id="aop-的应用场景">AOP 的应用场景</h2>
<ol>
<li>日志记录</li>
<li>权限验证</li>
<li>效率检查</li>
<li>事务管理</li>
<li>exception</li>
</ol>
<h2 id="springaop-的底层技术">SpringAOP 的底层技术</h2>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">JDK动态代理</th>
<th style="text-align:center">CGLIB代理</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">编译时期的织入还是运行时期的织入?</td>
<td style="text-align:center">运行时期织入</td>
<td style="text-align:center">运行时期织入</td>
</tr>
<tr>
<td style="text-align:center">初始化时期织入还是获取对象时期织入？</td>
<td style="text-align:center">初始化时期织入</td>
<td style="text-align:center">初始化时期织入</td>
</tr>
</tbody>
</table>
<h2 id="springaop-和-aspectj-的关系">SpringAOP 和 AspectJ 的关系</h2>
<p>AOP 是一种概念<br>
SpringAOP、AspectJ 都是 AOP 的实现，SpringAOP 有自己的语法，但是语法复杂，所以SpringAOP 借助了AspectJ 的注解，但是底层实现还是自己的<br>
AspectJ 是静态注入：编译（.java -&gt; .class）时就完成了注入，SpringAOP是动态注入：运行时才注入</p>
<pre><code>spring AOP提供两种编程风格
@AspectJ support         ------------&gt;利用aspectj的注解
Schema-based AOP support -----------&gt;xml aop:config 命名空间

证明:spring,通过源  码分析了,我们可以知道spring底层使用的是JDK或者CGLIB来完成的代理,并且在官网上spring给出了aspectj的文档,和springAOP是不同的
</code></pre>
<p>如果您只需要建议在Spring bean上执行操作，那么Spring AOP是正确的选择。如果需要通知Spring容器没有管理的对象(通常是域对象)，则需要使用AspectJ。<br>
Spring AOP的概念<br>
参考链接：<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-introduction-defn">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-introduction-defn</a></p>
<ul>
<li>aspect:一定要给spring去管理  抽象  aspectj-&gt;类</li>
<li>pointcut:切点表示连接点的集合  -----------------&gt;   表 （我的理解：PointCut是JoinPoint的谓语，这是一个动作，主要是告诉通知连接点在哪里，切点表达式决定 JoinPoint 的数量）</li>
<li>Joinpoint:连接点   目标对象中的方法 ----------------&gt;    记录（我的理解：JoinPoint是要关注和增强的方法，也就是我们要作用的点）</li>
<li>Weaving :把代理逻辑加入到目标对象上的过程叫做织入</li>
<li>target 目标对象 原始对象</li>
<li>aop Proxy 代理对象  包含了原始对象的代码和增加后的代码的那个对象</li>
<li>advice:通知    (位置 + logic)</li>
</ul>
<h2 id="aspect-切面">Aspect 切面</h2>
<blockquote>
<p>Aspect: A modularization of a concern that cuts across multiple classes. Transaction management is a good example of a crosscutting concern in enterprise Java applications. In Spring AOP, aspects are implemented by using regular classes (the schema-based approach) or regular classes annotated with the @Aspect annotation (the @AspectJ style).</p>
</blockquote>
<p>切面是：通知、切点、连接点的载体。通知、连接点要放到哪里去，好比 Java 中的属性、方法、构造方法，这些东西要放到哪里去？放到一个类里面，这个类就是方法以及参数属性的载体。切面就是连接点、切点、通知的载体，把这些连接点、切点、通知所在的位置称之为一个切面。</p>
<h2 id="join-point-连接点">Join point 连接点</h2>
<blockquote>
<p>Join point: A point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution.</p>
</blockquote>
<p>连接点：程序执行过程中的一个点，如方法的执行或异常的处理。在Spring AOP中，连接点总是表示方法执行。<br>
<img src="https://epitomm.github.io/post-images/AOP%E8%BF%9E%E6%8E%A5%E7%82%B9.png" alt="图片" loading="lazy"><br>
ProceedingJoinPoint 和 JoinPoint 的区别:<br>
ProceedingJoinPoint  继承了JoinPoint ,proceed()这个是aop代理链执行的方法。并扩充实现了proceed()方法，用于继续执行连接点。JoinPoint 仅能获取相关参数，无法执行连接点。<br>
JoinPoint 的方法：</p>
<ol>
<li>java.lang.Object[] getArgs()：获取连接点方法运行时的入参列表；</li>
<li>Signature getSignature() ：获取连接点的方法签名对象；</li>
<li>java.lang.Object getTarget() ：获取连接点所在的目标对象；</li>
<li>java.lang.Object getThis() ：获取代理对象本身；<br>
proceed()有重载,有个带参数的方法,可以修改目标方法的的参数</li>
</ol>
<p>Advice 通知<br>
Advice: Action taken by an aspect at a particular join point. Different types of advice include “around”, “before” and “after” advice. (Advice types are discussed later.) Many AOP frameworks, including Spring, model an advice as an interceptor and maintain a chain of interceptors around the join point.<br>
<img src="https://epitomm.github.io/post-images/AOP%E9%80%9A%E7%9F%A5.png" alt="图片" loading="lazy"></p>
<ul>
<li>advice通知类型:</li>
<li>Before 连接点执行之前，但是无法阻止连接点的正常执行，除非该段执行抛出异常</li>
<li>After  连接点正常执行之后，执行过程中正常执行返回退出，非异常退出</li>
<li>After throwing  执行抛出异常的时候</li>
<li>After (finally)  无论连接点是正常退出还是异常退出，都会执行</li>
<li>Around advice: 围绕连接点执行，例如方法调用。这是最有用的切面方式。around通知可以在方法调用之前和之后执行自定义行为。它还负责选择是继续加入点还是通过返回自己的返回值或抛出异常来快速建议的方法执行。</li>
</ul>
<h3 id="after">After</h3>
<pre><code class="language-java">@After(&quot;pointCutTarget()&quot;)
public void after(){
    System.out.println(&quot;after&quot;);
}
</code></pre>
<h3 id="before">Before</h3>
<pre><code class="language-java">@Before(&quot;pointCut()&quot;)
public void before(JoinPoint joinPoint){
    System.out.println(&quot;before&quot;);
    System.out.println(joinPoint.getThis());
    System.out.println(joinPoint.getTarget());
}
</code></pre>
<p>断点调试：<br>
1、joinPoint.getThis()<br>
<img src="https://epitomm.github.io/post-images/%E8%BF%9E%E6%8E%A5%E7%82%B9%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_1.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/%E8%BF%9E%E6%8E%A5%E7%82%B9%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_2.png" alt="图片" loading="lazy"><br>
2、joinPoint.getTarget()<br>
<img src="https://epitomm.github.io/post-images/%E8%BF%9E%E6%8E%A5%E7%82%B9%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_3.png" alt="图片" loading="lazy"></p>
<h3 id="around">Around</h3>
<p>在通知中拿到连接点，然后执行连接点。</p>
<pre><code class="language-java">@Around(&quot;pointCut()&quot;)
// ProceedingJoinPoint：正在进行的 JointPoint：正在增强的方法
public void around(ProceedingJoinPoint pjp) throws Throwable {
    System.out.println(&quot;around...before&quot;);
    // 拿到方法并执行它
    pjp.proceed();
    System.out.println(&quot;around...after&quot;);
}
</code></pre>
<p>测试结果：</p>
<pre><code>around...before
query
around...after
</code></pre>
<h3 id="xml-通知">XML 通知</h3>
<p>1、编写 xml，定义切面、连接点、通知</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                         http://www.springframework.org/schema/beans/spring-beans.xsd
                         http://www.springframework.org/schema/aop
                         http://www.springframework.org/schema/aop/spring-aop.xsd
                         http://www.springframework.org/schema/context
                         http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:component-scan base-package=&quot;com.ssm&quot;/&gt;
    &lt;!-- 定义一个切面 --&gt;
    &lt;aop:config&gt;
        &lt;!-- 定义一个连接点 --&gt;
        &lt;aop:pointcut id=&quot;allDao&quot; expression=&quot;execution(* com.ssm.dao.*.*(..))&quot;/&gt;
        &lt;!-- 通知包含两部分：位置 pointcut-ref 、逻辑 ref --&gt;
        &lt;aop:aspect id=&quot;aspect&quot; ref=&quot;xmlBean&quot;&gt;
            &lt;aop:before pointcut-ref=&quot;allDao&quot;
                    method=&quot;before&quot;/&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;

    &lt;bean id=&quot;xmlBean&quot; class=&quot;com.ssm.app.XMLAopBean&quot;/&gt;
    &lt;bean id=&quot;indexDao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p>2、编写通知的逻辑</p>
<pre><code class="language-java">public class XMLAopBean {
    public void before(){
        System.out.println(&quot;xml before...&quot;);
    }
}
</code></pre>
<p>3、测试</p>
<pre><code class="language-java">public class TestXML {
    public static void main(String[] args) throws IOException {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
        IndexDao dao = (IndexDao) context.getBean(&quot;indexDao&quot;);
        dao.query(&quot;hello&quot;);
    }
}
</code></pre>
<p>4、运行结果</p>
<pre><code>xml before...
query
hello
</code></pre>
<h4 id="环绕通知中改变参数值">环绕通知中改变参数值</h4>
<p>1、传递进来的参数为 &quot;hello&quot;</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws IOException {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        IndexDao dao = (IndexDao) context.getBean(&quot;indexDao&quot;);
        dao.query(&quot;hello&quot;);
    }
}
</code></pre>
<p>2、在环绕通知内将参数修改为  hello  world</p>
<pre><code class="language-java">@Around(&quot;pointCut()&quot;)
// ProceedingJoinPoint：正在进行的 JointPoint：正在增强的方法 
public void around(ProceedingJoinPoint pjp) throws Throwable {
    Object[] args = pjp.getArgs();
    if(args != null &amp;&amp; args.length &gt; 0){
        for (int i = 0; i &lt; args.length; i++) {
            args[i] += &quot; world&quot;;
        }
    }
    System.out.println(&quot;around...before&quot;);
    // 拿到方法并执行它
    pjp.proceed(args);
    System.out.println(&quot;around...after&quot;);
}
</code></pre>
<p>3、输出参数值</p>
<pre><code class="language-java">@Repository(&quot;indexDao&quot;)
public class IndexDaoImpl implements IndexDao {
    @Override
    public void query(String str){
        System.out.println(&quot;query&quot;);
        System.out.println(str);
    }
}
</code></pre>
<p>4、输出结果：</p>
<pre><code>around...before
query
hello world
around...after
</code></pre>
<h2 id="pointcut-切点">Pointcut 切点</h2>
<blockquote>
<p>Pointcut: A predicate that matches join points. Advice is associated with a pointcut expression and runs at any join point matched by the pointcut (for example, the execution of a method with a certain name). The concept of join points as matched by pointcut expressions is central to AOP, and Spring uses the AspectJ pointcut expression language by default.</p>
</blockquote>
<p>切点：连接点的集合。<br>
<img src="https://epitomm.github.io/post-images/AOP%E5%88%87%E7%82%B9.png" alt="图片" loading="lazy"></p>
<h2 id="introduction">Introduction</h2>
<blockquote>
<p>Introduction: Declaring additional methods or fields on behalf of a type. Spring AOP lets you introduce new interfaces (and a corresponding implementation) to any advised object. For example, you could use an introduction to make a bean implement an IsModified interface, to simplify caching. (An introduction is known as an inter-type declaration in the AspectJ community.)</p>
</blockquote>
<h3 id="实例">实例</h3>
<p>1、准备一个 IndexDao 接口</p>
<pre><code class="language-java">public interface IndexDao {
    void query(String str);
}
</code></pre>
<p>2、准备一个 IndexDao 接口的实现类</p>
<pre><code class="language-java">@Repository(&quot;indexDao&quot;)
public class IndexDaoImpl implements IndexDao {
    @Override
    public void query(String str){
        System.out.println(&quot;query&quot;);
        System.out.println(str);
    }
}
</code></pre>
<p>3、再准备一个接口 OrderDAO，并把它注入到 Spring 容器中</p>
<pre><code class="language-java">@Repository(&quot;orderDao&quot;)
public class OrderDao {
}
</code></pre>
<p>4、引入</p>
<pre><code class="language-java">@Component
// 切面
@Aspect
public class NotVeryUsefulAspect {
     // 找到 com.ssm.dao 下的所有类，让它引入 IndexDao 接口的 IndexDaoImpl 实现，
    // 即让 class OrderDao implements IndexDao，并且方法的具体实现与 IndexDaoImpl 相同
    @DeclareParents(value=&quot;com.ssm.dao.*&quot;, defaultImpl= IndexDaoImpl.class)
    public static IndexDao indexDao;
}
</code></pre>
<p>5、测试</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws IOException {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        IndexDao dao = (IndexDao) context.getBean(&quot;orderDao&quot;);
        dao.query(&quot;hello&quot;);
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>query
hello
</code></pre>
<p>6、分析：orderDao 内并没有方法，但是获得容器内的 OrderDao 对象后却可以正常调用  query() 方法，原因就是使用了 Introduction。</p>
<h2 id="aspect-instantiation-models">Aspect Instantiation Models</h2>
<p>使用方式如下：<br>
@Aspect(&quot;perthis(this(com.chenss.dao.IndexDaoImpl))&quot;)<br>
要求：</p>
<ol>
<li>AspectJ对象的注入类型为prototype</li>
<li>目标对象也必须是prototype的<br>
原因为：只有目标对象是原型模式的，每次getBean得到的对象才是不一样的，由此针对每个对象就会产生新的切面对象，才能产生不同的切面结果。</li>
</ol>
<h3 id="示例">示例</h3>
<p>1、多例的 IndexDaoImpl</p>
<pre><code class="language-java">@Repository(&quot;indexDao&quot;)
@Scope(&quot;prototype&quot;)
public class IndexDaoImpl implements IndexDao {
</code></pre>
<p>2、单例的切面</p>
<pre><code class="language-java">@Component
@Aspect
public class NotVeryUsefulAspect {
    // 切点 com.ssm.dao 下的子包下的任意类的任意方法 任意返回值 任意修饰符
    @Pointcut(&quot;execution(* com.ssm.dao.*.*(..))&quot;)
    public void pointCut(){
    }

    @Around(&quot;pointCut()&quot;)
    // ProceedingJoinPoint：正在进行的 JointPoint：正在增强的方法
    public void around(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println(&quot;this.hashCode = &quot; + this.hashCode());
        Object[] args = pjp.getArgs();
        if(args != null &amp;&amp; args.length &gt; 0){
            for (int i = 0; i &lt; args.length; i++) {
                args[i] += &quot; world&quot;;
            }
        }
        System.out.println(&quot;around...before&quot;);
        // 拿到方法并执行它
        pjp.proceed(args);
        System.out.println(&quot;around...after&quot;);
    }
}
</code></pre>
<p>3、测试类</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws IOException {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        IndexDao dao = (IndexDao) context.getBean(&quot;indexDao&quot;);
        IndexDao dao1 = (IndexDao) context.getBean(&quot;indexDao&quot;);
        // com.ssm.dao.impl.IndexDaoImpl@24aed80c : com.ssm.dao.impl.IndexDaoImpl@3a52dba3
        System.out.println(dao+&quot; : &quot;+dao1);
        dao.query(&quot;hello&quot;);
        System.out.println(&quot; - - - - - - - - - - - &quot;);
        dao1.query(&quot;hi&quot;);
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>com.ssm.dao.impl.IndexDaoImpl@24aed80c : com.ssm.dao.impl.IndexDaoImpl@3a52dba3
this.hashCode = 1792550665
around...before
query
hello world
around...after
 - - - - - - - - - - - 
this.hashCode = 1792550665
around...before
query
hi world
around...after
</code></pre>
<p>4、分析：<br>
当 IndexDaoImpl 设置为原型时，两次 context.getBean(&quot;indexDaoImpl&quot;) 得到的 IndexDaoImpl 是不同的对象。但是不同的 bean 对象得到的切面却是完全相同的。</p>
<p>更改：AspectJ 对象的注入类型为 prototype，为所有代理对象是 IndexDaoImpl 的单独创建一个切点出来</p>
<pre><code class="language-java">@Component
// 为所有代理对象是 IndexDaoImpl 的单独创建一个切点出来
@Aspect(&quot;perthis(this(com.ssm.dao.impl.IndexDaoImpl))&quot;)
@Scope(&quot;prototype&quot;)
public class NotVeryUsefulAspect {
</code></pre>
<p>CJLIB 动态代理</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
// 开启 AspectJ 语法支持
@EnableAspectJAutoProxy(proxyTargetClass=true)
public class AppConfig {
}
</code></pre>
<p>运行结果：</p>
<pre><code>com.ssm.dao.impl.IndexDaoImpl@672872e1 : com.ssm.dao.impl.IndexDaoImpl@32910148
this.hashCode = 254801937
around...before
query
hello world
around...after
 - - - - - - - - - - - 
this.hashCode = 90767234
around...before
query
hi world
around...after
</code></pre>
<h2 id="target-object目标对象">Target object：目标对象</h2>
<blockquote>
<p>Target object: An object being advised by one or more aspects. Also referred to as the “advised object”. Since Spring AOP is implemented by using runtime proxies, this object is always a proxied object.</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/AOP%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1.png" alt="图片" loading="lazy"></figure>
<h2 id="aop-proxy-代理对象">AOP proxy 代理对象</h2>
<blockquote>
<p>AOP proxy: An object created by the AOP framework in order to implement the aspect contracts (advise method executions and so on). In the Spring Framework, an AOP proxy is a JDK dynamic proxy or a CGLIB proxy.</p>
</blockquote>
<h2 id="weaving">Weaving</h2>
<blockquote>
<p>Weaving: linking aspects with other application types or objects to create an advised object. This can be done at compile time (using the AspectJ compiler, for example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks, performs weaving at runtime.</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/AOP%E7%BB%87%E5%85%A5.png" alt="图片" loading="lazy"></figure>
<h1 id="springaop-支持-aspectj">SpringAOP 支持 AspectJ</h1>
<p>AOP 和 SpringAOP 的 关系？SpringAOP 是 AOP 的一种实现。<br>
实现 AOP 的技术：AspectJ、SpringAOP<br>
SpringAOP 和 AspectJ 的关系？Spring 原先版本的 AOP 语法过于繁琐，于是 Spring 借助了 AspectJ 的语法，底层技术还是用的 Spring 底层的技术。<br>
参考资料：<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-ataspectj">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-ataspectj</a></p>
<h2 id="0-导入-spring-依赖">0、导入 Spring 依赖</h2>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
  &lt;version&gt;5.0.9.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>准备一个 IndexDao：</p>
<pre><code class="language-java">@Repository
public class IndexDao {
    public void query(){
        System.out.println(&quot;query&quot;);
    }
}
</code></pre>
<h2 id="1-启用aspectj支持">1、启用@AspectJ支持</h2>
<p>使用Java Configuration启用@AspectJ支持<br>
要使用Java @Configuration启用@AspectJ支持，请添加@EnableAspectJAutoProxy注释</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
@EnableAspectJAutoProxy
public class AppConfig {

}
</code></pre>
<p>使用XML配置启用@AspectJ支持<br>
要使用基于xml的配置启用@AspectJ支持，可以使用aop:aspectj-autoproxy元素</p>
<pre><code class="language-xml">&lt;aop:aspectj-autoproxy/&gt;
</code></pre>
<h2 id="2-声明一个aspect">2、声明一个Aspect</h2>
<p>引入 Aspect 依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
  &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
  &lt;version&gt;1.9.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>声明一个@Aspect注释类，并且定义成一个bean交给Spring管理。</p>
<pre><code class="language-java">@Component
@Aspect
public class UserAspect {
}
</code></pre>
<h2 id="3-声明一个pointcut">3、声明一个PointCut</h2>
<p>切入点表达式由@Pointcut注释表示。切入点声明由两部分组成:一个签名包含名称和任何参数，以及一个切入点表达式，该表达式确定我们对哪个方法执行感兴趣。</p>
<pre><code class="language-java">@Pointcut(&quot;execution(* transfer(..))&quot;)// 切入点表达式
private void anyOldTransfer() {}// 切入点签名
</code></pre>
<p>切入点确定感兴趣的 join points（连接点），从而使我们能够控制何时执行通知。Spring AOP只支持Spring bean的方法执行 join points（连接点），所以您可以将切入点看作是匹配Spring bean上方法的执行。</p>
<pre><code class="language-java">/**
 * 申明Aspect，并且交给spring容器管理
 */
@Component
@Aspect
public class UserAspect {
    /**
     * 申明切入点，匹配UserDao所有方法调用
     * execution匹配方法执行连接点
     * within:将匹配限制为特定类型中的连接点
     * args：参数
     * target：目标对象
     * this：代理对象
     */
    @Pointcut(&quot;execution(* com.yao.dao.UserDao.*(..))&quot;)
    public void pintCut(){
        System.out.println(&quot;point cut&quot;);
    }
</code></pre>
<h2 id="4-声明一个advice通知">4、声明一个Advice通知</h2>
<p>advice通知与pointcut切入点表达式相关联，并在切入点匹配的方法执行@Before之前、@After之后或前后运行。</p>
<pre><code class="language-java">/**
 * 申明Aspect，并且交给spring容器管理
 */
@Component
@Aspect
public class UserAspect {
    /**
     * 申明切入点，匹配UserDao所有方法调用
     * execution匹配方法执行连接点
     * within:将匹配限制为特定类型中的连接点
     * args：参数
     * target：目标对象
     * this：代理对象
     */
    @Pointcut(&quot;execution(* com.yao.dao.UserDao.*(..))&quot;)
    public void pintCut(){
        System.out.println(&quot;point cut&quot;);
    }
    /**
     * 申明before通知,在pintCut切入点前执行
     * 通知与切入点表达式相关联，
     * 并在切入点匹配的方法执行之前、之后或前后运行。
     * 切入点表达式可以是对指定切入点的简单引用，也可以是在适当位置声明的切入点表达式。
     */
    @Before(&quot;com.yao.aop.UserAspect.pintCut()&quot;)
    public void beforeAdvice(){
        System.out.println(&quot;before&quot;);
    }
}
</code></pre>
<p>测试类：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        IndexDao dao = context.getBean(IndexDao.class);
        dao.query();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>before
query
</code></pre>
<h1 id="各种连接点-joinpoint-的意义">各种连接点 JoinPoint 的意义:</h1>
<h2 id="execution">execution</h2>
<p>用于匹配方法执行连接点，最小粒度方法，在aop中主要使用。</p>
<pre><code class="language-java">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern)
          throws-pattern?)
</code></pre>
<p>这里问号表示当前项可以有也可以没有，其中各项的语义如下：<br>
modifiers-pattern：方法的可见性，如public，protected；<br>
ret-type-pattern：方法的返回值类型，如int，void等；<br>
declaring-type-pattern：方法所在类的全路径名，如com.spring.Aspect；<br>
name-pattern：方法名类型，如 buisinessService()；<br>
param-pattern：方法的参数类型，如java.lang.String；<br>
throws-pattern：方法抛出的异常类型，如java.lang.Exception；</p>
<h3 id="examples">Examples</h3>
<p>@Pointcut(&quot;execution(* com.chenss.dao.<em>.</em>(..))&quot;)//匹配com.chenss.dao包下的任意接口和类的任意方法【方法返回值类型任意，方法所在类的全路径名：com.chenss.dao，方法名类型任意，方法的参数类型任意】<br>
@Pointcut(&quot;execution(public * com.chenss.dao.<em>.</em>(..))&quot;)//匹配com.chenss.dao包下的任意接口和类的public方法<br>
@Pointcut(&quot;execution(public * com.chenss.dao.<em>.</em>())&quot;)//匹配com.chenss.dao包下的任意接口和类的public 无方法参数的方法<br>
@Pointcut(&quot;execution(* com.chenss.dao.<em>.</em>(java.lang.String, ..))&quot;)//匹配com.chenss.dao包下的任意接口和类的第一个参数为String类型的方法<br>
@Pointcut(&quot;execution(* com.chenss.dao.<em>.</em>(java.lang.String))&quot;)//匹配com.chenss.dao包下的任意接口和类的只有一个参数，且参数为String类型的方法<br>
@Pointcut(&quot;execution(* com.chenss.dao.<em>.</em>(java.lang.String))&quot;)//匹配com.chenss.dao包下的任意接口和类的只有一个参数，且参数为String类型的方法<br>
@Pointcut(&quot;execution(public * <em>(..))&quot;)//匹配任意的public方法<br>
@Pointcut(&quot;execution(</em> te*(..))&quot;)//匹配任意的以te开头的方法<br>
@Pointcut(&quot;execution(* com.chenss.dao.IndexDao.<em>(..))&quot;)//匹配com.chenss.dao.IndexDao接口中任意的方法<br>
@Pointcut(&quot;execution(</em> com.chenss.dao..<em>.</em>(..))&quot;)//匹配com.chenss.dao包及其子包中任意的方法</p>
<p>关于这个表达式的详细写法,可以脑补也可以参考官网很容易的,可以作为一个看spring官网文档的入门,打破你害怕看官方文档的心理,其实你会发觉官方文档也是很容易的<br>
<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-pointcuts-examples">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-pointcuts-examples</a></p>
<p>由于Spring切面粒度最小是达到方法级别，而execution表达式可以用于明确指定方法返回类型，类名，方法名和参数名等与方法相关的信息，并且在Spring中，大部分需要使用AOP的业务场景也只需要达到方法级别即可，因而execution表达式的使用是最为广泛的。</p>
<h2 id="within">within</h2>
<p>表达式的最小粒度为类<br>
within与execution相比，粒度更大，仅能实现到包和接口、类级别。而execution可以精确到方法的返回值，参数个数、修饰符、参数类型等</p>
<pre><code class="language-java">@Pointcut(&quot;within(com.chenss.dao.*)&quot;)//匹配com.chenss.dao包中的任意方法
@Pointcut(&quot;within(com.chenss.dao..*)&quot;)//匹配com.chenss.dao包及其子包中的任意方法
</code></pre>
<h2 id="args">args</h2>
<blockquote>
<p>args: Limits matching to join points (the execution of methods when using Spring AOP) where the arguments are instances of the given types.</p>
</blockquote>
<p>限制连接点的匹配(使用Spring AOP时方法的执行)，其中的参数是给定类型的实例。<br>
args表达式的作用是匹配指定参数类型和指定参数数量的方法,与包名和类名无关</p>
<pre><code class="language-java">/**
 * args同execution不同的地方在于：
 * args匹配的是运行时传递给方法的参数类型
 * execution(* *(java.io.Serializable))匹配的是方法在声明时指定的方法参数类型。
 */
@Pointcut(&quot;args(java.io.Serializable)&quot;)//匹配运行时传递的参数类型为指定类型的、且参数个数和顺序匹配
@Pointcut(&quot;@args(com.chenss.anno.Chenss)&quot;)//接受一个参数，并且传递的参数的运行时类型具有@Classified
</code></pre>
<h2 id="this">this</h2>
<blockquote>
<p>this: Limits matching to join points (the execution of methods when using Spring AOP) where the bean reference (Spring AOP proxy) is an instance of the given type.</p>
</blockquote>
<p>限制连接点(使用Spring AOP时方法的执行)的匹配，其中bean引用(Spring AOP代理)是给定类型的实例。<br>
<strong>this JDK代理时，指向接口和代理类proxy，cglib代理时 指向接口和子类(不使用proxy)</strong></p>
<h2 id="target">target</h2>
<p>target: Limits matching to join points (the execution of methods when using Spring AOP) where the target object (application object being proxied) is an instance of the given type.<br>
限制对连接点(使用Spring AOP时方法的执行)的匹配，其中目标对象(代理的应用程序对象)是给定类型的实例。<br>
<strong>target  指向接口和子类</strong>。</p>
<pre><code class="language-java">/**
 * 此处需要注意的是，如果配置设置proxyTargetClass=false，或默认为false，则是用JDK代理，否则使用的是CGLIB代理
 * JDK代理的实现方式是基于接口实现，代理类继承Proxy，实现接口。
 * 而CGLIB继承被代理的类来实现。
 * 所以使用target会保证目标不变，关联对象不会受到这个设置的影响。
 * 但是使用this对象时，会根据该选项的设置，判断是否能找到对象。
 */
@Pointcut(&quot;target(com.chenss.dao.IndexDaoImpl)&quot;)//目标对象，也就是被代理的对象。限制目标对象为com.chenss.dao.IndexDaoImpl类
@Pointcut(&quot;this(com.chenss.dao.IndexDaoImpl)&quot;)//当前对象，也就是代理对象，代理对象时通过代理目标对象的方式获取新的对象，与原值并非一个
@Pointcut(&quot;@target(com.chenss.anno.Chenss)&quot;)//具有@Chenss的目标对象中的任意方法
@Pointcut(&quot;@within(com.chenss.anno.Chenss)&quot;)//等同于@targ
</code></pre>
<p>这个比较难.......<br>
proxy模式里面有两个重要的术语<br>
proxy Class<br>
target Class<br>
CGLIB和JDK有区别    JDK是基于接口   cglib是基于继承，所有this可以在cglib作用</p>
<h2 id="annotation">@annotation</h2>
<p>这个很简单........<br>
作用<strong>方法</strong>级别<br>
上述所有表达式都有@ 比如@Target(里面是一个注解类xx,表示所有加了xx注解的类,和包名无关)<br>
注意:上述所有的表达式可以混合使用,|| &amp;&amp; !</p>
<pre><code class="language-java">@Before(&quot;pointCutWithin()&amp;&amp;!pointCutArgs()&quot;)
</code></pre>
<pre><code class="language-java">@Pointcut(&quot;@annotation(com.chenss.anno.Chenss)&quot;)//匹配带有com.chenss.anno.Chenss注解的方法
</code></pre>
<p>如下面这个方法：</p>
<pre><code class="language-java">@Chenss
public void query(String str){
</code></pre>
<h2 id="bean">bean</h2>
<pre><code class="language-java">@Pointcut(&quot;bean(dao1)&quot;)//名称为dao1的bean上的任意方法
@Pointcut(&quot;bean(dao*)&quot;)
</code></pre>
<h1 id="aop-proxies">AOP Proxies</h1>
<p>参考链接：<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-introduction-proxies">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-introduction-proxies</a></p>
<blockquote>
<p>Spring AOP defaults to using standard JDK dynamic proxies for AOP proxies. This enables any interface (or set of interfaces) to be proxied.</p>
</blockquote>
<p>Spring AOP 默认使用标准 JDK 动态代理来完成 AOP 代理。这允许代理任何接口(或一组接口)。</p>
<h2 id="问题引入">问题引入</h2>
<p>1、定义一个接口</p>
<pre><code class="language-java">public interface IndexDao {
    void query(String str);
}
</code></pre>
<p>2、自定义一个注解</p>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
public @interface Luban {
}
</code></pre>
<p>3、定义切面，@annotation 连接点</p>
<pre><code class="language-java">@Component
// 切面
@Aspect
public class NotVeryUsefulAspect {
    @Pointcut(&quot;@annotation(com.ssm.anno.Luban)&quot;)
    public void pointCutAnno(){
    }
    /**
     * 通知
     *  通知位置：pointCut() 的前面
     *  通知内容
     */
    @Before(&quot;pointCutAnno()&quot;)
    public void before(){
        System.out.println(&quot;before&quot;);
    }
}
</code></pre>
<p>4、接口实现类，使用注解增强 query 方法</p>
<pre><code class="language-java">@Repository(&quot;indexDao&quot;)
public class IndexDaoImpl implements IndexDao {
    @Override
    @Luban
    public void query(String str){
        System.out.println(&quot;query&quot;);
    }
}
</code></pre>
<p>5、配置文件类</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
// 开启 AspectJ 语法支持
@EnableAspectJAutoProxy
public class AppConfig {
}
</code></pre>
<p>6、测试类</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        IndexDao dao = (IndexDao) context.getBean(&quot;indexDao&quot;);
        System.out.println(dao instanceof IndexDaoImpl);
        dao.query(&quot;111&quot;);
    }
}
</code></pre>
<p>7、运行结果：</p>
<pre><code>false
before
query
</code></pre>
<p>8、分析：为什么我们将一个 IndexDaoImpl 放入 Spring 容器（@Repository），然后再从 Spring 容器内取出来（context.getBean(&quot;indexDao&quot;)）类型却不是 IndexDaoImpl 了呢？<br>
9、在配置类中加上：@EnableAspectJAutoProxy(proxyTargetClass = true) 后，设置代理方式为 cglib 代理：</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
// 开启 AspectJ 语法支持
@EnableAspectJAutoProxy(proxyTargetClass = true)
public class AppConfig {
}
</code></pre>
<p>System.out.println(dao instanceof IndexDaoImpl); 返回 true 了。<br>
注：proxyTargetClass 默认是 false，所以 dao instanceof IndexDaoImpl 返回 false。</p>
<pre><code class="language-java">boolean proxyTargetClass() default false;
</code></pre>
<h2 id="spring-aop-默认使用标准-jdk-动态代理来完成-aop-代理">Spring AOP 默认使用标准 JDK 动态代理来完成 AOP 代理</h2>
<p>当我们使用 JDK 动态代理时，即 @EnableAspectJAutoProxy(proxyTargetClass = false)，从 Spring 容器中取出来的对象与放进去的对象不一致：context.getBean(&quot;indexDao&quot;) instanceof IndexDaoImpl 返回 false。<br>
但是 context.getBean(&quot;indexDao&quot;) instanceof indexDao 返回 true，因为 JDK 动态代理底层用的是接口。<br>
context.getBean(&quot;indexDao&quot;) instanceof Proxy 也返回 true。<br>
实现代理的办法</p>
<ul>
<li>继承</li>
<li>聚合接口（JDK 动态代理基于聚合）</li>
<li>动态代理</li>
</ul>
<h3 id="jdk-动态代理为什么只能是基于接口不能用继承">JDK 动态代理为什么只能是基于接口，不能用继承？</h3>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws IOException {
        Class&lt;?&gt;[] interfaces = new Class[]{IndexDao.class};
        byte[] bytes = ProxyGenerator.generateProxyClass(&quot;SSM&quot;,interfaces);
        File file = new File(&quot;C:\\Users\\Only\\Test.class&quot;);
        FileOutputStream fw = new FileOutputStream(file);
        fw.write(bytes);
        fw.flush();
        fw.close();
    }
}
</code></pre>
<p>注意：ProxyGenerator 的使用是基于 JDK8 的，如果使用 JDK10 会报 “找不到符号” 错误，参考：<a href="https://blog.csdn.net/weixin_46034990/article/details/105892718">https://blog.csdn.net/weixin_46034990/article/details/105892718</a><br>
JDK 底层源码已经帮这个对象自动继承了一个 Proxy 对象了，由于 Java 是单继承，所以不可能再去继承目标对象，所以只能实现目标对象的接口。<br>
<img src="https://epitomm.github.io/post-images/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.png" alt="图片" loading="lazy"><br>
基于上图可以看出，这个代理对象等于 IndexDao、也等于 Proxy，但是不等于 IndexDaoImpl，这也就解释了上述 【context.getBean(&quot;indexDao&quot;) instanceof IndexDaoImpl 返回 false。context.getBean(&quot;indexDao&quot;) instanceof indexDao 返回 true、context.getBean(&quot;indexDao&quot;) instanceof Proxy 也返回 true。】的原因。</p>
<h2 id="this-切点">this 切点</h2>
<p>this 表示<strong>代理对象</strong>的匹配类型<br>
前提：使用 JDK 动态代理，即 @EnableAspectJAutoProxy(proxyTargetClass = false)</p>
<pre><code class="language-java">@Component
// 切面
@Aspect
public class NotVeryUsefulAspect {
    // this 表示代理对象的匹配类型，使用 JDK 动态代理后，代理对象的类型是：Proxy、IndexDao，但不是 IndexDaoImpl
    @Pointcut(&quot;this(com.ssm.dao.IndexDao)&quot;)
    public void pointCutThis(){
        System.out.println(&quot;point cut&quot;);
    }
    /**
     * 通知
     *  通知位置：pointCut() 的前面
     *  通知内容
     */
    @Before(&quot;pointCutThis()&quot;)
    public void before(){
        System.out.println(&quot;before&quot;);
    }
}
</code></pre>
<p>增强成功：</p>
<pre><code>before
query
</code></pre>
<pre><code class="language-java">// this 表示代理对象的匹配类型，使用 JDK 动态代理后，代理对象的类型是：Proxy、IndexDao，但不是 IndexDaoImpl
@Pointcut(&quot;this(com.ssm.dao.impl.IndexDaoImpl)&quot;)
public void pointCutThis(){
    System.out.println(&quot;point cut&quot;);
}

@Before(&quot;pointCutThis()&quot;)
public void before(){
    System.out.println(&quot;before&quot;);
}
</code></pre>
<p>增强失败：</p>
<pre><code>query
</code></pre>
<h1 id="spring-aop-xml实现方式的注意事项">Spring AOP XML实现方式的注意事项:</h1>
<ol>
<li>在aop:config中定义切面逻辑，允许重复出现，重复多次，以最后出现的逻辑为准，但是次数以出现的次数为准</li>
<li>aop:aspect ID重复不影响正常运行，依然能够有正确结果</li>
<li>aop:pointcut ID重复会出现覆盖，以最后出现的为准。不同aop:aspect内出现的pointcut配置，可以相互引用</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/aop
                           http://www.springframework.org/schema/aop/spring-aop.xsd
                           http://www.springframework.org/schema/context
                           http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!-- 定义开始进行注解扫描 --&gt;
    &lt;context:component-scan base-package=&quot;com.chenss&quot;&gt;&lt;/context:component-scan&gt;

    &lt;!-- 定义AspectJ对象使用的逻辑类，类中提供切面之后执行的逻辑方法 --&gt;
    &lt;bean id=&quot;aspectAop&quot; class=&quot;com.chenss.aspectj.Aspect&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;aspectAop2&quot; class=&quot;com.chenss.aspectj.Aspect2&quot;&gt;&lt;/bean&gt;

    &lt;bean id=&quot;indexDao&quot; class=&quot;com.chenss.entity.IndexDao&quot;&gt;&lt;/bean&gt;

    &lt;!--在Config中定义切面逻辑，允许重复出现，重复多次，以最后出现的逻辑为准，但是次数以出现的次数为准--&gt;
    &lt;aop:config&gt;
        &lt;!-- aop:aspect ID重复不影响正常运行，依然能够有正确结果 --&gt;
        &lt;!-- aop:pointcut ID重复会出现覆盖，以最后出现的为准。不同aop:aspect内出现的pointcut配置，可以相互引用 --&gt;
        &lt;aop:aspect id=&quot;aspect&quot; ref=&quot;aspectAop&quot;&gt;
            &lt;aop:pointcut id=&quot;aspectCut&quot; expression=&quot;execution(* com.chenss.entity.*.*())&quot;/&gt;
            &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;aspectCut&quot;&gt;&lt;/aop:before&gt;
      
            &lt;aop:pointcut id=&quot;aspectNameCut&quot; expression=&quot;execution(* com.chenss.entity.*.*(java.lang.String, ..))&quot;/&gt;
            &lt;aop:before method=&quot;before2&quot; pointcut-ref=&quot;aspectNameCut&quot;&gt;&lt;/aop:before&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring系列（一）Spring IoC 应用]]></title>
        <id>https://epitomm.github.io/post/spring-ioc/</id>
        <link href="https://epitomm.github.io/post/spring-ioc/">
        </link>
        <updated>2020-04-30T15:17:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="what-is-ioc">what is IOC</h1>
<p><strong>控制反转</strong>（Inversion of Control，缩写为<strong>IOC</strong>），是面向对象编程中的一种<strong>设计原则</strong>，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称<strong>DI</strong>），还有一种方式叫“依赖查找”（Dependency Lookup）</p>
<h2 id="ioc-和-di-的关系">IOC 和 DI 的关系</h2>
<p>IOC 是一种<strong>目标</strong>，DI 是实现 IOC 的<strong>技术手段</strong>。IOC 与 DI 的关系好似 ORM（对象关系映射） 和 Mybatis 的关系一样。</p>
<h2 id="dependency-injection">Dependency Injection</h2>
<ul>
<li>依赖注入</li>
</ul>
<h3 id="关于什么是依赖">关于什么是依赖</h3>
<pre><code class="language-java">// IndexService 依赖了 IndexDao 对象
public class IndexServiceImpl implements IndexService{
  private IndexDao indexDao;
}
</code></pre>
<p><strong>当一个类中拥有一个类的属性，或者构造方法中传了一个值，就可以说：当前这个类依赖于这个属性，或者依赖于构造方法里传入的对象</strong>。</p>
<p>Student 类中有一个 Address 类的属性，Student 类依赖于 Address 属性。</p>
<p>Student 类的构造方法的参数中有一个 Address 类，Student 类依赖于构造方法里传入的 Address 对象。</p>
<pre><code class="language-java">public class Student{
  private String name;
  private Integer age;
  private Address address;
  publci Student(String name,Integer age,Address address){
    this.name = name;
    this.age = age;
    this.address = address;
  }
}

public class Address{
  private String province;
  private String city;
}
</code></pre>
<h1 id="为什么要使用-spring-ioc">为什么要使用 Spring IOC</h1>
<h2 id="面向抽象编程">面向抽象编程</h2>
<pre><code class="language-java">public class IndexServiceImpl implements IndexService{
  public void test(){
     // 这样的写法会造成高耦合
     IndexDao indexDao = new IndexDaoImpl();
  }
}
</code></pre>
<p>假设有一天要对这个 IndexDao 进行一个代理，就不能通过 new 了，而是通过 Proxy.newXXX(); 就需要<strong>更改代码</strong>为：IndexDao indexDao = Proxy.newXXX(); <strong>一个类的产生不应该由程序员自己 new 出来</strong>。</p>
<p>面向抽象编程正确写法：</p>
<pre><code class="language-java">public class IndexServiceImpl implements IndexService{
  private IndexDao indexDao;
    public void test(){
     indexDao.call();
  }
}
</code></pre>
<p>无论 IndexDao 是代理还是本身实现，它都叫做 IndexDao，如果有一天需要一个代理类的话，只需要产生一个代理类，并且把这个代理类的代理对象<strong>传递过来就可以了</strong>。如果有一天不需要这个代理对象了，只需要把这个对象 new 出来传过来就可以了。</p>
<h2 id="如何传递过来呢">如何传递过来呢？</h2>
<p>提供一个 <strong>setter</strong> 或<strong>构造方法</strong>把这个类传递过来。</p>
<pre><code class="language-java">public class IndexServiceImpl implements IndexService{
  // 1.setter 方法
  // 2.构造方法，别人在 new 这个ServiceImpl 时就需要把具体的实现传进来
    public IndexServiceImpl(IndexDao dao){
  }
}
</code></pre>
<h2 id="spring体系结构-ioc的位置">spring体系结构----IOC的位置</h2>
<blockquote>
<p><a href="https://spring.io/projects">https://spring.io/projects</a><br>
Spring Framework<br>
Provides core support for dependency injection, transaction management, web apps, data access, messaging and more.<br>
提供了 DI、事务管理、web 开发和更多的核心支持<br>
<a href="https://spring.io/projects/spring-framework">https://spring.io/projects/spring-framework</a><br>
Features（特点）<br>
Core technologies（核心技术）: dependency injection（DI）, events, resources, i18n, validation, data binding, type conversion, SpEL, AOP.<br>
Testing: mock objects, TestContext framework, Spring MVC Test, WebTestClient.<br>
Data Access: transactions, DAO support, JDBC, ORM, Marshalling XML.<br>
Spring MVC and Spring WebFlux web frameworks.<br>
Integration: remoting, JMS, JCA, JMX, email, tasks, scheduling, cache.<br>
Languages: Kotlin, Groovy, dynamic languages.</p>
</blockquote>
<h2 id="容器">容器</h2>
<p>在日常程序开发过程当中，我们推荐<strong>面向抽象</strong>编程，面向抽象编程会产生<strong>类的依赖</strong>，当然如果你够强大可以自己写一个<strong>管理的容器</strong>，但是既然spring以及实现了，并且spring如此优秀，我们仅仅需要学习spring框架便可。</p>
<p>当我们有了一个管理对象的容器之后，<strong>类的产生过程交给了容器</strong>，至于我们自己的app则可以不需要去关系这些对象的产生了。</p>
<h1 id="spring-实现-ioc-的思路和方法">Spring 实现 IOC 的思路和方法</h1>
<p>Spring 实现 IOC 的思路是<strong>提供一些配置信息用来描述类之间的依赖关系，然后由容器去解析这些配置信息，继而维护好对象之间的依赖关系</strong>，前提是对象之间的依赖关系必须在类中定义好，比如 A.class 中有一个 B.class 的属性，那么我们可以理解为 A 依赖了 B。既然我们在类中已经定义了他们之间的依赖关系那么为什么还需要在配置文件中去描述和定义呢？</p>
<h2 id="spring-实现-ioc-的思路大致可以拆分成-3-点">Spring 实现 IOC 的思路大致可以拆分成 3 点</h2>
<ol>
<li>应用程序中提供类，提供依赖关系（属性或者构造方法）</li>
<li>把需要交给容器管理的<strong>对象</strong>通过配置信息告诉容器（xml、Annotation，JavaConfig）</li>
<li>把各个类之间的<strong>依赖关系</strong>通过配置信息告诉容器</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/springIOC.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>1、定义一个类 A，把类 A 和 类 B 的关系通过应用程序描述出来：类 A 中有一个类 B 的属性<br>
2、将类 A、类 B 交给 Spring 容器进行管理：使用 <bean><br>
3、在 xml 定义中描述类 A、类 B 之间的依赖关系</p>
</blockquote>
<h2 id="既然我们在类中已经定义了他们之间的依赖关系那么为什么还需要在配置文件中去描述和定义呢">既然我们在类中已经定义了他们之间的依赖关系那么为什么还需要在配置文件中去描述和定义呢？</h2>
<p>类中定义了但是 Spring 感知不到你是否需要依赖注入</p>
<p>配置这些信息的方法有三种分别是 xml，Annotation 和 JavaConfig</p>
<p>维护的过程称为<strong>自动注入</strong>，自动注入的方法有两种：<strong>构造方法</strong> 和 <strong>setter</strong></p>
<p>自动注入的值可以是对象，数组，map，list和常量比如字符串整形等</p>
<h1 id="spring编程的风格">spring编程的风格</h1>
<h2 id="schemal-based-xml">schemal-based-------xml</h2>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-schema-declaring-an-aspect">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-schema-declaring-an-aspect</a></p>
<pre><code class="language-xml">&lt;aop:config&gt;
    &lt;aop:aspect id=&quot;myAspect&quot; ref=&quot;aBean&quot;&gt;
        ...
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;

&lt;bean id=&quot;aBean&quot; class=&quot;...&quot;&gt;
    ...
&lt;/bean&gt;
</code></pre>
<h2 id="annotation-based-annotation">annotation-based-----annotation</h2>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-advice-before">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-advice-before</a></p>
<pre><code class="language-java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect
public class BeforeExample {

    @Before(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;)
    public void doAccessCheck() {
        // ...
    }

}
</code></pre>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-required-annotation">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-required-annotation</a></p>
<pre><code class="language-java">public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Required
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
</code></pre>
<h2 id="java-based-java-configuration">java-based----java Configuration</h2>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-java-basic-concepts">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-java-basic-concepts</a></p>
<pre><code class="language-java">@Configuration
public class AppConfig {

    @Bean
    public MyService myService() {
        return new MyServiceImpl();
    }
}
</code></pre>
<h1 id="注入">注入</h1>
<p>想看一部电影，可以有如下两种方法：</p>
<p>① 输入 url 到迅雷，然后下载下来：<strong>依赖查找</strong>：输入一个 url 找到一个资源。</p>
<p>② 下载一个播放器，输入我想要看的类型，就会自动推送这个类型的电影列表。</p>
<p>IOC 也是如此，仅仅需要在代码中提供依赖关系，由容器维护好，自动把对象提供给我们使用，给的过程称之为<strong>注入</strong>。</p>
<p>注入：提供一个 setter 方法或构造方法，Spring 就会把对象给我们。给我们的过程称为注入。</p>
<blockquote>
<p>Spring3 有接口注入，但是从 Spring4 开始就已经取消了。</p>
</blockquote>
<h2 id="spring注入详细配置字符串-数组等">spring注入详细配置（字符串、数组等）</h2>
<p>参考文档：</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-properties-detailed">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-properties-detailed</a></p>
<h3 id="字符串属性注入"><strong>字符串属性注入</strong></h3>
<p>使用 value：<property name="str" value=""/></p>
<pre><code class="language-java">package com.ssm.dao.impl;
import com.ssm.dao.IndexDao;
public class IndexDaoImpl implements IndexDao {
    private String str=&quot;&quot;;
    public void setStr(String str) {
        this.str = str;
    }
    public String getStr() {
        return str;
    }
    @Override
    public void test() {
        System.out.println(&quot;IndexDaoImpl...&quot;);
    }
}
</code></pre>
<pre><code class="language-xml">&lt;bean id=&quot;dao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot;&gt;
    &lt;property name=&quot;str&quot; value=&quot;Hello world&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="language-xml">&lt;bean id=&quot;myDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;
    &lt;!-- results in a setDriverClassName (String) call --&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mydb&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;masterkaoli&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="内部-bean">内部 bean</h3>
<p>原来是通过在 <property ref="xxx"/>，ref 引入外部 bean</p>
<p>内部 bean 是 <property><bean>  ... </bean></property>，在 property 标签内部注入 bean</p>
<pre><code class="language-xml">&lt;bean id=&quot;outer&quot; class=&quot;...&quot;&gt;
    &lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;
    &lt;property name=&quot;target&quot;&gt;
        &lt;bean class=&quot;com.example.Person&quot;&gt; &lt;!-- this is the inner bean --&gt;
            &lt;property name=&quot;name&quot; value=&quot;Fiona Apple&quot;/&gt;
            &lt;property name=&quot;age&quot; value=&quot;25&quot;/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="collections">Collections</h3>
<pre><code class="language-xml">&lt;bean id=&quot;moreComplexObject&quot; class=&quot;example.ComplexObject&quot;&gt;
    &lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;
    &lt;property name=&quot;adminEmails&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;administrator&quot;&gt;administrator@example.org&lt;/prop&gt;
            &lt;prop key=&quot;support&quot;&gt;support@example.org&lt;/prop&gt;
            &lt;prop key=&quot;development&quot;&gt;development@example.org&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeList(java.util.List) call --&gt;
    &lt;property name=&quot;someList&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;a list element followed by a reference&lt;/value&gt;
            &lt;ref bean=&quot;myDataSource&quot; /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeMap(java.util.Map) call --&gt;
    &lt;property name=&quot;someMap&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;an entry&quot; value=&quot;just some string&quot;/&gt;
            &lt;entry key =&quot;a ref&quot; value-ref=&quot;myDataSource&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeSet(java.util.Set) call --&gt;
    &lt;property name=&quot;someSet&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;just some string&lt;/value&gt;
            &lt;ref bean=&quot;myDataSource&quot; /&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="xml-shortcut-with-the-p-namespace">XML Shortcut with the p-namespace</h3>
<blockquote>
<p>Spring supports extensible configuration formats with namespaces, which are based on an XML Schema definition. The beans configuration format discussed in this chapter is defined in an XML Schema document. However, the p-namespace is not defined in an XSD file and exists only in the core of Spring.</p>
<p>Spring 支持带有名称空间的可扩展配置格式，这些名称空间基于XML模式定义。本章讨论的 bean 配置格式是在 XML 模式文档中定义的。但是，p-namespace 并没有在 XSD 文件中定义，它只存在于Spring 的核心中。</p>
</blockquote>
<p>1、在原有的基础上添加 xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 命名空间</p>
<p>2、<bean id="dao" class="com.ssm.dao.impl.IndexDaoImpl" p:str="Hello world"> 注入 等价于 原有的 <property name="str" value="Hello world"/>  注入。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;dao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot; p:str=&quot;Hello world&quot;&gt;
&lt;!--        &lt;property name=&quot;str&quot; value=&quot;Hello world&quot;&gt;&lt;/property&gt;--&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="xml-shortcut-with-the-c-namespace">XML Shortcut with the c-namespace</h3>
<p>如果类中定义了构造函数注入，但 bean 标签内没有声明 <constructor-arg> 就会产生 Caused by: java.lang.NoSuchMethodException: com.ssm.service.IndexService.<init>() 异常</p>
<pre><code>&lt;bean id=&quot;service&quot; class=&quot;com.ssm.service.IndexService&quot;&gt;&lt;!--        &lt;constructor-arg ref=&quot;dao&quot;&gt;&lt;/constructor-arg&gt;--&gt;&lt;/bean&gt;
</code></pre>
<p>使用 c-namespace 注入：<br>
1、添加 xmlns:c=&quot;http://www.springframework.org/schema/c&quot; 命名空间</p>
<p>2、<bean id="service" class="com.ssm.service.IndexService" c:indexDao-ref="dao"> 注入 等价于 原来的     <bean id="service" class="com.ssm.service.IndexService">  <constructor-arg ref="dao"></constructor-arg>  </bean></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;dao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot; p:str=&quot;Hello world&quot;&gt; 
&lt;!--        &lt;property name=&quot;str&quot; value=&quot;Hello world&quot;&gt;&lt;/property&gt;--&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;service&quot; class=&quot;com.ssm.service.IndexService&quot; c:indexDao-ref=&quot;dao&quot;&gt;
&lt;!--        &lt;constructor-arg ref=&quot;dao&quot;&gt;&lt;/constructor-arg&gt;--&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<h2 id="spring-通过-setter-注入的应用实例">Spring 通过 setter 注入的应用实例</h2>
<p>1、pom.xml 导入 spring 依赖</p>
<pre><code class="language-xml">&lt;!-- ioc 90% 以上的内容 --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
  &lt;version&gt;5.0.9.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、应用程序中提供类，提供依赖关系（属性或者构造方法）</p>
<p>IndexDao 类：</p>
<pre><code class="language-java">package com.ssm.dao;

public interface IndexDao {
    void test();
}
</code></pre>
<p>IndexDaoImpl 类：</p>
<pre><code class="language-java">package com.ssm.dao.impl;

import com.ssm.dao.IndexDao;

public class IndexDaoImpl implements IndexDao {

    @Override
    public void test() {
        System.out.println(&quot;IndexDaoImpl...&quot;);
    }
}
</code></pre>
<p>IndexService 依赖 Index：</p>
<p><strong>提供 setter 方法：</strong></p>
<pre><code class="language-java">package com.ssm.service;

import com.ssm.dao.IndexDao;

public class IndexService {

    private IndexDao indexDao;

    public void service(){
        indexDao.test();
    }

    // 提供 setter 方法
    public void setIndexDao(IndexDao indexDao) {
        this.indexDao = indexDao;
    }
}
</code></pre>
<p>3、把需要交给容器管理的对象通过配置信息告诉容器（xml、Annotation，JavaConfig）</p>
<p>4、把各个类之间的依赖关系通过配置信息告诉容器</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;dao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot;&gt;&lt;/bean&gt;

    &lt;bean id=&quot;service&quot; class=&quot;com.ssm.service.IndexService&quot;&gt;
        &lt;property name=&quot;indexDao&quot; ref=&quot;dao&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>5、测试</p>
<pre><code class="language-java">package com.ssm.test;

import com.ssm.service.IndexService;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test {
    public static void main(String[] args) {
        // ClassPathXmlApplicationContext：通过 ClassPath 下的 xml 初始化 Spring 应用环境
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
        IndexService service = (IndexService) context.getBean(&quot;service&quot;);
        service.service();
    }
}
</code></pre>
<p>6、运行结果</p>
<pre><code>IndexDaoImpl...注入的两种方法
</code></pre>
<h3 id="constructor-based-dependency-injection">Constructor-based Dependency Injection</h3>
<p>构造方法注入参考文档：</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-constructor-injection">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-constructor-injection</a></p>
<h4 id="构造方法注入实例">构造方法注入实例</h4>
<pre><code class="language-java">public class IndexService {
    private IndexDao indexDao;
    public IndexService(IndexDao indexDao){
        this.indexDao = indexDao;
    }
    public void service(){
        indexDao.test();
    }
}
</code></pre>
<p>xml 文件：</p>
<pre><code class="language-xml">&lt;bean id=&quot;dao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;service&quot; class=&quot;com.ssm.service.IndexService&quot;&gt;
  &lt;constructor-arg ref=&quot;dao&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5.png" alt="图片" loading="lazy"></figure>
<h3 id="setter-based-dependency-injection">Setter-based Dependency Injection</h3>
<p>setter参考文档：</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-setter-injection">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-setter-injection</a></p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/setter%E6%B3%A8%E5%85%A5.png" alt="图片" loading="lazy"></figure>
<h2 id="注解-xml-混合使用">注解 + xml 混合使用</h2>
<p>1、xml 内 的ref 引用 dao</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;service&quot; class=&quot;com.ssm.service.IndexService&quot; c:indexDao-ref=&quot;dao&quot;&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>2、使用注解声明 dao：</p>
<pre><code class="language-java">@Component(&quot;dao&quot;)
public class IndexDaoImpl implements IndexDao {
</code></pre>
<p>3、报错：找不到 dao</p>
<p>Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named 'dao' available</p>
<p>4、分析：没有开启注解、没有注解扫描</p>
<h3 id="开启注解">开启注解：</h3>
<p>1、xml 中添加 context 相关内容</p>
<pre><code class="language-xml">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
 xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;
</code></pre>
<p>2、开启注解（现在 Spring 版本不写开启注解、只写注解扫描，也能实现功能）</p>
<pre><code class="language-xml">&lt;context:annotation-config /&gt;
</code></pre>
<p>3、开启注解扫描</p>
<pre><code class="language-xml">&lt;context:component-scan base-package=&quot;com.ssm&quot;/&gt;
</code></pre>
<p>将 service 的 bean 声明也使用注解，于是就可以删除 xml 中的 id 为 service 的 bean 标签了。</p>
<pre><code class="language-java">@Service(value = &quot;service&quot;)
public class IndexService {
</code></pre>
<p>完整代码：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!-- 开启注解 --&gt;
    &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt;
    &lt;!-- 开启注解扫描 --&gt;
    &lt;context:component-scan base-package=&quot;com.ssm&quot;&gt;&lt;/context:component-scan&gt;
&lt;/beans&gt;
</code></pre>
<p>4、测试，运行结果：</p>
<pre><code>IndexDaoImpl...
</code></pre>
<p>总结：以上这种注解方式一定需要 xml，因为需要在 xml 内<strong>开启注解扫描</strong>。</p>
<p>有没有办法删掉 xml 呢？答：JavaConfig 配置方式</p>
<h2 id="javaconfig-配置方式">JavaConfig 配置方式</h2>
<p>1、编写配置类</p>
<pre><code class="language-java">package com.ssm.config;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.stereotype.Component;
// 表明这是一个 xml 文件
@Configuration
// 扫描包
@ComponentScan(&quot;com.ssm&quot;)      
public class SpringConfig {
}
</code></pre>
<p>2、修改测试类 Test</p>
<pre><code class="language-java">package com.ssm.test;
import com.ssm.config.SpringConfig;
import com.ssm.service.IndexService;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        IndexService service = (IndexService) context.getBean(&quot;service&quot;);
        service.service();
    }
}
</code></pre>
<p>3、测试，运行结果：</p>
<pre><code>IndexDaoImpl...
</code></pre>
<h2 id="javaconfig-xml-注解配置">JavaConfig + xml +注解配置</h2>
<p>1、Sservice 的注入使用注解方式</p>
<pre><code>@Service(&quot;service&quot;)
public class IndexService {
</code></pre>
<p>2、Dao 的注入使用 xml 方式</p>
<pre><code class="language-java">public class IndexDaoImpl implements IndexDao {
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!-- 开启注解 --&gt;
    &lt;context:annotation-config/&gt;
    &lt;!-- 开启注解扫描 --&gt;
    &lt;context:component-scan base-package=&quot;com.ssm&quot;/&gt;
    &lt;bean id=&quot;dao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot; p:str=&quot;Hello world&quot;&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>3、JavaConfig 配置类引入 xml 文件</p>
<pre><code class="language-java">// 表明这是一个 xml 文件
@Configuration
// 扫描包
@ComponentScan(&quot;com.ssm&quot;)
// 引入 xml 配置文件
@ImportResource(&quot;classpath:spring.xml&quot;)
public class SpringConfig {
}
</code></pre>
<p>4、测试类</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        IndexService service = (IndexService) context.getBean(&quot;service&quot;);
        service.service();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>IndexDaoImpl...
</code></pre>
<h1 id="自动装配">自动装配</h1>
<p>上面说过，IOC 的注入有两个地方需要提供依赖关系，一是类的定义中，二是在spring的配置中需要去描述。自动装配则把第二个取消了，即我们仅仅需要在类中提供依赖，继而把对象交给容器管理即可完成注入。</p>
<p>在实际开发中，描述类之间的依赖关系通常是大篇幅的，如果使用自动装配则省去了很多配置，并且如果对象的依赖发生更新我们可以不需要去更新配置，但是也带来了一定的缺点</p>
<h2 id="自动装配的优点">自动装配的优点</h2>
<p>参考文档：</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire</a></p>
<blockquote>
<p>The Spring container can autowire relationships between collaborating beans. You can let Spring resolve collaborators (other beans) automatically for your bean by inspecting the contents of the ApplicationContext. Autowiring has the following advantages:</p>
</blockquote>
<p>Spring容器可以自动创建协作 bean 之间的关系。通过检查 ApplicationContext 的内容，您可以让 Spring 为您的 bean 自动解析协作者(其他bean)。自动装配有以下优点:</p>
<blockquote>
<p>Autowiring can significantly reduce the need to specify properties or constructor arguments. (Other mechanisms such as a bean template discussed elsewhere in this chapter are also valuable in this regard.)</p>
</blockquote>
<p>自动装配可以大大减少指定属性或构造函数参数的需要。(本章其他地方讨论的其他机制，如bean模板，在这方面也很有价值。)</p>
<blockquote>
<p>Autowiring can update a configuration as your objects evolve. For example, if you need to add a dependency to a class, that dependency can be satisfied automatically without you needing to modify the configuration. Thus autowiring can be especially useful during development, without negating the option of switching to explicit wiring when the code base becomes more stable.</p>
</blockquote>
<p>自动装配可以随着对象的演化更新配置。例如，如果需要向类添加依赖，则可以自动更新该依赖，而不需要修改配置。因此，自动装配在开发过程中特别有用，当代码库变得更加稳定时，自动装配可以避免切换到显式连接的选项。</p>
<pre><code class="language-xml">&lt;bean id=&quot;indexService&quot; class=&quot;com.ssm.service.IndexService&quot;&gt;
    &lt;property name=&quot;indexDao&quot; ref=&quot;dao&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>分析：上述配置需要手动添加依赖，比如现在 IndexService 新增了依赖 helloDao：</p>
<pre><code class="language-java">public class IndexService{
  private IndexDao indexDao;
  private HelloDao helloDao;
}
</code></pre>
<p>就需要在 xml 的 <bean> 内增加 <property name="hello" ref="hello"/></p>
<pre><code class="language-xml">&lt;bean id=&quot;indexService&quot; class=&quot;com.ssm.service.IndexService&quot;&gt;
    &lt;property name=&quot;indexDao&quot; ref=&quot;dao&quot;/&gt;
     &lt;property name=&quot;hello&quot; ref=&quot;hello&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>使用了自动装配后，就无须手动在 xml 中增加依赖进行维护了，<strong>自动装配可以自动更新该依赖，而不需要修改配置</strong>。</p>
<h2 id="自动装配的缺点">自动装配的缺点</h2>
<p>参考文档：</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-autowired-exceptions">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-autowired-exceptions</a></p>
<p>作为我来讲，我觉得以上缺点都不是缺点</p>
<h2 id="自动装配的方法">自动装配的方法</h2>
<p>自动装配的方式参考文档：</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire</a></p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Mode</strong></th>
<th style="text-align:left"><strong>Explanation</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">no ( 不使用自动装配 )</td>
<td style="text-align:left">(默认)没有自动装配。Bean 引用必须由 ref 元素定义。对于较大的部署，不建议更改默认设置，因为显式地指定协作者可以提供更好的控制和清晰度。在某种程度上，它记录了一个系统的结构。</td>
</tr>
<tr>
<td style="text-align:left">byName</td>
<td style="text-align:left">通过属性名自动装配。Spring 寻找与需要自动装配的属性同名的 bean。例如，如果一个 bean 定义被按名称设置为自动装配，并且它包含一个主属性(也就是说，它有一个setMaster(..)方法)，Spring 会查找一个名为master 的 bean 定义并使用它来设置属性。</td>
</tr>
<tr>
<td style="text-align:left">byType</td>
<td style="text-align:left">如果容器中恰好存在该属性类型的一个 bean，则允许自动获取该属性。如果存在多个异常，则抛出一个致命异常，这表明您不能为该 bean 使用byType 自动装配。如果没有匹配的 bean，则什么也不会发生(属性没有设置)。</td>
</tr>
<tr>
<td style="text-align:left">constructor</td>
<td style="text-align:left">类似于 byType，但适用于构造函数参数。如果容器中没有一个构造函数参数类型的 bean，则会引发致命错误。</td>
</tr>
</tbody>
</table>
<h3 id="bytype-自动装配实例">byType 自动装配实例</h3>
<p>1、IndexService 依赖 IndexDao</p>
<pre><code class="language-java">public class IndexService {
    private IndexDao indexDao;
    public void service(){
        indexDao.test();
    }
    public void setIndexDao(IndexDao indexDao) {
        this.indexDao = indexDao;
    }
}
</code></pre>
<p>2、使用自动装配：beans 标签内导入 default-autowire=&quot;byType&quot;</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;
        default-autowire=&quot;byType&quot;&gt;

    &lt;!-- 开启注解 --&gt;
    &lt;context:annotation-config/&gt;
    &lt;!-- 开启注解扫描 --&gt;
    &lt;context:component-scan base-package=&quot;com.ssm&quot;/&gt;

    &lt;bean id=&quot;dao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot;&gt;
    &lt;/bean&gt;

    &lt;!-- IndexService 内应该注入 IndexDao，但因为指定了自动装配，所以可以不显式通过 property 标签注入 IndexDao --&gt;
    &lt;bean id=&quot;indexService&quot; class=&quot;com.ssm.service.IndexService&quot;&gt;
&lt;!--        &lt;property name=&quot;indexDao&quot; ref=&quot;dao&quot;/&gt;--&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>分析：IndexService 内应该注入 IndexDao，但因为通过 default-autowire=&quot;byType&quot; 指定了自动装配，所以可以不显式通过 property 标签注入 IndexDao。</p>
<p>在扫描到 IndexService 类时，发现该类依赖了 IndexDao，发现它的类型是 IndexDao，到 Spring 容器中找类型或父类类型为 IndexDao 的，如果有，就把这个对象直接赋给 IndexService 中的 IndexDao。</p>
<blockquote>
<p>自动装配并不是完全不需要配置了，自动装配仍需要配置 bean，将类交给 Spring 容器管理，自动装配省略了类与类之间依赖的管理，比如类 A 依赖类 B，无需配置依赖关系了，Spring 会自动到容器中找到类 B 然后把它赋给类 A 的成员变量。</p>
</blockquote>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D.png" alt="图片" loading="lazy"></figure>
<h4 id="bytype-自动装配多个相同类型的问题">byType 自动装配多个相同类型的问题</h4>
<p>当有多个相同类型时，会报错</p>
<p>1、添加一个 IndexDaoImpl2 类</p>
<pre><code class="language-java">public class IndexDaoImpl2 implements IndexDao {
    @Override
    public void test() {
        System.out.println(&quot;IndexDaoImpl...2&quot;);
    }
}
</code></pre>
<p>2、把 IndexDaoImpl2 交给 Spring 容器管理，现在 Spring 容器内有两个 type = IndexDao 的类：IndexDaoImp、IndexDaoImpl2</p>
<pre><code class="language-xml">&lt;bean id=&quot;dao2&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl2&quot;/&gt;
</code></pre>
<p>3、测试结果：</p>
<p>Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'com.ssm.dao.IndexDao' available: expected single matching bean but found 2: dao,dao2</p>
<p>需要单个匹配，但是发现了两个：dao、dao2</p>
<h3 id="byname-自动装配实例">byName 自动装配实例</h3>
<p>1、beans 标签内指定 byName 自动装配：</p>
<pre><code>default-autowire=&quot;byName&quot;
</code></pre>
<p>2、如果没有指定 <bean> 标签的 name 属性，name 默认为将 setIndexDao 的 set 去掉、第一个字母小写，即 name=indexDao</p>
<pre><code class="language-java">public class IndexService {
    private IndexDao indexDao;
    public void service(){
        indexDao.test();
    }
    public void setIndexDao(IndexDao indexDao) {
        this.indexDao = indexDao;
    }
}
</code></pre>
<p>3、于是到 Spring 容器内找 name=indexDao 的，没有找到，报错 Exception in thread &quot;main&quot; java.lang.NullPointerException</p>
<pre><code class="language-xml">&lt;bean id=&quot;dao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot;/&gt;
&lt;bean id=&quot;dao2&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl2&quot;/&gt;
</code></pre>
<p>解决办法一：</p>
<p>1、改变 set 方法的方法名：</p>
<pre><code class="language-java">public void setDao(IndexDao indexDao) {
    this.indexDao = indexDao;
}
</code></pre>
<p>2、测试成功：</p>
<pre><code>IndexDaoImpl...
</code></pre>
<p>解决方法二：</p>
<p>1、set 方法不变</p>
<pre><code>public void setIndexDao(IndexDao indexDao) {
    this.indexDao = indexDao;
 }
</code></pre>
<p>2、给 bean 标签添加 name 属性</p>
<pre><code>&lt;bean id=&quot;dao2&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl2&quot; name=&quot;indexDao&quot;&gt;&lt;/bean&gt;
</code></pre>
<p>3、测试成功</p>
<pre><code>IndexDaoImpl...2
</code></pre>
<h3 id="default-no-不使用自动装配">default = no 不使用自动装配</h3>
<p>beans 标签内部增加如下说明：</p>
<p>default-autowire=&quot;default&quot;</p>
<p>default=autowire=&quot;no&quot;</p>
<p>异常信息：Exception in thread &quot;main&quot; java.lang.NullPointerException</p>
<p>其他都想手动装配，唯独 IndexService 想自动装配，就不能在 beans 标签内添加 default-autowire 了，可以<strong>为每一个属性单独指定一个 autowire</strong></p>
<pre><code class="language-xml">&lt;bean id=&quot;indexService&quot; class=&quot;com.ssm.service.IndexService&quot; autowire=&quot;byType&quot;/&gt;
</code></pre>
<p>参考资料：<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-stereotype-annotations">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-stereotype-annotations</a></p>
<blockquote>
<p>Spring provides further stereotype annotations: @Component, @Service, and @Controller. @Component is a generic stereotype for any Spring-managed component. @Repository, @Service, and @Controller are specializations of @Component for more specific use cases (in the persistence, service, and presentation layers, respectively). Therefore, you can annotate your component classes with @Component, but, by annotating them with @Repository, @Service, or @Controller instead, your classes are more properly suited for processing by tools or associating with aspects. For example, these stereotype annotations make ideal targets for pointcuts. @Repository, @Service, and @Controller can also carry additional semantics in future releases of the Spring Framework. Thus, if you are choosing between using @Component or @Service for your service layer, @Service is clearly the better choice. Similarly, as stated earlier, @Repository is already supported as a marker for automatic exception translation in your persistence layer.</p>
</blockquote>
<p>Spring提供了更多的的构造型注解:@Component， @Service，和@Controller。@Component 是任何spring管理组件的通用注解。@Repository、@Service和@Controller是@Component对更具体用例(分别在持久性、服务和表示层)的专门化。因此，您可以使用@Component来注释您的组件类，但是，通过使用@Repository、@Service或@Controller来注释它们，您的类更适合通过工具进行处理或与方面相关联。例如，这些构造型注释是切入点的理想目标。在Spring框架的未来版本中，@Repository、@Service和 @Controller 也可以包含额外的语义。因此，如果您在使用@Component或@Service作为服务层之间进行选择，那么@Service显然是更好的选择。类似地，如前所述，@Repository已经被支持作为持久层中自动异常转换的标记。</p>
<h2 id="autowired-默认采用-bytype-注入">@Autowired 默认采用 byType 注入</h2>
<p>1、JavaConfig 配置类</p>
<ul>
<li>声明这是一个注解类</li>
<li>扫描包</li>
</ul>
<pre><code class="language-java">// 表明这是一个 xml 文件
@Configuration
// 注解扫描包
@ComponentScan(&quot;com.ssm&quot;)
public class SpringConfig {
}
</code></pre>
<p>2、@Service 注解</p>
<ul>
<li>@Autowired注入 IndexDao</li>
<li>setIndexDao 方法</li>
</ul>
<pre><code class="language-java">@Service
public class IndexService {
    @Autowired
    private IndexDao indexDao;
    public void service(){
        indexDao.test();
    }
    public void setIndexDao(IndexDao indexDao) {
        this.indexDao = indexDao;
    }
}
</code></pre>
<p>3、IndexDao 类型的 IndexDaoImpl 类</p>
<pre><code class="language-java">@Repository
public class IndexDaoImpl implements IndexDao {
    @Override
    public void test() {
        System.out.println(&quot;IndexDaoImpl...&quot;);
    }
}
</code></pre>
<p>4、相同 IndexDao 类型的 IndexDaoImpl2</p>
<pre><code class="language-java">@Repository
public class IndexDaoImpl2 implements IndexDao {
    @Override
    public void test() {
        System.out.println(&quot;IndexDaoImpl...2&quot;);
    }
}
</code></pre>
<p>5、测试类</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        IndexService service = (IndexService) context.getBean(&quot;indexService&quot;);
        service.service();
    }
}
</code></pre>
<p>6、运行结果：</p>
<p>Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'com.ssm.dao.IndexDao' available: expected single matching bean but found 2: indexDaoImpl,indexDaoImpl2</p>
<p>期望一个匹配的 IndexDao 类型的 bean，却发现了两个：indexDaoImpl、indexDaoImpl2</p>
<p>7、分析</p>
<p>@Autowired 注解默认使用的是 byType 自动装配方式。</p>
<p>当执行 @Autowired 注入时，到 Spring 容器中找 IndexDao 类型或父类为 IndexDao 类型的，结果找到了 IndexDaoImpl、IndexDaoImpl2，注入失败。此时根据 byType 找到多个类，则根据 byName 注入（private IndexDao indexDao;）因为没有名为 indexDao 的组件，所以注入失败。</p>
<p><strong>@Autowired 默认采用 byType 注入，如果 byType 找到多个，则根据 byName 注入</strong>，name 为属性名 indexDaoImpl2（private IndexDao indexDaoImpl2）。当根据 name 值注入时，仅与属性值有关，与 set 方法的方法名无关。</p>
<pre><code class="language-java">@Service
public class IndexService {
    @Autowired
    private IndexDao indexDaoImpl2;
    public void service(){
        indexDaoImpl2.test();
    }
    public void setIndexDao(IndexDao indexDao) {
        this.indexDaoImpl2 = indexDao;
    }
}
</code></pre>
<p>Spring 容器中找到 name 为 indexDaoImpl2 的组件，注入成功</p>
<pre><code class="language-java">@Repositorypublic class IndexDaoImpl2 implements IndexDao {
</code></pre>
<p>运行结果：</p>
<pre><code>IndexDaoImpl...2
</code></pre>
<h2 id="resource-默认采用-byname-注入">@Resource 默认采用 byName 注入</h2>
<pre><code class="language-java">@Resource
private IndexDao indexDaoImpl2;
</code></pre>
<p>@Resource 模式采用 byName 注入，并且 name 的值为属性值 indexDaoImpl2，与 set 方法的名字无关。</p>
<h2 id="spring-默认-bean-名称的生成策略">Spring 默认 bean 名称的生成策略</h2>
<pre><code class="language-java">@Repository
public class IndexDaoImpl implements IndexDao {
</code></pre>
<p>Spring 中如果不显式指定 bean 的名字，默认 bean 的名称为类名首字母变小写，即：indexDaoImpl</p>
<p>参考资料：<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-scanning-name-generator">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-scanning-name-generator</a></p>
<blockquote>
<p>When a component is autodetected as part of the scanning process, its bean name is generated by the BeanNameGenerator strategy known to that scanner. By default, any Spring stereotype annotation (@Component, @Repository, @Service, and @Controller) that contains a name value thereby provides that name to the corresponding bean definition.</p>
</blockquote>
<p>当一个组件作为扫描过程的一部分被自动检测时，它的bean名称由该扫描程序所知道的BeanNameGenerator策略生成。默认情况下，任何包含名称值的Spring构造型注释(@Component、@Repository、@Service和@Controller)都将该名称提供给相应的bean定义。</p>
<blockquote>
<p>If such an annotation contains no name value or for any other detected component (such as those discovered by custom filters), the default bean name generator returns the uncapitalized non-qualified class name. For example, if the following component classes were detected, the names would be myMovieLister and movieFinderImpl:</p>
</blockquote>
<p>如果这样的注释不包含名称值或任何其他检测到的组件(例如由自定义过滤器发现的组件)，则默认bean名称生成器将返回未大写的非限定类名。例如，如果检测到以下组件类，其名称将是myMovieLister和movieFinderImpl:</p>
<pre><code class="language-java">@Service(&quot;myMovieLister&quot;)
public class SimpleMovieLister {
    // ...
}
</code></pre>
<pre><code>@Repository
public class MovieFinderImpl implements MovieFinder {
    // ...
}
</code></pre>
<blockquote>
<p>If you do not want to rely on the default bean-naming strategy, you can provide a custom bean-naming strategy. First, implement the BeanNameGenerator interface, and be sure to include a default no-arg constructor. Then, provide the fully qualified class name when configuring the scanner, as the following example annotation and bean definition show.</p>
</blockquote>
<p>如果不希望依赖默认的 bean 命名策略，可以提供自定义 bean 命名策略。首先，实现BeanNameGenerator 接口，并确保包含一个默认的无参数构造函数。然后，在配置扫描程序时提供完全限定的类名，如下面的注释和 bean 定义示例所示。</p>
<p>如果由于多个自动检测到的组件具有相同的非限定类名(即您可能需要配置一个BeanNameGenerator，该生成器默认为生成的bean名称的完全限定类名。从Spring Framework 5.2.3开始，FullyQualifiedAnnotationBeanNameGenerator位于包org.springframework.context中。注释可以用于这些目的。</p>
<pre><code class="language-java">@Configuration
@ComponentScan(basePackages = &quot;org.example&quot;, nameGenerator = MyNameGenerator.class)
public class AppConfig {
    // ...
}
</code></pre>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;context:component-scan base-package=&quot;org.example&quot;
        name-generator=&quot;org.example.MyNameGenerator&quot; /&gt;
&lt;/beans&gt;
</code></pre>
<h1 id="spring懒加载">spring懒加载</h1>
<p>官网已经解释的非常清楚了：</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lazy-init">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lazy-init</a></p>
<blockquote>
<p>By default, ApplicationContext implementations eagerly create and configure all singleton beans as part of the initialization process. Generally, this pre-instantiation is desirable, because errors in the configuration or surrounding environment are discovered immediately, as opposed to hours or even days later. When this behavior is not desirable, you can prevent pre-instantiation of a singleton bean by marking the bean definition as being lazy-initialized. A lazy-initialized bean tells the IoC container to create a bean instance when it is first requested, rather than at startup.</p>
</blockquote>
<p>默认情况下，ApplicationContext实现将创建和配置所有的单例 bean 作为初始化过程的一部分。通常，这种预实例化是可取的，因为配置或周围环境中的错误会立即被发现，而不是几小时甚至几天之后。当此行为不可取时，您可以通过将 bean 定义标记为延迟初始化来防止单例 bean 的预实例化。延迟初始化的bean 告诉 IoC 容器在第一次请求时创建 bean 实例，而不是在启动时。</p>
<pre><code class="language-xml">&lt;bean id=&quot;lazy&quot; class=&quot;com.something.ExpensiveToCreateBean&quot; lazy-init=&quot;true&quot;/&gt;
&lt;bean name=&quot;not.lazy&quot; class=&quot;com.something.AnotherBean&quot;/&gt;
</code></pre>
<p>您还可以使用 <beans/> 元素上的 default-lazy-init 属性来控制容器级别的延迟初始化，如下面的示例所示：</p>
<figure data-type="image" tabindex="5"><img src="https://images-cdn.shimo.im/AL7NwUqEre0woKxB/image.png!thumbnail" alt="图片" loading="lazy"></figure>
<h1 id="springbean的作用域">springbean的作用域</h1>
<p>文档参考：</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes</a></p>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/SpringBean%E4%BD%9C%E7%94%A8%E5%9F%9F.png" alt="图片" loading="lazy"></figure>
<h2 id="singleton">singleton</h2>
<pre><code class="language-java">@Service@Scope(&quot;singleton&quot;)
public class IndexService {
</code></pre>
<p>测试结果：</p>
<pre><code>com.ssm.service.IndexService@5884a914
IndexDaoImpl...2
com.ssm.service.IndexService@5884a914
</code></pre>
<p>两次获得到的 Service 对象是同一个实例：单例。</p>
<h2 id="prototype">prototype</h2>
<pre><code class="language-java">@Service
@Scope(&quot;prototype&quot;)
public class IndexService {
    @Autowired
    private IndexDao indexDaoImpl2;
    public void service(){
        indexDaoImpl2.test();
    }
}
</code></pre>
<p>测试</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        IndexService service = (IndexService) context.getBean(&quot;indexService&quot;);
        System.out.println(service);
        service.service();
        service = (IndexService) context.getBean(&quot;indexService&quot;);
        System.out.println(service);
    }
}
</code></pre>
<p>结果：</p>
<pre><code>com.ssm.service.IndexService@5884a914
IndexDaoImpl...2
com.ssm.service.IndexService@50378a4
</code></pre>
<p>两次得到的 Service 对象是两个对象：多例。</p>
<h3 id="xml定义方式">xml定义方式</h3>
<pre><code>&lt;bean id=&quot;accountService&quot; class=&quot;com.something.DefaultAccountService&quot; scope=&quot;singleton&quot;/&gt;
</code></pre>
<h3 id="annotation的定义方式">annotation的定义方式</h3>
<pre><code class="language-java">@Service
@Scope(&quot;prototype&quot;)
public class IndexService {
</code></pre>
<h2 id="singleton-beans-with-prototype-bean-dependencies">Singleton Beans with Prototype-bean Dependencies</h2>
<p>意思是在 Singleton 当中引用了一个 Prototype 的 bean 的时候引发的问题：</p>
<p>在单例对象中引用多例 bean，这个多例 bean 就失去了意义。</p>
<p>1、IndexService 单例</p>
<pre><code class="language-java">@Service
@Scope(&quot;singleton&quot;)
public class IndexService {
    @Autowired
    private IndexDao indexDao;
    public void service(){
        System.out.println(this);
        System.out.println(indexDao);
    }
}
</code></pre>
<p>2、IndexDao 多例</p>
<pre><code class="language-java">@Repository
@Scope(&quot;prototype&quot;)
public class IndexDaoImpl implements IndexDao {
</code></pre>
<p>3、测试</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        IndexService service = (IndexService) context.getBean(&quot;indexService&quot;);
        service.service();
        System.out.println(&quot; - - - - - - - - - &quot;);
        service = (IndexService) context.getBean(&quot;indexService&quot;);
        service.service();
        System.out.println(&quot; - - - - - - - - - &quot;);
        service = (IndexService) context.getBean(&quot;indexService&quot;);
        service.service();
    }
}
</code></pre>
<p>4、结果：</p>
<pre><code>com.ssm.service.IndexService@4d14b6c2
com.ssm.dao.impl.IndexDaoImpl@7e990ed7
 - - - - - - - - - 
com.ssm.service.IndexService@4d14b6c2
com.ssm.dao.impl.IndexDaoImpl@7e990ed7
 - - - - - - - - - 
com.ssm.service.IndexService@4d14b6c2
com.ssm.dao.impl.IndexDaoImpl@7e990ed7
</code></pre>
<p>5、分析：</p>
<p>虽然 IndexDaoImpl 是多例的，但是 IndexDaoImpl 是 IndexService 的一个属性，而 IndexService 是单例的，就造成了每次打印的 IndexDaoImpl 都是一样的。</p>
<p>解决方案一：</p>
<p>1、通过实现 applicationcontext - ware 接口，并在每次 bean A 需要时调用容器的 getBean(“B”) 来请求(通常是一个新的)bean B实例，从而使 bean A 知道容器。</p>
<pre><code class="language-java">@Service
@Scope(&quot;singleton&quot;)
public class IndexService implements ApplicationContextAware {
    @Autowired
    private IndexDao indexDao;
    private ApplicationContext applicationContext;
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
    public void service(){
        System.out.println(this);
       System.out.println(applicationContext.getBean(&quot;indexDaoImpl&quot;));
    }
}
</code></pre>
<p>2、测试结果</p>
<pre><code>com.ssm.service.IndexService@50378a4
com.ssm.dao.impl.IndexDaoImpl@60f00693
 - - - - - - - - - 
com.ssm.service.IndexService@50378a4
com.ssm.dao.impl.IndexDaoImpl@79207381
 - - - - - - - - - 
com.ssm.service.IndexService@50378a4
com.ssm.dao.impl.IndexDaoImpl@491b9b8
</code></pre>
<p>3、分析：单例 IndexService 内引用多例的 IndexDaoImpl，多次获取 IndexDaoImpl，打印的是不同值。</p>
<p>解决方案二：Lookup Method Injection</p>
<p>1、使用 @Lookup 注解</p>
<pre><code class="language-java">@Service
@Scope(&quot;singleton&quot;)
public abstract class IndexService {
    @Lookup
    public abstract IndexDao getIndexDao() ;
    public void service(){
        System.out.println(this);
        System.out.println(getIndexDao());
    }
}
</code></pre>
<p>2、测试结果</p>
<pre><code>com.ssm.service.IndexService$$EnhancerBySpringCGLIB$$8432b830@6b09fb41
com.ssm.dao.impl.IndexDaoImpl@6f43c82
 - - - - - - - - - 
com.ssm.service.IndexService$$EnhancerBySpringCGLIB$$8432b830@6b09fb41
com.ssm.dao.impl.IndexDaoImpl@5db6b9cd
 - - - - - - - - - 
com.ssm.service.IndexService$$EnhancerBySpringCGLIB$$8432b830@6b09fb41
com.ssm.dao.impl.IndexDaoImpl@210ab13f
</code></pre>
<p>3、分析：单例 IndexService 内引用多例的 IndexDaoImpl，多次获取 IndexDaoImpl，打印的是不同值。</p>
<p>官网引导我们参考<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-method-injection">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-method-injection</a></p>
<blockquote>
<p>In most application scenarios, most beans in the container are singletons. When a singleton bean needs to collaborate with another singleton bean or a non-singleton bean needs to collaborate with another non-singleton bean, you typically handle the dependency by defining one bean as a property of the other. A problem arises when the bean lifecycles are different. Suppose singleton bean A needs to use non-singleton (prototype) bean B, perhaps on each method invocation on A. The container creates the singleton bean A only once, and thus only gets one opportunity to set the properties. The container cannot provide bean A with a new instance of bean B every time one is needed.</p>
</blockquote>
<p>在大多数应用程序场景中，容器中的大多数 bean 都是单例的。当一个单例 bean 需要与另一个单例 bean 协作，或者 一个非单例 bean 需要与另一个非单例 bean 协作时，通常通过将一个bean 定义为另一个 bean 的属性来处理依赖性。当 bean 的生命周期不同时，就会出现问题。假设单例 bean A 需要使用非单例(原型) bean B，可能是在 A 的每个方法调用上。<strong>容器只创建一次单例bean A</strong>，因此只有一次机会来设置属性。容器不能每次需要 bean B 的新实例时都向 bean A 提供一个。</p>
<blockquote>
<p>A solution is to forego some inversion of control. You can make bean A aware of the container by implementing the ApplicationContextAware interface, and by making a getBean(&quot;B&quot;) call to the container ask for (a typically new) bean B instance every time bean A needs it. The following example shows this approach:</p>
</blockquote>
<p>解决的办法是放弃一些控制反转。您可以通过实现 applicationcontext - ware 接口，并在每次 bean A 需要时调用容器的 getBean(“B”) 来请求(通常是一个新的)bean B实例，从而使 bean A 知道容器。下面的例子展示了这种方法:</p>
<pre><code class="language-java">// a class that uses a stateful Command-style class to perform some processing
package fiona.apple;

// Spring-API imports
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class CommandManager implements ApplicationContextAware {

    private ApplicationContext applicationContext;

    public Object process(Map commandState) {
        // grab a new instance of the appropriate Command
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    protected Command createCommand() {
        // notice the Spring API dependency!
        return this.applicationContext.getBean(&quot;command&quot;, Command.class);
    }

    public void setApplicationContext(
            ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
}
</code></pre>
<h1 id="spring-生命周期的回调">Spring 生命周期的回调</h1>
<h2 id="spring-生命周期的回调的实现方法">Spring 生命周期的回调的实现方法：</h2>
<blockquote>
<p>Initialization Callbacks AND Destruction Callbacks<br>
The org.springframework.beans.factory.InitializingBean interface lets a bean perform initialization work after the container has set all necessary properties on the bean. The InitializingBean interface specifies a single method:</p>
</blockquote>
<p>org.springframework.beans.factory.InitializingBean 接口允许 bean 在容器设置了 bean 上所有必需的属性之后执行初始化工作。InitializingBean 接口指定了一个方法:</p>
<pre><code class="language-java">void afterPropertiesSet() throws Exception;
</code></pre>
<p>1、创建一个 Dao 接口</p>
<pre><code class="language-java">public interface IndexDao {
    void test();
}
</code></pre>
<p>2、接口实现类，实现 InitializingBean 接口，在调用构造方法后回调 afterPropertiesSet</p>
<pre><code class="language-java">@Repository
public class IndexDaoImpl implements IndexDao, InitializingBean {
    public IndexDaoImpl(){
        System.out.println(&quot;IndexDaoImpl...Constructor&quot;);
    }
    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println(&quot;IndexDaoImpl...init&quot;);
    }
}
</code></pre>
<p>3、测试</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
    }
}
</code></pre>
<p>4、测试结果</p>
<pre><code>IndexDaoImpl...Constructor
IndexDaoImpl...init
</code></pre>
<p>5、分析<br>
在调用构造方法初始化时回调 afterPropertiesSet 方法。</p>
<blockquote>
<p>Implementing the org.springframework.beans.factory.DisposableBean interface lets a bean get a callback when the container that contains it is destroyed. The DisposableBean interface specifies a single method:</p>
</blockquote>
<p>实现 org.springframework.beans.factory.DisposableBean 接口，当包含它的容器被销毁时，可处置bean 接口让 bean 获得一个回调。可处置 bean 接口指定了一个方法:</p>
<pre><code class="language-java">void destroy() throws Exception;
</code></pre>
<pre><code class="language-java">@Repository
public class IndexDaoImpl implements IndexDao, DisposableBean {
    @Override
    public void destroy() throws Exception {
        System.out.println(&quot;IndexDaoImpl...destory&quot;);
    }
}
</code></pre>
<h3 id="default-initialization-and-destroy-methods">Default Initialization and Destroy Methods</h3>
<blockquote>
<p>When you write initialization and destroy method callbacks that do not use the Spring-specific InitializingBean and DisposableBean callback interfaces, you typically write methods with names such as init(), initialize(), dispose(), and so on. Ideally, the names of such lifecycle callback methods are standardized across a project so that all developers use the same method names and ensure consistency.</p>
</blockquote>
<p>当您编写不使用特定于 spring 的 InitializingBean 和 DisposableBean 回调接口的初始化和销毁方法回调时，您通常会编写具有 init()、initialize()、dispose() 等名称的方法。理想情况下，这样的生命周期回调方法的名称在整个项目中是标准化的，这样所有开发人员都可以使用相同的方法名称并确保一致性。</p>
<blockquote>
<p>You can configure the Spring container to “look” for named initialization and destroy callback method names on every bean. This means that you, as an application developer, can write your application classes and use an initialization callback called init(), without having to configure an init-method=&quot;init&quot; attribute with each bean definition. The Spring IoC container calls that method when the bean is created (and in accordance with the standard lifecycle callback contract described previously). This feature also enforces a consistent naming convention for initialization and destroy method callbacks.</p>
</blockquote>
<p>您可以将 Spring 容器配置为在每个bean上“查找”名为 initialization 和 destroy 的回调方法名。这意味着，作为应用程序开发人员，您可以编写应用程序类并使用名为 init() 的初始化回调，而不必为每个bean 定义配置 init-method=&quot;init&quot; 属性。在创建bean时，Spring IoC 容器调用该方法(并根据前面描述的标准生命周期回调契约)。该特性还强制对初始化和销毁方法回调使用一致的命名约定。</p>
<blockquote>
<p>Suppose that your initialization callback methods are named init() and your destroy callback methods are named destroy(). Your class then resembles the class in the following example:</p>
</blockquote>
<p>假设您的初始化回调方法命名为init()，而销毁回调方法命名为destroy()。你的类类似于下面例子中的类:</p>
<pre><code class="language-java">public class DefaultBlogService implements BlogService {

    private BlogDao blogDao;

    public void setBlogDao(BlogDao blogDao) {
        this.blogDao = blogDao;
    }

    // this is (unsurprisingly) the initialization callback method
    public void init() {
        if (this.blogDao == null) {
            throw new IllegalStateException(&quot;The [blogDao] property must be set.&quot;);
        }
    }
}
</code></pre>
<p>然后你可以在一个类似如下的bean中使用这个类:</p>
<pre><code class="language-xml">&lt;beans default-init-method=&quot;init&quot;&gt;

    &lt;bean id=&quot;blogService&quot; class=&quot;com.something.DefaultBlogService&quot;&gt;
        &lt;property name=&quot;blogDao&quot; ref=&quot;blogDao&quot; /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="combining-lifecycle-mechanisms">Combining Lifecycle Mechanisms</h3>
<blockquote>
<p>As of Spring 2.5, you have three options for controlling bean lifecycle behavior:</p>
</blockquote>
<p>从spring2.5开始，你有三个控制bean生命周期行为的选项:</p>
<ul>
<li>The InitializingBean and DisposableBean callback interfaces</li>
<li>Custom init() and destroy() methods</li>
<li>The @PostConstruct and @PreDestroy annotations. You can combine these mechanisms to control a given bean.</li>
</ul>
<pre><code class="language-java">@PostConstruct
public void init(){
    System.out.println(&quot;IndexDaoImpl...init&quot;);
}
</code></pre>
<p>使用不同的初始化方法为同一个bean配置多个生命周期机制，调用方法如下:<br>
1、Methods annotated with @PostConstruct<br>
2、afterPropertiesSet() as defined by the InitializingBean callback interface<br>
3、A custom configured init() method</p>
<h1 id="其他">其他</h1>
<h2 id="using-filters-to-customize-scanning">Using Filters to Customize Scanning</h2>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-scanning-filters">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-scanning-filters</a></p>
<pre><code class="language-java">// 表明这是一个 xml 文件
@Configuration
// 注解扫描包
@ComponentScan(value = &quot;com.ssm&quot;,excludeFilters = {@ComponentScan.Filter(type = FilterType.REGEX, pattern = &quot;com.ssm.service.*&quot;)})
public class SpringConfig {
</code></pre>
<p>测试：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        IndexService indexService = (IndexService) context.getBean(&quot;indexService&quot;);
        indexService.service();

    }
}
</code></pre>
<p>Exception in thread &quot;main&quot; org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named 'indexService' available<br>
分析：自定义扫描过滤 com.ssm.service.* ，于是无法扫描到 IndexService，因此报错没有名为 indexService 的 bean。</p>
<h2 id="providing-qualifier-metadata-with-annotations">Providing Qualifier Metadata with Annotations</h2>
<p>1、当有两个 IndexDao 的实现类时，</p>
<pre><code class="language-java">@Repository
public class IndexDaoImpl implements IndexDao{
</code></pre>
<pre><code class="language-java">@Repository
public class IndexDaoImpl2 implements IndexDao {
</code></pre>
<p>2、Service 类使用 @Autowired 注入 IndexDao</p>
<pre><code class="language-java">@Service
public class IndexService {
    @Autowired
    IndexDao indexDao;
</code></pre>
<p>3、运行报错<br>
Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'com.ssm.dao.IndexDao' available: expected single matching bean but found 2: indexDaoImpl,indexDaoImpl2<br>
4、分析<br>
@Autowired 默认使用 byType 注入，结果发现了两个 IndexDao：IndexDaoImpl、IndexDaoImpl2，注入失败；于是采用 byName 注入（IndexDao indexDao;），在 Spring 容器中寻找 name = indexDao 的，没有找到（有名为 indexDaoImpl 和名为 indexDaoImpl2），注入失败。</p>
<h3 id="解决方案一primary">解决方案一：@Primary</h3>
<pre><code class="language-java">@Repository
@Primary
public class IndexDaoImpl implements IndexDao{
</code></pre>
<p>当向 IndexDaoImpl 类加入 @Primary 注解时，通过 byType 找到两个，于是注入 @Primary 注解修饰的类 IndexDaoImpl。</p>
<h3 id="解决方案二qualifier">解决方案二：@Qualifier</h3>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-scanning-qualifiers">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-scanning-qualifiers</a></p>
<pre><code class="language-java">@Service
public class IndexService {

    @Autowired
    @Qualifier(&quot;indexDaoImpl2&quot;)
    IndexDao indexDao;
</code></pre>
<h2 id="using-the-bean-annotation">Using the @Bean Annotation</h2>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-java-bean-annotation">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-java-bean-annotation</a></p>
<blockquote>
<p>@Bean is a method-level annotation and a direct analog of the XML <bean/> element. The annotation supports some of the attributes offered by <bean/>, such as: * init-method * destroy-method * autowiring * name.</p>
</blockquote>
<p>@Bean是方法级别的注释，是XML <bean/>元素的直接模拟。注释支持<bean/>提供的一些属性，比如:* init-method * destroy-method * autowiring * name。<br>
1、pom.xml</p>
<pre><code class="language-xml">&lt;dependencies&gt;
  &lt;!-- spring-ioc --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.0.9.RELEASE&lt;/version&gt;
  &lt;/dependency&gt;

  &lt;!-- mybatis --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
    &lt;version&gt;3.4.6&lt;/version&gt;
  &lt;/dependency&gt;

  &lt;!-- spring-mybatis --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;1.3.2&lt;/version&gt;
  &lt;/dependency&gt;

  &lt;!-- Spring 数据源 --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;
  &lt;/dependency&gt;

  &lt;!-- mysql --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;5.1.6&lt;/version&gt;
  &lt;/dependency&gt;

&lt;/dependencies&gt;
</code></pre>
<p>2、@Bean 注解的使用</p>
<pre><code class="language-java">// 表明这是一个 xml 文件
@Configuration
// 注解扫描包
@ComponentScan(&quot;com.ssm&quot;)
public class SpringConfig {

    @Bean
    public DataSource dataSource(){
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
        dataSource.setUsername(&quot;root&quot;);
        dataSource.setPassword(&quot;123456&quot;);
        dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);
        return dataSource;
    }

    @Bean
    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){
        SqlSessionFactoryBean sqlSessionFactoryBean =  new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource);
        return sqlSessionFactoryBean;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 并发——CAS 和 AQS]]></title>
        <id>https://epitomm.github.io/post/java-bing-fa-cas-he-aqs/</id>
        <link href="https://epitomm.github.io/post/java-bing-fa-cas-he-aqs/">
        </link>
        <updated>2020-04-29T15:37:33.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>多线程
<ul>
<li>Synchronized Volatile单例</li>
<li>锁：封锁。
<ul>
<li>悲观锁、写（增删改）多，读（查）少Lock</li>
<li>乐观锁：读（查）多、写少版本</li>
</ul>
</li>
<li>1.5 JUC</li>
</ul>
</li>
</ul>
<h1 id="一-cas">一、CAS</h1>
<h2 id="1-概念">1. 概念</h2>
<ul>
<li>CompareAndSet：比较和设置</li>
<li>CompareAndSwap：比较和交换。一种无锁的原子算法，乐观锁。</li>
<li>思想：
<ul>
<li>给你一个期望值，与现有的值比较，如果相等则修改；如果不相等什么事情都不做。</li>
<li>CAS(V,E,N)
<ul>
<li>V：目前拿到的值</li>
<li>E：期望值</li>
<li>N：新值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-作用及优点">2. 作用及优点</h2>
<ul>
<li>CAS 实现稍微复杂，无锁，不存在阻塞，提高了效率，CPU的吞吐量高，性能好。</li>
</ul>
<h2 id="3-实例">3. 实例</h2>
<pre><code class="language-java">package luban;

public class CASDemo1 {

    private static volatile int m = 0;

    public static void increase(){
        m ++;
    }
    public static void main(String[] args){
        for (int i = 0; i &lt; 20; i++) {
            new Thread(() -&gt; {
                CASDemo1.increase();
            }).start();
        }
        System.out.println(m);
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>16
</code></pre>
<p>分析：<br>
m++ 不具有原子性。</p>
<p>修改后：</p>
<pre><code class="language-java">package luban;

/**
 * volatile 变量
 * join()
 */
public class CASDemo3 {

    private static volatile int m = 0;
    public static void increase(){
        m ++;
    }
    public static void main(String[] args) throws InterruptedException {
        Thread[] threads = new Thread[20];
        for (int i = 0; i &lt; threads.length; i++) {
            threads[i] = new Thread(() -&gt; {
                CASDemo3.increase();
            });
            threads[i].start();
            threads[i].join();
        }
        System.out.println(m);
    }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/join.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">join()</p>
<p>反汇编：</p>
<pre><code>javap -c CASDemo3
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/i++.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">i++ 三步操作</p>
<pre><code class="language-java">package luban;

/**
 * AtomicInteger 变量
 * join()
 */

import java.util.concurrent.atomic.AtomicInteger;

public class CASDemo2 {

    private static AtomicInteger atomicI = new AtomicInteger(0);

    public static void increastAtomic(){
        atomicI.incrementAndGet();
    }
    public static void main(String[] args) throws InterruptedException {
        Thread[] threads = new Thread[20];
        for (int i = 0; i &lt; threads.length; i++) {
            threads[i] = new Thread(() -&gt; {
                CASDemo2.increastAtomic();
            });
            threads[i].start();
            threads[i].join();// join()：加入。当前 threads[i] 线程加入到线程组中，当前线程等待 threads[i]线程执行完了之后再执行
        }
        System.out.println(atomicI.get());
    }
}
</code></pre>
<p>反汇编：</p>
<pre><code>javap -c CASDemo2
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/atomicI.incrementAndGet.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">atomicI.incrementAndGet() 实现 i++ 只需一步操作</p>
<h2 id="4-方法摘要">4. 方法摘要</h2>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/atomic%E6%96%B9%E6%B3%95.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">java.util.concurrent.atomic</p>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/AtomicInteger%E6%96%B9%E6%B3%95.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">AtomicInteger 方法摘要</p>
<h2 id="5-原理">5. 原理</h2>
<p>JUC下的atomic类都是通过CAS来实现的，下面就以AtomicInteger为例来阐述CAS的实现。如下：</p>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/AtomicInteger%E7%B1%BB.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">AtomicInteger 类</p>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/getUnsafe.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">JVM 调用底层指令实现 getUnsafe()</p>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/incrementAndGet.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">incrementAndGet() 方法</p>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/getAndAddInt.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">getAndAddInt() 方法</p>
<pre><code class="language-java">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);
// var1：现在拿到的值
// var2：期望的值
// var4:最终改变的值
// var5：最后改变了的值  
</code></pre>
<p>总结：CAS的原子性流程<br>
<img src="https://epitomm.github.io/post-images/Unsafe.png" alt="图片" loading="lazy"></p>
<p style = "text-align:center;font-family:楷体">Unsafe 的返回值是 Atomic::cmpchg(x, addr, e)</p>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/Unsafe_2.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">Atomic::cmpchg(jint exchange_value, volatile jint* dest, jint com)</p>
<p>incrementAndGet -&gt; unsafe.java -&gt; unsafe.cpp -&gt; 汇编 cmpxchg</p>
<p>需要<strong>硬件支持</strong>汇编指令 cmpxchg</p>
<p>Unsafe是CAS的核心类，Java无法直接访问底层操作系统，而是通过本地（native）方法来访问。不过尽管如此，JVM还是开了一个后门：Unsafe，它提供了硬件级别的原子操作。</p>
<h2 id="6-缺点">6. 缺点</h2>
<ul>
<li>无法检测到中间值的变化：A(100) -&gt; B(110) -&gt; A(100)</li>
</ul>
<p>CAS需要检查操作值有没有发生改变，如果没有发生改变则更新。但是存在这样一种情况：如果一个值原来是A，变成了B，然后又变成了A，那么在CAS检查的时候会发现没有改变，但是实质上它已经发生了改变，这就是所谓的ABA问题。</p>
<pre><code class="language-java">package luban;
/**
 * 无法检测到中间值的变化
 */
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class CASDemo4 {

    private static AtomicInteger atomicI = new AtomicInteger(100);

    public static void main(String[] args){
        ExecutorService service = Executors.newCachedThreadPool();
        service.execute(() -&gt; {
            System.out.println(&quot;(1) 100 变为 110：&quot; + atomicI.compareAndSet(100,110));
        });

        service.execute(() -&gt; {
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;(2) 110 变为 100：&quot; + atomicI.compareAndSet(110,100));
        });

        service.execute(() -&gt; {
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;(3) 110 变为 100：&quot; + atomicI.compareAndSet(100,120));
        });

        service.shutdown();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>(1) 100 变为 110：true
(2) 110 变为 100：true
(3) 110 变为 100：true
</code></pre>
<h2 id="7-改进">7. 改进</h2>
<p>类 AtomicStampedReference<V></p>
<p>增加版本号声明：A1(100) -&gt; B2(110) -&gt; A3(100)</p>
<pre><code class="language-java">package luban;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicStampedReference;

public class CASDemo5 {

    // 设置初值时，给定版本号
    private static AtomicStampedReference asr = new AtomicStampedReference(100, 1);
    public static void main(String[] args){
        ExecutorService service = Executors.newCachedThreadPool();
        service.execute(() -&gt; {
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;100 变为 110：&quot; + asr.compareAndSet(100,110,asr.getStamp(), asr.getStamp() + 1));
            System.out.println(&quot;110 变成 100：&quot; +asr.compareAndSet(110,100,asr.getStamp(), asr.getStamp() + 1));
        });
        service.execute(() -&gt; {
            // 得到版本号
            int stamp = asr.getStamp();
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(asr.getStamp());
            System.out.println(stamp);
            System.out.println(&quot;100 变成 120：&quot; +asr.compareAndSet( 100,120,stamp, stamp  + 1));
//            System.out.println(&quot;100 变成 120：&quot; +asr.compareAndSet( 100,120,asr.getStamp(), asr.getStamp()  + 1));
        });
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>100 变为 110：true
110 变成 100：true
3
1
100 变成 120：false
</code></pre>
<p>分析：第一个线程 sleep 2 秒后执行 set，所以第二个线程先 getStamp() 到的stamp 是初始化的，还未修改过的 stamp = 1；而第二个线程 sleep 后的 asr 得到的 stamp = 3，现有值与期望值不同，所以修改失败。<br>
CAS 的应用场景：</p>
<ul>
<li>应用于简单的数据计算。</li>
<li>适合线程冲突少的场景。</li>
</ul>
<h1 id="二-aqs">二、AQS</h1>
<h2 id="1-概念-2">1. 概念</h2>
<ul>
<li>AbstractQueuedSynchronizer</li>
<li>同步发生器</li>
<li>构建 LOCK</li>
<li>JUC：java.util.current</li>
</ul>
<h2 id="2-基本思想">2. 基本思想</h2>
<ul>
<li>通过内置得到 FIFO 同步队列来完成线程争夺资源的管理工作。</li>
</ul>
<h2 id="3-clh同步队列">3. CLH同步队列</h2>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/CLH%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">CLH 同步队列</p>
<pre><code>static final class Node {
    /** Marker to indicate a node is waiting in shared mode */
    static final Node SHARED = new Node(); // 共享
    /** Marker to indicate a node is waiting in exclusive mode */
    static final Node EXCLUSIVE = null; // 排他

    /** waitStatus value to indicate thread has cancelled */
    static final int CANCELLED =  1; // 因中断、完成 退出队列
    /** waitStatus value to indicate successor's thread needs unparking */
    static final int SIGNAL    = -1; // 节点的后继结点被阻塞
    /** waitStatus value to indicate thread is waiting on condition */
    static final int CONDITION = -2; // 条件阻塞
    /**
     * waitStatus value to indicate the next acquireShared should
     * unconditionally propagate
     */
    static final int PROPAGATE = -3; // 共享模式下，头结点的状态
</code></pre>
<h1 id="三-自定义锁">三、自定义锁</h1>
<ul>
<li>AQS 写一个锁（Lock）
<ul>
<li>子类定义为非公共内部帮助器类（私有的内部类继承AQS），写锁的时候的一个帮助器，提供获取或和释放锁的功能。</li>
</ul>
</li>
<li>方法
<ul>
<li>acquire(int arg)：以<strong>独占</strong>模式获取，忽略中断。</li>
<li>acquireShared(int arg)：以<strong>共享</strong>模式获取，忽略中断。</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
</code></pre>
<ul>
<li>tryAcquire(int arg) ：尝试以独占模式获取对象状态。</li>
<li>tryAcquireShared(int arg)：尝试以共享模式获取对象状态 。</li>
</ul>
<pre><code class="language-java">private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    // Try the fast path of enq; backup to full enq on failure
    Node pred = tail;
    if (pred != null) {
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    enq(node);
    return node;
}
</code></pre>
<ul>
<li>release(int arg)：以独占模式释放对象。</li>
<li>releaseShared(int arg)：以共享模式释放对象。</li>
</ul>
<h2 id="实例">实例</h2>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/Lock%E7%B1%BB%E6%96%B9%E6%B3%95.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">Lock 类的方法</p>
<pre><code class="language-java">package luban;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.AbstractQueuedSynchronizer;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;

public class MyLock implements Lock {

    private Helper helper = new Helper();

    private class Helper extends AbstractQueuedSynchronizer{
        // 获取锁
        @Override
        protected boolean tryAcquire(int arg) {
            int state = getState();
            if(state == 0){
                // 利用 CAS 原理修改 state
                if(compareAndSetState(0, arg)){
                    // 设置当前线程占有资源
                    setExclusiveOwnerThread(Thread.currentThread());
                    return true;
                }
            }
            return false;
        }

        // 释放锁
        @Override
        protected boolean tryRelease(int arg) {// arg:信号量
            int state = getState() - arg;
            boolean flag = false;
            // 判断释放后是否为 0
            if(state == 0){
                setExclusiveOwnerThread(null);
                setState(state);
                return true;
            }
            setState(state);//不存在线程安全问题。重入性的问题，已经独占了资源state，其他线程不会干扰
            return false;
        }
        public Condition newConditionObject(){
            return new ConditionObject();
        }
    }
    @Override
    public void lock() {
        helper.acquire(1);
    }

    @Override
    public void lockInterruptibly() throws InterruptedException {
        helper.acquireInterruptibly(1);
    }

    @Override
    public boolean tryLock() {
        return helper.tryAcquire(1);
    }

    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return helper.tryAcquireNanos(1, unit.toNanos(time));
    }

    @Override
    public void unlock() {
        helper.release(1);
    }

    @Override
    public Condition newCondition() {
        return helper.newConditionObject();
    }
}
</code></pre>
<ol>
<li>不加锁的实现有问题</li>
</ol>
<pre><code class="language-java">package luban;
import java.util.concurrent.TimeUnit;

public class Demo {
    private int m = 0;
    private int next(){
        try {
            TimeUnit.SECONDS.sleep(1);
            return m++;
        } catch (InterruptedException e) {
            throw new RuntimeException(&quot;ERROR&quot;);
        }
    }

    public static void main(String[] args){
        Demo demo = new Demo();
        Thread[] th = new Thread[10];
        for(int i = 0 ; i &lt; 10 ; i ++){
            th[i] = new Thread(() -&gt; {
                System.out.println(demo.next());
            });
            th[i].start();
        }
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>1
7
8
6
5
0
4
3
2
0
</code></pre>
<ol start="2">
<li>使用自定义锁的实现正确</li>
</ol>
<pre><code class="language-java">package luban;

public class Demo01 {

    private MyLock lock = new MyLock();

    private int m = 0;

    public int next(){
        lock.lock();
        try {
            return m++;
        } finally{
            lock.unlock();
        }
    }

    public static void main(String[] args){
        Demo01 demo = new Demo01();
        Thread[] th = new Thread[10];
        for(int i = 0 ; i &lt; 10 ; i ++){
            th[i] = new Thread(() -&gt; {
                System.out.println(demo.next());
            });
            th[i].start();
        }
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>0
4
3
2
1
5
6
7
8
9
</code></pre>
<p>上面实现的 MyLock 不具有可重入性。测试：</p>
<pre><code class="language-java">package luban;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Demo02 {

    private MyLock lock = new MyLock();

    private int m = 0;

    public void a(){
        lock.lock();
        System.out.println(&quot;a&quot;);
        b();
        lock.unlock();
    }
    public void b(){
        lock.lock();
        System.out.println(&quot;b&quot;);
        lock.unlock();
    }

    public int next(){
        lock.lock();
        try {
            return m++;
        } finally{
            lock.unlock();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Demo02 demo = new Demo02();
        ExecutorService service = Executors.newCachedThreadPool();
        service.execute(() -&gt; {
            demo.a();
        });
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>a
（阻塞···）
</code></pre>
<h2 id="可重入性">可重入性</h2>
<p>同一个锁对同一资源进行占有的时候，直接分配给这个线程。</p>
<p>【占有锁的线程再次申请锁时仍可获取。获取一次，锁这个变量值(默认为 0) 加一。释放一次，锁这个变量值减一。锁这个变量值为 0 时，说明该锁没有被线程占用。】</p>
<p>对 MyLock 代码进行修改，使其具有可重入性：</p>
<pre><code class="language-java">package luban;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.AbstractQueuedSynchronizer;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;

public class MyLock implements Lock {

    private Helper helper = new Helper();

    private class Helper extends AbstractQueuedSynchronizer{
        // 获取锁
        @Override
        protected boolean tryAcquire(int arg) {
            int state = getState();
            if(state == 0){
                // 利用 CAS 原理修改 state
                if(compareAndSetState(0, arg)){
                    // 设置当前线程占有资源
                    setExclusiveOwnerThread(Thread.currentThread());
                    return true;
                }
            }else if(getExclusiveOwnerThread() == Thread.currentThread()){//可重入
                setState(getState() + arg);
                return true;
            }
            return false;
        }

        // 释放锁
        @Override
        protected boolean tryRelease(int arg) {// arg:信号量
            int state = getState() - arg;
            boolean flag = false;
            // 判断释放后是否为 0
            if(state == 0){
                setExclusiveOwnerThread(null);
                setState(state);
                return true;
            }
            setState(state);//不存在线程安全问题。重入性的问题，已经独占了资源state，其他线程不会干扰
            return false;
        }

        public Condition newConditionObject(){
            return new ConditionObject();
        }
    }
    @Override
    public void lock() {
        helper.acquire(1);
    }

    @Override
    public void lockInterruptibly() throws InterruptedException {
        helper.acquireInterruptibly(1);
    }

    @Override
    public boolean tryLock() {
        return helper.tryAcquire(1);
    }

    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return helper.tryAcquireNanos(1, unit.toNanos(time));
    }

    @Override
    public void unlock() {
        helper.release(1);
    }

    @Override
    public Condition newCondition() {
        return helper.newConditionObject();
    }
}
</code></pre>
<p>测试：</p>
<pre><code class="language-java">package luban;


import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Demo02 {

    private MyLock lock = new MyLock();

    private int m = 0;

    public void a(){
        lock.lock();
        System.out.println(&quot;a&quot;);
        b();
        lock.unlock();
    }
    public void b(){
        lock.lock();
        System.out.println(&quot;b&quot;);
        lock.unlock();
    }

    public int next(){
        lock.lock();
        try {
            return m++;
        } finally{
            lock.unlock();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Demo02 demo = new Demo02();
        ExecutorService service = Executors.newCachedThreadPool();
        service.execute(() -&gt; {
            demo.a();
        });
        service.shutdown();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>a
b
</code></pre>
]]></content>
    </entry>
</feed>