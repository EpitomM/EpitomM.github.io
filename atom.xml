<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://epitomm.github.io</id>
    <title>SSM</title>
    <updated>2020-04-30T15:38:58.330Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://epitomm.github.io"/>
    <link rel="self" href="https://epitomm.github.io/atom.xml"/>
    <subtitle>热心善良的老学姐</subtitle>
    <logo>https://epitomm.github.io/images/avatar.png</logo>
    <icon>https://epitomm.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, SSM</rights>
    <entry>
        <title type="html"><![CDATA[spring-ioc 应用（一）]]></title>
        <id>https://epitomm.github.io/post/spring-ioc/</id>
        <link href="https://epitomm.github.io/post/spring-ioc/">
        </link>
        <updated>2020-04-30T15:17:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="what-is-ioc">what is IOC</h1>
<p><strong>控制反转</strong>（Inversion of Control，缩写为<strong>IOC</strong>），是面向对象编程中的一种<strong>设计原则</strong>，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称<strong>DI</strong>），还有一种方式叫“依赖查找”（Dependency Lookup）</p>
<h2 id="ioc-和-di-的关系">IOC 和 DI 的关系</h2>
<p>IOC 是一种<strong>目标</strong>，DI 是实现 IOC 的<strong>技术手段</strong>。IOC 与 DI 的关系好似 ORM（对象关系映射） 和 Mybatis 的关系一样。</p>
<h2 id="dependency-injection">Dependency Injection</h2>
<ul>
<li>依赖注入</li>
</ul>
<h3 id="关于什么是依赖">关于什么是依赖</h3>
<pre><code class="language-java">// IndexService 依赖了 IndexDao 对象
public class IndexServiceImpl implements IndexService{
  private IndexDao indexDao;
}
</code></pre>
<p><strong>当一个类中拥有一个类的属性，或者构造方法中传了一个值，就可以说：当前这个类依赖于这个属性，或者依赖于构造方法里传入的对象</strong>。</p>
<p>Student 类中有一个 Address 类的属性，Student 类依赖于 Address 属性。</p>
<p>Student 类的构造方法的参数中有一个 Address 类，Student 类依赖于构造方法里传入的 Address 对象。</p>
<pre><code class="language-java">public class Student{
  private String name;
  private Integer age;
  private Address address;
  publci Student(String name,Integer age,Address address){
    this.name = name;
    this.age = age;
    this.address = address;
  }
}

public class Address{
  private String province;
  private String city;
}
</code></pre>
<h1 id="为什么要使用-spring-ioc">为什么要使用 Spring IOC</h1>
<h2 id="面向抽象编程">面向抽象编程</h2>
<pre><code class="language-java">public class IndexServiceImpl implements IndexService{
  public void test(){
     // 这样的写法会造成高耦合
     IndexDao indexDao = new IndexDaoImpl();
  }
}
</code></pre>
<p>假设有一天要对这个 IndexDao 进行一个代理，就不能通过 new 了，而是通过 Proxy.newXXX(); 就需要<strong>更改代码</strong>为：IndexDao indexDao = Proxy.newXXX(); <strong>一个类的产生不应该由程序员自己 new 出来</strong>。</p>
<p>面向抽象编程正确写法：</p>
<pre><code class="language-java">public class IndexServiceImpl implements IndexService{
  private IndexDao indexDao;
    public void test(){
     indexDao.call();
  }
}
</code></pre>
<p>无论 IndexDao 是代理还是本身实现，它都叫做 IndexDao，如果有一天需要一个代理类的话，只需要产生一个代理类，并且把这个代理类的代理对象<strong>传递过来就可以了</strong>。如果有一天不需要这个代理对象了，只需要把这个对象 new 出来传过来就可以了。</p>
<h2 id="如何传递过来呢">如何传递过来呢？</h2>
<p>提供一个 <strong>setter</strong> 或<strong>构造方法</strong>把这个类传递过来。</p>
<pre><code class="language-java">public class IndexServiceImpl implements IndexService{
  // 1.setter 方法
  // 2.构造方法，别人在 new 这个ServiceImpl 时就需要把具体的实现传进来
    public IndexServiceImpl(IndexDao dao){
  }
}
</code></pre>
<h2 id="spring体系结构-ioc的位置">spring体系结构----IOC的位置</h2>
<blockquote>
<p><a href="https://spring.io/projects">https://spring.io/projects</a><br>
Spring Framework<br>
Provides core support for dependency injection, transaction management, web apps, data access, messaging and more.<br>
提供了 DI、事务管理、web 开发和更多的核心支持<br>
<a href="https://spring.io/projects/spring-framework">https://spring.io/projects/spring-framework</a><br>
Features（特点）<br>
Core technologies（核心技术）: dependency injection（DI）, events, resources, i18n, validation, data binding, type conversion, SpEL, AOP.<br>
Testing: mock objects, TestContext framework, Spring MVC Test, WebTestClient.<br>
Data Access: transactions, DAO support, JDBC, ORM, Marshalling XML.<br>
Spring MVC and Spring WebFlux web frameworks.<br>
Integration: remoting, JMS, JCA, JMX, email, tasks, scheduling, cache.<br>
Languages: Kotlin, Groovy, dynamic languages.</p>
</blockquote>
<h2 id="容器">容器</h2>
<p>在日常程序开发过程当中，我们推荐<strong>面向抽象</strong>编程，面向抽象编程会产生<strong>类的依赖</strong>，当然如果你够强大可以自己写一个<strong>管理的容器</strong>，但是既然spring以及实现了，并且spring如此优秀，我们仅仅需要学习spring框架便可。</p>
<p>当我们有了一个管理对象的容器之后，<strong>类的产生过程交给了容器</strong>，至于我们自己的app则可以不需要去关系这些对象的产生了。</p>
<h1 id="spring-实现-ioc-的思路和方法">Spring 实现 IOC 的思路和方法</h1>
<p>Spring 实现 IOC 的思路是<strong>提供一些配置信息用来描述类之间的依赖关系，然后由容器去解析这些配置信息，继而维护好对象之间的依赖关系</strong>，前提是对象之间的依赖关系必须在类中定义好，比如 A.class 中有一个 B.class 的属性，那么我们可以理解为 A 依赖了 B。既然我们在类中已经定义了他们之间的依赖关系那么为什么还需要在配置文件中去描述和定义呢？</p>
<h2 id="spring-实现-ioc-的思路大致可以拆分成-3-点">Spring 实现 IOC 的思路大致可以拆分成 3 点</h2>
<ol>
<li>应用程序中提供类，提供依赖关系（属性或者构造方法）</li>
<li>把需要交给容器管理的<strong>对象</strong>通过配置信息告诉容器（xml、Annotation，JavaConfig）</li>
<li>把各个类之间的<strong>依赖关系</strong>通过配置信息告诉容器</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/springIOC.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>1、定义一个类 A，把类 A 和 类 B 的关系通过应用程序描述出来：类 A 中有一个类 B 的属性<br>
2、将类 A、类 B 交给 Spring 容器进行管理：使用 <bean><br>
3、在 xml 定义中描述类 A、类 B 之间的依赖关系</p>
</blockquote>
<h2 id="既然我们在类中已经定义了他们之间的依赖关系那么为什么还需要在配置文件中去描述和定义呢">既然我们在类中已经定义了他们之间的依赖关系那么为什么还需要在配置文件中去描述和定义呢？</h2>
<p>类中定义了但是 Spring 感知不到你是否需要依赖注入</p>
<p>配置这些信息的方法有三种分别是 xml，Annotation 和 JavaConfig</p>
<p>维护的过程称为<strong>自动注入</strong>，自动注入的方法有两种：**构造方法 **和 <strong>setter</strong></p>
<p>自动注入的值可以是对象，数组，map，list和常量比如字符串整形等</p>
<h1 id="spring编程的风格">spring编程的风格</h1>
<h2 id="schemal-based-xml">schemal-based-------xml</h2>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-schema-declaring-an-aspect">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-schema-declaring-an-aspect</a></p>
<pre><code class="language-xml">&lt;aop:config&gt;
    &lt;aop:aspect id=&quot;myAspect&quot; ref=&quot;aBean&quot;&gt;
        ...
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;

&lt;bean id=&quot;aBean&quot; class=&quot;...&quot;&gt;
    ...
&lt;/bean&gt;
</code></pre>
<h2 id="annotation-based-annotation">annotation-based-----annotation</h2>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-advice-before">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-advice-before</a></p>
<pre><code class="language-java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect
public class BeforeExample {

    @Before(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;)
    public void doAccessCheck() {
        // ...
    }

}
</code></pre>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-required-annotation">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-required-annotation</a></p>
<pre><code class="language-java">public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Required
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
</code></pre>
<h2 id="java-based-java-configuration">java-based----java Configuration</h2>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-java-basic-concepts">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-java-basic-concepts</a></p>
<pre><code class="language-java">@Configuration
public class AppConfig {

    @Bean
    public MyService myService() {
        return new MyServiceImpl();
    }
}
</code></pre>
<h1 id="注入">注入</h1>
<p>想看一部电影，可以有如下两种方法：</p>
<p>① 输入 url 到迅雷，然后下载下来：<strong>依赖查找</strong>：输入一个 url 找到一个资源。</p>
<p>② 下载一个播放器，输入我想要看的类型，就会自动推送这个类型的电影列表。</p>
<p>IOC 也是如此，仅仅需要在代码中提供依赖关系，由容器维护好，自动把对象提供给我们使用，给的过程称之为<strong>注入</strong>。</p>
<p>注入：提供一个 setter 方法或构造方法，Spring 就会把对象给我们。给我们的过程称为注入。</p>
<blockquote>
<p>Spring3 有接口注入，但是从 Spring4 开始就已经取消了。</p>
</blockquote>
<h2 id="spring注入详细配置字符串-数组等">spring注入详细配置（字符串、数组等）</h2>
<p>参考文档：</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-properties-detailed">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-properties-detailed</a></p>
<h3 id="字符串属性注入"><strong>字符串属性注入</strong></h3>
<p>使用 value：<property name="str" value=""/></p>
<pre><code class="language-java">package com.ssm.dao.impl;
import com.ssm.dao.IndexDao;
public class IndexDaoImpl implements IndexDao {
    private String str=&quot;&quot;;
    public void setStr(String str) {
        this.str = str;
    }
    public String getStr() {
        return str;
    }
    @Override
    public void test() {
        System.out.println(&quot;IndexDaoImpl...&quot;);
    }
}
</code></pre>
<pre><code class="language-xml">&lt;bean id=&quot;dao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot;&gt;
    &lt;property name=&quot;str&quot; value=&quot;Hello world&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="language-xml">&lt;bean id=&quot;myDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;
    &lt;!-- results in a setDriverClassName (String) call --&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mydb&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;masterkaoli&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="内部-bean">内部 bean</h3>
<p>原来是通过在 <property ref="xxx"/>，ref 引入外部 bean</p>
<p>内部 bean 是 <property><bean>  ... </bean></property>，在 property 标签内部注入 bean</p>
<pre><code class="language-xml">&lt;bean id=&quot;outer&quot; class=&quot;...&quot;&gt;
    &lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;
    &lt;property name=&quot;target&quot;&gt;
        &lt;bean class=&quot;com.example.Person&quot;&gt; &lt;!-- this is the inner bean --&gt;
            &lt;property name=&quot;name&quot; value=&quot;Fiona Apple&quot;/&gt;
            &lt;property name=&quot;age&quot; value=&quot;25&quot;/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="collections">Collections</h3>
<pre><code class="language-xml">&lt;bean id=&quot;moreComplexObject&quot; class=&quot;example.ComplexObject&quot;&gt;
    &lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;
    &lt;property name=&quot;adminEmails&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;administrator&quot;&gt;administrator@example.org&lt;/prop&gt;
            &lt;prop key=&quot;support&quot;&gt;support@example.org&lt;/prop&gt;
            &lt;prop key=&quot;development&quot;&gt;development@example.org&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeList(java.util.List) call --&gt;
    &lt;property name=&quot;someList&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;a list element followed by a reference&lt;/value&gt;
            &lt;ref bean=&quot;myDataSource&quot; /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeMap(java.util.Map) call --&gt;
    &lt;property name=&quot;someMap&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;an entry&quot; value=&quot;just some string&quot;/&gt;
            &lt;entry key =&quot;a ref&quot; value-ref=&quot;myDataSource&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeSet(java.util.Set) call --&gt;
    &lt;property name=&quot;someSet&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;just some string&lt;/value&gt;
            &lt;ref bean=&quot;myDataSource&quot; /&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="xml-shortcut-with-the-p-namespace">XML Shortcut with the p-namespace</h3>
<blockquote>
<p>Spring supports extensible configuration formats with namespaces, which are based on an XML Schema definition. The beans configuration format discussed in this chapter is defined in an XML Schema document. However, the p-namespace is not defined in an XSD file and exists only in the core of Spring.</p>
<p>Spring 支持带有名称空间的可扩展配置格式，这些名称空间基于XML模式定义。本章讨论的 bean 配置格式是在 XML 模式文档中定义的。但是，p-namespace 并没有在 XSD 文件中定义，它只存在于Spring 的核心中。</p>
</blockquote>
<p>1、在原有的基础上添加 xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 命名空间</p>
<p>2、<bean id="dao" class="com.ssm.dao.impl.IndexDaoImpl" p:str="Hello world"> 注入 等价于 原有的 <property name="str" value="Hello world"/>  注入。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;dao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot; p:str=&quot;Hello world&quot;&gt;
&lt;!--        &lt;property name=&quot;str&quot; value=&quot;Hello world&quot;&gt;&lt;/property&gt;--&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="xml-shortcut-with-the-c-namespace">XML Shortcut with the c-namespace</h3>
<p>如果类中定义了构造函数注入，但 bean 标签内没有声明 <constructor-arg> 就会产生 Caused by: java.lang.NoSuchMethodException: com.ssm.service.IndexService.<init>() 异常</p>
<pre><code>&lt;bean id=&quot;service&quot; class=&quot;com.ssm.service.IndexService&quot;&gt;&lt;!--        &lt;constructor-arg ref=&quot;dao&quot;&gt;&lt;/constructor-arg&gt;--&gt;&lt;/bean&gt;
</code></pre>
<p>使用 c-namespace 注入：<br>
1、添加 xmlns:c=&quot;http://www.springframework.org/schema/c&quot; 命名空间</p>
<p>2、<bean id="service" class="com.ssm.service.IndexService" c:indexDao-ref="dao"> 注入 等价于 原来的     <bean id="service" class="com.ssm.service.IndexService">  <constructor-arg ref="dao"></constructor-arg>  </bean></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;dao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot; p:str=&quot;Hello world&quot;&gt; 
&lt;!--        &lt;property name=&quot;str&quot; value=&quot;Hello world&quot;&gt;&lt;/property&gt;--&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;service&quot; class=&quot;com.ssm.service.IndexService&quot; c:indexDao-ref=&quot;dao&quot;&gt;
&lt;!--        &lt;constructor-arg ref=&quot;dao&quot;&gt;&lt;/constructor-arg&gt;--&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<h2 id="spring-通过-setter-注入的应用实例">Spring 通过 setter 注入的应用实例</h2>
<p>1、pom.xml 导入 spring 依赖</p>
<pre><code class="language-xml">&lt;!-- ioc 90% 以上的内容 --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
  &lt;version&gt;5.0.9.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、应用程序中提供类，提供依赖关系（属性或者构造方法）</p>
<p>IndexDao 类：</p>
<pre><code class="language-java">package com.ssm.dao;

public interface IndexDao {
    void test();
}
</code></pre>
<p>IndexDaoImpl 类：</p>
<pre><code class="language-java">package com.ssm.dao.impl;

import com.ssm.dao.IndexDao;

public class IndexDaoImpl implements IndexDao {

    @Override
    public void test() {
        System.out.println(&quot;IndexDaoImpl...&quot;);
    }
}
</code></pre>
<p>IndexService 依赖 Index：</p>
<p><strong>提供 setter 方法：</strong></p>
<pre><code class="language-java">package com.ssm.service;

import com.ssm.dao.IndexDao;

public class IndexService {

    private IndexDao indexDao;

    public void service(){
        indexDao.test();
    }

    // 提供 setter 方法
    public void setIndexDao(IndexDao indexDao) {
        this.indexDao = indexDao;
    }
}
</code></pre>
<p>3、把需要交给容器管理的对象通过配置信息告诉容器（xml、Annotation，JavaConfig）</p>
<p>4、把各个类之间的依赖关系通过配置信息告诉容器</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;dao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot;&gt;&lt;/bean&gt;

    &lt;bean id=&quot;service&quot; class=&quot;com.ssm.service.IndexService&quot;&gt;
        &lt;property name=&quot;indexDao&quot; ref=&quot;dao&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>5、测试</p>
<pre><code class="language-java">package com.ssm.test;

import com.ssm.service.IndexService;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test {
    public static void main(String[] args) {
        // ClassPathXmlApplicationContext：通过 ClassPath 下的 xml 初始化 Spring 应用环境
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
        IndexService service = (IndexService) context.getBean(&quot;service&quot;);
        service.service();
    }
}
</code></pre>
<p>6、运行结果</p>
<pre><code>IndexDaoImpl...注入的两种方法
</code></pre>
<h3 id="constructor-based-dependency-injection">Constructor-based Dependency Injection</h3>
<p>构造方法注入参考文档：</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-constructor-injection">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-constructor-injection</a></p>
<h4 id="构造方法注入实例">构造方法注入实例</h4>
<pre><code class="language-java">public class IndexService {
    private IndexDao indexDao;
    public IndexService(IndexDao indexDao){
        this.indexDao = indexDao;
    }
    public void service(){
        indexDao.test();
    }
}
</code></pre>
<p>xml 文件：</p>
<pre><code class="language-xml">&lt;bean id=&quot;dao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;service&quot; class=&quot;com.ssm.service.IndexService&quot;&gt;
  &lt;constructor-arg ref=&quot;dao&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5.png" alt="图片" loading="lazy"></figure>
<h3 id="setter-based-dependency-injection">Setter-based Dependency Injection</h3>
<p>setter参考文档：</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-setter-injection">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-setter-injection</a></p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/setter%E6%B3%A8%E5%85%A5.png" alt="图片" loading="lazy"></figure>
<h2 id="注解-xml-混合使用">注解 + xml 混合使用</h2>
<p>1、xml 内 的ref 引用 dao</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;service&quot; class=&quot;com.ssm.service.IndexService&quot; c:indexDao-ref=&quot;dao&quot;&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>2、使用注解声明 dao：</p>
<pre><code class="language-java">@Component(&quot;dao&quot;)
public class IndexDaoImpl implements IndexDao {
</code></pre>
<p>3、报错：找不到 dao</p>
<p>Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named 'dao' available</p>
<p>4、分析：没有开启注解、没有注解扫描</p>
<h3 id="开启注解">开启注解：</h3>
<p>1、xml 中添加 context 相关内容</p>
<pre><code class="language-xml">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
 xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;
</code></pre>
<p>2、开启注解（现在 Spring 版本不写开启注解、只写注解扫描，也能实现功能）</p>
<pre><code class="language-xml">&lt;context:annotation-config /&gt;
</code></pre>
<p>3、开启注解扫描</p>
<pre><code class="language-xml">&lt;context:component-scan base-package=&quot;com.ssm&quot;/&gt;
</code></pre>
<p>将 service 的 bean 声明也使用注解，于是就可以删除 xml 中的 id 为 service 的 bean 标签了。</p>
<pre><code class="language-java">@Service(value = &quot;service&quot;)
public class IndexService {
</code></pre>
<p>完整代码：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!-- 开启注解 --&gt;
    &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt;
    &lt;!-- 开启注解扫描 --&gt;
    &lt;context:component-scan base-package=&quot;com.ssm&quot;&gt;&lt;/context:component-scan&gt;
&lt;/beans&gt;
</code></pre>
<p>4、测试，运行结果：</p>
<pre><code>IndexDaoImpl...
</code></pre>
<p>总结：以上这种注解方式一定需要 xml，因为需要在 xml 内<strong>开启注解扫描</strong>。</p>
<p>有没有办法删掉 xml 呢？答：JavaConfig 配置方式</p>
<h2 id="javaconfig-配置方式">JavaConfig 配置方式</h2>
<p>1、编写配置类</p>
<pre><code class="language-java">package com.ssm.config;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.stereotype.Component;
// 表明这是一个 xml 文件
@Configuration
// 扫描包
@ComponentScan(&quot;com.ssm&quot;)      
public class SpringConfig {
}
</code></pre>
<p>2、修改测试类 Test</p>
<pre><code class="language-java">package com.ssm.test;
import com.ssm.config.SpringConfig;
import com.ssm.service.IndexService;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        IndexService service = (IndexService) context.getBean(&quot;service&quot;);
        service.service();
    }
}
</code></pre>
<p>3、测试，运行结果：</p>
<pre><code>IndexDaoImpl...
</code></pre>
<h2 id="javaconfig-xml-注解配置">JavaConfig + xml +注解配置</h2>
<p>1、Sservice 的注入使用注解方式</p>
<pre><code>@Service(&quot;service&quot;)
public class IndexService {
</code></pre>
<p>2、Dao 的注入使用 xml 方式</p>
<pre><code class="language-java">public class IndexDaoImpl implements IndexDao {
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!-- 开启注解 --&gt;
    &lt;context:annotation-config/&gt;
    &lt;!-- 开启注解扫描 --&gt;
    &lt;context:component-scan base-package=&quot;com.ssm&quot;/&gt;
    &lt;bean id=&quot;dao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot; p:str=&quot;Hello world&quot;&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>3、JavaConfig 配置类引入 xml 文件</p>
<pre><code class="language-java">// 表明这是一个 xml 文件
@Configuration
// 扫描包
@ComponentScan(&quot;com.ssm&quot;)
// 引入 xml 配置文件
@ImportResource(&quot;classpath:spring.xml&quot;)
public class SpringConfig {
}
</code></pre>
<p>4、测试类</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        IndexService service = (IndexService) context.getBean(&quot;service&quot;);
        service.service();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>IndexDaoImpl...
</code></pre>
<h1 id="自动装配">自动装配</h1>
<p>上面说过，IOC 的注入有两个地方需要提供依赖关系，一是类的定义中，二是在spring的配置中需要去描述。自动装配则把第二个取消了，即我们仅仅需要在类中提供依赖，继而把对象交给容器管理即可完成注入。</p>
<p>在实际开发中，描述类之间的依赖关系通常是大篇幅的，如果使用自动装配则省去了很多配置，并且如果对象的依赖发生更新我们可以不需要去更新配置，但是也带来了一定的缺点</p>
<h2 id="自动装配的优点">自动装配的优点</h2>
<p>参考文档：</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire</a></p>
<blockquote>
<p>The Spring container can autowire relationships between collaborating beans. You can let Spring resolve collaborators (other beans) automatically for your bean by inspecting the contents of the ApplicationContext. Autowiring has the following advantages:</p>
</blockquote>
<p>Spring容器可以自动创建协作 bean 之间的关系。通过检查 ApplicationContext 的内容，您可以让 Spring 为您的 bean 自动解析协作者(其他bean)。自动装配有以下优点:</p>
<blockquote>
<p>Autowiring can significantly reduce the need to specify properties or constructor arguments. (Other mechanisms such as a bean template discussed elsewhere in this chapter are also valuable in this regard.)</p>
</blockquote>
<p>自动装配可以大大减少指定属性或构造函数参数的需要。(本章其他地方讨论的其他机制，如bean模板，在这方面也很有价值。)</p>
<blockquote>
<p>Autowiring can update a configuration as your objects evolve. For example, if you need to add a dependency to a class, that dependency can be satisfied automatically without you needing to modify the configuration. Thus autowiring can be especially useful during development, without negating the option of switching to explicit wiring when the code base becomes more stable.</p>
</blockquote>
<p>自动装配可以随着对象的演化更新配置。例如，如果需要向类添加依赖，则可以自动更新该依赖，而不需要修改配置。因此，自动装配在开发过程中特别有用，当代码库变得更加稳定时，自动装配可以避免切换到显式连接的选项。</p>
<pre><code class="language-xml">&lt;bean id=&quot;indexService&quot; class=&quot;com.ssm.service.IndexService&quot;&gt;
    &lt;property name=&quot;indexDao&quot; ref=&quot;dao&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>分析：上述配置需要手动添加依赖，比如现在 IndexService 新增了依赖 helloDao：</p>
<pre><code class="language-java">public class IndexService{
  private IndexDao indexDao;
  private HelloDao helloDao;
}
</code></pre>
<p>就需要在 xml 的 <bean> 内增加 <property name="hello" ref="hello"/></p>
<pre><code class="language-xml">&lt;bean id=&quot;indexService&quot; class=&quot;com.ssm.service.IndexService&quot;&gt;
    &lt;property name=&quot;indexDao&quot; ref=&quot;dao&quot;/&gt;
     &lt;property name=&quot;hello&quot; ref=&quot;hello&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>使用了自动装配后，就无须手动在 xml 中增加依赖进行维护了，<strong>自动装配可以自动更新该依赖，而不需要修改配置</strong>。</p>
<h2 id="自动装配的缺点">自动装配的缺点</h2>
<p>参考文档：</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-autowired-exceptions">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-autowired-exceptions</a></p>
<p>作为我来讲，我觉得以上缺点都不是缺点</p>
<h2 id="自动装配的方法">自动装配的方法</h2>
<p>自动装配的方式参考文档：</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire</a></p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Mode</strong></th>
<th style="text-align:left"><strong>Explanation</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">no ( 不使用自动装配 )</td>
<td style="text-align:left">(默认)没有自动装配。Bean 引用必须由 ref 元素定义。对于较大的部署，不建议更改默认设置，因为显式地指定协作者可以提供更好的控制和清晰度。在某种程度上，它记录了一个系统的结构。</td>
</tr>
<tr>
<td style="text-align:left">byName</td>
<td style="text-align:left">通过属性名自动装配。Spring 寻找与需要自动装配的属性同名的 bean。例如，如果一个 bean 定义被按名称设置为自动装配，并且它包含一个主属性(也就是说，它有一个setMaster(..)方法)，Spring 会查找一个名为master 的 bean 定义并使用它来设置属性。</td>
</tr>
<tr>
<td style="text-align:left">byType</td>
<td style="text-align:left">如果容器中恰好存在该属性类型的一个 bean，则允许自动获取该属性。如果存在多个异常，则抛出一个致命异常，这表明您不能为该 bean 使用byType 自动装配。如果没有匹配的 bean，则什么也不会发生(属性没有设置)。</td>
</tr>
<tr>
<td style="text-align:left">constructor</td>
<td style="text-align:left">类似于 byType，但适用于构造函数参数。如果容器中没有一个构造函数参数类型的 bean，则会引发致命错误。</td>
</tr>
</tbody>
</table>
<h3 id="bytype-自动装配实例">byType 自动装配实例</h3>
<p>1、IndexService 依赖 IndexDao</p>
<pre><code class="language-java">public class IndexService {
    private IndexDao indexDao;
    public void service(){
        indexDao.test();
    }
    public void setIndexDao(IndexDao indexDao) {
        this.indexDao = indexDao;
    }
}
</code></pre>
<p>2、使用自动装配：beans 标签内导入 default-autowire=&quot;byType&quot;</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;
        default-autowire=&quot;byType&quot;&gt;

    &lt;!-- 开启注解 --&gt;
    &lt;context:annotation-config/&gt;
    &lt;!-- 开启注解扫描 --&gt;
    &lt;context:component-scan base-package=&quot;com.ssm&quot;/&gt;

    &lt;bean id=&quot;dao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot;&gt;
    &lt;/bean&gt;

    &lt;!-- IndexService 内应该注入 IndexDao，但因为指定了自动装配，所以可以不显式通过 property 标签注入 IndexDao --&gt;
    &lt;bean id=&quot;indexService&quot; class=&quot;com.ssm.service.IndexService&quot;&gt;
&lt;!--        &lt;property name=&quot;indexDao&quot; ref=&quot;dao&quot;/&gt;--&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>分析：IndexService 内应该注入 IndexDao，但因为通过 default-autowire=&quot;byType&quot; 指定了自动装配，所以可以不显式通过 property 标签注入 IndexDao。</p>
<p>在扫描到 IndexService 类时，发现该类依赖了 IndexDao，发现它的类型是 IndexDao，到 Spring 容器中找类型或父类类型为 IndexDao 的，如果有，就把这个对象直接赋给 IndexService 中的 IndexDao。</p>
<blockquote>
<p>自动装配并不是完全不需要配置了，自动装配仍需要配置 bean，将类交给 Spring 容器管理，自动装配省略了类与类之间依赖的管理，比如类 A 依赖类 B，无需配置依赖关系了，Spring 会自动到容器中找到类 B 然后把它赋给类 A 的成员变量。</p>
</blockquote>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D.png" alt="图片" loading="lazy"></figure>
<h4 id="bytype-自动装配多个相同类型的问题">byType 自动装配多个相同类型的问题</h4>
<p>当有多个相同类型时，会报错</p>
<p>1、添加一个 IndexDaoImpl2 类</p>
<pre><code class="language-java">public class IndexDaoImpl2 implements IndexDao {
    @Override
    public void test() {
        System.out.println(&quot;IndexDaoImpl...2&quot;);
    }
}
</code></pre>
<p>2、把 IndexDaoImpl2 交给 Spring 容器管理，现在 Spring 容器内有两个 type = IndexDao 的类：IndexDaoImp、IndexDaoImpl2</p>
<pre><code class="language-xml">&lt;bean id=&quot;dao2&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl2&quot;/&gt;
</code></pre>
<p>3、测试结果：</p>
<p>Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'com.ssm.dao.IndexDao' available: expected single matching bean but found 2: dao,dao2</p>
<p>需要单个匹配，但是发现了两个：dao、dao2</p>
<h3 id="byname-自动装配实例">byName 自动装配实例</h3>
<p>1、beans 标签内指定 byName 自动装配：</p>
<pre><code>default-autowire=&quot;byName&quot;
</code></pre>
<p>2、如果没有指定 <bean> 标签的 name 属性，name 默认为将 setIndexDao 的 set 去掉、第一个字母小写，即 name=indexDao</p>
<pre><code class="language-java">public class IndexService {
    private IndexDao indexDao;
    public void service(){
        indexDao.test();
    }
    public void setIndexDao(IndexDao indexDao) {
        this.indexDao = indexDao;
    }
}
</code></pre>
<p>3、于是到 Spring 容器内找 name=indexDao 的，没有找到，报错 Exception in thread &quot;main&quot; java.lang.NullPointerException</p>
<pre><code class="language-xml">&lt;bean id=&quot;dao&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl&quot;/&gt;
&lt;bean id=&quot;dao2&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl2&quot;/&gt;
</code></pre>
<p>解决办法一：</p>
<p>1、改变 set 方法的方法名：</p>
<pre><code class="language-java">public void setDao(IndexDao indexDao) {
    this.indexDao = indexDao;
}
</code></pre>
<p>2、测试成功：</p>
<pre><code>IndexDaoImpl...
</code></pre>
<p>解决方法二：</p>
<p>1、set 方法不变</p>
<pre><code>public void setIndexDao(IndexDao indexDao) {
    this.indexDao = indexDao;
 }
</code></pre>
<p>2、给 bean 标签添加 name 属性</p>
<pre><code>&lt;bean id=&quot;dao2&quot; class=&quot;com.ssm.dao.impl.IndexDaoImpl2&quot; name=&quot;indexDao&quot;&gt;&lt;/bean&gt;
</code></pre>
<p>3、测试成功</p>
<pre><code>IndexDaoImpl...2
</code></pre>
<h3 id="default-no-不使用自动装配">default = no 不使用自动装配</h3>
<p>beans 标签内部增加如下说明：</p>
<p>default-autowire=&quot;default&quot;</p>
<p>default=autowire=&quot;no&quot;</p>
<p>异常信息：Exception in thread &quot;main&quot; java.lang.NullPointerException</p>
<p>其他都想手动装配，唯独 IndexService 想自动装配，就不能在 beans 标签内添加 default-autowire 了，可以<strong>为每一个属性单独指定一个 autowire</strong></p>
<pre><code class="language-xml">&lt;bean id=&quot;indexService&quot; class=&quot;com.ssm.service.IndexService&quot; autowire=&quot;byType&quot;/&gt;
</code></pre>
<p>参考资料：<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-stereotype-annotations">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-stereotype-annotations</a></p>
<blockquote>
<p>Spring provides further stereotype annotations: @Component, @Service, and @Controller. @Component is a generic stereotype for any Spring-managed component. @Repository, @Service, and @Controller are specializations of @Component for more specific use cases (in the persistence, service, and presentation layers, respectively). Therefore, you can annotate your component classes with @Component, but, by annotating them with @Repository, @Service, or @Controller instead, your classes are more properly suited for processing by tools or associating with aspects. For example, these stereotype annotations make ideal targets for pointcuts. @Repository, @Service, and @Controller can also carry additional semantics in future releases of the Spring Framework. Thus, if you are choosing between using @Component or @Service for your service layer, @Service is clearly the better choice. Similarly, as stated earlier, @Repository is already supported as a marker for automatic exception translation in your persistence layer.</p>
</blockquote>
<p>Spring提供了更多的的构造型注解:@Component， @Service，和@Controller。@Component 是任何spring管理组件的通用注解。@Repository、@Service和@Controller是@Component对更具体用例(分别在持久性、服务和表示层)的专门化。因此，您可以使用@Component来注释您的组件类，但是，通过使用@Repository、@Service或@Controller来注释它们，您的类更适合通过工具进行处理或与方面相关联。例如，这些构造型注释是切入点的理想目标。在Spring框架的未来版本中，@Repository、@Service和 @Controller 也可以包含额外的语义。因此，如果您在使用@Component或@Service作为服务层之间进行选择，那么@Service显然是更好的选择。类似地，如前所述，@Repository已经被支持作为持久层中自动异常转换的标记。</p>
<h2 id="autowired-默认采用-bytype-注入">@Autowired 默认采用 byType 注入</h2>
<p>1、JavaConfig 配置类</p>
<ul>
<li>声明这是一个注解类</li>
<li>扫描包</li>
</ul>
<pre><code class="language-java">// 表明这是一个 xml 文件
@Configuration
// 注解扫描包
@ComponentScan(&quot;com.ssm&quot;)
public class SpringConfig {
}
</code></pre>
<p>2、@Service 注解</p>
<ul>
<li>@Autowired注入 IndexDao</li>
<li>setIndexDao 方法</li>
</ul>
<pre><code class="language-java">@Service
public class IndexService {
    @Autowired
    private IndexDao indexDao;
    public void service(){
        indexDao.test();
    }
    public void setIndexDao(IndexDao indexDao) {
        this.indexDao = indexDao;
    }
}
</code></pre>
<p>3、IndexDao 类型的 IndexDaoImpl 类</p>
<pre><code class="language-java">@Repository
public class IndexDaoImpl implements IndexDao {
    @Override
    public void test() {
        System.out.println(&quot;IndexDaoImpl...&quot;);
    }
}
</code></pre>
<p>4、相同 IndexDao 类型的 IndexDaoImpl2</p>
<pre><code class="language-java">@Repository
public class IndexDaoImpl2 implements IndexDao {
    @Override
    public void test() {
        System.out.println(&quot;IndexDaoImpl...2&quot;);
    }
}
</code></pre>
<p>5、测试类</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        IndexService service = (IndexService) context.getBean(&quot;indexService&quot;);
        service.service();
    }
}
</code></pre>
<p>6、运行结果：</p>
<p>Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'com.ssm.dao.IndexDao' available: expected single matching bean but found 2: indexDaoImpl,indexDaoImpl2</p>
<p>期望一个匹配的 IndexDao 类型的 bean，却发现了两个：indexDaoImpl、indexDaoImpl2</p>
<p>7、分析</p>
<p>@Autowired 注解默认使用的是 byType 自动装配方式。</p>
<p>当执行 @Autowired 注入时，到 Spring 容器中找 IndexDao 类型或父类为 IndexDao 类型的，结果找到了 IndexDaoImpl、IndexDaoImpl2，注入失败。此时根据 byType 找到多个类，则根据 byName 注入（private IndexDao indexDao;）因为没有名为 indexDao 的组件，所以注入失败。</p>
<p><strong>@Autowired 默认采用 byType 注入，如果 byType 找到多个，则根据 byName 注入</strong>，name 为属性名 indexDaoImpl2（private IndexDao indexDaoImpl2）。当根据 name 值注入时，仅与属性值有关，与 set 方法的方法名无关。</p>
<pre><code class="language-java">@Service
public class IndexService {
    @Autowired
    private IndexDao indexDaoImpl2;
    public void service(){
        indexDaoImpl2.test();
    }
    public void setIndexDao(IndexDao indexDao) {
        this.indexDaoImpl2 = indexDao;
    }
}
</code></pre>
<p>Spring 容器中找到 name 为 indexDaoImpl2 的组件，注入成功</p>
<pre><code class="language-java">@Repositorypublic class IndexDaoImpl2 implements IndexDao {
</code></pre>
<p>运行结果：</p>
<pre><code>IndexDaoImpl...2
</code></pre>
<h2 id="resource-默认采用-byname-注入">@Resource 默认采用 byName 注入</h2>
<pre><code class="language-java">@Resource
private IndexDao indexDaoImpl2;
</code></pre>
<p>@Resource 模式采用 byName 注入，并且 name 的值为属性值 indexDaoImpl2，与 set 方法的名字无关。</p>
<h2 id="spring-默认-bean-名称的生成策略">Spring 默认 bean 名称的生成策略</h2>
<pre><code class="language-java">@Repository
public class IndexDaoImpl implements IndexDao {
</code></pre>
<p>Spring 中如果不显式指定 bean 的名字，默认 bean 的名称为类名首字母变小写，即：indexDaoImpl</p>
<p>参考资料：<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-scanning-name-generator">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-scanning-name-generator</a></p>
<blockquote>
<p>When a component is autodetected as part of the scanning process, its bean name is generated by the BeanNameGenerator strategy known to that scanner. By default, any Spring stereotype annotation (@Component, @Repository, @Service, and @Controller) that contains a name value thereby provides that name to the corresponding bean definition.</p>
</blockquote>
<p>当一个组件作为扫描过程的一部分被自动检测时，它的bean名称由该扫描程序所知道的BeanNameGenerator策略生成。默认情况下，任何包含名称值的Spring构造型注释(@Component、@Repository、@Service和@Controller)都将该名称提供给相应的bean定义。</p>
<blockquote>
<p>If such an annotation contains no name value or for any other detected component (such as those discovered by custom filters), the default bean name generator returns the uncapitalized non-qualified class name. For example, if the following component classes were detected, the names would be myMovieLister and movieFinderImpl:</p>
</blockquote>
<p>如果这样的注释不包含名称值或任何其他检测到的组件(例如由自定义过滤器发现的组件)，则默认bean名称生成器将返回未大写的非限定类名。例如，如果检测到以下组件类，其名称将是myMovieLister和movieFinderImpl:</p>
<pre><code class="language-java">@Service(&quot;myMovieLister&quot;)
public class SimpleMovieLister {
    // ...
}
</code></pre>
<pre><code>@Repository
public class MovieFinderImpl implements MovieFinder {
    // ...
}
</code></pre>
<blockquote>
<p>If you do not want to rely on the default bean-naming strategy, you can provide a custom bean-naming strategy. First, implement the BeanNameGenerator interface, and be sure to include a default no-arg constructor. Then, provide the fully qualified class name when configuring the scanner, as the following example annotation and bean definition show.</p>
</blockquote>
<p>如果不希望依赖默认的 bean 命名策略，可以提供自定义 bean 命名策略。首先，实现BeanNameGenerator 接口，并确保包含一个默认的无参数构造函数。然后，在配置扫描程序时提供完全限定的类名，如下面的注释和 bean 定义示例所示。</p>
<p>如果由于多个自动检测到的组件具有相同的非限定类名(即您可能需要配置一个BeanNameGenerator，该生成器默认为生成的bean名称的完全限定类名。从Spring Framework 5.2.3开始，FullyQualifiedAnnotationBeanNameGenerator位于包org.springframework.context中。注释可以用于这些目的。</p>
<pre><code class="language-java">@Configuration
@ComponentScan(basePackages = &quot;org.example&quot;, nameGenerator = MyNameGenerator.class)
public class AppConfig {
    // ...
}
</code></pre>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;context:component-scan base-package=&quot;org.example&quot;
        name-generator=&quot;org.example.MyNameGenerator&quot; /&gt;
&lt;/beans&gt;
</code></pre>
<h1 id="spring懒加载">spring懒加载</h1>
<p>官网已经解释的非常清楚了：</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lazy-init">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lazy-init</a></p>
<blockquote>
<p>By default, ApplicationContext implementations eagerly create and configure all singleton beans as part of the initialization process. Generally, this pre-instantiation is desirable, because errors in the configuration or surrounding environment are discovered immediately, as opposed to hours or even days later. When this behavior is not desirable, you can prevent pre-instantiation of a singleton bean by marking the bean definition as being lazy-initialized. A lazy-initialized bean tells the IoC container to create a bean instance when it is first requested, rather than at startup.</p>
</blockquote>
<p>默认情况下，ApplicationContext实现将创建和配置所有的单例 bean 作为初始化过程的一部分。通常，这种预实例化是可取的，因为配置或周围环境中的错误会立即被发现，而不是几小时甚至几天之后。当此行为不可取时，您可以通过将 bean 定义标记为延迟初始化来防止单例 bean 的预实例化。延迟初始化的bean 告诉 IoC 容器在第一次请求时创建 bean 实例，而不是在启动时。</p>
<pre><code class="language-xml">&lt;bean id=&quot;lazy&quot; class=&quot;com.something.ExpensiveToCreateBean&quot; lazy-init=&quot;true&quot;/&gt;
&lt;bean name=&quot;not.lazy&quot; class=&quot;com.something.AnotherBean&quot;/&gt;
</code></pre>
<p>您还可以使用 <beans/> 元素上的 default-lazy-init 属性来控制容器级别的延迟初始化，如下面的示例所示：</p>
<figure data-type="image" tabindex="5"><img src="https://images-cdn.shimo.im/AL7NwUqEre0woKxB/image.png!thumbnail" alt="图片" loading="lazy"></figure>
<h1 id="springbean的作用域">springbean的作用域</h1>
<p>文档参考：</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes</a></p>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/SpringBean%E4%BD%9C%E7%94%A8%E5%9F%9F.png" alt="图片" loading="lazy"></figure>
<h2 id="singleton">singleton</h2>
<pre><code class="language-java">@Service@Scope(&quot;singleton&quot;)
public class IndexService {
</code></pre>
<p>测试结果：</p>
<pre><code>com.ssm.service.IndexService@5884a914
IndexDaoImpl...2
com.ssm.service.IndexService@5884a914
</code></pre>
<p>两次获得到的 Service 对象是同一个实例：单例。</p>
<h2 id="prototype">prototype</h2>
<pre><code class="language-java">@Service
@Scope(&quot;prototype&quot;)
public class IndexService {
    @Autowired
    private IndexDao indexDaoImpl2;
    public void service(){
        indexDaoImpl2.test();
    }
}
</code></pre>
<p>测试</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        IndexService service = (IndexService) context.getBean(&quot;indexService&quot;);
        System.out.println(service);
        service.service();
        service = (IndexService) context.getBean(&quot;indexService&quot;);
        System.out.println(service);
    }
}
</code></pre>
<p>结果：</p>
<pre><code>com.ssm.service.IndexService@5884a914
IndexDaoImpl...2
com.ssm.service.IndexService@50378a4
</code></pre>
<p>两次得到的 Service 对象是两个对象：多例。</p>
<h3 id="xml定义方式">xml定义方式</h3>
<pre><code>&lt;bean id=&quot;accountService&quot; class=&quot;com.something.DefaultAccountService&quot; scope=&quot;singleton&quot;/&gt;
</code></pre>
<h3 id="annotation的定义方式">annotation的定义方式</h3>
<pre><code class="language-java">@Service
@Scope(&quot;prototype&quot;)
public class IndexService {
</code></pre>
<h2 id="singleton-beans-with-prototype-bean-dependencies">Singleton Beans with Prototype-bean Dependencies</h2>
<p>意思是在 Singleton 当中引用了一个 Prototype 的 bean 的时候引发的问题：</p>
<p>在单例对象中引用多例 bean，这个多例 bean 就失去了意义。</p>
<p>1、IndexService 单例</p>
<pre><code class="language-java">@Service
@Scope(&quot;singleton&quot;)
public class IndexService {
    @Autowired
    private IndexDao indexDao;
    public void service(){
        System.out.println(this);
        System.out.println(indexDao);
    }
}
</code></pre>
<p>2、IndexDao 多例</p>
<pre><code class="language-java">@Repository
@Scope(&quot;prototype&quot;)
public class IndexDaoImpl implements IndexDao {
</code></pre>
<p>3、测试</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext：注解配置应用程序
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        IndexService service = (IndexService) context.getBean(&quot;indexService&quot;);
        service.service();
        System.out.println(&quot; - - - - - - - - - &quot;);
        service = (IndexService) context.getBean(&quot;indexService&quot;);
        service.service();
        System.out.println(&quot; - - - - - - - - - &quot;);
        service = (IndexService) context.getBean(&quot;indexService&quot;);
        service.service();
    }
}
</code></pre>
<p>4、结果：</p>
<pre><code>com.ssm.service.IndexService@4d14b6c2
com.ssm.dao.impl.IndexDaoImpl@7e990ed7
 - - - - - - - - - 
com.ssm.service.IndexService@4d14b6c2
com.ssm.dao.impl.IndexDaoImpl@7e990ed7
 - - - - - - - - - 
com.ssm.service.IndexService@4d14b6c2
com.ssm.dao.impl.IndexDaoImpl@7e990ed7
</code></pre>
<p>5、分析：</p>
<p>虽然 IndexDaoImpl 是多例的，但是 IndexDaoImpl 是 IndexService 的一个属性，而 IndexService 是单例的，就造成了每次打印的 IndexDaoImpl 都是一样的。</p>
<p>解决方案一：</p>
<p>1、通过实现 applicationcontext - ware 接口，并在每次 bean A 需要时调用容器的 getBean(“B”) 来请求(通常是一个新的)bean B实例，从而使 bean A 知道容器。</p>
<pre><code class="language-java">@Service
@Scope(&quot;singleton&quot;)
public class IndexService implements ApplicationContextAware {
    @Autowired
    private IndexDao indexDao;
    private ApplicationContext applicationContext;
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
    public void service(){
        System.out.println(this);
       System.out.println(applicationContext.getBean(&quot;indexDaoImpl&quot;));
    }
}
</code></pre>
<p>2、测试结果</p>
<pre><code>com.ssm.service.IndexService@50378a4
com.ssm.dao.impl.IndexDaoImpl@60f00693
 - - - - - - - - - 
com.ssm.service.IndexService@50378a4
com.ssm.dao.impl.IndexDaoImpl@79207381
 - - - - - - - - - 
com.ssm.service.IndexService@50378a4
com.ssm.dao.impl.IndexDaoImpl@491b9b8
</code></pre>
<p>3、分析：单例 IndexService 内引用多例的 IndexDaoImpl，多次获取 IndexDaoImpl，打印的是不同值。</p>
<p>解决方案二：Lookup Method Injection</p>
<p>1、使用 @Lookup 注解</p>
<pre><code class="language-java">@Service
@Scope(&quot;singleton&quot;)
public abstract class IndexService {
    @Lookup
    public abstract IndexDao getIndexDao() ;
    public void service(){
        System.out.println(this);
        System.out.println(getIndexDao());
    }
}
</code></pre>
<p>2、测试结果</p>
<pre><code>com.ssm.service.IndexService$$EnhancerBySpringCGLIB$$8432b830@6b09fb41
com.ssm.dao.impl.IndexDaoImpl@6f43c82
 - - - - - - - - - 
com.ssm.service.IndexService$$EnhancerBySpringCGLIB$$8432b830@6b09fb41
com.ssm.dao.impl.IndexDaoImpl@5db6b9cd
 - - - - - - - - - 
com.ssm.service.IndexService$$EnhancerBySpringCGLIB$$8432b830@6b09fb41
com.ssm.dao.impl.IndexDaoImpl@210ab13f
</code></pre>
<p>3、分析：单例 IndexService 内引用多例的 IndexDaoImpl，多次获取 IndexDaoImpl，打印的是不同值。</p>
<p>官网引导我们参考<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-method-injection">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-method-injection</a></p>
<blockquote>
<p>In most application scenarios, most beans in the container are singletons. When a singleton bean needs to collaborate with another singleton bean or a non-singleton bean needs to collaborate with another non-singleton bean, you typically handle the dependency by defining one bean as a property of the other. A problem arises when the bean lifecycles are different. Suppose singleton bean A needs to use non-singleton (prototype) bean B, perhaps on each method invocation on A. The container creates the singleton bean A only once, and thus only gets one opportunity to set the properties. The container cannot provide bean A with a new instance of bean B every time one is needed.</p>
</blockquote>
<p>在大多数应用程序场景中，容器中的大多数 bean 都是单例的。当一个单例 bean 需要与另一个单例 bean 协作，或者 一个非单例 bean 需要与另一个非单例 bean 协作时，通常通过将一个bean 定义为另一个 bean 的属性来处理依赖性。当 bean 的生命周期不同时，就会出现问题。假设单例 bean A 需要使用非单例(原型) bean B，可能是在 A 的每个方法调用上。<strong>容器只创建一次单例bean A</strong>，因此只有一次机会来设置属性。容器不能每次需要 bean B 的新实例时都向 bean A 提供一个。</p>
<blockquote>
<p>A solution is to forego some inversion of control. You can make bean A aware of the container by implementing the ApplicationContextAware interface, and by making a getBean(&quot;B&quot;) call to the container ask for (a typically new) bean B instance every time bean A needs it. The following example shows this approach:</p>
</blockquote>
<p>解决的办法是放弃一些控制反转。您可以通过实现 applicationcontext - ware 接口，并在每次 bean A 需要时调用容器的 getBean(“B”) 来请求(通常是一个新的)bean B实例，从而使 bean A 知道容器。下面的例子展示了这种方法:</p>
<pre><code class="language-java">// a class that uses a stateful Command-style class to perform some processing
package fiona.apple;

// Spring-API imports
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class CommandManager implements ApplicationContextAware {

    private ApplicationContext applicationContext;

    public Object process(Map commandState) {
        // grab a new instance of the appropriate Command
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    protected Command createCommand() {
        // notice the Spring API dependency!
        return this.applicationContext.getBean(&quot;command&quot;, Command.class);
    }

    public void setApplicationContext(
            ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 并发——CAS 和 AQS]]></title>
        <id>https://epitomm.github.io/post/java-bing-fa-cas-he-aqs/</id>
        <link href="https://epitomm.github.io/post/java-bing-fa-cas-he-aqs/">
        </link>
        <updated>2020-04-29T15:37:33.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>多线程
<ul>
<li>Synchronized Volatile单例</li>
<li>锁：封锁。
<ul>
<li>悲观锁、写（增删改）多，读（查）少Lock</li>
<li>乐观锁：读（查）多、写少版本</li>
</ul>
</li>
<li>1.5 JUC</li>
</ul>
</li>
</ul>
<h1 id="一-cas">一、CAS</h1>
<h2 id="1-概念">1. 概念</h2>
<ul>
<li>CompareAndSet：比较和设置</li>
<li>CompareAndSwap：比较和交换。一种无锁的原子算法，乐观锁。</li>
<li>思想：
<ul>
<li>给你一个期望值，与现有的值比较，如果相等则修改；如果不相等什么事情都不做。</li>
<li>CAS(V,E,N)
<ul>
<li>V：目前拿到的值</li>
<li>E：期望值</li>
<li>N：新值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-作用及优点">2. 作用及优点</h2>
<ul>
<li>CAS 实现稍微复杂，无锁，不存在阻塞，提高了效率，CPU的吞吐量高，性能好。</li>
</ul>
<h2 id="3-实例">3. 实例</h2>
<pre><code class="language-java">package luban;

public class CASDemo1 {

    private static volatile int m = 0;

    public static void increase(){
        m ++;
    }
    public static void main(String[] args){
        for (int i = 0; i &lt; 20; i++) {
            new Thread(() -&gt; {
                CASDemo1.increase();
            }).start();
        }
        System.out.println(m);
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>16
</code></pre>
<p>分析：<br>
m++ 不具有原子性。</p>
<p>修改后：</p>
<pre><code class="language-java">package luban;

/**
 * volatile 变量
 * join()
 */
public class CASDemo3 {

    private static volatile int m = 0;
    public static void increase(){
        m ++;
    }
    public static void main(String[] args) throws InterruptedException {
        Thread[] threads = new Thread[20];
        for (int i = 0; i &lt; threads.length; i++) {
            threads[i] = new Thread(() -&gt; {
                CASDemo3.increase();
            });
            threads[i].start();
            threads[i].join();
        }
        System.out.println(m);
    }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/join.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">join()</p>
<p>反汇编：</p>
<pre><code>javap -c CASDemo3
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/i++.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">i++ 三步操作</p>
<pre><code class="language-java">package luban;

/**
 * AtomicInteger 变量
 * join()
 */

import java.util.concurrent.atomic.AtomicInteger;

public class CASDemo2 {

    private static AtomicInteger atomicI = new AtomicInteger(0);

    public static void increastAtomic(){
        atomicI.incrementAndGet();
    }
    public static void main(String[] args) throws InterruptedException {
        Thread[] threads = new Thread[20];
        for (int i = 0; i &lt; threads.length; i++) {
            threads[i] = new Thread(() -&gt; {
                CASDemo2.increastAtomic();
            });
            threads[i].start();
            threads[i].join();// join()：加入。当前 threads[i] 线程加入到线程组中，当前线程等待 threads[i]线程执行完了之后再执行
        }
        System.out.println(atomicI.get());
    }
}
</code></pre>
<p>反汇编：</p>
<pre><code>javap -c CASDemo2
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/atomicI.incrementAndGet.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">atomicI.incrementAndGet() 实现 i++ 只需一步操作</p>
<h2 id="4-方法摘要">4. 方法摘要</h2>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/atomic%E6%96%B9%E6%B3%95.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">java.util.concurrent.atomic</p>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/AtomicInteger%E6%96%B9%E6%B3%95.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">AtomicInteger 方法摘要</p>
<h2 id="5-原理">5. 原理</h2>
<p>JUC下的atomic类都是通过CAS来实现的，下面就以AtomicInteger为例来阐述CAS的实现。如下：</p>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/AtomicInteger%E7%B1%BB.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">AtomicInteger 类</p>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/getUnsafe.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">JVM 调用底层指令实现 getUnsafe()</p>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/incrementAndGet.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">incrementAndGet() 方法</p>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/getAndAddInt.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">getAndAddInt() 方法</p>
<pre><code class="language-java">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);
// var1：现在拿到的值
// var2：期望的值
// var4:最终改变的值
// var5：最后改变了的值  
</code></pre>
<p>总结：CAS的原子性流程<br>
<img src="https://epitomm.github.io/post-images/Unsafe.png" alt="图片" loading="lazy"></p>
<p style = "text-align:center;font-family:楷体">Unsafe 的返回值是 Atomic::cmpchg(x, addr, e)</p>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/Unsafe_2.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">Atomic::cmpchg(jint exchange_value, volatile jint* dest, jint com)</p>
<p>incrementAndGet -&gt; unsafe.java -&gt; unsafe.cpp -&gt; 汇编 cmpxchg</p>
<p>需要<strong>硬件支持</strong>汇编指令 cmpxchg</p>
<p>Unsafe是CAS的核心类，Java无法直接访问底层操作系统，而是通过本地（native）方法来访问。不过尽管如此，JVM还是开了一个后门：Unsafe，它提供了硬件级别的原子操作。</p>
<h2 id="6-缺点">6. 缺点</h2>
<ul>
<li>无法检测到中间值的变化：A(100) -&gt; B(110) -&gt; A(100)</li>
</ul>
<p>CAS需要检查操作值有没有发生改变，如果没有发生改变则更新。但是存在这样一种情况：如果一个值原来是A，变成了B，然后又变成了A，那么在CAS检查的时候会发现没有改变，但是实质上它已经发生了改变，这就是所谓的ABA问题。</p>
<pre><code class="language-java">package luban;
/**
 * 无法检测到中间值的变化
 */
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class CASDemo4 {

    private static AtomicInteger atomicI = new AtomicInteger(100);

    public static void main(String[] args){
        ExecutorService service = Executors.newCachedThreadPool();
        service.execute(() -&gt; {
            System.out.println(&quot;(1) 100 变为 110：&quot; + atomicI.compareAndSet(100,110));
        });

        service.execute(() -&gt; {
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;(2) 110 变为 100：&quot; + atomicI.compareAndSet(110,100));
        });

        service.execute(() -&gt; {
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;(3) 110 变为 100：&quot; + atomicI.compareAndSet(100,120));
        });

        service.shutdown();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>(1) 100 变为 110：true
(2) 110 变为 100：true
(3) 110 变为 100：true
</code></pre>
<h2 id="7-改进">7. 改进</h2>
<p>类 AtomicStampedReference<V></p>
<p>增加版本号声明：A1(100) -&gt; B2(110) -&gt; A3(100)</p>
<pre><code class="language-java">package luban;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicStampedReference;

public class CASDemo5 {

    // 设置初值时，给定版本号
    private static AtomicStampedReference asr = new AtomicStampedReference(100, 1);
    public static void main(String[] args){
        ExecutorService service = Executors.newCachedThreadPool();
        service.execute(() -&gt; {
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;100 变为 110：&quot; + asr.compareAndSet(100,110,asr.getStamp(), asr.getStamp() + 1));
            System.out.println(&quot;110 变成 100：&quot; +asr.compareAndSet(110,100,asr.getStamp(), asr.getStamp() + 1));
        });
        service.execute(() -&gt; {
            // 得到版本号
            int stamp = asr.getStamp();
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(asr.getStamp());
            System.out.println(stamp);
            System.out.println(&quot;100 变成 120：&quot; +asr.compareAndSet( 100,120,stamp, stamp  + 1));
//            System.out.println(&quot;100 变成 120：&quot; +asr.compareAndSet( 100,120,asr.getStamp(), asr.getStamp()  + 1));
        });
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>100 变为 110：true
110 变成 100：true
3
1
100 变成 120：false
</code></pre>
<p>分析：第一个线程 sleep 2 秒后执行 set，所以第二个线程先 getStamp() 到的stamp 是初始化的，还未修改过的 stamp = 1；而第二个线程 sleep 后的 asr 得到的 stamp = 3，现有值与期望值不同，所以修改失败。<br>
CAS 的应用场景：</p>
<ul>
<li>应用于简单的数据计算。</li>
<li>适合线程冲突少的场景。</li>
</ul>
<h1 id="二-aqs">二、AQS</h1>
<h2 id="1-概念-2">1. 概念</h2>
<ul>
<li>AbstractQueuedSynchronizer</li>
<li>同步发生器</li>
<li>构建 LOCK</li>
<li>JUC：java.util.current</li>
</ul>
<h2 id="2-基本思想">2. 基本思想</h2>
<ul>
<li>通过内置得到 FIFO 同步队列来完成线程争夺资源的管理工作。</li>
</ul>
<h2 id="3-clh同步队列">3. CLH同步队列</h2>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/CLH%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">CLH 同步队列</p>
<pre><code>static final class Node {
    /** Marker to indicate a node is waiting in shared mode */
    static final Node SHARED = new Node(); // 共享
    /** Marker to indicate a node is waiting in exclusive mode */
    static final Node EXCLUSIVE = null; // 排他

    /** waitStatus value to indicate thread has cancelled */
    static final int CANCELLED =  1; // 因中断、完成 退出队列
    /** waitStatus value to indicate successor's thread needs unparking */
    static final int SIGNAL    = -1; // 节点的后继结点被阻塞
    /** waitStatus value to indicate thread is waiting on condition */
    static final int CONDITION = -2; // 条件阻塞
    /**
     * waitStatus value to indicate the next acquireShared should
     * unconditionally propagate
     */
    static final int PROPAGATE = -3; // 共享模式下，头结点的状态
</code></pre>
<h1 id="三-自定义锁">三、自定义锁</h1>
<ul>
<li>AQS 写一个锁（Lock）
<ul>
<li>子类定义为非公共内部帮助器类（私有的内部类继承AQS），写锁的时候的一个帮助器，提供获取或和释放锁的功能。</li>
</ul>
</li>
<li>方法
<ul>
<li>acquire(int arg)：以<strong>独占</strong>模式获取，忽略中断。</li>
<li>acquireShared(int arg)：以<strong>共享</strong>模式获取，忽略中断。</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
</code></pre>
<ul>
<li>tryAcquire(int arg) ：尝试以独占模式获取对象状态。</li>
<li>tryAcquireShared(int arg)：尝试以共享模式获取对象状态 。</li>
</ul>
<pre><code class="language-java">private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    // Try the fast path of enq; backup to full enq on failure
    Node pred = tail;
    if (pred != null) {
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    enq(node);
    return node;
}
</code></pre>
<ul>
<li>release(int arg)：以独占模式释放对象。</li>
<li>releaseShared(int arg)：以共享模式释放对象。</li>
</ul>
<h2 id="实例">实例</h2>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/Lock%E7%B1%BB%E6%96%B9%E6%B3%95.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">Lock 类的方法</p>
<pre><code class="language-java">package luban;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.AbstractQueuedSynchronizer;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;

public class MyLock implements Lock {

    private Helper helper = new Helper();

    private class Helper extends AbstractQueuedSynchronizer{
        // 获取锁
        @Override
        protected boolean tryAcquire(int arg) {
            int state = getState();
            if(state == 0){
                // 利用 CAS 原理修改 state
                if(compareAndSetState(0, arg)){
                    // 设置当前线程占有资源
                    setExclusiveOwnerThread(Thread.currentThread());
                    return true;
                }
            }
            return false;
        }

        // 释放锁
        @Override
        protected boolean tryRelease(int arg) {// arg:信号量
            int state = getState() - arg;
            boolean flag = false;
            // 判断释放后是否为 0
            if(state == 0){
                setExclusiveOwnerThread(null);
                setState(state);
                return true;
            }
            setState(state);//不存在线程安全问题。重入性的问题，已经独占了资源state，其他线程不会干扰
            return false;
        }
        public Condition newConditionObject(){
            return new ConditionObject();
        }
    }
    @Override
    public void lock() {
        helper.acquire(1);
    }

    @Override
    public void lockInterruptibly() throws InterruptedException {
        helper.acquireInterruptibly(1);
    }

    @Override
    public boolean tryLock() {
        return helper.tryAcquire(1);
    }

    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return helper.tryAcquireNanos(1, unit.toNanos(time));
    }

    @Override
    public void unlock() {
        helper.release(1);
    }

    @Override
    public Condition newCondition() {
        return helper.newConditionObject();
    }
}
</code></pre>
<ol>
<li>不加锁的实现有问题</li>
</ol>
<pre><code class="language-java">package luban;
import java.util.concurrent.TimeUnit;

public class Demo {
    private int m = 0;
    private int next(){
        try {
            TimeUnit.SECONDS.sleep(1);
            return m++;
        } catch (InterruptedException e) {
            throw new RuntimeException(&quot;ERROR&quot;);
        }
    }

    public static void main(String[] args){
        Demo demo = new Demo();
        Thread[] th = new Thread[10];
        for(int i = 0 ; i &lt; 10 ; i ++){
            th[i] = new Thread(() -&gt; {
                System.out.println(demo.next());
            });
            th[i].start();
        }
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>1
7
8
6
5
0
4
3
2
0
</code></pre>
<ol start="2">
<li>使用自定义锁的实现正确</li>
</ol>
<pre><code class="language-java">package luban;

public class Demo01 {

    private MyLock lock = new MyLock();

    private int m = 0;

    public int next(){
        lock.lock();
        try {
            return m++;
        } finally{
            lock.unlock();
        }
    }

    public static void main(String[] args){
        Demo01 demo = new Demo01();
        Thread[] th = new Thread[10];
        for(int i = 0 ; i &lt; 10 ; i ++){
            th[i] = new Thread(() -&gt; {
                System.out.println(demo.next());
            });
            th[i].start();
        }
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>0
4
3
2
1
5
6
7
8
9
</code></pre>
<p>上面实现的 MyLock 不具有可重入性。测试：</p>
<pre><code class="language-java">package luban;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Demo02 {

    private MyLock lock = new MyLock();

    private int m = 0;

    public void a(){
        lock.lock();
        System.out.println(&quot;a&quot;);
        b();
        lock.unlock();
    }
    public void b(){
        lock.lock();
        System.out.println(&quot;b&quot;);
        lock.unlock();
    }

    public int next(){
        lock.lock();
        try {
            return m++;
        } finally{
            lock.unlock();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Demo02 demo = new Demo02();
        ExecutorService service = Executors.newCachedThreadPool();
        service.execute(() -&gt; {
            demo.a();
        });
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>a
（阻塞···）
</code></pre>
<h2 id="可重入性">可重入性</h2>
<p>同一个锁对同一资源进行占有的时候，直接分配给这个线程。</p>
<p>【占有锁的线程再次申请锁时仍可获取。获取一次，锁这个变量值(默认为 0) 加一。释放一次，锁这个变量值减一。锁这个变量值为 0 时，说明该锁没有被线程占用。】</p>
<p>对 MyLock 代码进行修改，使其具有可重入性：</p>
<pre><code class="language-java">package luban;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.AbstractQueuedSynchronizer;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;

public class MyLock implements Lock {

    private Helper helper = new Helper();

    private class Helper extends AbstractQueuedSynchronizer{
        // 获取锁
        @Override
        protected boolean tryAcquire(int arg) {
            int state = getState();
            if(state == 0){
                // 利用 CAS 原理修改 state
                if(compareAndSetState(0, arg)){
                    // 设置当前线程占有资源
                    setExclusiveOwnerThread(Thread.currentThread());
                    return true;
                }
            }else if(getExclusiveOwnerThread() == Thread.currentThread()){//可重入
                setState(getState() + arg);
                return true;
            }
            return false;
        }

        // 释放锁
        @Override
        protected boolean tryRelease(int arg) {// arg:信号量
            int state = getState() - arg;
            boolean flag = false;
            // 判断释放后是否为 0
            if(state == 0){
                setExclusiveOwnerThread(null);
                setState(state);
                return true;
            }
            setState(state);//不存在线程安全问题。重入性的问题，已经独占了资源state，其他线程不会干扰
            return false;
        }

        public Condition newConditionObject(){
            return new ConditionObject();
        }
    }
    @Override
    public void lock() {
        helper.acquire(1);
    }

    @Override
    public void lockInterruptibly() throws InterruptedException {
        helper.acquireInterruptibly(1);
    }

    @Override
    public boolean tryLock() {
        return helper.tryAcquire(1);
    }

    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return helper.tryAcquireNanos(1, unit.toNanos(time));
    }

    @Override
    public void unlock() {
        helper.release(1);
    }

    @Override
    public Condition newCondition() {
        return helper.newConditionObject();
    }
}
</code></pre>
<p>测试：</p>
<pre><code class="language-java">package luban;


import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Demo02 {

    private MyLock lock = new MyLock();

    private int m = 0;

    public void a(){
        lock.lock();
        System.out.println(&quot;a&quot;);
        b();
        lock.unlock();
    }
    public void b(){
        lock.lock();
        System.out.println(&quot;b&quot;);
        lock.unlock();
    }

    public int next(){
        lock.lock();
        try {
            return m++;
        } finally{
            lock.unlock();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Demo02 demo = new Demo02();
        ExecutorService service = Executors.newCachedThreadPool();
        service.execute(() -&gt; {
            demo.a();
        });
        service.shutdown();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>a
b
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 并发——并发锁和并发工具]]></title>
        <id>https://epitomm.github.io/post/java-bing-fa-bing-fa-suo-he-bing-fa-gong-ju/</id>
        <link href="https://epitomm.github.io/post/java-bing-fa-bing-fa-suo-he-bing-fa-gong-ju/">
        </link>
        <updated>2020-04-28T08:13:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-并发锁">一、并发锁</h1>
<h2 id="reentrantlock">ReentrantLock</h2>
<ul>
<li>一个<strong>可重入互斥Lock</strong>，具有与使用synchronized方法和语句访问的隐式监视锁相同的基本行为和语义，但具有<strong>扩展功能</strong>。</li>
</ul>
<pre><code class="language-java"> class X { 
   
   private final ReentrantLock lock = new ReentrantLock(); 
   // ... 
   
   public void m() { 
     lock.lock(); // block until condition holds 
     try { 
       // ... method body 
     } finally { 
       lock.unlock() 
     } 
  } 
  
} 
</code></pre>
<ul>
<li>构造方法：
<ul>
<li>ReentrantLock()：创建一个 ReentrantLock的实例。</li>
<li>ReentrantLock(boolean fair)：根据给定的<strong>公平</strong>政策创建一个 ReentrantLock的实例。</li>
</ul>
</li>
</ul>
<h2 id="reentrantreadwritelock">ReentrantReadWriteLock</h2>
<ul>
<li>ReadWriteLock</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/ReentrantReadWriteLock.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">ReadWriteLock 类的方法</center>
<ul>
<li>write.unlock()写锁释放之前要加读锁read.lock()：锁降级：从写锁降级到读锁</li>
</ul>
<h1 id="二-并发工具">二、并发工具</h1>
<p>航班查询：APP ---&gt;多个线程到不同的公司查询 ---&gt; 全部线程都查询完毕后，整理结果 result 返回给前台用户。</p>
<h2 id="1-countdownlatch">1. CountDownLatch</h2>
<h3 id="countdownlatch-用法">CountDownLatch 用法</h3>
<ul>
<li>CountDownLatch 类位于java.util.concurrent包下，利用它可以实现类似<strong>计数器</strong>的功能。</li>
<li>比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch 来实现这种功能了。</li>
<li>CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。</li>
</ul>
<h3 id="countdownlatch-如何工作">CountDownLatch 如何工作</h3>
<ul>
<li>构造方法
<ul>
<li>CountDownLatch(int count)：构造一个以给定计数初始化的CountDownLatch。</li>
<li>构造器的计数值（count）实际上就是闭锁需要等待的线程数量。这个值只能被设置一次，而且CountDownLatch 没有提供任何机制去重新设置这个计数值。</li>
<li>与CountDownLatch的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用CountDownLatch.await() 方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</li>
<li>其他N个线程必须引用闭锁对象，因为他们需要通知CountDownLatch对象，他们已经完成了各自的任务。这种通知机制是通过CountDownLatch.countDown() 方法来完成的；每调用一次这个方法，在构造函数中初始化的count值就减1。所以当N个线程都调用了这个方法，count的值等于0，然后主线程就能通过await() 方法，恢复执行自己的任务。</li>
</ul>
</li>
<li>await()
<ul>
<li>使当前线程在锁存器倒计时至零前一直等待，除非线程被中断。</li>
<li>当 count 减少到零时，唤醒当前线程</li>
</ul>
</li>
<li>countDown()
<ul>
<li>递减锁存器的计数，如果计数达到零，则释放所有等待。</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/CountDownLatch.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">CountDownLatch 航班查询流程图</center>
<h3 id="示例">示例</h3>
<pre><code class="language-java">package luban;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
public class FightQueryDemo {
    private static List&lt;String&gt; company = Arrays.asList(&quot;东方航空&quot;,&quot;南方航空&quot;,&quot;海南航空&quot;);
    // 结果列表
    private static List&lt;String&gt; fightList = new ArrayList&lt;&gt;();
    public static void main(String[] args) throws InterruptedException {
        // 出发地
        String origin = &quot;BJ&quot;;
        // 目的地
        String dest = &quot;SH&quot;;
        // 定义门闩
        CountDownLatch latch = new CountDownLatch(company.size());
        // 创建线程池
        ExecutorService service = Executors.newCachedThreadPool();
        // 创建线程
        for (int i = 0; i &lt; company.size(); i++) {
            String name = company.get(i);
            service.execute(() -&gt; {
                // 获取公司名称
                System.out.println(name + &quot;查询从&quot; + origin + &quot;到&quot; + dest + &quot;的机票&quot;);
                // 生成随机数表示此公司机票数量
                int val = new Random().nextInt(10);
                try {
                    TimeUnit.SECONDS.sleep(val);
                    fightList.add(name + &quot;:&quot; + val);
                    System.out.println(name + &quot;查询成功！&quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 这个公司查询完毕，门闩 - 1
                latch.countDown();
            });
        }
        service.shutdown();
        // 等待所有线程结束
        latch.await();
        System.out.println(&quot;==== 查询结果如下 ====&quot;);
        System.out.println(fightList);
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>东方航空查询从BJ到SH的机票
海南航空查询从BJ到SH的机票
南方航空查询从BJ到SH的机票
海南航空查询成功！
南方航空查询成功！
东方航空查询成功！
==== 查询结果如下 ====
[海南航空:6, 南方航空:7, 东方航空:7]
</code></pre>
<h2 id="2-cyclicbarries">2. CyclicBarries</h2>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/CyclicBarries.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">CyclieBarries 模拟运动员跑步比赛</center>
<h3 id="cyclicbarrier用法">CyclicBarrier用法</h3>
<ul>
<li>字面意思<strong>回环栅栏</strong>，通过它可以实现让一组线程等待至某个状态之后再<strong>全部同时执行</strong>。</li>
<li>叫做回环是因为<strong>当所有等待线程都被释放以后</strong>，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用awai() 方法之后，线程就处于barrier了。</li>
<li>赛跑：
<ul>
<li>需要所有的子任务都完成时，才执行主任务，这个时候就可以选择使用CyclicBarrier。</li>
</ul>
</li>
</ul>
<h3 id="基本原理">基本原理：</h3>
<ul>
<li>每个线程执行时，都会碰到一个屏障，直到所有线程执行结束，然后屏障便会打开，使所有线程继续往下执行。</li>
<li>在 CyclicBarrier 的内部定义了一个 Lock 对象，每当一个线调用 await 方法时，将拦截的线程数加减 1，然后判断计数器当前是否等于 0 ，如果不是，进入Lock对象的条件队列等待。如果是，执行 barrierAction 对象的 Runnable 方法，然后将锁的条件队列中的所有线程放入锁等待队列中，这些线程会依次的获取锁、释放锁。</li>
<li>CyclicBarrier的两个<strong>构造函数</strong>：
<ul>
<li>CyclicBarrier（int parties）：声明需要拦截的线程数</li>
<li>CyclicBarrier（int parties，Runnable barierAction）：声明需要拦截的线程数，定义一个等待所有线程到达屏障优先执行的Runnable对象。</li>
</ul>
</li>
</ul>
<pre><code class="language-java">package luban;
import java.util.Random;
import java.util.concurrent.*;
public class RaceDemo {
    public static void main(String[] args) {
        CyclicBarrier barrier = new CyclicBarrier(8);
        ExecutorService service = Executors.newCachedThreadPool();
        for(int i = 0 ; i &lt; 8 ; i++){
            service.execute(() -&gt; {
                try {
                    TimeUnit.SECONDS.sleep(new Random().nextInt(10));
                    System.out.println(Thread.currentThread().getName() + &quot;准备好了&quot;);
                    // 此线程已经准备好，唤醒其他线程
                    barrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
                System.out.println(&quot;选手&quot; + Thread.currentThread().getName() + &quot;起跑&quot;);
            });
        }
        service.shutdown();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>pool-1-thread-8准备好了
pool-1-thread-4准备好了
pool-1-thread-5准备好了
pool-1-thread-2准备好了
pool-1-thread-1准备好了
pool-1-thread-7准备好了
pool-1-thread-3准备好了
pool-1-thread-6准备好了
选手pool-1-thread-6起跑
选手pool-1-thread-8起跑
选手pool-1-thread-5起跑
选手pool-1-thread-4起跑
选手pool-1-thread-3起跑
选手pool-1-thread-7起跑
选手pool-1-thread-1起跑
选手pool-1-thread-2起跑
</code></pre>
<ul>
<li>一般情况下对于两个非常相似的类，我们一般都会想当然地去把他们进行类比。对于CountDownLatch 和CyclicBarrier 两个类，我们可以看到CountDownLatch 类都是一个类似于集结点的概念，很多个线程做完事情之后等待其他线程完成，全部线程完成之后再恢复运行。不同的是CountDownLatch 类需要你自己调用countDown() 方法减少一个计数，然后调用await() 方法即可。而CyclicBarrier 则直接调用await() 方法即可。</li>
<li>所以从上面来看，CountDownLatch更倾向于多个线程合作的情况，等你所有东西都准备好了，我这边就自动执行了。而CyclicBarrier则是我们都在一个地方等你，大家到齐了，大家再一起执行。</li>
</ul>
<h2 id="3-semaphore">3. Semaphore</h2>
<ul>
<li>资源有限共享</li>
<li>停车场为例：</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/Semaphore.png" alt="图片" loading="lazy"></figure>
<pre><code class="language-java">package com.ssm;

import java.util.Random;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

public class CarDemo {
    public static void main(String[] args) throws InterruptedException {
        // 创建 Semaphore
        Semaphore semaphore = new Semaphore(3);
        Thread [] cars = new Thread[10];
        for (int i = 0; i &lt; 10; i++) {
            cars[i] = new Thread(()-&gt;{
                try {
                    // 请求许可
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName() + &quot;可以进入停车场&quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                // 使用资源
                try {
                    int val = new Random().nextInt(5);
                    TimeUnit.SECONDS.sleep(val);
                    System.out.println(Thread.currentThread().getName()+&quot;停留了&quot;+val+&quot;秒&quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 离开（释放资源）
                semaphore.release();
                System.out.println(Thread.currentThread().getName() + &quot;离开了停车场&quot;);
            },&quot;car[&quot;+i+&quot;]&quot;);
            cars[i].start();
        }
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>car[0]可以进入停车场
car[2]可以进入停车场
car[7]可以进入停车场
car[0]停留了0秒
car[0]离开了停车场
car[4]可以进入停车场
car[7]停留了2秒
car[7]离开了停车场
car[8]可以进入停车场
car[2]停留了3秒
car[8]停留了1秒
car[3]可以进入停车场
car[2]离开了停车场
car[5]可以进入停车场
car[8]离开了停车场
car[4]停留了4秒
car[4]离开了停车场
car[1]可以进入停车场
car[3]停留了2秒
car[3]离开了停车场
car[9]可以进入停车场
car[9]停留了0秒
car[9]离开了停车场
car[6]可以进入停车场
car[6]停留了0秒
car[6]离开了停车场
car[1]停留了1秒
car[1]离开了停车场
car[5]停留了3秒
car[5]离开了停车场
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP系列（四）安全的HTTPS]]></title>
        <id>https://epitomm.github.io/post/http-xi-lie-si-an-quan-de-https/</id>
        <link href="https://epitomm.github.io/post/http-xi-lie-si-an-quan-de-https/">
        </link>
        <updated>2020-04-28T04:18:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-http-与-https">一、HTTP 与 HTTPS</h1>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/HTTPS_1.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/HTTPS_2.png" alt="图片" loading="lazy"></figure>
<p>HTTP 协议：超文本传输协议，应用层协议，HTTP 协议通过 请求-响应的方式，在客户端和服务端之间进行通信。HTTP 协议传输<strong>明文</strong>，不安全。</p>
<h2 id="明文信息传输">明文信息传输</h2>
<p>小风向向小萌发出一个请求 “小萌，我喜欢你！” 来表白。</p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E6%98%8E%E6%96%87%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93.png" alt="图片" loading="lazy"></figure>
<h3 id="中间人攻击">中间人攻击</h3>
<p>但是由于传输信息是明文，这个信息可能被某个中间人恶意拦截甚至篡改：<strong>中间人攻击</strong>。</p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E6%98%8E%E6%96%87%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93_%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB.png" alt="图片" loading="lazy"></figure>
<h2 id="加密信息传输">加密信息传输</h2>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93.png" alt="图片" loading="lazy"></figure>
<h3 id="加密算法">加密算法</h3>
<ul>
<li>对称加密：加密、解密使用同一个秘钥</li>
<li>非对称加密：加密、解密使用不同的秘钥，公钥加密私钥解密</li>
</ul>
<h3 id="对称加密传输">对称加密传输</h3>
<p>小风和小萌事先约定好一种加密方式，并且约定一个随机生成的秘钥，后续通信信息的发送方使用秘钥对信息进行加密，信息的接收方使用同一个秘钥对接收到的密文进行解密。</p>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>小风发送聊天请求，小萌回复给小风一个秘钥，小风后面发送的信息都先使用秘钥加密后再发送。后续发送信息都是不可读的密文了。</p>
</blockquote>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93_2.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>如果不知道秘钥，即使拦截到了信息，也没有办法解析和篡改。<br>
但是这样做并不是绝对安全的，虽然在后续的通信中对明文进行了加密，但是<strong>第一次约定加密方式、约定加密方式之后的秘钥的传输</strong>还是用明文。如果第一次通信就已经被拦截了，那么秘钥就会泄露给中间人， 中间人仍可以解密后续所有通信内容。</p>
</blockquote>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93_%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB.png" alt="图片" loading="lazy"></figure>
<h2 id="非对称加密传输">非对称加密传输</h2>
<p>非对称加密的一组秘钥中包含一个公钥和一个私钥，既可以公钥加密私钥解密，也可以私钥加密公钥解密。</p>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_1.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>在小风和小萌建立通信时，小萌首先把自己的公钥 KEY1 发送给小风。</p>
</blockquote>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_2.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>收到小萌的公钥后，小风自己生成一个用于对称加密的公钥 KEY2，这个秘钥是为了后续聊天加密来用的，就是上次被中间人发现的那个秘钥，为了安全不再明文约定发送，而是用刚才接收到的公钥 KEY1 对 KEY2 进行加密，得到 VA3=KEY1(KEY2)，把 VA3 发送给小萌。</p>
</blockquote>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_3.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>小萌可以用自己的非对称加密的私钥，解开公钥 KEY1 的加密，获得了 KEY2 的内容，从此以后用 KEY2 进行加密通信。</p>
</blockquote>
<p>在这个通信过程中，即使中间人一开始就截获了公钥 KEY1，由于不知道私钥是什么，也没有办法去解密。</p>
<h3 id="总结">总结</h3>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_%E6%80%BB%E7%BB%93.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>发送方和接收方都有一套自己的公钥和私钥，公钥是所有人都知道的，私钥只有自己知道。<br>
<strong>发送方使用接收方的公钥进行加密，接收方使用自己的私钥对接收的密文进行解密。</strong></p>
</blockquote>
<h3 id="中间人攻击-2">中间人攻击</h3>
<p>中间人不知道小萌的私钥是什么，但是它截获了小萌的公钥 KEY1 后，可以自己另外生成一对公钥和私钥，把自己的公钥 KEY3 发送给小风，</p>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB_1.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>小风以为 KEY3 就是小萌的公钥，用 KEY3 加密自己生成的对称加密的公钥 KEY2 得到 VA4=KEY3(KEY2)，发送给小萌，中间人用自己的私钥解开 KEY3 加密，获得了 KEY2，然后用小萌发来的 KEY1 重新加密，得到 VAL5，发给小萌。</p>
</blockquote>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB_2.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>两个人的后续通信尽管一直在用 KEY2 做对称加密，但是中间人已经掌握了 KEY2，就可以轻松地解密获取内容了。</p>
</blockquote>
<h2 id="证书机构">证书机构</h2>
<p><img src="https://epitomm.github.io/post-images/%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84_2.png" alt="图片" loading="lazy"></p>
<blockquote>
<p>小萌把自己的公钥 KEY1 发给证书颁发机构去申请证书，证书颁发机构自己有一对公钥和私钥，机构利用自己的私钥来加密 KEY1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过了机构的私钥加密，这样制作完成一个证书，机构把这个证书发给服务端小萌。</p>
</blockquote>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84_3.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>当后续小风向小萌请求通信时，小萌不再返回自己的公钥，而是直接把自己申请的证书返回给小风。</p>
</blockquote>
<figure data-type="image" tabindex="16"><img src="https://epitomm.github.io/post-images/%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84_4.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>小风收到证书后， 验证证书的真伪，各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥，所以，小风只需要知道是哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书的签名。接下来小风按照同样的签名规则，自己生成一个证书签名，如果两个签名一致，说明证书有效，验证成功后，小风就可以放心地再次利用机构的公钥解密出服务端小萌的公钥 KEY1，小风生成自己对应的对称加密的秘钥 KEY2，并且用服务端公钥 KEY1 加密 KEY2 生成 VA3，发送给小萌。</p>
</blockquote>
<figure data-type="image" tabindex="17"><img src="https://epitomm.github.io/post-images/%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84_5.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>小萌用自己的私钥解开加密得到对称加密的秘钥 KEY2，于是两个人可以开始用 KEY2 进行对称加密通信。</p>
</blockquote>
<h1 id="二-https-协议概述">二、HTTPS 协议概述</h1>
<ul>
<li>HTTPS可以认为是HTTP+TLS。</li>
<li>TLS是传输层加密协议，它的前身是SSL协议。</li>
</ul>
<blockquote>
<p>我们默认 TLS 和 SSL 指的是一个东西。</p>
</blockquote>
<figure data-type="image" tabindex="18"><img src="https://epitomm.github.io/post-images/SSL.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>TLS 建立在 传输层和应用层之间，TLS 实际上是 TCP 之上建立了一个加密通道，TLS 协议主要有五个部分：应用数据层协议、握手协议、报警协议、加密消息确认协议、心跳协议。<br>
目前常用的 HTTP 协议是 HTTP1.1，常用的 TLS 协议版本有：TLS1.2、TLS1.1、TLS1.0 和 SSL3.0 这样几个版本。其中 SSL3.0 由于某种攻击，认为 SSL3.0 协议是不安全的。TLS1.0 也存在部分安全漏洞，TLS1.1 和 TLS1.2 暂时没有已知的安全漏洞。</p>
</blockquote>
<h2 id="https-功能介绍">HTTPS 功能介绍</h2>
<blockquote>
<p>HTTP 本身是明文传输，没有经过任何安全处理，比如在百度搜索一个关键字：小米手机，中间人能够查看这个消息并且有可能打电话推销；在使用百度的过程中，搜索返回的结果页面有广告。这里的中间者主要指网络节点，用户数据在浏览器和百度服务器中间传输必须要经过的那些节点。比如 wifi 热点、路由器、防火墙、反向代理、缓存服务器等，在 HTTP 协议下，中间人可随意窃听用户的搜索内容，窃取客户隐私甚至篡改网页，HTTPS 协议就是这些攻击的克星。</p>
</blockquote>
<ul>
<li>内容加密</li>
</ul>
<blockquote>
<p>浏览器到服务器的内容是以加密的形式传输的，中间者无法查看。</p>
<ul>
<li>非对称秘钥交换</li>
<li>对称内容加密<br>
对称加密的第一步：协商加密算法和秘钥，中间人依然可以在第一次通信时，截获加密方式和秘钥，这样有对称内容加密就安全了一些。<br>
非对称加密用公钥和私钥的方式把正常通信的秘钥 KEY2 协商好，但是在协商过程中，有一步骤是服务器把自己的公钥 KEY1 用明文传给客户端，</li>
</ul>
</blockquote>
<ul>
<li>身份认证</li>
</ul>
<blockquote>
<p>证书的存在保证用户访问的是你想访问的服务，在使用慕课看视频，HTTPS 证书保证了此时访问的一定是慕课网，即使被 DNS 劫持到了第三方站点，也会提醒用户没有访问慕课服务，有可能被劫持。</p>
</blockquote>
<ul>
<li>数据完整性</li>
</ul>
<blockquote>
<p>防止内容被第三方冒充或篡改。</p>
</blockquote>
<h2 id="https-原理介绍">HTTPS 原理介绍</h2>
<ul>
<li>内容加密</li>
</ul>
<p>非对称密钥交换</p>
<blockquote>
<p>非对称加密：公钥和私钥的方式把正常通信的 KEY2 协商好，协商的过程中，服务器把自己的公钥 KEY1 用明文传递给客户端，这里面涉及很多高级算法：对称加密的两种模式：流式加密、分组加密。在秘钥交换的过程中，中间人可以截获 KEY1，换成自己的公钥 KEY3，这样一来中间人依然可以获取正常通信时的秘钥，于是引入了数字证书。</p>
</blockquote>
<p>对称内容加密</p>
<blockquote>
<p>对称加密：协商加密算法和秘钥，中间人可以在第一次通信时拦截加密方式和秘钥。</p>
</blockquote>
<ul>
<li>身份认证</li>
</ul>
<p>数字证书</p>
<blockquote>
<p>服务端向权威机构申请证书。<br>
客户端和服务端通信时，服务端先把证书传递给客户端，客户端收到证书后，用证书机构的公钥解密证书签名，然后用签名生成的规则再生成一个签名，对比一致就是真整数，不一致就是假证书。<br>
如果确认是真证书，解密服务器公钥 KEY1，再生成通信用的秘钥 KEY2，用服务器端的公钥 KEY1 加密，发给服务端。</p>
</blockquote>
<h1 id="三-https-使用成本">三、HTTPS 使用成本</h1>
<ul>
<li>证书费用以及更新维护</li>
<li>HTTPS 降低用户访问速度</li>
<li>消耗CPU资源，需要增加大量机器</li>
</ul>
<h1 id="四-https-对性能的影响">四、HTTPS 对性能的影响</h1>
<ul>
<li>协议交互所增加的网络RTT</li>
</ul>
<blockquote>
<p>RTT：往返时延。从发送端发送数据开始，到发送端收到来自接收端的确认总共经过的时延。</p>
</blockquote>
<ul>
<li>加解密相关的计算耗时</li>
</ul>
<h2 id="网络耗时">网络耗时</h2>
<figure data-type="image" tabindex="19"><img src="https://epitomm.github.io/post-images/HTTP%E7%BD%91%E7%BB%9C%E8%80%97%E6%97%B6.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>HTTP 协议访问网站，交互延迟如上图，用户只需要完成 TCP 三次握手，建立 TCP 连接就能直接发送 HTTP 请求获取应用层数据了。除此之外在访问网络的过程中，也没有需要消耗计算资源的地方。</p>
</blockquote>
<figure data-type="image" tabindex="20"><img src="https://epitomm.github.io/post-images/HTTPS%E7%BD%91%E7%BB%9C%E8%80%97%E6%97%B6.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>HTTPS 访问流程如上图。<br>
① TCP 三次握手建立连接，一个 RTT<br>
② HTTP GET 请求服务端返回 302跳转到 HTTPS，一个 RTT 和 302 跳转时延。因为用户不会手动输入 https 访问网站，比如说百度，用户一般输入 baidu.com，而不会直接输入：https://www.baidu.com，所以服务端只能返回 302 强制浏览器跳转到 HTTPS。<br>
③ 而浏览器处理 302 跳转本身也需要耗时，这个耗时暂且不算，302 跳转到 https 服务器之后，由于端口和服务器不一样，所以需要重新完成三次握手，建立 TCP 连接。耗时一个 RTT。<br>
④ TLS 完全握手阶段1，耗时一个 RTT，这个阶段主要完成加密套件的协商和证书的身份确认。这个阶段下，服务端和浏览器会协商出来相同的秘钥交换算法、对称加密算法、内容一致性校验算法、证书签名算法等。<br>
浏览器获取到证书后，校验证书的有效性，比如证书是否过期，是否撤销等，浏览器首先获取证书里的 CA 域名，如果 CA 域名没有命中缓存的话，浏览器需要解析 CA 域名的 DNS，这个 DNS 解析至少耗费一个 RTT。DNS 解析到 ip 后，三次握手，建立 CA 站点的 TCP 连接，耗时一个 RTT，接着浏览器发送 Ocsp 请求获取响应，耗时一个 RTT,<br>
Ocsp：在线证书状态协议，维护服务器和其他网络资源安全性的两种普遍模式之一。另外一个叫做 CRL 证书注销列表。当用户试图访问一个服务器时，在线证书状态协议发送一个对于证书状态信息的请求，服务器会回复一个有效、过期或者未知的响应。协议规定了服务器和客户端应用程序的通信语法，在线证书状态协议给用户到期的证书一个宽限期，这样他们就可以在更新以前的一段时间继续访问到这个服务器。这里就需要发起对于证书状态信息的请求，也需要消耗一个 RTT。<br>
⑤ TLS 完全握手阶段2：秘钥协商，耗时一个 RTT 和计算时间，这个完全握手结束后，浏览器和服务器之间进行应用层也就是 HTTP 的数据传输。这和 HTTP 的方式几乎是相同的。<br>
一共耗时 7 个 RTT。<br>
如果不是第一次请求，比如 CA 域名解析，如果有缓存的话，就无需进行 DNS 解析，就可以减少一个 RTT。</p>
</blockquote>
<h2 id="计算耗时">计算耗时</h2>
<ul>
<li>浏览器计算耗时</li>
</ul>
<blockquote>
<p>浏览器解析证书签名，秘钥交换，应用层数据加密、解密，一致性的交换</p>
</blockquote>
<ul>
<li>服务端计算耗时</li>
</ul>
<blockquote>
<p>秘钥交换，应用层数据加密、解密耗时。<br>
由于客户端 CPU 和操作系统种类比较多，所以计算耗时不能一概而论。</p>
</blockquote>
<h1 id="五-https-常见问题">五、HTTPS 常见问题</h1>
<ul>
<li>https加密是不是需要我在电脑上安装证书/保存密码？</li>
</ul>
<blockquote>
<p>不需要，操作系统、浏览器把这些操作都做好了</p>
</blockquote>
<ul>
<li>https 不就是在http后面加个s，很难么？</li>
</ul>
<blockquote>
<p>HTTPS 包含证书、流量转发、负载均衡......<br>
小型网站不难，大型网站很难</p>
</blockquote>
<ul>
<li>https 解决了所有劫持问题吗？</li>
</ul>
<blockquote>
<p>https 是为了解决中间人攻击，假设在 https 页面中加载了 http 资源，http 资源还是有劫持的风险，客户端、局域网的风险也很大，恶意插件、木马、路由器、DNS 也都非常脆弱。HTTPS 能够在绝大部分下保证互联网访问数据传输的安全性。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP 系列（三）熟悉 HTTP 协议结构和通讯原理]]></title>
        <id>https://epitomm.github.io/post/http-xi-lie-san-shou-xi-http-xie-yi-jie-gou-he-tong-xun-yuan-li/</id>
        <link href="https://epitomm.github.io/post/http-xi-lie-san-shou-xi-http-xie-yi-jie-gou-he-tong-xun-yuan-li/">
        </link>
        <updated>2020-04-27T04:12:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="http-协议之身份认证">HTTP 协议之身份认证</h1>
<h2 id="身份认证信息">身份认证信息</h2>
<ul>
<li>密码</li>
</ul>
<blockquote>
<p>只有本人才知道的字符串信息</p>
</blockquote>
<ul>
<li>动态令牌</li>
</ul>
<blockquote>
<p>仅限本人持有的设备内显示的一次性密码</p>
</blockquote>
<ul>
<li>数字证书</li>
</ul>
<blockquote>
<p>只有本人终端持有的信息</p>
</blockquote>
<ul>
<li>生物认证</li>
</ul>
<blockquote>
<p>指纹、虹膜</p>
</blockquote>
<ul>
<li>IC 卡等</li>
</ul>
<blockquote>
<p>仅限本人持有的</p>
</blockquote>
<blockquote>
<p>身份认证信息时用来核对只有登陆者本人才知道、拥有的信息内容，但是即便对方是假冒用户，只要能够通过用户认证，HTTP 服务器就会默认这是出自于本人的行为。因此掌控机密性的密码不能让其他人得到，更不能轻易被破解。</p>
</blockquote>
<h2 id="常见认证方式">常见认证方式</h2>
<ul>
<li>BASIC 认证（基本认证）</li>
<li>DIGEST 认证（摘要认证）</li>
<li>SSL 客户端认证</li>
<li>FormBase 认证（基于表单认证）</li>
</ul>
<h2 id="basic-认证">BASIC 认证</h2>
<h3 id="什么是-basic-认证">什么是 BASIC 认证</h3>
<ul>
<li>从 HTTP1.0 就定义的一种认证方式，现在仍有一部分网站在使用。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/BASIC%E8%AE%A4%E8%AF%81.png" alt="图片" loading="lazy"></figure>
<ul>
<li>WEB 服务器与通信客户端之间进行的统一认证方式。</li>
</ul>
<h3 id="basic-认证过程">BASIC 认证过程</h3>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/BASIC%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<ul>
<li>客户端发送需要 BASIC 认证的请求资源</li>
<li>当请求的资源需要 BASIC 认证时，服务器会随状态码 401 返回一个 Authorization Required，告诉客户端需要身份认证</li>
<li>接收到状态码 401 的客户端为了通过 BASIC 认证，需要将用户名、密码发送给服务器，发送的字符和内容形式为是用户名和密码，中间用 “：” 拼接，将其经过 Base64 的编码后写入到首部字段 Authorization，并在前面加上“Basic ”，表明要执行的是 Basic 认证，发送给服务器。</li>
<li>服务器端接收到包含首部字段 Authorization 的请求后，会去认证信息的正确性，如果验证通过，返回包含 Request URI 的资源响应，返回的是 200；如果认证失败，继续返回 401，表示认证未通过。</li>
</ul>
<blockquote>
<p>BASIC 认证虽然采用 Base64 的编码方式，但是这不是加密处理，不需要任何附加信息就可以对 Base64 进行解码，由于明文解码后就是用户名和密码，在 HTTP 这样非加密通信的线路上，进行 BASIC 认证的过程中，如果不小心被别人窃听了，被盗的可能性就会非常大。<br>
BASIC 认证在使用上不够便捷灵活，而且不安全，所以并不常用。</p>
</blockquote>
<h2 id="digest-认证">DIGEST 认证</h2>
<h3 id="什么是digest认证">什么是DIGEST认证？</h3>
<ul>
<li>为弥补BASIC认证存在的弱点，从HTTP/1.1起就有了DIGEST认证。</li>
<li>DIGEST 认证同样使用质询/响应的方式，但不会像BASIC认证那样直接发送明文密码。</li>
</ul>
<blockquote>
<p>质询-响应方式：一方先发送认证要求给另一方，使用从另一方接收到的质询码，计算生成响应码，最后将响应码返回给对方进行认证。<br>
因为发送给对方的只是响应摘要，以及由质询码产生的计算结果，所以比 BASIC 认证多了一层保护，密码泄露的可能性也就降低了。</p>
</blockquote>
<h3 id="digest-认证过程">DIGEST 认证过程</h3>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/DIGEST%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<ul>
<li>客户端发送需要 DIGEST 认证的请求</li>
<li>服务端返回状态码 401，同时里面包含一个头部字段，包含质询-响应认证方式所需要的临时质询码，质询码是一个随机数 nonce，一次返回都是 401 响应生成的任意随机的 Base64 编码的字符串，多数情况下，由一串数字、或一串字符或一串其他的组成</li>
<li>接收到 401 状态码的客户端返回的响应中包含 DIGEST 认证必须要的头部字段 Authorization，包含这些信息：Digest username=&quot;xxx&quot;, realm=&quot;DIGEST&quot;, nonce=&quot;xxxxx&quot;, url=&quot;&quot;, response=&quot;&quot; ，其中 realm 和 nonce 就是从服务器端接收和响应的字段。username 是 realm 限定范围内可进行认证的内容，response 存放经过 MD5 算法运算生成的密码字符串。</li>
<li>服务器接收到包含首部字段的 Authorization，服务器端接收到这个请求会确认认证信息的正确性</li>
</ul>
<blockquote>
<p>DIGEST 认证提供了高于 BASIC 认证的安全等级，但是和 HTTPS 客户端认证相比还是很弱。DIGEST 认证提供了 <strong>“防止密码被窃听</strong>” 的保护机制，但是并不存在 “<strong>防止用户伪装</strong>” 的保护机制。DIGEST 认证和 BASIC 认证一样，使用上不那么便捷灵活，安全性不够，适用范围有限。<br>
使用用户名、密码的认证方式，只要二者的内容正确就可以认为是本人的行为，但是如果用户名和密码被盗，就很有可能<strong>被第三方冒充</strong>。所以利用 SSL 客户端认证，就可以避免这种情况的发生。</p>
</blockquote>
<h2 id="ssl客户端认证">SSL客户端认证</h2>
<ul>
<li>SSL 客户端认证是借由HTTPS的客户端<strong>证书</strong>完成认证的方式。凭借客户端证书认证，服务器可确认访问是否来自已登录的客户端。</li>
</ul>
<blockquote>
<p>银行网银：先输入用户名、密码，输入正确后下载它们的证书，下载好之后，以后每次登录会把证书也通过 HTTP 报文的方式发给服务器，开始通信。<br>
细节过程：①当服务器接收到需要认证资源的请求，服务器给客户端发送一个报文要求客户端提供客户端证书，②用户选择将发送的客户端证书后，客户端会把客户端证书信息以报文方式发送给服务器，③服务器验证客户端证书，验证通过后，就可以领取证书内客户端的公开秘钥，然后开始 HTTPS 的加密通信。</p>
</blockquote>
<h2 id="基于表单的认证">基于表单的认证</h2>
<ul>
<li>基于表单的认证方法并不是在HTTP协议中定义的。</li>
<li>使用由Web应用程序各自实现基于表单的认证方式。</li>
<li>通过Cookie和Session的方式来保持用户的状态。</li>
</ul>
<h1 id="http-的长连接与短连接">HTTP 的长连接与短连接</h1>
<blockquote>
<p>资源消耗的优化：长连接。<br>
连接好比从 A 地到 B 地的交通方式，想从 A 地到 B 地，打车过去，这样是一个短连接，就连通了一下，没办法让更多的人上车；后来发现从 A 去 B 的人很多，于是开通了一条地铁线，建立了一条长连接，很多人都可以复用这个连接。<br>
能一次性节约很多资源的、服务很多次的是长连接。</p>
</blockquote>
<ul>
<li>HTTP协议是基于请求/响应模式的，因此只要服务端给了响应，本次HTTP请求就结束了。</li>
<li>HTTP的长连接和短连接本质上是<strong>TCP长连接和短连接</strong>。</li>
</ul>
<blockquote>
<p>HTTP 协议是应用层协议，传输层使用的是 TCP 协议，网络层使用的是IP 协议，IP 协议主要解决网络路由、寻址的问题， TCP 协议解决的是如何在 IP 层之上可靠的传递数据包，使得在接收端能收到发送方发送的所有包，并且顺序与发出顺序一致。<br>
HTTP 分成长连接和短连接，本质上就是 TCP 连接。TCP 连接是一个双向通道，可以保持一段时间不关闭，因此 TCP 连接才有真正的长连接和短连接。</p>
</blockquote>
<ul>
<li>HTTP/1.0中，默认使用的是<strong>短连接</strong>。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，结束就中断。</li>
</ul>
<blockquote>
<p>如果客户端浏览器访问某个 html，该 html 内包含其他 js、css、img 资源，当浏览器每遇到一个 web 资源，就会建立一个 HTTP 会话。</p>
</blockquote>
<ul>
<li>HTTP/1.1起，默认使用<strong>长连接</strong>，用以保持连接特性。</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/HTTP%E9%95%BF%E8%BF%9E%E6%8E%A5.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>使用长连接的情况时，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接，这个 keep-alive 不会永久保持连接，有一个保持时间，在不同的服务器软件可以设置。</p>
</blockquote>
<ul>
<li>短连接：</li>
</ul>
<p>建立连接一数据传输一关闭连接..建立连接一数据传输一关闭连接</p>
<blockquote>
<p>客户端向服务器发送连接请求，Server 接到请求，双方建立连接，客户端向 Server 发送消息，Server 回应 Client，一次读写就完成了，这时候双方任何一个都可以发起 close 关闭的操作，一般都是 Client 先发起 close。短连接一般只会在 Client-Server 间传递一次读写操作。</p>
</blockquote>
<ul>
<li>长连接：</li>
</ul>
<p>建立连接—数据传输…（保持连接）.…数据传输——关闭连接</p>
<blockquote>
<p>Client 向 Server 发起连接请求，Server 接受 Client 的请求，双方建立连接，Client 与 Server 完成一次读写之后，它们之间的连接不会主动关闭，后续的读写操作会继续使用这个连接。<br>
短连接对于服务器来说，它的管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段，但如果客户请求频繁，将在 TCP 建立和关闭的操作上浪费时间也浪费带宽，响应的反应速度就会变慢，客户体验感不好。<br>
长连接可以省去较多的 TCP 连接和关闭的时间，减少浪费、节约时间，对于频繁请求资源的客户来说，比较适合使用长连接。在长连接的应用场景下， Client 端一般不会主动关闭连接，与短连接不同，Client 与 Server 之间的连接如果一直不关闭的话，就会存在问题：随着客户端连接越来越多，Server 承受不住，这时 Server 端需要采取一些策略，比如说，关闭一些长时间没有读写事件发生的连接，可以避免一些恶意连接导致 Server 端服务受损。</p>
</blockquote>
<h1 id="http-中介之代理">HTTP 中介之代理</h1>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/HTTP%E4%B8%AD%E4%BB%8B%E4%B9%8B%E4%BB%A3%E7%90%86.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>一般情况下是客户端直接与服务器连接，但是出于不方便或是其他的特殊原因，可能会通过一个中间人与服务器连接。这个中间人就叫做 <strong>web 代理</strong>，这个中间人<strong>既是客户端、又是服务端</strong>，对于服务器来说，由于请求是从代理访问过来的，所以在这个过程中，代理起到了客户端的作用；而对于真正的客户端来说，请求是发给代理的，所以代理起到了服务器的作用。</p>
</blockquote>
<h2 id="代理的作用">代理的作用</h2>
<ul>
<li>抓包</li>
</ul>
<blockquote>
<p>为了能够更好的分析 HTTP 请求，或者达到安全措施的目的，只有使用代理才可以更好的对客户端的数据包进行拦截，在这里代理的名字有另外一种叫法：拦截服务器</p>
</blockquote>
<ul>
<li>FQ</li>
</ul>
<blockquote>
<p>如果想通过计算机访问 facebook，由于长城防火墙屏蔽了 facebook、YouTube 这些网站，不可直接访问，就要通过代理翻墙。</p>
</blockquote>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/FQ.png" alt="图片" loading="lazy"></figure>
<ul>
<li>匿名访问</li>
</ul>
<blockquote>
<p>HTTP 协议本身具有匿名性，HTTP 代理服务器通过删除 HTTP 报文中的身份特性，比如客户端的 IP 地址、Cookie、会话 ID 等，从而对远端的服务器隐藏原始用户的 IP 地址以及其他细节，同时 HTTP 代理服务器上也不会记录原始用户访问记录，就使得代理上网的客户可以在更加安全隐秘的环境中访问网络。</p>
</blockquote>
<ul>
<li>过滤器</li>
</ul>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E8%BF%87%E6%BB%A4%E5%99%A8.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>HTTP 协议并不知道在访问网络的是谁，即便是个小朋友登上父母的账号进行访问，认证起来我们也认为他就是他的父母。通过代理服务器进行分析和部分请求的拦截，进一步加强对网络的控制。</p>
</blockquote>
<h1 id="http-中介之网关">HTTP 中介之网关</h1>
<ul>
<li>网关可以作为某种翻译器使用，它抽象出了一种能够到达资源的方法。网关是资源和应用程序之间的粘合剂。</li>
<li>网关扮演的是“协议转换器”的角色。</li>
</ul>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/HTTP%E4%B8%AD%E4%BB%8B%E4%B9%8B%E7%BD%91%E5%85%B3.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>代理连接的是两个或多个使用相同协议的应用程序。<br>
网关连接的是两个或多个使用不同协议的端点，网关扮演的是 “<strong>协议转换器</strong>” 的角色，网关可以向数据库发送查询数据、发邮件、生成动态内容。</p>
</blockquote>
<h2 id="web-网关">WEB 网关</h2>
<ul>
<li>Web网关在一侧使用HTTP协议，在另一侧使用另一种协议。</li>
</ul>
<p>&lt;客户端协议&gt;/&lt;服务器端协议&gt;</p>
<p>①（HTTP/）服务器端网关：通过HTTP协议与客户端对话，通过其他协议与服务器通信。</p>
<blockquote>
<p>发邮件就是服务器端网关，客户端是 HTTP 协议，邮件服务器是 SMTP 协议</p>
</blockquote>
<p>②（/HTTP）客户端网关：通过其他协议与客户端对话，通过HTTP协议与服务器通信。</p>
<h2 id="常见的网关类型">常见的网关类型</h2>
<ul>
<li>（HTTP/*）服务器端Web网关</li>
</ul>
<blockquote>
<p>客户端发送 HTTP 请求，服务器端 web网关会把这个请求转换为其他协议与服务器进行连接，完成获取资源后，会将对象放在一条 HTTP 响应中，发送给客户端：发邮件。</p>
</blockquote>
<ul>
<li>（HTTP/HTTPS）服务器端安全网关</li>
</ul>
<blockquote>
<p>客户端发送 HTTP 请求，网关自动进行加密，加密来自客户端的请求，然后再发送给服务器，为了安全问题。</p>
</blockquote>
<ul>
<li>（HTTPS/HTTP）客户端安全加速器网关</li>
</ul>
<blockquote>
<p>客户端发送的请求是经过加密的安全的 HTTPS ，通过网关进行解密后再向 web 服务器发送普通的 HTTP 请求。</p>
</blockquote>
<ul>
<li>资源网关</li>
</ul>
<blockquote>
<p>客户端通过 HTTP 连接到应用程序的服务器，服务器并不回送文件，而是将请求通过网关 API 发送给运行在服务器上的应用程序，应用程序将请求资源回送给客户端。</p>
</blockquote>
<h1 id="http-缓存">HTTP 缓存</h1>
<h2 id="为什么要使用http缓存">为什么要使用HTTP缓存？</h2>
<p>请求一次服务器，请求头大小 1KB，响应头大小 1KB，请求的文件大小 10KB，一次请求的流量就是 12KB，10 次就是 120KB，n 次请求就是 12*n KB。</p>
<ul>
<li><strong>客户端</strong>每次都要请求服务器，浪费<strong>流量</strong>。</li>
<li><strong>服务器</strong>每次都提供查找、下载，请求用户基数如果太大，服务器就会存在很大<strong>压力</strong>。</li>
<li><strong>客户端</strong>每次请求完都要进行页面渲染，<strong>用户体验差</strong>。</li>
</ul>
<p>是否可以将请求的文件存放起来使用：HTTP 缓存。</p>
<h2 id="缓存的内容又是什么">缓存的内容又是什么？</h2>
<p>主要针对样式：CSS、JS、图片这一系列更新频率不大的<strong>静态文件</strong>进行缓存。</p>
<blockquote>
<p>缓存是通过什么实现的？请求头-响应头</p>
</blockquote>
<h2 id="http缓存头部字段">HTTP缓存头部字段</h2>
<ul>
<li>Cache-Control请求/响应头，缓存控制字段</li>
</ul>
<blockquote>
<p>控制 HTTP 缓存的最高指令，要不要缓存也是 Cache-Control 说了算。</p>
</blockquote>
<p>no-store：所有内容都不缓存。</p>
<p>no-cache：缓存，但是浏览器使用缓存前，都会请求服务器判断缓存资源是否是最新。</p>
<p>max-age=X（单位秒）请求缓存后的X秒不再发起请求。</p>
<p>s-maxage=X（单位秒）代理服务器请求源站缓存后的X秒不再发起请求，只对CDN缓存有效。</p>
<p>public：客户端和代理服务器（CDN）都可缓存。</p>
<p>private：只有客户端可以缓存。</p>
<ul>
<li>Expires</li>
</ul>
<p>响应头，代表资源过期时间，由服务器返回提供，是http1.0的属性，在与max-age共存的情况下，优先级要低。</p>
<ul>
<li>Last-Modified</li>
</ul>
<p>响应头，资源最新修改时间，由服务器告诉浏览器。</p>
<ul>
<li>if-Modified-Since</li>
</ul>
<p>请求头，资源最新修改时间，由浏览器告诉服务器，和Last-Modified是一对，它两会进行对比。</p>
<ul>
<li>Etag</li>
</ul>
<p>响应头，资源标识，由服务器告诉浏览器。</p>
<ul>
<li>if-None-Match</li>
</ul>
<p>请求头，缓存资源标识，由浏览器告诉服务器（其实就是上次服务器给的Etag），和Etag是一对，它两会进行对比。</p>
<h2 id="http缓存工作方式">HTTP缓存工作方式</h2>
<h3 id="expires">Expires</h3>
<ul>
<li>场景一：让服务器与浏览器约定一个文件过期时间一Expires</li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/Expires.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>① 第一次请求时，浏览器向服务器请求一个 f.js 文件<br>
② 服务器说文件给你，我们约定一个时间，通过响应头返回一个 Expires 过期约定时间，同时返回了 f.js<br>
③ 后续请求浏览器先对比当前时间是否已经大于 Expires，判断缓存的文件是否超过了约定的过期时间，时间没过的话，不发起请求，直接使用本地缓存；时间过期了，就发起请求，再返回到步骤 ①。<br>
假设 Expires 已经过期，浏览器请求服务器，但是 f.js 并未改变，如何避免这时发起请求呢？</p>
</blockquote>
<h3 id="last-modified-与-if-modified-since">Last-Modified 与 if-Modified-Since</h3>
<ul>
<li>场景二：让服务器与浏览器在约定文件过期时间的基础上，再加一个文件最新修改时间的对比——Last-Modified 与 if-Modified-Since</li>
</ul>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/Last-Modified.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>① 浏览器向服务器请求 f.js，并要一个过期时间<br>
② 服务器返回给浏览器 f.js 和 一个过期时间，再给一个文件最新修改时间 Last-Modified，通过设置响应头返回给浏览器，文件过期后，双方核对文件修改时间<br>
后续浏览器可能有如下三种情况：</p>
<ol>
<li>Expires 还未过期，浏览器使用本地缓存</li>
<li>Expires 过期，浏览器请求服务器时带上文件最新修改时间，在请求头里面加上 if-Modified-Since，也就是上次请求服务器返回的 Last-Modified，把这个值又带回去。服务器把这个 if-Modified-Since（请求头里的文件最近修改时间） 和 服务器上的文件最新修改时间 Last-Modified 作对比，如果两个值不相等，服务器查找最新的 f.js + Expires + Last-Modified 返回给浏览器；如果相等，服务器返回状态码 304：文件未修改过，你还是用你的本地缓存吧。</li>
</ol>
</blockquote>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/Last-Modified_2.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>浏览器端可以随意修改 Expires，很极端的情况下，Last-Modified 只能精确到秒，假设文件在 1秒 内发生变化，Last-Modified 无法感知这个文件的变化，这样情况下，浏览器永远无法拿到最新文件。</p>
</blockquote>
<h3 id="etag与lf-none-match">Etag与lf-None-Match</h3>
<ul>
<li>场景三：让服务器与浏览器在过期时间Expires+Last-Modified的基础上，增加一个文件内容唯一对比标记——Etag与lf-None-Match。Expires不稳定，再加入一个max-age来加以代替。</li>
</ul>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/Etag.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>① 浏览器请求 f.js<br>
② 服务器将 f.js + max-age(过期时间) + Last-Modified + Etag（文件内容的唯一标识）<br>
③ 浏览器 60s 内不发起请求，直接使用本地缓存，<br>
max-age=60代表成功缓存后的 60s 内不再向服务器发起请求，与 Expires 相似，但 max-age 优先级比 Expires 高，max-age 存在时 Expires 就没用了。</p>
<blockquote>
<p>④ 60s 后，浏览器带上 If-Modified-Since 和 If-None-Match 向服务器发起请求，服务器对比 If-None-Match 与服务器端的 Etag，这时候尽管给出了 If-Modified-Since，但是不会再对比 If-Modified-Since 和 Last-Modified 了，因为 Etag 优先级比 Last-Modified 高，Etag 就是为了解决 1s 内文件发生改变的问题。如果 If-None-Match 与 Etag 不相等，说明 f.js 这个内容被修改过，服务器返回给浏览器最新的 f.js + 全新的 Etag + max-age +Last-Modified（没什么用了，优先级 &lt; Etag） + Expires（没什么用了，优先级&lt;max-age）；如果 Etag 与 If-None-Match 相等，返回 304 告诉浏览器继续使用之前的本地缓存。</p>
</blockquote>
</blockquote>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/Etag_2.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>max-age 或 Expires 不过期的时候，浏览器没有办法主动感知服务器的文件变化。<br>
如果服务端改变了文件，怎样让客户端知道呢？</p>
</blockquote>
<h2 id="缓存改进方案">缓存改进方案</h2>
<h3 id="md5hash缓存">md5/hash缓存</h3>
<p>通过不缓存html，为静态文件添加MD5或者hash标识，解决浏览器无法跳过缓存过期时间主动感知文件变化的问题。</p>
<blockquote>
<p>HTTP 缓存方案：服务器与浏览器的文件修改时间对比，文件内容标识对比，前提的基础都是建立在两者文件路径完全相同的基础上，请求的都是 f.js，这才能够解读这样的缓存，但是如果第一次要获取的名字是 f-hash1.js，下一次文件修改了就变成了 f-hash2.js，这是两个完全不同的文件。<br>
浏览器第一次加载页面，请求并缓存了 f-hash1,js，第二次加载同样一个地方文件指向 f-hash2.js，浏览器不会询问缓存了，因为本地没有这个缓存，浏览器会直接重新请求 f-hash2.js，因为这就是两个不同的文件。<br>
通过这种方式就可以解决过期时间没到，浏览器无法主动请求服务器的问题，只需要在在项目每次发布迭代的时候，将修改过的静态文件添加不同的 MD5 或者 hash 标识即可。</p>
</blockquote>
<h3 id="cdn缓存">CDN缓存</h3>
<p>CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</p>
<blockquote>
<p>假设多年前，我们所在的城市只有一个火车站，每次春运整个城市的人都得去这个火车站买票， 人流量及购票需求激增，为了缓解这个问题，城市的不同区都出现了火车票的代售点，这样每个区的人都可以就近买票，火车站总站的压力大大减轻。<br>
可以把每个区的售票点称之为 CDN 节点，也就是前面所说的 代理服务器，简而言之，可以把 CDN 理解成浏览器与服务器之间的临时站点，它会替服务器处理部分浏览器请求，从而减轻总服务器上的压力。静态资源也是一样的，可以分成多个临时站点来存储。<br>
把 CDN 的价值归纳为：<br>
①通过分流大大减轻了原站（服务器端）的压力。<br>
②解决了跨地区访问问题（就近站点访问）。</p>
</blockquote>
<h3 id="cdn-缓存工作方式">CDN 缓存工作方式</h3>
<ul>
<li>第一次请求</li>
</ul>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/CDN%E7%BC%93%E5%AD%98%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AF%B7%E6%B1%82.png" alt="图片" loading="lazy"></figure>
<ul>
<li>后续请求</li>
</ul>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/CDN%E7%BC%93%E5%AD%98%E5%90%8E%E7%BB%AD%E8%AF%B7%E6%B1%82.png" alt="图片" loading="lazy"></figure>
<p>可能出现以下几种情况：</p>
<p>① CDN 节点自己缓存的文件还没过期，于是返回 304 给浏览器，打回了这次请求</p>
<p>② CND 节点发现自己缓存的文件过期了，为了保险起见，自己发送请求给服务器，成功拿回最新数据，然后交还给浏览器。</p>
<p>CND 缓存的问题和 HTTP 缓存的问题一样，CDN 缓存时间不过期，浏览器始终被拦截，无法拿到最新的文件。回归 HTTP 缓存本身，缓存本身针对于更新频率不高的静态文件，CDN 缓存提供了分流、访问加速等。</p>
<p>CDN 与 HTTP 缓存不一样的是：CDN 类似于一个平台，可以通过登录手动更新 CDN 缓存，变相解决了浏览器缓存无法手动控制的问题。</p>
<h2 id="浏览器操作对http缓存的影响">浏览器操作对HTTP缓存的影响</h2>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>用户操作</strong></th>
<th style="text-align:left"><strong>Expires/Cache-Control</strong></th>
<th style="text-align:left"><strong>Last-Modihed/Etag</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">地址栏回车</td>
<td style="text-align:left">有效</td>
<td style="text-align:left">有效</td>
</tr>
<tr>
<td style="text-align:left">页面链接跳转</td>
<td style="text-align:left">有效</td>
<td style="text-align:left">有效</td>
</tr>
<tr>
<td style="text-align:left">新开窗口</td>
<td style="text-align:left">有效</td>
<td style="text-align:left">有效</td>
</tr>
<tr>
<td style="text-align:left">前进、后退</td>
<td style="text-align:left">有效</td>
<td style="text-align:left">有效</td>
</tr>
<tr>
<td style="text-align:left">F5刷新</td>
<td style="text-align:left">无效</td>
<td style="text-align:left">有效</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+F5刷新</td>
<td style="text-align:left">无效</td>
<td style="text-align:left">无效</td>
</tr>
</tbody>
</table>
<h1 id="内容协商机制">内容协商机制</h1>
<blockquote>
<p>访问谷歌，同一个 URL，在国内打开谷歌是中文，在国外打开是英文的。</p>
</blockquote>
<ul>
<li>指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言，字符集，编码方式等作为判断的基准。</li>
</ul>
<h2 id="内容协商方式">内容协商方式</h2>
<ul>
<li>客户端驱动</li>
</ul>
<p>客户端发起请求，服务器发送可选项列表，客户端作出选择后在发送第二次请求。</p>
<ul>
<li>服务器驱动</li>
</ul>
<p>服务器检查客户端的请求头部集并决定提供哪个版本的页面。</p>
<ul>
<li>透明协商</li>
</ul>
<p>某个中间设备（通常是缓存代理）代表客户端进行协商。</p>
<h2 id="服务器驱动内容协商-请求首部集">服务器驱动内容协商-请求首部集</h2>
<ul>
<li>Accept：告知服务器发送何种媒体类型</li>
<li>Accept-Language：告知服务器发送何种语言</li>
<li>Accept-Charset：告知服务器发送何种字符集</li>
<li>Accept-Encoding：告知服务器采用何种编码</li>
</ul>
<h2 id="服务器驱动内容协商-请求首部集-2">服务器驱动内容协商-请求首部集</h2>
<ul>
<li>Content-Type</li>
<li>Content-Language</li>
<li>Content-Type</li>
<li>Content-Encoding</li>
</ul>
<h2 id="服务器驱动内容协商-近似匹配">服务器驱动内容协商-近似匹配</h2>
<blockquote>
<p>客户端的 Accept-Language 指的是西班牙语，服务器端只有英语和法语，这个客户端希望在没有西班牙语的时候优先返回英语。这就意味着需要一种 HTTP 机制更详细的描述偏好：近似匹配方式。</p>
</blockquote>
<p>Accept-Language:en; q=0.5, fr; q=0.0, nl; q=1.0, tr; q=0.0</p>
<blockquote>
<p>上述首部表示用户最愿意接受 nl：荷兰语(nl; q=1.0)；其次，如果没有荷兰语的话，英文也行：en;q=0.5；不接受法语：fr;q=0.0 ，不接受土耳其语：tr;q=0.0</p>
</blockquote>
<p>q 值的范围是 0-1，不代表所有权重和为 1，不是权重的概念，只是优先级的概念。</p>
<blockquote>
<p>如果服务端既没有 nl 也没有 en，服务器端猜测，服务器端设置默认值。</p>
</blockquote>
<h2 id="断点续传和多线程下载">断点续传和多线程下载</h2>
<ul>
<li>断点续传？多线程下载？</li>
</ul>
<blockquote>
<p>下载文件时，下载到一半，突然网络不太好，下载中断了；<br>
或者主动暂停下载；<br>
用迅雷下载一个大文件，会分成好多块分开下载。<br>
上述叫断点续传。</p>
<ul>
<li>HTTP是通过在Header里两个参数实现的，客户端发请求时对应的是Range，服务器端响应时对应的是Content-Range。<br>
不论是断点续传还是迅雷的多线程分块下载，如果续传成功，返回 206，如果文件有变动，返回 200 和新文件的内容。</li>
</ul>
</blockquote>
<p>Range</p>
<ul>
<li>用于请求头中，指定第一个字节的位置和最后一个字节的位置，一般格式：</li>
<li>Range:（unit=first byte pos）-[last byte pos] 左开右闭区间
<ul>
<li>Range:bytes=0-499</li>
<li>Range:bytes=500-999</li>
<li>Range:bytes=-500  后 500 个字节的内容</li>
<li>imooc Range:bytes=500-   从第 500 字节开始，到文件结束部分</li>
<li>Range:bytes=500-600,601-999</li>
</ul>
</li>
</ul>
<p>Content-Range</p>
<ul>
<li>用于响应头中，在发出带 Range的请求后，服务器会在Content-Range 头部返回当前接受的范围和文件总大小。一般格式：
<ul>
<li>Content-Range:bytes（unit first byte pos）-[last byte pos]/[entity legth]</li>
</ul>
</li>
<li>而在响应完成后，返回的响应头内容也不同：
<ul>
<li>HTTP/1.1200 Ok（不使用断点续传方式）</li>
<li>HTTP/1.1 206 Partial Content（使用断点续传方式）</li>
</ul>
</li>
</ul>
<h2 id="断点续传过程">断点续传过程</h2>
<p>1.客户端下载一个1024K的文件，已经下载了其中512K。</p>
<p>2.网络中断，客户端请求续传，因此需要在HTTP头中申明本次需要续传的片段：Range:bytes=512000-</p>
<p>这个头通知服务端从文件的512K位置开始传输文件。</p>
<p>3.服务端收到断点续传请求，从文件的512K位置开始传输，并且在HTTP头中增加：</p>
<p>Content-Range:bytes 512000-/1024000并且此时服务端返回的HTTP状态码应该是206，而不是200。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM 垃圾回收]]></title>
        <id>https://epitomm.github.io/post/jvm-la-ji-hui-shou/</id>
        <link href="https://epitomm.github.io/post/jvm-la-ji-hui-shou/">
        </link>
        <updated>2020-04-24T14:54:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-如何判断对象可以回收">一、如何判断对象可以回收</h1>
<h2 id="11-引用计数法">1.1 引用计数法</h2>
<p>如果一个对象被其他变量引用，计数器 +1，如果某个变量不再引用，计数器 -1。如果一个对象的<strong>引用次数为 0</strong>，就可以被回收。</p>
<h3 id="循环引用问题">循环引用问题</h3>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png" alt="图片" loading="lazy"></figure>
<p>A 对象引用 B 对象，B 对象的引用计数 = 1；B 对象引用了 A 对象，A 对象的引用计数 = 1，但是没有其他对象在引用它们两个，它们本应被回收，却因彼此循环引用，计数器不为 0 ，不能被回收，造成内存泄露。</p>
<h2 id="12-可达性分析算法">1.2 可达性分析算法</h2>
<ul>
<li>Java 虚拟机中的垃圾回收器采用<strong>可达性分析</strong>来探索所有存活的对象</li>
<li>扫描<strong>堆</strong>中的对象，看是否能够沿着 <strong>GC Root对象为起点的引用链找到该对象</strong>，找不到，表示可以回收</li>
</ul>
<h3 id="哪些对象可以作为-gc-root">哪些对象可以作为 GC Root ?</h3>
<ul>
<li>虚拟机栈中局部变量引用的对象</li>
<li>本地方法栈中 JNI 中引用的对象</li>
<li>方法去区静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
</ul>
<h2 id="13-四种引用">1.3 四种引用</h2>
<h3 id="131-强引用">1.3.1. 强引用</h3>
<blockquote>
<p>一个对象通过等号赋值运算符赋值给变量，如：List<String> list = new ArrayList&lt;&gt;();<br>
变量 list 强引用了对象 ArrayList。只要沿着 GC Root 能够找到这个对象，这个对象就不会被垃圾回收。</p>
</blockquote>
<ul>
<li>只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E5%BC%BA%E5%BC%95%E7%94%A8.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E5%BC%BA%E5%BC%95%E7%94%A82.png" alt="图片" loading="lazy"></figure>
<pre><code>package cn.itcast.jvm.t2;

import java.io.IOException;
import java.lang.ref.SoftReference;
import java.util.ArrayList;
import java.util.List;

/**
 * 演示强引用
 * -Xmx20m -XX:+PrintGCDetails -verbose:gc
 */
public class Demo2_3 {
    private static final int _4MB = 4 * 1024 * 1024;
    public static void main(String[] args) throws IOException {
      List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
      for (int i = 0; i &lt; 5; i++) {
          list.add(new byte[_4MB]);// 读取图片放到 list 集合中进行显示，但是图片资源并不属于核心业务资源，如果图片过多，用强引用就会导致溢出。不太重要的资源能不能在内存紧张时把它占用的内存释放掉，以后如果再用到的话再读取一遍呢？采用软引用。
      } 
      System.in.read();
    }
}
</code></pre>
<p>通过 <code>-Xmx20m -XX:+PrintGCDetails -verbose:gc</code> 设置堆空间大小为 20M 并且打印 GC 信息，创建 list 变量强引用 ArrayLsit 对象，向 ArrayList 内放入 20M 对象，由于程序一直未被终止，所以 list 不能被回收，导致 堆内存溢出异常 <code>OutOfMemoryError: Java heap space</code>。</p>
<p>运行结果：</p>
<pre><code>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space
	at cn.itcast.jvm.t2.Demo2_3.main(Demo2_3.java:21)
</code></pre>
<h3 id="132-软引用softreference">1.3.2. 软引用（SoftReference）</h3>
<ul>
<li>仅有软引用引用该对象时，在<strong>垃圾回收后，内存仍不足</strong>时会再次触发垃圾回收，回收软引用对象</li>
<li>可以配合<strong>引用队列</strong>来释放软引用自身</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E8%BD%AF%E5%BC%95%E7%94%A8.png" alt="图片" loading="lazy"></figure>
<pre><code>package cn.itcast.jvm.t2;

import java.io.IOException;
import java.lang.ref.SoftReference;
import java.util.ArrayList;
import java.util.List;

/**
 * 演示软引用
 * -Xmx20m -XX:+PrintGCDetails -verbose:gc
 */
public class Demo2_3 {

    private static final int _4MB = 4 * 1024 * 1024;

    public static void main(String[] args) throws IOException {
        soft();
    }

    public static void soft() {
        // list --&gt; SoftReference --&gt; byte[]
        // list 和 SoftReference 之间是强引用，SoftReference 和 byte[] 之间是软引用
        List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 5; i++) {
            SoftReference&lt;byte[]&gt; ref = new SoftReference&lt;&gt;(new byte[_4MB]);
            System.out.println(ref.get());
            list.add(ref);
            System.out.println(list.size());

        }
        System.out.println(&quot;循环结束：&quot; + list.size());
        for (SoftReference&lt;byte[]&gt; ref : list) {
            System.out.println(ref.get());
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/%E8%BD%AF%E5%BC%95%E7%94%A8GC.png" alt="图片" loading="lazy"></figure>
<p><strong>清理无用的软引用：引用队列</strong></p>
<p>软引用对象被释放后，没必要再保存在 list 中了，希望把<strong>软引用本身做一个清理</strong>，从 list 集合中清理掉。</p>
<pre><code>package cn.itcast.jvm.t2;

import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.SoftReference;
import java.util.ArrayList;
import java.util.List;

/**
 * 演示软引用, 配合引用队列
 */
public class Demo2_4 {
    private static final int _4MB = 4 * 1024 * 1024;

    public static void main(String[] args) {
        List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();

        // 引用队列
        ReferenceQueue&lt;byte[]&gt; queue = new ReferenceQueue&lt;&gt;();
        for (int i = 0; i &lt; 5; i++) {
            // 关联了引用队列， 当软引用所关联的 byte[]被回收时，软引用自己会加入到 queue 中去
            SoftReference&lt;byte[]&gt; ref = new SoftReference&lt;&gt;(new byte[_4MB], queue);
            System.out.println(ref.get());
            list.add(ref);
            System.out.println(list.size());
        }

        // 从队列中获取无用的 软引用对象，并移除
        Reference&lt;? extends byte[]&gt; poll = queue.poll();
        while( poll != null) {
            list.remove(poll);
            poll = queue.poll();
        }

        System.out.println(&quot;===========================&quot;);
        for (SoftReference&lt;byte[]&gt; reference : list) {
            System.out.println(reference.get());
        }

    }
}
</code></pre>
<p>运行结果：值为空的软引用都被从 list 集合中清除了</p>
<pre><code>[B@6d6f6e28
1
[B@135fbaa4
2
[B@45ee12a7
3
[B@330bedb4
4
[B@2503dbd3
5
===========================
[B@2503dbd3
</code></pre>
<h3 id="133-弱引用weakreference">1.3.3. 弱引用（WeakReference）</h3>
<ul>
<li>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</li>
<li>可以配合引用队列来释放弱引用自身</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E5%BC%B1%E5%BC%95%E7%94%A8.png" alt="图片" loading="lazy"></figure>
<p>引用队列：</p>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E5%BC%B1%E5%BC%95%E7%94%A8%E5%BC%95%E7%94%A8%E9%98%9F%E5%88%97.png" alt="图片" loading="lazy"></figure>
<p>当软引用的对象被回收后，软引用自身也是一个对象，如果在创建时给他分配了一个引用队列，那在它<strong>引用的对象被回收</strong>时，软引用就会进入这个<strong>引用队列</strong>。当弱引用的对象被垃圾回收后，弱引用如果被分配了引用队列的话， 弱引用也会进入引用队列。因为软引用、弱引用自身也要占用一定内存，如果要对它俩占用的内存进一步释放，需要使用引用队列来找到它们。</p>
<pre><code>package cn.itcast.jvm.t2;

import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.List;

/**
 * 演示弱引用
 * -Xmx20m -XX:+PrintGCDetails -verbose:gc
 */
public class Demo2_5 {
    private static final int _4MB = 4 * 1024 * 1024;

    public static void main(String[] args) {
        //  list --&gt; WeakReference --&gt; byte[]
        List&lt;WeakReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 10; i++) {
            WeakReference&lt;byte[]&gt; ref = new WeakReference&lt;&gt;(new byte[_4MB]);
            list.add(ref);
            for (WeakReference&lt;byte[]&gt; w : list) {
                System.out.print(w.get()+&quot; &quot;);
            }
            System.out.println();

        }
        System.out.println(&quot;循环结束：&quot; + list.size());
    }
}
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/%E5%BC%B1%E5%BC%95%E7%94%A8GC.png" alt="图片" loading="lazy"></figure>
<p>在<strong>垃圾回收时，会把弱引用所占用的内存释放掉</strong>，弱引用自身占用的内存要释放的话，要结合引用队列来实现。</p>
<h3 id="134-虚引用phantomreference">1.3.4. 虚引用（PhantomReference）</h3>
<p>虚引用和终结器引用必须配合引用队列使用。<strong>当创建虚引用和终结器引用时，都会关联一个引用队列。</strong></p>
<ul>
<li>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队， 由 Reference Handler 线程调用虚引用相关方法<strong>释放直接内存</strong></li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/%E8%99%9A%E5%BC%95%E7%94%A8.png" alt="图片" loading="lazy"></figure>
<p>创建 ByteBuffer 的实现对象时，会创建一个名为 Cleaner 的<strong>虚引用对象</strong>，ByteBuffer 会分配一块直接内存，并且会把直接内存的地址传递给虚引用对象。将来 ByteBuffer 没有被强引用引用时，ByteBuffer 就会被垃圾回收，但是给他分配的<strong>直接内存并不能被 Java 垃圾回收</strong>管理。</p>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/%E8%99%9A%E5%BC%95%E7%94%A82.png" alt="图片" loading="lazy"></figure>
<p>所以在 ByteBuffer 被回收时，让虚引用对象进入引用队列，虚引用所在的引用队列会由 ReferenceHandler 线程定时到这个引用队列中找看有没有新入队的 Cleaner，如果有，就会调用 Cleaner 中的 clean() 方法，根据前面记录的直接内存的地址调用 Unsafe.freeMemory()，<strong>释放直接内存</strong>。</p>
<h3 id="135-终结器引用finalreference">1.3.5. 终结器引用（FinalReference）</h3>
<ul>
<li>无需手动编码，但其内部<strong>配合引用队列使用</strong>，在<strong>垃圾回收</strong>时，<strong>终结器引用入队</strong>（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并<strong>调用它的 finalize 方法</strong>，<strong>第二次 GC 时才能回收被引用对象</strong></li>
</ul>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/%E7%BB%88%E7%BB%93%E5%99%A8%E5%BC%95%E7%94%A8.png" alt="图片" loading="lazy"></figure>
<p>所有的 Java 对象都会继承在 Object 父类，Object 类中有一个 finalize() 终结方法。某个对象<strong>重写了 finalize() 方法</strong>，当没有强引用引用它时，就由虚拟机创建它对应的终结器引用，当这个对象要被垃圾回收时，就会把这个<strong>终结器引用加入引用队列</strong>，再由一个<strong>优先级很低的线程 <strong>（finalize() 迟迟未能被调用，导致对象很久不能被真正回收，所以不推荐使用 finalize() 释放资源）finalizeHandler 线程查看引用队列中是否有终结器引用，如果有，就会根据终结器引用找到那个</strong>要被垃圾回收的对象</strong>，并且<strong>调用它的 finalize()方法</strong>，调用完了，<strong>下一次垃圾回收时就可以把这个对象占用的内存真正回收了</strong>。</p>
<h1 id="二-垃圾回收算法">二、垃圾回收算法</h1>
<h2 id="21-标记清除">2.1 标记清除</h2>
<p>定义： Mark Sweep</p>
<ul>
<li>速度快</li>
<li>会造成内存碎片</li>
</ul>
<h3 id="标记清除流程">标记清除流程</h3>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png" alt="图片" loading="lazy"></figure>
<p><strong>标记</strong>：沿着 GC Root 的引用链去找，扫描整个堆对象的过程中，如果发现某个堆对象确实被引用了，那么这个堆对象是非垃圾对象，如果某个对<strong>象没有任何一个 GC Root 直接或间接引用</strong>它，那么把它<strong>标记为垃圾对象</strong>。</p>
<p><strong>清除</strong>：将被标记为垃圾对象所占用的空间释放掉。这里说的释放不是把这个对象所占用的内存的每个字节清零，只需要把垃<strong>圾对象占用内存的起始、结束地址记录下来，放在一个空闲地址列表</strong>，下次分配新对象时，到空闲地址列表中找是否有一块足够的空间能容纳新对象。</p>
<h3 id="优点">优点</h3>
<p><strong>速度快</strong>，只需把垃圾对象的起始、结束地址记录下来。</p>
<h3 id="缺点">缺点</h3>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E5%86%85%E7%A2%8E%E7%89%87.png" alt="图片" loading="lazy"></figure>
<p>易产生<strong>内存碎片</strong>。清除垃圾对象后不会对内存空间进行整理，如果分配了一个较大的对象，比如数组，数组需要一段连续的内存。每个小的空闲空间都不足以容纳下这个较大的新对象，虽然总的空闲空间足够，但由于<strong>不连续</strong>，造成新对象不能被保存。</p>
<h2 id="22-标记整理">2.2 标记整理</h2>
<p>定义：Mark Compact</p>
<ul>
<li>速度慢</li>
<li>没有内存碎片</li>
</ul>
<h3 id="标记整理流程">标记整理流程</h3>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png" alt="图片" loading="lazy"></figure>
<p><strong>标记</strong>：没有任何 GC Root 直接或间接指向的堆对象被标记为垃圾对象。</p>
<p><strong>整理</strong>：避免标记清除时的内存碎片问题，在清理垃圾的过程中，会把可用的对象向前移动，让内存更为<strong>紧凑</strong>，连续的内存空间就更大了。</p>
<h3 id="优点-2">优点</h3>
<p><strong>没有内碎片</strong>。</p>
<h3 id="缺点-2">缺点</h3>
<p>由于整理牵扯到对象的移动，<strong>效率降低</strong>。</p>
<p>对象在整理过程中发生移动，如果有其他局部变量引用了这个被移动的对象，就需要改变这些引用的地址。</p>
<h2 id="23-复制">2.3 复制</h2>
<p>定义：Copy</p>
<ul>
<li>不会有内存碎片</li>
<li>需要占用双倍内存空间</li>
</ul>
<h3 id="复制流程">复制流程</h3>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/%E5%A4%8D%E5%88%B61.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">标记垃圾对象</p>
<figure data-type="image" tabindex="16"><img src="https://epitomm.github.io/post-images/%E5%A4%8D%E5%88%B62.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">复制 FROM 区域的非垃圾对象到 TO 区域</p>
<figure data-type="image" tabindex="17"><img src="https://epitomm.github.io/post-images/%E5%A4%8D%E5%88%B63.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">清空 FROM 区域剩余的垃圾对象后交换 FROM 和 TO 区域</p>
<p>将内存区域划分成两块大小相等的区域，FROM 和 TO（空闲）。</p>
<p><strong>标记</strong>：找到那些不被引用的对象标记为垃圾对象。</p>
<p><strong>复制</strong>：把 <strong>FROM 区域上的非垃圾对象复制到 TO 区域</strong>中，复制的过程中完成碎片整理。复制完成后，<strong>FROM 区域</strong>都是垃圾对象，<strong>全部清除</strong>，并且<strong>交换 FROM 和 TO 区域</strong>。</p>
<h3 id="优点-3">优点</h3>
<p><strong>不会产生碎片。</strong></p>
<h3 id="缺点-3">缺点</h3>
<p><strong>占用双倍内存空间。</strong></p>
<h1 id="三-分代垃圾回收">三、分代垃圾回收</h1>
<p><strong>堆内存划分</strong></p>
<ul>
<li>新生代：用完了就丢弃。<strong>朝生夕死</strong>的对象
<ul>
<li>伊甸园 Eden</li>
<li>幸存区 FROM</li>
<li>幸存区 TO</li>
</ul>
</li>
<li>老年代：长时间使用的对象。<strong>长期存活</strong>的对象</li>
</ul>
<blockquote>
<p>有一栋居民楼，类似 Java 虚拟机中的堆内存，居民楼中每家每户每天要产生一些垃圾，需要保洁工人来处理，如果保洁工人挨家挨户去收垃圾，效率低，所以设立一个垃圾场（新生代），存放生命周期短的垃圾，比如盒饭、包装袋等，都是回收更为频繁的垃圾，保洁工人需要每天打扫了一次。 每家每户里存储的垃圾（老年代），比如用旧的椅子，暂存在家里，将来空间紧张到放不下时，找保洁员清理这些垃圾。</p>
</blockquote>
<figure data-type="image" tabindex="18"><img src="https://epitomm.github.io/post-images/%E5%A0%86%E5%86%85%E5%AD%98%E5%88%92%E5%88%86.png" alt="图片" loading="lazy"></figure>
<ul>
<li><strong>对象首先分配在伊甸园区域</strong></li>
<li><strong>新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1并且交换 from、to</strong></li>
<li><strong>minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</strong>
<ul>
<li>对象的复制会更改对象地址，如果用户线程仍在运行，就会造成访问原来对象的地址找不到。</li>
</ul>
</li>
<li><strong>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15</strong>（对象头中占用 4bit：1111B）</li>
<li><strong>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时间更长，如果之后空间仍不足，就会内存溢出。</strong></li>
</ul>
<h2 id="31-分代垃圾回收机制原理">3.1 分代垃圾回收机制原理</h2>
<figure data-type="image" tabindex="19"><img src="https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_1.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">当伊甸园被占满时要添加新对象，触发 minor gc</p>
<figure data-type="image" tabindex="20"><img src="https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_2.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">将伊甸园区的对象进行标记后，非垃圾对象复制到幸存区 TO，并且将这些非垃圾对象的寿命 +1，清空伊甸园内剩余的垃圾对象</p>
<figure data-type="image" tabindex="21"><img src="https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_3.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">交换 FROM 和 TO</p>
<p>创建一个新对象，存放到<strong>伊甸园</strong>，当伊甸园被占满时，触发 <strong>minor gc</strong>，先对伊甸园区域内的对象进行<strong>标记</strong>，标记结束后，采用<strong>复制算法</strong>，将非垃圾对象<strong>复制</strong>到幸存区 TO，并让这些对象的寿命+1，伊甸园剩余的垃圾对象回收掉，<strong>交换</strong> FROM 和 TO，第一次 minor gc 结束。</p>
<figure data-type="image" tabindex="22"><img src="https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_4.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">将伊甸园和幸存区 FROM 中的非垃圾对象复制到幸存区 TO，并将这些对象的寿命 +1，清空伊甸园和幸存区 FROM 中的非垃圾对象，交换 FROM 和 TO。将新对象放入伊甸园。</p>
<p>继续创建对象向伊甸园添加，伊甸园再次被填满，再次触发 minor gc，除了要将伊甸园中的非垃圾对象找到以外，还要把<strong>幸存区 FROM</strong> 中的非垃圾对象找到，将非垃圾对象复制到幸存区 TO，并让这些对象的寿命 +1，伊甸园和幸存区 FROM 的垃圾对象清除，交换 FROM 和 TO，第二次 minor gc 结束。</p>
<figure data-type="image" tabindex="23"><img src="https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_5.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">当幸存区对象的寿命 = 15时，将此对对象移动到老年代。</p>
<figure data-type="image" tabindex="24"><img src="https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_6.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">当老年代空间不足，触发 FULL GC，对整个堆进行清理。</p>
<h2 id="32-相关-vm-参数">3.2 相关 VM 参数</h2>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>含义</strong></th>
<th style="text-align:left"><strong>参数</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">堆初始大小</td>
<td style="text-align:left">-Xms</td>
</tr>
<tr>
<td style="text-align:left">堆最大大小</td>
<td style="text-align:left">-Xmx 或 -XX:MaxHeapSize=size</td>
</tr>
<tr>
<td style="text-align:left">新生代大小</td>
<td style="text-align:left">-Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )</td>
</tr>
<tr>
<td style="text-align:left">幸存区比例（动态）</td>
<td style="text-align:left">-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</td>
</tr>
<tr>
<td style="text-align:left">幸存区比例</td>
<td style="text-align:left">-XX:SurvivorRatio=ratio</td>
</tr>
<tr>
<td style="text-align:left">晋升阈值</td>
<td style="text-align:left">-XX:MaxTenuringThreshold=threshold</td>
</tr>
<tr>
<td style="text-align:left">晋升详情</td>
<td style="text-align:left">-XX:+PrintTenuringDistribution</td>
</tr>
<tr>
<td style="text-align:left">GC详情</td>
<td style="text-align:left">-XX:+PrintGCDetails -verbose:gc</td>
</tr>
<tr>
<td style="text-align:left">FullGC 前 MinorGC</td>
<td style="text-align:left">-XX:+ScavengeBeforeFullGC</td>
</tr>
</tbody>
</table>
<ol>
<li>没有运行任何代码时，虚拟机参数 <code>-Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</code> 的堆内存占用情况</li>
</ol>
<pre><code>public class Demo2_1 {
    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc
    // -Xms20M：初始堆空间20M；
    // -Xmx20M：最大堆空间20M；
    // -Xmn10M：新生代10M；
    // -XX:+UseSerialGC：垃圾回收器，幸存区比例不会动态调整
    // -XX:+PrintGCDetails -verbose:gc：打印 gc 详情
    public static void main(String[] args) throws InterruptedException {


    }
</code></pre>
<figure data-type="image" tabindex="25"><img src="https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B0.png" alt="图片" loading="lazy"></figure>
<p>2.Eden 区域不足时，触发 minor gc 时的堆内存占用</p>
<pre><code>package cn.itcast.vm.t2;
import java.util.ArrayList;
public class Demo2_1 {
    private static final int _7MB = 7 * 1024 * 1024;

    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC
    public static void main(String[] args) throws InterruptedException {
        ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
        list.add(new byte[_7MB]);
    }
}
</code></pre>
<p>因为 Eden 共 8M，类加载时创建一些对象占用了 29% 的空间，大概剩余 6M 空间，创建一个 7M 的对象，加入 Eden，Eden 内存不足，会触发垃圾回收。<br>
<img src="https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B02.png" alt="图片" loading="lazy"></p>
<pre><code>package cn.itcast.jvm.t2;

import java.util.ArrayList;

/**
 *  演示内存的分配策略
 */
public class Demo2_1 {
    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * 1024 * 1024;
    private static final int _7MB = 7 * 1024 * 1024;
    private static final int _8MB = 8 * 1024 * 1024;

    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC
    public static void main(String[] args) throws InterruptedException {
        ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
        list.add(new byte[_7MB]);
        list.add(new byte[_512KB]);
    }
}
</code></pre>
<figure data-type="image" tabindex="26"><img src="https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B03.png" alt="图片" loading="lazy"></figure>
<ol start="3">
<li>新生代区域内存不足创建对象，放入老年代</li>
</ol>
<pre><code>package cn.itcast.jvm.t2;

import java.util.ArrayList;

/**
 *  演示内存的分配策略
 */
public class Demo2_1 {
    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * 1024 * 1024;
    private static final int _7MB = 7 * 1024 * 1024;
    private static final int _8MB = 8 * 1024 * 1024;

    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC
    public static void main(String[] args) throws InterruptedException {
        ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
        list.add(new byte[_7MB]);
        list.add(new byte[_512KB]);
        list.add(new byte[_512KB]);
    }
}
</code></pre>
<figure data-type="image" tabindex="27"><img src="https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B04.png" alt="图片" loading="lazy"></figure>
<ol start="4">
<li>添加的对象比新生代总内存大，直接放入老年代且不触发 GC。</li>
</ol>
<pre><code>package cn.itcast.jvm.t2;
import java.util.ArrayList;
public class Demo2_1 {
    private static final int _8MB = 8 * 1024 * 1024;
    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC
    public static void main(String[] args) throws InterruptedException {
        ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
        list.add(new byte[_8MB]);
    }
}
</code></pre>
<figure data-type="image" tabindex="28"><img src="https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B05.png" alt="图片" loading="lazy"></figure>
<ol start="5">
<li>内存溢出</li>
</ol>
<pre><code>package cn.itcast.jvm.t2;

import java.util.ArrayList;

/**
 *  演示内存的分配策略
 */
public class Demo2_1 {
    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * 1024 * 1024;
    private static final int _7MB = 7 * 1024 * 1024;
    private static final int _8MB = 8 * 1024 * 1024;

    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC
    public static void main(String[] args) throws InterruptedException {
        ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
        list.add(new byte[_8MB]);
        list.add(new byte[_8MB]);
    }
}
</code></pre>
<figure data-type="image" tabindex="29"><img src="https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B06.png" alt="图片" loading="lazy"></figure>
<ol start="6">
<li>当内存溢出发生在子线程中，是否会导致 java 进程结束？</li>
</ol>
<pre><code>package cn.itcast.jvm.t2;

import java.util.ArrayList;

/**
 *  演示内存的分配策略
 */
public class Demo2_1 {
    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * 1024 * 1024;
    private static final int _7MB = 7 * 1024 * 1024;
    private static final int _8MB = 8 * 1024 * 1024;

    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails 
    public static void main(String[] args) throws InterruptedException {
        new Thread(() -&gt; {
            ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
            list.add(new byte[_8MB]);
            list.add(new byte[_8MB]);

        }).start();

        System.out.println(&quot;sleep....&quot;);
        Thread.sleep(1000L);  
    }
}
</code></pre>
<figure data-type="image" tabindex="30"><img src="https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B07.png" alt="图片" loading="lazy"></figure>
<h1 id="四-垃圾回收器">四、垃圾回收器</h1>
<ol>
<li>串行</li>
</ol>
<ul>
<li>单线程</li>
<li>堆内存较小，适合个人电脑</li>
</ul>
<ol start="2">
<li>吞吐量优先</li>
</ol>
<ul>
<li>多线程</li>
<li>堆内存较大，多核 cpu</li>
<li>让单位时间内，STW 的时间最短。两次垃圾回收：0.2+0.2 = 0.4，<strong>垃圾回收时间占比最低，这样就称吞吐量高</strong></li>
</ul>
<ol start="3">
<li>响应时间优先</li>
</ol>
<ul>
<li>多线程</li>
<li>堆内存较大，多核 cpu</li>
<li>尽可能让<strong>单次 STW 的时间最短</strong>。五次垃圾回收：0.1+0.1+0.1+0.1+0.1 = 0.5</li>
</ul>
<h2 id="41-串行">4.1 串行</h2>
<pre><code>-XX:+UseSerialGC = Serial + SerialOld
</code></pre>
<p>Serial：工作在<strong>新生代</strong>。<strong>复制</strong>算法<br>
SerialOld：工作在<strong>老年代</strong>。<strong>标记整理</strong>算法</p>
<figure data-type="image" tabindex="31"><img src="https://epitomm.github.io/post-images/%E4%B8%B2%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="图片" loading="lazy"></figure>
<p>四个 CPU 在运行，某时刻堆内存不足，触发垃圾回收。触发垃圾回收时，需要让这些线程到达一个<strong>安全点</strong>再停下，因为在垃圾回收的过程中，可能对象的地址发生改变，为了保证安全地使用这些对象地址，需要所有正在工作的用户线程到达这个安全点在停下。因为 Serial、SerialOld 都是<strong>单线程</strong>的垃圾回收器，因此在一个垃圾回收线程运行时，其他的用户线程都要<strong>阻塞</strong>，等到垃圾回收线程结束后，其他的用户线程再恢复运行。</p>
<h2 id="42-吞吐量优先">4.2 吞吐量优先</h2>
<p><strong>吞吐量</strong>：CPU 用于运行用户程序的时间与总时间的比值。</p>
<pre><code>-XX:+UseParallelGC ~ -XX:+UseParallelOldGC
-XX:+UseAdaptiveSizePolicy
-XX:GCTimeRatio=ratio 
-XX:MaxGCPauseMillis=ms 
-XX:ParallelGCThreads=n 
</code></pre>
<p><code>-XX:+UseParallelGC ~ -XX:+UseParallelOldGC</code>：JDK 1.8 默认使用 ParallelGC <strong>并行</strong>的垃圾回收器。<br>
UseParallelGC 并行的新生代垃圾回收器，采用<strong>复制</strong>算法；UseParallelOldGC 并行的老年代垃圾回收器，采用<strong>标记整理</strong>算法。</p>
<p><code>-XX:+UseAdaptiveSizePolicy</code>：自适应大小调整（新生代：Eden 和 Survival）策略</p>
<p><code>-XX:GCTimeRatio=ratio</code>：根据设置目标调整堆的大小以达到期望的目标。吞吐量：垃圾回收时间和总时间占比。1/(1+ratio)。一般堆调大，减少垃圾回收次数。</p>
<p><code>-XX:MaxGCPauseMillis=ms</code>：最大暂停毫秒数（每一次垃圾回收耗时）</p>
<p><code>-XX:ParallelGCThreads=n</code> ：控制 ParallelGC 运行时的<strong>线程数</strong>。</p>
<figure data-type="image" tabindex="32"><img src="https://epitomm.github.io/post-images/%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="图片" loading="lazy"></figure>
<p>四个 CPU 在运行，某一时刻内存不足触发垃圾回收，用户线程就会到达安全点然后停下来，垃圾回收器<strong>开启多个线程进行垃圾回收</strong>。垃圾回收线程个数默认和 CPU 核数相关。回收结束后再恢复其他的线程运行。在垃圾回收时，四核 CPU 都去进行垃圾回收了，<strong>CPU 占用率</strong>会一下达到 100%。</p>
<h2 id="43-响应时间优先">4.3 响应时间优先</h2>
<pre><code>-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld 
-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads 
-XX:CMSInitiatingOccupancyFraction=percent 
-XX:+CMSScavengeBeforeRemark
</code></pre>
<p><code>-XX:+UseConcMarkSweepGC</code> ：<strong>并发标记清除</strong>。垃圾回收器工作的同时，其他用户线程也能同时进行。垃圾回收线程和用户线程并发执行，都要去抢占 CPU。<br>
<code>-XX:+UseParNewGC</code>：工作在新生代，复制算法。 <strong>SerialOld</strong>：老年代垃圾回收器由并发退化为单线程 （基于标记整理的老年垃圾回收器）。<br>
<img src="https://epitomm.github.io/post-images/%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="图片" loading="lazy"></p>
<p>多个 CPU 并行执行，老年代内存不足，所有进程到达安全点，执行<strong>初始标记</strong>，用户线程阻塞，STW；初始标记结束后，用户线程开始运行，停止 STW，与此同时垃圾回收线程<strong>并发标记</strong>，把剩余的垃圾找出来；并发标记结束后，进行<strong>重新标记</strong>，这个过程 STW，因为并发标记的过程用户线程可能对垃圾回收做了干扰，所以并发标记结束后还要再做一次重新标记；重新标记结束后，用户线程继续运行，垃圾回收线程<strong>并发清理</strong>。</p>
<h2 id="44-g1">4.4 G1</h2>
<p>定义：Garbage First</p>
<ul>
<li>2004 论文发布</li>
<li>2009 JDK 6u14 体验</li>
<li>2012 JDK 7u4 官方支持</li>
<li>2017 JDK 9 默认。G1 取代了 CMS</li>
</ul>
<p>适用场景</p>
<ul>
<li>同时注重<strong>吞吐量</strong>（Throughput）和<strong>低延迟</strong>（Low latency），默认的暂停目标是 200 ms</li>
<li>并发的垃圾回收器，和 CMS 一样追求低延迟，可以在用户线程工作的同时垃圾回收线程也并发执行。另外还借鉴了 Parallel：注重吞吐量垃圾回收器的思想，可以进行调整，设置默认暂停目标（<code>-XX:MaxGCPauseMillis</code>）。</li>
<li><strong>超大堆内存</strong>，会<strong>将堆划分为多个大小相等的 Region</strong></li>
</ul>
<p>随着堆内存容量的增大，G1 与 CMS 相比优势更加明显。</p>
<p>将堆划分为多个大小相等的 Region：每个区域都可以独立地作为 Eden、survive、老年代。</p>
<p><code>-XX:G1HeapRegionSize</code>：设置区域的大小，必须是2的幂。如果堆内存过大，回收速度会变慢，因为会涉及对象的复制标记，而分成小的区域进行管理，可以化整为零，进行一些优化加快标记拷贝的速度。</p>
<ul>
<li>整体上是 <strong>标记+整理</strong> 算法（避免标记清除算法产生的内碎片），两个区域之间是复制算法</li>
</ul>
<p>相关 JVM 参数</p>
<pre><code>-XX:+UseG1GC 
-XX:G1HeapRegionSize=size 
-XX:MaxGCPauseMillis=time
</code></pre>
<figure data-type="image" tabindex="33"><img src="https://epitomm.github.io/post-images/G1_2.png" alt="图片" loading="lazy"></figure>
<h3 id="1-g1-垃圾回收阶段">1) G1 垃圾回收阶段</h3>
<figure data-type="image" tabindex="34"><img src="https://epitomm.github.io/post-images/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%98%B6%E6%AE%B5.png" alt="图片" loading="lazy"></figure>
<p>刚开始新生代垃圾收集，如果某时刻老年代内存超过阈值了，在新生代垃圾收集的同时进行并发标记，这个阶段结束后会进行混合收集：会对新生代、幸存区、老年代都进行收集。混合收集结束，Eden 内存释放掉，会再进入新生代垃圾收集。</p>
<h3 id="2-young-collection">2) Young Collection</h3>
<ul>
<li>会 STW</li>
</ul>
<figure data-type="image" tabindex="35"><img src="https://epitomm.github.io/post-images/G1%E5%88%86%E5%8C%BA.png" alt="图片" loading="lazy"></figure>
<p>G1 垃圾回收器把<strong>堆内存划分成大小相等的一个个区域</strong>，每个区域都可独立作为伊甸园、幸存区、老年代。刚开始白色的区域表示是空闲的区域，类加载时新创建的对象刚开始会分配到伊甸园区，绿色的 E 就代表 Eden 区，当 Eden 区域逐渐被占满，就会触发新生代的垃圾回收。</p>
<figure data-type="image" tabindex="36"><img src="https://epitomm.github.io/post-images/G1%E6%96%B0%E7%94%9F%E4%BB%A3%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="图片" loading="lazy"></figure>
<p>新生代垃圾回收会把非垃圾对象以复制算法放入幸存区。</p>
<figure data-type="image" tabindex="37"><img src="https://epitomm.github.io/post-images/G1%E8%80%81%E5%B9%B4%E4%BB%A3.png" alt="图片" loading="lazy"></figure>
<p>当幸存区对象放不下，或幸存区对象寿命达到一定值，会触发垃圾回收，幸存区一部分对象会晋升到老年代，而寿命未达到阈值的会拷贝到另一个幸存区，新生代的非垃圾对象也会复制到这个幸存区。</p>
<h3 id="3-young-collection-cm">3) Young Collection + CM</h3>
<p>CM：Concurrent mark：并发标记</p>
<p><strong>初始标记</strong>：找到那些根对象，标记根对象。</p>
<p><strong>并发标记</strong>：从根对象出发，顺着引用链找到其他非垃圾对象，标记那些其他非垃圾对象。</p>
<ul>
<li>在 Young GC 时会进行 GC Root 的<strong>初始标记</strong></li>
<li>老年代占用堆空间比例达到阈值时，进行<strong>并发标记</strong>（不会 STW），由下面的 JVM 参数决定</li>
</ul>
<pre><code>-XX:InitialtingHeapOccupancyPercent=percent（默认45%）
</code></pre>
<p>老年代占用堆空间内存达到 45% 时，会进行并发标记。<br>
<img src="https://epitomm.github.io/post-images/G1%E8%80%81%E5%B9%B4%E4%BB%A3%E8%BF%87%E5%A4%9A%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0.png" alt="图片" loading="lazy"></p>
<p>E：Eden</p>
<p>S：Survive</p>
<p>O：Old</p>
<h3 id="4-mixed-collection">4) Mixed Collection</h3>
<p>会对 E、S、O 进行<strong>全面垃圾回收</strong></p>
<ul>
<li>最终标记（Remark）会 STW</li>
<li>拷贝存活（Evacuation）会 STW</li>
</ul>
<p>-XX:MaxGCPauseMillis=ms</p>
<figure data-type="image" tabindex="38"><img src="https://epitomm.github.io/post-images/G1%E5%85%A8%E9%9D%A2%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png" alt="图片" loading="lazy"></figure>
<p>Eden 区域的非垃圾对象被复制到 Survive 区域，Survive 区域寿命未达到阈值的非垃圾对象被复制到另一个 Survive 区域，寿命达到阈值的晋升到老年代区域。一部分老年代区域的幸存对象通过复制算法复制到新的的老年代区域，为什么没有把所有老年代都通过箭头指向新的老年代呢？因为 G1 会根据最大暂停时间有选择地进行回收，有时候堆内存空间太大了，老年代的垃圾回收可能时间比较长（复制算法大量对象的复制），就达不到<strong>最大暂停时间</strong>的目标了，为了达到这个目标，G1 会从老年代中挑出<strong>回收价值最高</strong>的区域（垃圾回收后能释放空间多的区域），只从老年代中挑选一部分区域复制，复制的区域少了，就可以达到暂停时间的目标了。如果老年代没有那么多，可以达到最大暂停时间的话， 就会把所有区域都进行复制。</p>
<h3 id="5-full-gc">5) Full GC</h3>
<ul>
<li>SerialGC：串行
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足发生的垃圾收集 - full gc</li>
</ul>
</li>
<li>ParallelGC：并行
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足发生的垃圾收集 - full gc</li>
</ul>
</li>
<li>CMS
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足
<ul>
<li>并发收集失败后 Full GC</li>
</ul>
</li>
</ul>
</li>
<li>G1
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足
<ul>
<li>有一个阈值，当老年代内存达到阈值，就会触发并发标记、混合收集阶段。如果垃圾回收的速度高于新的用户线程产生垃圾的速度，就处于并发垃圾收集阶段，这阶段还不算 Full GC。</li>
<li>当垃圾回收的速度跟不上垃圾产生的速度，并发收集失败，就会触发串行收集，这阶段叫做 Full GC。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-young-collection-跨代引用">6) Young Collection 跨代引用</h3>
<p>新生代回收的跨代引用（老年代引用新生代）问题</p>
<figure data-type="image" tabindex="39"><img src="https://epitomm.github.io/post-images/Card.png" alt="图片" loading="lazy"></figure>
<p>新生代垃圾回收：找到根对象，沿着引用链找到存活对象，存活对象进行复制到幸存区。要找新生代对象的根对象，<strong>根对象有一部分来自于老年代</strong>，老年代的存活对象非常多，如果遍历老年代找根对象效率低，因此把<strong>老年代区域再进行细分</strong>，分成一个个 Card，每个 Card 是512KB，如果老年代其中有一个 <strong>Card 中的对象引用了新生代的某一个对象</strong>，就把这个 <strong>Card 标记为脏</strong>，这样以后，做 GC Root 遍历的时候就不用去找整个老年代了，只需要关注那些脏 Card 即可，减少搜索范围，<strong>提高扫描根对象的效率</strong>。</p>
<ul>
<li>卡表与 Remembered Set</li>
<li>在引用变更时通过 post-write barrier + dirty card queue</li>
<li>concurrent refinement threads 更新 Remembered Set</li>
</ul>
<figure data-type="image" tabindex="40"><img src="https://epitomm.github.io/post-images/Card2.png" alt="图片" loading="lazy"></figure>
<p>粉色的 Card 都是<strong>脏卡区</strong>，Card 内有对象指向新生代区域的对象，新生代会记录 <strong>Remembered Set：从外部对我的引用</strong>，将来对新生代 Eden 进行垃圾回收时，就可以先通过 Remembered Set 知道它对应的哪些脏 Card，然后在到这些脏卡区遍历对象找到 GC Root。通过 <strong>post-write barrier</strong>：写屏障在每次<strong>对象的引用发生变更时，去更新脏 Card</strong>，这个过程是<strong>异步</strong>操作，不会立刻完成脏卡的更新，会把更新指令放在 <strong>dirty card queue 脏卡队列</strong>中，将来由一个线程完成脏卡更新的操作。</p>
<h3 id="7-remark-重标记阶段">7) Remark 重标记阶段</h3>
<ul>
<li>pre-write barrier + satb_mark_queue</li>
</ul>
<p><code>pre-write barrier</code>：写屏障：在对象引用改变前，将对象加入到 <code>satb_mark_queue</code> 队列，将来 remark 从队列中取出对象进一步判断。</p>
<figure data-type="image" tabindex="41"><img src="https://epitomm.github.io/post-images/%E9%87%8D%E6%A0%87%E8%AE%B0_1.png" alt="图片" loading="lazy"></figure>
<p>并发标记阶段对象的 true 和 false，其中图中<strong>黑色</strong>表示已经处理完成，并且有引用在引用它们，在垃圾回收后会被<strong>保留</strong>下来。<strong>灰色</strong>的是正在<strong>触发中</strong>，灰色的因为有强引用黑色的在指向它，所以最终会变成黑色，<strong>白色</strong>的是<strong>尚未处理</strong>，如果有强引用指向它最后会变成黑色，如果没有引用指向它最终还是白色，会被当成垃圾回收。垃圾回收结束后，会根据对象的黑白状态区分它到底应该存活还是被回收。</p>
<p><img src="https://epitomm.github.io/post-images/%E9%87%8D%E6%A0%87%E8%AE%B0_2.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/%E9%87%8D%E6%A0%87%E8%AE%B0_3.png" alt="图片" loading="lazy"></p>
<p><strong>Remark 流程：</strong><br>
<img src="https://epitomm.github.io/post-images/%E9%87%8D%E6%A0%87%E8%AE%B0_4.png" alt="图片" loading="lazy"></p>
<h3 id="8-jdk-8u20-字符串去重">8) JDK 8u20 字符串去重</h3>
<ul>
<li>优点：节省大量内存</li>
<li>缺点：略微多占用了 cpu 时间，新生代回收时间略微增加</li>
</ul>
<p><code>-XX:+UseStringDeduplication</code></p>
<pre><code>String s1 = new String(&quot;hello&quot;); // char[]{'h','e','l','l','o'} 
String s2 = new String(&quot;hello&quot;); // char[]{'h','e','l','l','o'}
</code></pre>
<ul>
<li>将所有新分配的字符串放入一个<strong>队列</strong></li>
<li>当新生代回收时，G1并发检查队列中是否有字符串重复</li>
<li>如果它们值一样，让它们<strong>引用同一个 char[]</strong></li>
<li>注意，与 String.intern() 不一样
<ul>
<li>String.intern() 关注的是<strong>字符串对象</strong></li>
<li>而字符串去重关注的是 <strong>char[]</strong></li>
<li>在 JVM 内部，使用了不同的字符串表</li>
</ul>
</li>
</ul>
<h3 id="9-jdk-8u40-并发标记类卸载">9) JDK 8u40 并发标记类卸载</h3>
<p>所有对象都经过并发标记后，就能知道<strong>哪些类不再被使用</strong>，当一个类加载器的所有类都不再使用，则<strong>卸载它所加载的所有类</strong></p>
<p><code>-XX:+ClassUnloadingWithConcurrentMark</code> 默认启用</p>
<h3 id="10-jdk-8u60-回收巨型对象">10) JDK 8u60 回收巨型对象</h3>
<figure data-type="image" tabindex="42"><img src="https://epitomm.github.io/post-images/%E5%9B%9E%E6%94%B6%E5%B7%A8%E5%9E%8B%E5%AF%B9%E8%B1%A1.png" alt="图片" loading="lazy"></figure>
<p>Region 区域内粉色的 H 就是巨型对象。</p>
<ul>
<li>一个对象<strong>大于 region 的一半</strong>时，称之为巨型对象</li>
<li>G1 <strong>不会对巨型对象进行拷贝</strong></li>
<li><strong>回收时被优先考虑</strong></li>
<li>G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0 的巨型对象就可以在新生代垃圾回收时处理掉</li>
</ul>
<figure data-type="image" tabindex="43"><img src="https://epitomm.github.io/post-images/%E5%9B%9E%E6%94%B6%E5%B7%A8%E5%9E%8B%E5%AF%B9%E8%B1%A1_2.png" alt="图片" loading="lazy"></figure>
<h3 id="11-jdk-9-并发标记起始时间的调整">11) JDK 9 并发标记起始时间的调整</h3>
<p>如果垃圾回收的速度跟不上垃圾产生的速度，最终会退化为 Full GC。G1 的 Full GC 是多线程的，Full GC 的 STW 过程很长，因此要尽可能避免 Full GC 的发生。如何减少 Full GC 呢？提前让垃圾回收开始，并发标记、混合收集提前开始，就能减少 Full GC 发生的几率。</p>
<ul>
<li>并发标记必须在堆空间占满前完成，否则退化为 FullGC</li>
<li>JDK 9 之前需要使用 <code>-XX:InitiatingHeapOccupancyPercent</code>：老年代在堆内存的占比，当超过设置的这个阈值时，就会触发并发垃圾回收。</li>
<li>JDK 9 可以动态调整
<ul>
<li><code>-XX:InitiatingHeapOccupancyPercent</code> 用来设置<strong>初始值</strong></li>
<li>进行<strong>数据采样</strong>并<strong>动态调整</strong></li>
<li>总会添加一个安全的空档空间</li>
</ul>
</li>
</ul>
<h3 id="12-jdk-9-更高效的回收">12) JDK 9 更高效的回收</h3>
<p>250+增强</p>
<p>180+bug修复</p>
<p><a href="https://docs.oracle.com/en/java/javase/12/gctuning">https://docs.oracle.com/en/java/javase/12/gctuning</a></p>
<h1 id="五-垃圾回收调优">五、垃圾回收调优</h1>
<p>预备知识</p>
<ul>
<li>掌握 GC 相关的 VM 参数，会基本的空间调整</li>
<li>掌握相关工具</li>
<li>明白一点：调优跟应用、环境有关，没有放之四海而皆准的法则</li>
</ul>
<p>查看虚拟机运行参数：</p>
<pre><code>&quot;C:\Program Files\Java\jdk1.8.0_172\bin\java&quot; -XX:+PrintFlagsFinal -version | findstr &quot;GC&quot;
</code></pre>
<figure data-type="image" tabindex="44"><img src="https://epitomm.github.io/post-images/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%B0%83%E4%BC%98.png" alt="图片" loading="lazy"></figure>
<h2 id="51-调优领域">5.1 调优领域</h2>
<ul>
<li>内存</li>
<li>锁竞争</li>
<li>cpu 占用</li>
<li>io</li>
</ul>
<h2 id="52-确定目标">5.2 确定目标</h2>
<ul>
<li>【低延迟】还是【高吞吐量】，选择合适的回收器</li>
<li>CMS，G1，ZGC：低延迟</li>
<li>ParallelGC：高吞吐量</li>
<li>Zing</li>
</ul>
<h2 id="53-最快的-gc-是不发生-gc">5.3 最快的 GC 是不发生 GC</h2>
<p>答案是不发生 GC</p>
<ul>
<li>查看 FullGC 前后的内存占用，考虑下面几个问题
<ul>
<li>数据是不是太多？
<ul>
<li><code>resultSet = statement.executeQuery(&quot;select * from 大表 limit n&quot;)</code></li>
</ul>
</li>
<li>数据表示是否太臃肿？
<ul>
<li>对象图</li>
<li>对象大小 16 Integer 24 int 4</li>
</ul>
</li>
<li>是否存在内存泄漏？
<ul>
<li>static Map map 不断向里面放数据</li>
<li>软</li>
<li>弱</li>
<li>第三方缓存实现</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="54-新生代调优">5.4 新生代调优</h2>
<h3 id="新生代的特点">新生代的特点</h3>
<ul>
<li>所有的 new 操作的内存分配非常廉价
<ul>
<li>TLAB thread-local allocation buffer
<ul>
<li>在 Eden 中给<strong>每个线程分配一块私有缓冲区 TLAB</strong>，new 对象时会首先检查 TLAB 缓冲区内是否有空白区域，如果有就优先在 TLAB 这块内存分配。因为线程安全问题，比如线程 1 要用这块内存，分配还没结束时，线程 2 不能也要用这块内存，造成内存分配混乱，  因此在对象的内存分配时，要做线程安全的保护，<strong>减少线程之间对分配时的并发冲突</strong>：TLAB  ：线程局部分配缓冲区。每个线程用自己私有的 Eden 内存来进行内存分配，多个线程即使同时创建对象，也不会产生对内存占用的干扰。</li>
</ul>
</li>
</ul>
</li>
<li>死亡对象的回收代价是零
<ul>
<li>新生代发生垃圾回收时，垃圾回收器复制算法：把 Eden、幸存区 FROM 中的幸存对象都复制到幸存区 TO，Eden、FROM 中的内存就被释放了，因此死亡对象的回收代价是零。</li>
</ul>
</li>
<li>新生代大部分对象用过即死</li>
<li>Minor GC 的时间远远低于 Full GC</li>
</ul>
<h3 id="新生代越大越好吗">新生代越大越好吗？</h3>
<p>-Xmn</p>
<blockquote>
<p>Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery).<br>
GC is performed in this region more often than in other regions. If the size for the young<br>
generation is too small, then a lot of minor garbage collections are performed. If the size is too  large, then only full garbage collections are performed, which can take a long time to complete.<br>
Oracle recommends that you keep the size for the young generation greater than 25% and less than 50% of the overall heap size.</p>
</blockquote>
<p>-Xmn：设置堆中新生代的初始和最大值。<strong>新生代设置小</strong>了，<strong>可用空间少</strong>，创建对象时一旦发现新生代的空间不足就会触发新生代的 <strong>minor gc</strong>。如果新<strong>生代内存太大</strong>了，<strong>老年代的可用空间相对少了</strong>，老年代的空间少了，将来新生代觉得我空闲空间很多，新创建的对象都还不会触发垃圾回收，但是老年代的空间紧张，再触发垃圾回收，就是 full gc，<strong>full gc 的暂停时间比 minor gc 时间更长</strong>。<strong>新生代大于堆内存的 1/4 ,小于 1/2 即可</strong>。</p>
<figure data-type="image" tabindex="45"><img src="https://epitomm.github.io/post-images/%E6%96%B0%E7%94%9F%E4%BB%A3-%E5%90%9E%E5%90%90%E9%87%8F.png" alt="图片" loading="lazy"></figure>
<p><strong>吞吐量</strong>：单位时间能响应的请求数量。</p>
<p>随着新生代空间越来越大，吞吐量越来越高，垃圾回收占用整个 CPU 计算的时间比例少了，CPU时间更多用来处理请求了，吞吐量就变高了，但是到了一定的大小后，会有一个下降：<strong>新生代空间大了，意味着回收的时间较长</strong>。</p>
<p><strong>新生代调整尽可能大</strong>，新生代的垃圾回收都是复制算法，复制算法分成：标记、复制两个阶段，复制阶段花费的时间更多，而<strong>新生代的对象，绝大部分都是朝生夕死的，最终只有少量的对象会存活下来，复制所占用的时间也是相对较短的</strong>，而标记时间相对于复制时间来讲，就显得不是很重要了，所以<strong>新生代调大的情况下，主要时间还是耗费在复制上，即使增得很大，效率也不会有很明显的下降</strong>。</p>
<h3 id="新生代的大小设置">新生代的大小设置</h3>
<ul>
<li><strong>新生代能容纳并发量 *  (一次请求-响应过程产生的对象)的数据</strong>
<ul>
<li>并发量 * 请求 - 响应过程中所产生的的对象</li>
<li>如果一次 请求-响应 过程中产生的对象是 512KB，并发量是 1000，那么新生代理想的内存就是 1000* 512KB = 521M。因为一次 请求-响应的过程，在这次 请求-响应 结束后，大多数对象都会被回收，只要这一次 请求-响应 占用的内存不超过新生代的内存，就不会触发新生代的垃圾回收</li>
</ul>
</li>
<li><strong>幸存区大到能保留当前活跃对象+需要晋升对象</strong>
<ul>
<li>幸存区中有两类对象：<strong>①生命周期较短，下一次垃圾回收就把它回收掉了</strong>，但由于现在还在使用，暂时不能回收；<strong>②将来会被晋升到老年代</strong>，但是由于年龄不够，所以暂时存放在幸存区中。</li>
<li><strong>如果幸存区较小，就会由 JVM 动态调整晋升阈值</strong>，也许本来有些对象不应该晋升的，但是由于幸存区内存不够，导致会提前<strong>把本应回收的对象晋升到老年代</strong>。如果存活时间短的对象被晋升到了老年代，需要等到老年代内存不足，触发 Full GC 时才能把它当做垃圾进行回收，延长了对象的生存时间。</li>
</ul>
</li>
<li><strong>晋升阈值配置得当，让长时间存活对象尽快晋升</strong>
<ul>
<li>如果是一个<strong>长期存活的对象</strong>，把它<strong>留到幸存区里</strong>，只会<strong>耗费幸存区的内存</strong>，并且新生代垃圾回收都是复制算法，要把幸存区的存活对象从 FROM 复制到 TO，如果大量长时间存活的对象不能及早晋升，那么就要留在幸存区被<strong>复制来复制去</strong>。调整晋升阈值，让<strong>长时间存活的对象尽快晋升到老年代</strong>。</li>
</ul>
</li>
</ul>
<p>调整最大晋升阈值：</p>
<pre><code>-XX:MaxTenuringThreshold=threshold 
</code></pre>
<p>显示幸存区对象详情：</p>
<pre><code>-XX:+PrintTenuringDistribution 
</code></pre>
<pre><code>Desired survivor size 48286924 bytes, new threshold 10 (max 10) 
- age 1: 28992024 bytes, 28992024 total 
- age 2: 1366864 bytes, 30358888 total 
- age 3: 1425912 bytes, 31784800 total 
...
</code></pre>
<h2 id="55-老年代调优">5.5 老年代调优</h2>
<h3 id="以-cms-为例">以 CMS 为例</h3>
<p>CMS 垃圾回收器：<strong>低响应时间、并发的</strong>（垃圾回收线程在工作的同时其他用户线程也能在并发的执行：垃圾回收的同时其他用户线程也在运行，就会产生新的浮动垃圾，如果浮动垃圾产生导致内存不足，就会造成 CMS 并发失败，CMS 垃圾回收器退化为 串行老年代垃圾回收器：STW）</p>
<ul>
<li>CMS 的<strong>老年代内存越大越好</strong>
<ul>
<li>预留更多空间，避免浮动垃圾引起的并发失败</li>
</ul>
</li>
<li><strong>先尝试不做调优</strong>，如果没有 Full GC 那么已经可以了，否则先尝试调优新生代</li>
<li>观察<strong>发生 Full GC 时老年代内存占用</strong>，将老年代内存预设调大 1/4 ~ 1/3</li>
</ul>
<pre><code>-XX:CMSInitiatingOccupancyFraction=percent
</code></pre>
<p>老年代的空间占用达到老年代的 percent% 时，触发垃圾回收 percent 越小，老年代垃圾回收触发时间越早。</p>
<h2 id="56-案例">5.6 案例</h2>
<h3 id="案例1-full-gc-和-minor-gc频繁空间紧张">案例1 Full GC 和 Minor GC频繁：空间紧张</h3>
<ul>
<li>问题分析：</li>
</ul>
<p>新生代空间紧张：当业务高峰期来了，大量对象被创建，<strong>新生代被填满</strong>，<strong>幸存区空间紧张</strong>了，<strong>晋升对象的阈值就会降低</strong>，导致很多原来<strong>生存周期很短的对象被晋升到老年代</strong>了，老年代存了大量生存周期很短的对象，进一步触发老年代 <strong>Full GC</strong> 发生。</p>
<ul>
<li>问题解决：</li>
</ul>
<p><strong>增大新生代内存</strong>，新生代内存增大了，内存充裕，新生代的垃圾回收不那么频繁了，增大了幸存区的空间以及晋升阈值，生命周期较短的对象尽可能在幸存区被回收，而不要晋升到老年代，减少老年代 Full GC。</p>
<h3 id="案例2-请求高峰期发生-full-gc单次暂停时间特别长-cms">案例2 请求高峰期发生 Full GC，单次暂停时间特别长 （CMS）</h3>
<ul>
<li>问题分析：</li>
</ul>
<p>查看日志，看 CMS 哪个阶段耗费时间长</p>
<figure data-type="image" tabindex="46"><img src="https://epitomm.github.io/post-images/%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="图片" loading="lazy"></figure>
<p>初始标记和并发标记都是比较快的，<strong>重新标记比较慢</strong>， 查看 GC 日志会把每一阶段耗费的时间显示。</p>
<ul>
<li>问题解决：</li>
</ul>
<p>重新标记会扫描整个内存，不光是要扫描老年代对象，也要同时扫描新生代对象，如果是业务高峰期，新生代对象比较多，扫描标记时间就会很长，因为要根据对象找它的引用，能不能<strong>在重新标记前把新生代的对象做一次垃圾回收</strong>，减少新生代对象的数量，减少重新标记阶段耗费的时间。通过设置：<code>-XX:+CMSScavengeBeforeRemark</code>：在重新标记发生之前，先对新生代进行一次垃圾清理。</p>
<h3 id="案例3-老年代充裕情况下发生-full-gc-cms-jdk17">案例3 老年代充裕情况下，发生 Full GC （CMS jdk1.7）</h3>
<ul>
<li>问题分析：</li>
</ul>
<p>CMS 可能由于空间不足导致并发失败，或者由于空间碎片多都会产生 Full GC。但是经过排查，在 GC 日志没有并发失败或者碎片过多的提示。说明老年代空间充裕，不是由于老年代空间不足产生的 Full GC。<strong>JDK1.7 及以前采用永久代作为方法区的实现，永久代空间不足也会导致 Full GC 发生</strong>，1.8 以后使用元空间就不是由 Java 控制了，所以元空间使用操作系统的空间一般情况是比较充裕的。1.7 以前永久代空间设置小了就会触发整个堆的 Full GC。</p>
<ul>
<li>问题解决：</li>
</ul>
<p>增大永久代的初始值和最大值</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP 系列（二）熟悉 HTTP 协议结构和通讯原理]]></title>
        <id>https://epitomm.github.io/post/http-xi-lie-er-shou-xi-http-xie-yi-jie-gou-he-tong-xun-yuan-li/</id>
        <link href="https://epitomm.github.io/post/http-xi-lie-er-shou-xi-http-xie-yi-jie-gou-he-tong-xun-yuan-li/">
        </link>
        <updated>2020-04-23T06:24:08.000Z</updated>
        <content type="html"><![CDATA[<h1 id="http-特点">HTTP 特点</h1>
<h2 id="支持-客户服务器-模式">支持 客户/服务器 模式</h2>
<p>客户/服务器模式工作的方式是由客户端向服务器发出请求，服务器端响应请求，并进行相应服务。</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/client-server.png" alt="图片" loading="lazy"></figure>
<h2 id="简单快速">简单快速</h2>
<ul>
<li>客户向服务器请求服务时，只需传送<strong>请求方法和路径</strong></li>
<li>请求方法常用的有<strong>GET、HEAD、POST</strong>。每种方法规定了客户与服务器联系的类型不同</li>
<li>由于HTTP协议简单，使得HTTP服务器的程序规模小，因而<strong>通信速度很快</strong></li>
</ul>
<h2 id="灵活">灵活</h2>
<ul>
<li><strong>HTTP允许传输任意类型的数据对象</strong></li>
<li>正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记</li>
</ul>
<h2 id="无连接">无连接</h2>
<ul>
<li>无连接的含义是限制<strong>每次连接只处理一个请求</strong></li>
<li>服务器处理完客户的请求，并收到客户的应答后，即断开连接</li>
<li>采用这种方式可以<strong>节省传输时间</strong></li>
</ul>
<h2 id="无状态">无状态</h2>
<ul>
<li>HTTP协议是无状态协议</li>
<li>无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大</li>
<li>另一方面，在服务器不需要先前信息时它的应答就较快</li>
</ul>
<h1 id="uri-与-url">URI 与 URL</h1>
<p>Q：我们输入在浏览器里的Web地址应该叫URL还是URI？</p>
<p>小A：我们访问的就是<strong>URL</strong>！</p>
<p>小B：不！其实那时<strong>URI</strong>好不好！</p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/URI.png" alt="图片" loading="lazy"></figure>
<ul>
<li>URI：一个紧凑的字符串用来标示抽象或物理资源</li>
<li>A URI 可以进一步被分为定位符、名字或两者都是</li>
<li>术语&quot;Uniform Resource Locator&quot;（URL）是URI的子集，除了确定一个资源，还提供一种定位该资源的主要访问机制（如其网络“位置”）</li>
</ul>
<h2 id="维基百科解释">维基百科解释</h2>
<ul>
<li>URI可以分为URL，URN或同时具备locators 和names特性的一个东西</li>
<li>URN作用就好像一个人的<strong>名字</strong>，URL就像一个人的<strong>地址</strong></li>
<li>换句话说：URN确定了东西的身份，URL提供了找到它的方式</li>
</ul>
<blockquote>
<p>一家公司的总经理有一张名片，上面写了 “北京 xxx 公司总经理张三”、办公室地址 “北京市海淀区长安街35号 xx 楼 xxx 办公室”。<br>
头衔：北京 xxx 公司总经理 —— 张三，建立一个映射，这个头衔就是 URI，<strong>只要看到一个 URI 就知道它代表什么</strong>。<br>
<a href="http://www.baidu.cn">www.baidu.cn</a> —— 百度网，<a href="http://www.baidu.com">www.baidu.com</a> 就是一个 URI<br>
admin@qq.com —— 代表某个人的 QQ 邮箱，admin@qq.com 也是一个 URI<br>
<strong>URI 是一个网络资源的头衔</strong>，是一个统称，通过 URI 可以把网络世界里的每一个事务都加以标记并且区分开来。<br>
“北京 xxx 公司总经理” 是一个 URI，我们知道这个头衔对应的是张三，但是我们不能去找到这个人，因为不知道他的地址，要定位到他就必须要知道他的办公室地址。反映到网络世界，网络世界中的每个资源不只有头衔，还要能够被人访问，所以网络地址也是必须的，否则这个网络资源的存在就没有任何意义了，这个<strong>网络地址就叫做 URL</strong>。</p>
</blockquote>
<ul>
<li>URL是URI的一种，但不是所有的URI都是URL</li>
<li>URI和URL最大的差别是“访问机制（HTTP 还是 FTP）&quot;</li>
<li>URN 是唯一标识的一部分，是身份信息</li>
</ul>
<h2 id="安能辨我是雌雄">安能辨我是雌雄</h2>
<ul>
<li>ftp://ftp.is.co.za/rfc/rfc1808.txt
<ul>
<li>URL，提供了访问机制是 FTP</li>
</ul>
</li>
<li>http://www.ietf.org/rfc/rfc2396.txt
<ul>
<li>URL，提供了访问机制是 HTTP</li>
</ul>
</li>
<li>Idap://[2001:db8::7]/c=GB?objectClass?one
<ul>
<li>URL，提供了访问机制 LDAP</li>
</ul>
</li>
<li>mailto:John.Doe@example.com
<ul>
<li>URL，通过邮件进行访问</li>
</ul>
</li>
<li>news:comp.infosystems.www.servers.unix
<ul>
<li>URL</li>
</ul>
</li>
<li>tel:+1-816-555-1212
<ul>
<li>URI：电话号码可以标识某一个人，但是没有访问机制</li>
</ul>
</li>
<li>telnet://192.0.2.16:80/
<ul>
<li>URL，访问机制 telnet</li>
</ul>
</li>
<li>urn:oasis:names:specification:docbook:dtd:xml:4.1.2
<ul>
<li>URL，地址中已经显示了 urn，没有自己的访问方式</li>
</ul>
</li>
</ul>
<h1 id="http-报文结构分析-请求报文">HTTP 报文结构分析 - 请求报文</h1>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>报文头和报文体中间有一行空行<br>
报文体内是表单的数据，不同参数之间使用 &amp; 进行拼接</p>
</blockquote>
<h2 id="http-报文头">HTTP 报文头</h2>
<ul>
<li>HTTP的报文头大体可以分为四类，分别是：通用报文头、请求报文头、响应报文头和实体报文头</li>
<li>在HTTP/1.1里一共规范了47种报文头字段</li>
</ul>
<h3 id="通用报文头">通用报文头</h3>
<table>
<thead>
<tr>
<th style="text-align:left">首部字段名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Cache-Control</td>
<td style="text-align:left">控制缓存的行为</td>
</tr>
<tr>
<td style="text-align:left">Connection</td>
<td style="text-align:left">逐跳首部、连接的管理</td>
</tr>
<tr>
<td style="text-align:left">Date</td>
<td style="text-align:left">创建报文的日期时间</td>
</tr>
<tr>
<td style="text-align:left">Pragma</td>
<td style="text-align:left">报文指令</td>
</tr>
<tr>
<td style="text-align:left">Trailer</td>
<td style="text-align:left">报文末端的首部一览</td>
</tr>
<tr>
<td style="text-align:left">Transfer-Encoding</td>
<td style="text-align:left">指定报文主体的传输编码方式</td>
</tr>
<tr>
<td style="text-align:left">Upgrade</td>
<td style="text-align:left">升级为其他协议</td>
</tr>
<tr>
<td style="text-align:left">Via</td>
<td style="text-align:left">代理服务器的相关信息</td>
</tr>
<tr>
<td style="text-align:left">Warning</td>
<td style="text-align:left">错误通知</td>
</tr>
</tbody>
</table>
<h3 id="请求报文头">请求报文头</h3>
<table>
<thead>
<tr>
<th style="text-align:left">首部字段名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Accept</td>
<td style="text-align:left">用户代理可处理的媒体类型</td>
</tr>
<tr>
<td style="text-align:left">Accept-Charset</td>
<td style="text-align:left">优先的字符集</td>
</tr>
<tr>
<td style="text-align:left">Accept-Encoding</td>
<td style="text-align:left">优先的内容编码</td>
</tr>
<tr>
<td style="text-align:left">Accept-Language</td>
<td style="text-align:left">优先的语言（自然语言）</td>
</tr>
<tr>
<td style="text-align:left">Authorization</td>
<td style="text-align:left">Web 认证信息</td>
</tr>
<tr>
<td style="text-align:left">Expect</td>
<td style="text-align:left">期待服务器的特定行为</td>
</tr>
<tr>
<td style="text-align:left">From</td>
<td style="text-align:left">用户的电子邮箱地址</td>
</tr>
<tr>
<td style="text-align:left">Host</td>
<td style="text-align:left">请求资源所在服务器</td>
</tr>
<tr>
<td style="text-align:left">If-Match</td>
<td style="text-align:left">比较实体标记（ETag）</td>
</tr>
<tr>
<td style="text-align:left">If-Modified-Since</td>
<td style="text-align:left">比较资源的更新时间</td>
</tr>
<tr>
<td style="text-align:left">If-None-Match</td>
<td style="text-align:left">比较实体标记（与 If-Match 相反）</td>
</tr>
<tr>
<td style="text-align:left">If-Range</td>
<td style="text-align:left">资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td style="text-align:left">If-Unmodified-Since</td>
<td style="text-align:left">比较资源的更新时间（与 If-Modified-Since相反）</td>
</tr>
<tr>
<td style="text-align:left">Max-Forwards</td>
<td style="text-align:left">最大传输逐跳数</td>
</tr>
<tr>
<td style="text-align:left">Proxy-Authorization</td>
<td style="text-align:left">代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td style="text-align:left">Range</td>
<td style="text-align:left">实体的字节范围请求</td>
</tr>
<tr>
<td style="text-align:left">Referrer</td>
<td style="text-align:left">对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td style="text-align:left">TE</td>
<td style="text-align:left">传输编码的优先级</td>
</tr>
<tr>
<td style="text-align:left">User-Agent</td>
<td style="text-align:left">HTTP 客户端程序的信息</td>
</tr>
</tbody>
</table>
<h3 id="响应报文头">响应报文头</h3>
<table>
<thead>
<tr>
<th style="text-align:left">首部字段名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Accept-Ranges</td>
<td style="text-align:left">是否接受字节范围请求</td>
</tr>
<tr>
<td style="text-align:left">Age</td>
<td style="text-align:left">推算资源创建经过时间</td>
</tr>
<tr>
<td style="text-align:left">ETag</td>
<td style="text-align:left">资源的匹配信息</td>
</tr>
<tr>
<td style="text-align:left">Location</td>
<td style="text-align:left">令客户端重定向至指定 URI</td>
</tr>
<tr>
<td style="text-align:left">Proxy-Authenticate</td>
<td style="text-align:left">代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td style="text-align:left">Retry-After</td>
<td style="text-align:left">对再次发起请求的时机要求</td>
</tr>
<tr>
<td style="text-align:left">Server</td>
<td style="text-align:left">HTTP服务器的安装信息</td>
</tr>
<tr>
<td style="text-align:left">Vary</td>
<td style="text-align:left">代理服务器缓存的管理信息</td>
</tr>
<tr>
<td style="text-align:left">WWW-Authenticate</td>
<td style="text-align:left">服务器对客户端的认证信息</td>
</tr>
</tbody>
</table>
<h3 id="实体报文头">实体报文头</h3>
<table>
<thead>
<tr>
<th style="text-align:left">首部字段名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Allow</td>
<td style="text-align:left">资源可支持的 HTTP 方法</td>
</tr>
<tr>
<td style="text-align:left">Content-Encoding</td>
<td style="text-align:left">实体主体使用的编码方式</td>
</tr>
<tr>
<td style="text-align:left">Content-Language</td>
<td style="text-align:left">实体主体的自然语言</td>
</tr>
<tr>
<td style="text-align:left">Content-Length</td>
<td style="text-align:left">实体主体的大小（单位：字节）</td>
</tr>
<tr>
<td style="text-align:left">Content-Location</td>
<td style="text-align:left">替代对应资源的 URI</td>
</tr>
<tr>
<td style="text-align:left">Content-MD5</td>
<td style="text-align:left">实体主体的报文摘要</td>
</tr>
<tr>
<td style="text-align:left">Content-Range</td>
<td style="text-align:left">实体主体的位置范围</td>
</tr>
<tr>
<td style="text-align:left">Content-Type</td>
<td style="text-align:left">实体主体的媒体类型</td>
</tr>
<tr>
<td style="text-align:left">Expires</td>
<td style="text-align:left">实体主体过期的日期时间</td>
</tr>
<tr>
<td style="text-align:left">Last-Modified</td>
<td style="text-align:left">资源的最后修改日期时间</td>
</tr>
</tbody>
</table>
<h2 id="accept">ACCEPT</h2>
<ul>
<li>作用：<strong>浏览器端可以接受的媒体类型</strong></li>
</ul>
<p>Accept:<strong>text/html</strong> 代表浏览器可以接受服务器回发的类型为 text/html 也就是我们常说的 html 文档，如果服务器无法返回 text/html 类型的数据，服务器应该返回一个406错误（Non Acceptable）</p>
<p>如果想要给显示的媒体类型增加优先级，则使用q=来额外表示权重值）；重值 q 的范围是0~1（可精确到小数点后 3 位），且 1 为最大值。不指定权重 q 值时，默认权重为 q=1.0。当服务器提供多种内容时，将会首先返回权重值最高的媒体类型。</p>
<h2 id="accept-encoding">Accept-Encoding</h2>
<ul>
<li>作用：浏览器申明自己接收的<strong>编码方法</strong>，通常指定<strong>压缩</strong>方法，是否支持压缩，支持什么压缩方法（gzip，deflate）
<ul>
<li>Accept-Encoding:gzip，deflate</li>
</ul>
</li>
<li>作用：浏览器申明自己接收的语言
<ul>
<li>Accept-Language:zh-cn, zh; q=0.7, en-us, en; q=0.3</li>
<li>客户端在服务器有中文版资源的情况下，会请求其返回中文版对应的响应，没有中文版时，则请求返回英文版响应</li>
</ul>
</li>
<li><strong>Connection:keep-alive</strong> ：当一个网页打开完成后，客户端和服务器之间<strong>用于传输HTTP数据的TCP连接不会关闭</strong>，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。</li>
<li>Connection:close 代表<strong>一个Request</strong>完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭，当客户端再次发送Request，需要重新建立TCP连接</li>
</ul>
<h2 id="host">Host</h2>
<ul>
<li>作用：请求报头域主要用于指定被请求资源的 <strong>Internet主机和端口号</strong>，它通常从HTTP URL中提取出来的</li>
</ul>
<p>我们在浏览器中输入：http://www.fljf.com:8080 刘览器发送的请求消息中，就会包含Host请求报头域，如下：Host：www.fljf.com:8080</p>
<h2 id="referer">Referer</h2>
<p>当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理</p>
<h2 id="user-agent">User-Agent</h2>
<ul>
<li>作用：告诉HTTP服务器，客户端使用的操作系统和浏览器的名称和版本</li>
<li>很多情况下我们会通过User-Agnet来判断浏览器类型，从而进行不同的兼容设计</li>
</ul>
<h2 id="content-type">Content-Type</h2>
<ul>
<li>作用：说明了报文体内对象的媒体类型</li>
</ul>
<p>text/html：HTML格式</p>
<p>text/plain：纯文本格式</p>
<p>text/xml：XML格式</p>
<p>image/gif：gif图片格式</p>
<p>image/jpeg：jpg图片格式</p>
<p>image/png：png图片格式</p>
<p>application/xhtml+xml：XHTML格式</p>
<p>application/xml：XML数据格式</p>
<p>application/atom+xml：Atom XML聚合格式</p>
<p>application/json：JSON数据格式</p>
<p>application/pdf：pdf格式</p>
<p>application/msword：Word文档格式</p>
<p>application/octet-stream：二进制流数据（如常见的文件下载）</p>
<p>application/x-www-form-urlencoded：表单提交</p>
<h1 id="http-报文结构分析-响应报文">HTTP 报文结构分析 - 响应报文</h1>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.png" alt="图片" loading="lazy"></figure>
<h1 id="http-请求方法剖析">HTTP 请求方法剖析</h1>
<p>HTTP/1.1常用方法</p>
<p>①GET</p>
<p>② POST</p>
<p>③ PUT</p>
<p>④HEAD</p>
<p>⑤ DELETE</p>
<p>⑥OPTIONS</p>
<p>⑦TRACE</p>
<p>③ CONNECT</p>
<h2 id="get-获取资源">GET 获取资源</h2>
<ul>
<li>GET方法用来请求访问已被URI识别的资源</li>
<li>指定的资源经服务器端解析后返回响应内容</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/GET%E8%AF%B7%E6%B1%82.png" alt="图片" loading="lazy"></figure>
<ul>
<li>GET方法也可以用来提交表单和其他数据</li>
<li>http://localhost/login.php?username=aa&amp;password=1234 从上面的 URL 请求中，很容易就可以辩认出表单提交的内容</li>
</ul>
<h2 id="post">POST</h2>
<ul>
<li>POST 方法与 GET 功能类似，一般用来<strong>传输实体的主体</strong></li>
<li>POST 方法的主要目的不是获取响应主体的内容</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/POST%E8%AF%B7%E6%B1%82.png" alt="图片" loading="lazy"></figure>
<h3 id="说下-get-和-post-的区别">说下 GET 和 POST 的区别？</h3>
<p>GET 和 POST 本质都是 HTTP 请求，只不过对它们的作用做了界定和适配，并且让他们适应各自的场景。</p>
<ul>
<li>本质区别：GET 只是一次 HTTP请求，POST 先发请求头再发请求体，实际上是两次请求。</li>
<li>从功能上讲，GET 一般用来<strong>从服务器上获取资源</strong>，POST 一般用来<strong>更新服务器上的资源</strong>；</li>
<li>从 REST 服务角度上说，<strong>GET 是幂等</strong>的，即读取同一个资源，总是得到相同的数据，而 <strong>POST 不是幂等</strong>的，因为每次请求对资源的改变并不是相同的；进一步地，GET 不会改变服务器上的资源，而 POST 会对服务器资源进行改变；</li>
<li>从请求参数形式上看，<strong>GET 请求的数据会附在 URL 之后</strong>，即将请求数据放置在 HTTP 报文的 请求头 中，以 ? 分割 URL 和传输数据，参数之间以 &amp; 相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用 BASE64 加密，得出如：%E4%BD%A0%E5%A5%BD，其中 ％XX 中的 XX 为该符号以 16 进制表示的 ASCII)；而 **POST 请求会把提交的数据则放置在是 HTTP 请求报文的 **<strong>请求体</strong> 中；</li>
<li>就安全性而言，<strong>POST 的安全性要比 GET 的安全性高</strong>，因为 GET 请求提交的数据将明文出现在 URL 上，而且 POST 请求参数则被包装到请求体中，相对更安全；</li>
<li>从请求的大小看，GET 请求的长度受限于浏览器或服务器对 URL 长度的限制，允许发送的数据量比较小，而 POST 请求则是没有大小限制的。</li>
</ul>
<h2 id="put">PUT</h2>
<ul>
<li>从客户端向服务器传送的数据<strong>取代指定的文档的内容</strong></li>
<li>PUT方法与POST方法最大的不同是：PUT是幂等的，而POST是不幂等的</li>
<li>因此，我们更多时候将PUT方法用作传输资源</li>
</ul>
<blockquote>
<p>创建对象用 POST，更新对象用 PUT。<br>
但是，HTTP1.1 的 PUT 方法不带有验证机制，存在一定的安全问题，所以一般不使用 PUT，更新对象可以使用 POST 请求，然后在后端代码逻辑处理。</p>
</blockquote>
<h2 id="headdelete">HEAD/DELETE</h2>
<ul>
<li>HEAD类似于GET请求，只不过返回的响应中没有具体的内容，用于<strong>获取报头</strong>。</li>
<li>DELETE请求服务器删除指定的资源。</li>
</ul>
<blockquote>
<p>DELETE 方法没有验证机制，所以一般不使用。</p>
</blockquote>
<h2 id="options">OPTIONS</h2>
<p>用来查询针对请求URI指定的资源支持的方法</p>
<blockquote>
<p>不知道对方支持什么方法，询问一下。</p>
</blockquote>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/OPTIONS%E8%AF%B7%E6%B1%82.png" alt="图片" loading="lazy"></figure>
<h2 id="traceconnect">TRACE/CONNECT</h2>
<ul>
<li>TRACE：回显服务器收到的请求，主要用于测试或诊断</li>
</ul>
<blockquote>
<p>容易引发 XSP 攻击，所以一般不使用 TRACE 请求</p>
</blockquote>
<ul>
<li>CONNECT：开启一个客户端与所请求资源之间的双向沟通的通道，它可以用来创建隧道</li>
</ul>
<blockquote>
<p>代理服务器访问互联网时，就是用 CONNECT 方法。<br>
浏览器向代理服务器发送 CONNECT 请求，代理服务器返回状态码 200，浏览器就和服务器三次握手交换数据，代理服务器只负责传输彼此的数据包，并不能读取数据内容。</p>
</blockquote>
<h1 id="状态码">状态码</h1>
<p>是用以表示网页服务器超文本传输协议响应状态的3位数字代码。</p>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/%E7%8A%B6%E6%80%81%E7%A0%81.png" alt="图片" loading="lazy"></figure>
<h2 id="http-状态码详解">HTTP 状态码详解</h2>
<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1XX</td>
<td style="text-align:left">表示消息。这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。</td>
</tr>
<tr>
<td style="text-align:left">2XX</td>
<td style="text-align:left">表示<strong>成功</strong>。这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。</td>
</tr>
<tr>
<td style="text-align:left">3XX</td>
<td style="text-align:left">表示<strong>重定向</strong>。这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。</td>
</tr>
<tr>
<td style="text-align:left">4XX</td>
<td style="text-align:left">表示<strong>请求错误</strong>。这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。</td>
</tr>
<tr>
<td style="text-align:left">5XX</td>
<td style="text-align:left">表示<strong>服务器错误</strong>。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。</td>
</tr>
</tbody>
</table>
<h3 id="常用http状态码">常用HTTP状态码</h3>
<p>2XX 状态码：</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">状态码英文名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">200</td>
<td style="text-align:left">OK</td>
<td style="text-align:left">请求已成功，请求所希望的响应头或数据体将随此响应返回</td>
</tr>
<tr>
<td style="text-align:left">202</td>
<td style="text-align:left">Accepted</td>
<td style="text-align:left">已接受，已经接受请求，但未处理完成</td>
</tr>
<tr>
<td style="text-align:left">206</td>
<td style="text-align:left">Partial Content</td>
<td style="text-align:left">部分内容，服务器成功处理了部分GET请求</td>
</tr>
</tbody>
</table>
<p>3XX 状态码：</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">状态码英文名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">301</td>
<td style="text-align:left">Moved Permanently</td>
<td style="text-align:left"><strong>永久移动</strong>，请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替（<strong>更换域名</strong>）</td>
</tr>
<tr>
<td style="text-align:left">302</td>
<td style="text-align:left">Found</td>
<td style="text-align:left">临时移动，与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
</tbody>
</table>
<p>4XX 状态码：</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">状态码英文名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left">Bad Request</td>
<td style="text-align:left">客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td style="text-align:left">401</td>
<td style="text-align:left">Unauthorized</td>
<td style="text-align:left">请求要求用户的身份认证</td>
</tr>
<tr>
<td style="text-align:left">403</td>
<td style="text-align:left">Forbidden</td>
<td style="text-align:left">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td style="text-align:left">404</td>
<td style="text-align:left">Not Found</td>
<td style="text-align:left">服务器无法根据客户端的请求找到资源（网页）。</td>
</tr>
</tbody>
</table>
<p>5XX 状态码：</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">状态码英文名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left">Internal Server Error</td>
<td style="text-align:left">服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td style="text-align:left">502</td>
<td style="text-align:left">Bad Gateway</td>
<td style="text-align:left">充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</td>
</tr>
</tbody>
</table>
<h1 id="http状态管理cookie与session">HTTP状态管理：Cookie与Session</h1>
<p>HTTP 是无状态协议，每个请求都是独立的，如果后续处理需要前面的信息，必须重传，就会导致连接传送的数据量增大，于是引入 Cookie 和 Session 保存 HTTP 连接状态。</p>
<h2 id="cookie">Cookie</h2>
<ul>
<li>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就向客户端浏览器颁发一个Cookie。</li>
<li><strong>客户端浏览器</strong>会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态<br>
<img src="https://epitomm.github.io/post-images/cookie.png" alt="图片" loading="lazy"></li>
</ul>
<blockquote>
<p>在浏览器地址栏输入 www.baidu.com ，浏览器向百度服务器发送读取网页的请求，并且把结果显示回显示器上。<br>
发送之前，这个网页在本机电脑上寻找百度网站设置的 cookie 文件，如果找到，浏览器会把 cookie 文件中的数据连同 url 一同发送给百度服务器，服务器收到数据，就会在它的数据库中检索 id、搜索记录等信息，并且记录下这次新的内容，增加到数据库和 cookie 文件中。如果没有检测到 cookie，或者 cookie 信息与数据库信息不符合，说明这是第一次浏览这个网站，服务器就会创建一个新的 id，并且保存到数据库，并给浏览器下发一个 cookie，这样下一次访问就会像前面描述的那样查到 cookie 记录了。</p>
</blockquote>
<h2 id="cookie-工作原理">Cookie 工作原理</h2>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/cookie%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="图片" loading="lazy"></figure>
<p>1.浏览器发送请求到服务器</p>
<p>2.如果是第一次访问这个服务器，服务器 set-cookie</p>
<p>3.服务器通过 set-cookie 这样的一个响应头把 cookie 发送给客户端</p>
<p>4.客户端读取到 set-cookie 之后，把 cookie 存储到本地的文本文件中</p>
<p>5.再次发送请求，会把 cookie 一起发送到服务器端</p>
<p>6.服务器接收到这个 cookie，检查 cookie，证明没问题，确实是我已经存在的用户了，返回响应结果。</p>
<h2 id="session">Session</h2>
<ul>
<li>Session是另一种记录客户状态的机制，保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上</li>
<li>客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了</li>
</ul>
<p>##Session 工作原理<br>
<img src="https://epitomm.github.io/post-images/session%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="图片" loading="lazy"></p>
<blockquote>
<p>用户访问一个服务器，如果服务器启用 session，服务器就要为这个用户创建一个 session，在创建这个 session 的时候，服务器首先检查这个用户发来的请求里，是否包含一个 sessionID，如果包含了，就说明这个用户此前已经登陆过，并且已经创建过 session，就按照这个 sessionID 把 session 从服务器的内存中查找出来。如果查找不到或客户端请求就不包含这个 sessionID，就为这个客户端创建一个新的 session，并且生成一个与此 session 相关的 sessionID，这个 sessionID 在服务端是唯一的，这个 sessionID会在这一次响应中返回到客户端进行保存，保存这个 sessionID 的正是 cookie。</p>
</blockquote>
<h2 id="保存session-id的方式">保存Session ID的方式</h2>
<ul>
<li>Cookie</li>
<li>URL重写：
<ul>
<li>https://.../xxx?sessionID=BpRZx3lQx33ccEoU6QZcEb64（参数）</li>
<li>https://.../xxx;SessionID=BpRZx3lQx33ccEoU6QZcEb64（路径附加信息）</li>
</ul>
</li>
<li>隐藏表单</li>
</ul>
<h2 id="session的有效期">Session的有效期</h2>
<ul>
<li>Session超时失效
<ul>
<li>服务器空间有限，设置 session 有效时间，防止更多的用户访问造成服务器内存溢出</li>
</ul>
</li>
<li>程序调用HttpSession.invalidate()
<ul>
<li>点击退出，手动调用 session 失效方法</li>
</ul>
</li>
<li>服务器进程被停止</li>
<li>Cokie 与 Session理存放位置不同
<ul>
<li>Cookie 保存在客户端</li>
<li>Session 保存在服务端</li>
</ul>
</li>
<li>安全性（隐私策略）的不同
<ul>
<li>Cookie 存储在浏览器，对客户端可见，客户端的程序可修改 Cookie 中的内容</li>
<li>Session 存储在服务器端，对客户端来说是透明的，不存在敏感信息泄露的风险</li>
</ul>
</li>
<li>有效期的不同
<ul>
<li>设置 Cookie 的过期时间为很大的数字，Cookie 就可以在浏览器保存很长时间</li>
<li>服务器端会定时清理超时的 sessionID，避免出现过大的压力</li>
<li>session 依赖名为 sessionID 这样类似的 cookie，而 cookie 的 sessionID 过期时间默许是 -1，所以只要关闭了浏览器，也就是<strong>一次会话</strong>结束，这个 session 就失效了。</li>
</ul>
</li>
<li>对服务器压力的不同
<ul>
<li>session 保管在服务器端，每个用户都保存一个 session，耗费大量内存。</li>
<li>cookie 保存在客户端，不太占用服务器的资源。</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode876. 链表的中间结点]]></title>
        <id>https://epitomm.github.io/post/leetcode876-lian-biao-de-zhong-jian-jie-dian/</id>
        <link href="https://epitomm.github.io/post/leetcode876-lian-biao-de-zhong-jian-jie-dian/">
        </link>
        <updated>2020-04-23T02:57:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个带有头结点 head 的非空单链表，返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<h2 id="示例">示例</h2>
<p>示例 1：</p>
<p>输入：[1,2,3,4,5]<br>
输出：此列表中的结点 3 (序列化形式：[3,4,5])<br>
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。<br>
注意，我们返回了一个 ListNode 类型的对象 ans，这样：<br>
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.</p>
<p>示例 2：</p>
<p>输入：[1,2,3,4,5,6]<br>
输出：此列表中的结点 4 (序列化形式：[4,5,6])<br>
由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</p>
<p>提示：</p>
<p>给定链表的结点数介于 1 和 100 之间。</p>
<h2 id="方法一遍历两次链表">方法一：遍历两次链表</h2>
<h3 id="问题分析">问题分析</h3>
<ul>
<li>
<p>遍历链表，记录下链表长度 length。</p>
</li>
<li>
<p>再遍历链表返回第 length/2 个节点。</p>
</li>
</ul>
<h3 id="复杂度分析">复杂度分析</h3>
<ul>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
</ul>
<p>链表节点数为奇数个时：</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9.png" alt="图片" loading="lazy"></figure>
<p>链表节点数为偶数个时：</p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B92.png" alt="图片" loading="lazy"></figure>
<h3 id="代码">代码</h3>
<pre><code>public class AlgoCasts {
  public class ListNode {
    int val;
    ListNode next;
    ListNode(int x) {
      val = x;
    }
  }
  // Time: O(n), Space: O(1)
  public ListNode getMiddleNodeTwoPass(ListNode head) {
    ListNode p = head;
    int len = 0;
    for (; p != null; p = p.next) ++len;
    p = head;
    for (int i = 0; i &lt; len/2; ++i) p = p.next;
    return p;
  }
}
</code></pre>
<h2 id="方法二快慢指针">方法二：快慢指针</h2>
<h3 id="问题分析-2">问题分析</h3>
<p>快指针一次走两步，慢指针一次走一步，<strong>当快指针遍历完链表时，慢指针正好指向中间节点</strong>。</p>
<h3 id="复杂度分析-2">复杂度分析</h3>
<ul>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
</ul>
<pre><code>while(fast != nul &amp;&amp; fast.next != null){
  fast = fast.next.next; // 快指针移动两步
  slow = slow.next; // 慢指针移动一步
}  
</code></pre>
<p>链表节点数为奇数个时：<br>
<img src="https://epitomm.github.io/post-images/%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9_%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%881.png" alt="图片" loading="lazy"></p>
<p>链表节点数为偶数个时：<br>
<img src="https://epitomm.github.io/post-images/%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9_%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%882.png" alt="图片" loading="lazy"></p>
<h3 id="代码-2">代码</h3>
<pre><code>public class AlgoCasts {
  public class ListNode {
    int val;
    ListNode next;
    ListNode(int x) {
      val = x;
    }
  }
  // Time: O(n), Space: O(1)
  public ListNode getMiddleNodeOnePass(ListNode head) {
    ListNode fast = head, slow = head;
    while (fast != null &amp;&amp; fast.next != null) {
      fast = fast.next.next;
      slow = slow.next;
    }
    return slow;
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP系列（一）了解 HTTP 协议]]></title>
        <id>https://epitomm.github.io/post/httpyi-liao-jie-http-xie-yi/</id>
        <link href="https://epitomm.github.io/post/httpyi-liao-jie-http-xie-yi/">
        </link>
        <updated>2020-04-21T09:10:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="浏览器背后的故事">浏览器背后的故事</h1>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%85%E4%BA%8B.png" alt="图片" loading="lazy"></figure>
<ol>
<li>在浏览器地址栏<strong>输入域名</strong>想要访问某个网站，但是真正标识服务器的而是 IP 地址。</li>
<li>根据域名到 <strong>DNS 服务器中查询目标服务器对应的 IP 地址</strong></li>
<li>浏览器根据查询到的 IP 地址<strong>与 WEB 服务器进行通信</strong>，通信的协议就是 HTTP 协议。</li>
</ol>
<blockquote>
<p>把这个过程类比为电话通信的过程。如果我们想要给某个人打电话。</p>
<ol>
<li>从通讯录翻到这个人的名字（域名）</li>
<li>实际拨打过去的电话号（IP 地址）<br>
我们很容易记住姓名，但很难记住每个人的电话号。</li>
<li>打通电话后需要进行对话，就需要两个人使用共同的语言（HTTP 协议）。</li>
</ol>
</blockquote>
<ol>
<li>WEB 服务器收到请求，到后端进行执行，将执行结果以<strong>响应报文</strong>的形式回传到浏览器，如果直接将响应报文展示出来，是一串串代码，普通人难以理解。</li>
<li>浏览器对响应报文进行<strong>渲染</strong>，使用 HTML 描述对应数据，把网页资源的源代码转换为图像结果。</li>
</ol>
<h2 id="http">HTTP</h2>
<ul>
<li>超文本传输协议（HTTP）是一种<strong>通信协议</strong>，它允许将超文本标记语言（HTML）文档从Web服务器传送到客户端的浏览器。</li>
</ul>
<blockquote>
<p>超文本传输协议：传输超文本（HTML）的协议。在服务端和客户端传输 HTML 要遵守的<strong>规则</strong>。</p>
</blockquote>
<ul>
<li>HTTP是一个属于<strong>应用层的面向对象的协议</strong>，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展</li>
</ul>
<h2 id="web-与-http">WEB 与 HTTP</h2>
<ul>
<li>WEB是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式<strong>图形信息系统</strong>。</li>
<li>建立在Internet上的一种<strong>网络服务</strong>，为浏览者在Internet上查找和浏览信息提供了图形化的、易于访问的直观界面，其中的文档及超级链接将Internet上的信息节点组织成一个互为关联的网状结构。</li>
</ul>
<h1 id="http-协议的前世今生">HTTP 协议的前世今生</h1>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.png" alt="图片" loading="lazy"></figure>
<h1 id="透过-tcpip-看-http">透过 TCP/IP 看 HTTP</h1>
<ul>
<li>HTTP协议是构建在 <strong>TCP/IP</strong> 协议之上的，是TCP/IP协议的一个子集</li>
<li>为了更好的理解HTTP协议，我们先了解一下TCP/IP的相关知识。</li>
</ul>
<h2 id="tcpip协议族">TCP/IP协议族</h2>
<ul>
<li>TCP/IP 协议其实是一系列与互联网相关联的协议集合起来的总称</li>
<li>分层管理是 TCP/IP 协议的重要特征</li>
</ul>
<h2 id="tcpip协议族分层">TCP/IP协议族分层</h2>
<ul>
<li>TCP/IP协议族是由一个四层协议组成的系统，这四层分别为：和数据链路层、网络层、运输层、应用层</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E5%9B%9B%E5%B1%82%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84.png" alt="图片" loading="lazy"></figure>
<h3 id="应用层">应用层</h3>
<ul>
<li>应用层一般是我们编写的应用程序，决定了向用户提供的应用服务。应用层可以通过系统调用与传输层进行通信。</li>
<li>如：<strong>FTP、DNS、HTTP</strong>等。</li>
</ul>
<h3 id="传输层">传输层</h3>
<ul>
<li>传输层通过系统调用向应用层提供处于网络连接中的两台计算机之间的数据传输功能。</li>
<li>在传输层有两个性质不同的协议：**TCP **和 <strong>UDP</strong>。</li>
</ul>
<h3 id="网络层">网络层</h3>
<ul>
<li>网络层用来处理在网络上流动的数据包，数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（<strong>传输路线</strong>）到达对方计算机，并把数据包传输给对方。</li>
</ul>
<h3 id="链路层">链路层</h3>
<ul>
<li>链路层用来处理连接网络的<strong>硬件</strong>部分，包括控制操作系统、硬件设备驱动、NIC（Network Interface Card，网络适配器）以及光纤等物理可见部分。硬件上的范畴均在链路层的作用范围之内。</li>
</ul>
<h2 id="数据包的封装过程">数据包的封装过程</h2>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%B0%81%E8%A3%85%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<h2 id="http-数据传输过程">HTTP 数据传输过程</h2>
<p>发送端发送数据时，数据会从上层传输到下层，且每经过一层都会被打上该层的头部信息。而接收端接收数据时，数据会从下层传输到上层，传输前会把下层的头部信息删除</p>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/HTTP%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<p>发送端从应用层向下走，接收端从链路层向上走。</p>
<ul>
<li>作为发送端的客户端，在<strong>应用层</strong>，通过 HTTP 协议发出一个请求，</li>
<li>为了传输方便，在<strong>传输层</strong>，通过 TCP 协议把应用层收到的数据（HTTP 请求报文）进行分割并且在各个报文上打上标记序号、端口号等信息，发送到网络层</li>
<li>在<strong>网络层</strong>，通过 IP 协议，增加作为目的地的 MAC 地址，转发给链路层。</li>
<li><strong>链路层</strong>添加帧头、帧尾后，通过电信号传输给接收端。</li>
<li><strong>接收端</strong>的服务器在链路层接收到请求的数据，按顺序向上层发送，一直发送到应用层。</li>
</ul>
<h2 id="传输层-tcp-三次握手">传输层 —— TCP 三次握手</h2>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="图片" loading="lazy"></figure>
<p>使用TCP协议进行通信的双方必须先建立连接，然后才能开始传输数据。为了确保连接双方可靠性，在双方建立连接时，TCP协议采用了三次握手策略。</p>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B2.png" alt="图片" loading="lazy"></figure>
<ul>
<li><strong>第一次握手</strong>：客户端发送带有 SYN 标志的连接请求报文段，然后进入SYN_SEND状态，等待服务端的确认。</li>
</ul>
<blockquote>
<p>客户端：客户端发送能力正常<br>
服务端：客户端发送能力正常、服务端接收能力正常</p>
</blockquote>
<ul>
<li><strong>第二次握手</strong>：服务端接收到客户端的 SYN 报文段后，需要发送 ACK 信息对这个 SYN 报文段进行确认。同时，还要发送自己的 SYN 请求信息。服务端会将上述的信息放到一个报文段（SYN+ACK报文段）中，一并发送给客户端，此时服务端将会进入SYN_RECV状态。</li>
</ul>
<blockquote>
<p>客户端：客户端发送能力正常、服务端接收能力正常、客户端接收能力正常、服务端发送能力正常<br>
服务端：客户端发送能力正常、服务端接收能力正常</p>
</blockquote>
<ul>
<li><strong>第三次握手</strong>：客户端接收到服务端的 SYN+ACK 报文段后，会向服务端发送 ACK 确认报文段，这个报文段发送完毕后，客户端和服务端都进入 ESTABLISHED 状态，完成 TCP 三次握手。</li>
</ul>
<blockquote>
<p>客户端：客户端发送能力正常、服务端接收能力正常、客户端接收能力正常、服务端发送能力正常<br>
服务端：客户端发送能力正常、服务端接收能力正常、客户端端接收能力正常、服务端发送能力正常</p>
</blockquote>
<p>三次握手结束后，发送、接收双方都确认了彼此的发送和接收能力都正常。</p>
<h3 id="为什么两次握手不可以">为什么两次握手不可以？</h3>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8D%E5%8F%AF%E4%BB%A5.png" alt="图片" loading="lazy"></figure>
<p>为了防止已经失效的连接请求报文段突然又传送到了 B，因而产生错误。比如下面这种情况：A 发出的第一个连接请求报文段并没有丢失，而是在网路结点长时间滞留了，以致于延误到连接释放以后的某个时间段才到达 B。本来这是一个早已失效的报文段。但是 B 收到此失效的链接请求报文段后，就<strong>误认为 A 又发出一次新的连接请求</strong>。于是就向 A 发出确认报文段，同意建立连接。</p>
<p>对于上面这种情况，如果不进行第三次握手，<strong>B 发出确认后就认为新的运输连接已经建立了</strong>，并一直等待 A 发来数据。B 的许多资源就这样白白浪费了。</p>
<p>如果采用了三次握手，由于 A 实际上并没有发出建立连接请求，所以不会理睬 B 的确认，也不会向 B 发送数据。B 由于收不到确认，就知道 A 并没有要求建立连接。</p>
<h1 id="dns-域名解析">DNS 域名解析</h1>
<ul>
<li>已经介绍了与HTTP协议有着密切关系的TCP/IP协议，接下来介绍的DNS服务也是与HTTP协议有着密不可分的关系。</li>
<li>通常我们访问一个网站，使用的是主机名或者域名来进行访问的。因为相对于IP地址（一组纯数字），域名更容易让人记住。 但TCP/IP协议使用的是IP地址进行访问的，所以必须有个机制或服务把域名转换成IP地址。<strong>DNS</strong>服务就是用来解决这个问题的，它提供<strong>域名到IP地址之间的解析</strong>服务。</li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.png" alt="图片" loading="lazy"></figure>
<p>DNS 服务解析是有层次的，就近原则。</p>
<ul>
<li>本地电脑会将经常使用的域名和 IP 地址建立映射关系并且保存到<strong>系统文件</strong>中，在进行 DNS 解析时，系统会优先从 <strong>hosts 文件</strong>去寻找对应的 IP 地址，如果找到，直接使用 hosts 文件中的 IP 地址。</li>
<li>如果本地 hosts 文件没有找到该域名对应的 IP 地址的映射，向<strong>本地 DNS 服务器</strong>发送请求，查询域名对应的 IP 地址，本地域名服务器找到对应的 IP 地址，响应给浏览器。本地 DNS 服务有限，如果没有找到，依次向上层 DNS 服务器发起请求，</li>
<li>直到 <strong>DNS 根服务器</strong>，如果找到则返回。</li>
</ul>
<h2 id="dns-解析过程">DNS 解析过程</h2>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<h1 id="回溯-http-事务处理过程">回溯 HTTP 事务处理过程</h1>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/HTTP%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<p>当客户端访问Web站点时，首先会通过DNS服务查询到域名的IP地址。然后浏览器生成HTTP请求，并通过TCP/IP协议发送给Web服务器。Web服务器接收到请求后会根据请求生成响应内容，并通过TCP/IP协议返回给客户端。</p>
<h2 id="http-事务处理完整过程">HTTP 事务处理完整过程</h2>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/HTTP%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<ul>
<li>如果使用客户端浏览器浏览页面，需要从中分解出协议名、主机名、端口、对象路径等，得到协议是 HTTP 协议、主机是 mooc.com 主机、端口是 80 端口、路径是 mooc 的根节点。在这一步需要通过 DNS 服务器解析出它的 <strong>IP 地址</strong>。</li>
<li><strong>封装 HTTP 请求的数据包</strong>，把以上部分结合自己的本机信息封装成一个 HTTP 请求的数据包。</li>
<li>数据报向下封装成 <strong>TCP 包</strong>，<strong>三次握手建立 TCP 连接</strong>。</li>
<li>客户端<strong>发送请求</strong>给服务器</li>
<li>服务器进行<strong>响应</strong>，消息体有状态码、版本号</li>
<li><strong>释放 TCP 连接</strong></li>
</ul>
<h1 id="实验">实验</h1>
<ul>
<li>现在，我们已经了解了HTTP协议的基本概念，也知道了我们是如何从浏览器访问到我们想要的网站资源的。</li>
<li>那么对于浏览器来说，HTTP请求到底是什么样子的呢？让我们一起来跟踪查看一下！</li>
</ul>
<h2 id="环境搭建">环境搭建</h2>
<p>下载抓包工具：<a href="https://www.wireshark.org/">https://www.wireshark.org/</a></p>
<h2 id="实验过程">实验过程</h2>
<p>1.因为连接的是 WIFI，所以选择 WLAN，如下：</p>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/wireshark%E9%80%89%E6%8B%A9WLAN.png" alt="图片" loading="lazy"></figure>
<p>2.浏览器栏输入域名 <a href="http://www.baidu.com">www.baidu.com</a>（HTTPS协议）</p>
<p><a href="http://www.jszg.edu.cn/portal/home/index">http://www.jszg.edu.cn/portal/home/index</a>（HTTP协议）</p>
<p>3.Wireshark 点击停止</p>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/wireshark%E5%81%9C%E6%AD%A2.png" alt="图片" loading="lazy"></figure>
<p>4.分析处理过程</p>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/wrieshark%E5%88%86%E6%9E%90%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL 索引详解]]></title>
        <id>https://epitomm.github.io/post/mysql-suo-yin-xiang-jie/</id>
        <link href="https://epitomm.github.io/post/mysql-suo-yin-xiang-jie/">
        </link>
        <updated>2020-04-20T02:53:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="存储引擎">存储引擎</h2>
<p><code>InnoDB</code>：不加任何条件 <code>select</code> 出来的数据是排好序的（按主键字段排序）——聚簇索引。<code>MySQL</code>默认的存储引擎是 <code>InnoDB</code>。</p>
<p><code>MyISAM</code>：不加任何条件 <code>select</code> 出来的数据是没有排序的（按照插入顺序输出）——堆表</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"><code>MyISAM</code></th>
<th style="text-align:center"><code>InnoDB</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>锁级别</strong></td>
<td style="text-align:center">只有<strong>表级锁</strong></td>
<td style="text-align:center">支持<strong>行级锁和表级锁</strong>，默认为行级锁</td>
</tr>
<tr>
<td style="text-align:center">查询性能</td>
<td style="text-align:center">强调的是性能，每次查询具有原子性，执行速度快</td>
<td style="text-align:center">使用了聚簇索引、或需要访问的数据可以放入内存的应用下速度快</td>
</tr>
<tr>
<td style="text-align:center"><strong>是否支持事务</strong></td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center"><strong>是否支持崩溃后的安全恢复</strong></td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">支持。事务、回滚、崩溃修复能力和事务安全型表</td>
</tr>
<tr>
<td style="text-align:center">是否支持外键</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center">是否支持 <code>MVCC</code></td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">支持。应对高并发事务，<code>MVCC</code>比单纯的加锁更高效。<code>MVCC</code>只在<code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作；<code>MVCC</code> 可以使用乐观锁和悲观锁来实现。</td>
</tr>
<tr>
<td style="text-align:center">其他功能</td>
<td style="text-align:center">全文索引、压缩、空间函数</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="索引的分类">索引的分类</h2>
<h3 id="哈希索引">哈希索引</h3>
<ul>
<li>Hash索引底层的数据结构是<strong>哈希表</strong>。</li>
<li>Hash 索引仅仅能满足 &quot;=&quot;、&quot;IN&quot; 的<strong>等值查询</strong>，不能使用范围查询。</li>
<li>Hash 索引不能利用组合索引的<strong>部分索引键</strong>查询。</li>
<li>Hash 索引遇到大量 Hash 值相等的情况后会发生<strong>碰撞</strong>，性能不一定会比 B+树 高。</li>
</ul>
<h3 id="b树-索引">B+树 索引</h3>
<ul>
<li>B+树 索引底层的数据结构是 <strong>B+树</strong>。</li>
<li>B+树 索引支持<strong>范围查询</strong></li>
<li>B+树 索引可以使用组合索引的<strong>部分索引</strong>键查询。</li>
</ul>
<h4 id="innodb-的-b树聚簇索引"><code>InnoDB</code> 的 B+树：聚簇索引</h4>
<p><code>InnoDB</code> 中索引即数据，也就是聚簇索引的B+树的叶子节点中包含完整的数据记录。</p>
<p><code>InnoDB</code> 的 B+Tree 索引分为主索引和辅助索引。</p>
<p>主索引的叶子节点 data 域记录着<strong>完整的数据记录</strong>，这种索引方式被称为<strong>聚簇索引</strong>。</p>
<p>辅助索引的叶子节点的 data 域记录着<strong>主键的值</strong>，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>
<h5 id="聚簇索引">聚簇索引</h5>
<p>聚簇索引的特点：</p>
<ol>
<li>按<strong>主键值的大小</strong>进行记录和页的排序：</li>
</ol>
<ul>
<li>
<p>数据页(叶子节点)里的记录是按照主键值从小到大排序的一个单向链表。</p>
</li>
<li>
<p>数据页(叶子节点)之间也是是按照主键值从小到大排序的一个双向链表。</p>
</li>
<li>
<p>B+树中同一个层的页目录也是按照主键值从小到大排序的一个双向链表。</p>
</li>
</ul>
<ol start="2">
<li>B+树的<strong>叶子节点</strong>存储的是完整的用户记录，就是指这个记录中<strong>存储了所有列的值</strong>（包括隐藏列）。</li>
</ol>
<p>具有这两种特性的B+树称为<strong>聚簇索引</strong>，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在<code>MySQL</code>语句中显式的使用<code>INDEX</code>语句去创建。<code>InnoDB</code>存储引擎会自动的为我们创建聚簇索引。在<code>InnoDB</code>存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的<strong>索引即数据</strong>，数据即索引。</p>
<h4 id="myisam-的-b树非聚簇索引"><code>MyISAM</code> 的 B+树：非聚簇索引</h4>
<p><code>InnoDB</code> 中索引即数据，也就是聚簇索引的那棵B+树的叶子节点中已经把所有完整的用户记录都包含了，而<code>MyISAM</code> 的索引方案虽然也使用树形结构，但是却将<strong>索引和数据分开存储</strong>：</p>
<ul>
<li>
<p>将表中的记录按照记录的<strong>插入顺序</strong>单独存储在一个文件中，称之为数据文件。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。我们可以通过<strong>行号</strong>而快速访问到一条记录。</p>
</li>
<li>
<p>使用 <code>MyISAM</code> 存储引擎的表会把索引信息另外存储到一个称为<strong>索引文件</strong>的另一个文件中。<code>MyISAM</code>会单独为表的主键创建一个索引，只不过在索引的<strong>叶子节点</strong>中存储的不是完整的用户记录，而是<strong>主键值+行号</strong>的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录！这一点和<code>InnoDB</code>是完全不相同的，在<code>lnnoDB</code>存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在<code>MyISAM</code>中却需要进行一次回表操作，意味着<code>MyISAM</code>中建立的索引相当于全部都是二级索引！</p>
</li>
<li>
<p>如果有需要的话，我们也可以对其它的列分别建立索引或者建立联合索引，原理和<code>InnoDB</code>中的索引差不多，不过在叶子节点处存储的是相应的<strong>列+行号</strong>。这些索引也全部都是二级索引。</p>
</li>
</ul>
<blockquote>
<p>为什么不自动为每个列都建立个索引呢？</p>
<p>① 当对表中的数据进行增加、删除和修改的时候，索引也要<strong>动态的维护</strong>，这样就降低了数据的维护速度。</p>
<p>② 索引需要占<strong>物理空间</strong>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p>
<p>③ 创建索引和维护索引要<strong>耗费时间</strong>，这种时间随着数据量的增加而增加。</p>
</blockquote>
<h3 id="二级索引辅助索引">二级索引（辅助索引）</h3>
<p>聚簇索引只能在搜索条件是主键值时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。当我们想以别的列作为搜索条件时我们可以多建几棵B+树，不同的B+树中的数据采用不同的排序规则。</p>
<p>二级索引与聚簇索引有几处不同：</p>
<ol>
<li>
<p>按<strong>指定的索引列的值</strong>来进行排序</p>
</li>
<li>
<p><strong>叶子节点</strong>存储的不是完整的用户记录，而只是<strong>索引列+主键</strong>。</p>
</li>
<li>
<p>目录项记录中不是主键+页号，变成了<strong>索引列+页号</strong>。</p>
</li>
<li>
<p>在对二级索引进行查找数据时，需要根据主键值去聚簇索引中再查找一遍完整的用户记录，这个过程叫做 <strong>回表</strong></p>
</li>
</ol>
<h3 id="联合索引">联合索引</h3>
<p>以多个列的大小为排序规则建立的 B+树 称为联合索引，本质上也是一个二级索引。</p>
<h2 id="覆盖索引">覆盖索引</h2>
<h3 id="什么是覆盖索引">什么是覆盖索引</h3>
<p>如果<strong>一个索引包含（或者说覆盖）所有需要查询的字段的值</strong>，我们就称之为“覆盖索引”。我们知道在<code>InnoDB</code>存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>
<h3 id="覆盖索引使用实例">覆盖索引使用实例</h3>
<p>现在我创建了索引(username,age)，在查询数据的时候：<code>select username , age from user where username = 'Java' and age = 22</code>。要查询出的列在叶子节点都存在！所以，就不用回表。</p>
<h2 id="目录项记录的唯一性">目录项记录的唯一性</h2>
<p>我们需要保证在 B+树 的同一层内节点的目录项记录除页号这个字段以外是唯一的。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p>
<ul>
<li>
<p>索引列的值</p>
</li>
<li>
<p>主键值</p>
</li>
<li>
<p>页号</p>
</li>
</ul>
<h2 id="b树的索引总结">B+树的索引总结</h2>
<ol>
<li>
<p>每个索引都对应一棵<strong>B+树</strong>。用户记录都存储在 B+树 的叶子节点，所有目录记录都存储在非叶子节点。</p>
</li>
<li>
<p><code>InnoDB</code>存储引擎会自动为<strong>主键</strong>（如果没有它会自动帮我们添加）建立<strong>聚簇索引</strong>，聚簇索引的叶子节点包含完整的用户记录。</p>
</li>
<li>
<p>可以为指定的列建立二级索引，二级索引的叶子节点包含的用户记录由<strong>索引列 + 主键</strong>组成，所以如果想通过二级索引来查找完整的用户记录的话，需要通过<strong>回表</strong>操作，也就是在通过二级索引找到主键值之后再到聚簇索引中查找完整的用户记录。</p>
</li>
<li>
<p>B+树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是联合索引的话，则页面和记录先按照联合索引前边的列排序，如果该列值相同，再按照联合索引后边的列排序。</p>
</li>
<li>
<p>通过索引查找记录是从 B+树 的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了页目录，所以在这些页面中的查找非常快。</p>
</li>
</ol>
<p>表：</p>
<pre><code class="language-sql">create table t1(
  a int primary key, 
  b int,
  c int,
  d int, 
  e varchar(20)
)engine=InnoDB;
</code></pre>
<p>表记录：</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E8%A1%A8%E8%AE%B0%E5%BD%95.png" alt="图片" loading="lazy"></figure>
<p>创建索引：</p>
<pre><code class="language-sql">create index idx_t1_bcd on t1(b,c,d);
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B4%A2%E5%BC%95.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">自行创建索引</p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">主键索引</p>
<h2 id="索引的代价">索引的代价</h2>
<h3 id="空间上的代价">空间上的代价</h3>
<p>每建立一个索引都为要它建立一棵 B+树，每一棵 <strong>B+树 的每一个节点都是一个数据页</strong>，一个页默认会占用 <strong>16KB</strong> 的存储空间，一棵很大的 B+树 由许多数据页组成，那是很大的一片存储空间。</p>
<h3 id="时间上的代价">时间上的代价</h3>
<p>每次对表中的数据进行增、删、改操作时，都需要去修改各个 B+树 索引。而且我们讲过，B+树 每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收啥的操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的 B+树 都要进行相关的维护操作。</p>
<h2 id="b树索引实战">B+树索引实战</h2>
<h3 id="全值匹配">全值匹配</h3>
<p>如果我们的搜索条件中的列和索引列一致的话，这种情况就称为全值匹配，比方说下边这个查找语句：</p>
<pre><code class="language-sql">select * from t1 where b=1 and c=1 and d=1；
</code></pre>
<p><code>MySQL</code>中有查询优化器，会分析这些搜索条件并且按照可以使用的索引中列的顺序来决定先使用哪个搜索条件。</p>
<h3 id="匹配左边的列">匹配左边的列</h3>
<pre><code class="language-sql">select * from t1 where b=1；
select * from t1 where b=1 and c=1；
</code></pre>
<p>下面这个<code>sql</code>是用不到索引的</p>
<pre><code class="language-sql">select * from t1 where c = 1；
</code></pre>
<p>因为 B+树 的数据页和记录先是按照 b 列的值排序的，在 b 列的值相同的情况下才使用 c 列进行排序，也就是说 b 列的值不同的记录中 c 的值可能是无序的。而现在你跳过 b 列直接根据 c 的值去查找，这是做不到的。</p>
<h3 id="匹配列前缀"><strong>匹配列前缀</strong></h3>
<p>但是需要注意的是，如果只给出后缀或者中间的某个字符串，比如这样：</p>
<pre><code class="language-sql">select * from t1 where b like ''%101%';
</code></pre>
<p>MySQL 就无法快速定位记录位置了，所以只能全表扫描了。有时候我们有一些匹配某些字符串后缀的需求，比方说某个表有一个url列，该列中存储了许多url：</p>
<pre><code>www.baidu.com 

www.google.com 

www.qq.com
</code></pre>
<p>假设已经对该 url 列创建了索引，如果我们想查询以 com 为后缀的网址的话可以这样写查询条件：WHERE url LIKE '%com'，但是这样的话无法使用该 url 列的索引。为了在查询时用到这个索引而不至于全表扫描，我们可以把后缀查询改写成前缀查询，不过我们就得把表中的数据全部逆序存储一下，也就是说我们可以这样保存 url 列中的数据：</p>
<pre><code>moc.udiab.www 

moc.e1goog.www

moc.qq.www
</code></pre>
<p>这样再查找以com为后缀的网址时搜索条件便可以这么写：WHERE url LIKE 'moc%'，这样就可以用到索引了。</p>
<h3 id="匹配范围值">匹配范围值</h3>
<p>查询方式：</p>
<ul>
<li>
<p>辅助索引查询成本+回表成本</p>
</li>
<li>
<p>全表扫描成本</p>
</li>
</ul>
<p>所有记录都是按照索引列的值从小到大的顺序排好序的，所以这极大的方便我们查找索引列的值在某个范围内的记录。比方说下边这个查询语句：</p>
<pre><code>select * from t1 where b &gt; 1 and b &lt; 2000;
</code></pre>
<p>由于B+树中的数据页和记录是先按 b 列排序的，所以我们上边的查询过程其实是这样的：</p>
<ul>
<li>
<p>找到 b 值为 1 的记录。</p>
</li>
<li>
<p>找到 b 值为 20000 的记录。</p>
</li>
<li>
<p>由于所有记录都是由链表连起来的（记录之间用单链表，数据页之间用双链表），所以他们之间的记录都可以很容易的取出来</p>
</li>
<li>
<p>找到这些记录的主键值，再到聚簇索引中回表查找完整的记录。</p>
</li>
</ul>
<p>不过在使用联合进行范围查找的时候需要注意，如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到 B+树 索引，比方说这样：</p>
<pre><code class="language-sql">select * from t1 where b &gt; 1 and c &gt; 1;
</code></pre>
<p>上边这个查询可以分成两个部分：</p>
<ol>
<li>
<p>通过条件 b&gt;1 来对 b 进行范围查找，查找的结果可能有多条 b 值不同的记录，</p>
</li>
<li>
<p>对这些 b 值不同的记录继续通过 c&gt;1 继续过滤。</p>
</li>
</ol>
<p>这样子对于联合索引来说，只能用到 b 列的部分，而用不到 c 列的部分，因为只有 b 值相同的情况下才能用 c 列的值进行排序（select * from t1 where b = 1 and c &gt;1），而这个查询中通过 b 进行范围查找的记录中可能并不是按照 c 列进行排序的，所以在搜索条件中继续以 c 列进行查找时是用不到这个B+树索引的。</p>
<h3 id="精确匹配某一列并范围匹配另外一列">精确匹配某一列并范围匹配另外一列</h3>
<p>对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找，比方说这样：</p>
<pre><code class="language-sql">select * from t1 where b=1 and c&gt;1；
</code></pre>
<h3 id="排序">排序</h3>
<p>我们在写查询语句的时候经常需要对查询出来的记录通过 ORDER BY 子句按照某种规则进行排序。一般情况下，我们只能把记录都加载到内存中，再用一些排序算法，比如快速排序、归并排序等等在内存中对这些记录进行排序，有的时候可能查询的结果集太大以至于不能在内存中进行排序的话，还可能暂时借助磁盘的空间来存放中间结果，排序操作完成后再把排好序的结果集返回到客户端。在MySQL中，把这种在内存中或者磁盘上进行排序的方式统称为<strong>文件排序</strong>（英文名：filesort），这些排序操作非常慢。但是如果 ORDER BY 子句里使用到了我们的索引列，就有可能省去在内存或文件中排序的步骤，比如下边这个简单的查询语句：</p>
<pre><code class="language-sql">select * from t1 order by b，c，d
</code></pre>
<p>这个查询的结果集需要先按照 b 值排序，如果记录的 b 值相同，则需要按照 c 来排序，如果 c 的值相同，则需要按照 d 排序。因为这个 B+ 树索引本身就是按照上述规则排好序的，所以直接从索引中提取数据，然后进行回表操作取出该索引中不包含的列就好了。</p>
<h3 id="分组">分组</h3>
<pre><code class="language-sql">select b，c，d，count（*）from t1 group by b，c，d；
</code></pre>
<p>这个查询语句相当于做了3次分组操作：</p>
<ol>
<li>
<p>先把记录按照b值进行分组，所有 b 值相同的记录划分为一组。</p>
</li>
<li>
<p>将每个 b 值相同的分组里的记录再按照 c 的值进行分组，将 title 值相同的记录放到一个小分组里，所以看起来就像在一个大分组里又化分了好多小分组。</p>
</li>
<li>
<p>再将上一步中产生的小分组按照 d 的值分成更小的分组，所以整体上看起来就像是先把记录分成一个大分组，然后把大分组分成若干个小分组，然后把若干个小分组再细分成更多的小小分组。</p>
</li>
</ol>
<p>然后针对那些小小分组进行统计，比如在我们这个查询语句中就是统计每个小小分组包含的记录条数。如果没有索引的话，这个分组过程全部需要在内存里实现，而如果有了索引的话，恰巧这个分组顺序又和我们的 B+树 中的索引列的顺序是一致的，而我们的 B+树 索引又是按照索引列排好序的，所以可以直接使用 B+树 索引进行分组。</p>
<p>和使用 B+树 索引进行排序是一个道理，分组列的顺序也需要和索引列的顺序一致，也可以只使用索引列中左边的列进行分组。</p>
<h3 id="使用联合索引进行排序或分组的注意事项">使用联合索引进行排序或分组的注意事项</h3>
<p>对于联合索引有个问题需要注意，ORDER BY 的子句后边的列的顺序也必须按照索引列的顺序给出，如果给出 order by c，b 的顺序，那也是用不了 B+树 索引的。</p>
<p>同理，order by b，order by b，c 这种匹配索引左边的列的形式可以使用部分的 B+树 索引。当联合索引左边列的值为常量，也可以使用后边的列进行排序，比如这样：</p>
<pre><code class="language-sql">select * from t1 where b=1 order by c，d；
</code></pre>
<p>这个查询能使用联合索引进行排序是因为 b 列的值相同的记录是按照 c，d 排序的。</p>
<h3 id="不可以使用索引进行排序或分组的几种情况">不可以使用索引进行排序或分组的几种情况</h3>
<p><code>ASC</code>、<code>DESC</code>混用</p>
<p>对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是 <code>ASC</code> 规则排序，要么都是 <code>DESC</code> 规则排序。</p>
<blockquote>
<p>ORDER BY 子句后的列如果不加 <code>ASC</code> 或者 <code>DESC</code> 默认是按照 <code>ASC</code> 排序规则排序的，也就是升序排序的。</p>
</blockquote>
<pre><code class="language-sql">select * from t1 order by b ASC，c DESC；
</code></pre>
<p>这个查询时用不到索引的。</p>
<h2 id="如何建立索引">如何建立索引</h2>
<h3 id="考虑索引选择性">考虑索引选择性</h3>
<p>索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数的比值：</p>
<pre><code>选择性=基数/记录数
</code></pre>
<p>选择性的取值范围为（0，1]，选择性越高的索引价值越大。如果选择性等于1，就代表这个列的不重复值和表记录数是一样的，那么对这个列建立索引是非常合适的，如果选择性非常小，那么就代表这个列的重复值是很多的，不适合建立索引。</p>
<h3 id="考虑前缀索引">考虑前缀索引</h3>
<p>用列的前缀代替整个列作为索引 key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引 key 变短而减少了索引文件的大小和维护开销。</p>
<blockquote>
<p>使用mysql官网提供的示例数据库：<a href="https://dev.mysql.com/doc/employee/en/employees-installation.html">https://dev.mysql.com/doc/employee/en/employees-installation.html</a></p>
<p>github地址：<a href="https://github.com/datacharmer/test_db">https://github.com/datacharmer/test_db</a></p>
</blockquote>
<p>employees表只有一个索引&lt;emp_no&gt;，那么如果我们想按名字搜索一个人，就只能全表扫描了：</p>
<pre><code class="language-sql">EXPLAIN SELECT * FROM employees.employees WHERE first_name='Eric' AND last_name='Anido';
</code></pre>
<p>那么可以对 &lt;first_name&gt; 或 &lt;first_name，last_name&gt; 建立索引，看下两个索引的选择性：</p>
<pre><code class="language-sql">SELECT count(DISTINCT(first_name))/count(*) AS Selectivity FROM employees.employees; -- 0.0042

SELECT count(DISTINCT(concat(first_name, last_name)))/count(*) AS Selectivity FROM employees.employees; -- 0.9313
</code></pre>
<p>&lt;first_name&gt;显然选择性太低，&lt;first_name，last_name&gt;选择性很好，但是first_name和last_name加起来长度为30，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如&lt;first_name, left(last_name, 3)&gt;，看看其选择性：</p>
<pre><code class="language-sql">SELECT count(DISTINCT(concat(first_name, left(last_name, 3))))/count(*) AS Selectivity FROM employees.employees; -- 0.7879
</code></pre>
<p>选择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4：</p>
<pre><code class="language-sql">SELECT count(DISTINCT(concat(first_name, left(last_name, 4))))/count(*) AS Selectivity FROM employees.employees; -- 0.9007
</code></pre>
<p>这时选择性已很理想了，而这个索引的长度只有18，比&lt;first_name，last_name&gt;短了接近一半，建立前缀索引的方式为：</p>
<pre><code class="language-sql">ALTER TABLE employees.employees ADD INDEX first_name_last_name4 (first_name,last_name(4));
</code></pre>
<p>前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于 OFRDER BY 和 GROUP BY 操作，也不能用于覆盖索引。</p>
<h3 id="总结">总结</h3>
<ul>
<li>
<p>索引列的类型尽量小</p>
</li>
<li>
<p>利用索引字符串值的前缀</p>
</li>
<li>
<p>主键自增</p>
</li>
<li>
<p>定位并删除表中的重复和冗余索引</p>
</li>
<li>
<p>尽量使用覆盖索引进行查询，避免回表带来的性能损耗。</p>
</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<p>https://cyc2018.github.io/CS-Notes/#/notes/MySQL</p>
]]></content>
    </entry>
</feed>