<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://epitomm.github.io</id>
    <title>SSM</title>
    <updated>2020-08-12T09:17:14.396Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://epitomm.github.io"/>
    <link rel="self" href="https://epitomm.github.io/atom.xml"/>
    <subtitle>热心善良的老学姐</subtitle>
    <logo>https://epitomm.github.io/images/avatar.png</logo>
    <icon>https://epitomm.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, SSM</rights>
    <entry>
        <title type="html"><![CDATA[Spring系列（十六）Spring循环依赖]]></title>
        <id>https://epitomm.github.io/post/spring-xi-lie-shi-liu-xun-huan-yi-lai/</id>
        <link href="https://epitomm.github.io/post/spring-xi-lie-shi-liu-xun-huan-yi-lai/">
        </link>
        <updated>2020-06-15T02:23:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="spring-循环依赖">Spring 循环依赖</h1>
<h2 id="先准备一段循环依赖代码">先准备一段循环依赖代码</h2>
<p>0、项目准备<br>
打开之前编译好的 spring-framework-5.0.x 项目，新建 gradle 模块，导入依赖：<br>
build.gradle：</p>
<pre><code class="language-gradle">dependencies {
    testCompile group: 'junit', name: 'junit', version: '4.12'
    compile project(':spring-context')
}
</code></pre>
<p>配置类：</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
public class AppConfig {
}
</code></pre>
<p>1、IndexService 依赖 Luban</p>
<pre><code class="language-java">@Service
public class IndexService {
   @Autowired
   Luban luban;
}
</code></pre>
<p>2、Luban 依赖 IndexService</p>
<pre><code class="language-java">@Component
public class Luban {
   @Autowired
   IndexService indexService;
}
</code></pre>
<p>测试类：</p>
<pre><code class="language-java">public class Test {
	public static void main(String[] args) {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
		IndexService indexService = (IndexService) context.getBean(&quot;indexService&quot;);
		System.out.println(indexService);
		Luban luban = (Luban) context.getBean(&quot;luban&quot;);
		System.out.println(luban);
	}
}
</code></pre>
<p>运行结果：</p>
<pre><code>com.ssm.service.IndexService@3d36e4cd
com.ssm.app.Luban@6a472554
</code></pre>
<p>从设置属性 populateBean 开始看起<br>
<img src="https://epitomm.github.io/post-images/populateBean.png" alt="图片" loading="lazy"></p>
<pre><code class="language-java">protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
   if (bw == null) {
      if (mbd.hasPropertyValues()) {
         throw new BeanCreationException(
               mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;);
      }
      else {
         // Skip property population phase for null instance.
         return;
      }
   }
   // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the
   // state of the bean before properties are set. This can be used, for example,
   // to support styles of field injection.
   if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {
      for (BeanPostProcessor bp : getBeanPostProcessors()) {
         // 如果实例化了 InstantiationAwareBeanPostProcessor接口，重写 postProcessAfterInstantiation方法：
         // 表示不需要 Spring 帮助我们设置属性，就在这里直接 return，不进行后续通过 Spring 来设置属性的操作
         if (bp instanceof InstantiationAwareBeanPostProcessor) {
            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
            if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
               return;
            }
         }
      }
   }
   // Spring 内部设置的，Spring 内部可以添加参数值：
   // 1.设置构造方法的值：genericBeanDefinition.getConstructorArgumentValues().addGenericArgumentValue(&quot;com.ssm.app.Luban&quot;);、
   // 2.设置属性值，如果Spring内部没有设置则 pvs=null
   PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);
   // Spring 默认 AUTOWIRE_NO，如果没有自定义设置自动装配类型，则不会进入这个 if 分支
   int resolvedAutowireMode = mbd.getResolvedAutowireMode();
   if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
      MutablePropertyValues newPvs = new MutablePropertyValues(pvs);
      // Add property values based on autowire by name if applicable.
      if (resolvedAutowireMode == AUTOWIRE_BY_NAME) {
         autowireByName(beanName, mbd, bw, newPvs);
      }
      // Add property values based on autowire by type if applicable.
      if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
         autowireByType(beanName, mbd, bw, newPvs);
      }
      pvs = newPvs;
   }
   // 是否要处理，这里返回 true
   boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
   // 是否要深度检查，比如循环引用时就需要，这里返回 true
   boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);
   if (hasInstAwareBpps || needsDepCheck) {
      if (pvs == null) {
         pvs = mbd.getPropertyValues();
      }
      // 拿到所有 Descriptor，带 get、set 方法的都拿到
      PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
      if (hasInstAwareBpps) {
         for (BeanPostProcessor bp : getBeanPostProcessors()) {
            if (bp instanceof InstantiationAwareBeanPostProcessor) {
               InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
               pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
               if (pvs == null) {
                  return;
               }
            }
         }
      }
      if (needsDepCheck) {
         checkDependencies(beanName, mbd, filteredPds, pvs);
      }
   }
   if (pvs != null) {
      applyPropertyValues(beanName, mbd, bw, pvs);
   }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/filteredPds%E6%8B%BF%E5%88%B0getClass.png" alt="图片" loading="lazy"></figure>
<p>共有 7 个后置处理器，其中有 3个 instanceof InstantiationAwareBeanPostProcessor，会成功进入 if 分支：</p>
<ul>
<li>ImportAwareBeanPostProcessor</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/ImportAwareBeanPostProcessor.png" alt="图片" loading="lazy"></figure>
<ul>
<li>CommonAnnotationBeanPostProcessor</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/CommonAnnotationBeanPostProcessor.png" alt="图片" loading="lazy"></figure>
<p>前两个后置处理器执行完毕后，luban 变量都没有被赋值，而第三个后置处理器执行完成后，luban 变量被成功赋值。</p>
<ul>
<li>AutowiredAnnotationBeanPostProcessor</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/AutowiredAnnotationBeanPostProcessor.png" alt="图片" loading="lazy"></figure>
<p>当执行完 AutowiredAnnotationBeanPostProcessor 的 postProcessPropertyValues() 方法后，indexService 中的属性 luban 被成功赋值，不再为 null 了。</p>
<h2 id="postprocesspropertyvalues">postProcessPropertyValues</h2>
<pre><code class="language-java">pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
</code></pre>
<p>接下来看 postProcessPropertyValues 内都做了什么事情：<br>
AutowiredAnnotationBeanPostProcessor#postProcessPropertyValues</p>
<pre><code class="language-java">public PropertyValues postProcessPropertyValues(
      PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeanCreationException {
   InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);
   try {
      metadata.inject(bean, beanName, pvs);
   }
   catch (BeanCreationException ex) {
      throw ex;
   }
   catch (Throwable ex) {
      throw new BeanCreationException(beanName, &quot;Injection of autowired dependencies failed&quot;, ex);
   }
   return pvs;
}
</code></pre>
<p>上述代码第 6 行：</p>
<pre><code class="language-java">metadata.inject(bean, beanName, pvs);
</code></pre>
<p>InjectionMetadata#inject</p>
<pre><code class="language-java">public void inject(Object target, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {
   Collection&lt;InjectedElement&gt; checkedElements = this.checkedElements;
   Collection&lt;InjectedElement&gt; elementsToIterate =
         (checkedElements != null ? checkedElements : this.injectedElements);
   if (!elementsToIterate.isEmpty()) {
      for (InjectedElement element : elementsToIterate) {
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Processing injected element of bean '&quot; + beanName + &quot;': &quot; + element);
         }
         element.inject(target, beanName, pvs);
      }
   }
}
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/checkedElements.png" alt="图片" loading="lazy"></figure>
<p>上述代码第 10 行：</p>
<pre><code class="language-java">element.inject(target, beanName, pvs);
</code></pre>
<p>AutowiredAnnotationBeanPostProcessor#inject</p>
<pre><code class="language-java">protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {
   Field field = (Field) this.member;
   Object value;
   if (this.cached) {
      value = resolvedCachedArgument(beanName, this.cachedFieldValue);
   }
   else {
      DependencyDescriptor desc = new DependencyDescriptor(field, this.required); 
      desc.setContainingClass(bean.getClass());
      Set&lt;String&gt; autowiredBeanNames = new LinkedHashSet&lt;&gt;(1);
      Assert.state(beanFactory != null, &quot;No BeanFactory available&quot;);
      TypeConverter typeConverter = beanFactory.getTypeConverter();
      try {
         value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);
      }
      catch (BeansException ex) {
         throw new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(field), ex);
      }
      synchronized (this) {
         if (!this.cached) {
            if (value != null || this.required) {
               this.cachedFieldValue = desc;
               registerDependentBeans(beanName, autowiredBeanNames);
               if (autowiredBeanNames.size() == 1) {
                  String autowiredBeanName = autowiredBeanNames.iterator().next();
                  if (beanFactory.containsBean(autowiredBeanName) &amp;&amp;
                        beanFactory.isTypeMatch(autowiredBeanName, field.getType())) {
                     this.cachedFieldValue = new ShortcutDependencyDescriptor(
                           desc, autowiredBeanName, field.getType());
                  }
               }
            }
            else {
               this.cachedFieldValue = null;
            }
            this.cached = true;
         }
      }
   }
   if (value != null) {
      ReflectionUtils.makeAccessible(field);
      field.set(bean, value);
   }
}
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/inject%E7%9A%84field.png" alt="图片" loading="lazy"></figure>
<p>上述代码第 14 行：</p>
<pre><code class="language-java">value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);
</code></pre>
<p>DefaultListableBeanFactory#resolveDependency</p>
<pre><code class="language-java">public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,
      @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {
   descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());
   if (Optional.class == descriptor.getDependencyType()) {
      return createOptionalDependency(descriptor, requestingBeanName);
   }
   else if (ObjectFactory.class == descriptor.getDependencyType() ||
         ObjectProvider.class == descriptor.getDependencyType()) {
      return new DependencyObjectProvider(descriptor, requestingBeanName);
   }
   else if (javaxInjectProviderClass == descriptor.getDependencyType()) {
      return new Jsr330ProviderFactory().createDependencyProvider(descriptor, requestingBeanName);
   }
   else {
      Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(
            descriptor, requestingBeanName);
      if (result == null) {
         result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);
      }
      return result;
   }
}
</code></pre>
<p>上述代码第 19 行：</p>
<pre><code class="language-java">result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);
</code></pre>
<p>DefaultListableBeanFactory#doResolveDependency</p>
<pre><code class="language-java">public Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName,
      @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {
   InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);
   try {
      Object shortcut = descriptor.resolveShortcut(this);
      if (shortcut != null) {
         return shortcut;
      }
      
      // 根据类型，从Spring容器中把 Luban 对象取出来
      Class&lt;?&gt; type = descriptor.getDependencyType();
      Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);
      if (value != null) {
         if (value instanceof String) {
            String strVal = resolveEmbeddedValue((String) value);
            BeanDefinition bd = (beanName != null &amp;&amp; containsBean(beanName) ? getMergedBeanDefinition(beanName) : null);
            value = evaluateBeanDefinitionString(strVal, bd);
         }
         TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());
         return (descriptor.getField() != null ?
               converter.convertIfNecessary(value, type, descriptor.getField()) :
               converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));
      }
      Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);
      if (multipleBeans != null) {
         return multipleBeans;
      }
      Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);
      if (matchingBeans.isEmpty()) {
         if (isRequired(descriptor)) {
            raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);
         }
         return null;
      }
      String autowiredBeanName;
      Object instanceCandidate;
      if (matchingBeans.size() &gt; 1) {
         autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);
         if (autowiredBeanName == null) {
            if (isRequired(descriptor) || !indicatesMultipleBeans(type)) {
               return descriptor.resolveNotUnique(type, matchingBeans);
            }
            else {
               // In case of an optional Collection/Map, silently ignore a non-unique case:
               // possibly it was meant to be an empty collection of multiple regular beans
               // (before 4.3 in particular when we didn't even look for collection beans).
               return null;
            }
         }
         instanceCandidate = matchingBeans.get(autowiredBeanName);
      }
      else {
         // We have exactly one match.
         Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next();
         autowiredBeanName = entry.getKey();
         instanceCandidate = entry.getValue();
      }
      if (autowiredBeanNames != null) {
         autowiredBeanNames.add(autowiredBeanName);
      }
      if (instanceCandidate instanceof Class) {
         instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, this);
      }
      Object result = instanceCandidate;
      if (result instanceof NullBean) {
         if (isRequired(descriptor)) {
            raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);
         }
         result = null;
      }
      if (!ClassUtils.isAssignableValue(type, result)) {
         throw new BeanNotOfRequiredTypeException(autowiredBeanName, type, instanceCandidate.getClass());
      }
      return result;
   }
   finally {
      ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);
   }
}
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/instanceCandidate.png" alt="图片" loading="lazy"></figure>
<h2 id="resolvecandidate">resolveCandidate</h2>
<p>主要代码如下：</p>
<pre><code class="language-java">instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, this);
</code></pre>
<p>通过如上代码把 luban 实例化出来。<br>
<img src="https://epitomm.github.io/post-images/singletonObjects.png" alt="图片" loading="lazy"></p>
<p>当 Spring 实例化 IndexService 时，调用一个后置处理器把 IndexService 实例化出来，然后把它放到 singletonFactories 中，然后处理它的后置处理器，有一个后置处理器 AutowiredAnnotationBeanPostProcessor，发现 IndexService 有一个属性 Luban 需要自动装配，就调用这个属性 inject，首先拿到他的类型，然后从 Spring 容器中找。</p>
<p>DependencyDescriptor#resolveCandidate</p>
<pre><code class="language-java">public Object resolveCandidate(String beanName, Class&lt;?&gt; requiredType, BeanFactory beanFactory)
      throws BeansException {
   return beanFactory.getBean(beanName);
}
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/getBean%E7%9A%84beanName%E5%8F%82%E6%95%B0.png" alt="图片" loading="lazy"></figure>
<p>AbstractBeanFactory#getBean</p>
<pre><code class="language-java">public Object getBean(String name) throws BeansException {
   return doGetBean(name, null, null, false);
}
</code></pre>
<p>AbstractBeanFactory#doGetBean</p>
<pre><code class="language-java">protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,
      @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {
   /**
    * 通过 name 获取 beanName，这里不使用 name 直接作为 beanName 有两个原因：
    *     1.name 可能会以 &amp; 字符开头，表名调用者想获取 FactoryBean 本身，而非 FactoryBean
    *     实现类锁创建的 bean。在 Spring 工厂中，FactoryBean 的实现类和其他的普通 bean 存储
    *     方式是一致的，即&lt;beanName, bean&gt;，beanName 中是没有 &amp; 这个字符的。所以我们需要
    *     将 name 的首字符 &amp; 移除，这样才能从缓存里取到 FactoryBean 实例。
    * 2.还是别名的问题，转换需要
    */
   final String beanName = transformedBeanName(name);
   Object bean;
   /**
    * 这个方法在初始化的时候会调用，在 getBean 的时候也会调用
    * 为什么需要这么做呢？
    * 也就是说 Spring 在初始化的时候先获取这个对象，判断这个对象是否被实例化好了
    * （一般情况下为空，因为在初始化阶段，还未初始化结束，所以为空 === 有一种情况可能不为空）
    * 从 Spring 的 Bean 容器中获取一个 bean，由于 Spring 中 Bean 容器是一个 map（singletonObjects）
    * 所以可以理解 getSingleton(beanName) 等于 beanMap.get(beanName)
    * 由于方法会在 Spring 环境初始化的时候（就是对象被创建的时候调用一次）调用一次
    * 还会在 getBean 的时候调用一次
    * 所以在调试的时候需要特别注意，不能直接断点在这里，
    * 需要先进入到 annotationConfigApplicationContext.getBean(IndexService.class)
    * 之后再来断点，这样就确保了我们是在获取这个 bean 的时候调用的
    *
    * 需要说明的是在初始化时候调用一般都是返回 null
    */
   // Eagerly check singleton cache for manually registered singletons.
   // 先 getSingleton(beanName)，如果拿不到，再去初始化
   Object sharedInstance = getSingleton(beanName);
   if (sharedInstance != null &amp;&amp; args == null) {
      if (logger.isDebugEnabled()) {
         if (isSingletonCurrentlyInCreation(beanName)) {
            logger.debug(&quot;Returning eagerly cached instance of singleton bean '&quot; + beanName +
                  &quot;' that is not fully initialized yet - a consequence of a circular reference&quot;);
         }
         else {
            logger.debug(&quot;Returning cached instance of singleton bean '&quot; + beanName + &quot;'&quot;);
         }
      }
      bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
   }
   else {
      // Fail if we're already creating this bean instance:
      // We're assumably within a circular reference.
      /**
       * 原型
       * 如果是原型不应该在初始化的时候创建
       */
      if (isPrototypeCurrentlyInCreation(beanName)) {
         throw new BeanCurrentlyInCreationException(beanName);
      }
      // Check if bean definition exists in this factory.
      BeanFactory parentBeanFactory = getParentBeanFactory();
      if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {
         // Not found -&gt; check parent.
         String nameToLookup = originalBeanName(name);
         if (parentBeanFactory instanceof AbstractBeanFactory) {
            return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
                  nameToLookup, requiredType, args, typeCheckOnly);
         }
         else if (args != null) {
            // Delegation to parent with explicit args.
            return (T) parentBeanFactory.getBean(nameToLookup, args);
         }
         else {
            // No args -&gt; delegate to standard getBean method.
            return parentBeanFactory.getBean(nameToLookup, requiredType);
         }
      }
      if (!typeCheckOnly) {
         // 添加到 alreadyCreated set集合中，表示他已经创建过一次
         markBeanAsCreated(beanName);
      }
      try {
         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
         checkMergedBeanDefinition(mbd, beanName, args);
         // Guarantee initialization of beans that the current bean depends on.
         String[] dependsOn = mbd.getDependsOn();
         if (dependsOn != null) {
            for (String dep : dependsOn) {
               if (isDependent(beanName, dep)) {
                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        &quot;Circular depends-on relationship between '&quot; + beanName + &quot;' and '&quot; + dep + &quot;'&quot;);
               }
               registerDependentBean(dep, beanName);
               try {
                  getBean(dep);
               }
               catch (NoSuchBeanDefinitionException ex) {
                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        &quot;'&quot; + beanName + &quot;' depends on missing bean '&quot; + dep + &quot;'&quot;, ex);
               }
            }
         }
         // Create bean instance.
         if (mbd.isSingleton()) {
            sharedInstance = getSingleton(beanName, () -&gt; {
               try {
                  return createBean(beanName, mbd, args);
               }
               catch (BeansException ex) {
                  // Explicitly remove instance from singleton cache: It might have been put there
                  // eagerly by the creation process, to allow for circular reference resolution.
                  // Also remove any beans that received a temporary reference to the bean.
                  destroySingleton(beanName);
                  throw ex;
               }
            });
            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
         }
         else if (mbd.isPrototype()) {
            // It's a prototype -&gt; create a new instance.
            Object prototypeInstance = null;
            try {
               beforePrototypeCreation(beanName);
               prototypeInstance = createBean(beanName, mbd, args);
            }
            finally {
               afterPrototypeCreation(beanName);
            }
            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
         }
         else {
            String scopeName = mbd.getScope();
            final Scope scope = this.scopes.get(scopeName);
            if (scope == null) {
               throw new IllegalStateException(&quot;No Scope registered for scope name '&quot; + scopeName + &quot;'&quot;);
            }
            try {
               Object scopedInstance = scope.get(beanName, () -&gt; {
                  beforePrototypeCreation(beanName);
                  try {
                     return createBean(beanName, mbd, args);
                  }
                  finally {
                     afterPrototypeCreation(beanName);
                  }
               });
               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
            }
            catch (IllegalStateException ex) {
               throw new BeanCreationException(beanName,
                     &quot;Scope '&quot; + scopeName + &quot;' is not active for the current thread; consider &quot; +
                     &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,
                     ex);
            }
         }
      }
      catch (BeansException ex) {
         cleanupAfterBeanCreationFailure(beanName);
         throw ex;
      }
   }
   // Check if required type matches the type of the actual bean instance.
   if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) {
      try {
         T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
         if (convertedBean == null) {
            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
         }
         return convertedBean;
      }
      catch (TypeMismatchException ex) {
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Failed to convert bean '&quot; + name + &quot;' to required type '&quot; +
                  ClassUtils.getQualifiedName(requiredType) + &quot;'&quot;, ex);
         }
         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
      }
   }
   return (T) bean;
}
</code></pre>
<p>一开始实例化时，调用 getSingleton() 返回为 null；当要完成属性填充时，还需调用 getSingleton()。此时<br>
DefaultSingletonBeanRegistry#getSingleton</p>
<pre><code class="language-java">public Object getSingleton(String beanName) {
   return getSingleton(beanName, true);
}
</code></pre>
<p>DefaultSingletonBeanRegistry#getSingleton</p>
<pre><code class="language-java">// allowEarlyReference=true：允许缓存它、允许暴露出来
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
   // 从 map 中获取 bean 如果不为空直接返回，不再进行初始化工作
   Object singletonObject = this.singletonObjects.get(beanName);
   // 此时 Luban 和 IndexService 还没有被放到容器中，所以从容器中get去获取为空，即 singletonObject == null
   // isSingletonCurrentlyInCreation(beanName)==true：表示一个类正在被创建，在第一次初始化调用 doCreateBean 时把对象放到 singletonCurrentlyCreation 中，此时对象已经被 new 出来了，只是没有填充属性
   if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {
      synchronized (this.singletonObjects) {
         // 此时还没有把对象放到 earlySingletonObjects 中，所以 singletonObject=null
         singletonObject = this.earlySingletonObjects.get(beanName);
         // 此 if 判断成立
         if (singletonObject == null &amp;&amp; allowEarlyReference) {
            // 从缓存中取出还没有被填充属性的 Bean
            ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);
            if (singletonFactory != null) {
               singletonObject = singletonFactory.getObject();
               // 放到 earlySingletonObjects 中 
               this.earlySingletonObjects.put(beanName, singletonObject);
               this.singletonFactories.remove(beanName);
            }
         }
      }
   }
   return singletonObject;
}
</code></pre>
<p>当一个对象执行 doCreateBean 时：通过构造方法 new Bean，把 Bean 放到 singletonFactories 中，当填充属性时又调用 getBean()，从 singletonFactories 缓存中拿出 Bean，但此时的 Bean 还没有属性，把它放到 earlySingletonObjects 中，然后从 singletonFactories 中移除。<br>
<img src="https://epitomm.github.io/post-images/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.png" alt="图片" loading="lazy"></p>
<p>上述代码第 10 行：</p>
<pre><code class="language-java">singletonObject = this.earlySingletonObjects.get(beanName);
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/singletonObject.png" alt="图片" loading="lazy"></figure>
<p>上述代码第 14 行：</p>
<pre><code class="language-java">ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/singletonFactory.png" alt="图片" loading="lazy"></figure>
<p>上述代码第 18-19 行：</p>
<pre><code class="language-java">this.earlySingletonObjects.put(beanName, singletonObject);
this.singletonFactories.remove(beanName);
</code></pre>
<p>将 luban 放到 earlySingletonObjects 中，将 luban 从 singletonFactories 中移除。<br>
<img src="https://epitomm.github.io/post-images/earlySingletonObjects.png" alt="图片" loading="lazy"></p>
<p>IndexService 类注入 luban 属性的值：</p>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/InsexService%E6%B3%A8%E5%85%A5%E5%B1%9E%E6%80%A7%E5%80%BC.png" alt="图片" loading="lazy"></figure>
<h1 id="spring-循环依赖方法调用过程图">Spring 循环依赖方法调用过程图</h1>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%9B%BE.png" alt="图片" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring系列（十五）Spring源码解析——特殊构造方法]]></title>
        <id>https://epitomm.github.io/post/spring-xi-lie-shi-wu-spring-yuan-ma-jie-xi-te-shu-gou-zao-fang-fa/</id>
        <link href="https://epitomm.github.io/post/spring-xi-lie-shi-wu-spring-yuan-ma-jie-xi-te-shu-gou-zao-fang-fa/">
        </link>
        <updated>2020-06-15T02:06:56.000Z</updated>
        <content type="html"><![CDATA[<p>·# context.getBean()</p>
<pre><code class="language-java">IndexDao dao = (IndexDao) context.getBean(&quot;indexDao&quot;);
</code></pre>
<p>AbstractApplicationContext#getBean</p>
<pre><code class="language-java">@Override
public Object getBean(String name) throws BeansException {
   assertBeanFactoryActive();
   return getBeanFactory().getBean(name);
}
</code></pre>
<p>DefaultListableBeanFactory#getBean</p>
<pre><code class="language-java">public &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException {
   return getBean(requiredType, (Object[]) null);
}
</code></pre>
<p>DefaultListableBeanFactory#getBean</p>
<pre><code class="language-java">public &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, @Nullable Object... args) throws BeansException {
   NamedBeanHolder&lt;T&gt; namedBean = resolveNamedBean(requiredType, args);
   if (namedBean != null) {
      return namedBean.getBeanInstance();
   }
   BeanFactory parent = getParentBeanFactory();
   if (parent != null) {
      return (args != null ? parent.getBean(requiredType, args) : parent.getBean(requiredType));
   }
   throw new NoSuchBeanDefinitionException(requiredType);
}
</code></pre>
<p>上述代码第 2 行：</p>
<pre><code class="language-java">NamedBeanHolder&lt;T&gt; namedBean = resolveNamedBean(requiredType, args);
</code></pre>
<p>DefaultListableBeanFactory#resolveNamedBean</p>
<pre><code class="language-java">private &lt;T&gt; NamedBeanHolder&lt;T&gt; resolveNamedBean(Class&lt;T&gt; requiredType, @Nullable Object... args) throws BeansException {
   Assert.notNull(requiredType, &quot;Required type must not be null&quot;);
   String[] candidateNames = getBeanNamesForType(requiredType);
   if (candidateNames.length &gt; 1) {
      List&lt;String&gt; autowireCandidates = new ArrayList&lt;&gt;(candidateNames.length);
      for (String beanName : candidateNames) {
         if (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) {
            autowireCandidates.add(beanName);
         }
      }
      if (!autowireCandidates.isEmpty()) {
         candidateNames = StringUtils.toStringArray(autowireCandidates);
      }
   }
   if (candidateNames.length == 1) {
      String beanName = candidateNames[0];
      return new NamedBeanHolder&lt;&gt;(beanName, getBean(beanName, requiredType, args));
   }
   else if (candidateNames.length &gt; 1) {
      Map&lt;String, Object&gt; candidates = new LinkedHashMap&lt;&gt;(candidateNames.length);
      for (String beanName : candidateNames) {
         if (containsSingleton(beanName) &amp;&amp; args == null) {
            Object beanInstance = getBean(beanName);
            candidates.put(beanName, (beanInstance instanceof NullBean ? null : beanInstance));
         }
         else {
            candidates.put(beanName, getType(beanName));
         }
      }
      String candidateName = determinePrimaryCandidate(candidates, requiredType);
      if (candidateName == null) {
         candidateName = determineHighestPriorityCandidate(candidates, requiredType);
      }
      if (candidateName != null) {
         Object beanInstance = candidates.get(candidateName);
         if (beanInstance == null || beanInstance instanceof Class) {
            beanInstance = getBean(candidateName, requiredType, args);
         }
         return new NamedBeanHolder&lt;&gt;(candidateName, (T) beanInstance);
      }
      throw new NoUniqueBeanDefinitionException(requiredType, candidates.keySet());
   }
   return null;
}
</code></pre>
<p>上述代码第 19 行：</p>
<pre><code class="language-java">return new NamedBeanHolder&lt;&gt;(beanName, getBean(beanName, requiredType, args));
</code></pre>
<p>AbstractBeanFactory#getBean</p>
<pre><code class="language-java">public &lt;T&gt; T getBean(String name, @Nullable Class&lt;T&gt; requiredType, @Nullable Object... args)
      throws BeansException {
   return doGetBean(name, requiredType, args, false);
}
</code></pre>
<p>AbstractBeanFactory#doGetBean</p>
<pre><code class="language-java">protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,
      @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {
   final String beanName = transformedBeanName(name);
   Object bean;
   // Eagerly check singleton cache for manually registered singletons.
   Object sharedInstance = getSingleton(beanName);
   if (sharedInstance != null &amp;&amp; args == null) {
      if (logger.isDebugEnabled()) {
         if (isSingletonCurrentlyInCreation(beanName)) {
            logger.debug(&quot;Returning eagerly cached instance of singleton bean '&quot; + beanName +
                  &quot;' that is not fully initialized yet - a consequence of a circular reference&quot;);
         }
         else {
            logger.debug(&quot;Returning cached instance of singleton bean '&quot; + beanName + &quot;'&quot;);
         }
      }
      bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
   }
   else {
      // Fail if we're already creating this bean instance:
      // We're assumably within a circular reference.
      if (isPrototypeCurrentlyInCreation(beanName)) {
         throw new BeanCurrentlyInCreationException(beanName);
      }
      // Check if bean definition exists in this factory.
      BeanFactory parentBeanFactory = getParentBeanFactory();
      if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {
         // Not found -&gt; check parent.
         String nameToLookup = originalBeanName(name);
         if (parentBeanFactory instanceof AbstractBeanFactory) {
            return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
                  nameToLookup, requiredType, args, typeCheckOnly);
         }
         else if (args != null) {
            // Delegation to parent with explicit args.
            return (T) parentBeanFactory.getBean(nameToLookup, args);
         }
         else {
            // No args -&gt; delegate to standard getBean method.
            return parentBeanFactory.getBean(nameToLookup, requiredType);
         }
      }
      if (!typeCheckOnly) {
         markBeanAsCreated(beanName);
      }
      try {
         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
         checkMergedBeanDefinition(mbd, beanName, args);
         // Guarantee initialization of beans that the current bean depends on.
         String[] dependsOn = mbd.getDependsOn();
         if (dependsOn != null) {
            for (String dep : dependsOn) {
               if (isDependent(beanName, dep)) {
                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        &quot;Circular depends-on relationship between '&quot; + beanName + &quot;' and '&quot; + dep + &quot;'&quot;);
               }
               registerDependentBean(dep, beanName);
               try {
                  getBean(dep);
               }
               catch (NoSuchBeanDefinitionException ex) {
                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        &quot;'&quot; + beanName + &quot;' depends on missing bean '&quot; + dep + &quot;'&quot;, ex);
               }
            }
         }
         // Create bean instance.
         if (mbd.isSingleton()) {
            sharedInstance = getSingleton(beanName, () -&gt; {
               try {
                  return createBean(beanName, mbd, args);
               }
               catch (BeansException ex) {
                  // Explicitly remove instance from singleton cache: It might have been put there
                  // eagerly by the creation process, to allow for circular reference resolution.
                  // Also remove any beans that received a temporary reference to the bean.
                  destroySingleton(beanName);
                  throw ex;
               }
            });
            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
         }
         else if (mbd.isPrototype()) {
            // It's a prototype -&gt; create a new instance.
            Object prototypeInstance = null;
            try {
               beforePrototypeCreation(beanName);
               prototypeInstance = createBean(beanName, mbd, args);
            }
            finally {
               afterPrototypeCreation(beanName);
            }
            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
         }
         else {
            String scopeName = mbd.getScope();
            final Scope scope = this.scopes.get(scopeName);
            if (scope == null) {
               throw new IllegalStateException(&quot;No Scope registered for scope name '&quot; + scopeName + &quot;'&quot;);
            }
            try {
               Object scopedInstance = scope.get(beanName, () -&gt; {
                  beforePrototypeCreation(beanName);
                  try {
                     return createBean(beanName, mbd, args);
                  }
                  finally {
                     afterPrototypeCreation(beanName);
                  }
               });
               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
            }
            catch (IllegalStateException ex) {
               throw new BeanCreationException(beanName,
                     &quot;Scope '&quot; + scopeName + &quot;' is not active for the current thread; consider &quot; +
                     &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,
                     ex);
            }
         }
      }
      catch (BeansException ex) {
         cleanupAfterBeanCreationFailure(beanName);
         throw ex;
      }
   }
   // Check if required type matches the type of the actual bean instance.
   if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) {
      try {
         T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
         if (convertedBean == null) {
            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
         }
         return convertedBean;
      }
      catch (TypeMismatchException ex) {
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Failed to convert bean '&quot; + name + &quot;' to required type '&quot; +
                  ClassUtils.getQualifiedName(requiredType) + &quot;'&quot;, ex);
         }
         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
      }
   }
   return (T) bean;
}
</code></pre>
<h1 id="使用特殊构造方法实例化对象">使用特殊构造方法实例化对象</h1>
<h2 id="提前准备-demo-代码">提前准备 demo 代码</h2>
<p>1、准备一个特殊构造方法</p>
<pre><code class="language-java">@Service
public class IndexService {
   public IndexService(Luban luban){
      System.out.println(&quot;IndexService...constructor&quot;);
   }
   public void query(){
      System.out.println(&quot;query...&quot;);
   }
}
</code></pre>
<p>2、构造方法参数类型</p>
<pre><code class="language-java">@Component
public class Luban {
}
</code></pre>
<p>3、测试类</p>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext(AppConfig.class);
   }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/bean%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<p>AnnotationConfigApplicationContext#AnnotationConfigApplicationContext ---&gt; AbstractApplicationContext#refresh(); --&gt; finishBeanFactoryInitialization --&gt; DefaultListableBeanFactory#preInstantiateSingletons() --&gt; AbstractBeanFactory#getBean --&gt; AbstractBeanFactory#doGetBean --&gt; AbstractAutowireCapableBeanFactory#createBeanInstance --&gt; AbstractAutowireCapableBeanFactory#createBeanInstance --&gt; AbstractAutowireCapableBeanFactory#autowireConstructor</p>
<pre><code class="language-java">protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {
   // Make sure bean class is actually resolved at this point.
   Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);
   /**
    * 检测一个类的访问权限 Spring 默认情况下对于非 public 的类是允许访问的。
    */
   if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) {
      throw new BeanCreationException(mbd.getResourceDescription(), beanName,
            &quot;Bean class isn't public, and non-public access not allowed: &quot; + beanClass.getName());
   }
   Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();
   if (instanceSupplier != null) {
      return obtainFromSupplier(instanceSupplier, beanName);
   }
   /**
    * 如果工厂方法不为空，则通过工厂方法创建 bean 对象
    * 这种构建 bean 的方式可以自己写个 demo 去试试
    */
   if (mbd.getFactoryMethodName() != null) {
      return instantiateUsingFactoryMethod(beanName, mbd, args);
   }
   // Shortcut when re-creating the same bean...
   /**
    * 从 Spring 的原始注释可以知道这是一个 Shortcut，什么意思呢？
    * 当多次构建同一个 bean 时，可以使用这个 Shortcut，
    * 也就是说不在需要此腿短应该使用哪种方式构造 bean
    * 比如在多次构建同一个 prototype 类型的 bean 时，就可以走此处的 Shortcut
    * 这里的 resolved  和 mbd.constructorArgumentsResolved 将会在 bean 第一次实例化的过程中被设置，后面来证明
    */
   boolean resolved = false;
   // 必须自动装配
   boolean autowireNecessary = false;
   if (args == null) {
      synchronized (mbd.constructorArgumentLock) {
         // 如果是一个 FactoryMethod 创建的，就会把 resolved 设置为 true
         if (mbd.resolvedConstructorOrFactoryMethod != null) {
            resolved = true;
            // 如果已经解析了构造方法的参数，则必须要通过一个带参构造方法来实例
            autowireNecessary = mbd.constructorArgumentsResolved;
         }
      }
   }
   if (resolved) {
      if (autowireNecessary) {
         // 通过构造方法自动装配的方式构造 bean 对象
         return autowireConstructor(beanName, mbd, null, null);
      }
      else {
         // 通过默认的无参构造方法进行
         return instantiateBean(beanName, mbd);
      }
   }
   // Candidate constructors for autowiring?
   // 由后置处理器决定返回哪些构造方法
      Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
   if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
      return autowireConstructor(beanName, mbd, ctors, args);
   }
   // No special handling: simply use no-arg constructor.
   // 使用默认的无参构造方法进行初始化
   return instantiateBean(beanName, mbd);
}
</code></pre>
<p>断点在如下位置：</p>
<pre><code class="language-java">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
</code></pre>
<p>此时有一个构造方法：<br>
<img src="https://epitomm.github.io/post-images/%E6%89%AB%E6%8F%8F%E5%88%B0%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png" alt="图片" loading="lazy"></p>
<p>继续向下看代码，constrs != null 满足，于是进入此 if 分支：</p>
<pre><code class="language-java">   if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
      return autowireConstructor(beanName, mbd, ctors, args);
</code></pre>
<p>AbstractAutowireCapableBeanFactory#autowireConstructor</p>
<pre><code class="language-java">protected BeanWrapper autowireConstructor(
      String beanName, RootBeanDefinition mbd, @Nullable Constructor&lt;?&gt;[] ctors, @Nullable Object[] explicitArgs) {
   return new ConstructorResolver(this).autowireConstructor(beanName, mbd, ctors, explicitArgs);
}
</code></pre>
<h2 id="autowireconstructor">autowireConstructor</h2>
<p>ConstructorResolver#autowireConstructor</p>
<pre><code class="language-java">public BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd,
      @Nullable Constructor&lt;?&gt;[] chosenCtors, @Nullable Object[] explicitArgs) {
   // 实例一个 BeanWrapperImpl 对象
   // 前面外部返回的 BeanWrapper 其实就是这个 BeanWrapperImpl
   // 因为 BeanWrapper 是个接口
   BeanWrapperImpl bw = new BeanWrapperImpl();
   this.beanFactory.initBeanWrapper(bw);
   /**
    * 通过构造方法创建一个对象，需要三个条件：
    * 1.构造方法
    * 2.构造方法的参数类型
    * 3.构造方法的参数值
    * 上述三个条件组成了：public IndexService(String str){}
    */
   // Spring 决定采用哪个构造方法来实例化 bean
   // 代码执行到这里 Spring 已经决定要采用一个特殊构造方法来实例 bean
   // 但是到底用哪个？可能类提供了很多构造方法
   // 采用哪个，Spring 有自己的一套规则
   // 当它找到一个之后他就会把这个构造方法赋值给 constructorToUser
   Constructor&lt;?&gt; constructorToUse = null;
   // 构造方法的值，注意不是参数
   // 比如 public IndexService(String str){},str 的值，只有在真正调用这个构造方法传参时才能被确定
   // 构造方法通过反射来实例化一个对象
   // 在调用反射来实例对象的时候，需要把具体的值
   // 这个变量就是用来记录这些值的，后面有证明
   // 但是这里需要注意的是 argsHolderToUse 是一个数据结构
   // argsToUse[] 才是真正的值
   ArgumentsHolder argsHolderToUse = null;
   Object[] argsToUse = null;
   // 确定参数值列表
   /**
    * explicitArgs 是从 createBeanInstance 方法传过来的，构造方法的值
    * org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBeanInstance
    * 可以看到如果从 createBeanInstance 调用那么永远为空
    */
   if (explicitArgs != null) {
      argsToUse = explicitArgs;
   }
   else {
      // argsToResolve：参数解析器
      Object[] argsToResolve = null;
      synchronized (mbd.constructorArgumentLock) {
         // mbd.resolvedConstructorOrFactoryMethod：获得BeanDefinition中已解析完的构造方法
         // 当 Spring 确定了要使用那个构造方法后，会把要使用的这个构造方法赋值给  mbd.resolvedConstructorOrFactoryMethod，下一次就不需要再解析了
         constructorToUse = (Constructor&lt;?&gt;) mbd.resolvedConstructorOrFactoryMethod;
         if (constructorToUse != null &amp;&amp; mbd.constructorArgumentsResolved) {
            // Found a cached constructor...
            argsToUse = mbd.resolvedConstructorArguments;
            if (argsToUse == null) {
               argsToResolve = mbd.preparedConstructorArguments;
            }
         }
      }
      // 如果有已解析的构造方法
      if (argsToResolve != null) {
         argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve);
      }
   }
   if (constructorToUse == null) {
      // Need to resolve the constructor.
      // 如果没有已经解析的构造方法，则需要去解析构造方法，使用哪个构造方法来实例化对象
      // 两个判断条件：判断1.chosenCtors != null
      // chosenCtors != null：判断传参进来的构造方法是否为空，如果不为空，则需要解析构造方法：
      // chosenCtors参数是由 { AbstractAutowireCapableBeanFactory#createBeanInstance：
      // Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);后置处理器决定要用ctors来实例化对象 } 传递过来的
      // 判断2.mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR：根据构造方法自动注入，也需要解析构造方法
      // 由于上面传递了 ctors,所以 chosenCtors != null
      boolean autowiring = (chosenCtors != null ||
            mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);
      // 构造方法参数的值
      ConstructorArgumentValues resolvedValues = null;
      // 定义了最小参数个数
      // 如果构造方法的参数列表给定了具体的值
      // 那么这里指的就是构造方法参数的个数
      int minNrOfArgs;
      // explicitArgs：如果传参为 Object[]{&quot;hello&quot;, &quot;world&quot;}，即构造方法的参数值为 &quot;hello&quot;、&quot;world&quot;，
      // 则最小参数个数 minNrOfArgs=2
      if (explicitArgs != null) {
         minNrOfArgs = explicitArgs.length;
      }
      else {
         // cargs 获取构造方法的值，注意是值，不是类型和列表
         // 实例化一个对象，用来存放构造方法的参数值，当中主要存放了参数值和参数所对应的下标
         ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();
         // 如 MyBtis 通过 mbd.getConstructorArgumentValues().addGenericArgumentValue(&quot;com.index.dao&quot;); 设置构造参数的值
         // 则下面获取的 minNrOfArgs：构造方法最小参数个数就是 1 了，因为有上一行代码给了一个参数&quot;com.index.dao&quot;
         resolvedValues = new ConstructorArgumentValues();
         /**
          * 把 cargs 的内容给 resolvedValues 比那里并且确定构造方法参数数量，假设有如下配置：
          *     &lt;bean id=&quot;luban&quot; class=&quot;com.luban.Luban&quot;&gt;
          *        &lt;constructor-arg index=&quot;0&quot; value=&quot;str1&quot;/&gt;
          *        &lt;constructor-arg index=&quot;1&quot; value=&quot;1&quot;/&gt;
          *        &lt;constructor-arg index=&quot;2&quot; value=&quot;str2&quot;/&gt;
          *      &lt;/bean&gt;
          *
          * 那么 minNrOfArgs=3
          * 或者你通过 Spring 的各种扩展点给了 Spring 一些构造方法的值，那么也能确定
          * 为什么要确定？
          * 因为我们的构造方法有多个，
          * 那么类型和个数是 Spring 用来确定使用哪个构造方法的重要信息
          */
         minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);
      }
      // Take specified constructors, if any.
      Constructor&lt;?&gt;[] candidates = chosenCtors;
      if (candidates == null) {
         Class&lt;?&gt; beanClass = mbd.getBeanClass();
         try {
            candidates = (mbd.isNonPublicAccessAllowed() ?
                  beanClass.getDeclaredConstructors() : beanClass.getConstructors());
         }
         catch (Throwable ex) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                  &quot;Resolution of declared constructors on bean Class [&quot; + beanClass.getName() +
                  &quot;] from ClassLoader [&quot; + beanClass.getClassLoader() + &quot;] failed&quot;, ex);
         }
      }
      /**
       * 排序：优先访问权限，继而参数个数
       * 1.public Luban(Object o1, Object o2, Object o3)
       * 2.public Luban(Object o1, Object o2)
       * 3.public Luban(Object o1)
       * 4.protected Luban(Integer i, Object o1, Object o2,Object o3)
       * 5.protected Luban(Integer i, Object o1, Object o2)
       * 6.protected Luban(Integer i, Object o1)
       */
      AutowireUtils.sortConstructors(candidates);
      // 定义了一个差异变量，初始化为 Integer 最大值
      int minTypeDiffWeight = Integer.MAX_VALUE;
      // 有歧义的构造方法，比如 public IndexService(Class clazz){} 和 public IndexService(Object obj){}
      Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors = null;
      LinkedList&lt;UnsatisfiedDependencyException&gt; causes = null;
      
      // 循环所有的构造方法
      for (Constructor&lt;?&gt; candidate : candidates) {
         Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();
         /**
          * constructorToUse != null 这个很好理解，
          * 前面已经说过首先 constructorToUse 主要是用来装已经解析过了并且在使用的构造方法
          * 只有在它等于空的情况下，才有继续的意义，因为下面如果解析到了一个符合的构造方法，就会赋值给这个变量。故而如果这个变量不等于 null 就不需要再进行解析了，
          * 说明 Spring 已经找到了一个合适的构造方法，直接使用便可以
          *
          * argsToUse.length &gt; paramTypes.length
          * 首先假设 argsToUse=[1,&quot;hello&quot;,obj]
          * 那么会去匹配到上面的构造方法的 1 和 5
          * 因为排序，大到小，如果第一个都比 argsToUse 小，那么后面的就不需要去判断了
          */
          // 如果已经确定了要使用哪个构造方法，即constructorToUse != null直接break 即可。
         if (constructorToUse != null &amp;&amp; argsToUse.length &gt; paramTypes.length) {
            // Already found greedy constructor that can be satisfied -&gt;
            // do not look any further, there are only less greedy constructors left.
            break;
         }
         // 当构造方法的参数列表长度 &lt; 最小参数个数，终止当前循环，继续下一次循环
         if (paramTypes.length &lt; minNrOfArgs) {
            continue;
         }
         ArgumentsHolder argsHolder;
         if (resolvedValues != null) {
            try {
               // 判断是否加了 ConstructorProperties 注解，如果加了则把值取出来
               // @ConstructorProperties(value={&quot;xxx&quot;, &quot;111 &quot;})
               String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, paramTypes.length);
               if (paramNames == null) {
                  ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();
                  if (pnd != null) {
                     // 获取构造方法参数名称列表
                     // 假如有一个 (String str, Object obj)，则 paramNames=[str,obj]
                     paramNames = pnd.getParameterNames(candidate);
                  }
               }
               // 获取构造方法参数值列表
               /**
                * Spring 只能提供字符串的参数值
                * 如 &lt;constructor-arg index=&quot;0&quot; value=&quot;com.ssm.dao.IndexDao&quot;&gt;&lt;/constructor-arg&gt; 就需要将 &quot;com.ssm.dao.IndexDao&quot; 转换成 IndexDao 对象
                * 故而需要进行转换，argsHolder 所包含的值就是转换之后的
                */
               argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,
                     getUserDeclaredConstructor(candidate), autowiring);
            }
            catch (UnsatisfiedDependencyException ex) {
               if (logger.isTraceEnabled()) {
                  logger.trace(&quot;Ignoring constructor [&quot; + candidate + &quot;] of bean '&quot; + beanName + &quot;': &quot; + ex);
               }
               // Swallow and try next constructor.
               if (causes == null) {
                  causes = new LinkedList&lt;&gt;();
               }
               causes.add(ex);
               continue;
            }
         }
         else {
            // Explicit arguments given -&gt; arguments length must match exactly.
            if (paramTypes.length != explicitArgs.length) {
               continue;
            }
            argsHolder = new ArgumentsHolder(explicitArgs);
         }
         /**
          * typeDiffWeight差异量，何谓差异量呢？
          * argsHolder.arguments 和 parameTypes 之间的差异
          * 每个参数值的类型与构造方法参数列表的类型之间的差异量
          * 通过这个差异量来衡量或者确定一个合适的构造方法
          *
          * 值得注意的是 constructoToUse=candidate
          *
          * 第一次循环一定会 typeDiffWeight &lt; minTypeDiffWeight，因为 minTypeDiffWeight 的值非常大
          * 然后每次循环会把 typeDiffWeight 赋值给 minTypeDiffWeight（minTypeDiffWeight=typeDiffWeight）
          * else if(constructorToUse != null &amp;&amp; typeDiffWeight == minTypeDiffWeight)
          * 第一次循环肯定不会进入这个，第二次如果进入了这个分支代表什么？
          * 代表有两个构造方法都符合我们要求？那么 Spring 不知道该怎么做了
          * ambiguousConstructors.add(candidate);
          * ambiguousConstructors=null，但是非常重要，因为需要清空
          * 这也解释了为什么它找到两个符合要求的方法不直接抛异常的原因
          * 如果这个 ambiguousConstructors 一直存在，Spring 会在循环外面去 exception
          *
          */
         int typeDiffWeight = (mbd.isLenientConstructorResolution() ?
               argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));
         // Choose this constructor if it represents the closest match.
         if (typeDiffWeight &lt; minTypeDiffWeight) {
            constructorToUse = candidate;
            argsHolderToUse = argsHolder;
            argsToUse = argsHolder.arguments;
            // 比如当第一次循环时候，将差异量赋值给最小差异量；第二次循环时候进行对比，如果第二次循环得到的差异量&lt;当前最小差异量，则更新最小差异值；否则不更新
            minTypeDiffWeight = typeDiffWeight;
            // 如果找到比歧义变量更符合的，把歧义变量清空
            ambiguousConstructors = null;
         }
         // 如果找到两个差异值一样的，就会把它们放到歧义变量 ambiguousConstructors 里面
         else if (constructorToUse != null &amp;&amp; typeDiffWeight == minTypeDiffWeight) {
            if (ambiguousConstructors == null) {
               ambiguousConstructors = new LinkedHashSet&lt;&gt;();
               ambiguousConstructors.add(constructorToUse);
            }
            ambiguousConstructors.add(candidate);
         }
      }
      // 没有找到合适的构造方法
      if (constructorToUse == null) {
         if (causes != null) {
            UnsatisfiedDependencyException ex = causes.removeLast();
            for (Exception cause : causes) {
               this.beanFactory.onSuppressedException(cause);
            }
            throw ex;
         }
         throw new BeanCreationException(mbd.getResourceDescription(), beanName,
               &quot;Could not resolve matching constructor &quot; +
               &quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)&quot;);
      }
      // 如果 ambiguousConstructors 还存在异常？为什么会在上面方法中直接 exception?
      // 上面注释当中有说明
      else if (ambiguousConstructors != null &amp;&amp; !mbd.isLenientConstructorResolution()) {
         throw new BeanCreationException(mbd.getResourceDescription(), beanName,
               &quot;Ambiguous constructor matches found in bean '&quot; + beanName + &quot;' &quot; +
               &quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): &quot; +
               ambiguousConstructors);
      }
      if (explicitArgs == null) {
         /**
          * 缓存相关信息，比如：
          *     1.已解析出的构造方法对象 resolvedConstructorOfFactoryMethod
          *     2.构造方法参数列表是否已解析标志 constructorArgumentsResolved
          *     这些信息可用在其他地方，用于进行快捷判断
          */
         argsHolderToUse.storeCache(mbd, constructorToUse);
      }
   }
   try {
      /**
       * 使用反射创建实例 lookup-method 通过 CGLIB 增强 bean 实例
       */
      final InstantiationStrategy strategy = beanFactory.getInstantiationStrategy();
      Object beanInstance;
      if (System.getSecurityManager() != null) {
         final Constructor&lt;?&gt; ctorToUse = constructorToUse;
         final Object[] argumentsToUse = argsToUse;
         beanInstance = AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;
               strategy.instantiate(mbd, beanName, beanFactory, ctorToUse, argumentsToUse),
               beanFactory.getAccessControlContext());
      }
      else {
         beanInstance = strategy.instantiate(mbd, beanName, this.beanFactory, constructorToUse, argsToUse);
      }
      bw.setBeanInstance(beanInstance);
      return bw;
   }
   catch (Throwable ex) {
      throw new BeanCreationException(mbd.getResourceDescription(), beanName,
            &quot;Bean instantiation via constructor failed&quot;, ex);
   }
}
</code></pre>
<p>上述代码第 89 行：</p>
<pre><code class="language-java">// cargs 获取构造方法的值，注意是值，不是类型和列表
// 实例化一个对象，用来存放构造方法的参数值，当中主要存放了参数值和参数所所对应的下标
ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();
</code></pre>
<p>ConstructorArgumentValues 用来存构造方法的值。</p>
<ul>
<li>无序时，使用 List 存储；</li>
<li>有序时，使用 Map 存储，如：&lt;1, &quot;hello&quot;&gt;；&lt;2, &quot;world&quot;&gt;。
<ul>
<li>
<constructor-arg index="1" value="hello">
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class ConstructorArgumentValues {
   private final Map&lt;Integer, ValueHolder&gt; indexedArgumentValues = new LinkedHashMap&lt;&gt;();
   private final List&lt;ValueHolder&gt; genericArgumentValues = new ArrayList&lt;&gt;();
</code></pre>
<p>上述代码第 107 行：</p>
<pre><code class="language-java">minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/minNrOfArgs%E4%B8%BA0.png" alt="图片" loading="lazy"></figure>
<p>上述代码第 178 行：</p>
<pre><code class="language-java">// 获取构造方法参数名称列表
// 假如有一个 (String str, Object obj)，则 paramNames=[str,obj]
paramNames = pnd.getParameterNames(candidate);
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E8%8E%B7%E5%BE%97%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E5%90%8D%E7%A7%B0%E5%88%97%E8%A1%A8.png" alt="图片" loading="lazy"></figure>
<pre><code class="language-java">// 获取构造方法参数值列表
/**
 * Spring 只能提供字符串的参数值
 * 故而需要进行转换
 * argsHolder 所包含的值就是转换之后的
 */
argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,
      getUserDeclaredConstructor(candidate), autowiring);
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B.png" alt="图片" loading="lazy"></figure>
<p>上述代码第 299 行：</p>
<pre><code class="language-java">beanInstance = strategy.instantiate(mbd, beanName, this.beanFactory, constructorToUse, argsToUse);
</code></pre>
<p>SimpleInstantiationStrategy#instantiate</p>
<pre><code class="language-java">public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,
      final Constructor&lt;?&gt; ctor, @Nullable Object... args) {
   if (!bd.hasMethodOverrides()) {
      if (System.getSecurityManager() != null) {
         // use own privileged to change accessibility (when security is on)
         AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
            ReflectionUtils.makeAccessible(ctor);
            return null;
         });
      }
      return (args != null ? BeanUtils.instantiateClass(ctor, args) : BeanUtils.instantiateClass(ctor));
   }
   else {
      return instantiateWithMethodInjection(bd, beanName, owner, ctor, args);
   }
}
</code></pre>
<p>上述代码第 15 行：<br>
BeanUtils#instantiateClass</p>
<pre><code class="language-java">public static &lt;T&gt; T instantiateClass(Constructor&lt;T&gt; ctor, Object... args) throws BeanInstantiationException {
   Assert.notNull(ctor, &quot;Constructor must not be null&quot;);
   try {
      // 设置构造方法可访问
      ReflectionUtils.makeAccessible(ctor);
      // 反射创建对象
      return (KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ?
            KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args));
   }
   catch (InstantiationException ex) {
      throw new BeanInstantiationException(ctor, &quot;Is it an abstract class?&quot;, ex);
   }
   catch (IllegalAccessException ex) {
      throw new BeanInstantiationException(ctor, &quot;Is the constructor accessible?&quot;, ex);
   }
   catch (IllegalArgumentException ex) {
      throw new BeanInstantiationException(ctor, &quot;Illegal arguments for constructor&quot;, ex);
   }
   catch (InvocationTargetException ex) {
      throw new BeanInstantiationException(ctor, &quot;Constructor threw exception&quot;, ex.getTargetException());
   }
}
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1.png" alt="图片" loading="lazy"></figure>
<h1 id="构造方法注入-class">构造方法注入 Class</h1>
<pre><code class="language-java">@Service
public class IndexService {
   Class clazz;
   // 如果类型为 Class，直接忽略，不会自动装配，那么如何将 Class 注入给构造方法呢？拿出 BeanDefinition,给他一个 Class 值即可。
   public IndexService(Class clazz){
      this.clazz = clazz;
      System.out.println(&quot;IndexService...constructor&quot;);
   }
   public void query(){
     System.out.println(&quot;clazz = &quot; + this.clazz);
  }
}
</code></pre>
<p>MyBatis 中的 MapperFactoryBean 就是类似场景：注入 Class<br>
MapperFactoryBean{</p>
<p>getObject(){</p>
<p>// 根据 clazz 返回真实代理对象</p>
<p>return proxyObject.proxy(clazz);</p>
<p>}</p>
<p>}</p>
<h2 id="beanfactory">BeanFactory</h2>
<pre><code class="language-java">@Component
public class IndexFactory implements BeanFactoryPostProcessor {
   @Override
   public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
      // 得到 BeanDefintion
      GenericBeanDefinition indexService = (GenericBeanDefinition) beanFactory.getBeanDefinition(&quot;indexService&quot;);
      // 为 BeanDefinition 设置一个 Class 属性，传值 &quot;com.ssm.app.Luban&quot;，Spring 将字符串转化成类对象
      indexService.getConstructorArgumentValues().addGenericArgumentValue(&quot;com.ssm.app.Luban&quot;);
   }
}
</code></pre>
<p>测试类：</p>
<pre><code class="language-plain">IndexService...constructor
clazz = class com.ssm.app.Luban
</code></pre>
<p>AbstractAutowireCapableBeanFactory#createBeanInstance<br>
<img src="https://epitomm.github.io/post-images/%E6%89%AB%E6%8F%8F%E5%88%B0%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png" alt="图片" loading="lazy"></p>
<p>ConstructorResolver#autowireConstructor</p>
<p><img src="https://epitomm.github.io/post-images/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E5%80%BC.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/minNrOfArgs%E4%B8%BA1.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/argsHolder.png" alt="图片" loading="lazy"></p>
<h1 id="addsingletonfactory">addSingletonFactory</h1>
<p>当把对象实例化完成之后，就会执行 addSingletonFactory 方法。</p>
<p>AbstractApplicationContext#refresh --&gt; AbstractApplicationContext#invokeBeanFactoryPostProcessors --&gt; PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors --&gt; AbstractBeanFactory#getBean --&gt; AbstractBeanFactory#doGetBean --&gt; DefaultSingletonBeanRegistry#getSingleton --&gt;  AbstractBeanFactory #lambda$doGetBean --&gt;AbstractAutowireCapableBeanFactory#createBean --&gt; AbstractAutowireCapableBeanFactory#doCreateBean</p>
<pre><code class="language-java">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
      throws BeanCreationException {
   // Instantiate the bean.
   BeanWrapper instanceWrapper = null;
   if (mbd.isSingleton()) {
      instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
   }
   if (instanceWrapper == null) {
      /**
       * 创建 bean 实例，并将实例包裹在 BeanWrapper 实现类对象中返回。
       * createBeanInstance中包含三种创建 bean 实例的方式：
       *     1.通过工厂方法创建 bean 实例
       *     2.通过构造方法自动注入（autowire by constructor）的方式创建 bean 实例
       *     3.通过无参构造方法创建 bean 实例
       *
       *     若 bean 的配置信息中配置了 lookup-method 和 replace-method，则会
       *     增强 bean 实例。
       */
      instanceWrapper = createBeanInstance(beanName, mbd, args);
   }
   final Object bean = instanceWrapper.getWrappedInstance();
   Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();
   if (beanType != NullBean.class) {
      mbd.resolvedTargetType = beanType;
   }
   // Allow post-processors to modify the merged bean definition.
   synchronized (mbd.postProcessingLock) {
      if (!mbd.postProcessed) {
         try {
            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
         }
         catch (Throwable ex) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                  &quot;Post-processing of merged bean definition failed&quot;, ex);
         }
         mbd.postProcessed = true;
      }
   }
   // Eagerly cache singletons to be able to resolve circular references
   // even when triggered by lifecycle interfaces like BeanFactoryAware.
   boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;
         isSingletonCurrentlyInCreation(beanName));
   if (earlySingletonExposure) {
      if (logger.isDebugEnabled()) {
         logger.debug(&quot;Eagerly caching bean '&quot; + beanName +
               &quot;' to allow for resolving potential circular references&quot;);
      }
      addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));
   }
   // Initialize the bean instance.
   Object exposedObject = bean;
   try {
      // 设置属性，非常重要
      populateBean(beanName, mbd, instanceWrapper);
      // 执行后置处理器，AOP就是在这里完成的处理
      exposedObject = initializeBean(beanName, exposedObject, mbd);
   }
   catch (Throwable ex) {
      if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {
         throw (BeanCreationException) ex;
      }
      else {
         throw new BeanCreationException(
               mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);
      }
   }
   if (earlySingletonExposure) {
      Object earlySingletonReference = getSingleton(beanName, false);
      if (earlySingletonReference != null) {
         if (exposedObject == bean) {
            exposedObject = earlySingletonReference;
         }
         else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {
            String[] dependentBeans = getDependentBeans(beanName);
            Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);
            for (String dependentBean : dependentBeans) {
               if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                  actualDependentBeans.add(dependentBean);
               }
            }
            if (!actualDependentBeans.isEmpty()) {
               throw new BeanCurrentlyInCreationException(beanName,
                     &quot;Bean with name '&quot; + beanName + &quot;' has been injected into other beans [&quot; +
                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
                     &quot;] in its raw version as part of a circular reference, but has eventually been &quot; +
                     &quot;wrapped. This means that said other beans do not use the final version of the &quot; +
                     &quot;bean. This is often the result of over-eager type matching - consider using &quot; +
                     &quot;'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.&quot;);
            }
         }
      }
   }
   // Register bean as disposable.
   try {
      registerDisposableBeanIfNecessary(beanName, bean, mbd);
   }
   catch (BeanDefinitionValidationException ex) {
      throw new BeanCreationException(
            mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);
   }
   return exposedObject;
}
</code></pre>
<p>上述代码第 51 行：</p>
<pre><code class="language-java">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));
</code></pre>
<p>DefaultSingletonBeanRegistry#addSingletonFactory</p>
<pre><code class="language-java">protected void addSingletonFactory(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {
   Assert.notNull(singletonFactory, &quot;Singleton factory must not be null&quot;);
   synchronized (this.singletonObjects) {
      // 判断有没有实例化完成：singletonObjects 放的是原来已经实例化好的对象
      if (!this.singletonObjects.containsKey(beanName)) {
         this.singletonFactories.put(beanName, singletonFactory);
         this.earlySingletonObjects.remove(beanName);
         this.registeredSingletons.add(beanName);
      }
   }
}
</code></pre>
<h2 id="spring-的对象有四种状态">Spring 的对象有四种状态：</h2>
<ul>
<li>Bean 原生对象：把 Bean 创建出来，不存在于任何集合中</li>
<li>放到 singletonFactories 中的对象：</li>
<li>放到 earlySingletonObjects 中的对象：过渡对象：已经被 new 出来的，但是属性没有填充</li>
<li>放到 singletonObjects 中的对象：已经实例化好的对象</li>
</ul>
<h2 id="populatebean">populateBean</h2>
<p>上述代码第 58 行：</p>
<pre><code class="language-java">// 设置属性，非常重要：通过后置处理器填充属性
populateBean(beanName, mbd, instanceWrapper);
</code></pre>
<p>主要使用两个后置处理器</p>
<ul>
<li>CommonAnnotationBeanPostProcessor：主要处理 @Resource、@PostConstruct 和 @PreDestory 注解</li>
<li>AutowiredAnnotationBeanPostProcessor：处理 @Autowired 注解</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring系列（十四）Spring源码解析——类的实例化过程]]></title>
        <id>https://epitomm.github.io/post/spring-xi-lie-shi-si-spring-yuan-ma-jie-xi/</id>
        <link href="https://epitomm.github.io/post/spring-xi-lie-shi-si-spring-yuan-ma-jie-xi/">
        </link>
        <updated>2020-05-31T01:55:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="preinstantiatesingletons">preInstantiateSingletons</h1>
<p>AnnotationConfigApplicationContext#refresh() --&gt; AbstractApplicationContext#finishBeanFactoryInitialization --&gt; DefaultListableBeanFactory#preInstantiateSingletons：准备实例化单例对象</p>
<pre><code class="language-java">public void preInstantiateSingletons() throws BeansException {
   if (logger.isDebugEnabled()) {
      logger.debug(&quot;Pre-instantiating singletons in &quot; + this);
   }
   // Iterate over a copy to allow for init methods which in turn register new bean definitions.
   // While this may not be part of the regular factory bootstrap, it does otherwise work fine.
   // beanNames：BeanDefinitionMap中所有类的名字
   List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames);
   // Trigger initialization of all non-lazy singleton beans...
   // 触发所有非 Lazy 单例 beans 的初始化，主要步骤为调用 getBean
   for (String beanName : beanNames) {
      // 通过 beanName 得到 BeanDefinition，合并父类 BeanDefinition
      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
      // 如果这个 bd 是非抽象的、单例、非懒加载的：懒加载一开始不会实例化
      if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) {
         if (isFactoryBean(beanName)) {
            // 如果是 FactoryBean 则加上 &amp;
            Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
            // 判断这个 bean 是不是 FactoryBean
            if (bean instanceof FactoryBean) {
               final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;
               boolean isEagerInit;
               if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) {
                  isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)
                              ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,
                        getAccessControlContext());
               }
               else {
                  isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;
                        ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());
               }
               if (isEagerInit) {
                  getBean(beanName);
               }
            }
         }
         else {
            getBean(beanName);
         }
      }
   }
   // Trigger post-initialization callback for all applicable beans...
   for (String beanName : beanNames) {
      Object singletonInstance = getSingleton(beanName);
      if (singletonInstance instanceof SmartInitializingSingleton) {
         final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
         if (System.getSecurityManager() != null) {
            AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
               smartSingleton.afterSingletonsInstantiated();
               return null;
            }, getAccessControlContext());
         }
         else {
            smartSingleton.afterSingletonsInstantiated();
         }
      }
   }
}
</code></pre>
<p>上述代码第 15行合并父类，案例如下：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
   &lt;bean id=&quot;parent&quot; class=&quot;com.ssm.service.IndexService&quot;&gt;
      &lt;property name=&quot;name&quot; value=&quot;parent&quot;&gt;&lt;/property&gt;
   &lt;/bean&gt;
   &lt;bean id=&quot;child&quot; parent=&quot;parent&quot;&gt;
      &lt;property name=&quot;name&quot; value=&quot;children&quot;&gt;&lt;/property&gt;
   &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
@ImportResource(&quot;classpath:spring.xml&quot;)
public class AppConfig {
</code></pre>
<pre><code class="language-java">public class IndexService {
   private String name;
   public String getName(){
      return name;
   }
   public void setName(String name){
      this.name = name;
   }
}
</code></pre>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext(AppConfig.class);
      IndexService indexService = (IndexService) context.getBean(&quot;parent&quot;);
      System.out.println(indexService.getName());
      IndexService child = (IndexService) context.getBean(&quot;child&quot;);
      System.out.println(child.getName());
   }
}
</code></pre>
<p>运行结果：</p>
<p>``<br>
parent<br>
children</p>
<pre><code>
当 Spring 实例化时，首先把所有类都扫描出来，放到 BeanDefinitionMap 中，从 map 中把所有名字都拿出来。
Spring 工厂的 IOC 容器两方面体现：

* 宏观方面：Spring环境，包括Bean工厂，包括Spring内部处理器，包括读取器、注册器...
* 微观方面：private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);

## getBean(beanName);

上述代码第 40 行：

```java
getBean(beanName);
</code></pre>
<p>AbstractBeanFactory#getBean</p>
<pre><code class="language-java">public Object getBean(String name) throws BeansException {
   return doGetBean(name, null, null, false);
}
</code></pre>
<h3 id="dogetbean">doGetBean</h3>
<p>AbstractBeanFactory#doGetBean</p>
<pre><code class="language-java">protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,
      @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {
   /**
    * 通过 name 获取 beanName，这里不使用 name 直接作为 beanName 有两个原因：
    *     1.name 可能会以 &amp; 字符开头，表名调用者想获取 FactoryBean 本身，而非 FactoryBean
    *     实现类锁创建的 bean。在 Spring 工厂中，FactoryBean 的实现类和其他的普通 bean 存储
    *     方式是一致的，即&lt;beanName, bean&gt;，beanName 中是没有 &amp; 这个字符的。所以我们需要
    *     将 name 的首字符 &amp; 移除，这样才能从缓存里取到 FactoryBean 实例。
    * 2.还是别名的问题，转换需要
    */
   final String beanName = transformedBeanName(name);
   Object bean;
   /**
    * 这个方法在初始化的时候会调用，在 getBean 的时候也会调用
    * 为什么需要这么做呢？
    * 也就是说 Spring 在初始化的时候先获取这个对象，判断这个对象是否被实例化好了
    * （一般情况下为空，因为在初始化阶段，还未初始化结束，所以为空 === 有一种情况可能不为空）
    * 从 Spring 的 Bean 容器中获取一个 bean，由于 Spring 中 Bean 容器是一个 map（singletonObjects）
    * 所以可以理解 getSingleton(beanName) 等于 beanMap.get(beanName)
    * 由于方法会在 Spring 环境初始化的时候（就是对象被创建的时候调用一次）调用一次
    * 还会在 getBean 的时候调用一次
    * 所以在调试的时候需要特别注意，不能直接断点在这里，
    * 需要先进入到 annotationConfigApplicationContext.getBean(IndexService.class)
    * 之后再来断点，这样就确保了我们是在获取这个 bean 的时候调用的
    *
    * 需要说明的是在初始化时候调用一般都是返回 null
    */
   // Eagerly check singleton cache for manually registered singletons.
   // 先 getSingleton(beanName)，如果拿不到，再去初始化
   Object sharedInstance = getSingleton(beanName);
   if (sharedInstance != null &amp;&amp; args == null) {
      if (logger.isDebugEnabled()) {
         if (isSingletonCurrentlyInCreation(beanName)) {
            logger.debug(&quot;Returning eagerly cached instance of singleton bean '&quot; + beanName +
                  &quot;' that is not fully initialized yet - a consequence of a circular reference&quot;);
         }
         else {
            logger.debug(&quot;Returning cached instance of singleton bean '&quot; + beanName + &quot;'&quot;);
         }
      }
      bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
   }
   else {
      // Fail if we're already creating this bean instance:
      // We're assumably within a circular reference.
      /**
       * 原型
       * 如果是原型不应该在初始化的时候创建
       */
      if (isPrototypeCurrentlyInCreation(beanName)) {
         throw new BeanCurrentlyInCreationException(beanName);
      }
      // Check if bean definition exists in this factory.
      BeanFactory parentBeanFactory = getParentBeanFactory();
      if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {
         // Not found -&gt; check parent.
         String nameToLookup = originalBeanName(name);
         if (parentBeanFactory instanceof AbstractBeanFactory) {
            return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
                  nameToLookup, requiredType, args, typeCheckOnly);
         }
         else if (args != null) {
            // Delegation to parent with explicit args.
            return (T) parentBeanFactory.getBean(nameToLookup, args);
         }
         else {
            // No args -&gt; delegate to standard getBean method.
            return parentBeanFactory.getBean(nameToLookup, requiredType);
         }
      }
      if (!typeCheckOnly) {
         // 添加到 alreadyCreated set集合中，表示他已经创建过一次
         markBeanAsCreated(beanName);
      }
      try {
         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
         checkMergedBeanDefinition(mbd, beanName, args);
         // Guarantee initialization of beans that the current bean depends on.
         String[] dependsOn = mbd.getDependsOn();
         if (dependsOn != null) {
            for (String dep : dependsOn) {
               if (isDependent(beanName, dep)) {
                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        &quot;Circular depends-on relationship between '&quot; + beanName + &quot;' and '&quot; + dep + &quot;'&quot;);
               }
               registerDependentBean(dep, beanName);
               try {
                  getBean(dep);
               }
               catch (NoSuchBeanDefinitionException ex) {
                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        &quot;'&quot; + beanName + &quot;' depends on missing bean '&quot; + dep + &quot;'&quot;, ex);
               }
            }
         }
         // Create bean instance.
         if (mbd.isSingleton()) {
            sharedInstance = getSingleton(beanName, () -&gt; {
               try {
                  return createBean(beanName, mbd, args);
               }
               catch (BeansException ex) {
                  // Explicitly remove instance from singleton cache: It might have been put there
                  // eagerly by the creation process, to allow for circular reference resolution.
                  // Also remove any beans that received a temporary reference to the bean.
                  destroySingleton(beanName);
                  throw ex;
               }
            });
            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
         }
         else if (mbd.isPrototype()) {
            // It's a prototype -&gt; create a new instance.
            Object prototypeInstance = null;
            try {
               beforePrototypeCreation(beanName);
               prototypeInstance = createBean(beanName, mbd, args);
            }
            finally {
               afterPrototypeCreation(beanName);
            }
            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
         }
         else {
            String scopeName = mbd.getScope();
            final Scope scope = this.scopes.get(scopeName);
            if (scope == null) {
               throw new IllegalStateException(&quot;No Scope registered for scope name '&quot; + scopeName + &quot;'&quot;);
            }
            try {
               Object scopedInstance = scope.get(beanName, () -&gt; {
                  beforePrototypeCreation(beanName);
                  try {
                     return createBean(beanName, mbd, args);
                  }
                  finally {
                     afterPrototypeCreation(beanName);
                  }
               });
               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
            }
            catch (IllegalStateException ex) {
               throw new BeanCreationException(beanName,
                     &quot;Scope '&quot; + scopeName + &quot;' is not active for the current thread; consider &quot; +
                     &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,
                     ex);
            }
         }
      }
      catch (BeansException ex) {
         cleanupAfterBeanCreationFailure(beanName);
         throw ex;
      }
   }
   // Check if required type matches the type of the actual bean instance.
   if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) {
      try {
         T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
         if (convertedBean == null) {
            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
         }
         return convertedBean;
      }
      catch (TypeMismatchException ex) {
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Failed to convert bean '&quot; + name + &quot;' to required type '&quot; +
                  ClassUtils.getQualifiedName(requiredType) + &quot;'&quot;, ex);
         }
         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
      }
   }
   return (T) bean;
}
</code></pre>
<p>上述代码第 32 行：</p>
<pre><code class="language-java">Object sharedInstance = getSingleton(beanName);
</code></pre>
<p>DefaultSingletonBeanRegistry#getSingleton</p>
<pre><code class="language-java">public Object getSingleton(String beanName) {
   return getSingleton(beanName, true);
}
</code></pre>
<p>DefaultSingletonBeanRegistry#getSingleton</p>
<pre><code class="language-java">protected Object getSingleton(String beanName, boolean allowEarlyReference) {
   // 从 map 中获取 bean 如果不为空直接返回，不再进行初始化工作
   Object singletonObject = this.singletonObjects.get(beanName);
   // 第一次 getSingleton() 返回空原因：
   // singletonObject=null
   // isSingletonCurrentlyInCreation:Spring认为还没有到需要创建对象的时候
   if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {
      synchronized (this.singletonObjects) {
         singletonObject = this.earlySingletonObjects.get(beanName);
         if (singletonObject == null &amp;&amp; allowEarlyReference) {
            ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);
            if (singletonFactory != null) {
               singletonObject = singletonFactory.getObject();
               this.earlySingletonObjects.put(beanName, singletonObject);
               this.singletonFactories.remove(beanName);
            }
         }
      }
   }
   return singletonObject;
}
</code></pre>
<p>上述代码第 7 行：</p>
<pre><code class="language-java">/**  正在创建的 bean 名字 */
private final Set&lt;String&gt; singletonsCurrentlyInCreation =
      Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;(16));
      
public boolean isSingletonCurrentlyInCreation(String beanName) {
   return this.singletonsCurrentlyInCreation.contains(beanName);
}
</code></pre>
<p>doGetBean 的第 32 行：第一次调用 getSingleton() 返回空，因为上述 getSingleton 的第 7 行判断：singletonObject=null 且 isSingletonCurrentlyInCreation 为 false :Spring认为还没有到需要创建对象的时候。使用：context.getBean() --&gt; getBeanFactory().getBean(name); --&gt; doGetBean(name, null, null, false);<br>
doGetBean 的第 106 行：第二次调用 getSingleton() 不为空，因为 Spring 已经做了该做的验证（比如 checkMergedBeanDefinition 验证 BeanDefinitionMap 有没有错误，有没有DependsOn），如果都成立则把类放到 alreadyCreated set 集合中，然后调用 getSingleton，如果为空则创建对象。使用：初始化时 new</p>
<pre><code class="language-java">sharedInstance = getSingleton(beanName, () -&gt; {
</code></pre>
<pre><code class="language-java">public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {
      Assert.notNull(beanName, &quot;Bean name must not be null&quot;);
   synchronized (this.singletonObjects) {
      Object singletonObject = this.singletonObjects.get(beanName);
      if (singletonObject == null) {
         if (this.singletonsCurrentlyInDestruction) {
            throw new BeanCreationNotAllowedException(beanName,
                  &quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot; +
                  &quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;);
         }
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Creating shared instance of singleton bean '&quot; + beanName + &quot;'&quot;);
         }
         /**
          * 将 beanName 添加到 singletonCurrentlyInCreation 这样一个 set 集合中
          * 表示 beanName 对应的 bean 正在创建中
          */
         beforeSingletonCreation(beanName);
         boolean newSingleton = false;
         boolean recordSuppressedExceptions = (this.suppressedExceptions == null);
         if (recordSuppressedExceptions) {
            this.suppressedExceptions = new LinkedHashSet&lt;&gt;();
         }
         try {
            singletonObject = singletonFactory.getObject();
            newSingleton = true;
         }
         catch (IllegalStateException ex) {
            // Has the singleton object implicitly appeared in the meantime -&gt;
            // if yes, proceed with it since the exception indicates that state.
            singletonObject = this.singletonObjects.get(beanName);
            if (singletonObject == null) {
               throw ex;
            }
         }
         catch (BeanCreationException ex) {
            if (recordSuppressedExceptions) {
               for (Exception suppressedException : this.suppressedExceptions) {
                  ex.addRelatedCause(suppressedException);
               }
            }
            throw ex;
         }
         finally {
            if (recordSuppressedExceptions) {
               this.suppressedExceptions = null;
            }
            afterSingletonCreation(beanName);
         }
         if (newSingleton) {
            addSingleton(beanName, singletonObject);
         }
      }
      return singletonObject;
   }
}
</code></pre>
<p>上述代码第 18 行：将 beanName 添加到 singletonCurrentlyInCreation 这样一个 set 集合中，表示 beanName 对应的 bean 正在创建中</p>
<pre><code class="language-java">protected void beforeSingletonCreation(String beanName) {
   if (!this.inCreationCheckExclusions.contains(beanName) &amp;&amp; !this.singletonsCurrentlyInCreation.add(beanName)) {
      throw new BeanCurrentlyInCreationException(beanName);
   }
} 
private final Set&lt;String&gt; singletonsCurrentlyInCreation =
      Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;(16));
</code></pre>
<p>断点在上述代码第 25 行：</p>
<pre><code class="language-java">singletonObject = singletonFactory.getObject();
</code></pre>
<p>然后会执行：</p>
<pre><code class="language-java">return createBean(beanName, mbd, args);
</code></pre>
<p>接下来点进 createBean 方法：</p>
<pre><code class="language-java">protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
      throws BeanCreationException {
   if (logger.isDebugEnabled()) {
      logger.debug(&quot;Creating instance of bean '&quot; + beanName + &quot;'&quot;);
   }
   RootBeanDefinition mbdToUse = mbd;
   // Make sure bean class is actually resolved at this point, and
   // clone the bean definition in case of a dynamically resolved Class
   // which cannot be stored in the shared merged bean definition.
   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);
   if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) {
      mbdToUse = new RootBeanDefinition(mbd);
      mbdToUse.setBeanClass(resolvedClass);
   }
   // Prepare method overrides.
   // 处理 lookup-method 和 replace-method 配置，Spring 将这两个配置统称为 MethodOverrides
   try {
      mbdToUse.prepareMethodOverrides();
   }
   catch (BeanDefinitionValidationException ex) {
      throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),
            beanName, &quot;Validation of method overrides failed&quot;, ex);
   }
   try {
      // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
      // 在 bean 实例化前应用后置处理，如果后置处理返回的 bean 不为空，则直接返回，我们这里并没有实现 InstantiationAwareBeanPostProcessor 后置处理器，所以返回的 bean=null
      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
      if (bean != null) {
         return bean;
      }
   }
   catch (Throwable ex) {
      throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,
            &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);
   }
   try {
      Object beanInstance = doCreateBean(beanName, mbdToUse, args);
      if (logger.isDebugEnabled()) {
         logger.debug(&quot;Finished creating instance of bean '&quot; + beanName + &quot;'&quot;);
      }
      return beanInstance;
   }
   catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {
      // A previously detected exception with proper bean creation context already,
      // or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.
      throw ex;
   }
   catch (Throwable ex) {
      throw new BeanCreationException(
            mbdToUse.getResourceDescription(), beanName, &quot;Unexpected exception during bean creation&quot;, ex);
   }
}
</code></pre>
<p>上述代码第 31 行：</p>
<pre><code class="language-java">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
</code></pre>
<pre><code class="language-java">protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {
   Object bean = null;
   if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {
      // Make sure bean class is actually resolved at this point.
      if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {
         Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);
         if (targetType != null) {
            // 执行后置处理器，如果有一个类中有一些属性不需要交给 Spring 处理，就实现InstantiationAwareBeanPostProcessor后置处理器，通过这个后置处理器返回一个 Bean
            bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);
            if (bean != null) {
               bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);
            }
         }
      }
      mbd.beforeInstantiationResolved = (bean != null);
   }
   return bean;
} 
</code></pre>
<p>执行了一个后置处理器，后置处理器是对 Bean 的生产进行插手的，但是现在这个 Bean 并没有产生出来，后置处理器是做什么的呢？<br>
如果有一个类中有一些属性不需要交给 Spring 处理，就实现 InstantiationAwareBeanPostProcessor 后置处理器，通过这个后置处理器返回一个 Bean，如果这个 Bean 不为空，就直接返回这个 Bean。</p>
<p>上述代码第 9 行：</p>
<pre><code class="language-java">protected Object applyBeanPostProcessorsBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) {
   for (BeanPostProcessor bp : getBeanPostProcessors()) {
      // 如果一个类实现了 InstantiationAwareBeanPostProcessor 后置处理器
      if (bp instanceof InstantiationAwareBeanPostProcessor) {
         InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
         // 实现了 InstantiationAwareBeanPostProcessor 后置处理器的类，就可以通过重写 postProcessBeforeInstantiation 方法返回一个真实的 Bean 对象
         Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);
         if (result != null) {
            return result;
         }
      }
   }
   return null;
}
</code></pre>
<p>实现了 InstantiationAwareBeanPostProcessor 后置处理器的类，可以通过重写 postProcessBeforeInstantiation 方法返回一个真实的 Bean 对象：</p>
<pre><code class="language-java">default Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException {
   return null;
}
</code></pre>
<p>上述代码 createBean 方法第 42 行：</p>
<pre><code class="language-java">Object beanInstance = doCreateBean(beanName, mbdToUse, args);
</code></pre>
<pre><code class="language-java">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
      throws BeanCreationException {
   // Instantiate the bean.
   BeanWrapper instanceWrapper = null;
   if (mbd.isSingleton()) {
      instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
   }
   if (instanceWrapper == null) {
      /**
       * 创建 bean 实例，并将实例包裹在 BeanWrapper 实现类对象中返回。
       * createBeanInstance中包含三种创建 bean 实例的方式：
       *     1.通过工厂方法创建 bean 实例
       *     2.通过构造方法自动注入（autowire by constructor）的方式创建 bean 实例
       *     3.通过无参构造方法创建 bean 实例
       *
       *     若 bean 的配置信息中配置了 lookup-method 和 replace-method，则会
       *     增强 bean 实例。
       */
      instanceWrapper = createBeanInstance(beanName, mbd, args);
   }
   final Object bean = instanceWrapper.getWrappedInstance();
   Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();
   if (beanType != NullBean.class) {
      mbd.resolvedTargetType = beanType;
   }
   // Allow post-processors to modify the merged bean definition.
   synchronized (mbd.postProcessingLock) {
      if (!mbd.postProcessed) {
         try {
            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
         }
         catch (Throwable ex) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                  &quot;Post-processing of merged bean definition failed&quot;, ex);
         }
         mbd.postProcessed = true;
      }
   }
   // Eagerly cache singletons to be able to resolve circular references
   // even when triggered by lifecycle interfaces like BeanFactoryAware.
   boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;
         isSingletonCurrentlyInCreation(beanName));
   if (earlySingletonExposure) {
      if (logger.isDebugEnabled()) {
         logger.debug(&quot;Eagerly caching bean '&quot; + beanName +
               &quot;' to allow for resolving potential circular references&quot;);
      }
      addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));
   }
   // Initialize the bean instance.
   Object exposedObject = bean;
   try {
      // 设置属性，非常重要
      populateBean(beanName, mbd, instanceWrapper);
      // 执行后置处理器，AOP就是在这里完成的处理
      exposedObject = initializeBean(beanName, exposedObject, mbd);
   }
   catch (Throwable ex) {
      if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {
         throw (BeanCreationException) ex;
      }
      else {
         throw new BeanCreationException(
               mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);
      }
   }
   if (earlySingletonExposure) {
      Object earlySingletonReference = getSingleton(beanName, false);
      if (earlySingletonReference != null) {
         if (exposedObject == bean) {
            exposedObject = earlySingletonReference;
         }
         else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {
            String[] dependentBeans = getDependentBeans(beanName);
            Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);
            for (String dependentBean : dependentBeans) {
               if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                  actualDependentBeans.add(dependentBean);
               }
            }
            if (!actualDependentBeans.isEmpty()) {
               throw new BeanCurrentlyInCreationException(beanName,
                     &quot;Bean with name '&quot; + beanName + &quot;' has been injected into other beans [&quot; +
                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
                     &quot;] in its raw version as part of a circular reference, but has eventually been &quot; +
                     &quot;wrapped. This means that said other beans do not use the final version of the &quot; +
                     &quot;bean. This is often the result of over-eager type matching - consider using &quot; +
                     &quot;'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.&quot;);
            }
         }
      }
   }
   // Register bean as disposable.
   try {
      registerDisposableBeanIfNecessary(beanName, bean, mbd);
   }
   catch (BeanDefinitionValidationException ex) {
      throw new BeanCreationException(
            mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);
   }
   return exposedObject;
}
</code></pre>
<h4 id="createbeaninstance">createBeanInstance</h4>
<p>上述代码第 20 行：</p>
<pre><code class="language-java">protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {
   // Make sure bean class is actually resolved at this point.
   Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);
   /**
    * 检测一个类的访问权限 Spring 默认情况下对于非 public 的类是允许访问的。
    */
   if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) {
      throw new BeanCreationException(mbd.getResourceDescription(), beanName,
            &quot;Bean class isn't public, and non-public access not allowed: &quot; + beanClass.getName());
   }
   Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();
   if (instanceSupplier != null) {
      return obtainFromSupplier(instanceSupplier, beanName);
   }
   /**
    * 如果工厂方法不为空，则通过工厂方法创建 bean 对象，在这里直接 return，就不会再去执行下面的 Shortcut 等语句了。
    * 这种构建 bean 的方式可以参考以下 demo
    */
   if (mbd.getFactoryMethodName() != null) {
      return instantiateUsingFactoryMethod(beanName, mbd, args);
   }
   // Shortcut when re-creating the same bean...
   /**
    * 从 Spring 的原始注释可以知道这是一个 Shortcut，什么意思呢？
    * 当多次构建同一个 bean 时，可以使用这个 Shortcut，
    * 也就是说不在需要此腿短应该使用哪种方式构造 bean
    * 比如在多次构建同一个 prototype 类型的 bean 时，就可以走此处的 Shortcut
    * 这里的 resolved  和 mbd.constructorArgumentsResolved 将会在 bean 第一次实例化的过程中被设置，后面来证明
    */
   boolean resolved = false;
   boolean autowireNecessary = false;
   if (args == null) {
      synchronized (mbd.constructorArgumentLock) {
         if (mbd.resolvedConstructorOrFactoryMethod != null) {
            resolved = true;
            // 如果已经解析了构造方法的参数，则必须要通过一个带参构造方法来实例
            autowireNecessary = mbd.constructorArgumentsResolved;
         }
      }
   }
   if (resolved) {
      if (autowireNecessary) {
         // 通过构造方法自动装配的方式构造 bean 对象
         return autowireConstructor(beanName, mbd, null, null);
      }
      else {
         // 通过默认的无参构造方法进行
         return instantiateBean(beanName, mbd);
      }
   }
   // Candidate constructors for autowiring?
   // 由后置处理器决定返回哪些构造方法
   Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
   if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
      return autowireConstructor(beanName, mbd, ctors, args);
   }
   // No special handling: simply use no-arg constructor.
   // 使用默认的无参构造方法进行初始化
   return instantiateBean(beanName, mbd);
}
</code></pre>
<h4 id="演示-factorymethod-的-demo1">演示 FactoryMethod 的 demo1</h4>
<p>上述代码第 22 行：</p>
<pre><code class="language-java">//  按照以下demo，当执行到这行代码，发现有一个 FactoryMethod， 就调用 instantiateUsingFactoryMethod 方法去创建
if (mbd.getFactoryMethodName() != null) {
  return instantiateUsingFactoryMethod(beanName, mbd, args);
</code></pre>
<p>Spring 要实例化一个 Bean，会经过一个 getSingleton() 方法，经过一系列判断后，会进入 createBeanInstance() 方法：先判断这个 BeanDefinition 中有没有 FactoryMethod 属性，如果有，则调用 FactoryMethod 去创建对象。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
   &lt;bean id=&quot;order&quot; class=&quot;com.ssm.service.OrderService&quot; factory-method=&quot;query&quot;&gt;
   &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
@ImportResource(&quot;classpath:spring.xml&quot;)
public class AppConfig {
</code></pre>
<pre><code class="language-java">public class Luban {
}
</code></pre>
<pre><code class="language-java">public class OrderService {
   public static Object query(){
      return new Luban();
   }
}
</code></pre>
<p>因为在 xml 中使用了 factory-method 进行配置，所以会将 Luban 对象放到 Spring 容器中去，因此通过 beanName=&quot;order&quot; 拿出的对象也是 Luban。<br>
测试类：</p>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext(AppConfig.class);
      System.out.println(context.getBean(&quot;order&quot;));
      System.out.println(context.getBean(OrderService.class));
      System.out.println(context.getBean(Luban.class));
   }
}
</code></pre>
<p>输出结果：</p>
<pre><code>com.ssm.app.Luban@7c30a502
com.ssm.service.OrderService@49e4cb85
com.ssm.app.Luban@7c30a502
</code></pre>
<h4 id="演示-factorymethod-的-demo2">演示 FactoryMethod 的 demo2</h4>
<p>另一个演示 FactoryMethod 的 demo，被 @Bean 修饰的 static 相当于给这个 bean 添加了一个 factory-method：</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
public class AppConfig {
   @Bean
   public static IndexService indexService(){
      return new IndexService();
   }
   @Bean
   public OrderService orderService(){
      indexService();
      return new OrderService();
   }
}
</code></pre>
<p>按照上述代码，IndexService 会调用两次初始化。</p>
<pre><code class="language-java">@Service
public class IndexService {
   public IndexService(){
      System.out.println(&quot;IndexService...constructor&quot;);
   }
}
</code></pre>
<p>输出结果：</p>
<pre><code>IndexService...constructor
IndexService...constructor
</code></pre>
<p>但是如果去掉 static，IndexService 只会调用一次初始化。</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
public class AppConfig {
   @Bean
   public IndexService indexService(){
      return new IndexService();
   }
   @Bean
   public OrderService orderService(){
      indexService();
      return new OrderService();
   }
}
</code></pre>
<pre><code>IndexService...constructor
</code></pre>
<p>ConfigurationClassPostProcessor#processConfigBeanDefinitions：</p>
<pre><code class="language-java">// configClasses 拿到了 @Import、@Service、@Bean
this.reader.loadBeanDefinitions(configClasses);
</code></pre>
<p>ConfigurationClassBeanDefinitionReader#loadBeanDefinitions --&gt; ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForConfigurationClass：</p>
<pre><code class="language-java">// 如果一个类是 @Bean，会循环拿出所有加了 @Bean 的方法
for (BeanMethod beanMethod : configClass.getBeanMethods()) {
   loadBeanDefinitionsForBeanMethod(beanMethod);
}
</code></pre>
<p>ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForBeanMethod：</p>
<pre><code class="language-java">// 如果这个方法是 static 的，相当于为这个 Bean 配置了一个 factory-method=&quot;index&quot;， 即&lt;bean id=&quot;indexService&quot; class=&quot;com.ssm.service.IndexService&quot; factory-method=&quot;indexService&quot;&gt;
if (metadata.isStatic()) {
   // static @Bean method
   beanDef.setBeanClassName(configClass.getMetadata().getClassName());
   // 设置 FactoryMethod
   beanDef.setFactoryMethodName(methodName);
}
// 如果这个方法不是 static 的
else {
   // instance @Bean method
   beanDef.setFactoryBeanName(configClass.getBeanName());
   // 设置  UniqueFactoryMethod
   beanDef.setUniqueFactoryMethodName(methodName);
}
</code></pre>
<h1 id="shortcut-快捷方式">Shortcut 快捷方式</h1>
<h2 id="无参构造方法">无参构造方法</h2>
<p>首先声明 IndexService 中有一个无参构造方法：</p>
<pre><code class="language-java">@Service
public class IndexService {
   public IndexService(){
      System.out.println(&quot;IndexService...constructor&quot;);
   }
}
</code></pre>
<ul>
<li>当重新创建同一个 Bean 的时候使用 Shortcut 快捷方式</li>
</ul>
<p>createBeanInstance 的第 27-67 行：</p>
<pre><code class="language-java">// 当重新创建同一个 Bean 的时候使用 Shortcut 快捷方式
/**
 * 从 Spring 的原始注释可以知道这是一个 Shortcut，什么意思呢？
 * 当多次构建同一个 bean 时，可以使用这个 Shortcut，
 * 也就是说不在需要此腿短应该使用哪种方式构造 bean
 * 比如在多次构建同一个 prototype 类型的 bean 时，就可以走此处的 Shortcut
 * 这里的 resolved  和 mbd.constructorArgumentsResolved 将会在 bean 第一次实例化的过程中被设置，后面来证明
 */
boolean resolved = false;
// 必须自动装配
boolean autowireNecessary = false;
if (args == null) {
   synchronized (mbd.constructorArgumentLock) {
      // 如果是一个 FactoryMethod 创建的，就会把 resolved 设置为 true
      if (mbd.resolvedConstructorOrFactoryMethod != null) {
         resolved = true;
         // 如果已经解析了构造方法的参数，则必须要通过一个带参构造方法来实例
         autowireNecessary = mbd.constructorArgumentsResolved;
      }
   }
}
if (resolved) {
   if (autowireNecessary) {
      // 通过构造方法自动装配的方式构造 bean 对象
      return autowireConstructor(beanName, mbd, null, null);
   }
   else {
      // 通过默认的无参构造方法进行
      return instantiateBean(beanName, mbd);
   }
}
// Candidate constructors for autowiring?
// 由后置处理器决定返回哪些构造方法
   Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
      mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
   return autowireConstructor(beanName, mbd, ctors, args);
}
// No special handling: simply use no-arg constructor.
// 使用默认的无参构造方法进行初始化
return instantiateBean(beanName, mbd);
</code></pre>
<p>Spring 在构建对象的时候，要知道这个对象如何构建，利用构造方法还是默认的构造方法，通过 autowireNecessary 值来记录，当第二次被实例化时，直接判断 autowireNecessary 的值即可。<br>
上述代码第 35 行：</p>
<pre><code class="language-java">//  拿出构造方法，然后决定用哪个构造方法进行实例化
Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/FZ9Tj8MwpTCVHFpr.png" alt="图片" loading="lazy"></figure>
<p>Spring 得到构造方法，然后通过构造方法去 new 对象。</p>
<p>IndexService 中有一个无参构造方法，Spring 会认为它没有构造方法，如上图 determineConstructorsFromBeanPostProcessors 方法返回 null，然后执行 instantiateBean 方法去创建对象。</p>
<pre><code class="language-java">protected Constructor&lt;?&gt;[] determineConstructorsFromBeanPostProcessors(@Nullable Class&lt;?&gt; beanClass, String beanName)
      throws BeansException {
   // 是否有 InstantiationAwareBeanPostProcessors 后置处理器
   if (beanClass != null &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {
      for (BeanPostProcessor bp : getBeanPostProcessors()) {
         // 如果有 SmartInstantiationAwareBeanPostProcessor 后置处理器
         if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
            SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;
            Constructor&lt;?&gt;[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);
            if (ctors != null) {
               return ctors;
            }
         }
      }
   }
   return null;
}
</code></pre>
<p>上述代码第 9 行，首先这个 SmartInstantiationAwareBeanPostProcessor 后置处理器什么都没做，直接 return null;</p>
<pre><code class="language-java">public Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, String beanName) throws BeansException {
   return null;
}
</code></pre>
<p>再进行下一轮循环，这个后置处理器的操作非常复杂了：</p>
<pre><code class="language-java">public Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, final String beanName)
      throws BeanCreationException {
   // Let's check for lookup methods here...
   if (!this.lookupMethodsChecked.contains(beanName)) {
      try {
         ReflectionUtils.doWithMethods(beanClass, method -&gt; {
            Lookup lookup = method.getAnnotation(Lookup.class);
            if (lookup != null) {
               Assert.state(this.beanFactory != null, &quot;No BeanFactory available&quot;);
               LookupOverride override = new LookupOverride(method, lookup.value());
               try {
                  RootBeanDefinition mbd = (RootBeanDefinition)
                        this.beanFactory.getMergedBeanDefinition(beanName);
                  mbd.getMethodOverrides().addOverride(override);
               }
               catch (NoSuchBeanDefinitionException ex) {
                  throw new BeanCreationException(beanName,
                        &quot;Cannot apply @Lookup to beans without corresponding bean definition&quot;);
               }
            }
         });
      }
      catch (IllegalStateException ex) {
         throw new BeanCreationException(beanName, &quot;Lookup method resolution failed&quot;, ex);
      }
      this.lookupMethodsChecked.add(beanName);
   }
   // Quick check on the concurrent map first, with minimal locking.
   // 从构造方法的缓存中拿一个构造方法
   Constructor&lt;?&gt;[] candidateConstructors = this.candidateConstructorsCache.get(beanClass);
   if (candidateConstructors == null) {
      // Fully synchronized resolution now...
      synchronized (this.candidateConstructorsCache) {
         candidateConstructors = this.candidateConstructorsCache.get(beanClass);
         if (candidateConstructors == null) {
            Constructor&lt;?&gt;[] rawCandidates;
            try {
               // 通过反射得到 IndexService 的构造方法
               rawCandidates = beanClass.getDeclaredConstructors();
            }
            catch (Throwable ex) {
               throw new BeanCreationException(beanName,
                     &quot;Resolution of declared constructors on bean Class [&quot; + beanClass.getName() +
                     &quot;] from ClassLoader [&quot; + beanClass.getClassLoader() + &quot;] failed&quot;, ex);
            }
            List&lt;Constructor&lt;?&gt;&gt; candidates = new ArrayList&lt;&gt;(rawCandidates.length);
            Constructor&lt;?&gt; requiredConstructor = null;
            Constructor&lt;?&gt; defaultConstructor = null;
            Constructor&lt;?&gt; primaryConstructor = BeanUtils.findPrimaryConstructor(beanClass);
            int nonSyntheticConstructors = 0;
            for (Constructor&lt;?&gt; candidate : rawCandidates) {
               if (!candidate.isSynthetic()) {
                  nonSyntheticConstructors++;
               }
               else if (primaryConstructor != null) {
                  continue;
               }
               AnnotationAttributes ann = findAutowiredAnnotation(candidate);
               if (ann == null) {
                  Class&lt;?&gt; userClass = ClassUtils.getUserClass(beanClass);
                  if (userClass != beanClass) {
                     try {
                        Constructor&lt;?&gt; superCtor =
                              userClass.getDeclaredConstructor(candidate.getParameterTypes());
                        ann = findAutowiredAnnotation(superCtor);
                     }
                     catch (NoSuchMethodException ex) {
                        // Simply proceed, no equivalent superclass constructor found...
                     }
                  }
               }
               if (ann != null) {
                  if (requiredConstructor != null) {
                     throw new BeanCreationException(beanName,
                           &quot;Invalid autowire-marked constructor: &quot; + candidate +
                           &quot;. Found constructor with 'required' Autowired annotation already: &quot; +
                           requiredConstructor);
                  }
                  boolean required = determineRequiredStatus(ann);
                  if (required) {
                     if (!candidates.isEmpty()) {
                        throw new BeanCreationException(beanName,
                              &quot;Invalid autowire-marked constructors: &quot; + candidates +
                              &quot;. Found constructor with 'required' Autowired annotation: &quot; +
                              candidate);
                     }
                     requiredConstructor = candidate;
                  }
                  candidates.add(candidate);
               }
               // 如果构造方法的参数=0，即无参构造方法
               else if (candidate.getParameterCount() == 0) {
                  defaultConstructor = candidate;
               }
            }
            if (!candidates.isEmpty()) {
               // Add default constructor to list of optional constructors, as fallback.
               if (requiredConstructor == null) {
                  if (defaultConstructor != null) {
                     candidates.add(defaultConstructor);
                  }
                  else if (candidates.size() == 1 &amp;&amp; logger.isWarnEnabled()) {
                     logger.warn(&quot;Inconsistent constructor declaration on bean with name '&quot; + beanName +
                           &quot;': single autowire-marked constructor flagged as optional - &quot; +
                           &quot;this constructor is effectively required since there is no &quot; +
                           &quot;default constructor to fall back to: &quot; + candidates.get(0));
                  }
               }
               candidateConstructors = candidates.toArray(new Constructor&lt;?&gt;[0]);
            }
            // 如果有 1个 构造方法，且构造方法有参数
            else if (rawCandidates.length == 1 &amp;&amp; rawCandidates[0].getParameterCount() &gt; 0) {
               candidateConstructors = new Constructor&lt;?&gt;[] {rawCandidates[0]};
            }
            // 如果有 2个 构造方法，且主要的构造方法不为空且...
            else if (nonSyntheticConstructors == 2 &amp;&amp; primaryConstructor != null &amp;&amp;
                  defaultConstructor != null &amp;&amp; !primaryConstructor.equals(defaultConstructor)) {
               candidateConstructors = new Constructor&lt;?&gt;[] {primaryConstructor, defaultConstructor};
            }
            // 如果有 1个 构造方法，且构造方法参数不为空
            else if (nonSyntheticConstructors == 1 &amp;&amp; primaryConstructor != null) {
               candidateConstructors = new Constructor&lt;?&gt;[] {primaryConstructor};
            }
            else {
               // 因为  IndexService 内有一个无参构造方法，所以上述三个 else if 判断都不成立，所以会进入 else 分支
               candidateConstructors = new Constructor&lt;?&gt;[0];
            }
            this.candidateConstructorsCache.put(beanClass, candidateConstructors);
         }
      }
   }
   return (candidateConstructors.length &gt; 0 ? candidateConstructors : null);
}
</code></pre>
<p>上述代码第 41 行：</p>
<pre><code class="language-java">rawCandidates = beanClass.getDeclaredConstructors();
</code></pre>
<p><img src="https://epitomm.github.io/post-images/mWIAbxNGJdjVMIGW.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/6pMDddCa1pKMHuyv.png" alt="图片" loading="lazy"></p>
<h2 id="有参构造方法">有参构造方法</h2>
<p>如果为 IndexService 添加了一个 有参构造方法：</p>
<pre><code class="language-java">@Service
public class IndexService {
   public IndexService(String str){
      System.out.println(&quot;IndexService...constructor&quot;);
   }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/PMA5pOIPRlLi8GVH.png" alt="图片" loading="lazy"></figure>
<pre><code class="language-java">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
      mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
   return autowireConstructor(beanName, mbd, ctors, args);
}
</code></pre>
<p>有参构造方法就会调用 autowireConstructor 方法创建对象。</p>
<pre><code class="language-java">protected BeanWrapper autowireConstructor(
      String beanName, RootBeanDefinition mbd, @Nullable Constructor&lt;?&gt;[] ctors, @Nullable Object[] explicitArgs) {
   return new ConstructorResolver(this).autowireConstructor(beanName, mbd, ctors, explicitArgs);
}
</code></pre>
<pre><code class="language-java">public ConstructorResolver(AbstractAutowireCapableBeanFactory beanFactory) {
   this.beanFactory = beanFactory;
   this.logger = beanFactory.getLogger();
}
</code></pre>
<pre><code class="language-java">public BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd,
      @Nullable Constructor&lt;?&gt;[] chosenCtors, @Nullable Object[] explicitArgs) {
   // 实例一个 BeanWrapperImpl 对象
   // 前面外部返回的 BeanWrapper 其实就是这个 BeanWrapperImpl
   // 因为 BeanWrapper 是个接口
   BeanWrapperImpl bw = new BeanWrapperImpl();
   this.beanFactory.initBeanWrapper(bw);
   // Spring 决定采用哪个构造方法来实例化 bean，把这个构造方法使用 constructorToUse 变量暂存起来
   // 代码执行到这里 Spring 已经决定要采用一个特殊构造方法来实例 bean
   Constructor&lt;?&gt; constructorToUse = null;
   // 构造方法的值，构造方法通过反射来实例化一个对象
   // 但是这里需要注意的是 argsHolderToUse 是一个数据结构
   // argsToUse[] 才是真正的值
   ArgumentsHolder argsHolderToUse = null;
   Object[] argsToUse = null;
   // 确定参数值列表
   /**
    * explicitArgs 是从 createBeanInstance 方法传过来的，构造方法的值
    * org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBeanInstance
    * 可以看到如果从 createBeanInstance 调用那么永远为空
    */
   if (explicitArgs != null) {
      argsToUse = explicitArgs;
   }
   else {
      Object[] argsToResolve = null;
      synchronized (mbd.constructorArgumentLock) {
         constructorToUse = (Constructor&lt;?&gt;) mbd.resolvedConstructorOrFactoryMethod;
         if (constructorToUse != null &amp;&amp; mbd.constructorArgumentsResolved) {
            // Found a cached constructor...
            argsToUse = mbd.resolvedConstructorArguments;
            if (argsToUse == null) {
               argsToResolve = mbd.preparedConstructorArguments;
            }
         }
      }
      if (argsToResolve != null) {
         argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve);
      }
   }
   if (constructorToUse == null) {
      // Need to resolve the constructor.
      // 如果没有已经解析的构造方法
      // 则需要去解析构造方法
      // 判断构造方法是否为空，判断是否根据构造方法自动注入，此时 IndexService 有一个有参构造方法，所以 autowiring =true
      boolean autowiring = (chosenCtors != null ||
            mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);
      ConstructorArgumentValues resolvedValues = null;
      // 定义了最小参数个数
      // 如果构造方法的参数列表给定了具体的值
      // 那么这里指的就是构造方法参数的个数
      int minNrOfArgs;
      if (explicitArgs != null) {
         minNrOfArgs = explicitArgs.length;
      }
      else {
         /**
          * cargs 获取构造方法的值，注意是值，不是类型和列表
          */
         ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();
         resolvedValues = new ConstructorArgumentValues();
         /**
          * 把 cargs 的内容给 resolvedValues 比那里并且确定构造方法参数数量，假设有如下配置：
          *     &lt;bean id=&quot;luban&quot; class=&quot;com.luban.Luban&quot;&gt;
          *        &lt;constructor-arg index=&quot;0&quot; value=&quot;str1&quot;/&gt;
          *        &lt;constructor-arg index=&quot;1&quot; value=&quot;1&quot;/&gt;
          *        &lt;constructor-arg index=&quot;2&quot; value=&quot;str2&quot;/&gt;
          *      &lt;/bean&gt;
          *
          * 那么 minNrOfArgs=3
          * 或者你通过 Spring 的各种扩展点给了 Spring 一些构造方法的值，那么也能确定
          * 为什么要确定？
          * 因为我们的构造方法有多个，
          * 那么类型和个数是 Spring 用来确定使用哪个构造方法的重要信息
          */
         minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);
      }
      // Take specified constructors, if any.
      Constructor&lt;?&gt;[] candidates = chosenCtors;
      if (candidates == null) {
         Class&lt;?&gt; beanClass = mbd.getBeanClass();
         try {
            // 得到所有的构造方法
            candidates = (mbd.isNonPublicAccessAllowed() ?
                  beanClass.getDeclaredConstructors() : beanClass.getConstructors());
         }
         catch (Throwable ex) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                  &quot;Resolution of declared constructors on bean Class [&quot; + beanClass.getName() +
                  &quot;] from ClassLoader [&quot; + beanClass.getClassLoader() + &quot;] failed&quot;, ex);
         }
      }
      // 构造方法进行排序 
      AutowireUtils.sortConstructors(candidates);
      // 定义了一个差异变量，默认为 Integer 最大值
      int minTypeDiffWeight = Integer.MAX_VALUE;
      // 有歧义的构造方法 public IndexService(Class clazz){} 和 public IndexService(Object obj){}
      Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors = null;
      // 循环所有的构造方法
      LinkedList&lt;UnsatisfiedDependencyException&gt; causes = null;
      for (Constructor&lt;?&gt; candidate : candidates) {
         Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();
         // 需要循环寻找构造方法，
         // 因为：比如传参为 (&quot;hello&quot;, &quot;world&quot;, 120)
         // 比如有这样这样一个这样的构造方法：public void IndexService(Object o1, Object o2, Object o3) ，Spring 会认为它符合；但是还有一个 public void IndexService(String str, String str2, Integer i2):这个构造方法更符合传参的类型，所以会循环不断寻找构造方法，为了找到更匹配的。
         // 如果构造方法参数个数(3) &gt; 当前这个构造方法参数个数(2)，则不再继续向下找。因为当前构造方法是按照参数个数进行排好序的，当前构造方法个数为2了，表明后面不会有更匹配的了，于是终止。 
         if (constructorToUse != null &amp;&amp; argsToUse.length &gt; paramTypes.length) {
            // Already found greedy constructor that can be satisfied -&gt;
            // do not look any further, there are only less greedy constructors left.
            break;
         }
         if (paramTypes.length &lt; minNrOfArgs) {
            continue;
         }
         ArgumentsHolder argsHolder;
         if (resolvedValues != null) {
            try {
               String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, paramTypes.length);
               if (paramNames == null) {
                  ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();
                  if (pnd != null) {
                     paramNames = pnd.getParameterNames(candidate);
                  }
               }
               argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,
                     getUserDeclaredConstructor(candidate), autowiring);
            }
            catch (UnsatisfiedDependencyException ex) {
               if (logger.isTraceEnabled()) {
                  logger.trace(&quot;Ignoring constructor [&quot; + candidate + &quot;] of bean '&quot; + beanName + &quot;': &quot; + ex);
               }
               // Swallow and try next constructor.
               if (causes == null) {
                  causes = new LinkedList&lt;&gt;();
               }
               causes.add(ex);
               continue;
            }
         }
         else {
            // Explicit arguments given -&gt; arguments length must match exactly.
            if (paramTypes.length != explicitArgs.length) {
               continue;
            }
            argsHolder = new ArgumentsHolder(explicitArgs);
         }
         int typeDiffWeight = (mbd.isLenientConstructorResolution() ?
               argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));
         // Choose this constructor if it represents the closest match.
         if (typeDiffWeight &lt; minTypeDiffWeight) {
            constructorToUse = candidate;
            argsHolderToUse = argsHolder;
            argsToUse = argsHolder.arguments;
            minTypeDiffWeight = typeDiffWeight;
            ambiguousConstructors = null;
         }
         else if (constructorToUse != null &amp;&amp; typeDiffWeight == minTypeDiffWeight) {
            if (ambiguousConstructors == null) {
               ambiguousConstructors = new LinkedHashSet&lt;&gt;();
               ambiguousConstructors.add(constructorToUse);
            }
            ambiguousConstructors.add(candidate);
         }
      }
      if (constructorToUse == null) {
         if (causes != null) {
            UnsatisfiedDependencyException ex = causes.removeLast();
            for (Exception cause : causes) {
               this.beanFactory.onSuppressedException(cause);
            }
            throw ex;
         }
         throw new BeanCreationException(mbd.getResourceDescription(), beanName,
               &quot;Could not resolve matching constructor &quot; +
               &quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)&quot;);
      }
      else if (ambiguousConstructors != null &amp;&amp; !mbd.isLenientConstructorResolution()) {
         throw new BeanCreationException(mbd.getResourceDescription(), beanName,
               &quot;Ambiguous constructor matches found in bean '&quot; + beanName + &quot;' &quot; +
               &quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): &quot; +
               ambiguousConstructors);
      }
      if (explicitArgs == null) {
         argsHolderToUse.storeCache(mbd, constructorToUse);
      }
   }
   try {
      final InstantiationStrategy strategy = beanFactory.getInstantiationStrategy();
      Object beanInstance;
      if (System.getSecurityManager() != null) {
         final Constructor&lt;?&gt; ctorToUse = constructorToUse;
         final Object[] argumentsToUse = argsToUse;
         beanInstance = AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;
               strategy.instantiate(mbd, beanName, beanFactory, ctorToUse, argumentsToUse),
               beanFactory.getAccessControlContext());
      }
      else {
         beanInstance = strategy.instantiate(mbd, beanName, this.beanFactory, constructorToUse, argsToUse);
      }
      bw.setBeanInstance(beanInstance);
      return bw;
   }
   catch (Throwable ex) {
      throw new BeanCreationException(mbd.getResourceDescription(), beanName,
            &quot;Bean instantiation via constructor failed&quot;, ex);
   }
}
</code></pre>
<p>上述第 116 行代码：</p>
<pre><code class="language-java">if (constructorToUse != null &amp;&amp; argsToUse.length &gt; paramTypes.length){
</code></pre>
<p>constructorToUse != null：因为 Spring 会有多次循环，当循环第一次如果找到了匹配的构造方法，会把构造方法赋值给 constructorToUse；第二次循环时 constructorToUse != null，然后判断 argsToUse.length 参数长度<br>
需要循环寻找构造方法，因为：比如传参为 (&quot;hello&quot;, &quot;world&quot;, 120)</p>
<p>比如有这样这样一个这样的构造方法：public void IndexService(Object o1, Object o2, Object o3) ，Spring 会认为它符合；</p>
<p>但是还有一个 public void IndexService(String str, String str2, Integer i2):这个构造方法更符合传参的类型，所以会循环不断寻找构造方法，为了找到更匹配的。</p>
<p>如果构造方法参数个数(3) &gt; 当前这个构造方法参数个数(2)，则不再继续向下找。因为当前构造方法是按照参数个数进行排好序的，当前构造方法个数为2了，表明后面不会有更匹配的了，于是终止。</p>
<h2 id="一个有参-一个无参构造方法">一个有参、一个无参构造方法</h2>
<p>当 IndexService 有一个无参、一个有参构造方法时：</p>
<pre><code class="language-java">@Service
public class IndexService {
   public IndexService(String str){
      System.out.println(&quot;IndexService...constructor&quot;);
   }
   public IndexService(){
   }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/S7iCrnxWKpwY5lkQ.png" alt="图片" loading="lazy"></figure>
<p>Spring 不知道你到底要调用哪个构造方法，于是干脆返回 null，调用无参构造方法。</p>
<p>createBeanInstance 中使用默认构造方法进行实例化：</p>
<pre><code class="language-java">// 使用默认的无参构造方法进行初始化
return instantiateBean(beanName, mbd);
</code></pre>
<pre><code class="language-java">protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {
   try {
      Object beanInstance;
      final BeanFactory parent = this;
      if (System.getSecurityManager() != null) {
         beanInstance = AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;
               getInstantiationStrategy().instantiate(mbd, beanName, parent),
               getAccessControlContext());
      }
      else {
         // getInstantiationStrategy() 得到类的实例化策略
         // 默认情况下是得到一个反射的实例化策略
         beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);
      }
      BeanWrapper bw = new BeanWrapperImpl(beanInstance);
      initBeanWrapper(bw);
      return bw;
   }
   catch (Throwable ex) {
      throw new BeanCreationException(
            mbd.getResourceDescription(), beanName, &quot;Instantiation of bean failed&quot;, ex);
   }
}
</code></pre>
<p>上述代码第 13 行：</p>
<pre><code class="language-java">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/cVEHVfWfsTFkJTj5__thumbnail.png" alt="图片" loading="lazy"></figure>
<pre><code class="language-java">public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {
   // Don't override the class with CGLIB if no overrides.
   // 检查 bean 配置中是否配置了 lookup-method 或 replace-method
   // 如果配置了就需要使用 CGLIB 构建 bean 对象
   if (!bd.hasMethodOverrides()) {
      Constructor&lt;?&gt; constructorToUse;
      synchronized (bd.constructorArgumentLock) {
         // constructorToUse： 使用哪个构造方法
         constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;
         if (constructorToUse == null) {
            final Class&lt;?&gt; clazz = bd.getBeanClass();
            // 如果 clazz 是接口，抛出异常
            if (clazz.isInterface()) {
               throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;);
            }
            try {
               if (System.getSecurityManager() != null) {
                  constructorToUse = AccessController.doPrivileged(
                        (PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) clazz::getDeclaredConstructor);
               }
               else {
                  // getDeclaredConstructor：得到默认构造方法，constructorToUse：表示 Spring 使用哪个构造方法实例对象
                  constructorToUse = clazz.getDeclaredConstructor();
               }
               bd.resolvedConstructorOrFactoryMethod = constructorToUse;
            }
            catch (Throwable ex) {
               throw new BeanInstantiationException(clazz, &quot;No default constructor found&quot;, ex);
            }
         }
      }
      return BeanUtils.instantiateClass(constructorToUse);
   }
   else {
      // Must generate CGLIB subclass.
      return instantiateWithMethodInjection(bd, beanName, owner);
   }
}
</code></pre>
<p>上述代码第 23 行：<br>
<img src="https://epitomm.github.io/post-images/AxQHvIdwrp1K1Dd2__thumbnail.png" alt="图片" loading="lazy"></p>
<p>上述代码第 32 行，反射完成 Bean 的实例化：</p>
<pre><code class="language-java">public static &lt;T&gt; T instantiateClass(Constructor&lt;T&gt; ctor, Object... args) throws BeanInstantiationException {
   Assert.notNull(ctor, &quot;Constructor must not be null&quot;);
   try {
      // 设置构造方法可访问
      ReflectionUtils.makeAccessible(ctor);
      // 反射创建对象
      return (KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ?
            KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args));
   }
   catch (InstantiationException ex) {
      throw new BeanInstantiationException(ctor, &quot;Is it an abstract class?&quot;, ex);
   }
   catch (IllegalAccessException ex) {
      throw new BeanInstantiationException(ctor, &quot;Is the constructor accessible?&quot;, ex);
   }
   catch (IllegalArgumentException ex) {
      throw new BeanInstantiationException(ctor, &quot;Illegal arguments for constructor&quot;, ex);
   }
   catch (InvocationTargetException ex) {
      throw new BeanInstantiationException(ctor, &quot;Constructor threw exception&quot;, ex.getTargetException());
   }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring系列（十三）Spring AOP源码分析]]></title>
        <id>https://epitomm.github.io/post/spring-xi-lie-shi-san-spring-aop-yuan-ma-fen-xi/</id>
        <link href="https://epitomm.github.io/post/spring-xi-lie-shi-san-spring-aop-yuan-ma-fen-xi/">
        </link>
        <updated>2020-05-27T11:03:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="先从一个-aop-例子开始">先从一个 AOP 例子开始</h1>
<pre><code class="language-xml">&lt;dependencies&gt;
  &lt;!-- spring --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.0.9.RELEASE&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;!-- aspectj --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
    &lt;version&gt;1.9.0&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<pre><code class="language-java">@ComponentScan(&quot;com.ssm&quot;)
@Configuration
@EnableAspectJAutoProxy
public class AppConfig {
}
</code></pre>
<pre><code class="language-java">@Component
@Aspect
public class AspectSSM {
    @Pointcut(&quot;execution(* com.ssm.dao.*.*(..))&quot;)
    public void pointCut(){
    }
    @Before(&quot;pointCut()&quot;)
    public void before(){
        System.out.println(&quot;proxy before&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public interface OrderDao {
    public void query();
}
</code></pre>
<pre><code class="language-java">@Component
public class OrderDaoImpl implements OrderDao {
    @Override
    public void query() {
        System.out.println(&quot;query...&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext configApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
        configApplicationContext.getBean(OrderDao.class).query();
    }
}
</code></pre>
<p>测试结果：</p>
<pre><code>proxy before
query...
</code></pre>
<h2 id="一个需求根据参数在-service-内调用不同-dao">一个需求：根据参数在 service 内调用不同 dao</h2>
<p>一个需求：如果登录的是 A类用户，就调用 OrderADaoImpl；如果登录的是 B 类用户，就调用 OrderDaoBImpl</p>
<pre><code class="language-java">@Service
public class OrderService {
    @Autowired
    OrderDao orderDao;
    public void query(String str){
        // 如果 str='A',orderDao=OrderDaoAImpl;
        // 如果 str'B',OrderDao=OrderDaoBImpl
        orderDao.query(str);
    }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/5KUUxsI8sbRrU7m3.png" alt="图片" loading="lazy"></figure>
<p>第一阶段 Spring 初始化：初始化后已经有了 OrderService 类，OrderService 类依赖 OrderDao</p>
<p>第二阶段用户阶段： 用户登录，调用 orderService 的方法，因为 OrderService 已经被实例化了，里面的属性 OrderDao 也被确定了。</p>
<p>Spring 扩展点是在 Spring 生命周期之间插手去做一些事情，一旦 Spring 生命周期结束，对 Spring 工厂做其他事情已经没有意义了。</p>
<h3 id="解决方案一再创建一个工厂">解决方案一：再创建一个工厂</h3>
<pre><code class="language-java">@Service
public class OrderService implements ApplicationContextAware {
    ApplicationContext applicationContext;
    
    public void query(String str){
        OrderDao orderDao = null;
        if(&quot;A&quot;.equals(str)){
            orderDao = (OrderDao) applicationContext.getBean(&quot;orderDaoAImpl&quot;);
        }else if(&quot;B&quot;.equals(str)){
            orderDao = (OrderDao) applicationContext.getBean(&quot;orderDaoBImpl&quot;);
        }
        orderDao.query(str);
    }
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
}
</code></pre>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext configApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
        OrderService orderService = configApplicationContext.getBean(OrderService.class);
        orderService.query(&quot;A&quot;);
    }
}
</code></pre>
<p>当传参数为 A 时，调用 OrderDaoAImpl 的方法；当传参数为 B 时，调用 OrderDaoBImpl 的方法。</p>
<h3 id="方法二map">方法二：Map</h3>
<pre><code class="language-java">@Service
public class OrderService{
    @Autowired
    Map&lt;String,OrderDao&gt; orderDaoMap;
    public void query(String str){
        OrderDao orderDao =  orderDaoMap.get(&quot;orderDao&quot;+str+&quot;Impl&quot;);
        orderDao.query(str);
    }
}
</code></pre>
<p><img src="https://epitomm.github.io/post-images/6FvFs1Etv3oBBqLg.png" alt="图片" loading="lazy"><br>
当测试类传参数为 A 时，调用 OrderDaoAImpl 的方法；当传参数为 B 时，调用 OrderDaoBImpl 的方法。</p>
<h1 id="spring-中的后置处理器">Spring 中的后置处理器</h1>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/Spring%E4%B8%AD%E7%9A%84%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8.png" alt="图片" loading="lazy"></figure>
<p>BeanPostProcessor：Spring 后置处理器。为什么需要注册 BeanPostProcessor？</p>
<p>实例化要经过 BeanPostProcessor 处理器，这个处理器是一个 List，这个 List 被维护在 Spring 内部，所以要把 BeanPostProcessor 注册给它，BeanPostProcessor 是一个 List，有自定义，也有 Spring 内部的，Spring 内部有非常多后置处理器，这里就是把 Spring 内部要执行的后置处理器注册到这个 List 中。</p>
<p>AbstractApplicationContext#refresh(); ---&gt; AbstractApplicationContext#registerBeanPostProcessors ---&gt;PostProcessorRegistrationDelegate#registerBeanPostProcessors</p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/3%E4%B8%AA%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8.png" alt="图片" loading="lazy"></figure>
<p>如上图所示，现在 Spring 容器中有三个后置处理器。</p>
<h2 id="applicationcontextawareprocessor">ApplicationContextAwareProcessor</h2>
<h2 id="applicationlistenerdetector">ApplicationListenerDetector</h2>
<p>先来分析第一个后置处理器 ApplicationContextAwareProcessor 和第二个后置处理器 ApplicationListenerDetector。</p>
<p>按调用链：AnnotationConfigApplicationContext#AnnotationConfigApplicationContext(Class&lt;?&gt;... annotatedClasses) ---&gt; AbstractApplicationContext#refresh() ---&gt; AbstractApplicationContext#prepareBeanFactory(beanFactory); 添加了两个后置处理器到 Spring 容器内：</p>
<pre><code class="language-java">// 添加后置处理器
beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));
</code></pre>
<h2 id="importawarebeanpostprocessor">ImportAwareBeanPostProcessor</h2>
<p>接下来看第三个后置处理器 ImportAwareBeanPostProcessor，这个类是在哪里注入进来的呢？</p>
<p>refresh() 方法内的 invokeBeanFactoryPostProcessors(beanFactory); 在 CGLIB 增强时，注入了 ImportAwareBeanPostProcessor。</p>
<p>调用链如下：AbstractApplicationContext #refresh ---&gt; AbstractApplicationContext#invokeBeanFactoryPostProcessors ---&gt; PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors ---&gt; PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors ---&gt; ConfigurationClassPostProcessor#postProcessBeanFactory</p>
<pre><code class="language-java">beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory));
</code></pre>
<p>ImportAwareBeanPostProcessor 间接继承了 BeanPostProcessor<br>
当一个类实例化之后会调用 BeanPostProcessor，</p>
<p>ImportAwareBeanPostProcessor#postProcessBeforeInitialization</p>
<pre><code class="language-java">@Override
public Object postProcessBeforeInitialization(Object bean, String beanName) {
   // 判断这个 bean 是否是 ImportAware
   if (bean instanceof ImportAware) {
      ImportRegistry ir = this.beanFactory.getBean(IMPORT_REGISTRY_BEAN_NAME, ImportRegistry.class);
      AnnotationMetadata importingClass = ir.getImportingClassFor(bean.getClass().getSuperclass().getName());
      if (importingClass != null) {
         ((ImportAware) bean).setImportMetadata(importingClass);
      }
   }
   return bean;
}
</code></pre>
<h3 id="importaware扩展-spring-常用">ImportAware：扩展 Spring 常用</h3>
<p>比如有一个连接数据库工具 DBConfig：</p>
<pre><code class="language-java">public class DBConfig{
   String name;
   String password;
   //...
}
</code></pre>
<p>在 AppConfig 中：</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
@SSMDBUtils 
public class AppConfig {
</code></pre>
<p>如何将数据库的用户名、密码等信息设置给 SSMDBUtils 的 name、password 属性呢？</p>
<ul>
<li>xml、properties 配置文件</li>
</ul>
<p>ImportAware 的 setImportMetadata() 方法：得到 Spring 注解上的值，设置给特定属性：</p>
<pre><code class="language-java">@Component
public class DBConfig implements ImportAware {
   String name;
   String password;
   @Override
   public void setImportMetadata(AnnotationMetadata importMetadata) {
      // 拿到 AppConfig 类上的所有注解，得到 @EnableSSMUtil注解 上的 name、password 值赋值给当前对象
      Set&lt;String&gt; appConfig = importMetadata.getMetaAnnotationTypes(&quot;appConfig&quot;);
      System.out.println(appConfig);
   }
}
</code></pre>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
@EnableSSMUtil
public class AppConfig {
</code></pre>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
public @interface EnableSSMUtil {
   String name() default &quot;root&quot;;
   String password() default &quot;root&quot;;
}
</code></pre>
<h2 id="beanpostprocessorchecker">BeanPostProcessorChecker</h2>
<p>AbstractApplicationContext#refresh ---&gt; AbstractApplicationContext#registerBeanPostProcessors ---&gt; PostProcessorRegistrationDelegate#registerBeanPostProcessors</p>
<pre><code class="language-java">public static void registerBeanPostProcessors(
      ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {
   // 从 beanDefinitionMap 中得到所有的 BeanPostProcessor
      String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);
   // Register BeanPostProcessorChecker that logs an info message when
   // a bean is created during BeanPostProcessor instantiation, i.e. when
   // a bean is not eligible for getting processed by all BeanPostProcessors.
   int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;
   beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));
   // Separate between BeanPostProcessors that implement PriorityOrdered,
   // Ordered, and the rest.
   List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();
   List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;&gt;();
   List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();
   List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();
   for (String ppName : postProcessorNames) {
      if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
         BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
         priorityOrderedPostProcessors.add(pp);
         if (pp instanceof MergedBeanDefinitionPostProcessor) {
            internalPostProcessors.add(pp);
         }
      }
      else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
         orderedPostProcessorNames.add(ppName);
      }
      else {
         nonOrderedPostProcessorNames.add(ppName);
      }
   }
   // First, register the BeanPostProcessors that implement PriorityOrdered.
   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
   registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);
   // Next, register the BeanPostProcessors that implement Ordered.
   List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();
   for (String ppName : orderedPostProcessorNames) {
      BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
      orderedPostProcessors.add(pp);
      if (pp instanceof MergedBeanDefinitionPostProcessor) {
         internalPostProcessors.add(pp);
      }
   }
   sortPostProcessors(orderedPostProcessors, beanFactory);
   registerBeanPostProcessors(beanFactory, orderedPostProcessors);
   // Now, register all regular BeanPostProcessors.
   List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();
   for (String ppName : nonOrderedPostProcessorNames) {
      BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
      nonOrderedPostProcessors.add(pp);
      if (pp instanceof MergedBeanDefinitionPostProcessor) {
         internalPostProcessors.add(pp);
      }
   }
   registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);
   // Finally, re-register all internal BeanPostProcessors.
   sortPostProcessors(internalPostProcessors, beanFactory);
   registerBeanPostProcessors(beanFactory, internalPostProcessors);
   // Re-register post-processor for detecting inner beans as ApplicationListeners,
   // moving it to the end of the processor chain (for picking up proxies etc).
   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));
}
</code></pre>
<p>上述代码第 11 行：</p>
<pre><code class="language-java">/** 当 Spring 的配置中的后置处理器还没有被注册就已经开始了 bean 的初始化
  * 便会打印出 BeanPostProcessorChecker 中设定的信息
  */
public BeanPostProcessorChecker(ConfigurableListableBeanFactory beanFactory, int beanPostProcessorTargetCount) {
   this.beanFactory = beanFactory;
   this.beanPostProcessorTargetCount = beanPostProcessorTargetCount;
}
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/YVAE0NRT6PKD1ndX__thumbnail.png" alt="图片" loading="lazy"></figure>
<p>当 Spring 的配置中的后置处理器还没有被注册就已经开始了 bean 的初始化，便会打印出 BeanPostProcessorChecker 中设定的信息。</p>
<h2 id="commonannotationbeanpostprocessor">CommonAnnotationBeanPostProcessor</h2>
<p>处理公共注解，比如 @POSTConstructor</p>
<h2 id="autowiredannotationbeanpostprocessor">AutowiredAnnotationBeanPostProcessor</h2>
<p>有没有加 @Autowired，如果加了 @Autowired 注解，就进行处理</p>
<h2 id="requiredannotationbeanpostprocessor">RequiredAnnotationBeanPostProcessor</h2>
<p>如果加了 @Required 注解，就进行处理</p>
<pre><code class="language-java">@Service
public class IndexService {
   private String name;
   public String getName(){
      return name;
   }
   // 必须注入 name，不注入会报异常
   @Required
   public void setName(String name){
      this.name = name;
   }
}
</code></pre>
<p>运行 Test，报错信息如下：<br>
Initialization of bean failed; nested exception is org.springframework.beans.factory.BeanInitializationException: Property 'name' is required for bean 'indexService'</p>
<p>因为@Required 表示 name 是必须的，没有给 IndexService 设置 name，使用后置处理器 RequiredAnnotationBeanPostProcessor 进行处理后结果： IndexService 无法实例化。</p>
<h2 id="annotationawareaspectjautoproxycreator">AnnotationAwareAspectJAutoProxyCreator</h2>
<p>当加入 @EnableAspectJAutoProxy 后，Spring 加入了一个后置处理器 AnnotationAwareAspectJAutoProxyCreator：处理 aop，把一个对象变成代理对象。</p>
<pre><code class="language-java">@ComponentScan(&quot;com.ssm&quot;)
@Configuration
@EnableAspectJAutoProxy
public class AppConfig {
</code></pre>
<pre><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(AspectJAutoProxyRegistrar.class)
public @interface EnableAspectJAutoProxy {
</code></pre>
<pre><code class="language-java">class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar {
   @Override
   public void registerBeanDefinitions(
         AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
      AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);
</code></pre>
<p>上述代码动态加载了一个处理 aop 的后置处理器 AnnotationAwareAspectJAutoProxyCreator 到 BeanDefinitionMap 中。<br>
<img src="https://epitomm.github.io/post-images/AnnotationAwareAspectJAutoProxyCreator.png" alt="图片" loading="lazy"></p>
<p>AnnotationAwareAspectJAutoProxyCreator 间接继承了 BeanPostProcessor，所以它也是一个后置处理器。</p>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/8%E4%B8%AA%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8.png" alt="图片" loading="lazy"></figure>
<p>原来有 7 个后置处理器，注册了一个 AnnotationAwareAspectJAutoProxyCreator 后置处理器后，现在有 8 个后置处理器。</p>
<h2 id="总结">总结</h2>
<ul>
<li>通过 add 添加了 3 个：
<ul>
<li><strong>ApplicationContextAwareProcessor</strong></li>
<li><strong>ApplicationListenerDetector</strong></li>
<li><strong>ImportAwareBeanPostProcessor</strong></li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/add%E6%B7%BB%E5%8A%A0%E4%BA%863%E4%B8%AA%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8.png" alt="图片" loading="lazy"></figure>
<ul>
<li>从 BeanDefinitionMap 中拿出 3个 对象，放到 List 中：String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);
<ul>
<li><strong>AutowiredAnnotationBeanPostProcessor</strong></li>
<li><strong>RequiredAnnotationBeanPostProcessor</strong></li>
<li><strong>CommonAnnotationBeanPostProcessor</strong></li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E4%BB%8Emap%E6%8B%BF%E5%87%BA%E4%BA%863%E4%B8%AA%E5%AF%B9%E8%B1%A1.png" alt="图片" loading="lazy"></figure>
<ul>
<li>通过 add 添加了 1个 真实对象：
<ul>
<li><strong>BeanPostProcessorChecker</strong>：beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/add%E6%B7%BB%E5%8A%A01%E4%B8%AA%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8.png" alt="图片" loading="lazy"></figure>
<ul>
<li>通过 beanFactory 拿出了一个对象：beanFactory.getBean(ppName, BeanPostProcessor.class);
<ul>
<li><strong>AnnotationAwareAspectJAutoProxyCreator</strong>：</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/%E4%BB%8EbeanFactory%E6%8B%BF%E5%87%BA1%E4%B8%AA%E5%AF%B9%E8%B1%A1.png" alt="图片" loading="lazy"></figure>
<h1 id="finishbeanfactoryinitialization">finishBeanFactoryInitialization</h1>
<p>AbstractApplicationContext#refresh() ---&gt; AbstractApplicationContext#finishBeanFactoryInitialization</p>
<pre><code class="language-java">protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
   // Initialize conversion service for this context.
   // CONVERSION_SERVICE_BEAN_NAME：用来转换类型的
   if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;
         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {
      beanFactory.setConversionService(
            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
   }
   // Register a default embedded value resolver if no bean post-processor
   // (such as a PropertyPlaceholderConfigurer bean) registered any before:
   // at this point, primarily for resolution in annotation attribute values.
   // 是否有内置value转换器
   if (!beanFactory.hasEmbeddedValueResolver()) {
      beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));
   }
   // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.
   // LoadTimeWeaverAware ：AspectJ 静态织入的过程
   // AspectJ：编译过程就织入，扩展了JDK编译器
   // Spring：无论用JDK还是CGLIB，都是动态织入，在项目运行过程中织入。
   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
   for (String weaverAwareName : weaverAwareNames) {
      getBean(weaverAwareName);
   }
   // Stop using the temporary ClassLoader for type matching.
   beanFactory.setTempClassLoader(null);
   // Allow for caching all bean definition metadata, not expecting further changes.
   beanFactory.freezeConfiguration();
   // Instantiate all remaining (non-lazy-init) singletons.
   // 到此为止，bean还没有实例化出来，这个方法是实例化单例对象之前要做的事情
   beanFactory.preInstantiateSingletons();
}
</code></pre>
<p>上述代码第 35 行：</p>
<pre><code class="language-java">@Override
public void preInstantiateSingletons() throws BeansException {
   if (logger.isDebugEnabled()) {
      logger.debug(&quot;Pre-instantiating singletons in &quot; + this);
   }
   // Iterate over a copy to allow for init methods which in turn register new bean definitions.
   // While this may not be part of the regular factory bootstrap, it does otherwise work fine.
   List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames);
   // Trigger initialization of all non-lazy singleton beans...
   // beanNames：BeanDefinitionMap中所有类的名字
   for (String beanName : beanNames) {
      // 通过 beanName 得到 BeanDefinition，合并父类 BeanDefinition
      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
      // 如果这个 bd 是非抽象、单例、非懒加载的
      if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) {
         if (isFactoryBean(beanName)) {
            Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
            // 判断这个 bean 是不是 FactoryBean
            if (bean instanceof FactoryBean) {
               final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;
               boolean isEagerInit;
               if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) {
                  isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)
                              ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,
                        getAccessControlContext());
               }
               else {
                  isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;
                        ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());
               }
               if (isEagerInit) {
                  getBean(beanName);
               }
            }
         }
         else {
            getBean(beanName);
         }
      }
   }
   // Trigger post-initialization callback for all applicable beans...
   for (String beanName : beanNames) {
      Object singletonInstance = getSingleton(beanName);
      if (singletonInstance instanceof SmartInitializingSingleton) {
         final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
         if (System.getSecurityManager() != null) {
            AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
               smartSingleton.afterSingletonsInstantiated();
               return null;
            }, getAccessControlContext());
         }
         else {
            smartSingleton.afterSingletonsInstantiated();
         }
      }
   }
}
</code></pre>
<p>上述代码第 39 行：</p>
<pre><code class="language-java">@Override
public Object getBean(String name) throws BeansException {
   return doGetBean(name, null, null, false);
}
</code></pre>
<pre><code class="language-java">protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,
      @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {
   final String beanName = transformedBeanName(name);
   Object bean;
   // Eagerly check singleton cache for manually registered singletons.
   // 先 getSingleton(beanName)，如果拿不到，再去初始化
   Object sharedInstance = getSingleton(beanName);
   if (sharedInstance != null &amp;&amp; args == null) {
      if (logger.isDebugEnabled()) {
         if (isSingletonCurrentlyInCreation(beanName)) {
            logger.debug(&quot;Returning eagerly cached instance of singleton bean '&quot; + beanName +
                  &quot;' that is not fully initialized yet - a consequence of a circular reference&quot;);
         }
         else {
            logger.debug(&quot;Returning cached instance of singleton bean '&quot; + beanName + &quot;'&quot;);
         }
      }
      bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
   }
   else {
      // Fail if we're already creating this bean instance:
      // We're assumably within a circular reference.
      if (isPrototypeCurrentlyInCreation(beanName)) {
         throw new BeanCurrentlyInCreationException(beanName);
      }
      // Check if bean definition exists in this factory.
      // 有没有对 Spring 进行改造
      BeanFactory parentBeanFactory = getParentBeanFactory();
      if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {
         // Not found -&gt; check parent.
         String nameToLookup = originalBeanName(name);
         if (parentBeanFactory instanceof AbstractBeanFactory) {
            return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
                  nameToLookup, requiredType, args, typeCheckOnly);
         }
         else if (args != null) {
            // Delegation to parent with explicit args.
            return (T) parentBeanFactory.getBean(nameToLookup, args);
         }
         else {
            // No args -&gt; delegate to standard getBean method.
            return parentBeanFactory.getBean(nameToLookup, requiredType);
         }
      }
      // 检查
      if (!typeCheckOnly) {
         markBeanAsCreated(beanName);
      }
      try {
         // 拿出 RootBeanDefinition 
         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
         checkMergedBeanDefinition(mbd, beanName, args);
         // Guarantee initialization of beans that the current bean depends on.
         // 判断有没有 DependsOn
         String[] dependsOn = mbd.getDependsOn();
         if (dependsOn != null) {
            for (String dep : dependsOn) {
               if (isDependent(beanName, dep)) {
                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        &quot;Circular depends-on relationship between '&quot; + beanName + &quot;' and '&quot; + dep + &quot;'&quot;);
               }
               registerDependentBean(dep, beanName);
               try {
                  getBean(dep);
               }
               catch (NoSuchBeanDefinitionException ex) {
                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        &quot;'&quot; + beanName + &quot;' depends on missing bean '&quot; + dep + &quot;'&quot;, ex);
               }
            }
         }
         // Create bean instance.
         //
         if (mbd.isSingleton()) {
            sharedInstance = getSingleton(beanName, () -&gt; {
               try {
                  return createBean(beanName, mbd, args);
               }
               catch (BeansException ex) {
                  // Explicitly remove instance from singleton cache: It might have been put there
                  // eagerly by the creation process, to allow for circular reference resolution.
                  // Also remove any beans that received a temporary reference to the bean.
                  destroySingleton(beanName);
                  throw ex;
               }
            });
            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
         }
         else if (mbd.isPrototype()) {
            // It's a prototype -&gt; create a new instance.
            Object prototypeInstance = null;
            try {
               beforePrototypeCreation(beanName);
               prototypeInstance = createBean(beanName, mbd, args);
            }
            finally {
               afterPrototypeCreation(beanName);
            }
            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
         }
         else {
            String scopeName = mbd.getScope();
            final Scope scope = this.scopes.get(scopeName);
            if (scope == null) {
               throw new IllegalStateException(&quot;No Scope registered for scope name '&quot; + scopeName + &quot;'&quot;);
            }
            try {
               Object scopedInstance = scope.get(beanName, () -&gt; {
                  beforePrototypeCreation(beanName);
                  try {
                     return createBean(beanName, mbd, args);
                  }
                  finally {
                     afterPrototypeCreation(beanName);
                  }
               });
               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
            }
            catch (IllegalStateException ex) {
               throw new BeanCreationException(beanName,
                     &quot;Scope '&quot; + scopeName + &quot;' is not active for the current thread; consider &quot; +
                     &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,
                     ex);
            }
         }
      }
      catch (BeansException ex) {
         cleanupAfterBeanCreationFailure(beanName);
         throw ex;
      }
   }
   // Check if required type matches the type of the actual bean instance.
   if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) {
      try {
         T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
         if (convertedBean == null) {
            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
         }
         return convertedBean;
      }
      catch (TypeMismatchException ex) {
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Failed to convert bean '&quot; + name + &quot;' to required type '&quot; +
                  ClassUtils.getQualifiedName(requiredType) + &quot;'&quot;, ex);
         }
         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
      }
   }
   return (T) bean;
}
</code></pre>
<p>上述代码第 84 行：</p>
<pre><code class="language-java">public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {
   Assert.notNull(beanName, &quot;Bean name must not be null&quot;);
   synchronized (this.singletonObjects) {
      // 从SpringIOC容器中拿出 key=orderDaoAImpl，因为还未被实例化，所以 singletonObject=null
      Object singletonObject = this.singletonObjects.get(beanName);
      if (singletonObject == null) {
         if (this.singletonsCurrentlyInDestruction) {
            throw new BeanCreationNotAllowedException(beanName,
                  &quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot; +
                  &quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;);
         }
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Creating shared instance of singleton bean '&quot; + beanName + &quot;'&quot;);
         }
         beforeSingletonCreation(beanName);
         boolean newSingleton = false;
         boolean recordSuppressedExceptions = (this.suppressedExceptions == null);
         if (recordSuppressedExceptions) {
            this.suppressedExceptions = new LinkedHashSet&lt;&gt;();
         }
         try {
            // 执行完这行代码，OrderDaoAImpl对象被创建出来了
            singletonObject = singletonFactory.getObject();
            newSingleton = true;
         }
         catch (IllegalStateException ex) {
            // Has the singleton object implicitly appeared in the meantime -&gt;
            // if yes, proceed with it since the exception indicates that state.
            singletonObject = this.singletonObjects.get(beanName);
            if (singletonObject == null) {
               throw ex;
            }
         }
         catch (BeanCreationException ex) {
            if (recordSuppressedExceptions) {
               for (Exception suppressedException : this.suppressedExceptions) {
                  ex.addRelatedCause(suppressedException);
               }
            }
            throw ex;
         }
         finally {
            if (recordSuppressedExceptions) {
               this.suppressedExceptions = null;
            }
            afterSingletonCreation(beanName);
         }
         if (newSingleton) {
            addSingleton(beanName, singletonObject);
         }
      }
      return singletonObject;
   }
}
</code></pre>
<p>上述代码第 4 行：SpringIOC容器 singletonObjects</p>
<pre><code class="language-java">private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);
</code></pre>
<p>上述代码第 23 行：<br>
<img src="https://epitomm.github.io/post-images/zjTYCzGjuFjMmnDr.png" alt="图片" loading="lazy"></p>
<p>OrderDaoAImpl 对象被创建出来后，已经是一个代理对象了，应该是一个原生对象 -&gt; 后置处理器 -&gt; 代理对象，所以后置处理器在 singletonFactory.getObject(); 已经被执行了，所以才能产生一个代理对象。看是怎样执行后置处理器的？</p>
<pre><code class="language-java">singletonObject = singletonFactory.getObject();
</code></pre>
<p>singletonFactory 是作为参数传递过来的：<br>
DefaultSingletonBeanRegistry#getSingleton</p>
<pre><code class="language-java">public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {
</code></pre>
<p>于是查看调用链，传过来的参数是一个匿名内部类，如下所示：<br>
AbstractBeanFactory#doGetBean</p>
<pre><code class="language-java">sharedInstance = getSingleton(beanName, () -&gt; {
   try {
      return createBean(beanName, mbd, args);
   }
   catch (BeansException ex) {
      // Explicitly remove instance from singleton cache: It might have been put there
      // eagerly by the creation process, to allow for circular reference resolution.
      // Also remove any beans that received a temporary reference to the bean.
      destroySingleton(beanName);
      throw ex;
   }
});
</code></pre>
<p>上述代码第 3 行：</p>
<pre><code class="language-java">protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
      throws BeanCreationException {
   if (logger.isDebugEnabled()) {
      logger.debug(&quot;Creating instance of bean '&quot; + beanName + &quot;'&quot;);
   }
   RootBeanDefinition mbdToUse = mbd;
   // Make sure bean class is actually resolved at this point, and
   // clone the bean definition in case of a dynamically resolved Class
   // which cannot be stored in the shared merged bean definition.
   // 属性值的赋值：拿到一些属性值，通过 Spring 给它的值：bd.setPropertyValues(&quot;xxx&quot;)，这里就能拿到 xxx 
   // 如何给属性赋值：外部写代码赋值；通过 Spring 的 BeanDefinition 给它赋值。
   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);
   if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) {
      mbdToUse = new RootBeanDefinition(mbd);
      mbdToUse.setBeanClass(resolvedClass);
   }
   // Prepare method overrides.
   try {
      mbdToUse.prepareMethodOverrides();
   }
   catch (BeanDefinitionValidationException ex) {
      throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),
            beanName, &quot;Validation of method overrides failed&quot;, ex);
   }
   try {
      // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
      if (bean != null) {
         return bean;
      }
   }
   catch (Throwable ex) {
      throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,
            &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);
   }
   try {
      Object beanInstance = doCreateBean(beanName, mbdToUse, args);
      if (logger.isDebugEnabled()) {
         logger.debug(&quot;Finished creating instance of bean '&quot; + beanName + &quot;'&quot;);
      }
      return beanInstance;
   }
   catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {
      // A previously detected exception with proper bean creation context already,
      // or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.
      throw ex;
   }
   catch (Throwable ex) {
      throw new BeanCreationException(
            mbdToUse.getResourceDescription(), beanName, &quot;Unexpected exception during bean creation&quot;, ex);
   }
}
</code></pre>
<p>上述代码第 42 行：</p>
<pre><code class="language-java">Object beanInstance = doCreateBean(beanName, mbdToUse, args);
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/kacCBa8WLRfTCTOO.png" alt="图片" loading="lazy"></figure>
<pre><code class="language-java">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
      throws BeanCreationException {
   // Instantiate the bean.
   // BeanWrapper：Bean的包装
   BeanWrapper instanceWrapper = null;
   if (mbd.isSingleton()) {
      instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
   }
   if (instanceWrapper == null) {
      instanceWrapper = createBeanInstance(beanName, mbd, args);
   }
   // 拿到原生对象 OrderDaoAImpl，而不是代理
   final Object bean = instanceWrapper.getWrappedInstance();
   Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();
   if (beanType != NullBean.class) {
      mbd.resolvedTargetType = beanType;
   }
   // Allow post-processors to modify the merged bean definition.
   synchronized (mbd.postProcessingLock) {
      if (!mbd.postProcessed) {
         try {
            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
         }
         catch (Throwable ex) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                  &quot;Post-processing of merged bean definition failed&quot;, ex);
         }
         mbd.postProcessed = true;
      }
   }
   // Eagerly cache singletons to be able to resolve circular references
   // even when triggered by lifecycle interfaces like BeanFactoryAware.
   boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;
         isSingletonCurrentlyInCreation(beanName));
   if (earlySingletonExposure) {
      if (logger.isDebugEnabled()) {
         logger.debug(&quot;Eagerly caching bean '&quot; + beanName +
               &quot;' to allow for resolving potential circular references&quot;);
      }
      addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));
   }
   // Initialize the bean instance.
   Object exposedObject = bean;
   try {
      // 这个方法是用来赋值属性的
      populateBean(beanName, mbd, instanceWrapper);
      exposedObject = initializeBean(beanName, exposedObject, mbd);
   }
   catch (Throwable ex) {
      if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {
         throw (BeanCreationException) ex;
      }
      else {
         throw new BeanCreationException(
               mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);
      }
   }
   if (earlySingletonExposure) {
      Object earlySingletonReference = getSingleton(beanName, false);
      if (earlySingletonReference != null) {
         if (exposedObject == bean) {
            exposedObject = earlySingletonReference;
         }
         else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {
            String[] dependentBeans = getDependentBeans(beanName);
            Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);
            for (String dependentBean : dependentBeans) {
               if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                  actualDependentBeans.add(dependentBean);
               }
            }
            if (!actualDependentBeans.isEmpty()) {
               throw new BeanCurrentlyInCreationException(beanName,
                     &quot;Bean with name '&quot; + beanName + &quot;' has been injected into other beans [&quot; +
                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
                     &quot;] in its raw version as part of a circular reference, but has eventually been &quot; +
                     &quot;wrapped. This means that said other beans do not use the final version of the &quot; +
                     &quot;bean. This is often the result of over-eager type matching - consider using &quot; +
                     &quot;'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.&quot;);
            }
         }
      }
   }
   // Register bean as disposable.
   try {
      registerDisposableBeanIfNecessary(beanName, bean, mbd);
   }
   catch (BeanDefinitionValidationException ex) {
      throw new BeanCreationException(
            mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);
   }
   return exposedObject;
}
</code></pre>
<p>上述代码第 6 行的 BeanWrapper：</p>
<pre><code class="language-java">public interface BeanWrapper extends ConfigurablePropertyAccessor {
   /**
    * Return the bean instance wrapped by this object.
    */ 
   // 真实对象被 BeanWrapper 包装了，此方法可返回真实对象
   Object getWrappedInstance();
   /**
    * Obtain the PropertyDescriptors for the wrapped object
    * (as determined by standard JavaBeans introspection).
    * @return the PropertyDescriptors for the wrapped object
    */
    // 拿到当前类所有set方法以及属性
    PropertyDescriptor[] getPropertyDescriptors();
</code></pre>
<p>MyBatis 中通过 PropertyDescriptiors 拿到 DaoSupport 中所有的 set 方法，如果用 Bena 去拿就拿不到，因为 Bean 没有这个 getPropertyDescriptors() 方法.<br>
上述代码第 14 行：</p>
<pre><code class="language-java">final Object bean = instanceWrapper.getWrappedInstance();
</code></pre>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/pP3vXT3NuPdFl10t.png" alt="图片" loading="lazy"></figure>
<p>上述代码第 51 行：</p>
<pre><code class="language-java">exposedObject = initializeBean(beanName, exposedObject, mbd);
</code></pre>
<p><img src="https://epitomm.github.io/post-images/Usp0Jdaj4VUS2rCE.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/f84P5zIwXEOHdDAR__thumbnail.png" alt="图片" loading="lazy"></p>
<p>当执行完 initializeBean 方法后，原生对象变成了代理对象，因此产生代理对象的逻辑（后置处理器的执行）是在 initializeBean 方法内。</p>
<pre><code class="language-java">protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {
   if (System.getSecurityManager() != null) {
      AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
         invokeAwareMethods(beanName, bean);
         return null;
      }, getAccessControlContext());
   }
   else {
      invokeAwareMethods(beanName, bean);
   }
   Object wrappedBean = bean;
   if (mbd == null || !mbd.isSynthetic()) {
      // 执行所有的 BeanPostProcessor 的 postProcessBeforeInitialization 方法
      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
   }
   try {
      invokeInitMethods(beanName, wrappedBean, mbd);
   }
   catch (Throwable ex) {
      throw new BeanCreationException(
            (mbd != null ? mbd.getResourceDescription() : null),
            beanName, &quot;Invocation of init method failed&quot;, ex);
   }
   if (mbd == null || !mbd.isSynthetic()) {
      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
   }
   return wrappedBean;
}
</code></pre>
<p>上述代码第 1 行参数：</p>
<pre><code class="language-java">protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) 
</code></pre>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/ccXowFCJVQJC5Or9__thumbnail.png" alt="图片" loading="lazy"></figure>
<p>上述代码第 30 行：</p>
<pre><code class="language-java">protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) 
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/7a47oIqK7YxjiLdA.png" alt="图片" loading="lazy"></figure>
<p>传进来的参数是原生对象，最终返回的是代理对象，于是得出结果：把原生对象变为代理对象的逻辑就在这个方法内。</p>
<p>上述代码第 15 行：</p>
<pre><code class="language-java">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
</code></pre>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/31119MWEqBNxDpOJ__thumbnail.png" alt="图片" loading="lazy"></figure>
<p>上述代码第 27 行：</p>
<pre><code class="language-java">wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
</code></pre>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/DJ2g1jLeAfvnxmEu.png" alt="图片" loading="lazy"></figure>
<pre><code class="language-java">public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)
      throws BeansException {
   Object result = existingBean;
   for (BeanPostProcessor processor : getBeanPostProcessors()) {
      Object current = processor.postProcessAfterInitialization(result, beanName);
      if (current == null) {
         return result;
      }
      result = current;
   }
   return result;
} 
</code></pre>
<p><img src="https://epitomm.github.io/post-images/41Nr3cCPIIdWbJkZ.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/LNrUMvC84nYPM5g2.png" alt="图片" loading="lazy"></p>
<p>所以是在 processor.postProcessAfterInitialization(result, beanName); 方法内将原生对象变成了代理对象：AbstractAutoProxyCreator#postProcessAfterInitialization</p>
<pre><code class="language-java">public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) throws BeansException {
   if (bean != null) {
      Object cacheKey = getCacheKey(bean.getClass(), beanName);
      if (!this.earlyProxyReferences.contains(cacheKey)) {
         return wrapIfNecessary(bean, beanName, cacheKey);
      }
   }
   return bean;
}
</code></pre>
<p>上述代码第 5 行：</p>
<pre><code class="language-java">protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {
   if (StringUtils.hasLength(beanName) &amp;&amp; this.targetSourcedBeans.contains(beanName)) {
      return bean;
   }
   if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {
      return bean;
   }
   if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {
      this.advisedBeans.put(cacheKey, Boolean.FALSE);
      return bean;
   }
   // Create proxy if we have advice.
   // 解析所有配置的切面，看这个类是否符合切点描述的，如果符合就加上拦截器
   Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);
   if (specificInterceptors != DO_NOT_PROXY) {
      this.advisedBeans.put(cacheKey, Boolean.TRUE);
      Object proxy = createProxy(
            bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
      this.proxyTypes.put(cacheKey, proxy.getClass());
      return proxy;
   }
   this.advisedBeans.put(cacheKey, Boolean.FALSE);
   return bean;
}
</code></pre>
<p>上述代码第 18 行：</p>
<pre><code class="language-java">protected Object createProxy(Class&lt;?&gt; beanClass, @Nullable String beanName,
      @Nullable Object[] specificInterceptors, TargetSource targetSource) {
   if (this.beanFactory instanceof ConfigurableListableBeanFactory) {
      AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);
   }
   ProxyFactory proxyFactory = new ProxyFactory();
   proxyFactory.copyFrom(this);
   if (!proxyFactory.isProxyTargetClass()) {
      if (shouldProxyTargetClass(beanClass, beanName)) {
         proxyFactory.setProxyTargetClass(true);
      }
      else {
         evaluateProxyInterfaces(beanClass, proxyFactory);
      }
   }
   Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);
   proxyFactory.addAdvisors(advisors);
   proxyFactory.setTargetSource(targetSource);
   customizeProxyFactory(proxyFactory);
   proxyFactory.setFrozen(this.freezeProxy);
   if (advisorsPreFiltered()) {
      proxyFactory.setPreFiltered(true);
   }
   return proxyFactory.getProxy(getProxyClassLoader());
}
</code></pre>
<p>上述代码第 30 行：</p>
<pre><code class="language-java">public Object getProxy(@Nullable ClassLoader classLoader) {
   return createAopProxy().getProxy(classLoader);
}
</code></pre>
<pre><code class="language-java">protected final synchronized AopProxy createAopProxy() {
   if (!this.active) {
      activate();
   }
   return getAopProxyFactory().createAopProxy(this);
}
</code></pre>
<pre><code class="language-java">public Object getProxy(@Nullable ClassLoader classLoader) {
   return createAopProxy().getProxy(classLoader);
}
</code></pre>
<pre><code class="language-java">public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException { 
   if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {
      Class&lt;?&gt; targetClass = config.getTargetClass();
      if (targetClass == null) {
         throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +
               &quot;Either an interface or a target is required for proxy creation.&quot;);
      }
      if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
         return new JdkDynamicAopProxy(config);
      }
      return new ObjenesisCglibAopProxy(config);
   }
   else {
      // 创建一个 JDK 动态代理返回
      return new JdkDynamicAopProxy(config);
   }
}
</code></pre>
<p>先看第 2 行代码的判断：</p>
<pre><code>if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {
</code></pre>
<p>第一个条件：config.isOptimize()：可以在 xml 中配置 optimize，如果不配置默认 optimize=false;<br>
<img src="https://epitomm.github.io/post-images/xPRuOoTpWagSzEsK.png" alt="图片" loading="lazy"></p>
<pre><code class="language-java">public class ProxyConfig implements Serializable {
   private boolean proxyTargetClass = false;
   private boolean optimize = false;
</code></pre>
<p>第二个条件：config.isProxyTargetClass(); proxyTargetClass 默认值也为 false。<br>
创建一个 JDK 动态代理后返回，沿着调用链 到 ProxyFactory#getProxy</p>
<pre><code class="language-java">public Object getProxy(@Nullable ClassLoader classLoader) {
   return createAopProxy().getProxy(classLoader);
}
</code></pre>
<p>接下来进入 getProxy 方法：</p>
<pre><code class="language-java">public Object getProxy(@Nullable ClassLoader classLoader) {
   if (logger.isDebugEnabled()) {
      logger.debug(&quot;Creating JDK dynamic proxy: target source is &quot; + this.advised.getTargetSource());
   }
   Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);
   findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);
   // 动态代理创建代理对象 
   return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);
}
</code></pre>
<p>总结：<br>
bean new出来 --&gt; BeanPostProcessor --&gt; doCreateBean() --&gt; BeanWrapper --&gt; beanWrapper.getBean() --&gt; for(8个后置处理器)</p>
<h1 id="spring-如何处理-aop">Spring 如何处理 AOP？</h1>
<ul>
<li>在后置处理器 AnnotationAwareAspectJAutoProxyCreator 内处理</li>
</ul>
<p>AbstractApplicationContext#refresh() --&gt; AbstractApplicationContext#registerBeanPostProcessors(beanFactory); --&gt; 如果添加了 @EnableAspectJAutoProxy注解，就会利用 ImportBeanDefinitionRegistrar 动态注册一个后置处理器 AnnotationAwareAspectJAutoProxyCreator，完成代理。</p>
<h2 id="后置处理器在哪里处理">后置处理器在哪里处理</h2>
<p>AbstractApplicationContext#refresh() --&gt; AbstractApplicationContext#finishBeanFactoryInitialization(beanFactory); --&gt; DefaultListableBeanFactory#preInstantiateSingletons --&gt; AbstractBeanFactory#getBean --&gt; AbstractBeanFactory#doGetBean --&gt; AbstractAutowireCapableBeanFactory#createBean --&gt; AbstractAutowireCapableBeanFactory#doCreateBean：实例化BeanWrapper，然后通过 BeanWrapper 拿到原始对象 --&gt; AbstractAutowireCapableBeanFactory#initializeBean：执行后置处理器，将原始对象变为代理对象，aop就是在这里完成的代理 --&gt; applyBeanPostProcessorsAfterInitialization：执行后置处理器的 after 方法</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MyBatis系列（三）MyBatis源码]]></title>
        <id>https://epitomm.github.io/post/mybatis-xi-lie-san-mybatis-huan-cun/</id>
        <link href="https://epitomm.github.io/post/mybatis-xi-lie-san-mybatis-huan-cun/">
        </link>
        <updated>2020-05-24T13:59:58.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-java">public interface IndexMapper {
    public void query();
}
</code></pre>
<h1 id="执行代理对象的-invoke-方法">执行代理对象的 invoke 方法</h1>
<p>动态代理为接口生成代理对象时，为什么会执行 invoke() 方法？</p>
<pre><code class="language-java"> public class Test {
    public static void main(String[] args) throws IOException {
        AnnotationConfigApplicationContext configApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
        byte[] bytes = ProxyGenerator.generateProxyClass(&quot;mapper&quot;, new Class[]{IndexMapper.class});
        FileOutputStream fw = new FileOutputStream(&quot;C:\\Users\\Only\\IdeaProjects\\luban\\mapper.class&quot;);
        fw.write(bytes);
        fw.flush();
        fw.close();
    }
}
</code></pre>
<p>生成的代理类：</p>
<pre><code class="language-java">public final class mapper extends Proxy implements IndexMapper {
    private static Method m1;
    private static Method m3;
    private static Method m2;
    private static Method m0;
    public mapper(InvocationHandler var1) throws  {
        super(var1);
    }
    public final boolean equals(Object var1) throws  {
        try {
            return (Boolean)super.h.invoke(this, m1, new Object[]{var1});
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }
    public final void query() throws  {
        try {
            super.h.invoke(this, m3, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }
    public final String toString() throws  {
        try {
            return (String)super.h.invoke(this, m2, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }
    public final int hashCode() throws  {
        try {
            return (Integer)super.h.invoke(this, m0, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }
    static {
        try {
            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));
            m3 = Class.forName(&quot;com.ssm.service.IndexMapper&quot;).getMethod(&quot;query&quot;);
            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;);
            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;);
        } catch (NoSuchMethodException var2) {
            throw new NoSuchMethodError(var2.getMessage());
        } catch (ClassNotFoundException var3) {
            throw new NoClassDefFoundError(var3.getMessage());
        }
    }
}
</code></pre>
<p>当调用接口的 query() 时，实际执行的是代理对象的 query() 方法：</p>
<pre><code class="language-java">super.h.invoke(this, m3, (Object[])null);
</code></pre>
<p>在代理对象的 query() 方法中调用了 “实现了 InvocationHandler 接口的类” 的 invoke() 方法。</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws IOException {
        AnnotationConfigApplicationContext configApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
        configApplicationContext.getBean(IndexService.class).list();
    }
}
</code></pre>
<p>当调用 Service 中的 list() 方法时，会调用 mapper 的 list() 方法，实际调用的是 mapper 的代理对象的 list() 方法，即 实现了 InvocationHandler 接口的类的 invoke() 方法</p>
<pre><code class="language-java">@Service
public class IndexService implements InitializingBean {
    @Autowired
    UserMapper userMapper;
    public List&lt;Map&lt;String,Object&gt;&gt; list(){
        return userMapper.list();
    }
    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println(&quot;app...&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public interface UserMapper {
    @Select(&quot;select * from t1&quot;)
    List&lt;Map&lt;String,Object&gt;&gt; list();
}
</code></pre>
<p>调用 Mapper 代理对象：MapperProxy 的 invoke() 方法：</p>
<pre><code class="language-java">public class MapperProxy&lt;T&gt; implements InvocationHandler, Serializable {
  //...
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    try {
      if (Object.class.equals(method.getDeclaringClass())) {
        return method.invoke(this, args);
      } else if (isDefaultMethod(method)) {
        return invokeDefaultMethod(proxy, method, args);
      }
    } catch (Throwable t) {
      throw ExceptionUtil.unwrapThrowable(t);
    }
    // MapperMethod 包含了当前方法，比如 list() 的所有信息：注解
    final MapperMethod mapperMethod = cachedMapperMethod(method);
    // 在 spring 中，当产生代理对象时，sqlSession 已经被替换成了 SqlSessionTemplate 
    return mapperMethod.execute(sqlSession, args);
  }
  //...
}
</code></pre>
<p>execute() 方法判断当前注解是什么类型操作：增、删、改、查</p>
<pre><code class="language-java">public Object execute(SqlSession sqlSession, Object[] args) {
  Object result;
  switch (command.getType()) {
    case INSERT: {
    Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.insert(command.getName(), param));
      break;
    }
    case UPDATE: {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.update(command.getName(), param));
      break;
    }
    case DELETE: {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.delete(command.getName(), param));
      break;
    }
    case SELECT:
      if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) {
        executeWithResultHandler(sqlSession, args);
        result = null;
      } else if (method.returnsMany()) {
        // SELECT 返回结果有多条，执行此方法
        result = executeForMany(sqlSession, args);
      } else if (method.returnsMap()) {
        result = executeForMap(sqlSession, args);
      } else if (method.returnsCursor()) {
        result = executeForCursor(sqlSession, args);
      } else {
        Object param = method.convertArgsToSqlCommandParam(args);
        result = sqlSession.selectOne(command.getName(), param);
      }
      break;
    case FLUSH:
      result = sqlSession.flushStatements();
      break;
    default:
      throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());
  }
  if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) {
    throw new BindingException(&quot;Mapper method '&quot; + command.getName() 
        + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);
  }
  return result;
}
</code></pre>
<pre><code class="language-java">private &lt;E&gt; Object executeForMany(SqlSession sqlSession, Object[] args) {
  List&lt;E&gt; result;
  Object param = method.convertArgsToSqlCommandParam(args);
  if (method.hasRowBounds()) {
    RowBounds rowBounds = method.extractRowBounds(args);
    result = sqlSession.&lt;E&gt;selectList(command.getName(), param, rowBounds);
  } else {
    // 调用 sqlSession 的 selectList 方法
    result = sqlSession.&lt;E&gt;selectList(command.getName(), param);
  }
  // issue #510 Collections &amp; arrays support
  if (!method.getReturnType().isAssignableFrom(result.getClass())) {
    if (method.getReturnType().isArray()) {
      return convertToArray(result);
    } else {
      return convertToDeclaredCollection(sqlSession.getConfiguration(), result);
    }
  }
  return result;
}
</code></pre>
<p>如果使用 Spring，sqlSession 就是 SqlSessionTemplate 类型；如果不使用 Spring，单独使用 MyBatis，sqlSession 就是 DefaultSqlSession 类型。</p>
<h1 id="defaultsqlsession">DefaultSqlSession</h1>
<p>DefaultSqlSession#selectList</p>
<pre><code class="language-java">public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) {
  try {
    MappedStatement ms = configuration.getMappedStatement(statement);
    // 直接用 executor 执行 query 方法
    return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
  } catch (Exception e) {
    throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);
  } finally {
    ErrorContext.instance().reset();
  }
}
</code></pre>
<h1 id="sqlsessiontemplate">SqlSessionTemplate</h1>
<p>SqlSessionTemplate#selectList</p>
<pre><code class="language-java">public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) {
  // 调用代理对象的 selectList
  return this.sqlSessionProxy.&lt;E&gt; selectList(statement, parameter);
}
</code></pre>
<p>MapperProxy 的 invoke() 方法中的 sqlSession 已经被替换成了 SqlSessionTemplate，但它具体是在什么时候被替换的现在还不知道。<br>
SqlSessionTemplate 肯定会被赋值给 sqlSession，但是具体什么时候赋值的不知道，于是看它什么时候被实例化，于是断点在 SqlSessionTemplate 实例化的地方进行调试。</p>
<pre><code class="language-java">public SqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
  this(sqlSessionFactory, sqlSessionFactory.getConfiguration().getDefaultExecutorType());
}
</code></pre>
<pre><code class="language-java">public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) {
  if (!this.externalSqlSession) {
    this.sqlSession = new SqlSessionTemplate(sqlSessionFactory);
  }
}
</code></pre>
<p>沿着 setSqlSessionFactory 的调用链向下找发现了：AbstractAutowireCapableBeanFactory#doCreateBean</p>
<pre><code class="language-java">populateBean(beanName, mbd, instanceWrapper);
</code></pre>
<p>在创建 UserMapper 时实例化了 sqlSessionFactory</p>
<h1 id="哪些属性需要自动装配">哪些属性需要自动装配？</h1>
<p>Spring 当中有自动装配，当创建 MapperFactoryBean 时，要看这个类里面的属性是否需要自动装配：</p>
<pre><code class="language-java">public class MapperFactoryBean&lt;T&gt; extends SqlSessionDaoSupport implements FactoryBean&lt;T&gt; {
  // mapperInterface 不需要自动装配 ，因为自动装配忽略 Class 类型
  private Class&lt;T&gt; mapperInterface;
  // addToConfig 需要自动装配
  private boolean addToConfig = true;
  
  public void setAddToConfig(boolean addToConfig) {
    this.addToConfig = addToConfig;
  }
}
</code></pre>
<p>它的父类 SqlSessionDaoSupport 中的属性是否需要自动装配：</p>
<pre><code class="language-java">public abstract class SqlSessionDaoSupport extends DaoSupport {
  // 不需要自动装配，因为没有对应的 set 方法
  private SqlSession sqlSession;
  // 不需要自动装配，因为没有对应的 set 方法
  private boolean externalSqlSession;
  // sqlSessionFactory 需要自动装配，因为有 set 方法
  public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) {
    if (!this.externalSqlSession) {
      this.sqlSession = new SqlSessionTemplate(sqlSessionFactory);
    }
  }
  // sqlSessionTemplate 需要自动装配，因为有 set 方法
  public void setSqlSessionTemplate(SqlSessionTemplate sqlSessionTemplate) {
    this.sqlSession = sqlSessionTemplate;
    this.externalSqlSession = true;
  }
  //......
}
</code></pre>
<p>sqlSessionFactory 和 sqlSessionTemplate 由于有 set 方法，所以需要自动装配。<br>
Spring 在创建 IndexService 时，发现它依赖了 UserMapper：</p>
<pre><code class="language-java">@Service
public class IndexService implements InitializingBean {
    @Autowired
    UserMapper userMapper;
</code></pre>
<p>于是就去创建 UserMapper，发现 MapperFactoryBean 中有很多依赖，然后决定是否注入这些依赖。<br>
断点在：</p>
<pre><code class="language-java">public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) {
  if (!this.externalSqlSession) {
    this.sqlSession = new SqlSessionTemplate(sqlSessionFactory);
  }
}
</code></pre>
<p>调用链如下：<br>
<img src="https://epitomm.github.io/post-images/setSqlSessionFactory%E8%B0%83%E7%94%A8%E9%93%BE.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AF%BB%E5%8F%96indexService.png" alt="图片" loading="lazy"></p>
<p>populateBean 用来设置类的属性的，发现 IndexService 类中有一个属性 UserMapper，于是就去创建 UserMapper</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/indexService%E6%9C%89%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7UserMapper.png" alt="图片" loading="lazy"></figure>
<p>当自动装配时，如果属性的类型是 Class 的直接忽略</p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E6%8B%BF%E5%88%B0%E4%B9%8B%E5%89%8D%E6%B7%BB%E5%8A%A0%E7%9A%84addToConfig.png" alt="图片" loading="lazy"></figure>
<p>类中的属性如何拿到？</p>
<pre><code class="language-java">protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) {
   PropertyValues pvs = mbd.getPropertyValues();
   if (bw == null) {
      if (!pvs.isEmpty()) {
         throw new BeanCreationException(
               mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;);
      }
      else {
         // Skip property population phase for null instance.
         return;
      }
   }
   // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the
   // state of the bean before properties are set. This can be used, for example,
   // to support styles of field injection.
   boolean continueWithPropertyPopulation = true;
   if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {
      for (BeanPostProcessor bp : getBeanPostProcessors()) {
         if (bp instanceof InstantiationAwareBeanPostProcessor) {
            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
            if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
               continueWithPropertyPopulation = false;
               break;
            }
         }
      }
   }
   if (!continueWithPropertyPopulation) {
      return;
   }
    
   // 拿出当前对象自动注入的模型，如果是 BY_NAME 或 BY_TYPE，才会进入这个 if 分支
   if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||
         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
      //  用原来的 pvs 定义一个新的 newPvs
      MutablePropertyValues newPvs = new MutablePropertyValues(pvs);
      // Add property values based on autowire by name if applicable.
      if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {
         autowireByName(beanName, mbd, bw, newPvs);
      }
      // Add property values based on autowire by type if applicable.
      if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
         autowireByType(beanName, mbd, bw, newPvs);
      }
      pvs = newPvs;
   }
   boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
   boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);
   if (hasInstAwareBpps || needsDepCheck) {
      PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
      if (hasInstAwareBpps) {
         for (BeanPostProcessor bp : getBeanPostProcessors()) {
            if (bp instanceof InstantiationAwareBeanPostProcessor) {
               InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
               pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
               if (pvs == null) {
                  return;
               }
            }
         }
      }
      if (needsDepCheck) {
         checkDependencies(beanName, mbd, filteredPds, pvs);
      }
   }
   applyPropertyValues(beanName, mbd, bw, pvs);
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/newPvs.png" alt="图片" loading="lazy"></figure>
<p>所以分析是上面的 autowireByType 注入了 sqlSessionFactory 属性</p>
<pre><code class="language-java">protected void autowireByType(
      String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {
   TypeConverter converter = getCustomTypeConverter();
   if (converter == null) {
      converter = bw;
   }
   Set&lt;String&gt; autowiredBeanNames = new LinkedHashSet&lt;String&gt;(4);
   String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);
   for (String propertyName : propertyNames) {
      try {
         PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);
         // Don't try autowiring by type for type Object: never makes sense,
         // even if it technically is a unsatisfied, non-simple property.
         if (Object.class != pd.getPropertyType()) {
            MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);
            // Do not allow eager init for type matching in case of a prioritized post-processor.
            boolean eager = !PriorityOrdered.class.isAssignableFrom(bw.getWrappedClass());
            DependencyDescriptor desc = new AutowireByTypeDependencyDescriptor(methodParam, eager);
            Object autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);
            if (autowiredArgument != null) {
               pvs.add(propertyName, autowiredArgument);
            }
            for (String autowiredBeanName : autowiredBeanNames) {
               registerDependentBean(autowiredBeanName, beanName);
               if (logger.isDebugEnabled()) {
                  logger.debug(&quot;Autowiring by type from bean name '&quot; + beanName + &quot;' via property '&quot; +
                        propertyName + &quot;' to bean named '&quot; + autowiredBeanName + &quot;'&quot;);
               }
            }
            autowiredBeanNames.clear();
         }
      }
      catch (BeansException ex) {
         throw new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);
      }
   }
}
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/propertyNames.png" alt="图片" loading="lazy"></figure>
<p>字符串中有两个值，addToConfig 已经被包含了，mapperInterface 是 Class 不注入，所以共有 sqlSessionFactory 和 sqlSessionTemplate 两个属性。</p>
<p>接下来看 unsatisfiedNonSimpleProperties 方法是如何得到这两个值的？</p>
<pre><code class="language-java">protected String[] unsatisfiedNonSimpleProperties(AbstractBeanDefinition mbd, BeanWrapper bw) {
   Set&lt;String&gt; result = new TreeSet&lt;String&gt;();
   PropertyValues pvs = mbd.getPropertyValues();
   // PropertyDescriptor 属性描述器：拿出所有的属性
   PropertyDescriptor[] pds = bw.getPropertyDescriptors();
   for (PropertyDescriptor pd : pds) {
      if (pd.getWriteMethod() != null &amp;&amp; !isExcludedFromDependencyCheck(pd) &amp;&amp; !pvs.contains(pd.getName()) &amp;&amp;
            !BeanUtils.isSimpleProperty(pd.getPropertyType())) {
         result.add(pd.getName());
      }
   }
   return StringUtils.toStringArray(result);
}
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/pds%E6%8B%BF%E5%87%BA%E6%89%80%E6%9C%89%E7%9A%84%E5%B1%9E%E6%80%A7.png" alt="图片" loading="lazy"></figure>
<h2 id="spring-如何判断一个类是一个属性">Spring 如何判断一个类是一个属性</h2>
<p>readMethod：有 get 方法就认为这是一个属性；writeMethod：有 set 方法就认为这是一个属性</p>
<h3 id="addtoconfig">addToConfig</h3>
<ul>
<li>因为 MapperFactoryBean 类中有这个属性<br>
<img src="https://epitomm.github.io/post-images/pds_addToConfig.png" alt="图片" loading="lazy"></li>
</ul>
<h3 id="class">class</h3>
<p>为什么会有一个 class 属性？任意一个对象都可以 xxx.getClass()，所以认为 class 是一个属性<br>
<img src="https://epitomm.github.io/post-images/pds_class.png" alt="图片" loading="lazy"></p>
<h3 id="mapperinterface">mapperInterface</h3>
<ul>
<li>因为 MapperFactoryBean 类中有这个属性<br>
<img src="https://epitomm.github.io/post-images/pds_mapperInterface.png" alt="图片" loading="lazy"></li>
</ul>
<h3 id="object">object</h3>
<ul>
<li>MapperFactoryBean  是一个 FactoryBean，Bean 当中都有一个 getObject() 方法，因为有 getObject() 方法，所以认为 object 是一个属性<br>
<img src="https://epitomm.github.io/post-images/pds_object.png" alt="图片" loading="lazy"></li>
</ul>
<h3 id="objecttype">objectType</h3>
<ul>
<li>因为有 getObjectType() 方法，所以任务 objectType 是一个属性<br>
<img src="https://epitomm.github.io/post-images/pds_objectType.png" alt="图片" loading="lazy"></li>
</ul>
<h3 id="single">single</h3>
<ul>
<li>boolean flag; 默认将 getFlag() 改成 isFlag()，因为有 isFlag() 属性，所以认为 singleton 是一个属性。<br>
<img src="https://epitomm.github.io/post-images/pds_singleton.png" alt="图片" loading="lazy"></li>
</ul>
<h3 id="sqlsession">sqlSession</h3>
<ul>
<li>因为 SqlSessionDaoSupport 中有 getSqlSession(); 所以认为 sqlSession 是一个属性。<br>
<img src="https://epitomm.github.io/post-images/pds_sqlSession.png" alt="图片" loading="lazy"></li>
</ul>
<h3 id="sqlsessionfactory">sqlSessionFactory</h3>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/pds_sqlSessionFactory.png" alt="图片" loading="lazy"></figure>
<h3 id="sqlsessiontemplate-2">sqlSessionTemplate</h3>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/pds_sqlSessionTmplate.png" alt="图片" loading="lazy"></figure>
<h2 id="判断哪些类需要自动装配">判断哪些类需要自动装配</h2>
<pre><code class="language-java">protected String[] unsatisfiedNonSimpleProperties(AbstractBeanDefinition mbd, BeanWrapper bw) {
   Set&lt;String&gt; result = new TreeSet&lt;String&gt;();
   PropertyValues pvs = mbd.getPropertyValues();
   PropertyDescriptor[] pds = bw.getPropertyDescriptors();
   for (PropertyDescriptor pd : pds) {
      if (pd.getWriteMethod() != null &amp;&amp; !isExcludedFromDependencyCheck(pd) &amp;&amp; !pvs.contains(pd.getName()) &amp;&amp;
            !BeanUtils.isSimpleProperty(pd.getPropertyType())) {
         result.add(pd.getName());
      }
   }
   return StringUtils.toStringArray(result);
}
</code></pre>
<p>判断哪些类需要自动装配的核心代码第 6-7 行：</p>
<pre><code class="language-java">if (pd.getWriteMethod() != null &amp;&amp; !isExcludedFromDependencyCheck(pd) &amp;&amp; !pvs.contains(pd.getName()) &amp;&amp;
            !BeanUtils.isSimpleProperty(pd.getPropertyType()))
</code></pre>
<p>先看第一个条件：pd.getWriteMethod() != null：将 name=class、name=object、name=objectType、name=singleton、name=sqlSession 这5 个属性忽略掉，即它们不需要自动装配，因为它们的 writeMethod=null。<br>
这也就解释了 AUTOWIRED_BY_TYPE 只关心 set 方法，因为如果没有 set 方法，writeMethod=null，不满足 pd.getWriteMethod() != null 条件，就会被过滤掉，不会自动装配。</p>
<p>经过第一个条件判断后还剩下 4 个属性：addToConfig、mapperInterface、SqlSessionFactory、SqlSessionTemplate</p>
<p>接下来看第二个条件：!isExcludedFromDependencyCheck(pd)：自定义设置过滤接口，由于没有自行设置过滤，所以可暂时忽略这个条件判断。</p>
<p>下面看第三个条件：!pvs.contains(pd.getName())：pvs 不包含 pd.getName()，如果一个类在 pd 中，就会被过滤掉，不自动装配，比如 addToConfig 就会被过滤掉。</p>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/pvs%E5%8C%85%E5%90%ABpd.png" alt="图片" loading="lazy"></figure>
<p>pvs 是 Spring 自动设置给它的，</p>
<p>@Mapper --- &gt; @Import(MapperScannerRegistrar.class) ---&gt; MapperScannerRegistrar#registerBeanDefinitions ---&gt; ClassPathMapperScanner#doScan ---&gt; org.mybatis.spring.mapper.ClassPathMapperScanner#processBeanDefinitions</p>
<pre><code class="language-java">definition.getPropertyValues().add(&quot;addToConfig&quot;, this.addToConfig);
</code></pre>
<p>自己设置一个值，不需要自动装配，放到 pd 中。<br>
经过上述三个判断条件后还剩下 3 个属性：mapperInterface、SqlSessionFactory、SqlSessionTemplate</p>
<p>接下来来第四个条件：!BeanUtils.isSimpleProperty(pd.getPropertyType()：不是简单类型，来看一下什么是简单类型</p>
<pre><code class="language-java">public static boolean isSimpleProperty(Class&lt;?&gt; clazz) {
   Assert.notNull(clazz, &quot;Class must not be null&quot;);
   return isSimpleValueType(clazz) || (clazz.isArray() &amp;&amp; isSimpleValueType(clazz.getComponentType()));
}
</code></pre>
<pre><code class="language-java">public static boolean isSimpleValueType(Class&lt;?&gt; clazz) {
   return (ClassUtils.isPrimitiveOrWrapper(clazz) ||
         Enum.class.isAssignableFrom(clazz) ||
         CharSequence.class.isAssignableFrom(clazz) ||
         Number.class.isAssignableFrom(clazz) ||
         Date.class.isAssignableFrom(clazz) ||
         URI.class == clazz || URL.class == clazz ||
         Locale.class == clazz || Class.class == clazz);
}
</code></pre>
<p>由上述代码可知，简单类型为：Enum、CharSequence、Number、Date、URI、URI、Locale、Class<br>
所以第四个判断条件会过滤掉 mapperInterface，name = mapperInterface 的属性 getPropertyType() 方法返回 java.lang.Class</p>
<p>最终，经过四个判断后，还剩下 SqlSessionFactory、SqlSessionTemplate 这两个属性。</p>
<h1 id="如何判断一个类中的某个属性是否需要自动装配">如何判断一个类中的某个属性是否需要自动装配？</h1>
<h3 id="默认-autowire_no">默认 AUTOWIRE_NO</h3>
<p>有一个 OrderClazz 类交给 Spring 管理</p>
<pre><code class="language-java">@Component
public class OrderClazz {
}
</code></pre>
<p>UserClazz 类交给 Spring 管理，UserClazz 类依赖 OrderClazz：</p>
<pre><code class="language-java">@Component
public class UserClazz {
    // orderClazz 是否会自动装配？会
    private OrderClazz orderClazz;
    public OrderClazz getOrderClazz() {
        return orderClazz;
    }
    public void setOrderClazz(OrderClazz orderClazz) {
        this.orderClazz = orderClazz;
    }
}
</code></pre>
<p>一个测试类：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws IOException {
        AnnotationConfigApplicationContext configApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
        OrderClazz orderClazz = configApplicationContext.getBean(UserClazz.class).getOrderClazz();
        System.out.println(orderClazz);
    }
}
</code></pre>
<p>打印结果：null，而不是报错没有这个 bean。<br>
自动装配有三种类型：</p>
<pre><code class="language-java">/**
 * Constant that indicates no autowiring at all.
 * @see #setAutowireMode
 */
public static final int AUTOWIRE_NO = AutowireCapableBeanFactory.AUTOWIRE_NO;
/**
 * Constant that indicates autowiring bean properties by name.
 * @see #setAutowireMode
 */
public static final int AUTOWIRE_BY_NAME = AutowireCapableBeanFactory.AUTOWIRE_BY_NAME;
/**
 * Constant that indicates autowiring bean properties by type.
 * @see #setAutowireMode
 */
public static final int AUTOWIRE_BY_TYPE = AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE;
</code></pre>
<p>Spring 默认自动装配规则 AUTOWIRE_NO：不自动装配，但是加了 @Autowired 或 @Resource 的会自动装配：</p>
<pre><code class="language-java">@Component
public class UserClazz{
  @Autowired
  private OrderClazz orderClazz;
}
</code></pre>
<p>如果使用自动装配规则 AUTOWIRE_BY_TYPE，会根据属性的 set 方法进行装配，无需 @Autowired 注解：</p>
<pre><code class="language-java">@Component
public class UserClazz{
  private OrderClazz orderClazz;
  public OrderClazz getOrderClazz() {
    return orderClazz;
  }
}
</code></pre>
<h3 id="设置自动装配类型为-autowire_by_type">设置自动装配类型为 AUTOWIRE_BY_TYPE</h3>
<pre><code class="language-java">public class SSMScanRegistrar implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        GenericBeanDefinition userClazz = (GenericBeanDefinition) registry.getBeanDefinition(&quot;userClazz&quot;);
        // 设置自动装配类型为 AUTOWIRE_BY_TYPE
userClazz.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);
        registry.registerBeanDefinition(&quot;userClazz&quot;,userClazz);
    }
}
</code></pre>
<p>启动类扫描 SSMScanRegistrar</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
@MapperScan(&quot;com.ssm.dao&quot;)
@Import(SSMScanRegistrar.class)
public class AppConfig{
</code></pre>
<p>测试类打印：com.ssm.manager.OrderClazz@4c12331b</p>
<pre><code class="language-java">@Component
public class UserClazz {
//    private OrderClazz orderClazz;
    public OrderClazz getOrderClazz() {
        return null;
    }
    public void setOrderClazz(OrderClazz orderClazz) {
//        this.orderClazz = orderClazz;
        System.out.println(&quot;---------&quot;);
    }
}
</code></pre>
<p>测试类打印：---------<br>
AUTOWIRE_BY_TYPE 读取 set 方法，当有 set 方法，就认为 set 方法的参数对应的类 OrderClazz  需要自动装配。</p>
<p>如果去掉 set 方法：</p>
<pre><code class="language-java">@Component
public class UserClazz {
    private OrderClazz orderClazz;
    public OrderClazz getOrderClazz() {
        return orderClazz;
    }
}
</code></pre>
<p>测试类打印：null<br>
AUTOWIRE_BY_TYPE 根据 set 方法进行自动装配，与属性的声明无关。上述虽然声明了属性，但没有 set 方法，所以 orderClazz 并没有被赋值。</p>
<p>当实例化 MapperFactoryBean 时：</p>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Import(MapperScannerRegistrar.class)
public @interface MapperScan {
</code></pre>
<p>MapperScannerRegistrar#registerBeanDefinitions ---&gt; ClassPathMapperScanner#doScan ---&gt; ClassPathMapperScanner#processBeanDefinitions</p>
<pre><code class="language-java">private void processBeanDefinitions(Set&lt;BeanDefinitionHolder&gt; beanDefinitions) {
  GenericBeanDefinition definition;
  for (BeanDefinitionHolder holder : beanDefinitions) {
    definition = (GenericBeanDefinition) holder.getBeanDefinition();
    if (logger.isDebugEnabled()) {
      logger.debug(&quot;Creating MapperFactoryBean with name '&quot; + holder.getBeanName() 
        + &quot;' and '&quot; + definition.getBeanClassName() + &quot;' mapperInterface&quot;);
    }
    // the mapper interface is the original class of the bean
    // but, the actual class of the bean is MapperFactoryBean
    definition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName()); // issue #59
    // 
    definition.setBeanClass(this.mapperFactoryBean.getClass());
    definition.getPropertyValues().add(&quot;addToConfig&quot;, this.addToConfig);
    boolean explicitFactoryUsed = false;
    if (StringUtils.hasText(this.sqlSessionFactoryBeanName)) {
      definition.getPropertyValues().add(&quot;sqlSessionFactory&quot;, new RuntimeBeanReference(this.sqlSessionFactoryBeanName));
      explicitFactoryUsed = true;
    } else if (this.sqlSessionFactory != null) {
      definition.getPropertyValues().add(&quot;sqlSessionFactory&quot;, this.sqlSessionFactory);
      explicitFactoryUsed = true;
    }
    if (StringUtils.hasText(this.sqlSessionTemplateBeanName)) {
      if (explicitFactoryUsed) {
        logger.warn(&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;);
      }
      definition.getPropertyValues().add(&quot;sqlSessionTemplate&quot;, new RuntimeBeanReference(this.sqlSessionTemplateBeanName));
      explicitFactoryUsed = true;
    } else if (this.sqlSessionTemplate != null) {
      if (explicitFactoryUsed) {
        logger.warn(&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;);
      }
      definition.getPropertyValues().add(&quot;sqlSessionTemplate&quot;, this.sqlSessionTemplate);
      explicitFactoryUsed = true;
    }
    if (!explicitFactoryUsed) {
      if (logger.isDebugEnabled()) {
        logger.debug(&quot;Enabling autowire by type for MapperFactoryBean with name '&quot; + holder.getBeanName() + &quot;'.&quot;);
      }
      // mapper 自动注入类型修改为 AUTOWIRE_BY_TYPE
            definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);
    }
  }
}
</code></pre>
<p>当实例化 MapperFactoryBean 时，由于 addToConfig 有 set 方法，所以会自动装配 addToConfig：<br>
MapperFactoryBean#setAddToConfig</p>
<pre><code class="language-java">public void setAddToConfig(boolean addToConfig) {
  this.addToConfig = addToConfig;
}
</code></pre>
<p>由于 MapperFactoryBean 继承了 SqlSessionDaoSupport：<br>
SqlSessionDaoSupport # 所有set方法：</p>
<pre><code class="language-java">public abstract class SqlSessionDaoSupport extends DaoSupport {
  private SqlSession sqlSession;
  private boolean externalSqlSession;
  public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) {
    if (!this.externalSqlSession) {
      this.sqlSession = new SqlSessionTemplate(sqlSessionFactory);
    }
  }
  public void setSqlSessionTemplate(SqlSessionTemplate sqlSessionTemplate) {
    this.sqlSession = sqlSessionTemplate;
    this.externalSqlSession = true;
  }
  //......
</code></pre>
<p>因为有 setSqlSessionFactory 和  setSqlSessionTemplate 方法，所以会自动装配 sqlSessionTemplate 和 sqlSessionFactory，所以 sqlSessionTemplate 是在实例化 MapperFactoryBean 时被赋值的。<br>
为什么不直接使用 @Autowired SqlSession sqlSesssion; 自动注入？解耦。</p>
<p>如果写了 @Autowired，永远依赖 Spring 去编译。</p>
<h1 id="mybatis-整合-spring-流程">MyBatis 整合 Spring 流程</h1>
<p>扫描，实例化各种 mapper，通过 @MapperScan 把 mapper 变成 MapperFactoryBean，</p>
<p>在实例化过程中，MyBatis 会产生两个代理对象，mapper 代理对象；往 mapper 的代理对象中注入一个 SqlSessionTemplate，执行 SqlSessionTemplate 的代理方法，代理方法中关闭 sqlSession，一级缓存 map 失效，</p>
<p>当执行 userMapper.list() 时，实际上执行的是代理对象 MappperProxy 的 invoke()</p>
<pre><code class="language-java">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
  try {
    if (Object.class.equals(method.getDeclaringClass())) {
      return method.invoke(this, args);
    } else if (isDefaultMethod(method)) {
      return invokeDefaultMethod(proxy, method, args);
    }
  } catch (Throwable t) {
    throw ExceptionUtil.unwrapThrowable(t);
  }
  final MapperMethod mapperMethod = cachedMapperMethod(method);
  return mapperMethod.execute(sqlSession, args);
}
</code></pre>
<p>上述代码第 11 行：MapperProxy#cachedMapperMethod</p>
<pre><code class="language-java">private MapperMethod cachedMapperMethod(Method method) {
  MapperMethod mapperMethod = methodCache.get(method);
  if (mapperMethod == null) {
    mapperMethod = new MapperMethod(mapperInterface, method, sqlSession.getConfiguration());
    methodCache.put(method, mapperMethod);
  }
  return mapperMethod;
}
</code></pre>
<p>上述代码第 4 行：</p>
<pre><code class="language-java">public MapperMethod(Class&lt;?&gt; mapperInterface, Method method, Configuration config) {
  this.command = new SqlCommand(config, mapperInterface, method);
  this.method = new MethodSignature(config, mapperInterface, method);
}
</code></pre>
<p>上述代码第 2 行：</p>
<pre><code class="language-java">public SqlCommand(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method) {
  final String methodName = method.getName();
  final Class&lt;?&gt; declaringClass = method.getDeclaringClass();
  MappedStatement ms = resolveMappedStatement(mapperInterface, methodName, declaringClass,
      configuration);
  if (ms == null) {
    if (method.getAnnotation(Flush.class) != null) {
      name = null;
      type = SqlCommandType.FLUSH;
    } else {
      throw new BindingException(&quot;Invalid bound statement (not found): &quot;
          + mapperInterface.getName() + &quot;.&quot; + methodName);
    }
  } else {
    name = ms.getId();
    type = ms.getSqlCommandType();
    if (type == SqlCommandType.UNKNOWN) {
      throw new BindingException(&quot;Unknown execution method for: &quot; + name);
    }
  }
}
</code></pre>
<p>上述代码第 4 行：<br>
<img src="https://epitomm.github.io/post-images/mapperStatement.png" alt="图片" loading="lazy"></p>
<p>执行完 org.apache.ibatis.binding.MapperMethod.SqlCommand#resolveMappedStatement 方法，能够得到 SQL 语句。</p>
<pre><code class="language-java">private MappedStatement resolveMappedStatement(Class&lt;?&gt; mapperInterface, String methodName,
    Class&lt;?&gt; declaringClass, Configuration configuration) {
    // 方法名：List&lt;Map&lt;String,Object&gt;&gt; list(); 为什么要和 mapper 的 id：&lt;select id=&quot;list&quot; &gt; 相同：通过命名空间+方法名得到 statementId：com.ssm.mapper.UserMapper.list
  String statementId = mapperInterface.getName() + &quot;.&quot; + methodName;
  // 判断 configuration 是否包含 statementId
  if (configuration.hasStatement(statementId)) {
    // 通过 configuration 得到 statementId 对应的 MappedStatement 
    return configuration.getMappedStatement(statementId);
  } else if (mapperInterface.equals(declaringClass)) {
    return null;
  }
  for (Class&lt;?&gt; superInterface : mapperInterface.getInterfaces()) {
    if (declaringClass.isAssignableFrom(superInterface)) {
      MappedStatement ms = resolveMappedStatement(superInterface, methodName,
          declaringClass, configuration);
      if (ms != null) {
        return ms;
      }
    }
  }
  return null;
}
</code></pre>
<p>上述代码第 8 行：</p>
<pre><code class="language-java">public MappedStatement getMappedStatement(String id) {
  return this.getMappedStatement(id, true);
}
</code></pre>
<pre><code class="language-java">public MappedStatement getMappedStatement(String id, boolean validateIncompleteStatements) {
  if (validateIncompleteStatements) {
    buildAllStatements();
  }
  return mappedStatements.get(id);
}
</code></pre>
<pre><code class="language-java">protected final Map&lt;String, MappedStatement&gt; mappedStatements = new StrictMap&lt;MappedStatement&gt;(&quot;Mapped Statements collection&quot;);
</code></pre>
<p>先把 SQL 语句 放到 mappedStatements 中，然后通过 mappedStatements.get(id) 拿出 SQL 语句，在 execute(sql) 执行 SQL 语句<br>
上述 invoke 方法的第 12 行：</p>
<p>MapperMethod#execute</p>
<pre><code class="language-java">public Object execute(SqlSession sqlSession, Object[] args) {
  Object result;
  switch (command.getType()) {
    case INSERT: {
    Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.insert(command.getName(), param));
      break;
    }
    case UPDATE: {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.update(command.getName(), param));
      break;
    }
    case DELETE: {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.delete(command.getName(), param));
      break;
    }
    case SELECT:
      if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) {
        executeWithResultHandler(sqlSession, args);
        result = null;
      } else if (method.returnsMany()) {
        result = executeForMany(sqlSession, args);
      } else if (method.returnsMap()) {
        result = executeForMap(sqlSession, args);
      } else if (method.returnsCursor()) {
        result = executeForCursor(sqlSession, args);
      } else {
        Object param = method.convertArgsToSqlCommandParam(args);
        result = sqlSession.selectOne(command.getName(), param);
      }
      break;
    case FLUSH:
      result = sqlSession.flushStatements();
      break;
    default:
      throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());
  }
  if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) {
    throw new BindingException(&quot;Mapper method '&quot; + command.getName() 
        + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);
  }
  return result;
}
</code></pre>
<p>上述代码第 24 行：MapperMethod#executeForMany</p>
<pre><code class="language-java">private &lt;E&gt; Object executeForMany(SqlSession sqlSession, Object[] args) {
  List&lt;E&gt; result;
  Object param = method.convertArgsToSqlCommandParam(args);
  if (method.hasRowBounds()) {
    RowBounds rowBounds = method.extractRowBounds(args);
    result = sqlSession.&lt;E&gt;selectList(command.getName(), param, rowBounds);
  } else {
    result = sqlSession.&lt;E&gt;selectList(command.getName(), param);
  }
  // issue #510 Collections &amp; arrays support
  if (!method.getReturnType().isAssignableFrom(result.getClass())) {
    if (method.getReturnType().isArray()) {
      return convertToArray(result);
    } else {
      return convertToDeclaredCollection(sqlSession.getConfiguration(), result);
    }
  }
  return result;
}
</code></pre>
<p>DefaultSqlSession#selectList</p>
<pre><code class="language-java">public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) {
  return this.selectList(statement, parameter, RowBounds.DEFAULT);
}
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/statement.png" alt="图片" loading="lazy"></figure>
<pre><code class="language-java">public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) {
  try {
    MappedStatement ms = configuration.getMappedStatement(statement);
    return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
  } catch (Exception e) {
    throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);
  } finally {
    ErrorContext.instance().reset();
  }
}
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/ms.png" alt="图片" loading="lazy"></figure>
<pre><code class="language-java">@Override
public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {
  BoundSql boundSql = ms.getBoundSql(parameterObject);
  CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);
  return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
}
</code></pre>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/BoundSql.png" alt="图片" loading="lazy"></figure>
<p>MyBatis 中的所有信息，包括 SQL 语句、返回类型信息都存在了 mappedStatements 中。</p>
<p>什么时候把 mapper 信息放到 mappedStatements 中的？</p>
<pre><code class="language-java">public void addMappedStatement(MappedStatement ms) {
  mappedStatements.put(ms.getId(), ms);
}
</code></pre>
<p>调用链如下：<br>
<img src="https://epitomm.github.io/post-images/ms%E8%B0%83%E7%94%A8%E9%93%BE.png" alt="图片" loading="lazy"></p>
<p>Spring 容器初始化 UserMapper 时，就拿到 mapper 里的所有信息，放到 mapperStatements 中，</p>
<p>一个对象被实例化后，由于实例化的是 MapperFactoryBean，MapperFactoryBean 继承了 SqlSessionDaoSupport 接口，SqlSessionDaoSupport 继承了 DaoSupport，所以会执行 DaoSupport#afterPropertiesSet() ---&gt; DaoSupport#checkDaoConfig(); ---&gt; Configuration#addMapper ---&gt; MapperRegistry#addMapper --&gt; MapperAnnotationBuilder#parse()</p>
<pre><code class="language-java">public void parse() {
  String resource = type.toString();
  if (!configuration.isResourceLoaded(resource)) {
    loadXmlResource();
    configuration.addLoadedResource(resource);
    assistant.setCurrentNamespace(type.getName());
    parseCache();
    parseCacheRef();
    Method[] methods = type.getMethods();
    for (Method method : methods) {
      try {
        // issue #237
        if (!method.isBridge()) {
          parseStatement(method);
        }
      } catch (IncompleteElementException e) {
        configuration.addIncompleteMethod(new MethodResolver(this, method));
      }
    }
  }
  parsePendingMethods();
}
</code></pre>
<p>上述代码第 14 行：</p>
<pre><code class="language-java">void parseStatement(Method method) {
  Class&lt;?&gt; parameterTypeClass = getParameterType(method);
  LanguageDriver languageDriver = getLanguageDriver(method);
  
  SqlSource sqlSource = getSqlSourceFromAnnotations(method, parameterTypeClass, languageDriver);
  // ......
}
</code></pre>
<p>上述代码第 5 行：</p>
<pre><code class="language-java">private SqlSource getSqlSourceFromAnnotations(Method method, Class&lt;?&gt; parameterType, LanguageDriver languageDriver) {
  try {
    // 判断 sqlAnnotationType  是不是 SELECT、INSERT 等
    Class&lt;? extends Annotation&gt; sqlAnnotationType = getSqlAnnotationType(method);
    // 判断注解是否是 @SelectProvider
    Class&lt;? extends Annotation&gt; sqlProviderAnnotationType = getSqlProviderAnnotationType(method);
    if (sqlAnnotationType != null) {
      if (sqlProviderAnnotationType != null) {
        // @SelectProvider 与 @Select 注解不能同时存在
        throw new BindingException(&quot;You cannot supply both a static SQL and SqlProvider to method named &quot; + method.getName());
      }
      Annotation sqlAnnotation = method.getAnnotation(sqlAnnotationType);
      // 获取 SQL 语句，可以是个数组：@Select({&quot;select * from city&quot;},{&quot;xxx&quot;})
      final String[] strings = (String[]) sqlAnnotation.getClass().getMethod(&quot;value&quot;).invoke(sqlAnnotation);
      return buildSqlSourceFromStrings(strings, parameterType, languageDriver);
    } else if (sqlProviderAnnotationType != null) {
      Annotation sqlProviderAnnotation = method.getAnnotation(sqlProviderAnnotationType);
      return new ProviderSqlSource(assistant.getConfiguration(), sqlProviderAnnotation, type, method);
    }
    return null;
  } catch (Exception e) {
    throw new BuilderException(&quot;Could not find value method on SQL annotation.  Cause: &quot; + e, e);
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MyBatis系列（二）MyBatis缓存]]></title>
        <id>https://epitomm.github.io/post/mybatis-xi-lie-er-mybatis-huan-cun/</id>
        <link href="https://epitomm.github.io/post/mybatis-xi-lie-er-mybatis-huan-cun/">
        </link>
        <updated>2020-05-20T03:59:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="spring-中的-mybatis-缓存">Spring 中的 MyBatis 缓存</h1>
<h2 id="一级缓存">一级缓存</h2>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/MyBatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98.png" alt="图片" loading="lazy"></figure>
<p>如果不使用 Spring，执行三行相同的查询，只会打印一条 SQL 语句，证明一级缓存有效。</p>
<p>但是使用 Spring 后，执行三行相同的查询，会打印三条 SQL 语句，证明<strong>一级缓存失效</strong>。</p>
<p>一级缓存基于 SqlSession，当执行 list() 方法时，在代理类中，会得到一个 SqlSession 对象，并且把它设置到当前线程中去，<strong>当完成一个查询后，会关闭 SqlSession</strong>，这是 Spring 做的，所以一级缓存失效了。</p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E6%97%A0%E6%B3%95%E5%85%B1%E4%BA%ABMyBatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98.png" alt="图片" loading="lazy"></figure>
<h2 id="spring当中为什么失效">spring当中为什么失效</h2>
<p>因为 mybatis 和 spring 的集成包当中扩展了一个类 SqlSessionTemplate，这个类在 spring 容器启动的时候被注入给了 mapper 这个类替代了原来的 DefulatSqlSession，SqlSessionTemplate当中的所有查询方法不是直接查询，而是经过一个代理对象，代理对象增强了查询方法，主要是关闭了session。</p>
<h3 id="先来看一个-mybatis-spring-的-demo">先来看一个 mybatis-spring 的 demo</h3>
<p>准备一个 Mapper 接口：</p>
<pre><code class="language-java">public interface UserMapper {
    @Select(&quot;select * from t1&quot;)
    List&lt;Map&lt;String,Object&gt;&gt; list();
}
</code></pre>
<p>测试类调用 mapper 接口中的 list() 方法两次，查询两次数据库，MyBatis 一级缓存失效：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws IOException {
        AnnotationConfigApplicationContext configApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
        UserMapper mapper = configApplicationContext.getBean(UserMapper.class);
        System.out.println(mapper.list());
        System.out.println(mapper.list());
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/spring-mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88.png" alt="图片" loading="lazy"></figure>
<p>执行 list() 方法是通过 ImportBeanDefinitionRegistrar</p>
<p>MyBatis 底层 生成的是 MapperFactoryBean 对象，</p>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Import(MapperScannerRegistrar.class)
public @interface MapperScan {
</code></pre>
<pre><code class="language-java">public class MapperScannerRegistrar implements ImportBeanDefinitionRegistrar, ResourceLoaderAware {
</code></pre>
<p><strong>在 Spring 容器中，有多少个 mapper，就有多少个 MapperFactoryBean</strong>，<br>
当调用 getSqlSession() 时，使用了代理，因为 mapper 是接口，肯定会为它产生一个代理类，就是通过 getSqlSession() 产生一个代理对象出来，</p>
<p>MapperFactoryBean#getObject</p>
<pre><code class="language-java">public T getObject() throws Exception {
  return getSqlSession().getMapper(this.mapperInterface);
}
</code></pre>
<p>SqlSessionTemplate#getMapper</p>
<pre><code class="language-java">public &lt;T&gt; T getMapper(Class&lt;T&gt; type) {
  return getConfiguration().getMapper(type, this);
}
</code></pre>
<p>Configuration#getMapper</p>
<pre><code class="language-java">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
  return mapperRegistry.getMapper(type, sqlSession);
}
</code></pre>
<p>MapperRegistry#getMapper</p>
<pre><code class="language-java">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
  final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);
  if (mapperProxyFactory == null) {
    throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);
  }
  try {
    return mapperProxyFactory.newInstance(sqlSession);
  } catch (Exception e) {
    throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);
  }
}
</code></pre>
<p>MapperProxyFactory#newInstance</p>
<pre><code class="language-java">public T newInstance(SqlSession sqlSession) {
  final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);
  return newInstance(mapperProxy);
}
</code></pre>
<p>MapperProxyFactory#newInstance</p>
<pre><code class="language-java">protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) {
  // mapperInterface 就是接口 UserMapper，为 UserMapper 产生一个代理对象，产生代理对象需要传递一个 InvocationHandler 参数：mapperProxy
  return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);
}
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E8%B0%83%E7%94%A8mapper%E7%9A%84list%E6%96%B9%E6%B3%95.png" alt="图片" loading="lazy"></figure>
<p><strong>当调用 userMapper.list() 时，实际执行的逻辑是实现 InvocationHandler 接口的类中的 invoke() 方法</strong>。</p>
<p>mapperProxy 是一个 InvocationHandler：</p>
<pre><code class="language-java">public class MapperProxy&lt;T&gt; implements InvocationHandler, Serializable {
    // ...
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
      try {
        if (Object.class.equals(method.getDeclaringClass())) {
          return method.invoke(this, args);
        } else if (isDefaultMethod(method)) {
          return invokeDefaultMethod(proxy, method, args);
        }
      } catch (Throwable t) {
        throw ExceptionUtil.unwrapThrowable(t);
      }
      // MapperMethod 相当于 Spring 当中的 BeanDefinition，包含了：返回类型、缓存级别
      final MapperMethod mapperMethod = cachedMapperMethod(method);
      return mapperMethod.execute(sqlSession, args);
    }
    // ...
}
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/sqlSessionTemplate.png" alt="图片" loading="lazy"></figure>
<p>这里的 sqlSession 是一个 SqlSessionTemplate 对象，</p>
<p>UserMapper 代理对象</p>
<pre><code class="language-java">// 代理类
class UserMapperProxy{
  private InvocationHandler h;
  // 构造方法
  public UserMapperProxy(InvocationHandler h){
     this.h = h;
  }
  list(){
    // 执行 InvocationHandler 的 invoke() 方法
    return h.invoke();
  }
}
</code></pre>
<p>当 configApplicationContext.getBean(UserMapper.class); 时就拿出了 UserMapper 的代理对象。<br>
MapperMethod#execute</p>
<pre><code class="language-java">public Object execute(SqlSession sqlSession, Object[] args) {
  Object result;
  switch (command.getType()) {
    case INSERT: {
    Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.insert(command.getName(), param));
      break;
    }
    case UPDATE: {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.update(command.getName(), param));
      break;
    }
    case DELETE: {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.delete(command.getName(), param));
      break;
    }
    case SELECT:
      if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) {
        executeWithResultHandler(sqlSession, args);
        result = null;
      } else if (method.returnsMany()) {
        // 返回值是 Map，查询多条，所以走这个分支
        result = executeForMany(sqlSession, args);
      } else if (method.returnsMap()) {
        result = executeForMap(sqlSession, args);
      } else if (method.returnsCursor()) {
        result = executeForCursor(sqlSession, args);
      } else {
        Object param = method.convertArgsToSqlCommandParam(args);
        result = sqlSession.selectOne(command.getName(), param);
      }
      break;
    case FLUSH:
      result = sqlSession.flushStatements();
      break;
    default:
      throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());
  }
  if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) {
    throw new BindingException(&quot;Mapper method '&quot; + command.getName() 
        + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);
  }
  return result;
}
</code></pre>
<p><img src="https://epitomm.github.io/post-images/command.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/DefaultSqlSession.png" alt="图片" loading="lazy"></p>
<p>MapperMethod#executeForMany</p>
<pre><code class="language-java">private &lt;E&gt; Object executeForMany(SqlSession sqlSession, Object[] args) {
  List&lt;E&gt; result;
  Object param = method.convertArgsToSqlCommandParam(args);
  if (method.hasRowBounds()) {
    RowBounds rowBounds = method.extractRowBounds(args);
    result = sqlSession.&lt;E&gt;selectList(command.getName(), param, rowBounds);
  } else {
    // 因为 select *，所以走这个分支
    result = sqlSession.&lt;E&gt;selectList(command.getName(), param);
  }
  // issue #510 Collections &amp; arrays support
  if (!method.getReturnType().isAssignableFrom(result.getClass())) {
    if (method.getReturnType().isArray()) {
      return convertToArray(result);
    } else {
      return convertToDeclaredCollection(sqlSession.getConfiguration(), result);
    }
  }
  return result;
}
</code></pre>
<p>上述代码第 9 行：SqlSessionTemplate#selectList</p>
<pre><code class="language-java">public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) {
  return this.sqlSessionProxy.&lt;E&gt; selectList(statement, parameter);
}
</code></pre>
<p>SqlSessionInterceptor#invoke</p>
<pre><code class="language-java">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
  SqlSession sqlSession = getSqlSession(
      SqlSessionTemplate.this.sqlSessionFactory,
      SqlSessionTemplate.this.executorType,
      SqlSessionTemplate.this.exceptionTranslator);
  try {
    Object result = method.invoke(sqlSession, args);
    if (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.this.sqlSessionFactory)) {
      // force commit even on non-dirty sessions because some databases require
      // a commit/rollback before calling close()
      sqlSession.commit(true);
    }
    return result;
  } catch (Throwable t) {
    Throwable unwrapped = unwrapThrowable(t);
    if (SqlSessionTemplate.this.exceptionTranslator != null &amp;&amp; unwrapped instanceof PersistenceException) {
      // release the connection to avoid a deadlock if the translator is no loaded. See issue #22
      closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory);
      sqlSession = null;
      Throwable translated = SqlSessionTemplate.this.exceptionTranslator.translateExceptionIfPossible((PersistenceException) unwrapped);
      if (translated != null) {
        unwrapped = translated;
      }
    }
    throw unwrapped;
  } finally {
    if (sqlSession != null) {
      // 当执行完查询，关闭 sqlSession，所以 Spring+MyBatis一级缓存失效。
      closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory);
    }
  }
}
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/DefaultSqlSession_2.png" alt="图片" loading="lazy"></figure>
<p>如果使用普通 MyBatis，执行的不是 SqlSessionTemplate 的代理方法，执行的是 DefaultSqlSession；在 Spring 过程中，执行代理对象的方法：sqlSessionProxy.<E> selectList(statement, parameter);</p>
<p>由于 sqlSessionProxy 是代理对象，所以看不到代理对象的方法，点进去只能看到 它实现的 InvocationHandler（SqlSessionInterceptor） 的 invoke 方法；与 userMapper.list(); 一样，当调用 list() 方法时，debug 下一步进入的是它实现的 InvocationHandler：MapperProxy 的 invoke() 方法。</p>
<h3 id="再来看一个-mybatis-原生的-demo">再来看一个 mybatis 原生的 demo</h3>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws IOException {
        String resource = &quot;mybatis-config.xml&quot;;
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        SqlSession sqlSession = sqlSessionFactory.openSession();
        sqlSession.getConfiguration().addMapper(UserMapper.class);
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        System.out.println(mapper.list());
        System.out.println(mapper.list());
    }
}
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98_2.png" alt="图片" loading="lazy"></figure>
<p>当调用 mapper 的 list() 方法时，执行 InvocationHandler 的实现类：MapperProxy 的 invoke() 方法，因为 mapper 是一个代理对象。</p>
<p>MapperProxy#invoke</p>
<pre><code class="language-java">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
  try {
    if (Object.class.equals(method.getDeclaringClass())) {
      return method.invoke(this, args);
    } else if (isDefaultMethod(method)) {
      return invokeDefaultMethod(proxy, method, args);
    }
  } catch (Throwable t) {
    throw ExceptionUtil.unwrapThrowable(t);
  }
  final MapperMethod mapperMethod = cachedMapperMethod(method);
  return mapperMethod.execute(sqlSession, args);
}
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/mappedStatements.png" alt="图片" loading="lazy"></figure>
<p>上述代码第 12 行：MapperMethod#execute</p>
<pre><code class="language-java">public Object execute(SqlSession sqlSession, Object[] args) {
  Object result;
  switch (command.getType()) {
    case INSERT: {
    Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.insert(command.getName(), param));
      break;
    }
    case UPDATE: {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.update(command.getName(), param));
      break;
    }
    case DELETE: {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.delete(command.getName(), param));
      break;
    }
    case SELECT:
      if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) {
        executeWithResultHandler(sqlSession, args);
        result = null;
      } else if (method.returnsMany()) {
        result = executeForMany(sqlSession, args);
      } else if (method.returnsMap()) {
        result = executeForMap(sqlSession, args);
      } else if (method.returnsCursor()) {
        result = executeForCursor(sqlSession, args);
      } else {
        Object param = method.convertArgsToSqlCommandParam(args);
        result = sqlSession.selectOne(command.getName(), param);
      }
      break;
    case FLUSH:
      result = sqlSession.flushStatements();
      break;
    default:
      throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());
  }
  if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) {
    throw new BindingException(&quot;Mapper method '&quot; + command.getName() 
        + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);
  }
  return result;
}
</code></pre>
<p>上述代码第 24 行：MapperMethod#executeForMany</p>
<pre><code class="language-java">private &lt;E&gt; Object executeForMany(SqlSession sqlSession, Object[] args) {
  List&lt;E&gt; result;
  Object param = method.convertArgsToSqlCommandParam(args);
  if (method.hasRowBounds()) {
    RowBounds rowBounds = method.extractRowBounds(args);
    result = sqlSession.&lt;E&gt;selectList(command.getName(), param, rowBounds);
  } else {
    result = sqlSession.&lt;E&gt;selectList(command.getName(), param);
  }
  // issue #510 Collections &amp; arrays support
  if (!method.getReturnType().isAssignableFrom(result.getClass())) {
    if (method.getReturnType().isArray()) {
      return convertToArray(result);
    } else {
      return convertToDeclaredCollection(sqlSession.getConfiguration(), result);
    }
  }
  return result;
}
</code></pre>
<p>上述代码第 8 行：DefaultSqlSession#selectList</p>
<pre><code class="language-java">public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) {
  return this.selectList(statement, parameter, RowBounds.DEFAULT);
}
</code></pre>
<p>MyBatis 直接调用 DefaultSqlSession 的 selectList 方法；而 Spring 调用的是 DefaultSqlSession 的代理类的方法，Spring 把 sqlSession 替换成了代理对象：在完成查询后关闭 sqlSession。<br>
DefaultSqlSession#selectList</p>
<pre><code class="language-java">public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) {
  try {
    MappedStatement ms = configuration.getMappedStatement(statement);
    return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
  } catch (Exception e) {
    throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);
  } finally {
    ErrorContext.instance().reset();
  }
}
</code></pre>
<h3 id="总结">总结</h3>
<p>MyBatis --&gt; SqlSession --&gt; DefaultSqlSession --&gt; DefaultSqlSession.select(); --&gt; SQL</p>
<p>spring-mybatis --&gt; SqlSession --&gt; SqlSessionTemplate --&gt;  SqlSessionTemplate.selectList(); --&gt;  sqlSessionProxy.selectList();</p>
<h3 id="为什么-spring-当中-mybatis-一级缓存失效">为什么 Spring 当中 MyBatis 一级缓存失效</h3>
<p>MyBatis 整合 Spring 时，MyBatis 为 Spring 提供了一个插件包：mybatis-spring，在 mybatis-spring 中提供了一个类：SqlSessionTemplate 替代了 MyBatis 中默认的 DefaultSqlSession，对</p>
<p>DefaultSqlSession 的增强，在代理的代码中把 SqlSession 关闭了。</p>
<h4 id="spring-为什么要关闭-sqlsession">Spring 为什么要关闭 sqlSession？</h4>
<p>MyBatis 把 SqlSession 暴露出来，想什么时候关闭，就什么时候关闭。</p>
<pre><code class="language-java">SqlSession sqlSession = sqlSessionFactory.openSession();
sqlSession.close();
</code></pre>
<p>而在 Spring 没有把 SqlSession 暴露出来，所以只有在源码中，使用完一次后就关闭，否则没有其他地方可以关闭。</p>
<h2 id="二级缓存">二级缓存</h2>
<p>多个线程共享二级缓存</p>
<pre><code class="language-java">@CacheNamespace
public interface IndexDao {
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/MyBatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.png" alt="图片" loading="lazy"></figure>
<pre><code class="language-java">@CacheNamespace
public interface IndexDao2 {
    @Update(&quot;update t1 set b=1 where a=1&quot;)
    public int update();
}
</code></pre>
<pre><code class="language-java">@Service
public class IndexService {
    @Autowired
    IndexDao indexDao;
    @Autowired
    IndexDao2 indexDao2;
    public List&lt;Map&lt;String,Object&gt;&gt; list(){
        indexDao.list();
        indexDao.list();
        return indexDao.list();
    }
    public void update(){
       indexDao2.update();
    }
}
</code></pre>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext configApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
        List&lt;Map&lt;String, Object&gt;&gt; list = configApplicationContext.getBean(IndexService.class).list();
        System.out.println(list);
        configApplicationContext.getBean(IndexService.class).update();
        System.out.println(configApplicationContext.getBean(IndexService.class).list());
    }
}
</code></pre>
<p>我们发现，使用了二级缓存后，第一次查询，将查询结果缓存起来，接下来更新操作，第二次再次查询直接使用缓存结果，无法查到更新后的值。<br>
<img src="https://epitomm.github.io/post-images/MyBatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E8%AF%BB%E8%84%8F%E6%95%B0%E6%8D%AE.png" alt="图片" loading="lazy"></p>
<p>分析：MyBatis 缓存是基于<strong>命名空间</strong>的，当调用 indexDao.list() 查询出结果后，由于 IndexDao 添加了缓存 @CacheNamespace，把 list() 查询结果放到缓存中，存放形式：&lt;&quot;com.ssm.dao.IndexDao&quot;, &quot;list&quot;&gt;，当调用 update() 方法时，更新当前这个 update() 方法所在的命名空间，即 com.ssm.dao.IndexDao2，于是放入缓存 &lt;&quot;com.ssm.dao.IndexDao2&quot;, &quot;更新后的list&quot;&gt;，而第二次调用 list() 查询时，查找 list() 方法对应的命名空间的缓存：&lt;&quot;com.ssm.dao.IndexDao&quot;, &quot;list&quot;&gt;。</p>
<p>如果将 update、select 写在一个 dao 内，就不会出现上述问题了，代码修改如下：</p>
<pre><code class="language-java">@CacheNamespace
public interface IndexDao {
    @Select(&quot;select * from t1&quot;)
    List&lt;Map&lt;String,Object&gt;&gt; list();
    @Update(&quot;update t1 set b=111 where a=1&quot;)
    public int update();
}
</code></pre>
<pre><code class="language-java">@Service
public class IndexService {
    @Autowired
    IndexDao indexDao;
    public List&lt;Map&lt;String,Object&gt;&gt; list(){
        indexDao.list();
        indexDao.list();
        return indexDao.list();
    }
    public void update(){
       indexDao.update();
    }
}
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/MyBatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9B%B8%E5%90%8C%E8%AF%BB%E6%95%B0%E6%8D%AE%E6%AD%A3%E7%A1%AE.png" alt="图片" loading="lazy"></figure>
<p>分析：MyBatis 缓存是基于<strong>命名空间</strong>的，当调用 indexDao.list() 查询出结果后，由于 IndexDao 添加了缓存 @CacheNamespace，把 list() 查询结果放到缓存中，存放形式：&lt;&quot;com.ssm.dao.IndexDao&quot;, &quot;list&quot;&gt;，当调用 update() 方法时，更新当前这个 update() 方法所在的命名空间，即 &lt;&quot;com.ssm.dao.IndexDao&quot;, &quot;更新后的list&quot;&gt;。</p>
<h1 id="当调用-list-时已经拿到了-sql-语句">当调用 list() 时，已经拿到了 sql 语句</h1>
<p>当实例化一个 MapperFactoryBean 时，MyBatis 初始化：解析注解：把接口 mapper 中的 method 中的注解拿出来，把&lt;id,object&gt;放到 map 中。</p>
<pre><code class="language-java">protected final Map&lt;String, MappedStatement&gt; mappedStatements = new StrictMap&lt;MappedStatement&gt;(&quot;Mapped Statements collection&quot;);
</code></pre>
<p>在调用方法前，就实例化 mappedStatements 了。当创建 Service 时，由于 Service 会调用 putVal，putVal 就会创建 mapper，当创建 mapper 时，就 put 了一个&lt;id,object&gt;<br>
<img src="https://epitomm.github.io/post-images/DefaultSqlSession_3.png" alt="图片" loading="lazy"></p>
<p>Mapper 被实例化之后，就立刻把 sql 语句放到 map 中了。</p>
<h2 id="当一个类被实例化时就去执行一些东西把-sql-放到-map-中怎么做">当一个类被实例化时，就去执行一些东西（把 sql 放到 map 中）怎么做？</h2>
<p>实现 InitializingBean 接口，重写接口中的 afterPropertiesSet() 方法：</p>
<pre><code class="language-java">@Service
public class IndexService implements InitializingBean {
    @Autowired
    UserMapper userMapper;
    public List&lt;Map&lt;String,Object&gt;&gt; list(){
        userMapper.list();
        userMapper.list();
        return userMapper.list();
    }
    public void update(){
       userMapper.update();
    }
    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println(&quot;app...&quot;);
    }
}
</code></pre>
<p>打印结果：</p>
<pre><code class="language-plain">DEBUG [main] - Finished creating instance of bean 'userMapper'
DEBUG [main] - Autowiring by type from bean name 'indexService' to bean named 'userMapper'
DEBUG [main] - Invoking afterPropertiesSet() on bean with name 'indexService'
app...
DEBUG [main] - Finished creating instance of bean 'indexService'
DEBUG [main] - Returning cached instance of singleton bean 'dataSource'
DEBUG [main] - Returning cached instance of singleton bean 'sqlSessionFactoryBean'
</code></pre>
<p>Spring 与 MyBatis 整合的流程：<br>
MyBatis 中所有的 mapper 都是 MapperFactoryBean，MapperFactoryBean 实现了 SqlSessionDaoSupport：</p>
<pre><code class="language-java">public class MapperFactoryBean&lt;T&gt; extends SqlSessionDaoSupport implements FactoryBean&lt;T&gt; {
</code></pre>
<p>SqlSessionDaoSupport  是 MyBatis 开发的，SqlSessionDaoSupport 继承了 DaoSupport：</p>
<pre><code class="language-java">package org.mybatis.spring.support;
public abstract class SqlSessionDaoSupport extends DaoSupport {
</code></pre>
<p>DaoSupport 是 Spring 开发的，DaoSupport 实现了 InitializingBean：</p>
<pre><code class="language-java">package org.springframework.dao.support;
public abstract class DaoSupport implements InitializingBean {
    // ...
    public final void afterPropertiesSet() throws IllegalArgumentException, BeanInitializationException {
       // Let abstract subclasses check their configuration.
       // 抽象方法，所以会调用子类的实现
       checkDaoConfig();
    
       // Let concrete implementations initialize themselves.
       try {
          initDao();
       }
       catch (Exception ex) {
          throw new BeanInitializationException(&quot;Initialization of DAO failed&quot;, ex);
       }
    }
    //...
}
</code></pre>
<p>如果用 MapperFactoryBean 直接实现 InitializingBean，重写 afterPropertiesSet()，当 MapperFactoryBean 被实例化后，就会调用 DaoSupport 的 afterPropertiesSet()，而  DaoSupport 的 afterPropertiesSet() 内部会调用 checkDaoConfig()，由于 checkDaoConfig() 是抽象方法，所以会去调用子类 MapperFactoryBean 的实现：<br>
MapperFactoryBean#checkDaoConfig</p>
<pre><code class="language-java">protected void checkDaoConfig() {
  super.checkDaoConfig();
  notNull(this.mapperInterface, &quot;Property 'mapperInterface' is required&quot;);
  // 得到 Configuration
  Configuration configuration = getSqlSession().getConfiguration();
  if (this.addToConfig &amp;&amp; !configuration.hasMapper(this.mapperInterface)) {
    try {
      // 初始化 mapper 这些类
      configuration.addMapper(this.mapperInterface);
    } catch (Exception e) {
      logger.error(&quot;Error while adding the mapper '&quot; + this.mapperInterface + &quot;' to configuration.&quot;, e);
      throw new IllegalArgumentException(e);
    } finally {
      ErrorContext.instance().reset();
    }
  }
}
</code></pre>
<p>Configuration#addMapper</p>
<pre><code class="language-java">public &lt;T&gt; void addMapper(Class&lt;T&gt; type) {
  mapperRegistry.addMapper(type);
}
</code></pre>
<p>MapperRegistry#addMapper</p>
<pre><code class="language-java">public &lt;T&gt; void addMapper(Class&lt;T&gt; type) {
  if (type.isInterface()) {
    if (hasMapper(type)) {
      throw new BindingException(&quot;Type &quot; + type + &quot; is already known to the MapperRegistry.&quot;);
    }
    boolean loadCompleted = false;
    try {
      // 放到 map 中
      knownMappers.put(type, new MapperProxyFactory&lt;T&gt;(type));
      // It's important that the type is added before the parser is run
      // otherwise the binding may automatically be attempted by the
      // mapper parser. If the type is already known, it won't try.
      MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);
      // 解析
      parser.parse();
      loadCompleted = true;
    } finally {
      if (!loadCompleted) {
        knownMappers.remove(type);
      }
    }
  }
}
</code></pre>
<h1 id="spring-和-mybatis-结合如何初始化">Spring 和 MyBatis 结合如何初始化？</h1>
<h2 id="springbean-实例化之前的工作">SpringBean 实例化之前的工作：</h2>
<p>通过分析源码可以得出 @MapperScan 主要做了3个事情：</p>
<p>1.扫描出来所有的 mapper 所对应的 BeanDefinition</p>
<p>2.把 mapper 变成 FactoryBean，MapperFactoryBean  和 BeanDefinition</p>
<p>3.为BeanDefinition 添加一个构造方法的值，因为 MyBatis 的 MapperFactoryBean 有一个有参构造方法，Spring 在实例化这个对象的时候需要一个构造方法的值，这个值是一个 class，后面 Spring 在实例化过程中根据这个 class 返回我们的代理对象</p>
<h2 id="springbean-实例化之中和之后的工作">SpringBean 实例化之中和之后的工作：</h2>
<p>mybatis 主要利用 spring 的初始方法扩展点来完成对 mapper 信息的初始化，比如 sql 语句的初始化。这里的 spring 扩展点主要就是 afterPropertiesSet，说白了就是利用 MapperFactoryBean 去实现 InitializingBean 接口，由于 MapperFactoryBean 是一个 FactoryBean，我们理解为就是一个 mapper，把 &lt;id,object&gt; 缓存到 map 中。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MyBatis系列（一）MyBatis日志]]></title>
        <id>https://epitomm.github.io/post/spring-xi-lie-shi-san-mybatis-ri-zhi/</id>
        <link href="https://epitomm.github.io/post/spring-xi-lie-shi-san-mybatis-ri-zhi/">
        </link>
        <updated>2020-05-18T13:50:22.000Z</updated>
        <content type="html"><![CDATA[<h1 id="mybatis-入门">MyBatis 入门</h1>
<p>MyBatis 官网：<a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a></p>
<h2 id="先从一个测试类开始">先从一个测试类开始</h2>
<pre><code class="language-java">public interface IndexDao {
    @Select(&quot;select * from t1&quot;)
    List&lt;Map&lt;String,Object&gt;&gt; list();
}
</code></pre>
<pre><code class="language-java">@Service
public class IndexService {
    @Autowired
    IndexDao indexDao;
    public List&lt;Map&lt;String,Object&gt;&gt; list(){
        return indexDao.list();
    }
}
</code></pre>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
@MapperScan(&quot;com.ssm.dao&quot;)
public class AppConfig{
    @Bean
    public DataSource dataSource(){
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
        dataSource.setUsername(&quot;root&quot;);
        dataSource.setPassword(&quot;123456&quot;);
        dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/t1&quot;);
        return dataSource;
    }
    @Bean
    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){
        SqlSessionFactoryBean sqlSessionFactoryBean =  new SqlSessionFactoryBean();
         // 配置日志打印 SQL
        org.apache.ibatis.session.Configuration configuration = new org.apache.ibatis.session.Configuration();
        configuration.setLogImpl(Log4jImpl.class);
        sqlSessionFactoryBean.setConfiguration(configuration);
        // -- 日志打印 SQL 结束
        sqlSessionFactoryBean.setDataSource(dataSource);
        return sqlSessionFactoryBean;
    }
}
</code></pre>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext configApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
        List&lt;Map&lt;String, Object&gt;&gt; list = configApplicationContext.getBean(IndexService.class).list();
        System.out.println(list);
    }
}
</code></pre>
<pre><code># 全局日志配置
log4j.rootLogger=DEBUG, stdout
# MyBatis 日志配置
log4j.logger.com.ssm.IndexDao=TRACE
# 控制台输出
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n
</code></pre>
<p>日志打印结果：</p>
<pre><code>五月 18, 2020 8:47:01 下午 org.springframework.context.support.AbstractApplicationContext prepareRefresh
信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@433c675d: startup date [Mon May 18 20:47:01 CST 2020]; root of context hierarchy
五月 18, 2020 8:47:01 下午 org.springframework.jdbc.datasource.DriverManagerDataSource setDriverClassName
信息: Loaded JDBC driver: com.mysql.jdbc.Driver
DEBUG [main] - Logging initialized using 'class org.apache.ibatis.logging.log4j.Log4jImpl' adapter.
DEBUG [main] - Creating a new SqlSession
DEBUG [main] - SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@445b295b] was not registered for synchronization because synchronization is not active
DEBUG [main] - JDBC Connection [com.mysql.jdbc.JDBC4Connection@a2431d0] will not be managed by Spring
DEBUG [main] - ==&gt;  Preparing: select * from t1 
DEBUG [main] - ==&gt; Parameters: 
DEBUG [main] - &lt;==      Total: 9
DEBUG [main] - Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@445b295b]
[{a=1, b=11, c=4, d=1, e=a}, {a=2, b=2, c=2, d=2, e=b}, {a=3, b=3, c=2, d=2, e=c}, {a=4, b=3, c=1, d=1, e=d}, {a=5, b=2, c=3, d=5, e=e}, {a=6, b=6, c=4, d=4, e=6}, {a=7, b=4, c=5, d=5, e=g}, {a=8, b=8, c=8, d=8, e=h}, {a=9, b=9, c=9, d=9, e=i}]
</code></pre>
<h1 id="mybatis的日志技术实现">mybatis的日志技术实现</h1>
<h2 id="初始化">初始化</h2>
<h3 id="orgapacheibatislogginglogfactory">org.apache.ibatis.logging.LogFactory</h3>
<p><img src="https://epitomm.github.io/post-images/logFactory_static.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/tryImplementation.png" alt="图片" loading="lazy"></p>
<pre><code class="language-java">tryImplementation(new Runnable() {
  @Override
  public void run() {
    useSlf4jLogging();
  }
});
</code></pre>
<p>方法中的 runnable 参数是 new Runnable() 对象，run() 方法里面调用了 useSlf4jLogging() 方法，使用 SLF4J 日志。关键代码  **   if (logConstructor == null)****,**没有找到实现则继续找</p>
<pre><code class="language-java">private static void tryImplementation(Runnable runnable) {
  if (logConstructor == null) {
    try {
      runnable.run();
    } catch (Throwable t) {
      // ignore
    }
  }
}
</code></pre>
<p>调用 setImplementation 方法，传参 Slf4jImpl ：</p>
<pre><code class="language-java">public static synchronized void useSlf4jLogging() {
  setImplementation(org.apache.ibatis.logging.slf4j.Slf4jImpl.class);
}
</code></pre>
<p>LogFactory#setImplementation</p>
<pre><code class="language-java">private static void setImplementation(Class&lt;? extends Log&gt; implClass) {
  try {
    //  通过参数 implClass 得到构造方法
    Constructor&lt;? extends Log&gt; candidate = implClass.getConstructor(String.class);
    //  通过构造方法 new 出来对象
    Log log = candidate.newInstance(LogFactory.class.getName());
    if (log.isDebugEnabled()) {
      log.debug(&quot;Logging initialized using '&quot; + implClass + &quot;' adapter.&quot;);
    }
    // 将构造方法赋值给全局变量：private static Constructor&lt;? extends Log&gt; logConstructor;
    logConstructor = candidate;
  } catch (Throwable t) {
    throw new LogException(&quot;Error setting Log implementation.  Cause: &quot; + t, t);
  }
}
</code></pre>
<p>上述代码第 6 行，调用 Slf4jImpl 的构造方法：</p>
<pre><code class="language-java">public Slf4jImpl(String clazz) {
  Logger logger = LoggerFactory.getLogger(clazz);
  if (logger instanceof LocationAwareLogger) {
    try {
      // check for slf4j &gt;= 1.6 method signature
      logger.getClass().getMethod(&quot;log&quot;, Marker.class, String.class, int.class, String.class, Object[].class, Throwable.class);
      log = new Slf4jLocationAwareLoggerImpl((LocationAwareLogger) logger);
      return;
    } catch (SecurityException e) {
      // fail-back to Slf4jLoggerImpl
    } catch (NoSuchMethodException e) {
      // fail-back to Slf4jLoggerImpl
    }
  }
  // Logger is not LocationAwareLogger or slf4j version &lt; 1.6
  log = new Slf4jLoggerImpl(logger);
}
</code></pre>
<p>在执行过程中发现，上述代码执行到第 2 行就返回了，因为项目中并未添加 SLF4J 依赖。于是抛出异常，执行 static 块的 useCommonsLogging。</p>
<h2 id="总结">总结</h2>
<p>MyBatis 日志使用顺序： SLF4J、JCL、Log4J2、JUL、NO</p>
<p>如果没有引入 SLF4J，就会使用 JCL，因为 spring-context 默认内置 JCL。</p>
<h2 id="日志打印-sql">日志打印 SQL</h2>
<pre><code class="language-java">@Service
public class IndexService {
    @Autowired
    IndexDao indexDao;
    public List&lt;Map&lt;String,Object&gt;&gt; list(){
        // 将代码添加在这里无法打印 SQL
        org.apache.ibatis.logging.LogFactory.useLog4JLogging();
        return indexDao.list();
    }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0SQL.png" alt="图片" loading="lazy"></figure>
<p><strong>打印 SQL 语句是一个 proxy 代理对象</strong>，这个代理对象在 Spring 初始化时利用 Registrar 创建的，但是在创建这个 proxy 之前是没有任何日志的，而 useLog4J() 这个方法是在后面使用的，于是在 proxy 里面无法得到 log4j 对象，为什么创建时可以使用？因为 Spring 实例化过程 比 MyBatis 实例化的过程早，Spring 实例化 Service 时已经告诉 MyBatis 要使用 log4j 了，当创建 MyBatis 工厂时，可以直接打印日志，但是<strong>代理对象在 useLog4JLogging() 方法之前</strong>，所以不知道到底要使用哪个日志。实例化 indexDao 这个代理对象，包含一个日志对象 Log logger，但是在创建 BeanDefinition 之前，不知道要使用哪个 Log，所以 logger=null。</p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0SQL_2.png" alt="图片" loading="lazy"></figure>
<p>需要将 org.apache.ibatis.logging.LogFactory.useLog4JLogging(); 写在 Spring 初始化之前，告诉 MyBatis 要使用 log4J，当产生代理对象时，就知道要使用 log4j 日志了，代理对象中就有了 Log logger = new Log4JLogger();对象。</p>
<p>一个对象要记录日志：logger.info()，证明代理对象 proxy 要包含一个 Log logger， proxy 被 new 出来的过程中，MyBatis 不知道它要使用什么日志，所以就不记录日志，即 logger=null。</p>
<p>如果在 proxy 之前让 proxy 使用 Log4J，在产生这个代理对象之前，Log logger = new Log4JLogger();</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
         // 在 Spring 初始化前设置使用的日志
        org.apache.ibatis.logging.LogFactory.useLog4JLogging();
        AnnotationConfigApplicationContext configApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
        List&lt;Map&lt;String, Object&gt;&gt; list = configApplicationContext.getBean(IndexService.class).list();
        System.out.println(list);
    }
}
</code></pre>
<p>LogFactory#useLog4JLogging -&gt; LogFactory#setImplementation：给构造方法赋值logConstructor = candidate;</p>
<h3 id="在使用日志时如何得到-logger">在使用日志时如何得到 logger？</h3>
<pre><code class="language-java">private static final Log LOGGER = LogFactory.getLog(SqlSessionFactoryBean.class);
</code></pre>
<pre><code class="language-java">public static Log getLog(Class&lt;?&gt; aClass) {
  return getLog(aClass.getName());
}
</code></pre>
<p>调用 logConstructor.newInstance(logger); logConstructor 即之前赋的值 candidate：</p>
<pre><code class="language-java">public static Log getLog(String logger) {
  try {
    return logConstructor.newInstance(logger);
  } catch (Throwable t) {
    throw new LogException(&quot;Error creating logger for logger &quot; + logger + &quot;.  Cause: &quot; + t, t);
  }
}
</code></pre>
<p>日志打印：</p>
<pre><code>DEBUG [main] - Property 'configuration' or 'configLocation' not specified, using default MyBatis Configuration
DEBUG [main] - Property 'mapperLocations' was not specified or no matching resources found
DEBUG [main] - Creating a new SqlSession
DEBUG [main] - SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@445b295b] was not registered for synchronization because synchronization is not active
DEBUG [main] - JDBC Connection [com.mysql.jdbc.JDBC4Connection@a2431d0] will not be managed by Spring
DEBUG [main] - ==&gt;  Preparing: select * from t1 
DEBUG [main] - ==&gt; Parameters: 
DEBUG [main] - &lt;==      Total: 9
DEBUG [main] - Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@445b295b]
[{a=1, b=11, c=4, d=1, e=a}, {a=2, b=2, c=2, d=2, e=b}, {a=3, b=3, c=2, d=2, e=c}, {a=4, b=3, c=1, d=1, e=d}, {a=5, b=2, c=3, d=5, e=e}, {a=6, b=6, c=4, d=4, e=6}, {a=7, b=4, c=5, d=5, e=g}, {a=8, b=8, c=8, d=8, e=h}, {a=9, b=9, c=9, d=9, e=i}]
</code></pre>
<h2 id="mybatisspring5log4j-没有日志打印">MyBatis+Spring5+Log4J 没有日志打印</h2>
<pre><code class="language-xml">&lt;dependencies&gt;
  &lt;!-- spring-core --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.0.9.RELEASE&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;!-- spring 连接池 --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;version&gt;5.0.9.RELEASE&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;!-- mybatis --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
    &lt;version&gt;3.4.6&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;!-- mybatis-spring --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;1.3.2&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;!-- mysql-connector-java --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;5.1.46&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;!-- log4j --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.17&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
@MapperScan(&quot;com.ssm.dao&quot;)
public class AppConfig{
    @Bean
    public DataSource dataSource(){
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
        dataSource.setUsername(&quot;root&quot;);
        dataSource.setPassword(&quot;123456&quot;);
        dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/t1&quot;);
        return dataSource;
    }
    @Bean
    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){
        SqlSessionFactoryBean sqlSessionFactoryBean =  new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource);
        return sqlSessionFactoryBean;
    }
}
</code></pre>
<p><img src="https://epitomm.github.io/post-images/%E6%B2%A1%E6%9C%89%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/Spring5_static.png" alt="图片" loading="lazy"></p>
<p>如果想在 Spring5+MyBatis+log4j 打印 log4j 日志，方法一：改变 JUL 的默认级别，但是 JUL 的默认级别不能改变；方法二：扩展 MyBatis。</p>
<h3 id="方法一改变-jul-默认级别">方法一：改变 JUL 默认级别</h3>
<p>由于 Spring5 内置 spring-jcl，spring-jcl+log4j 打印 JUL 日志。</p>
<pre><code class="language-java">private static void setImplementation(Class&lt;? extends Log&gt; implClass) {
  try {
    Constructor&lt;? extends Log&gt; candidate = implClass.getConstructor(String.class);
    Log log = candidate.newInstance(LogFactory.class.getName());
    // 判断能不能打印日志,MyBatis在记录日志时，要判断级别是不是DEBUG级别，如果是DEBUG级别才会记录；否则不会记录。
    if (log.isDebugEnabled()) {
      // 因为这是 debug 信息
      log.debug(&quot;Logging initialized using '&quot; + implClass + &quot;' adapter.&quot;);
    }
    logConstructor = candidate;
  } catch (Throwable t) {
    throw new LogException(&quot;Error setting Log implementation.  Cause: &quot; + t, t);
  }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/Spring5_JUL.png" alt="图片" loading="lazy"></figure>
<p>由于 JCL 是一个接口，真实调用了 JUL 或 log4j 的日志打印，所以会判断 JUL 或 lo4j 的级别是否是 DEBUG 级别。</p>
<p>JakartaCommonsLoggingImpl#isDebugEnabled</p>
<pre><code class="language-java">@Override
public boolean isDebugEnabled() {
  return log.isDebugEnabled();
}
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E5%88%A4%E6%96%ADJUL%E7%BA%A7%E5%88%AB.png" alt="图片" loading="lazy"></figure>
<p>判断 JUL 是否是 DEBUG 级别，会返回 false，因为 JUL 日志级别是写死的，不是 DEBUG；</p>
<p>但如果是 log4j，由于 lo4j 是自己在 .properties 文件内配置的，可配置级别为 DEBUG。</p>
<pre><code class="language-plain">log4j.rootLogger=DEBUG, stdout
</code></pre>
<p>JavaUtilLog#isDebugEnabled</p>
<pre><code class="language-java">public boolean isDebugEnabled() {
   return this.logger.isLoggable(java.util.logging.Level.FINE);
}
</code></pre>
<p>可以将源码中的 java.util.logging.Level.FINE 更改，来改变 JUL 的日志级别。</p>
<pre><code class="language-java">private transient java.util.logging.Logger logger;
</code></pre>
<p>MyBatis - JCL - JavaUtilLog - JUL(java.util.logging.Logger)<br>
<img src="https://epitomm.github.io/post-images/JUL%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="图片" loading="lazy"></p>
<h3 id="方法二扩展-mybatis">方法二：扩展 MyBatis</h3>
<p>可以传值一个优先级比 500 高的日志级别。</p>
<p>官方文档：<a href="https://mybatis.org/mybatis-3/zh/logging.html">https://mybatis.org/mybatis-3/zh/logging.html</a></p>
<h2 id="mybatisspring4log4j-有日志打印">MyBatis+Spring4+Log4J 有日志打印</h2>
<p>如果将上述 Spring5 改为 Spring4，可以打印日志。因为在Spring4中：Spring+MyBatis+log4j</p>
<p>Spring4 内置 JCL，Spring4+log4j = log4j，所以变成了 MyBatis+log4j，所以打印 log4j 日志。</p>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/%E6%9C%89%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0.png" alt="图片" loading="lazy"></figure>
<h2 id="mybatis-如何解析-mapper">MyBatis 如何解析 mapper</h2>
<ul>
<li>resource：<mapper resource=""></li>
<li>url：<mapper url=""></li>
<li>class：<mapper class=""></li>
<li>package：<package name=""></li>
</ul>
<h2 id="mybatis-log4j-打印-log4j-日志">MyBatis + Log4J 打印 Log4J 日志</h2>
<pre><code class="language-xml">&lt;dependencies&gt;
  &lt;!-- spring-core --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.0.9.RELEASE&lt;/version&gt;
    &lt;!-- 剔除 spring-jcl 依赖 --&gt;
    &lt;exclusions&gt;
      &lt;exclusion&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-jcl&lt;/artifactId&gt;
      &lt;/exclusion&gt;
    &lt;/exclusions&gt;
  &lt;/dependency&gt;
  &lt;!-- spring 连接池 --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;version&gt;5.0.9.RELEASE&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;!-- mybatis --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
    &lt;version&gt;3.4.6&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;!-- mybatis-spring --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;1.3.2&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;!-- mysql-connector-java --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;5.1.46&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;!-- log4j --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.17&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/t1&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
&lt;!--        &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;--&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws IOException {
        String resource = &quot;mybatis-config.xml&quot;;
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        SqlSession sqlSession = sqlSessionFactory.openSession();
        sqlSession.getConfiguration().addMapper(IndexDao.class);
        IndexDao mapper = sqlSession.getMapper(IndexDao.class);
        System.out.println(mapper.list());
    }
}
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E6%9C%89%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0_2.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/log4j%E4%BE%9D%E8%B5%96.png" alt="图片" loading="lazy"></figure>
<h2 id="具体实现类">具体实现类</h2>
<p>mybatis提供很多日志的实现类,用来记录日志,取决于初始化的时候load到的class</p>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/MyBatis%E6%97%A5%E5%BF%97%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%B1%BB.png" alt="图片" loading="lazy"></figure>
<pre><code>上图红色箭头可以看到 JakartaCommonsLoggingImpl 中引用了 jcl 的类,如果在初始化的时候load到类为JakartaCommonsLoggingImpl，
那么则使用 jcl 去实现日志记录,但是也是顺序的,顺序参考源码
</code></pre>
<h2 id="自己模拟实现mybaits的日志实现">自己模拟实现mybaits的日志实现</h2>
<pre><code>mybatis的官网关于日志的介绍
定义org.apache.ibatis.session.Configuration
参考org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl
分析为什么jcl不记录日志,修改代码
</code></pre>
<h1 id="架构系统如何考虑日志">架构系统如何考虑日志</h1>
<p>old:jcl+log4j</p>
<p>new:slf4j+jul</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring系列（十二）Spring5新特性——日志]]></title>
        <id>https://epitomm.github.io/post/spring-xi-lie-shi-er-spring-ri-zhi/</id>
        <link href="https://epitomm.github.io/post/spring-xi-lie-shi-er-spring-ri-zhi/">
        </link>
        <updated>2020-05-18T05:50:22.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>各种日志技术的关系和作用</li>
<li>通过源码来分析spring的日志技术</li>
<li>commons-logging源码分析</li>
<li>通过源码分析mybaits的日志技术</li>
<li>架构系统时候如何选择、优化日志技术</li>
</ul>
<h1 id="先从一个-spring-日志开始">先从一个 Spring 日志开始</h1>
<p>1、配置文件引入 spring-context</p>
<pre><code class="language-xml">&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.0.9.RELEASE&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>2、一个 配置类</p>
<pre><code class="language-java">@Configuration
@Component(&quot;com.ssm&quot;)
public class AppConfig {
}
</code></pre>
<p>3、一个 Service</p>
<pre><code class="language-java">@Service
public class IndexService {
    public void query(){
        System.out.println(&quot;query...&quot;);
    }
}
</code></pre>
<p>4、测试类</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext configApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
        configApplicationContext.start();
    }
}
</code></pre>
<p>5、日志打印如下：</p>
<pre><code>五月 17, 2020 12:02:07 下午 org.springframework.context.support.AbstractApplicationContext prepareRefresh
信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@7e6cbb7a: startup date [Sun May 17 12:02:07 CST 2020]; root of context hierarchy
</code></pre>
<h2 id="spring4-spring5-日志打印">Spring4、Spring5 日志打印</h2>
<p>接下来开始分析这个日志如何打印出来的</p>
<p>先从日志打印 AbstractApplicationContext 类开始：</p>
<pre><code class="language-java">protected void prepareRefresh() {
   this.startupDate = System.currentTimeMillis();
   this.closed.set(false);
   this.active.set(true);
   if (logger.isInfoEnabled()) {
      logger.info(&quot;Refreshing &quot; + this);
   }
   // Initialize any placeholder property sources in the context environment
   initPropertySources();
   // Validate that all properties marked as required are resolvable
   // see ConfigurablePropertyResolver#setRequiredProperties
   getEnvironment().validateRequiredProperties();
   // Allow for the collection of early ApplicationEvents,
   // to be published once the multicaster is available...
   this.earlyApplicationEvents = new LinkedHashSet&lt;&gt;();
}
</code></pre>
<p>上述代码第6 行打印 Refreshing：即我们上面看到的日志打印结果，这里调用了 logger.info()，那么我们来看看这个 logger 到底是什么？先来剧透一下：其实它是一个 JUL。</p>
<pre><code class="language-java">protected final Log logger = LogFactory.getLog(getClass());
</code></pre>
<p>由于 JUL 是 JDK 的，很难去修改它的打印格式，于是我们想把日志打印换成 log4j，于是我们在 xml 中加上 log4j 依赖，如下：</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;log4j&lt;/groupId&gt;
  &lt;artifactId&gt;log4j&lt;/artifactId&gt;
  &lt;version&gt;1.2.17&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>log4j 配置文件：</p>
<pre><code class="language-prolog">log4j.rootLogger=ERROR,stdout
# 输出到控制台
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.target=System.out
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss,SSS} %p [%t] %C.%M(%L) | %m%n
</code></pre>
<p>结果却发现，即使加上了 log4j 依赖，日志却仍然使用 JUL 打印</p>
<pre><code>五月 17, 2020 12:13:10 下午 org.springframework.context.support.AbstractApplicationContext prepareRefresh
信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@7106e68e: startup date [Sun May 17 12:13:09 CST 2020]; root of context hierarchy
</code></pre>
<p>当将 Spring 版本更改为 4.x.x 后，上述代码成功打印了 log4j 日志：</p>
<pre><code class="language-java">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
  &lt;version&gt;4.3.16.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>由于 log4j 内配置只打印 ERROR 级别的日志，由于没有 ERROR，所以日志打印为空。</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/log4j%E6%97%A5%E5%BF%97.png" alt="图片" loading="lazy"></figure>
<h1 id="主流的log技术名词">主流的log技术名词</h1>
<h2 id="1log4j">1.log4j</h2>
<ul>
<li>可以不需要依赖第三方的技术</li>
<li>直接记录日志</li>
</ul>
<p>（1）引入依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;log4j&lt;/groupId&gt;
  &lt;artifactId&gt;log4j&lt;/artifactId&gt;
  &lt;version&gt;1.2.17&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>（2）配置</p>
<pre><code class="language-java">log4j.rootLogger=INFO,stdout
# 输出到控制台
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.target=System.out
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss,SSS} %p [%t] %C.%M(%L) | %m%n
</code></pre>
<p>（3）测试类</p>
<pre><code class="language-java">import org.apache.log4j.Logger;
public class Log4j {
    public static void main(String[] args) {
        Logger logger = Logger.getLogger(&quot;log4j&quot;);
        logger.info(&quot;log4j&quot;);
    }
}
</code></pre>
<p>（4）日志打印：</p>
<pre><code>2020-05-17 12:44:41,453 INFO [main] com.ssm.utils.Log4j.main(9) | log4j
</code></pre>
<h2 id="2jul">2.jul</h2>
<p>java自带的一个日志记录的技术,直接使用</p>
<pre><code class="language-java">import java.util.logging.Logger;
public class JUL {
    public static void main(String[] args) {
        Logger logger = Logger.getLogger(&quot;jul&quot;);
        logger.info(&quot;jul&quot;);
    }
}
</code></pre>
<p>打印结果：</p>
<pre><code>五月 17, 2020 12:45:59 下午 com.ssm.utils.JUL main
信息: jul
</code></pre>
<h2 id="3jcl">3.jcl</h2>
<p>jakartaCommonsLoggingImpl</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;commons-logging&lt;/groupId&gt;
    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
    &lt;version&gt;1.1.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>jcl他不直接记录日志,他是通过第三方记录日志(jul、log4j)</li>
<li>如果使用jcl来记录日志,在没有log4j的依赖情况下,使用jul</li>
<li>如果有了log4j则使用log4j</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/JCL%E6%97%A5%E5%BF%97.png" alt="图片" loading="lazy"></figure>
<h3 id="log4j">log4j</h3>
<p>当有 log4j 依赖时，JCL 日志使用 log4j 打印：</p>
<pre><code class="language-java">public class JCL {
    public static void main(String[] args) {
        Log log = LogFactory.getLog(&quot;jcl&quot;);
        log.info(&quot;jcl&quot;);
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/JCL_log4j.png" alt="图片" loading="lazy"></figure>
<p>日志打印：</p>
<pre><code>2020-05-17 12:50:04,813 INFO [main] com.ssm.utils.JCL.main(9) | jcl
</code></pre>
<h4 id="分析">分析</h4>
<p>LogFactory#getLog</p>
<pre><code class="language-java">public static Log getLog(String name) throws LogConfigurationException {
    return getFactory().getInstance(name);
}
</code></pre>
<p>LogFactoryImpl#getInstance</p>
<pre><code class="language-java">public Log getInstance(String name) throws LogConfigurationException {
    Log instance = (Log) instances.get(name);
    if (instance == null) {
        instance = newInstance(name);
        instances.put(name, instance);
    }
    return instance;
}
</code></pre>
<p>上述代码第 4 行：<br>
LogFactoryImpl#newInstance</p>
<pre><code class="language-java">protected Log newInstance(String name) throws LogConfigurationException {
    Log instance;
    try {
        if (logConstructor == null) {
            instance = discoverLogImplementation(name);
        }
        else {
            Object params[] = { name };
            instance = (Log) logConstructor.newInstance(params);
        }
        if (logMethod != null) {
            Object params[] = { this };
            logMethod.invoke(instance, params);
        }
        return instance;
    } catch (LogConfigurationException lce) {
        // this type of exception means there was a problem in discovery
        // and we've already output diagnostics about the issue, etc.;
        // just pass it on
        throw lce;
    } catch (InvocationTargetException e) {
        // A problem occurred invoking the Constructor or Method
        // previously discovered
        Throwable c = e.getTargetException();
        throw new LogConfigurationException(c == null ? e : c);
    } catch (Throwable t) {
        handleThrowable(t); // may re-throw t
        // A problem occurred invoking the Constructor or Method
        // previously discovered
        throw new LogConfigurationException(t);
    }
}
</code></pre>
<p>LogFactoryImpl#discoverLogImplementation</p>
<pre><code class="language-java">private Log discoverLogImplementation(String logCategory)
    throws LogConfigurationException {
    if (isDiagnosticsEnabled()) {
        logDiagnostic(&quot;Discovering a Log implementation...&quot;);
    }
    initConfiguration();
    Log result = null;
    // See if the user specified the Log implementation to use
    String specifiedLogClassName = findUserSpecifiedLogClassName();
    if (specifiedLogClassName != null) {
        if (isDiagnosticsEnabled()) {
            logDiagnostic(&quot;Attempting to load user-specified log class '&quot; +
                specifiedLogClassName + &quot;'...&quot;);
        }
        result = createLogFromClass(specifiedLogClassName,
                                    logCategory,
                                    true);
        if (result == null) {
            StringBuffer messageBuffer =  new StringBuffer(&quot;User-specified log class '&quot;);
            messageBuffer.append(specifiedLogClassName);
            messageBuffer.append(&quot;' cannot be found or is not useable.&quot;);
            // Mistyping or misspelling names is a common fault.
            // Construct a good error message, if we can
            informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_LOG4J_LOGGER);
            informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_JDK14_LOGGER);
            informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_LUMBERJACK_LOGGER);
            informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_SIMPLE_LOGGER);
            throw new LogConfigurationException(messageBuffer.toString());
        }
        return result;
    }
    // No user specified log; try to discover what's on the classpath
    //
    // Note that we deliberately loop here over classesToDiscover and
    // expect method createLogFromClass to loop over the possible source
    // classloaders. The effect is:
    //   for each discoverable log adapter
    //      for each possible classloader
    //          see if it works
    //
    // It appears reasonable at first glance to do the opposite:
    //   for each possible classloader
    //     for each discoverable log adapter
    //        see if it works
    //
    // The latter certainly has advantages for user-installable logging
    // libraries such as log4j; in a webapp for example this code should
    // first check whether the user has provided any of the possible
    // logging libraries before looking in the parent classloader.
    // Unfortunately, however, Jdk14Logger will always work in jvm&gt;=1.4,
    // and SimpleLog will always work in any JVM. So the loop would never
    // ever look for logging libraries in the parent classpath. Yet many
    // users would expect that putting log4j there would cause it to be
    // detected (and this is the historical JCL behaviour). So we go with
    // the first approach. A user that has bundled a specific logging lib
    // in a webapp should use a commons-logging.properties file or a
    // service file in META-INF to force use of that logging lib anyway,
    // rather than relying on discovery.
    if (isDiagnosticsEnabled()) {
        logDiagnostic(
            &quot;No user-specified Log implementation; performing discovery&quot; +
            &quot; using the standard supported logging implementations...&quot;);
    }
    for(int i=0; i&lt;classesToDiscover.length &amp;&amp; result == null; ++i) {
        result = createLogFromClass(classesToDiscover[i], logCategory, true);
    }
    if (result == null) {
        throw new LogConfigurationException
                    (&quot;No suitable Log implementation&quot;);
    }
    return result;
}
</code></pre>
<p>上述代码第 74 行：</p>
<pre><code class="language-java">result = createLogFromClass(classesToDiscover[i], logCategory, true);
</code></pre>
<pre><code class="language-java">private static final String[] classesToDiscover = {
        LOGGING_IMPL_LOG4J_LOGGER,
        &quot;org.apache.commons.logging.impl.Jdk14Logger&quot;,
        &quot;org.apache.commons.logging.impl.Jdk13LumberjackLogger&quot;,
        &quot;org.apache.commons.logging.impl.SimpleLog&quot;
};
</code></pre>
<pre><code class="language-java">private static final String LOGGING_IMPL_LOG4J_LOGGER = &quot;org.apache.commons.logging.impl.Log4JLogger&quot;;
</code></pre>
<p>当执行到 73 行，进行第 0 次 for 循环时，将 org.apache.commons.logging.impl.Log4JLogger 作为第一个参数传递给 createLogFromClass 方法：</p>
<pre><code class="language-java">private Log createLogFromClass(String logAdapterClassName,
                               String logCategory,
                               boolean affectState)
    throws LogConfigurationException {
    if (isDiagnosticsEnabled()) {
        logDiagnostic(&quot;Attempting to instantiate '&quot; + logAdapterClassName + &quot;'&quot;);
    }
    Object[] params = { logCategory };
    Log logAdapter = null;
    Constructor constructor = null;
    Class logAdapterClass = null;
    ClassLoader currentCL = getBaseClassLoader();
    for(;;) {
        // Loop through the classloader hierarchy trying to find
        // a viable classloader.
        logDiagnostic(&quot;Trying to load '&quot; + logAdapterClassName + &quot;' from classloader &quot; + objectId(currentCL));
        try {
            if (isDiagnosticsEnabled()) {
                // Show the location of the first occurrence of the .class file
                // in the classpath. This is the location that ClassLoader.loadClass
                // will load the class from -- unless the classloader is doing
                // something weird.
                URL url;
                String resourceName = logAdapterClassName.replace('.', '/') + &quot;.class&quot;;
                if (currentCL != null) {
                    url = currentCL.getResource(resourceName );
                } else {
                    url = ClassLoader.getSystemResource(resourceName + &quot;.class&quot;);
                }
                if (url == null) {
                    logDiagnostic(&quot;Class '&quot; + logAdapterClassName + &quot;' [&quot; + resourceName + &quot;] cannot be found.&quot;);
                } else {
                    logDiagnostic(&quot;Class '&quot; + logAdapterClassName + &quot;' was found at '&quot; + url + &quot;'&quot;);
                }
            }
            Class c;
            try {
                c = Class.forName(logAdapterClassName, true, currentCL);
            } catch (ClassNotFoundException originalClassNotFoundException) {
                // The current classloader was unable to find the log adapter
                // in this or any ancestor classloader. There's no point in
                // trying higher up in the hierarchy in this case..
                String msg = originalClassNotFoundException.getMessage();
                logDiagnostic(&quot;The log adapter '&quot; + logAdapterClassName + &quot;' is not available via classloader &quot; +
                              objectId(currentCL) + &quot;: &quot; + msg.trim());
                try {
                    // Try the class classloader.
                    // This may work in cases where the TCCL
                    // does not contain the code executed or JCL.
                    // This behaviour indicates that the application
                    // classloading strategy is not consistent with the
                    // Java 1.2 classloading guidelines but JCL can
                    // and so should handle this case.
                    c = Class.forName(logAdapterClassName);
                } catch (ClassNotFoundException secondaryClassNotFoundException) {
                    // no point continuing: this adapter isn't available
                    msg = secondaryClassNotFoundException.getMessage();
                    logDiagnostic(&quot;The log adapter '&quot; + logAdapterClassName +
                                  &quot;' is not available via the LogFactoryImpl class classloader: &quot; + msg.trim());
                    break;
                }
            }
            constructor = c.getConstructor(logConstructorSignature);
            Object o = constructor.newInstance(params);
            // Note that we do this test after trying to create an instance
            // [rather than testing Log.class.isAssignableFrom(c)] so that
            // we don't complain about Log hierarchy problems when the
            // adapter couldn't be instantiated anyway.
            if (o instanceof Log) {
                logAdapterClass = c;
                logAdapter = (Log) o;
                break;
            }
            // Oops, we have a potential problem here. An adapter class
            // has been found and its underlying lib is present too, but
            // there are multiple Log interface classes available making it
            // impossible to cast to the type the caller wanted. We
            // certainly can't use this logger, but we need to know whether
            // to keep on discovering or terminate now.
            //
            // The handleFlawedHierarchy method will throw
            // LogConfigurationException if it regards this problem as
            // fatal, and just return if not.
            handleFlawedHierarchy(currentCL, c);
        } catch (NoClassDefFoundError e) {
            // We were able to load the adapter but it had references to
            // other classes that could not be found. This simply means that
            // the underlying logger library is not present in this or any
            // ancestor classloader. There's no point in trying higher up
            // in the hierarchy in this case..
            String msg = e.getMessage();
            logDiagnostic(&quot;The log adapter '&quot; + logAdapterClassName +
                          &quot;' is missing dependencies when loaded via classloader &quot; + objectId(currentCL) +
                          &quot;: &quot; + msg.trim());
            break;
        } catch (ExceptionInInitializerError e) {
            // A static initializer block or the initializer code associated
            // with a static variable on the log adapter class has thrown
            // an exception.
            //
            // We treat this as meaning the adapter's underlying logging
            // library could not be found.
            String msg = e.getMessage();
            logDiagnostic(&quot;The log adapter '&quot; + logAdapterClassName +
                          &quot;' is unable to initialize itself when loaded via classloader &quot; + objectId(currentCL) +
                          &quot;: &quot; + msg.trim());
            break;
        } catch (LogConfigurationException e) {
            // call to handleFlawedHierarchy above must have thrown
            // a LogConfigurationException, so just throw it on
            throw e;
        } catch (Throwable t) {
            handleThrowable(t); // may re-throw t
            // handleFlawedDiscovery will determine whether this is a fatal
            // problem or not. If it is fatal, then a LogConfigurationException
            // will be thrown.
            handleFlawedDiscovery(logAdapterClassName, currentCL, t);
        }
        if (currentCL == null) {
            break;
        }
        // try the parent classloader
        // currentCL = currentCL.getParent();
        currentCL = getParentClassLoader(currentCL);
    }
    if (logAdapterClass != null &amp;&amp; affectState) {
        // We've succeeded, so set instance fields
        this.logClassName   = logAdapterClassName;
        this.logConstructor = constructor;
        // Identify the &lt;code&gt;setLogFactory&lt;/code&gt; method (if there is one)
        try {
            this.logMethod = logAdapterClass.getMethod(&quot;setLogFactory&quot;, logMethodSignature);
            logDiagnostic(&quot;Found method setLogFactory(LogFactory) in '&quot; + logAdapterClassName + &quot;'&quot;);
        } catch (Throwable t) {
            handleThrowable(t); // may re-throw t
            this.logMethod = null;
            logDiagnostic(&quot;[INFO] '&quot; + logAdapterClassName + &quot;' from classloader &quot; + objectId(currentCL) +
                          &quot; does not declare optional method &quot; + &quot;setLogFactory(LogFactory)&quot;);
        }
        logDiagnostic(&quot;Log adapter '&quot; + logAdapterClassName + &quot;' from classloader &quot; +
                      objectId(logAdapterClass.getClassLoader()) + &quot; has been selected for use.&quot;);
    }
    return logAdapter;
}
</code></pre>
<p>上述代码第 44 行</p>
<pre><code>c = Class.forName(logAdapterClassName, true, currentCL);
</code></pre>
<p>logAdapterClassName 是 createLogFromClass 方法的第一个参数  org.apache.commons.logging.impl.Log4JLogger<br>
Class c = Class.forName(&quot;org.apache.commons.logging.impl.Log4JLogger&quot;, true, currentCL);</p>
<p>如果能够得到这个 Class，c 就有值，因为当前有 log4j 依赖，所以能够得到 Log4JLogger 类。</p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/c.png" alt="图片" loading="lazy"></figure>
<p>上述代码第 70 行：</p>
<pre><code class="language-java">//  得到这个类的构造方法
constructor = c.getConstructor(logConstructorSignature);
// 创建一个实例对象
Object o = constructor.newInstance(params);
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/o.png" alt="图片" loading="lazy"></figure>
<p>上述代码第 77 行：把创建出来的实例对象 o 赋值给 logAdapter</p>
<pre><code class="language-java">if (o instanceof Log) {
    logAdapterClass = c;
    logAdapter = (Log) o;
    break;
}
</code></pre>
<p>第 158 行：返回实例化对象 logAdapter：</p>
<pre><code class="language-java">return logAdapter;
</code></pre>
<p>于是第一次 for 循环结束，result != null ，于是终止 for 循环</p>
<pre><code class="language-java">for(int i=0; i&lt;classesToDiscover.length &amp;&amp; result == null; ++i) {
    result = createLogFromClass(classesToDiscover[i], logCategory, true);
}
</code></pre>
<h3 id="jul">JUL</h3>
<p>当 pom.xml 内没有 log4j 依赖时，JCL 日志使用 JUL 打印：</p>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/JUL.png" alt="图片" loading="lazy"></figure>
<pre><code>五月 17, 2020 12:59:17 下午 jcl main
信息: jcl
</code></pre>
<p>Class c = Class.forName(&quot;org.apache.commons.logging.impl.Log4JLogger&quot;, true, currentCL);<br>
因为当前没有 log4j 依赖，所以不能得到 Log4JLogger 类，所以进入 catch (NoClassDefFoundError e){，logAdapter 没有被复制，最终返回 null。</p>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/logAdapter.png" alt="图片" loading="lazy"></figure>
<p>于是进入第 1 次循环：</p>
<pre><code class="language-java">for(int i=0; i&lt;classesToDiscover.length &amp;&amp; result == null; ++i) {
    result = createLogFromClass(classesToDiscover[i], logCategory, true);
}
</code></pre>
<p>classesToDiscover[1] = org.apache.commons.logging.impl.Jdk14Logger<br>
因为 Jdk14Logger 是JDK 内部自带的，所以执行第 1 次循环，返回的 result 一定有值。</p>
<p><img src="https://epitomm.github.io/post-images/c_2.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/logAdapter_2.png" alt="图片" loading="lazy"></p>
<h3 id="总结">总结</h3>
<pre><code>jcl=Jakarta commons-logging ,是apache公司开发的一个抽象日志通用框架,本身不实现日志记录,
但是提供了记录日志的抽象方法即接口(info,debug,error.......),底层通过一个数组存放具体的日志
框架的类名,然后循环数组依次去匹配这些类名是否在app中被依赖了,如果找到被依赖的则直接使用,所以他
有先后顺序。
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/jcl1.png" alt="图片" loading="lazy"></figure>
<pre><code>上图为jcl中存放日志技术类名的数组，默认有四个，后面两个可以忽略。
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/jcl0.png" alt="图片" loading="lazy"></figure>
<pre><code>上图81行就是通过一个类名去load一个class，如果load成功则直接new出来并且返回使用。
如果没有load到class这循环第二个，直到找到为止。
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/jcl2.png" alt="图片" loading="lazy"></figure>
<pre><code>可以看到这里的循环条件必须满足result不为空，
也就是如果没有找到具体的日志依赖则继续循环，如果找到则条件不成立，不进行循环了。
总结：顺序log4j&gt;jul
</code></pre>
<h2 id="为什么要引入-jcl">为什么要引入 JCL</h2>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/JCL.png" alt="图片" loading="lazy"></figure>
<p>如果要合并两个 app1 和 app2，其中 app1 使用 JUL 日志，app2 使用 lot4j 记录日志，就会出现：日志打印格式混乱问题。</p>
<p><img src="https://epitomm.github.io/post-images/%E4%B8%A4%E7%A7%8D%E6%97%A5%E5%BF%97.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/JCL%E7%9A%84%E4%BD%BF%E7%94%A8.png" alt="图片" loading="lazy"></p>
<p>如果使用 JCL，如果想使用 log4j 打印日志，只需引入 log4j 依赖；如果想使用 JUL 打印日志，只需删除 log4j 依赖即可。</p>
<h2 id="4log4j2">4.log4j2</h2>
<h2 id="5slf4j">5.slf4j</h2>
<p>slf4j官网：<a href="http://www.slf4j.org/">http://www.slf4j.org/</a></p>
<p><strong>slf4j他也不记录日志,通过绑定器绑定一个具体的日志记录来完成日志记录</strong></p>
<pre><code>log4j---&lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
</code></pre>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/slf4j.png" alt="图片" loading="lazy"></figure>
<h3 id="加入-slf4j-依赖">加入 slf4j 依赖</h3>
<pre><code class="language-xml">&lt;!-- slf4j --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
  &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
  &lt;version&gt;1.7.25&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- 绑定器：注绑定器版本号和 slf4j 版本号要一致 --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
  &lt;artifactId&gt;slf4j-jdk14&lt;/artifactId&gt;
  &lt;version&gt;1.7.25&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/slf4j%E6%94%AF%E6%8C%81%E7%9A%84%E6%97%A5%E5%BF%97%E7%BB%91%E5%AE%9A.png" alt="图片" loading="lazy"></figure>
<h3 id="模拟日志打印">模拟日志打印</h3>
<pre><code class="language-java">import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class SLF4J {
    public static void main(String[] args) {
        Logger logger = LoggerFactory.getLogger(&quot;slf4j&quot;);
        logger.info(&quot;slf4j&quot;);
    }
}
</code></pre>
<p>日志打印 JUL：</p>
<pre><code>五月 17, 2020 5:25:58 下午 com.ssm.utils.SLF4J main
信息: slf4j
</code></pre>
<p>当绑定 slf4j 时，</p>
<pre><code class="language-xml">&lt;!-- slf4j --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
    &lt;version&gt;1.7.25&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- 绑定器：log4j --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
    &lt;version&gt;1.7.25&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>日志打印是 log4j 形式：</p>
<pre><code>2020-05-17 17:30:47,801 INFO [main] com.ssm.utils.SLF4J.main(9) | slf4j
</code></pre>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/%E4%B8%8D%E5%90%8C%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0.png" alt="图片" loading="lazy"></figure>
<p>如果想统一日志格式为 log4j，只需修改 app1 的绑定器，使它绑定 log4j 即可，如下图所示：</p>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/%E7%BB%9F%E4%B8%80%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E4%B8%BAlog4j.png" alt="图片" loading="lazy"></figure>
<p>如果想统一日志格式为 JUL ：① 可删除 Spring 内的 log4j 依赖，JCL 就自动使用 JCL 了。</p>
<p>② 为 Spring 添加桥接器，通过桥接器把它桥接到 slf4j，然后再绑定 JUL，就能打印 JUL 了，如下图所示：</p>
<figure data-type="image" tabindex="16"><img src="https://epitomm.github.io/post-images/%E7%BB%9F%E4%B8%80%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E4%B8%BAJUL.png" alt="图片" loading="lazy"></figure>
<h3 id="模拟">模拟</h3>
<h4 id="两种日志打印">两种日志打印</h4>
<p>Sring 使用 JCL，且有 log4j，即 Spring 使用 log4j 日志打印。</p>
<p>App1 使用 slf4j ，绑定器绑定 JUL 日志打印。</p>
<pre><code class="language-xml">  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
      &lt;version&gt;4.3.16.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- 绑定器：JUL --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
      &lt;artifactId&gt;slf4j-jdk14&lt;/artifactId&gt;
      &lt;version&gt;1.7.25&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- log4j --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;log4j&lt;/groupId&gt;
      &lt;artifactId&gt;log4j&lt;/artifactId&gt;
      &lt;version&gt;1.2.17&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- JCL --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;commons-logging&lt;/groupId&gt;
      &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
      &lt;version&gt;1.2&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;  
</code></pre>
<p>自己的 app 使用 slf4j 日志打印：</p>
<pre><code class="language-java">import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class SLF4J {
    public static void main(String[] args) {
        Logger logger = LoggerFactory.getLogger(&quot;slf4j&quot;);
        logger.info(&quot;slf4j&quot;);
    }
}
</code></pre>
<figure data-type="image" tabindex="17"><img src="https://epitomm.github.io/post-images/slf4j%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0.png" alt="图片" loading="lazy"></figure>
<p>Spring 使用 log4j 日志打印：</p>
<pre><code class="language-java">import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
public class TestSpringLog {
    public static void main(String[] args) {
        Log log = LogFactory.getLog(&quot;spring&quot;);
        log.info(&quot;spring...JCL&quot;);
    }
}
</code></pre>
<figure data-type="image" tabindex="18"><img src="https://epitomm.github.io/post-images/log4j%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0.png" alt="图片" loading="lazy"></figure>
<h4 id="统一日志打印">统一日志打印</h4>
<p>添加桥接器</p>
<pre><code class="language-xml">&lt;!-- 桥接器 --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
  &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;
  &lt;version&gt;1.7.25&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>运行：</p>
<pre><code class="language-java">import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
public class TestSpringLog {
    public static void main(String[] args) {
        Log log = LogFactory.getLog(&quot;spring&quot;);
        log.info(&quot;spring...JCL&quot;);
    }
}
</code></pre>
<figure data-type="image" tabindex="19"><img src="https://epitomm.github.io/post-images/%E4%BE%9D%E8%B5%96%E6%B7%B7%E4%B9%B1%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA.png" alt="图片" loading="lazy"></figure>
<p>Spring 日志打印也变成 JUL 了。</p>
<h3 id="依赖混乱导致内存溢出">依赖混乱导致内存溢出</h3>
<figure data-type="image" tabindex="20"><img src="https://epitomm.github.io/post-images/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA.png" alt="图片" loading="lazy"></figure>
<pre><code class="language-xml">&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;4.3.16.RELEASE&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;!-- slf4j --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
    &lt;version&gt;1.7.25&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;!-- 绑定器：JCL. slf4j 绑定到 JCL --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-jcl&lt;/artifactId&gt;
    &lt;version&gt;1.7.25&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;!-- 桥接器：JCL. JCL 桥接到 slf4j --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;
    &lt;version&gt;1.7.25&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>测试类：</p>
<pre><code class="language-java">import com.ssm.app.AppConfig;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
public class Test {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext configApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
        configApplicationContext.start();
        LoggerFactory.getLogger(&quot;ttt&quot;).info(&quot;test&quot;);
    }
}
</code></pre>
<p>运行结果：<br>
<img src="https://epitomm.github.io/post-images/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA.png" alt="图片" loading="lazy"></p>
<h2 id="6logback">6.logback</h2>
<h2 id="7simple-log">7.simple-log</h2>
<h1 id="各种日志技术的关系和作用">各种日志技术的关系和作用</h1>
<figure data-type="image" tabindex="21"><img src="https://epitomm.github.io/post-images/%E5%90%84%E7%A7%8D%E6%97%A5%E5%BF%97.png" alt="图片" loading="lazy"></figure>
<h1 id="spring日志技术分析">spring日志技术分析</h1>
<p>再来看一下开始的那个问题：Spring4 加上 log4j 就打印 log4j 日志；但是 Spring5 加上 log4j 仍打印 JUL 日志。</p>
<h2 id="spring4日志技术实现">spring4.*日志技术实现</h2>
<p>spring4当中依赖的是原生的jcl：commons-logging.jar</p>
<p><img src="https://epitomm.github.io/post-images/Spring4%E6%97%A5%E5%BF%97.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/Spring4%E5%BC%95%E5%85%A5log4j.png" alt="图片" loading="lazy"></p>
<p>上面的日志打印说是在org.springframework.context.support.AbstractApplicationContext.prepareRefresh(583) 内进行的日志打印：logger.info(&quot;Refreshing &quot; + this);</p>
<figure data-type="image" tabindex="22"><img src="https://epitomm.github.io/post-images/Spring%E7%89%88%E6%9C%AC%E5%8F%B7.png" alt="图片" loading="lazy"></figure>
<p>这里我们要查看的是 Spring4 的 AbstractApplicationContext，我们来看一下 AbstractApplicationContext#prepareRefresh</p>
<pre><code class="language-java">protected void prepareRefresh() {
   this.startupDate = System.currentTimeMillis();
   this.closed.set(false);
   this.active.set(true);
   if (logger.isInfoEnabled()) {
      logger.info(&quot;Refreshing &quot; + this);
   }
   // Initialize any placeholder property sources in the context environment
   initPropertySources();
   // Validate that all properties marked as required are resolvable
   // see ConfigurablePropertyResolver#setRequiredProperties
   getEnvironment().validateRequiredProperties();
   // Allow for the collection of early ApplicationEvents,
   // to be published once the multicaster is available...
   this.earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent&gt;();
}
</code></pre>
<figure data-type="image" tabindex="23"><img src="https://epitomm.github.io/post-images/Log4JLogger.png" alt="图片" loading="lazy"></figure>
<p>org.springframework.context.support.AbstractApplicationContext.prepareRefresh(583) 的 logger 对象是 Log4JLogger，所以打印 log4j 日志。</p>
<p>来看一个 logger 变量的定义：</p>
<pre><code class="language-java">protected final Log logger = LogFactory.getLog(getClass());
</code></pre>
<p>我们再来看一下这个 Log 对象，它是 JCL （org.apache.commons.logging）包下的，我们的 pom.xml 中并未引入 JCL 依赖，只引入了 spring-context 和 log4j 依赖，于是猜想 spring-context 中有 JCL 依赖。</p>
<pre><code class="language-java">package org.apache.commons.logging;
public interface Log {
</code></pre>
<p>看一下 maven 依赖图：<br>
<img src="https://epitomm.github.io/post-images/spring4maven%E4%BE%9D%E8%B5%96.png" alt="图片" loading="lazy"></p>
<p><strong>Spring4 当中依赖了 JCL，Spring4 中采用的日志技术是 JCL：commons-logging.jar</strong>。</p>
<p>LogFactory#getLog</p>
<pre><code class="language-java">public static Log getLog(Class clazz) throws LogConfigurationException {
    return getFactory().getInstance(clazz);
}
</code></pre>
<p>LogFactory#getFactory</p>
<pre><code class="language-java">public static LogFactory getFactory() throws LogConfigurationException {
    // Identify the class loader we will be using
    ClassLoader contextClassLoader = getContextClassLoaderInternal();
    if (contextClassLoader == null) {
        // This is an odd enough situation to report about. This
        // output will be a nuisance on JDK1.1, as the system
        // classloader is null in that environment.
        if (isDiagnosticsEnabled()) {
            logDiagnostic(&quot;Context classloader is null.&quot;);
        }
    }
    // Return any previously registered factory for this class loader
    LogFactory factory = getCachedFactory(contextClassLoader);
    if (factory != null) {
        return factory;
    }
    if (isDiagnosticsEnabled()) {
        logDiagnostic(
                &quot;[LOOKUP] LogFactory implementation requested for the first time for context classloader &quot; +
                objectId(contextClassLoader));
        logHierarchy(&quot;[LOOKUP] &quot;, contextClassLoader);
    }
    // Load properties file.
    //
    // If the properties file exists, then its contents are used as
    // &quot;attributes&quot; on the LogFactory implementation class. One particular
    // property may also control which LogFactory concrete subclass is
    // used, but only if other discovery mechanisms fail..
    //
    // As the properties file (if it exists) will be used one way or
    // another in the end we may as well look for it first.
    Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES);
    // Determine whether we will be using the thread context class loader to
    // load logging classes or not by checking the loaded properties file (if any).
    ClassLoader baseClassLoader = contextClassLoader;
    if (props != null) {
        String useTCCLStr = props.getProperty(TCCL_KEY);
        if (useTCCLStr != null) {
            // The Boolean.valueOf(useTCCLStr).booleanValue() formulation
            // is required for Java 1.2 compatibility.
            if (Boolean.valueOf(useTCCLStr).booleanValue() == false) {
                // Don't use current context classloader when locating any
                // LogFactory or Log classes, just use the class that loaded
                // this abstract class. When this class is deployed in a shared
                // classpath of a container, it means webapps cannot deploy their
                // own logging implementations. It also means that it is up to the
                // implementation whether to load library-specific config files
                // from the TCCL or not.
                baseClassLoader = thisClassLoader;
            }
        }
    }
    // Determine which concrete LogFactory subclass to use.
    // First, try a global system property
    if (isDiagnosticsEnabled()) {
        logDiagnostic(&quot;[LOOKUP] Looking for system property [&quot; + FACTORY_PROPERTY +
                      &quot;] to define the LogFactory subclass to use...&quot;);
    }
    try {
        String factoryClass = getSystemProperty(FACTORY_PROPERTY, null);
        if (factoryClass != null) {
            if (isDiagnosticsEnabled()) {
                logDiagnostic(&quot;[LOOKUP] Creating an instance of LogFactory class '&quot; + factoryClass +
                              &quot;' as specified by system property &quot; + FACTORY_PROPERTY);
            }
            factory = newFactory(factoryClass, baseClassLoader, contextClassLoader);
        } else {
            if (isDiagnosticsEnabled()) {
                logDiagnostic(&quot;[LOOKUP] No system property [&quot; + FACTORY_PROPERTY + &quot;] defined.&quot;);
            }
        }
    } catch (SecurityException e) {
        if (isDiagnosticsEnabled()) {
            logDiagnostic(&quot;[LOOKUP] A security exception occurred while trying to create an&quot; +
                          &quot; instance of the custom factory class&quot; + &quot;: [&quot; + trim(e.getMessage()) +
                          &quot;]. Trying alternative implementations...&quot;);
        }
        // ignore
    } catch (RuntimeException e) {
        // This is not consistent with the behaviour when a bad LogFactory class is
        // specified in a services file.
        //
        // One possible exception that can occur here is a ClassCastException when
        // the specified class wasn't castable to this LogFactory type.
        if (isDiagnosticsEnabled()) {
            logDiagnostic(&quot;[LOOKUP] An exception occurred while trying to create an&quot; +
                          &quot; instance of the custom factory class&quot; + &quot;: [&quot; +
                          trim(e.getMessage()) +
                          &quot;] as specified by a system property.&quot;);
        }
        throw e;
    }
    // Second, try to find a service by using the JDK1.3 class
    // discovery mechanism, which involves putting a file with the name
    // of an interface class in the META-INF/services directory, where the
    // contents of the file is a single line specifying a concrete class
    // that implements the desired interface.
    if (factory == null) {
        if (isDiagnosticsEnabled()) {
            logDiagnostic(&quot;[LOOKUP] Looking for a resource file of name [&quot; + SERVICE_ID +
                          &quot;] to define the LogFactory subclass to use...&quot;);
        }
        try {
            final InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID);
            if( is != null ) {
                // This code is needed by EBCDIC and other strange systems.
                // It's a fix for bugs reported in xerces
                BufferedReader rd;
                try {
                    rd = new BufferedReader(new InputStreamReader(is, &quot;UTF-8&quot;));
                } catch (java.io.UnsupportedEncodingException e) {
                    rd = new BufferedReader(new InputStreamReader(is));
                }
                String factoryClassName = rd.readLine();
                rd.close();
                if (factoryClassName != null &amp;&amp; ! &quot;&quot;.equals(factoryClassName)) {
                    if (isDiagnosticsEnabled()) {
                        logDiagnostic(&quot;[LOOKUP]  Creating an instance of LogFactory class &quot; +
                                      factoryClassName +
                                      &quot; as specified by file '&quot; + SERVICE_ID +
                                      &quot;' which was present in the path of the context classloader.&quot;);
                    }
                    factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader );
                }
            } else {
                // is == null
                if (isDiagnosticsEnabled()) {
                    logDiagnostic(&quot;[LOOKUP] No resource file with name '&quot; + SERVICE_ID + &quot;' found.&quot;);
                }
            }
        } catch (Exception ex) {
            // note: if the specified LogFactory class wasn't compatible with LogFactory
            // for some reason, a ClassCastException will be caught here, and attempts will
            // continue to find a compatible class.
            if (isDiagnosticsEnabled()) {
                logDiagnostic(
                    &quot;[LOOKUP] A security exception occurred while trying to create an&quot; +
                    &quot; instance of the custom factory class&quot; +
                    &quot;: [&quot; + trim(ex.getMessage()) +
                    &quot;]. Trying alternative implementations...&quot;);
            }
            // ignore
        }
    }
    // Third try looking into the properties file read earlier (if found)
    if (factory == null) {
        if (props != null) {
            if (isDiagnosticsEnabled()) {
                logDiagnostic(
                    &quot;[LOOKUP] Looking in properties file for entry with key '&quot; + FACTORY_PROPERTY +
                    &quot;' to define the LogFactory subclass to use...&quot;);
            }
            String factoryClass = props.getProperty(FACTORY_PROPERTY);
            if (factoryClass != null) {
                if (isDiagnosticsEnabled()) {
                    logDiagnostic(
                        &quot;[LOOKUP] Properties file specifies LogFactory subclass '&quot; + factoryClass + &quot;'&quot;);
                }
                factory = newFactory(factoryClass, baseClassLoader, contextClassLoader);
                // TODO: think about whether we need to handle exceptions from newFactory
            } else {
                if (isDiagnosticsEnabled()) {
                    logDiagnostic(&quot;[LOOKUP] Properties file has no entry specifying LogFactory subclass.&quot;);
                }
            }
        } else {
            if (isDiagnosticsEnabled()) {
                logDiagnostic(&quot;[LOOKUP] No properties file available to determine&quot; + &quot; LogFactory subclass from..&quot;);
            }
        }
    }
    // Fourth, try the fallback implementation class
    if (factory == null) {
        if (isDiagnosticsEnabled()) {
            logDiagnostic(
                &quot;[LOOKUP] Loading the default LogFactory implementation '&quot; + FACTORY_DEFAULT +
                &quot;' via the same classloader that loaded this LogFactory&quot; +
                &quot; class (ie not looking in the context classloader).&quot;);
        }
        // Note: unlike the above code which can try to load custom LogFactory
        // implementations via the TCCL, we don't try to load the default LogFactory
        // implementation via the context classloader because:
        // * that can cause problems (see comments in newFactory method)
        // * no-one should be customising the code of the default class
        // Yes, we do give up the ability for the child to ship a newer
        // version of the LogFactoryImpl class and have it used dynamically
        // by an old LogFactory class in the parent, but that isn't
        // necessarily a good idea anyway.
        factory = newFactory(FACTORY_DEFAULT, thisClassLoader, contextClassLoader);
    }
    if (factory != null) {
        /**
         * Always cache using context class loader.
         */
        cacheFactory(contextClassLoader, factory);
        if (props != null) {
            Enumeration names = props.propertyNames();
            while (names.hasMoreElements()) {
                String name = (String) names.nextElement();
                String value = props.getProperty(name);
                factory.setAttribute(name, value);
            }
        }
    }
    return factory;
}
</code></pre>
<h2 id="spring5日志技术实现">spring5.*日志技术实现</h2>
<p>spring5使用的spring的jcl(spring改了jcl的代码)来记录日志的,但是jcl不能直接记录日志,采用循环优先的原则</p>
<p><img src="https://epitomm.github.io/post-images/Spring5%E6%97%A5%E5%BF%97.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/Spring5maven%E4%BE%9D%E8%B5%96.png" alt="图片" loading="lazy"></p>
<p><strong>Spring5 当中依赖了 JCL，Spring5 中采用的日志技术是 JCL：spring-jcl</strong>。</p>
<figure data-type="image" tabindex="24"><img src="https://epitomm.github.io/post-images/Spring5%E5%BC%95%E5%85%A5log4j.png" alt="图片" loading="lazy"></figure>
<p>上面的日志打印说是在org.springframework.context.support.AbstractApplicationContext prepareRefresh 内进行的日志打印：logger.info(&quot;Refreshing &quot; + this);</p>
<p>这里我们要查看的是 Spring5 的 AbstractApplicationContext#prepareRefresh，我们来看一下</p>
<pre><code class="language-java">protected void prepareRefresh() {
   this.startupDate = System.currentTimeMillis();
   this.closed.set(false);
   this.active.set(true);
   if (logger.isInfoEnabled()) {
      logger.info(&quot;Refreshing &quot; + this);
   }
   // Initialize any placeholder property sources in the context environment
   initPropertySources();
   // Validate that all properties marked as required are resolvable
   // see ConfigurablePropertyResolver#setRequiredProperties
   getEnvironment().validateRequiredProperties();
   // Allow for the collection of early ApplicationEvents,
   // to be published once the multicaster is available...
   this.earlyApplicationEvents = new LinkedHashSet&lt;&gt;();
}
</code></pre>
<figure data-type="image" tabindex="25"><img src="https://epitomm.github.io/post-images/Spring5JUL.png" alt="图片" loading="lazy"></figure>
<p>org.springframework.context.support.AbstractApplicationContext prepareRefresh 的 logger 对象是 JavaUtilLog，所以打印 JUL 日志。</p>
<p>来看一个 logger 变量的定义：</p>
<pre><code class="language-java">protected final Log logger = LogFactory.getLog(getClass());
</code></pre>
<p>我们再来看一下这个 Log 对象，它是 JCL （org.apache.commons.logging）包下的，虽然我们的 pom.xml 中并未引入 JCL 依赖，但是 spring-context 中有 JCL 依赖。</p>
<pre><code class="language-java">package org.apache.commons.logging;
public interface Log {
</code></pre>
<figure data-type="image" tabindex="26"><img src="https://epitomm.github.io/post-images/Spring5JUL_2.png" alt="图片" loading="lazy"></figure>
<p>一般情况下，JCL 在有 log4j 时，使用 log4j 打印日志；在没有 log4j 时，使用 JUL 打印日志。但是 Spring5 在有 log4j 时，仍然打印 JUL 日志，因为Spring 把 JCL 的源码改了。</p>
<p>LogFactory#getLog</p>
<pre><code class="language-java">public static Log getLog(Class&lt;?&gt; clazz) {
   return getLog(clazz.getName());
}
</code></pre>
<p>LogFactory#getLog</p>
<pre><code class="language-java">public static Log getLog(String name) {
   switch (logApi) {
      case LOG4J:
         return Log4jDelegate.createLog(name);
      case SLF4J_LAL:
         return Slf4jDelegate.createLocationAwareLog(name);
      case SLF4J:
         return Slf4jDelegate.createLog(name);
      default:
         // Defensively use lazy-initializing delegate class here as well since the
         // java.logging module is not present by default on JDK 9. We are requiring
         // its presence if neither Log4j nor SLF4J is available; however, in the
         // case of Log4j or SLF4J, we are trying to prevent early initialization
         // of the JavaUtilLog adapter - e.g. by a JVM in debug mode - when eagerly
         // trying to parse the bytecode for all the cases of this switch clause.
         return JavaUtilDelegate.createLog(name);
   }
}
</code></pre>
<figure data-type="image" tabindex="27"><img src="https://epitomm.github.io/post-images/logApi.png" alt="图片" loading="lazy"></figure>
<p>来看一下 logApi 这个变量：</p>
<pre><code class="language-java">private static LogApi logApi = LogApi.JUL;
</code></pre>
<p>JavaUtilDelegate#createLog</p>
<pre><code class="language-java">private static class JavaUtilDelegate {
   public static Log createLog(String name) {
      return new JavaUtilLog(name);
   }
}
</code></pre>
<p>最终会返回 JavaUtilLog。Spiring5 默认采用 JCL 绑定 JUL 打印日志。<br>
我们看一下 case LOG4J 分支：</p>
<pre><code class="language-java">case LOG4J:
   return Log4jDelegate.createLog(name);   
</code></pre>
<p>如果走 case LOG4J 分支，创建的是 Log4j2 日志：org.apache.logging.log4j.Level，而不是 log4j 日志：org.apache.log4j.Logger;</p>
<pre><code class="language-java">import org.apache.logging.log4j.Level;
private static class Log4jDelegate {
   public static Log createLog(String name) {
      return new Log4jLog(name);
   }
}
</code></pre>
<p>所以在 Spring5 中不能仅仅通过在 pom.xml 中引入 log4j 来使用 log4j。</p>
<h3 id="spring5-使用桥接器-slf4j-绑定-log4j-打印日志">Spring5 使用桥接器 SLF4J 绑定 log4j 打印日志</h3>
<p>如果想要使用 log4j 打印日志，就需要修改 logApi 的值，先来看一下 logApi 是在哪里赋值的：</p>
<pre><code class="language-java">static {
   ClassLoader cl = LogFactory.class.getClassLoader();
   try {
      // 如果有 log4j2，就使用 log4j2 打印日志
      // Try Log4j 2.x API
      cl.loadClass(&quot;org.apache.logging.log4j.spi.ExtendedLogger&quot;);
      logApi = LogApi.LOG4J;
   }
   // 如果没有 log4j2
   catch (ClassNotFoundException ex1) {
      try {
         // 如果有 SLF4J，就桥接 SLF4J 日志打印
         // Try SLF4J 1.7 SPI
         cl.loadClass(&quot;org.slf4j.spi.LocationAwareLogger&quot;);
         logApi = LogApi.SLF4J_LAL;
      }
      catch (ClassNotFoundException ex2) {
         try {
            // Try SLF4J 1.7 API
            cl.loadClass(&quot;org.slf4j.Logger&quot;);
            logApi = LogApi.SLF4J;
         }
         catch (ClassNotFoundException ex3) {
            // Keep java.util.logging as default
         }
      }
   }
}
</code></pre>
<figure data-type="image" tabindex="28"><img src="https://epitomm.github.io/post-images/logApi%E8%B5%8B%E5%80%BC%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<pre><code class="language-xml">  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
      &lt;version&gt;5.0.9.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- slf4j --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
      &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
      &lt;version&gt;1.7.25&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- 绑定器：Log4J. slf4j 绑定到 Log4J --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
      &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
      &lt;version&gt;1.7.25&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
</code></pre>
<figure data-type="image" tabindex="29"><img src="https://epitomm.github.io/post-images/Spring5%E6%89%93%E5%8D%B0log4j.png" alt="图片" loading="lazy"></figure>
<h2 id="总结-2">总结</h2>
<p>Spring4 默认使用 JCL 日志打印，通过 for 循环一个数组[&quot;org.apache.commons.logging.impl.Log4JLogger&quot;,</p>
<p>&quot;org.apache.commons.logging.impl.Jdk14Logger&quot;,</p>
<p>&quot;org.apache.commons.logging.impl.Jdk13LumberjackLogger&quot;,</p>
<p>&quot;org.apache.commons.logging.impl.SimpleLog&quot;</p>
<p>]，给 result 赋值。</p>
<p>Spring5 默认采用 JCL 日志，但是 Spring 把 JCL 改了，底层用了一个 switch-case 去选择一个不同的日志实现，默认采用 JUL，当项目中如果有 SLF4J 或 Log4J2 时，Spring5 就会选用 SLF4J 或  Log4J2 ，采用一个 class.forName() 机制，如果找到了就修改 logApi 值，调用 getLog 方法时得到具体的日志实现。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring系列（十一）Spring源码解析]]></title>
        <id>https://epitomm.github.io/post/spring-xi-lie-shi-yi-spring-yuan-ma-jie-xi/</id>
        <link href="https://epitomm.github.io/post/spring-xi-lie-shi-yi-spring-yuan-ma-jie-xi/">
        </link>
        <updated>2020-05-17T03:47:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="如何处理bean">如何处理@Bean</h1>
<p>给配置类产生 CGLIB 代理：需要维护配置类中 Bean 的作用域。</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E9%85%8D%E7%BD%AE%E7%B1%BB%E4%BA%A7%E7%94%9FCGLIB%E4%BB%A3%E7%90%86.png" alt="图片" loading="lazy"></figure>
<h2 id="enhance">enhance</h2>
<pre><code class="language-java">public Class&lt;?&gt; enhance(Class&lt;?&gt; configClass, @Nullable ClassLoader classLoader) {
   // 判断是否被代理过
   // 如何判断是否被代理？这个 AppConfig 一旦被代理了，就会产生一个EnhancedConfiguration接口。
   // 如果实现了这个接口，就代表已经被代理过了，直接 return
   if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {
      if (logger.isDebugEnabled()) {
         logger.debug(String.format(&quot;Ignoring request to enhance %s as it has &quot; +
               &quot;already been enhanced. This usually indicates that more than one &quot; +
               &quot;ConfigurationClassPostProcessor has been registered (e.g. via &quot; +
               &quot;&lt;context:annotation-config&gt;). This is harmless, but you may &quot; +
               &quot;want check your configuration and remove one CCPP if possible&quot;,
               configClass.getName()));
      }
      return configClass;
   }
   // 如果没有被代理，就cglib 代理
   Class&lt;?&gt; enhancedClass = createClass(newEnhancer(configClass, classLoader));
   if (logger.isDebugEnabled()) {
      logger.debug(String.format(&quot;Successfully enhanced %s; enhanced class name is: %s&quot;,
            configClass.getName(), enhancedClass.getName()));
   }
   return enhancedClass;
}
</code></pre>
<h2 id="newenhancer">newEnhancer</h2>
<pre><code class="language-java">private Enhancer newEnhancer(Class&lt;?&gt; configSuperClass, @Nullable ClassLoader classLoader) {
   Enhancer enhancer = new Enhancer();
   // 增强父类，cglib 是基于继承来的
   // 把当前类 configSuperClass 作为 enhancer 的父类
   enhancer.setSuperclass(configSuperClass);
   // 增强接口，为什么要增强接口？
   // 便于判断，表示一个类已经被增强了
   enhancer.setInterfaces(new Class&lt;?&gt;[] {EnhancedConfiguration.class});
   enhancer.setUseFactory(false);
   enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
   // BeanFactoryAwareGeneratorStrategy 是一个生成策略
   // 主要为生成的 CGLIB 类中添加成员变量 $$beanFactory
   // 同时基于接口 EnhancedConfiguration 的父接口 BeanFactoryAware 中的 setBeanFactory 方法，
   // 设置此变量的值为当前 Context 中的 beanFactory，这样一来我们这个 cglib 代理的对象就有了 beanFactory
   // 有了 factory 就能获得对象，而不用去通过方法获得对象了，因为通过方法获得对象不能控制其过程
   // BeanFactory 的作用是在 this 调用时拦截该调用，并直接在 beanFactory 中获得目标 bean
   enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader));
   // 过滤方法，不能每次都去 new
   enhancer.setCallbackFilter(CALLBACK_FILTER);
   enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());
   return enhancer;
}
</code></pre>
<pre><code class="language-java">private static final ConditionalCallbackFilter CALLBACK_FILTER = new ConditionalCallbackFilter(CALLBACKS);
</code></pre>
<pre><code class="language-java">private static final Callback[] CALLBACKS = new Callback[] {
      // 增强方法，主要控制 bean 的作用域，就是不让它每调用方法都去 new
      new BeanMethodInterceptor(),
      // 设置一个 BeanFactory
      new BeanFactoryAwareMethodInterceptor(),
      NoOp.INSTANCE
};
</code></pre>
<h1 id="怎样拿到-cglib-代理产生的类">怎样拿到 CGLIB 代理产生的类？</h1>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      // 初始化 Spring 的环境
      context. refresh();
      /**
       * 对目标对象的所有方法进行拦截
       */
      Enhancer enhancer = new Enhancer();
      enhancer.setSuperclass(IndexDaoImpl.class);
      // 增强接口
      enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
      // 添加方法过滤器
      enhancer.setCallback(new TestMethodCallabck());
      IndexDaoImpl indexDao = (IndexDaoImpl) enhancer.create();
      indexDao.query();
      try {
         System.in.read();
      } catch (IOException e) {
         e.printStackTrace();
      }
   }
}
</code></pre>
<pre><code class="language-java">public class TestMethodCallabck implements MethodInterceptor {
   /**
    *
    * @param o 代理对象
    * @param method 当前方法，目标对象的方法
    * @param objects 参数
    * @param methodProxy 代理对象的方法
    * @return
    * @throws Throwable
    */
   @Override
   public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
      System.out.println(&quot;method...&quot;);
      return methodProxy.invokeSuper(o,objects);
   }
}
</code></pre>
<h2 id="原始类未经过代理的">原始类（未经过代理的）</h2>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
public class AppConfig {
   @Bean
   public IndexDao indexDao2(){
      indexDao();
      return new IndexDaoImpl2();
   }
   @Bean
   public IndexDao indexDao(){
      return new IndexDaoImpl();
   }
}
</code></pre>
<h2 id="经过-cglib-代理后得到的代理类">经过 CGLIB 代理后得到的代理类</h2>
<h3 id="我们的猜测">我们的猜测</h3>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
public class xxxx extends AppConfig implements EnhancedConfiguration{
   private BeanFactory $$beanFactory;
   @Bean
   public IndexDao indexDao2(){
      if(第一次调用){
        // 调用父类方法，让父类去 new
        proxy.invokeSuper();
      }else{
        // 如果不是第一次调用，直接从 bean 工厂中取出对象并返回
        return $$beanFactory.getBean();
      }
   }
   @Bean
   public IndexDao indexDao(){
      return new IndexDaoImpl();
   }
}
</code></pre>
<ul>
<li>代理类 extends AppConfig implements EnhancedConfiguration</li>
</ul>
<pre><code class="language-java">enhancer.setInterfaces(new Class&lt;?&gt;[] {EnhancedConfiguration.class});
</code></pre>
<ul>
<li>添加了一个属性：private BeanFactory $$beanFactory;</li>
</ul>
<p>为代理类添加了一个方法过滤器后，代理类与原始类代码有什么区别？</p>
<p>在外部调用时， AppConfig appConfig = getBean(); 拿到的对象是代理类 xxxx</p>
<p>当调用 appConfig.indexDao() 时，具体方法里面是什么样还不知道。</p>
<p>其实 indexDao() 方法并没有改变，只不过在这个方法前面还执行了一段代码进行拦截，可以调用父类方法，也可以直接调用子类方法。</p>
<h3 id="查看-cglib-生成的-class-文件">查看 CGLIB 生成的 class 文件</h3>
<p>java -classpath &quot;C:\Program Files\Java\jdk1.8.0_172\lib\sa-jdi.jar&quot; sun.jvm.hotspot.HSDB</p>
<pre><code class="language-java">Only@DESKTOP-MHJI7PB MINGW64 ~/Downloads/spring-framework-5.0.x
$ jps
11408 RemoteMavenServer36
22980 Test
23636 Launcher
24132 KotlinCompileDaemon
24708
22172 Jps
Only@DESKTOP-MHJI7PB MINGW64 ~/Downloads/spring-framework-5.0.x
$ java -classpath &quot;C:\Program Files\Java\jdk1.8.0_172\lib\sa-jdi.jar&quot; sun.jvm.hotspot.HSDB
</code></pre>
<p><img src="https://epitomm.github.io/post-images/%E5%BE%97%E5%88%B0CGLIB%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90%E7%9A%84class%E6%96%87%E4%BB%B6_1.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/%E5%BE%97%E5%88%B0CGLIB%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90%E7%9A%84class%E6%96%87%E4%BB%B6_2.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/%E5%BE%97%E5%88%B0CGLIB%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90%E7%9A%84class%E6%96%87%E4%BB%B6_3.png" alt="图片" loading="lazy"></p>
<p>创建完成后，在当前运行目录  ~/Downloads/spring-framework-5.0.x 下</p>
<p><img src="https://epitomm.github.io/post-images/%E5%BE%97%E5%88%B0CGLIB%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90%E7%9A%84class%E6%96%87%E4%BB%B6_4.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/%E5%BE%97%E5%88%B0CGLIB%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90%E7%9A%84class%E6%96%87%E4%BB%B6_5.png" alt="图片" loading="lazy"></p>
<pre><code class="language-java">public final void query() {
    // CGLIB$CALLBACK_0 对应 TestMethodInterceptor 类
    MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
    if (var10000 == null) {
        CGLIB$BIND_CALLBACKS(this);
        var10000 = this.CGLIB$CALLBACK_0;
    }
    if (var10000 != null) {
        // 调用 TestMethodInterceptor 的 intercept 方法
        var10000.intercept(this, CGLIB$query$0$Method, CGLIB$emptyArgs, CGLIB$query$0$Proxy);
    } else {
        super.query();
    }
}
</code></pre>
<p>JDK 动态代理是实现一个接口，CGLIB 动态代理是继承父类。</p>
<h1 id="如何判断是不是第一次调用">如何判断是不是第一次调用</h1>
<p>第一次调用 indexDao() 方法时 new IndexDaoImpl ，之后再次调用 indexDao() ，则直接从容器中拿出来，factory.getBean() ，如此保持了 IndexDaoImpl 对象的单例。</p>
<p>当 Spring 容器解析到 @Bean 时，就会调用 indexDao()，产生一个 Bean，把它放到 Spring 的 singleObjects 中，得到对象。</p>
<h2 id="intercept">intercept</h2>
<pre><code class="language-java">public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,
         MethodProxy cglibMethodProxy) throws Throwable {
   // enhancedConfigInstance 代理对象
   // 通过 enhancedConfigInstance 中 cglib 生成的成员变量 $$beanFactory 获得 beanFactory
   ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance);
   String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod);
   // Determine whether this bean is a scoped-proxy
   Scope scope = AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class);
   if (scope != null &amp;&amp; scope.proxyMode() != ScopedProxyMode.NO) {
      String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName);
      if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {
         beanName = scopedBeanName;
      }
   }
   // To handle the case of an inter-bean method reference, we must explicitly check the
   // container for already cached instances.
   // First, check to see if the requested bean is a FactoryBean. If so, create a subclass
   // proxy that intercepts calls to getObject() and returns any cached bean instance.
   // This ensures that the semantics of calling a FactoryBean from within @Bean methods
   // is the same as that of referring to a FactoryBean within XML. See SPR-6602.
   if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &amp;&amp;
         factoryContainsBean(beanFactory, beanName)) {
      // 如何判断这个 Bean 是不是 FactoryBean？
      // 从 BeanFactory 中拿 &quot;&amp;beanName&quot;，如果能够拿到，证明这就是一个 FactoryBean
      Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName);
      if (factoryBean instanceof ScopedProxyFactoryBean) {
         // Scoped proxy factory beans are a special case and should not be further proxied
      }
      else {
         // It is a candidate FactoryBean - go ahead with enhancement
         return enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName);
      }
   }
   // 判断是不是第一次调用，如果是第一次就 new；否则 factory,getBean()
   // 判断执行的方法和调用方法是不是同一个方法
   if (isCurrentlyInvokedFactoryMethod(beanMethod)) {
      // The factory is calling the bean method in order to instantiate and register the bean
      // (i.e. via a getBean() call) -&gt; invoke the super implementation of the method to actually
      // create the bean instance.
      if (logger.isWarnEnabled() &amp;&amp;
            BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {
         logger.warn(String.format(&quot;@Bean method %s.%s is non-static and returns an object &quot; +
                     &quot;assignable to Spring's BeanFactoryPostProcessor interface. This will &quot; +
                     &quot;result in a failure to process annotations such as @Autowired, &quot; +
                     &quot;@Resource and @PostConstruct within the method's declaring &quot; +
                     &quot;@Configuration class. Add the 'static' modifier to this method to avoid &quot; +
                     &quot;these container lifecycle issues; see @Bean javadoc for complete details.&quot;,
               beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()));
      }
      return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);
   }
   return resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName);
}
</code></pre>
<p>beanMethod 是当前调用的方法。</p>
<pre><code class="language-java">public void query(){
  //...具体操作
}
// query2()是调用方法，query()是执行方法
public void query2(){
  // 判断当前调用方法 query2 与执行方法 query 是否相同，如果相同，证明是第一次调用，就执行 new；如果不同，证明不是第一次调用，就执行 factory.getBean()。
  query();
  //...具体操作
}
</code></pre>
<pre><code class="language-java">public class TestMethodCallabck implements MethodInterceptor {
   /**
    *
    * @param o 代理对象
    * @param method 当前方法，目标对象的方法
    * @param objects 参数
    * @param methodProxy 代理对象的方法
    * @return
    * @throws Throwable
    */
    // 当一个方法调用时，method 与 methodProxy 相同。当在 query2()内调用 query() 时，method=query() 与 methodProxy=query2() 不同。
   @Override
   public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
      System.out.println(&quot;method...&quot;);
      return methodProxy.invokeSuper(o,objects);
   }
}
</code></pre>
<pre><code class="language-java">private boolean isCurrentlyInvokedFactoryMethod(Method method) {
   //  得到代理方法（调用方法），如果调用方法名与执行方法名相同，即method.getName().equals(currentlyInvoked.getName())，就认为是第一次调用
   Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod();
   return (currentlyInvoked != null &amp;&amp; method.getName().equals(currentlyInvoked.getName()) &amp;&amp;
         Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()));
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8.png" alt="图片" loading="lazy"></figure>
<p>第一次调用时，需要 new，直接调用父类方法，父类方法内含有 new，让父类去 new，上述 intercept 方法第 55 行：</p>
<pre><code class="language-java">cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8indexDao2.png" alt="图片" loading="lazy"></figure>
<p>首先扫描 @Bean，调用 indexDao2() 方法，</p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8indexDao.png" alt="图片" loading="lazy"></figure>
<p>调用 indexDao2() 方法内部的 indexDao() 方法</p>
<p><img src="https://epitomm.github.io/post-images/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%B0%83%E7%94%A8indexDao.png" alt="图片" loading="lazy"><br>
扫描下一个 @Bean，调用 indexDao() 方法</p>
<p>intercept 方法的第 58 行：</p>
<pre><code class="language-java">private Object resolveBeanReference(Method beanMethod, Object[] beanMethodArgs,
      ConfigurableBeanFactory beanFactory, String beanName) {
   // The user (i.e. not the factory) is requesting this bean through a call to
   // the bean method, direct or indirect. The bean may have already been marked
   // as 'in creation' in certain autowiring scenarios; if so, temporarily set
   // the in-creation status to false in order to avoid an exception.
   // 判断它是否正在创建
   boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName);
   try {
      if (alreadyInCreation) {
         beanFactory.setCurrentlyInCreation(beanName, false);
      }
      boolean useArgs = !ObjectUtils.isEmpty(beanMethodArgs);
      if (useArgs &amp;&amp; beanFactory.isSingleton(beanName)) {
         // Stubbed null arguments just for reference purposes,
         // expecting them to be autowired for regular singleton references?
         // A safe assumption since @Bean singleton arguments cannot be optional...
         for (Object arg : beanMethodArgs) {
            if (arg == null) {
               useArgs = false;
               break;
            }
         }
      }
      Object beanInstance = (useArgs ? beanFactory.getBean(beanName, beanMethodArgs) :
            beanFactory.getBean(beanName));
      if (!ClassUtils.isAssignableValue(beanMethod.getReturnType(), beanInstance)) {
         // Detect package-protected NullBean instance through equals(null) check
         if (beanInstance.equals(null)) {
            if (logger.isDebugEnabled()) {
               logger.debug(String.format(&quot;@Bean method %s.%s called as bean reference &quot; +
                     &quot;for type [%s] returned null bean; resolving to null value.&quot;,
                     beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(),
                     beanMethod.getReturnType().getName()));
            }
            beanInstance = null;
         }
         else {
            String msg = String.format(&quot;@Bean method %s.%s called as bean reference &quot; +
                  &quot;for type [%s] but overridden by non-compatible bean instance of type [%s].&quot;,
                  beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(),
                  beanMethod.getReturnType().getName(), beanInstance.getClass().getName());
            try {
               BeanDefinition beanDefinition = beanFactory.getMergedBeanDefinition(beanName);
               msg += &quot; Overriding bean of same name declared in: &quot; + beanDefinition.getResourceDescription();
            }
            catch (NoSuchBeanDefinitionException ex) {
               // Ignore - simply no detailed message then.
            }
            throw new IllegalStateException(msg);
         }
      }
      Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod();
      if (currentlyInvoked != null) {
         String outerBeanName = BeanAnnotationHelper.determineBeanNameFor(currentlyInvoked);
         beanFactory.registerDependentBean(beanName, outerBeanName);
      }
      return beanInstance;
   }
   finally {
      if (alreadyInCreation) {
         beanFactory.setCurrentlyInCreation(beanName, true);
      }
   }
}
</code></pre>
<p>一个对象有三种状态：</p>
<ul>
<li>no 没有创建
<ul>
<li>去创建它</li>
</ul>
</li>
<li>ing 在创建中
<ul>
<li>标识正在创建</li>
</ul>
</li>
<li>ed 创建成功
<ul>
<li>直接拿出来</li>
</ul>
</li>
</ul>
<p>Spring 的 getBean() 方法做了封装：没有就创建，有就直接拿。</p>
<h1 id="spring-当中-bean-的后置处理器">Spring 当中 Bean 的后置处理器</h1>
<p>Spring 当中的后置处理器是 Spring 提供的一个扩展点，程序员只要去实现 BeanPostProcessor 接口，就能插手 Bean 的实例化过程，怎么插手呢？在 Bean 被放到 Spring 这个 Bean 容器之前去插手，能够对 Bean 做一些改变。经典场景：① Bean 的生命周期回调：CommonAnnotationBeanPostProcessor、② AOP：@AspectJ</p>
<h1 id="beanfactorypostprocessor-的作用">BeanFactoryPostProcessor 的作用</h1>
<p>BeanFactoryPostProcessor 主要能够在 Spring 的 bean容器当中的任意一个类被实例化之前来回调里面的方法。经典应用场景：ConfigurationClassPostProcessor#postProcessBeanFactory，针对 @Configuration 配置类加上 CGLIB 代理</p>
<h1 id="beandefinitionregistrypostprocessor">BeanDefinitionRegistryPostProcessor</h1>
<p>是 BeanFactoryPostProcessor 的子类，在 BeanFactoryPostProcessor 之前执行。</p>
<p>Spinrg 底层源码决定的，先遍历 BeanDefinitionRegistryPostProcessor：Spring 提供的 + 自定义的：context.addBeanFactoryPostProcessor()，先执行自定义的，后执行 Spring 提供的【参照源码：refresh(); ---&gt; invokeBeanFactoryPostProcessors(beanFactory); ---&gt; invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); ---&gt; invokeBeanFactoryPostProcessors】，后遍历 BeanFactoryPostProcessor。</p>
<p>应用场景：ConfigurationClassPostProcessor 扫描、解析。ConfigurationClassPostProcessor 实现了 BeanDefinitionRegistryPostProcessor 接口，这个类当中有一个回调方法，完成了 Spring 的核心功能：扫描类，包括3种import的扫描、@Bean的扫描、判断配置类是否是一个完整的配置类，解析、解析配置类、解析 XML。</p>
<h1 id="importselector">ImportSelector</h1>
<p>通过 selectImports 方法返回一个类名（全限定类名），把它变成 bd，动态添加 bd（这个 bd 是死的）。如果用 ImportSelector，实现了 selectImports 方法，返回全限定类名，Spring 会得到这些类名，然后通过这些类名得到一个 Class，然后把它变成一个 BeanDefinition，但是把 Class 变成 BeanDefinition 的过程是由 Spring 完成的，所以这个 BeanDefinition 是死的，这个 Class 是怎样的，这个 BeanDefinition 就是怎样的。</p>
<p>ImportSelector 还可以动态扫描</p>
<pre><code class="language-java">String[] selectImports(AnnotationMetadata importingClassMetadata){
  class A extends Spring扫描器{
    A 完成扫描，返回字符串xxxx，把字符串返回给 String[],也能注入成功
  }
}
</code></pre>
<p>扫描谁都可以做，关键是扫描出来后，程序员不能把它变成 BeanDefinition，因为扫描出来的仅仅是一个 Class 或者是 Resource，怎样把它变成 BeanDefinition 呢？要么交给 Spring，让 Spring 把它变成 BeanDefinition；要么手动 new reader，然后通过一个 BeanDefinition <br>
的实现类的构造方法去 new。而 selectImports 方法只需要把它变成 Class，后续 Spring 会把它变成一个 BeanDefinition。一些应用直接扩展 ImportSlector，在里面扩展 Spring 扫描器，完成自己的扫描，经典场景 MyBatis：MyBatis 扩展 Spring 扫描器，扫描 Dao，但是扫描出来由Spring 把它变成 BeanDefinition。但是 MyBatis 用的不是 ImportSelector，因为 MyBatis 底层要做一些 BeanDefinition 的改变，ImportSelector 无法实现。</p>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Import(MapperScannerRegistrar.class)
public @interface MapperScan {
</code></pre>
<pre><code class="language-java">public class MapperScannerRegistrar implements ImportBeanDefinitionRegistrar, ResourceLoaderAware {
</code></pre>
<pre><code class="language-java">// BeanDefinitionRegistry 注册器：在注册前可以改变 BeanDefinition，然后再注册到 Spring 容器中
public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
  AnnotationAttributes annoAttrs = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));
  ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);
  // this check is needed in Spring 3.1
  if (resourceLoader != null) {
    scanner.setResourceLoader(resourceLoader);
  }
  Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass(&quot;annotationClass&quot;);
  if (!Annotation.class.equals(annotationClass)) {
    scanner.setAnnotationClass(annotationClass);
  }
  Class&lt;?&gt; markerInterface = annoAttrs.getClass(&quot;markerInterface&quot;);
  if (!Class.class.equals(markerInterface)) {
    scanner.setMarkerInterface(markerInterface);
  }
  Class&lt;? extends BeanNameGenerator&gt; generatorClass = annoAttrs.getClass(&quot;nameGenerator&quot;);
  if (!BeanNameGenerator.class.equals(generatorClass)) {
    scanner.setBeanNameGenerator(BeanUtils.instantiateClass(generatorClass));
  }
  Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = annoAttrs.getClass(&quot;factoryBean&quot;);
  if (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) {
    scanner.setMapperFactoryBean(BeanUtils.instantiateClass(mapperFactoryBeanClass));
  }
  scanner.setSqlSessionTemplateBeanName(annoAttrs.getString(&quot;sqlSessionTemplateRef&quot;));
  scanner.setSqlSessionFactoryBeanName(annoAttrs.getString(&quot;sqlSessionFactoryRef&quot;));
  List&lt;String&gt; basePackages = new ArrayList&lt;String&gt;();
  for (String pkg : annoAttrs.getStringArray(&quot;value&quot;)) {
    if (StringUtils.hasText(pkg)) {
      basePackages.add(pkg);
    }
  }
  for (String pkg : annoAttrs.getStringArray(&quot;basePackages&quot;)) {
    if (StringUtils.hasText(pkg)) {
      basePackages.add(pkg);
    }
  }
  for (Class&lt;?&gt; clazz : annoAttrs.getClassArray(&quot;basePackageClasses&quot;)) {
    basePackages.add(ClassUtils.getPackageName(clazz));
  }
  scanner.registerFilters();
  scanner.doScan(StringUtils.toStringArray(basePackages));
}
</code></pre>
<pre><code class="language-java">public class ClassPathMapperScanner extends ClassPathBeanDefinitionScanner {
</code></pre>
<h1 id="importselector-与-importbeandefinitionregistrar-的区别">ImportSelector 与  ImportBeanDefinitionRegistrar 的区别</h1>
<p>ImportSelector 与 ImportBeanDefinitionRegistrar 的区别，实现的 ImportSelector，永远停留在 BeanDefinition 级别，Bean 的级别要到 BeanPostProcessor 那里去。</p>
<p><strong>什么时候用 ImportSelector，什么时候用 ImportBeanDefinitionRegistrar</strong> ？</p>
<p>看要不要动态改变这个 BeanDefinition，如果这个 BeanDefinition 不要动态改变，就用 ImportSelector；如果需要动态改变，就用 Registrar。</p>
<p>ImportSelector 能拿到 AnnotationMetadata 注解，但是 Registrar 不一定能拿到。</p>
<p>ImportSelector 能做的事情，Registrar 都能做，但是 Registrar 能动态改变 BeanDefinition，ImportSelector 做不了。</p>
<p>ImportSelector 的 String[] selectImports(AnnotationMetadata importingClassMetadata); 返回字符串，Spring 帮忙注册。</p>
<p>ImportBeanDefinitionRegistrar 的 registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry); 提供环境 registry，让程序员自己注册。</p>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/%E6%80%BB%E7%BB%93.png" alt="图片" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring系列（十）Spring源码解析]]></title>
        <id>https://epitomm.github.io/post/spring-xi-lie-shi-spring-yuan-ma/</id>
        <link href="https://epitomm.github.io/post/spring-xi-lie-shi-spring-yuan-ma/">
        </link>
        <updated>2020-05-15T15:32:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="processconfigurationclass">processConfigurationClass</h1>
<p>context.<em>refresh</em>(); ---&gt; <em>invokeBeanFactoryPostProcessors</em>(beanFactory); ---&gt; PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); ---&gt;invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); ---&gt; postProcessor.<em>postProcessBeanDefinitionRegistry</em>(registry); ---&gt; <em>processConfigBeanDefinitions</em>(registry);处理@Configuration ---&gt; parser.parse(candidates); 解析注解对象---&gt; parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName()); ---&gt; processConfigurationClass(new ConfigurationClass(metadata, beanName)); 处理Import---&gt; sourceClass = doProcessConfigurationClass(configClass, sourceClass); ---&gt; this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()); ---&gt; scanner.doScan(StringUtils.toStringArray(basePackages));扫描包</p>
<pre><code class="language-java">protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
   // 判断是否应该跳过解析
   if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
      return;
   }
   // 处理 Imported 的情况
   // 就是当前这个类有没有被别的类 @Import
   ConfigurationClass existingClass = this.configurationClasses.get(configClass);
   if (existingClass != null) {
      if (configClass.isImported()) {
         if (existingClass.isImported()) {
            existingClass.mergeImportedBy(configClass);
         }
         // Otherwise ignore new imported config class; existing non-imported class overrides it.
         return;
      }
      else {
         // Explicit bean definition found, probably replacing an import.
         // Let's remove the old one and go with the new one.
         this.configurationClasses.remove(configClass);
         this.knownSuperclasses.values().removeIf(configClass::equals);
      }
   }
   // Recursively process the configuration class and its superclass hierarchy.
   SourceClass sourceClass = asSourceClass(configClass);
   do {
      sourceClass = doProcessConfigurationClass(configClass, sourceClass);
   }
   while (sourceClass != null);
   // 一个 map，用来存放扫描出来的 bean（注意这里的 bean 不是对象，仅仅是 bean 的信息，因为还没到实例化）
   this.configurationClasses.put(configClass, configClass);
}
</code></pre>
<h2 id="扫描普通类component并放到-map-中">扫描普通类@Component，并放到 map 中</h2>
<h3 id="doprocessconfigurationclass">doProcessConfigurationClass</h3>
<p>上述代码第 29 行：解析注解类</p>
<pre><code class="language-java">protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)
      throws IOException {
   // Recursively process any member (nested) classes first
   // 处理内部类
   processMemberClasses(configClass, sourceClass);
   // Process any @PropertySource annotations
   for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
         sourceClass.getMetadata(), PropertySources.class,
         org.springframework.context.annotation.PropertySource.class)) {
      if (this.environment instanceof ConfigurableEnvironment) {
         processPropertySource(propertySource);
      }
      else {
         logger.warn(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() +
               &quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;);
      }
   }
   // Process any @ComponentScan annotations
   Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(
         sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
   if (!componentScans.isEmpty() &amp;&amp;
         !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
      for (AnnotationAttributes componentScan : componentScans) {
         // The config class is annotated with @ComponentScan -&gt; perform the scan immediately
         // 扫描普通类=componentScan=com.ssm
         // 这里扫描出来所有 @Component
         Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =
               this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
         // Check the set of scanned definitions for any further config classes and parse recursively if needed
         // 检查扫描出来的类当中是否还有 Configuration
         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
            BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
            if (bdCand == null) {
               bdCand = holder.getBeanDefinition();
            }
            if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
               parse(bdCand.getBeanClassName(), holder.getBeanName());
            }
         }
      }
   }
   /**
    * 上面的代码就是扫描普通类——@Component
    * 并且放到了map当中
    */
   // Process any @Import annotations
   // 处理 @Import：三种情况
   // ImportSelector、ImportBeanDefinitionRegistrar、普通类
   /**
    * 这里处理的 import 是需要判断我们的类当中是否有@Import注解： getImports(sourceClass)
    * 如果有 @Import 注解，就把这个值拿出来，是一个类
    * 比如 @Import(xxxx.class)，那么这里便把 xxxx 传进去进行解析
    * 在解析的过程中如果发觉是一个 importSelector 那么就回调 selector 的方法
    * 返回一个字符串（类名），通过这个字符串得到一个类
    * 继而在递归调用本方法来处理这个类
    *
    * 判断一组类是不是 imports(3种import)
    */
   processImports(configClass, sourceClass, getImports(sourceClass), true);
   // Process any @ImportResource annotations
   AnnotationAttributes importResource =
         AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
   if (importResource != null) {
      String[] resources = importResource.getStringArray(&quot;locations&quot;);
      Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;);
      for (String resource : resources) {
         String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
         configClass.addImportedResource(resolvedResource, readerClass);
      }
   }
   // Process individual @Bean methods
   Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
   for (MethodMetadata methodMetadata : beanMethods) {
      configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
   }
   // Process default methods on interfaces
   processInterfaces(configClass, sourceClass);
   // Process superclass, if any
   if (sourceClass.getMetadata().hasSuperClass()) {
      String superclass = sourceClass.getMetadata().getSuperClassName();
      if (superclass != null &amp;&amp; !superclass.startsWith(&quot;java&quot;) &amp;&amp;
            !this.knownSuperclasses.containsKey(superclass)) {
         this.knownSuperclasses.put(superclass, configClass);
         // Superclass found, return its annotation metadata and recurse
         return sourceClass.getSuperClass();
      }
   }
   // No superclass -&gt; processing is complete
   return null;
}
</code></pre>
<p>普通类扫描后就完成了注册：上述代码第 26 行：<br>
上述代码第 31 行：</p>
<pre><code class="language-java">public Set&lt;BeanDefinitionHolder&gt; parse(AnnotationAttributes componentScan, final String declaringClass) {
   ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,
         componentScan.getBoolean(&quot;useDefaultFilters&quot;), this.environment, this.resourceLoader);
   // BeanNameGenerator：Bean名字生成器
   Class&lt;? extends BeanNameGenerator&gt; generatorClass = componentScan.getClass(&quot;nameGenerator&quot;);
   boolean useInheritedGenerator = (BeanNameGenerator.class == generatorClass);
   scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator :
         BeanUtils.instantiateClass(generatorClass));
   ScopedProxyMode scopedProxyMode = componentScan.getEnum(&quot;scopedProxy&quot;);
   if (scopedProxyMode != ScopedProxyMode.DEFAULT) {
      scanner.setScopedProxyMode(scopedProxyMode);
   }
   else {
      Class&lt;? extends ScopeMetadataResolver&gt; resolverClass = componentScan.getClass(&quot;scopeResolver&quot;);
      scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));
   }
   scanner.setResourcePattern(componentScan.getString(&quot;resourcePattern&quot;));
   // 遍历当中的过滤
   for (AnnotationAttributes filter : componentScan.getAnnotationArray(&quot;includeFilters&quot;)) {
      for (TypeFilter typeFilter : typeFiltersFor(filter)) {
         scanner.addIncludeFilter(typeFilter);
      }
   }
   for (AnnotationAttributes filter : componentScan.getAnnotationArray(&quot;excludeFilters&quot;)) {
      for (TypeFilter typeFilter : typeFiltersFor(filter)) {
         scanner.addExcludeFilter(typeFilter);
      }
   }
   // 扫描出来的这个类是否需要懒加载：默认 false
   // xml 配置懒加载：&lt;beans lazy=&quot;true&quot;&gt;&lt;bean&gt;&lt;/bean&gt;&lt;/beans&gt;
   // JavaConfig配置懒加载：@Lazy   public class AppConfig{
   boolean lazyInit = componentScan.getBoolean(&quot;lazyInit&quot;);
   if (lazyInit) {
      scanner.getBeanDefinitionDefaults().setLazyInit(true);
   }
   Set&lt;String&gt; basePackages = new LinkedHashSet&lt;&gt;();
   String[] basePackagesArray = componentScan.getStringArray(&quot;basePackages&quot;);
   for (String pkg : basePackagesArray) {
      String[] tokenized = StringUtils.tokenizeToStringArray(this.environment.resolvePlaceholders(pkg),
            ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);
      Collections.addAll(basePackages, tokenized);
   }
   for (Class&lt;?&gt; clazz : componentScan.getClassArray(&quot;basePackageClasses&quot;)) {
      basePackages.add(ClassUtils.getPackageName(clazz));
   }
   if (basePackages.isEmpty()) {
      basePackages.add(ClassUtils.getPackageName(declaringClass));
   }
   scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {
      @Override
      protected boolean matchClassName(String className) {
         return declaringClass.equals(className);
      }
   });
   return scanner.doScan(StringUtils.toStringArray(basePackages));
}
</code></pre>
<p>上述代码第 62 行，调用 doScan 方法完成扫描</p>
<pre><code class="language-java">protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) {
   Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;);
   Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;&gt;();
   // 循环所有 basePackages，因为@ComponentScan({&quot;com.ssm.dao&quot;},{&quot;com.ssm.service&quot;})可以写多个
   for (String basePackage : basePackages) {
      // 扫表 basePackage 路径下的 java 文件
      // 并把它转成 BeanDefinition 类型
      Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);
      for (BeanDefinition candidate : candidates) {
         // 解析 scope 属性
         ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
         candidate.setScope(scopeMetadata.getScopeName());
         String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
         if (candidate instanceof AbstractBeanDefinition) {
            // 如果这个类是 AbstractBeanDefinition 的子类
            // 则为它设置默认值，比如 lazy，init destroy
            postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
         }
         if (candidate instanceof AnnotatedBeanDefinition) {
            // 检查并且处理常用的注解
            // 这里的处理主要是指把常用注解的值设置到 AnnotatedBeanDefinition 当中
            // 当前前提是这个类必须是 AnnotatedBeanDefinition 类型的，说白了就是加了注解的类
            AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
         }
         if (checkCandidate(beanName, candidate)) {
            BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
            definitionHolder =
                  AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
            beanDefinitions.add(definitionHolder);
            // 加入到 map 中
            registerBeanDefinition(definitionHolder, this.registry);
         }
      }
   }
   return beanDefinitions;
}
</code></pre>
<p>上述代码第 8 行：</p>
<pre><code class="language-java">Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);
</code></pre>
<p>调用 findCandidateComponents 方法完成扫描，并把扫描出来的类都转化成 BeanDefinition，<br>
第 31 行：把所有的 BeanDefinition 注册到 map 中。</p>
<p>即：普通类扫描后就完成了注册。</p>
<pre><code class="language-java">@Import(MyImportSelector.class)
@ComponentScan
public class AppConfig{
  
}
</code></pre>
<p>上述代码完成了：扫描所有的 @ComponentScan，并把 BeanDefinition 放到 map 中。<br>
还没有开始处理 @Import。</p>
<h2 id="处理-import">处理 @Import</h2>
<p>什么时候处理 @Import呢？上述 processConfigurationClass 方法的第 64 行：</p>
<pre><code class="language-java">/**
 * 这里处理的 import 是需要判断我们的类当中是否有@Import注解： getImports(sourceClass)
 * 如果有 @Import 注解，就把这个值拿出来，是一个类
 * 比如 @Import(xxxx.class)，那么这里便把 xxxx 传进去进行解析
 * 在解析的过程中如果发觉是一个 importSelector 那么就回调 selector 的方法
 * 返回一个字符串（类名），通过这个字符串得到一个类
 * 继而在递归调用本方法来处理这个类
 *
 * 判断一组类是不是 imports(3中import)
 */
processImports(configClass, sourceClass, getImports(sourceClass), true);
</code></pre>
<h3 id="示例代码">示例代码</h3>
<p>1、有一个配置类：</p>
<p>① 扫描包 com.ssm；</p>
<p>② @Import(MyImportSelector.class)；</p>
<p>③ 通过 @Bean 注入 IndexDaoImpl2</p>
<pre><code>@ComponentScan(&quot;com.ssm&quot;)
@Import(MyImportSelector.class)
public class AppConfig {
   @Bean
   public IndexDaoImpl2 indexDaoImpl2(){
      return new IndexDaoImpl2();
   }
}
</code></pre>
<p>2、有一个 IndexDaoImpl 通过 @Repository(&quot;indexDao&quot;) 注入到 Spring 容器中。</p>
<pre><code class="language-java">@Repository(&quot;indexDao&quot;)
public class IndexDaoImpl implements IndexDao{
   @Override
   public void query() {
      System.out.println(&quot;dao...模拟查询数据库&quot;);
   }
}
</code></pre>
<p>3、有一个 IndexDaoImpl2 在此类中并未添加 @Component，但是在 AppConfig 通过 @Bean 的方式 new IndexDaoImpl2 添加到 Spring 容器中了。</p>
<pre><code class="language-java">public class IndexDaoImpl2 implements IndexDao{
   @Override
   public void query() {
      System.out.println(&quot;dao2...模拟查询数据库&quot;);
   }
}
</code></pre>
<p>4、MyImportSelector implements ImportSelector，返回 “类的字符串”，即 IndexDaoImpl3.class.getName()</p>
<pre><code class="language-java">public class MyImportSelector implements ImportSelector {
   @Override
   public String[] selectImports(AnnotationMetadata importingClassMetadata) {
      return new String[]{IndexDaoImpl3.class.getName()};
   }
}
</code></pre>
<p>5、IndexDaoImpl3 implements BeanPostProcessor</p>
<pre><code class="language-java">public class IndexDaoImpl3 implements IndexDao, BeanPostProcessor {
   @Override
   public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
      if(beanName.equals(&quot;indexDao&quot;)){
         bean = Proxy.newProxyInstance(this.getClass().getClassLoader(), new Class[]{IndexDao.class},new MyInvocationHandler(bean));
      }
      return bean;
   }
   @Override
   public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
      return null;
   }
   @Override
   public void query() {
      System.out.println(&quot;dao3...模拟查询数据库&quot;);
   }
}
</code></pre>
<p>6、MyInvocationHandler implements InvocationHandler</p>
<pre><code class="language-java">public class MyInvocationHandler implements InvocationHandler {
   Object target;
   public MyInvocationHandler(Object target){
      this.target = target;
   }
   @Override
   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
      System.out.println(&quot;代理方法...&quot;);
      return method.invoke(target,args);
   }
}
</code></pre>
<p>7、测试类</p>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      // 初始化 Spring 的环境
      context. refresh();
      IndexDao dao = (IndexDao) context.getBean(&quot;indexDao&quot;);
      dao.query();
   }
}
</code></pre>
<p>8、运行结果：</p>
<pre><code>代理方法...
dao...模拟查询数据库
</code></pre>
<h3 id="processimports">processImports</h3>
<pre><code class="language-java">private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,
      Collection&lt;SourceClass&gt; importCandidates, boolean checkForCircularImports) {
   // 如果没有加@Import，直接返回
   if (importCandidates.isEmpty()) {
      return;
   }
   if (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) {
      this.problemReporter.error(new CircularImportProblem(configClass, this.importStack));
   }
   else {
      this.importStack.push(configClass);
      try {
         for (SourceClass candidate : importCandidates) {
            // @Import(IndexDao.class)、@Import(ImportSelector)、@Import(ImportBeanDefinitionRegistrar)
            // 判断是不是 ImportSelector
            if (candidate.isAssignable(ImportSelector.class)) {
               // Candidate class is an ImportSelector -&gt; delegate to it to determine imports
               Class&lt;?&gt; candidateClass = candidate.loadClass();
               // 反射实现一个对象
               ImportSelector selector = BeanUtils.instantiateClass(candidateClass, ImportSelector.class);
               ParserStrategyUtils.invokeAwareMethods(
                     selector, this.environment, this.resourceLoader, this.registry);
               if (this.deferredImportSelectors != null &amp;&amp; selector instanceof DeferredImportSelector) {
                  this.deferredImportSelectors.add(
                        new DeferredImportSelectorHolder(configClass, (DeferredImportSelector) selector));
               }
               else {
                  // 回调
                  String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
                  Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames);
                  // 递归，这里第二次调用 processImports
                  // 如果是一个普通类，会进 else
                  processImports(configClass, currentSourceClass, importSourceClasses, false);
               }
            }
            // 判断是不是 ImportBeanDefinitionRegistrar
            else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
               // Candidate class is an ImportBeanDefinitionRegistrar -&gt;
               // delegate to it to register additional bean definitions
               Class&lt;?&gt; candidateClass = candidate.loadClass();
               ImportBeanDefinitionRegistrar registrar =
                     BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);
               ParserStrategyUtils.invokeAwareMethods(
                     registrar, this.environment, this.resourceLoader, this.registry);
               // 添加到一个 list 当中和 importSelector 不同
               configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
            }
            // 普通类：@Import(IndexDao.class)
            else {
               // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt;
               // process it as an @Configuration class
               // 否则，加入到 importStack 后调用 processConfigurationClass 进行处理
               // processConfigurationClass 里面主要就是把类放到 configurationClasses
               // configurationClasses 是一个集合，会在后面拿出来解析成 bd 继而注册
               // 可以看到普通类在扫描出来的时候就被注册了
               // 如果是 importSelector，会先放到 configurationClasses 后面进行出来注册
               this.importStack.registerImport(
                     currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
               processConfigurationClass(candidate.asConfigClass(configClass));
            }
         }
      }
      catch (BeanDefinitionStoreException ex) {
         throw ex;
      }
      catch (Throwable ex) {
         throw new BeanDefinitionStoreException(
               &quot;Failed to process import candidates for configuration class [&quot; +
               configClass.getMetadata().getClassName() + &quot;]&quot;, ex);
      }
      finally {
         this.importStack.pop();
      }
   }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/candidate.png" alt="图片" loading="lazy"></figure>
<p>上述代码第 15-20 行：</p>
<pre><code class="language-java">for (SourceClass candidate : importCandidates) {
    // @Import(IndexDao.class)、@Import(ImportSelector)、@Import(ImportBeanDefinitionRegistrar)
    // 判断是不是 ImportSelector
    if (candidate.isAssignable(ImportSelector.class)) {
    // Candidate class is an ImportSelector -&gt; delegate to it to determine imports
        Class&lt;?&gt; candidateClass = candidate.loadClass(
        
</code></pre>
<p>解析到了 @Import(MyImportSelector.class)，</p>
<pre><code class="language-java">public class MyImportSelector implements ImportSelector {
   @Override
   public String[] selectImports(AnnotationMetadata importingClassMetadata) {
      return new String[]{IndexDaoImpl3.class.getName()};
   }
}
</code></pre>
<p>解析到 @MyImportSelector 后，会返回一个 “类的字符串”，如上述代码第 4 行所示。<br>
这个 “类的字符串” 肯定会放到 map 中，但此时还没有放进去。</p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/candidateClass.png" alt="图片" loading="lazy"></figure>
<p>普通类通过 doScan 方法被扫描出来，转化成 BeanDefinition，并被加入到 map 中：所以被 @Reposity 修饰的 IndexDaoImpl 此时已经在容器中了。</p>
<h3 id="何时将-importselector-返回的字符串放到-map-中">何时将 @ImportSelector 返回的字符串放到 map 中</h3>
<p>反射实现一个对象：Spring 要知道这个 ImportSelector  到底返回了哪些字符串（return new String[]{IndexDaoImpl3.class.getName()};），然后通过这个字符串反射得到类名。</p>
<pre><code class="language-java">public class MyImportSelector implements ImportSelector {
   @Override
   public String[] selectImports(AnnotationMetadata importingClassMetadata) {
      return new String[]{IndexDaoImpl3.class.getName()};
   }
}
</code></pre>
<p>得到 selectImports 方法返回的字符串数组：String[] strs = selectImports();<br>
for(String str: strs){</p>
<p>// 通过反射得到类名</p>
<p>class = Class.forName(str);</p>
<p>}</p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/importSourceClasses.png" alt="图片" loading="lazy"></figure>
<h2 id="递归调用-processimports">递归调用 processImports</h2>
<p>得到类名 IndexDaoImpl3，正常情况可能会想：将 IndexDaoImpl3 转化成 BeanDefinition，然后放到 map 中，但是，Spring 并不是这样做的，因为有可能这个 IndexDaoImpl3 里面也有一个 @Import，所以 Spring 进行递归处理。</p>
<p>上述 processImports 方法的第 30-35 行：</p>
<pre><code class="language-java">// 得到类名
String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames);
// 递归，这里第二次调用 processImports
// 如果是一个普通类，会进 else
processImports(configClass, currentSourceClass, importSourceClasses, false);
</code></pre>
<p>于是再次调用 processImports 方法：<br>
上述 processImports  方法第 18 行判断：</p>
<pre><code class="language-java">if (candidate.isAssignable(ImportSelector.class)) {
</code></pre>
<p>IndexDaoImpl3 不是一个 ImportSelector<br>
上述 processImports  方法第 39 行判断：</p>
<pre><code class="language-java">else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
</code></pre>
<p>IndexDaoImpl3 不是一个 ImportBeanDefinitionRegistrar<br>
所以进入 processImports  方法的第 51 行 else 分支</p>
<pre><code class="language-java">else{
  this.importStack.registerImport(
      currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
processConfigurationClass(candidate.asConfigClass(configClass));
}
</code></pre>
<h3 id="外部调用">外部调用</h3>
<p>从外部调用时，doProcessConfigurationClass 方法的第 64 行：</p>
<pre><code class="language-java">processImports(configClass, sourceClass, getImports(sourceClass), true);
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/getImports.png" alt="图片" loading="lazy"></figure>
<p>传递的第三个参数是获得 @Import(MyImportSelector.class) 的值：MyImportSelector。判断 AppConfig 中 @Import 的值到底是哪一种 Import，然后再来进行处理。</p>
<p>再来看 processImports 方法的参数</p>
<pre><code class="language-java">private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,
      Collection&lt;SourceClass&gt; importCandidates, boolean checkForCircularImports) {
</code></pre>
<p>第三个参数 importCandidates 即 MyImportSelector</p>
<h3 id="内部调用">内部调用</h3>
<p>内部递归调用时，传递的第三个参数是当前类：</p>
<pre><code class="language-java">processImports(configClass, currentSourceClass, importSourceClasses, false);
</code></pre>
<p>内部调用判断当前类 IndexDaoImpl3 到底是哪一种 @Import。<br>
<strong>getImports(sourceClass) 是获取 @Import 注解内的值，而 processImports 仅仅判断传进来的类（第三个参数）是 三种Import 中的哪一种</strong>。</p>
<h2 id="processconfigurationclass-2">processConfigurationClass</h2>
<p>前面提到递归调用会进入 else 分支，调用 processConfigurationClass 方法：</p>
<pre><code class="language-java">protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
   // 判断是否应该跳过解析
   if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
      return;
   }
   // 处理 Imported 的情况
   // 就是当前这个类有没有被别的类 @Import
   ConfigurationClass existingClass = this.configurationClasses.get(configClass);
   if (existingClass != null) {
      if (configClass.isImported()) {
         if (existingClass.isImported()) {
            existingClass.mergeImportedBy(configClass);
         }
         // Otherwise ignore new imported config class; existing non-imported class overrides it.
         return;
      }
      else {
         // Explicit bean definition found, probably replacing an import.
         // Let's remove the old one and go with the new one.
         this.configurationClasses.remove(configClass);
         this.knownSuperclasses.values().removeIf(configClass::equals);
      }
   }
   // Recursively process the configuration class and its superclass hierarchy.
   SourceClass sourceClass = asSourceClass(configClass);
   do {
      sourceClass = doProcessConfigurationClass(configClass, sourceClass);
   }
   while (sourceClass != null);
   // 一个 map，用来存放扫描出来的 bean（注意这里的 bean 不是对象，仅仅是 bean 的信息，因为还没到实例化）
   this.configurationClasses.put(configClass, configClass);
}
</code></pre>
<p>上述代码第 34 行：将类放到 configurationClasses 变量中。</p>
<pre><code class="language-java">private final Map&lt;ConfigurationClass, ConfigurationClass&gt; configurationClasses = new LinkedHashMap&lt;&gt;();
</code></pre>
<h1 id="spring-处理四种类">Spring 处理四种类</h1>
<h2 id="普通类-component">普通类 @Component</h2>
<p>扫描完成后注册</p>
<h2 id="importselector">importSelector</h2>
<p><strong>先放到 Map&lt;ConfigurationClass, ConfigurationClass&gt; configurationClasses = new LinkedHashMap&lt;&gt;(); 中，然后再注册</strong>。</p>
<p>context.<em>refresh</em>(); ---&gt; <em>invokeBeanFactoryPostProcessors</em>(beanFactory); ---&gt; PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); ---&gt;invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); ---&gt; postProcessor.<em>postProcessBeanDefinitionRegistry</em>(registry); ---&gt; <em>processConfigBeanDefinitions</em>(registry);处理@Configuration ---&gt; parser.parse(candidates); 解析注解对象---&gt; parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName()); ---&gt; processConfigurationClass(new ConfigurationClass(metadata, beanName)); 处理Import</p>
<pre><code class="language-java">protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
   // 判断是否应该跳过解析
   if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
      return;
   }
   // 处理 Imported 的情况
   // 就是当前这个类有没有被别的类 @Import
   ConfigurationClass existingClass = this.configurationClasses.get(configClass);
   if (existingClass != null) {
      if (configClass.isImported()) {
         if (existingClass.isImported()) {
            existingClass.mergeImportedBy(configClass);
         }
         // Otherwise ignore new imported config class; existing non-imported class overrides it.
         return;
      }
      else {
         // Explicit bean definition found, probably replacing an import.
         // Let's remove the old one and go with the new one.
         this.configurationClasses.remove(configClass);
         this.knownSuperclasses.values().removeIf(configClass::equals);
      }
   }
   // Recursively process the configuration class and its superclass hierarchy.
   SourceClass sourceClass = asSourceClass(configClass);
   do {
      sourceClass = doProcessConfigurationClass(configClass, sourceClass);
   }
   while (sourceClass != null);
   // 一个 map，用来存放扫描出来的 bean（注意这里的 bean 不是对象，仅仅是 bean 的信息，因为还没到实例化）
   this.configurationClasses.put(configClass, configClass);
}
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/map%E4%B8%AD%E6%9C%898%E4%B8%AA.png" alt="图片" loading="lazy"></figure>
<p>context. refresh(); ---&gt; invokeBeanFactoryPostProcessors(beanFactory); ---&gt; PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); ---&gt; invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); ---&gt; postProcessor.postProcessBeanDefinitionRegistry(registry); ---&gt; processConfigBeanDefinitions(registry); ---&gt; this.reader.loadBeanDefinitions(configClasses);</p>
<pre><code class="language-java">public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
   //定义一个 list 存放 app 提供的 bd：项目当中提供了 @Component
   List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;();
   // 获取容器中注册的所有 bd 名字
   // 7 个
   String[] candidateNames = registry.getBeanDefinitionNames();
   // 依次取出每个&lt;beanName,beanDefinition&gt;
   /**
    * full
    * lite
    */
   for (String beanName : candidateNames) {
      BeanDefinition beanDef = registry.getBeanDefinition(beanName);
      // 判断当前 bean 是否被处理过：使用 isFullConfigurationClass 来标识
      if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
            ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {
         // 如果 BeanDefinition 中的 configurationClass 属性为 full 或者 lite，则意味着已经处理过了，直接跳过
         // 这里需要结合下面的代码才能理解
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Bean definition has already been processed as a configuration class: &quot; + beanDef);
         }
      }
      // 判断这个 BeanDefinition 是否是 Configuration类，如果加了 Configuration 下面的这几个注解就不再判断了
      // 还有  add(Component.class.getName())
      //         candidateIndicators.add(ComponentScan.class.getName())
      //         candidateIndicators.add(Import.class.getName())
      //         candidateIndicators.add(ImportResource.class.getName())
      else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
         configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
      }
   }
   // Return immediately if no @Configuration classes were found
   if (configCandidates.isEmpty()) {
      return;
   }
   // 排序，根据 order，不重要
   // Sort by previously determined @Order value, if applicable
   configCandidates.sort((bd1, bd2) -&gt; {
      int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
      int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
      return Integer.compare(i1, i2);
   });
   // Detect any custom bean name generation strategy supplied through the enclosing application context
   SingletonBeanRegistry sbr = null;
   // 如果 BeanDefinitionRegistry 是 SingletonBeanRegistry 子类的话
   // 由于会将 registry 强转为 SingletonBeanRegistry
   if (registry instanceof SingletonBeanRegistry) {
      sbr = (SingletonBeanRegistry) registry;
      if (!this.localBeanNameGeneratorSet) {//是否有自定义的
         BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);
         // SingletonBeanRegistry 中有 id 为 org.springframework.context.annotation.internalConfigurationBeanNameGenerator
         // 如果有则利用它的，否则则使用 Spring 默认的
         if (generator != null) {
            this.componentScanBeanNameGenerator = generator;
            this.importBeanNameGenerator = generator;
         }
      }
   }
   if (this.environment == null) {
      this.environment = new StandardEnvironment();
   }
   // Parse each @Configuration class
   // 实例化 ConfigurationClassParser 为了解析各个配置类
   ConfigurationClassParser parser = new ConfigurationClassParser(
         this.metadataReaderFactory, this.problemReporter, this.environment,
         this.resourceLoader, this.componentScanBeanNameGenerator, registry);
   // 实例化 2 个 set，candidates 用于将之前加入的 configCandidates 进行去重
   // 因为可能有多个配置类重复了
   // alreadyParsed 用户判断是否处理过
   Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates);
   Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size());
   do {
      parser.parse(candidates);
      parser.validate();
      Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());
      configClasses.removeAll(alreadyParsed);
      // Read the model and create bean definitions based on its content
      if (this.reader == null) {
         this.reader = new ConfigurationClassBeanDefinitionReader(
               registry, this.sourceExtractor, this.resourceLoader, this.environment,
               this.importBeanNameGenerator, parser.getImportRegistry());
      }
      // 把扫描出来的 bean 对应的 beanDefinitions 添加到 factory 的 map 当中
      this.reader.loadBeanDefinitions(configClasses);
      alreadyParsed.addAll(configClasses);
      candidates.clear();
      if (registry.getBeanDefinitionCount() &gt; candidateNames.length) {
         String[] newCandidateNames = registry.getBeanDefinitionNames();
         Set&lt;String&gt; oldCandidateNames = new HashSet&lt;&gt;(Arrays.asList(candidateNames));
         Set&lt;String&gt; alreadyParsedClasses = new HashSet&lt;&gt;();
         for (ConfigurationClass configurationClass : alreadyParsed) {
            alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
         }
         for (String candidateName : newCandidateNames) {
            if (!oldCandidateNames.contains(candidateName)) {
               BeanDefinition bd = registry.getBeanDefinition(candidateName);
               if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp;
                     !alreadyParsedClasses.contains(bd.getBeanClassName())) {
                  candidates.add(new BeanDefinitionHolder(bd, candidateName));
               }
            }
         }
         candidateNames = newCandidateNames;
      }
   }
   while (!candidates.isEmpty());
   // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes
   if (sbr != null &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {
      sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
   }
   if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {
      // Clear cache in externally provided MetadataReaderFactory; this is a no-op
      // for a shared cache since it'll be cleared by the ApplicationContext.
      ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();
   }
}
</code></pre>
<p>上述代码第 82 行：</p>
<pre><code class="language-java">Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());
</code></pre>
<pre><code>public Set&lt;ConfigurationClass&gt; getConfigurationClasses() {
   return this.configurationClasses.keySet();
}
</code></pre>
<pre><code class="language-java">private final Map&lt;ConfigurationClass, ConfigurationClass&gt; configurationClasses = new LinkedHashMap&lt;&gt;();
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/getConfigurationClasses.png" alt="图片" loading="lazy"></figure>
<p>通过 parser.getConfigurationClasses() 方法，得到：普通类 @Component、 @Import 类、本身类 appConfig ，其中 普通类、本身类已经注册了，@Import 类还没有注册。</p>
<p>如何知道哪些类还没有注册呢？</p>
<p>上述代码第 92 行：</p>
<pre><code class="language-java">this.reader.loadBeanDefinitions(configClasses);
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E6%89%A7%E8%A1%8CloadBeanDefinitions%E5%89%8D.png" alt="图片" loading="lazy"></figure>
<pre><code class="language-java">public void loadBeanDefinitions(Set&lt;ConfigurationClass&gt; configurationModel) {
   TrackedConditionEvaluator trackedConditionEvaluator = new TrackedConditionEvaluator();
   for (ConfigurationClass configClass : configurationModel) {
      loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);
   }
}
</code></pre>
<pre><code class="language-java">private void loadBeanDefinitionsForConfigurationClass(
      ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) {
   if (trackedConditionEvaluator.shouldSkip(configClass)) {
      String beanName = configClass.getBeanName();
      if (StringUtils.hasLength(beanName) &amp;&amp; this.registry.containsBeanDefinition(beanName)) {
         this.registry.removeBeanDefinition(beanName);
      }
      this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());
      return;
   }
   if (configClass.isImported()) {
      registerBeanDefinitionForImportedConfigurationClass(configClass);
   }
   for (BeanMethod beanMethod : configClass.getBeanMethods()) {
      loadBeanDefinitionsForBeanMethod(beanMethod);
   }
   loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());
   // 注册 Registrar
loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());
}
</code></pre>
<p>上述代码第 22 行：</p>
<pre><code class="language-java">private void loadBeanDefinitionsFromRegistrars(Map&lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&gt; registrars) {
   registrars.forEach((registrar, metadata) -&gt;
         registrar.registerBeanDefinitions(metadata, this.registry));
}
</code></pre>
<p>如果一个类是 Registrar，将它放到 importBeanDefinitionRegistrars 中，循环遍历 importBeanDefinitionRegistrars  注册。<br>
当执行完 this.reader.loadBeanDefinitions(configClasses);</p>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/%E6%89%A7%E8%A1%8CloadBeanDefinitions%E5%90%8E.png" alt="图片" loading="lazy"></figure>
<p>IndexDaoImpl2 是通过 @Bean 注入到容器中的，IndexDaoImpl3 是通过 “将 @ImportSelector 返回的字符串放到 map 中” 注入到容器中的。</p>
<h2 id="registrar">Registrar</h2>
<p>先放到 importBeanDefinitionRegistrars 中，然后再 通过 loadBeanDefinitionsFromRegistrars 方法注册。</p>
<p>processImports 方法的第 39-49 行：</p>
<pre><code class="language-java">else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
    // Candidate class is an ImportBeanDefinitionRegistrar -&gt;
    // delegate to it to register additional bean definitions
    Class&lt;?&gt; candidateClass = candidate.loadClass();
    ImportBeanDefinitionRegistrar registrar = BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);
    ParserStrategyUtils.invokeAwareMethods(registrar, this.environment, this.resourceLoader, this.registry);
    // 添加到一个 list 当中和 importSelector 不同
    configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
}
</code></pre>
<p>如果有一个类是 ImportBeanDefinitionRegistrar，把这个类拿出来，把它实例化，放到 configClass 中。<br>
上述代码第 8 行：</p>
<pre><code class="language-java">public void addImportBeanDefinitionRegistrar(ImportBeanDefinitionRegistrar registrar, AnnotationMetadata importingClassMetadata) {
   this.importBeanDefinitionRegistrars.put(registrar, importingClassMetadata);
}
</code></pre>
<pre><code class="language-java">private final Map&lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&gt; importBeanDefinitionRegistrars = new LinkedHashMap&lt;&gt;();
</code></pre>
<h2 id="import-普通类">import 普通类</h2>
<p><strong>先放到 configurationClasses，注册时判断里面有没有，如果有就不注册了，因为扫描出来的已经有了</strong>。</p>
<p>processImports 方法第 51-62 行：</p>
<pre><code class="language-java">else {
    // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt;
    // process it as an @Configuration class
    // 否则，加入到 importStack 后调用 processConfigurationClass 进行处理
    // processConfigurationClass 里面主要就是把类放到 configurationClasses
    // configurationClasses 是一个集合，会在后面拿出来解析成 bd 继而注册
    // 可以看到普通类在扫描出来的时候就被注册了
    // 如果是 importSelector，会先放到 configurationClasses 后面进行出来注册
    this.importStack.registerImport(currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
               processConfigurationClass(candidate.asConfigClass(configClass));
}     
</code></pre>
<p>上述代码第 10 行：</p>
<pre><code class="language-java">protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
   // 判断是否应该跳过解析
   if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
      return;
   }
   // 处理 Imported 的情况
   // 就是当前这个类有没有被别的类 @Import
   ConfigurationClass existingClass = this.configurationClasses.get(configClass);
   if (existingClass != null) {
      if (configClass.isImported()) {
         if (existingClass.isImported()) {
            existingClass.mergeImportedBy(configClass);
         }
         // Otherwise ignore new imported config class; existing non-imported class overrides it.
         return;
      }
      else {
         // Explicit bean definition found, probably replacing an import.
         // Let's remove the old one and go with the new one.
         this.configurationClasses.remove(configClass);
         this.knownSuperclasses.values().removeIf(configClass::equals);
      }
   }
   // Recursively process the configuration class and its superclass hierarchy.
   SourceClass sourceClass = asSourceClass(configClass);
   do {
      sourceClass = doProcessConfigurationClass(configClass, sourceClass);
   }
   while (sourceClass != null);
   // 一个 map，用来存放扫描出来的 bean（注意这里的 bean 不是对象，仅仅是 bean 的信息，因为还没到实例化）
   this.configurationClasses.put(configClass, configClass);
}
</code></pre>
<p>至此为止，执行完了 自定义的 BeanDefinitionRegistryPostProcessor + Spring 内部的 BeanDefinitionRegistryPostProcessor 所有的 postProcessBeanDefinitionRegistry 方法。<br>
context. refresh(); ---&gt; invokeBeanFactoryPostProcessors(beanFactory); ---&gt; PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); 获取<strong>自定义的 beanFactoryPostProcessors+ Spring 内部自己实现了 BeanDefinitionRegistryPostProcessor 接口的对象</strong></p>
<p>---&gt; invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); <strong>执行所有 BeanDefinitionRegistryPostProcessor</strong>---&gt; postProcessor.postProcessBeanDefinitionRegistry(registry); ---&gt; processConfigBeanDefinitions(registry); ---&gt; parser.parse(candidates); 解析：把普通类放到 map 中；this.reader.loadBeanDefinitions(configClasses); 特殊类：处理所有的 @Import；</p>
<pre><code class="language-java">public static void invokeBeanFactoryPostProcessors(
      ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) {
   // Invoke BeanDefinitionRegistryPostProcessors first, if any.
   Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;();
   if (beanFactory instanceof BeanDefinitionRegistry) {
      BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
      // 定义两个 list， BeanDefinitionRegistryPostProcessor 实现了 BeanFactoryPostProcessor 接口
      // 因为 bdrp 是子类，子类肯定扩展了父类中的功能。
      List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;();
      List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;();
      // 自定义的 beanFactoryPostProcessors
      for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
         if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
            BeanDefinitionRegistryPostProcessor registryProcessor =
                  (BeanDefinitionRegistryPostProcessor) postProcessor;
            registryProcessor.postProcessBeanDefinitionRegistry(registry);
            registryProcessors.add(registryProcessor);
         }
         else {
            regularPostProcessors.add(postProcessor);
         }
      }
      // Do not initialize FactoryBeans here: We need to leave all regular beans
      // uninitialized to let the bean factory post-processors apply to them!
      // Separate between BeanDefinitionRegistryPostProcessors that implement
      // PriorityOrdered, Ordered, and the rest.
      // 这个 currentRegistryProcessors 放的是 Spring 内部自己实现了 BeanDefinitionRegistryPostProcessor 接口的对象
      List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;();
      // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
      // BeanDefinitionRegistryPostProcessor 等于 BeanFactoryPostProcessor
      // getBeanNamesForType：根据 bean 的 Type 类型获取 bean 的名字
      String[] postProcessorNames =
            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
      // 这个地方可以得到一个 BeanFactoryPostProcessor，因为是 Spring 默认在最开始自己注册的
      // 为什么要在最开始注册这个呢？
      // 因为 Spring 的工厂需要注解去扫描等等功能
      // 而这些功能都是需要在 Spring 工厂初始化完成之前就执行
      // 要么在工厂最开始的时候，要么在工厂初始化之中，反正不能在之后
      // 因为如果在之后就没有意义，因为那个时候已经需要使用工厂了
      // 所以这里 Spring 在一开始就注册了一个 BeanFactoryPostProcessor，用来插手 springFactory 的实例化过程
      // 在这个地方断点可以知道这个类叫做 ConfigurationClassPostProcessor
      // ConfigurationClassPostProcessor 那么这个类能干嘛呢？可以参考源码
      // 下面对这个“插手 Spring 工厂实例化过程”的类重点解释
      for (String ppName : postProcessorNames) {
         if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
         }
      }
      // 排序不重要，况且 currentRegistryProcessor 这里也只有一个数据
      sortPostProcessors(currentRegistryProcessors, beanFactory);
      // 合并 List，不重要（为什么要合并，因为有自定义的Spring自己的）
      registryProcessors.addAll(currentRegistryProcessors);
      // 最重要。注意这里是方法调用
      // 执行所有 BeanDefinitionRegistryPostProcessor
      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
      // 执行完了所有的 BeanDefinitionRegistryPostProcessor
      // 这个 list 只是一个临时变量，故而要清除
      currentRegistryProcessors.clear();
      // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
      for (String ppName : postProcessorNames) {
         if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
         }
      }
      sortPostProcessors(currentRegistryProcessors, beanFactory);
      registryProcessors.addAll(currentRegistryProcessors);
      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
      currentRegistryProcessors.clear();
      // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
      boolean reiterate = true;
      while (reiterate) {
         reiterate = false;
         postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
         for (String ppName : postProcessorNames) {
            if (!processedBeans.contains(ppName)) {
               currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
               processedBeans.add(ppName);
               reiterate = true;
            }
         }
         sortPostProcessors(currentRegistryProcessors, beanFactory);
         registryProcessors.addAll(currentRegistryProcessors);
         invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
         currentRegistryProcessors.clear();
      }
      // Now, invoke the postProcessBeanFactory callback of all processors handled so far.
      // 执行 BeanFactoryPostProcessor 的回调，前面不是吗？
      // 前面执行的 BeanFactoryPostProcessor 的子类 BeanDefinitionRegistryPostProcessor 的回调
      // 这里执行的是 BeanFactoryPostProcessor 的回调
      invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
      //
      invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
   }
   else {
      // Invoke factory processors registered with the context instance.
      invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
   }
   // Do not initialize FactoryBeans here: We need to leave all regular beans
   // uninitialized to let the bean factory post-processors apply to them!
   String[] postProcessorNames =
         beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);
   // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
   // Ordered, and the rest.
   List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();
   List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();
   List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();
   for (String ppName : postProcessorNames) {
      if (processedBeans.contains(ppName)) {
         // skip - already processed in first phase above
      }
      else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
         priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
      }
      else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
         orderedPostProcessorNames.add(ppName);
      }
      else {
         nonOrderedPostProcessorNames.add(ppName);
      }
   }
   // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
   invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);
   // Next, invoke the BeanFactoryPostProcessors that implement Ordered.
   List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();
   for (String postProcessorName : orderedPostProcessorNames) {
      orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
   }
   sortPostProcessors(orderedPostProcessors, beanFactory);
   invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);
   // Finally, invoke all other BeanFactoryPostProcessors.
   List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();
   for (String postProcessorName : nonOrderedPostProcessorNames) {
      nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
   }
   invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);
   // Clear cached merged bean definitions since the post-processors might have
   // modified the original metadata, e.g. replacing placeholders in values...
   beanFactory.clearMetadataCache();
}
</code></pre>
<p>上述第 98-102 行代码：</p>
<pre><code class="language-java">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.
// 执行 BeanFactoryPostProcessor 的回调，前面不是吗？
// 前面执行的 BeanFactoryPostProcessor 的子类 BeanDefinitionRegistryPostProcessor 的回调
// 这里执行的是 BeanFactoryPostProcessor 的回调
invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
</code></pre>
<p>执行 BeanFactoryPostProcessor 的回调，前面不是吗？<br>
前面执行的 BeanFactoryPostProcessor 的子类 BeanDefinitionRegistryPostProcessor 的回调。这里执行的是 BeanFactoryPostProcessor 的回调。</p>
<p>于是我们来看一下前面的代码验证一下，上述方法第 16 行，判断是不是 BeanDefinitionRegistryPostProcessor，如果是，就把它放到 registryProcessors 中：</p>
<pre><code class="language-java">for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
   if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
      BeanDefinitionRegistryPostProcessor registryProcessor =
            (BeanDefinitionRegistryPostProcessor) postProcessor;
      registryProcessor.postProcessBeanDefinitionRegistry(registry);
      registryProcessors.add(registryProcessor);
   }
   else {
      regularPostProcessors.add(postProcessor);
   }
}
</code></pre>
<p>接下来看 invokeBeanFactoryPostProcessors 方法：完成 BeanFactoryPostProcessor 的回调</p>
<pre><code class="language-java">private static void invokeBeanFactoryPostProcessors(
      Collection&lt;? extends BeanFactoryPostProcessor&gt; postProcessors, ConfigurableListableBeanFactory beanFactory) {
   for (BeanFactoryPostProcessor postProcessor : postProcessors) {
      postProcessor.postProcessBeanFactory(beanFactory);
   }
}
</code></pre>
<p>点进来这个方法：</p>
<pre><code class="language-java">public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
   int factoryId = System.identityHashCode(beanFactory);
   if (this.factoriesPostProcessed.contains(factoryId)) {
      throw new IllegalStateException(
            &quot;postProcessBeanFactory already called on this post-processor against &quot; + beanFactory);
   }
   this.factoriesPostProcessed.add(factoryId);
   if (!this.registriesPostProcessed.contains(factoryId)) {
      // BeanDefinitionRegistryPostProcessor hook apparently not supported...
      // Simply call processConfigurationClasses lazily at this point then.
      processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);
   }
   // 产生 cglib 代理
   // 为什么需要产生 cglib 代理
   enhanceConfigurationClasses(beanFactory);
   beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory));
}
</code></pre>
<h1 id="full-与-lite">FULL 与 LITE</h1>
<p>上述代码第 16 行：</p>
<pre><code class="language-java">public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) {
   Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = new LinkedHashMap&lt;&gt;();
   for (String beanName : beanFactory.getBeanDefinitionNames()) {
      BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);
      // 判断是否是一个全注解类
      // 什么是全注解类？FULL 和 LITE
      if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) {
         if (!(beanDef instanceof AbstractBeanDefinition)) {
            throw new BeanDefinitionStoreException(&quot;Cannot enhance @Configuration bean definition '&quot; +
                  beanName + &quot;' since it is not stored in an AbstractBeanDefinition subclass&quot;);
         }
         else if (logger.isWarnEnabled() &amp;&amp; beanFactory.containsSingleton(beanName)) {
            logger.warn(&quot;Cannot enhance @Configuration bean definition '&quot; + beanName +
                  &quot;' since its singleton instance has been created too early. The typical cause &quot; +
                  &quot;is a non-static @Bean method with a BeanDefinitionRegistryPostProcessor &quot; +
                  &quot;return type: Consider declaring such methods as 'static'.&quot;);
         }
         configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);
      }
   }
   if (configBeanDefs.isEmpty()) {
      // nothing to enhance -&gt; return immediately
      return;
   }
   ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer();
   for (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) {
      AbstractBeanDefinition beanDef = entry.getValue();
      // If a @Configuration class gets proxied, always proxy the target class
      beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);
      try {
         // Set enhanced subclass of the user-specified bean class
         Class&lt;?&gt; configClass = beanDef.resolveBeanClass(this.beanClassLoader);
         if (configClass != null) {
            Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, this.beanClassLoader);
            if (configClass != enhancedClass) {
               if (logger.isDebugEnabled()) {
                  logger.debug(String.format(&quot;Replacing bean definition '%s' existing class '%s' with &quot; +
                        &quot;enhanced class '%s'&quot;, entry.getKey(), configClass.getName(), enhancedClass.getName()));
               }
               beanDef.setBeanClass(enhancedClass);
            }
         }
      }
      catch (Throwable ex) {
         throw new IllegalStateException(&quot;Cannot load configuration class: &quot; + beanDef.getBeanClassName(), ex);
      }
   }
}
</code></pre>
<p>如果没有添加 @Configuration 会直接在上述代码第 23 行 return;<br>
如果添加了 @Configuration 后，就不会在第 23 行 return;而是会继续向下走到第 26 行。</p>
<p>加了 @Configuration 会进行 cglib 代理，如果不加 @Configuration  就不会进行 cglib 动态代理。</p>
<p>为什么加了 @Configuration 能够向下走到第 26 行呢？</p>
<p>上述代码第 5-8 行：</p>
<pre><code class="language-java">// 判断是否是一个全注解类
// 什么是全注解类？FULL 和 LITE
if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) {
  if (!(beanDef instanceof AbstractBeanDefinition)) {  
</code></pre>
<p>在解析 AppConfig 时，如果 AppConfig 有 @Configuration 注解，就会给它设置一个属性 FULL；如果没有，就设置属性 LITE。<br>
<strong>FULL 与 LITE 只是 Spring 当中的一个标识，Spring 标识为 FULL，表示它是一个全配置类，Spring 在为它生成 Bean 时，会加上 cglib 代理。标志为 LITE，表示它是一个部分配置类</strong>。</p>
<p><img src="https://epitomm.github.io/post-images/%E6%B7%BB%E5%8A%A0@Configuration%E6%B3%A8%E8%A7%A3.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/%E4%B8%8D%E6%B7%BB%E5%8A%A0@Configuration%E6%B3%A8%E8%A7%A3.png" alt="图片" loading="lazy"></p>
<h1 id="为什么要给这个类加上-cglib-动态代理">为什么要给这个类加上 cglib 动态代理</h1>
<pre><code class="language-java">public class IndexDaoImpl2 implements IndexDao{
   @Override
   public void query() {
      System.out.println(&quot;dao2...模拟查询数据库&quot;);
   }
}
</code></pre>
<pre><code class="language-java">public class IndexDaoImpl implements IndexDao{
   public IndexDaoImpl(){
      System.out.println(&quot;indexDao...constructor&quot;);
   }
   @Override
   public void query() {
      System.out.println(&quot;dao...模拟查询数据库&quot;);
   }
}
</code></pre>
<pre><code class="language-java">@ComponentScan(&quot;com.ssm&quot;)
public class AppConfig {
   @Bean
   public IndexDao indexDao2(){
      return new IndexDaoImpl2();
   }
   @Bean
   public IndexDao indexDao(){
      return new IndexDaoImpl();
   }
}
</code></pre>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      // 初始化 Spring 的环境
      context. refresh();
   }
}
</code></pre>
<p>运行结果：</p>
<pre><code>indexDao...constructor
</code></pre>
<p>分析：当执行 indexDao() 时，new IndexDaoImpl()，调用 IndexDaoImpl 的构造方法，所以IndexDaoImpl 的构造方法执行一次。</p>
<pre><code class="language-java">@ComponentScan(&quot;com.ssm&quot;)
public class AppConfig {
   @Bean
   public IndexDao indexDao2(){
      indexDao();
      return new IndexDaoImpl2();
   }
   @Bean
   public IndexDao indexDao(){
      return new IndexDaoImpl();
   }
}
</code></pre>
<p>运行结果：</p>
<pre><code>indexDao...constructor
indexDao...constructor
</code></pre>
<p>分析：当执行 indexDao() 时，new IndexDaoImpl()，调用 IndexDaoImpl 的构造方法。<br>
当执行 indexDao2 方法时，再次调用 indexDao(); 方法，所以IndexDaoImpl 的构造方法共执行了两次。</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
public class AppConfig {
   @Bean
   public IndexDao indexDao2(){
      indexDao();
      return new IndexDaoImpl2();
   }
   @Bean
   public IndexDao indexDao(){
      return new IndexDaoImpl();
   }
}
</code></pre>
<p>运行结果：</p>
<pre><code>indexDao...constructor
</code></pre>
<p>分析：<strong>添加了 @Configuration 后，仅调用一次 IndexDao 的构造方法</strong>。<br>
indexDao() 方法被改变了，即使在 indexDao2() 内再次调用 indexDao()，也不会执行方法内的代码 new IndexDaoImpl(); 了。</p>
<p>如何改变一个方法 indexD()？</p>
<p><strong>代理 AppConfig</strong>，当调用 AppConfig 的 indexDao() 时，调用的是代理类 AppConfig 内部的 indexDao()，而不是普通类 AppConfig 内部的 indexDao()。</p>
<pre><code class="language-java">public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) {
   Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = new LinkedHashMap&lt;&gt;();
   for (String beanName : beanFactory.getBeanDefinitionNames()) {
      BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);
      // 判断是否是一个全注解类
      // 什么是全注解类？FULL 和 LITE
      if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) {
         if (!(beanDef instanceof AbstractBeanDefinition)) {
            throw new BeanDefinitionStoreException(&quot;Cannot enhance @Configuration bean definition '&quot; +
                  beanName + &quot;' since it is not stored in an AbstractBeanDefinition subclass&quot;);
         }
         else if (logger.isWarnEnabled() &amp;&amp; beanFactory.containsSingleton(beanName)) {
            logger.warn(&quot;Cannot enhance @Configuration bean definition '&quot; + beanName +
                  &quot;' since its singleton instance has been created too early. The typical cause &quot; +
                  &quot;is a non-static @Bean method with a BeanDefinitionRegistryPostProcessor &quot; +
                  &quot;return type: Consider declaring such methods as 'static'.&quot;);
         }
         //  如果是一个全注解，添加到 configBeanDefs 中；如果不是全注解，则不会put，即 configBeanDefs 为空
         configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);
      }
   }
   // 如果不是全注解，configBeanDefs 为空，直接 return;
   if (configBeanDefs.isEmpty()) {
      // nothing to enhance -&gt; return immediately
      return;
   }
   ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer();
   for (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) {
      AbstractBeanDefinition beanDef = entry.getValue();
      // If a @Configuration class gets proxied, always proxy the target class
      beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);
      try {
         // Set enhanced subclass of the user-specified bean class
         Class&lt;?&gt; configClass = beanDef.resolveBeanClass(this.beanClassLoader);
         if (configClass != null) {
            // 完成对全注解类的 cglib 代理
            Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, this.beanClassLoader);
            if (configClass != enhancedClass) {
               if (logger.isDebugEnabled()) {
                  logger.debug(String.format(&quot;Replacing bean definition '%s' existing class '%s' with &quot; +
                        &quot;enhanced class '%s'&quot;, entry.getKey(), configClass.getName(), enhancedClass.getName()));
               }
               beanDef.setBeanClass(enhancedClass);
            }
         }
      }
      catch (Throwable ex) {
         throw new IllegalStateException(&quot;Cannot load configuration class: &quot; + beanDef.getBeanClassName(), ex);
      }
   }
}
</code></pre>
<p>上述代码第 38 行：</p>
<pre><code class="language-java">public Class&lt;?&gt; enhance(Class&lt;?&gt; configClass, @Nullable ClassLoader classLoader) {
   if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {
      if (logger.isDebugEnabled()) {
         logger.debug(String.format(&quot;Ignoring request to enhance %s as it has &quot; +
               &quot;already been enhanced. This usually indicates that more than one &quot; +
               &quot;ConfigurationClassPostProcessor has been registered (e.g. via &quot; +
               &quot;&lt;context:annotation-config&gt;). This is harmless, but you may &quot; +
               &quot;want check your configuration and remove one CCPP if possible&quot;,
               configClass.getName()));
      }
      return configClass;
   }
   // cglib 代理
   Class&lt;?&gt; enhancedClass = createClass(newEnhancer(configClass, classLoader));
   if (logger.isDebugEnabled()) {
      logger.debug(String.format(&quot;Successfully enhanced %s; enhanced class name is: %s&quot;,
            configClass.getName(), enhancedClass.getName()));
   }
   return enhancedClass;
}
</code></pre>
<p>创建一个类，把这个类 enhancedClass  返回，因为此时还没有实例化对象，<br>
AppConfig - cglib的class - BeanDefinition - cglib的Bean</p>
<p>如何返回一个 cglib 的 class？</p>
<p>上述代码第 14 行：</p>
<pre><code class="language-java">private Enhancer newEnhancer(Class&lt;?&gt; configSuperClass, @Nullable ClassLoader classLoader) {
   Enhancer enhancer = new Enhancer();
   // 增强父类，cglib 是基于继承来的
   // 把当前类 configSuperClass 作为 enhancer 的父类
   enhancer.setSuperclass(configSuperClass);
   // 增强接口，为什么要增强接口？
   // 便于判断，表示一个类已经被增强了
   enhancer.setInterfaces(new Class&lt;?&gt;[] {EnhancedConfiguration.class});
   enhancer.setUseFactory(false);
   enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
   // BeanFactoryAwareGeneratorStrategy 是一个生成策略
   // 主要为生成的 CGLIB 类中添加成员变量 $$beanFactory
   // 同时基于接口 EnhancedConfiguration 的父接口 BeanFactoryAware 中的 setBeanFactory 方法，
   // 设置此变量的值为当前 Context 中的 beanFactory，这样一来我们这个 cglib 代理的对象就有了 beanFactory
   // 有了 factory 就能获得对象，而不用去通过方法获得对象了，因为通过方法获得对象不能控制其过程
   // BeanFactory 的作用是在 this 调用时拦截该调用，并直接在 beanFactory 中获得目标 bean
   enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader));
   // 当调用 indexDao() 时进行拦截
   enhancer.setCallbackFilter(CALLBACK_FILTER);
   enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());
   return enhancer;
}
</code></pre>
<p>EnhancedConfiguration 继承了 BeanFactoryAware</p>
<pre><code class="language-java">public interface EnhancedConfiguration extends BeanFactoryAware {
</code></pre>
<p>BeanFactoryAware 实现了 Aware，Aware 里面有一个 setBeanFactory 方法</p>
<pre><code class="language-java">public interface BeanFactoryAware extends Aware {
   /**
    * Callback that supplies the owning factory to a bean instance.
    * &lt;p&gt;Invoked after the population of normal bean properties
    * but before an initialization callback such as
    * {@link InitializingBean#afterPropertiesSet()} or a custom init-method.
    * @param beanFactory owning BeanFactory (never {@code null}).
    * The bean can immediately call methods on the factory.
    * @throws BeansException in case of initialization errors
    * @see BeanInitializationException
    */
   void setBeanFactory(BeanFactory beanFactory) throws BeansException;
}
</code></pre>
<p>让 CGLIB 产生的代理对象能够获得 BeanFactory。</p>
<h3 id="cglib-的代理对象为什么要得到-beanfactory">CGLIB 的代理对象为什么要得到 BeanFactory？</h3>
<p>AppConfig 在执行代理前直接使用它得到原始类，就会执行原始类中的原始方法，每调用一次 indexDao() 方法，就会 new IndexDaoImpl(); 违背了 Spring 中的单例原则，所以不能使用原始对象，就需要使用代理对象，当再次调用 indexDao() 方法时，执行代理对象内的 indexDao() 方法，不再 new  IndexDaoImpl()，而是直接返回已经存在的 IndexDaoImpl。</p>
<p>![图片](https://epitomm.github.io/post-images/CGLIB的代理对象为什么要得到 BeanFactory.png)</p>
<p>当第一次调用 indexDao() 时，new IndexDaoImpl()，放到容器中，当第二次调用时，不再 new，而是直接从容器中拿出来 <strong>factory.getBean()</strong>，就需要在代理对象中有一个 BeanFactory，不然没办法 factory.getBean()。</p>
<h3 id="如何得到一个-beanfactory">如何得到一个 BeanFactory？</h3>
<p>实现 BeanFactoryAware 接口，后置处理器在实例化对象前，把它放进来。</p>
<p>BeanFactoryAwareGeneratorStrategy：CGLIB 生成类的策略。</p>
<p>默认策略：DefaultGeneratorStrategy，生成基本的。如果需要扩展，使用一个类 BeanFactoryAwareGeneratorStrategy：CGLIB  继承 DefaultGeneratorStrategy，在生成这个类的过程中，调用 declare_field 方法：声明一个属性 $$beanFactory。</p>
<pre><code class="language-java">protected ClassGenerator transform(ClassGenerator cg) throws Exception {
   ClassEmitterTransformer transformer = new ClassEmitterTransformer() {
      @Override
      public void end_class() {
         declare_field(Constants.ACC_PUBLIC, BEAN_FACTORY_FIELD, Type.getType(BeanFactory.class), null);
         super.end_class();
      }
   };
   return new TransformingClassGenerator(cg, transformer);
}
</code></pre>
<pre><code class="language-java">private static final String BEAN_FACTORY_FIELD = &quot;$$beanFactory&quot;;
</code></pre>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      // 把 Spring 所有前提环境准备好
      // 1.准备工厂=DefaultListableBeanFactory
      // 实例化一个 bdReader 和一个 scanner
      AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext();
      // 把一个 class 转成 bd，最后 put 到 map
      // map 位置 DefaultListableBeanFactory 的 beanDefinitionMap
      context.register(AppConfig.class);
      // 初始化 Spring 的环境
      context. refresh();
      /**
        * 对目标对象的所有方法进行拦截
        */
      Enhancer enhancer = new Enhancer();
      enhancer.setSuperclass(IndexDaoImpl.class);
      // 增强接口
      enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
      // 添加方法过滤器
      enhancer.setCallback(new TestMethodCallabck());
      IndexDaoImpl indexDao = (IndexDaoImpl) enhancer.create();
      indexDao.query();
   }
}
</code></pre>
<pre><code class="language-java">public class TestMethodCallabck implements MethodInterceptor {
   /**
    *
    * @param o 代理对象
    * @param method 当前方法，目标对象的方法
    * @param objects 参数
    * @param methodProxy 代理对象的方法
    * @return
    * @throws Throwable
    */
   @Override
   public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
      System.out.println(&quot;method...&quot;);
      return methodProxy.invokeSuper(o,objects);
   }
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-java">indexDao...constructor
indexDao...constructor
method...
dao...模拟查询数据库
</code></pre>
<p>newEnhancer 方法的第 19 行：</p>
<pre><code class="language-java">private static final ConditionalCallbackFilter CALLBACK_FILTER = new ConditionalCallbackFilter(CALLBACKS);
</code></pre>
<pre><code class="language-java">private static final Callback[] CALLBACKS = new Callback[] {
      new BeanMethodInterceptor(),
      new BeanFactoryAwareMethodInterceptor(),
      NoOp.INSTANCE
};
</code></pre>
<h1 id="configuration">@Configuration</h1>
<p>让 AppConfig 产生一个 CGLIB 动态代理类，这个 CGLIB 代理类会去实现一个 BeanFactoryAware 接口，自动注入一个 BeanFactory，于是当再次调用 indexDao() 时，首先会判断是不是第一次，如果是，则 new IndexDaoImpl；如果不是，从 BeanFactory 中得到这个 Bean 并返回。</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.ssm&quot;)
public class AppConfig {
   @Bean
   public IndexDao indexDao2(){
      indexDao();
      return new IndexDaoImpl2();
   }
   @Bean
   public static IndexDao indexDao(){
      return new IndexDaoImpl();
   }
}
</code></pre>
<p>即使添加了 @Configuration，如果 使用 static 修饰 indexDao()，也会创建两遍</p>
<pre><code>indexDao...constructor
indexDao...constructor
</code></pre>
<pre><code class="language-java">private void loadBeanDefinitionsForConfigurationClass(
      ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) {
   if (trackedConditionEvaluator.shouldSkip(configClass)) {
      String beanName = configClass.getBeanName();
      if (StringUtils.hasLength(beanName) &amp;&amp; this.registry.containsBeanDefinition(beanName)) {
         this.registry.removeBeanDefinition(beanName);
      }
      this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());
      return;
   }
   // 如果一个类是被 import 的，会被 Spring 标注
   // 在这里完成注册
   if (configClass.isImported()) {
      registerBeanDefinitionForImportedConfigurationClass(configClass);
   }
   // BeanMethod：得到 AppConfig 中的所有包，
   for (BeanMethod beanMethod : configClass.getBeanMethods()) {
      loadBeanDefinitionsForBeanMethod(beanMethod);
   }
   // xml
   loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());
   // 注册 Registrar
   loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());
}
</code></pre>
<pre><code class="language-java">private void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {
   ConfigurationClass configClass = beanMethod.getConfigurationClass();
   MethodMetadata metadata = beanMethod.getMetadata();
   String methodName = metadata.getMethodName();
   // Do we need to mark the bean as skipped by its condition?
   if (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {
      configClass.skippedBeanMethods.add(methodName);
      return;
   }
   if (configClass.skippedBeanMethods.contains(methodName)) {
      return;
   }
   AnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);
   Assert.state(bean != null, &quot;No @Bean annotation attributes&quot;);
   // Consider name and any aliases
   List&lt;String&gt; names = new ArrayList&lt;&gt;(Arrays.asList(bean.getStringArray(&quot;name&quot;)));
   String beanName = (!names.isEmpty() ? names.remove(0) : methodName);
   // Register aliases even when overridden
   for (String alias : names) {
      this.registry.registerAlias(beanName, alias);
   }
   // Has this effectively been overridden before (e.g. via XML)?
   if (isOverriddenByExistingDefinition(beanMethod, beanName)) {
      if (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) {
         throw new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(),
               beanName, &quot;Bean name derived from @Bean method '&quot; + beanMethod.getMetadata().getMethodName() +
               &quot;' clashes with bean name for containing configuration class; please make those names unique!&quot;);
      }
      return;
   }
   ConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass, metadata);
   beanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));
   if (metadata.isStatic()) {
      // static @Bean method
      beanDef.setBeanClassName(configClass.getMetadata().getClassName());
      beanDef.setFactoryMethodName(methodName);
   }
   else {
      // instance @Bean method
      beanDef.setFactoryBeanName(configClass.getBeanName());
      beanDef.setUniqueFactoryMethodName(methodName);
   }
   beanDef.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);
   beanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);
   AnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);
   Autowire autowire = bean.getEnum(&quot;autowire&quot;);
   if (autowire.isAutowire()) {
      beanDef.setAutowireMode(autowire.value());
   }
   String initMethodName = bean.getString(&quot;initMethod&quot;);
   if (StringUtils.hasText(initMethodName)) {
      beanDef.setInitMethodName(initMethodName);
   }
   String destroyMethodName = bean.getString(&quot;destroyMethod&quot;);
   beanDef.setDestroyMethodName(destroyMethodName);
   // Consider scoping
   ScopedProxyMode proxyMode = ScopedProxyMode.NO;
   AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(metadata, Scope.class);
   if (attributes != null) {
      beanDef.setScope(attributes.getString(&quot;value&quot;));
      proxyMode = attributes.getEnum(&quot;proxyMode&quot;);
      if (proxyMode == ScopedProxyMode.DEFAULT) {
         proxyMode = ScopedProxyMode.NO;
      }
   }
   // Replace the original bean definition with the target one, if necessary
   BeanDefinition beanDefToRegister = beanDef;
   if (proxyMode != ScopedProxyMode.NO) {
      BeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(
            new BeanDefinitionHolder(beanDef, beanName), this.registry,
            proxyMode == ScopedProxyMode.TARGET_CLASS);
      beanDefToRegister = new ConfigurationClassBeanDefinition(
            (RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);
   }
   if (logger.isDebugEnabled()) {
      logger.debug(String.format(&quot;Registering bean definition for @Bean method %s.%s()&quot;,
            configClass.getMetadata().getClassName(), beanName));
   }
   this.registry.registerBeanDefinition(beanName, beanDefToRegister);
}
</code></pre>
<p>上述代码第 40 行：</p>
<pre><code class="language-java">if (metadata.isStatic()) {
   // static @Bean method
   // 如果是静态的，BeanDefinition 中放的是 Bean   beanDef.setBeanClassName(configClass.getMetadata().getClassName());
   beanDef.setFactoryMethodName(methodName);
}
else {
   // instance @Bean method
   // 如果不是静态的，BeanDefinition 中放的是 FactoryBean
   // FactoryBean 是怎样被创建出来的？
   // FactoryBean 有两个意义：本身是一个 Bean，
   // 如何 new 出来一个 FactoryBean 给它呢？
   // 通过 setUniqueFactoryMethodName
   beanDef.setFactoryBeanName(configClass.getBeanName());
   beanDef.setUniqueFactoryMethodName(methodName);
}
</code></pre>
]]></content>
    </entry>
</feed>