<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://epitomm.github.io</id>
    <title>SSM</title>
    <updated>2020-04-21T09:18:59.508Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://epitomm.github.io"/>
    <link rel="self" href="https://epitomm.github.io/atom.xml"/>
    <subtitle>热心善良的老学姐</subtitle>
    <logo>https://epitomm.github.io/images/avatar.png</logo>
    <icon>https://epitomm.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, SSM</rights>
    <entry>
        <title type="html"><![CDATA[HTTP（一）了解 HTTP 协议]]></title>
        <id>https://epitomm.github.io/post/httpyi-liao-jie-http-xie-yi/</id>
        <link href="https://epitomm.github.io/post/httpyi-liao-jie-http-xie-yi/">
        </link>
        <updated>2020-04-21T09:10:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="浏览器背后的故事">浏览器背后的故事</h1>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%85%E4%BA%8B.png" alt="图片" loading="lazy"></figure>
<ol>
<li>在浏览器地址栏<strong>输入域名</strong>想要访问某个网站，但是真正标识服务器的而是 IP 地址。</li>
<li>根据域名到 <strong>DNS 服务器中查询目标服务器对应的 IP 地址</strong></li>
<li>浏览器根据查询到的 IP 地址<strong>与 WEB 服务器进行通信</strong>，通信的协议就是 HTTP 协议。</li>
</ol>
<blockquote>
<p>把这个过程类比为电话通信的过程。如果我们想要给某个人打电话。</p>
<ol>
<li>从通讯录翻到这个人的名字（域名）</li>
<li>实际拨打过去的电话号（IP 地址）<br>
我们很容易记住姓名，但很难记住每个人的电话号。</li>
<li>打通电话后需要进行对话，就需要两个人使用共同的语言（HTTP 协议）。</li>
</ol>
</blockquote>
<ol>
<li>WEB 服务器收到请求，到后端进行执行，将执行结果以<strong>响应报文</strong>的形式回传到浏览器，如果直接将响应报文展示出来，是一串串代码，普通人难以理解。</li>
<li>浏览器对响应报文进行<strong>渲染</strong>，使用 HTML 描述对应数据，把网页资源的源代码转换为图像结果。</li>
</ol>
<h2 id="http">HTTP</h2>
<ul>
<li>超文本传输协议（HTTP）是一种<strong>通信协议</strong>，它允许将超文本标记语言（HTML）文档从Web服务器传送到客户端的浏览器。</li>
</ul>
<blockquote>
<p>超文本传输协议：传输超文本（HTML）的协议。在服务端和客户端传输 HTML 要遵守的<strong>规则</strong>。</p>
</blockquote>
<ul>
<li>HTTP是一个属于<strong>应用层的面向对象的协议</strong>，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展</li>
</ul>
<h2 id="web-与-http">WEB 与 HTTP</h2>
<ul>
<li>WEB是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式<strong>图形信息系统</strong>。</li>
<li>建立在Internet上的一种<strong>网络服务</strong>，为浏览者在Internet上查找和浏览信息提供了图形化的、易于访问的直观界面，其中的文档及超级链接将Internet上的信息节点组织成一个互为关联的网状结构。</li>
</ul>
<h1 id="http-协议的前世今生">HTTP 协议的前世今生</h1>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.png" alt="图片" loading="lazy"></figure>
<h1 id="透过-tcpip-看-http">透过 TCP/IP 看 HTTP</h1>
<ul>
<li>HTTP协议是构建在 <strong>TCP/IP</strong> 协议之上的，是TCP/IP协议的一个子集</li>
<li>为了更好的理解HTTP协议，我们先了解一下TCP/IP的相关知识。</li>
</ul>
<h2 id="tcpip协议族">TCP/IP协议族</h2>
<ul>
<li>TCP/IP 协议其实是一系列与互联网相关联的协议集合起来的总称</li>
<li>分层管理是 TCP/IP 协议的重要特征</li>
</ul>
<h2 id="tcpip协议族分层">TCP/IP协议族分层</h2>
<ul>
<li>TCP/IP协议族是由一个四层协议组成的系统，这四层分别为：和数据链路层、网络层、运输层、应用层</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E5%9B%9B%E5%B1%82%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84.png" alt="图片" loading="lazy"></figure>
<h3 id="应用层">应用层</h3>
<ul>
<li>应用层一般是我们编写的应用程序，决定了向用户提供的应用服务。应用层可以通过系统调用与传输层进行通信。</li>
<li>如：<strong>FTP、DNS、HTTP</strong>等。</li>
</ul>
<h3 id="传输层">传输层</h3>
<ul>
<li>传输层通过系统调用向应用层提供处于网络连接中的两台计算机之间的数据传输功能。</li>
<li>在传输层有两个性质不同的协议：**TCP **和 <strong>UDP</strong>。</li>
</ul>
<h3 id="网络层">网络层</h3>
<ul>
<li>网络层用来处理在网络上流动的数据包，数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（<strong>传输路线</strong>）到达对方计算机，并把数据包传输给对方。</li>
</ul>
<h3 id="链路层">链路层</h3>
<ul>
<li>链路层用来处理连接网络的<strong>硬件</strong>部分，包括控制操作系统、硬件设备驱动、NIC（Network Interface Card，网络适配器）以及光纤等物理可见部分。硬件上的范畴均在链路层的作用范围之内。</li>
</ul>
<h2 id="数据包的封装过程">数据包的封装过程</h2>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%B0%81%E8%A3%85%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<h2 id="http-数据传输过程">HTTP 数据传输过程</h2>
<p>发送端发送数据时，数据会从上层传输到下层，且每经过一层都会被打上该层的头部信息。而接收端接收数据时，数据会从下层传输到上层，传输前会把下层的头部信息删除</p>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/HTTP%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<p>发送端从应用层向下走，接收端从链路层向上走。</p>
<ul>
<li>作为发送端的客户端，在<strong>应用层</strong>，通过 HTTP 协议发出一个请求，</li>
<li>为了传输方便，在<strong>传输层</strong>，通过 TCP 协议把应用层收到的数据（HTTP 请求报文）进行分割并且在各个报文上打上标记序号、端口号等信息，发送到网络层</li>
<li>在<strong>网络层</strong>，通过 IP 协议，增加作为目的地的 MAC 地址，转发给链路层。</li>
<li><strong>链路层</strong>添加帧头、帧尾后，通过电信号传输给接收端。</li>
<li><strong>接收端</strong>的服务器在链路层接收到请求的数据，按顺序向上层发送，一直发送到应用层。</li>
</ul>
<h2 id="传输层-tcp-三次握手">传输层 —— TCP 三次握手</h2>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="图片" loading="lazy"></figure>
<p>使用TCP协议进行通信的双方必须先建立连接，然后才能开始传输数据。为了确保连接双方可靠性，在双方建立连接时，TCP协议采用了三次握手策略。</p>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B2.png" alt="图片" loading="lazy"></figure>
<ul>
<li><strong>第一次握手</strong>：客户端发送带有 SYN 标志的连接请求报文段，然后进入SYN_SEND状态，等待服务端的确认。</li>
</ul>
<blockquote>
<p>客户端：客户端发送能力正常<br>
服务端：客户端发送能力正常、服务端接收能力正常</p>
</blockquote>
<ul>
<li><strong>第二次握手</strong>：服务端接收到客户端的 SYN 报文段后，需要发送 ACK 信息对这个 SYN 报文段进行确认。同时，还要发送自己的 SYN 请求信息。服务端会将上述的信息放到一个报文段（SYN+ACK报文段）中，一并发送给客户端，此时服务端将会进入SYN_RECV状态。</li>
</ul>
<blockquote>
<p>客户端：客户端发送能力正常、服务端接收能力正常、客户端接收能力正常、服务端发送能力正常<br>
服务端：客户端发送能力正常、服务端接收能力正常</p>
</blockquote>
<ul>
<li><strong>第三次握手</strong>：客户端接收到服务端的 SYN+ACK 报文段后，会向服务端发送 ACK 确认报文段，这个报文段发送完毕后，客户端和服务端都进入 ESTABLISHED 状态，完成 TCP 三次握手。</li>
</ul>
<blockquote>
<p>客户端：客户端发送能力正常、服务端接收能力正常、客户端接收能力正常、服务端发送能力正常<br>
服务端：客户端发送能力正常、服务端接收能力正常、客户端端接收能力正常、服务端发送能力正常</p>
</blockquote>
<p>三次握手结束后，发送、接收双方都确认了彼此的发送和接收能力都正常。</p>
<h3 id="为什么两次握手不可以">为什么两次握手不可以？</h3>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8D%E5%8F%AF%E4%BB%A5.png" alt="图片" loading="lazy"></figure>
<p>为了防止已经失效的连接请求报文段突然又传送到了 B，因而产生错误。比如下面这种情况：A 发出的第一个连接请求报文段并没有丢失，而是在网路结点长时间滞留了，以致于延误到连接释放以后的某个时间段才到达 B。本来这是一个早已失效的报文段。但是 B 收到此失效的链接请求报文段后，就<strong>误认为 A 又发出一次新的连接请求</strong>。于是就向 A 发出确认报文段，同意建立连接。</p>
<p>对于上面这种情况，如果不进行第三次握手，<strong>B 发出确认后就认为新的运输连接已经建立了</strong>，并一直等待 A 发来数据。B 的许多资源就这样白白浪费了。</p>
<p>如果采用了三次握手，由于 A 实际上并没有发出建立连接请求，所以不会理睬 B 的确认，也不会向 B 发送数据。B 由于收不到确认，就知道 A 并没有要求建立连接。</p>
<h1 id="dns-域名解析">DNS 域名解析</h1>
<ul>
<li>已经介绍了与HTTP协议有着密切关系的TCP/IP协议，接下来介绍的DNS服务也是与HTTP协议有着密不可分的关系。</li>
<li>通常我们访问一个网站，使用的是主机名或者域名来进行访问的。因为相对于IP地址（一组纯数字），域名更容易让人记住。 但TCP/IP协议使用的是IP地址进行访问的，所以必须有个机制或服务把域名转换成IP地址。<strong>DNS</strong>服务就是用来解决这个问题的，它提供<strong>域名到IP地址之间的解析</strong>服务。</li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.png" alt="图片" loading="lazy"></figure>
<p>DNS 服务解析是有层次的，就近原则。</p>
<ul>
<li>本地电脑会将经常使用的域名和 IP 地址建立映射关系并且保存到<strong>系统文件</strong>中，在进行 DNS 解析时，系统会优先从 <strong>hosts 文件</strong>去寻找对应的 IP 地址，如果找到，直接使用 hosts 文件中的 IP 地址。</li>
<li>如果本地 hosts 文件没有找到该域名对应的 IP 地址的映射，向<strong>本地 DNS 服务器</strong>发送请求，查询域名对应的 IP 地址，本地域名服务器找到对应的 IP 地址，响应给浏览器。本地 DNS 服务有限，如果没有找到，依次向上层 DNS 服务器发起请求，</li>
<li>直到 <strong>DNS 根服务器</strong>，如果找到则返回。</li>
</ul>
<h2 id="dns-解析过程">DNS 解析过程</h2>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<h1 id="回溯-http-事务处理过程">回溯 HTTP 事务处理过程</h1>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/HTTP%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<p>当客户端访问Web站点时，首先会通过DNS服务查询到域名的IP地址。然后浏览器生成HTTP请求，并通过TCP/IP协议发送给Web服务器。Web服务器接收到请求后会根据请求生成响应内容，并通过TCP/IP协议返回给客户端。</p>
<h2 id="http-事务处理完整过程">HTTP 事务处理完整过程</h2>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/HTTP%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<ul>
<li>如果使用客户端浏览器浏览页面，需要从中分解出协议名、主机名、端口、对象路径等，得到协议是 HTTP 协议、主机是 mooc.com 主机、端口是 80 端口、路径是 mooc 的根节点。在这一步需要通过 DNS 服务器解析出它的 <strong>IP 地址</strong>。</li>
<li><strong>封装 HTTP 请求的数据包</strong>，把以上部分结合自己的本机信息封装成一个 HTTP 请求的数据包。</li>
<li>数据报向下封装成 <strong>TCP 包</strong>，<strong>三次握手建立 TCP 连接</strong>。</li>
<li>客户端<strong>发送请求</strong>给服务器</li>
<li>服务器进行<strong>响应</strong>，消息体有状态码、版本号</li>
<li><strong>释放 TCP 连接</strong></li>
</ul>
<h1 id="实验">实验</h1>
<ul>
<li>现在，我们已经了解了HTTP协议的基本概念，也知道了我们是如何从浏览器访问到我们想要的网站资源的。</li>
<li>那么对于浏览器来说，HTTP请求到底是什么样子的呢？让我们一起来跟踪查看一下！</li>
</ul>
<h2 id="环境搭建">环境搭建</h2>
<p>下载抓包工具：<a href="https://www.wireshark.org/">https://www.wireshark.org/</a></p>
<h2 id="实验过程">实验过程</h2>
<p>1.因为连接的是 WIFI，所以选择 WLAN，如下：</p>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/wireshark%E9%80%89%E6%8B%A9WLAN.png" alt="图片" loading="lazy"></figure>
<p>2.浏览器栏输入域名 <a href="http://www.baidu.com">www.baidu.com</a>（HTTPS协议）</p>
<p><a href="http://www.jszg.edu.cn/portal/home/index">http://www.jszg.edu.cn/portal/home/index</a>（HTTP协议）</p>
<p>3.Wireshark 点击停止</p>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/wireshark%E5%81%9C%E6%AD%A2.png" alt="图片" loading="lazy"></figure>
<p>4.分析处理过程</p>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/wrieshark%E5%88%86%E6%9E%90%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL 索引详解]]></title>
        <id>https://epitomm.github.io/post/mysql-suo-yin-xiang-jie/</id>
        <link href="https://epitomm.github.io/post/mysql-suo-yin-xiang-jie/">
        </link>
        <updated>2020-04-20T02:53:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="索引">索引</h1>
<p><code>InnoDB</code>：不加任何条件 select 出来的数据是排好序的（按主键字段排序）——聚簇索引</p>
<p><code>MyISAM</code>：不加任何条件 select 出来的数据是没有排序的（按照插入顺序输出）——堆表</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E7%B4%A2%E5%BC%95_1.png" alt="图片" loading="lazy"></figure>
<h2 id="聚簇索引">聚簇索引</h2>
<p>聚簇索引的特点：</p>
<ol>
<li>按<strong>主键值的大小</strong>进行记录和页的排序：</li>
</ol>
<ul>
<li>数据页(叶子节点)里的记录是按照主键值从小到大排序的一个单向链表。</li>
<li>数据页(叶子节点)之间也是是按照主键值从小到大排序的一个双向链表。</li>
<li>B+树中同一个层的页目录也是按照主键值从小到大排序的一个双向链表。</li>
</ul>
<ol start="2">
<li>B+树的<strong>叶子节点</strong>存储的是完整的用户记录，就是指这个记录中<strong>存储了所有列的值</strong>（包括隐藏列）。</li>
</ol>
<p>具有这两种特性的B+树称为<strong>聚簇索引</strong>，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在<code>MySQL</code>语句中显式的使用<code>INDEX</code>语句去创建。<code>InnoDB</code>存储引擎会自动的为我们创建聚簇索引。在<code>InnoDB</code>存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的<strong>索引即数据</strong>，数据即索引。</p>
<h2 id="二级索引辅助索引">二级索引（辅助索引）</h2>
<p>聚簇索引只能在搜索条件是主键值时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。当我们想以别的列作为搜索条件时我们可以多建几棵B+树，不同的B+树中的数据采用不同的排序规则。</p>
<p>二级索引与聚簇索引有几处不同：</p>
<ol>
<li>按<strong>指定的索引列的值</strong>来进行排序</li>
<li><strong>叶子节点</strong>存储的不是完整的用户记录，而只是<strong>索引列+主键</strong>。</li>
<li>目录项记录中不是主键+页号，变成了<strong>索引列+页号</strong>。</li>
<li>在对二级索引进行查找数据时，需要根据主键值去聚簇索引中再查找一遍完整的用户记录，这个过程叫做 <strong>回表</strong></li>
</ol>
<h2 id="联合索引">联合索引</h2>
<p>以多个列的大小为排序规则建立的 B+树 称为联合索引，本质上也是一个二级索引。</p>
<h2 id="目录项记录的唯一性">目录项记录的唯一性</h2>
<p>我们需要保证在 B+树 的同一层内节点的目录项记录除页号这个字段以外是唯一的。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p>
<ul>
<li>索引列的值</li>
<li>主键值</li>
<li>页号</li>
</ul>
<h2 id="myisam-中的索引方案简单介绍">MyISAM 中的索引方案简单介绍</h2>
<p>InnoDB 中索引即数据，也就是聚簇索引的那棵B+树的叶子节点中已经把所有完整的用户记录都包含了，而MyISAM 的索引方案虽然也使用树形结构，但是却将<strong>索引和数据分开存储</strong>：</p>
<ul>
<li>将表中的记录按照记录的<strong>插入顺序</strong>单独存储在一个文件中，称之为数据文件。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。我们可以通过<strong>行号</strong>而快速访问到一条记录。</li>
<li>使用 MyISAM 存储引擎的表会把索引信息另外存储到一个称为<strong>索引文件</strong>的另一个文件中。MyISAM会单独为表的主键创建一个索引，只不过在索引的<strong>叶子节点</strong>中存储的不是完整的用户记录，而是<strong>主键值+行号</strong>的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录！这一点和InnoDB是完全不相同的，在lnnoDB存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在MyISAM中却需要进行一次回表操作，意味着MyISAM中建立的索引相当于全部都是二级索引！</li>
<li>如果有需要的话，我们也可以对其它的列分别建立索引或者建立联合索引，原理和InnoDB中的索引差不多，不过在叶子节点处存储的是相应的<strong>列+行号</strong>。这些索引也全部都是二级索引。</li>
</ul>
<blockquote>
<p>为什么不自动为每个列都建立个索引呢？别忘了，每建立一个索引都会建立一棵B+树，每插入一条记录都要维护各个记录、数据页的排序关系，这是很费性能和存储空间的。</p>
</blockquote>
<h2 id="b树的索引总结">B+树的索引总结</h2>
<ol>
<li>每个索引都对应一棵<strong>B+树</strong>。用户记录都存储在 B+树 的叶子节点，所有目录记录都存储在非叶子节点。</li>
<li>InnoDB存储引擎会自动为<strong>主键</strong>（如果没有它会自动帮我们添加）建立<strong>聚簇索引</strong>，聚簇索引的叶子节点包含完整的用户记录。</li>
<li>可以为指定的列建立二级索引，二级索引的叶子节点包含的用户记录由<strong>索引列 + 主键</strong>组成，所以如果想通过二级索引来查找完整的用户记录的话，需要通过<strong>回表</strong>操作，也就是在通过二级索引找到主键值之后再到聚簇索引中查找完整的用户记录。</li>
<li>B+树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是联合索引的话，则页面和记录先按照联合索引前边的列排序，如果该列值相同，再按照联合索引后边的列排序。</li>
<li>通过索引查找记录是从 B+树 的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了页目录，所以在这些页面中的查找非常快。</li>
</ol>
<p>表：</p>
<pre><code>create table t1(
  a int primary key, 
  b int,
  c int,
  d int, 
  e varchar(20)
)engine=InnoDB;
</code></pre>
<p>表记录：</p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E8%A1%A8%E8%AE%B0%E5%BD%95.png" alt="图片" loading="lazy"></figure>
<p>创建索引：</p>
<pre><code>create index idx_t1_bcd on t1(b,c,d);
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B4%A2%E5%BC%95.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">自行创建索引</p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">主键索引</p>
<h2 id="索引的代价">索引的代价</h2>
<h3 id="空间上的代价">空间上的代价</h3>
<p>每建立一个索引都为要它建立一棵 B+树，每一棵 <strong>B+树 的每一个节点都是一个数据页</strong>，一个页默认会占用 <strong>16KB</strong> 的存储空间，一棵很大的 B+树 由许多数据页组成，那是很大的一片存储空间。</p>
<h3 id="时间上的代价">时间上的代价</h3>
<p>每次对表中的数据进行增、删、改操作时，都需要去修改各个 B+树 索引。而且我们讲过，B+树 每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收啥的操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的 B+树 都要进行相关的维护操作。</p>
<h2 id="b树索引实战">B+树索引实战</h2>
<h3 id="全值匹配">全值匹配</h3>
<p>如果我们的搜索条件中的列和索引列一致的话，这种情况就称为全值匹配，比方说下边这个查找语句：</p>
<pre><code>select * from t1 where b=1 and c=1 and d=1；
</code></pre>
<p>MySQL中有查询优化器，会分析这些搜索条件并且按照可以使用的索引中列的顺序来决定先使用哪个搜索条件。</p>
<h3 id="匹配左边的列">匹配左边的列</h3>
<pre><code>select * from t1 where b=1；
select * from t1 where b=1 and c=1；
</code></pre>
<p>下面这个sql是用不到索引的</p>
<pre><code>select * from t1 where c = 1；
</code></pre>
<p>因为 B+树 的数据页和记录先是按照 b 列的值排序的，在 b 列的值相同的情况下才使用 c 列进行排序，也就是说 b 列的值不同的记录中 c 的值可能是无序的。而现在你跳过 b 列直接根据 c 的值去查找，这是做不到的。</p>
<h3 id="匹配列前缀">匹配列前缀</h3>
<p>但是需要注意的是，如果只给出后缀或者中间的某个字符串，比如这样：</p>
<pre><code>select * from t1 where b like ''%101%';
</code></pre>
<p>MySQL 就无法快速定位记录位置了，所以只能全表扫描了。有时候我们有一些匹配某些字符串后缀的需求，比方说某个表有一个url列，该列中存储了许多url：</p>
<pre><code>www.baidu.com 
www.google.com 
www.qq.com
</code></pre>
<p>假设已经对该 url 列创建了索引，如果我们想查询以 com 为后缀的网址的话可以这样写查询条件：WHERE url LIKE '%com'，但是这样的话无法使用该 url 列的索引。为了在查询时用到这个索引而不至于全表扫描，我们可以把后缀查询改写成前缀查询，不过我们就得把表中的数据全部逆序存储一下，也就是说我们可以这样保存 url 列中的数据：</p>
<pre><code>moc.udiab.www 
moc.e1goog.www
moc.qq.www
</code></pre>
<p>这样再查找以com为后缀的网址时搜索条件便可以这么写：WHERE url LIKE 'moc%'，这样就可以用到索引了。</p>
<h3 id="匹配范围值">匹配范围值</h3>
<p>查询方式：</p>
<ul>
<li>辅助索引查询成本+回表成本</li>
<li>全表扫描成本</li>
</ul>
<p>所有记录都是按照索引列的值从小到大的顺序排好序的，所以这极大的方便我们查找索引列的值在某个范围内的记录。比方说下边这个查询语句：</p>
<pre><code>select * from t1 where b &gt; 1 and b &lt; 2000;
</code></pre>
<p>由于B+树中的数据页和记录是先按 b 列排序的，所以我们上边的查询过程其实是这样的：</p>
<ul>
<li>找到 b 值为 1 的记录。</li>
<li>找到 b 值为 20000 的记录。</li>
<li>由于所有记录都是由链表连起来的（记录之间用单链表，数据页之间用双链表），所以他们之间的记录都可以很容易的取出来</li>
<li>找到这些记录的主键值，再到聚簇索引中回表查找完整的记录。</li>
</ul>
<p>不过在使用联合进行范围查找的时候需要注意，如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到 B+树 索引，比方说这样：</p>
<pre><code>select * from t1 where b &gt; 1 and c &gt; 1;
</code></pre>
<p>上边这个查询可以分成两个部分：</p>
<ol>
<li>通过条件 b&gt;1 来对 b 进行范围查找，查找的结果可能有多条 b 值不同的记录，</li>
<li>对这些 b 值不同的记录继续通过 c&gt;1 继续过滤。</li>
</ol>
<p>这样子对于联合索引来说，只能用到 b 列的部分，而用不到 c 列的部分，因为只有 b 值相同的情况下才能用 c 列的值进行排序（select * from t1 where b = 1 and c &gt;1），而这个查询中通过 b 进行范围查找的记录中可能并不是按照 c 列进行排序的，所以在搜索条件中继续以 c 列进行查找时是用不到这个B+树索引的。</p>
<h3 id="精确匹配某一列并范围匹配另外一列">精确匹配某一列并范围匹配另外一列</h3>
<p>对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找，比方说这样：</p>
<pre><code>select * from t1 where b=1 and c&gt;1；
</code></pre>
<h3 id="排序">排序</h3>
<p>我们在写查询语句的时候经常需要对查询出来的记录通过 ORDER BY 子句按照某种规则进行排序。一般情况下，我们只能把记录都加载到内存中，再用一些排序算法，比如快速排序、归并排序等等在内存中对这些记录进行排序，有的时候可能查询的结果集太大以至于不能在内存中进行排序的话，还可能暂时借助磁盘的空间来存放中间结果，排序操作完成后再把排好序的结果集返回到客户端。在MySQL中，把这种在内存中或者磁盘上进行排序的方式统称为<strong>文件排序</strong>（英文名：filesort），这些排序操作非常慢。但是如果 ORDER BY 子句里使用到了我们的索引列，就有可能省去在内存或文件中排序的步骤，比如下边这个简单的查询语句：</p>
<pre><code>select * from t1 order by b，c，d
</code></pre>
<p>这个查询的结果集需要先按照 b 值排序，如果记录的 b 值相同，则需要按照 c 来排序，如果 c 的值相同，则需要按照 d 排序。因为这个 B+ 树索引本身就是按照上述规则排好序的，所以直接从索引中提取数据，然后进行回表操作取出该索引中不包含的列就好了。</p>
<h3 id="分组">分组</h3>
<pre><code>select b，c，d，count（*）from t1 group by b，c，d；
</code></pre>
<p>这个查询语句相当于做了3次分组操作：</p>
<ol>
<li>先把记录按照b值进行分组，所有 b 值相同的记录划分为一组。</li>
<li>将每个 b 值相同的分组里的记录再按照 c 的值进行分组，将 title 值相同的记录放到一个小分组里，所以看起来就像在一个大分组里又化分了好多小分组。</li>
<li>再将上一步中产生的小分组按照 d 的值分成更小的分组，所以整体上看起来就像是先把记录分成一个大分组，然后把大分组分成若干个小分组，然后把若干个小分组再细分成更多的小小分组。</li>
</ol>
<p>然后针对那些小小分组进行统计，比如在我们这个查询语句中就是统计每个小小分组包含的记录条数。如果没有索引的话，这个分组过程全部需要在内存里实现，而如果有了索引的话，恰巧这个分组顺序又和我们的 B+树 中的索引列的顺序是一致的，而我们的 B+树 索引又是按照索引列排好序的，所以可以直接使用 B+树 索引进行分组。</p>
<p>和使用 B+树 索引进行排序是一个道理，分组列的顺序也需要和索引列的顺序一致，也可以只使用索引列中左边的列进行分组。</p>
<h3 id="使用联合索引进行排序或分组的注意事项">使用联合索引进行排序或分组的注意事项</h3>
<p>对于联合索引有个问题需要注意，ORDER BY 的子句后边的列的顺序也必须按照索引列的顺序给出，如果给出 order by c，b 的顺序，那也是用不了 B+树 索引的。</p>
<p>同理，order by b，order by b，c 这种匹配索引左边的列的形式可以使用部分的 B+树 索引。当联合索引左边列的值为常量，也可以使用后边的列进行排序，比如这样：</p>
<pre><code>select * from t1 where b=1 order by c，d；
</code></pre>
<p>这个查询能使用联合索引进行排序是因为 b 列的值相同的记录是按照 c，d 排序的。</p>
<h3 id="不可以使用索引进行排序或分组的几种情况">不可以使用索引进行排序或分组的几种情况</h3>
<p><strong>ASC、DESC混用</strong></p>
<p>对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是 ASC 规则排序，要么都是 DESC 规则排序。</p>
<blockquote>
<p>ORDER BY 子句后的列如果不加 ASC 或者 DESC 默认是按照 ASC 排序规则排序的，也就是升序排序的。</p>
</blockquote>
<pre><code>select * from t1 order by b ASC，c DESC；
</code></pre>
<p>这个查询时用不到索引的。</p>
<h2 id="如何建立索引">如何建立索引</h2>
<h3 id="考虑索引选择性">考虑索引选择性</h3>
<p>索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数的比值：</p>
<pre><code>选择性=基数/记录数
</code></pre>
<p>选择性的取值范围为（0，1]，选择性越高的索引价值越大。如果选择性等于1，就代表这个列的不重复值和表记录数是一样的，那么对这个列建立索引是非常合适的，如果选择性非常小，那么就代表这个列的重复值是很多的，不适合建立索引。</p>
<h3 id="考虑前缀索引">考虑前缀索引</h3>
<p>用列的前缀代替整个列作为索引 key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引 key 变短而减少了索引文件的大小和维护开销。</p>
<blockquote>
<p>使用mysql官网提供的示例数据库：<a href="https://dev.mysql.com/doc/employee/en/employees-installation.html">https://dev.mysql.com/doc/employee/en/employees-installation.html</a><br>
github地址：<a href="https://github.com/datacharmer/test_db">https://github.com/datacharmer/test_db</a></p>
</blockquote>
<p>employees表只有一个索引&lt;emp_no&gt;，那么如果我们想按名字搜索一个人，就只能全表扫描了：</p>
<pre><code>EXPLAIN SELECT * FROM employees.employees WHERE first_name='Eric' AND
last_name='Anido';
</code></pre>
<p>那么可以对 &lt;first_name&gt; 或 &lt;first_name，last_name&gt; 建立索引，看下两个索引的选择性：</p>
<pre><code>SELECT count(DISTINCT(first_name))/count(*) AS Selectivity FROM employees.employees; -- 0.0042
SELECT count(DISTINCT(concat(first_name, last_name)))/count(*) AS Selectivity FROM employees.employees; -- 0.9313
</code></pre>
<p>&lt;first_name&gt;显然选择性太低，&lt;first_name，last_name&gt;选择性很好，但是first_name和last_name加起来长度为30，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如&lt;first_name, left(last_name, 3)&gt;，看看其选择性：</p>
<pre><code>SELECT count(DISTINCT(concat(first_name, left(last_name, 3))))/count(*) AS Selectivity FROM employees.employees; -- 0.7879
</code></pre>
<p>选择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4：</p>
<pre><code>SELECT count(DISTINCT(concat(first_name, left(last_name, 4))))/count(*) AS Selectivity FROM employees.employees; -- 0.9007
</code></pre>
<p>这时选择性已经很理想了，而这个索引的长度只有18，比&lt;first_name，last_name&gt;短了接近一半，建立前缀索引的方式为：</p>
<pre><code>ALTER TABLE employees.employees ADD INDEX `first_name_last_name4` (first_name,last_name(4));
</code></pre>
<p>前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于 OFRDER BY 和 GROUP BY 操作，也不能用于覆盖索引。</p>
<h3 id="总结">总结</h3>
<ul>
<li>索引列的类型尽量小</li>
<li>利用索引字符串值的前缀</li>
<li>主键自增</li>
<li>定位并删除表中的重复和冗余索引</li>
<li>尽量使用覆盖索引进行查询，避免回表带来的性能损耗。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一篇文章彻底搞定 NIO]]></title>
        <id>https://epitomm.github.io/post/yi-pian-wen-zhang-che-di-gao-ding-nio/</id>
        <link href="https://epitomm.github.io/post/yi-pian-wen-zhang-che-di-gao-ding-nio/">
        </link>
        <updated>2020-04-19T06:58:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="用发展的眼光看看-bio">用发展的眼光看看 BIO</h1>
<h2 id="jdk14">JDK1.4</h2>
<ul>
<li>java.io包  XXX 类</li>
<li>BIO：Blocking IO：同步阻塞的 IO</li>
<li>Socket 应用程序：
<ul>
<li>监听端口：ServerSocket(9999);</li>
<li>获取客户端的 Socket：serverSocket.accept();</li>
<li>获取 IO 流对象，进行服务端和客户端的数据交互：socket.getInputStream()、getOutputStream()</li>
</ul>
</li>
</ul>
<h2 id="jdk14-之后">JDK1.4 之后</h2>
<ul>
<li>NIO：Non-Blocking IO 同步非阻塞</li>
<li>java.nio 包</li>
<li>对 NIO 做一个封装：netty</li>
</ul>
<h1 id="图解与代码展现bio及问题所在">图解与代码展现BIO及问题所在</h1>
<h2 id="单线程-bio">单线程 BIO</h2>
<h3 id="代码">代码</h3>
<pre><code>package com.gupao;
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
public class BIOServer {
    public static void main(String[] args) {
        byte [] bs = new byte[1024];
        List&lt;Socket&gt; list = new ArrayList&lt;&gt;();
        try(ServerSocket serverSocket = new ServerSocket(9999)) {
            System.out.println(&quot;BIOServer has started, listening on port:&quot; + serverSocket.getLocalSocketAddress());
            while (true){
                Socket clientSocket = serverSocket.accept();
                System.out.println(&quot;Connection from &quot; + clientSocket.getRemoteSocketAddress());
                // 业务处理的代码   
                try(Scanner input = new Scanner(clientSocket.getInputStream())) {
                    while (true){
                        String request = input.nextLine();
                        if(&quot;quit&quot;.equals(request)){
                            break;
                        }
                        System.out.println(String.format(&quot;From %s : %s&quot;, clientSocket.getRemoteSocketAddress(), request));
                        String response = &quot;From BIOServer Hello &quot; + request + &quot;.\n&quot;;
                        clientSocket.getOutputStream().write(response.getBytes());
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h3 id="运行结果">运行结果</h3>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E5%8D%95%E7%BA%BF%E7%A8%8BBIO%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="图片" loading="lazy"></figure>
<h3 id="分析">分析</h3>
<ul>
<li>第一个 Server 启动， 阻塞在 accept() 方法上，等待第二个 Server 的连接；</li>
<li>第二个 Server 连接上后，第一个 Server 不再阻塞在 accept() 上，继续向下运行，阻塞在 Scanner 的 nextLine() 方法上，等待第二个 Server 发送数据；</li>
<li>第二个 Server 数据准备好后，给第一个 Server 发送数据，第一个 Server 的 nextLine() 方法不再阻塞，继续向下运行，再次进行 while 循环，重新阻塞在 “等待数据准备好” 的方法上。</li>
<li>第三个 Server 进行连接，第一个 Server 无法接收到第三个 Server 连接成功请求，第三个 Server 也无法向第一个 Server 发送数据。
<ul>
<li>只有第二个 Server 通过 &quot;quit&quot; 与第一个 Server 断开连接后，第三个 Server 才能与第一个 Server 进行交互</li>
</ul>
</li>
</ul>
<p><strong>总结：不能使用两个客户端同时连接一个 Server 进行操作</strong></p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E5%8D%95%E7%BA%BF%E7%A8%8BBIO%E5%88%86%E6%9E%90.png" alt="图片" loading="lazy"></figure>
<h1 id="仔细想想bio的核心问题及解决方案">仔细想想BIO的核心问题及解决方案</h1>
<h2 id="多线程">多线程</h2>
<p><strong>那么如何同时处理多个客户端数据交互请求呢？</strong></p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E5%A4%9A%E7%BA%BF%E7%A8%8BBIO.png" alt="图片" loading="lazy"></figure>
<h2 id="线程池">线程池</h2>
<p>Client 越来越多， Server 端的线程就会越来越多，但是 Server 端的线程受 Server 端资源、CPU 影响，不能无限增大。就需要有效地<strong>控制线程的数量</strong>。</p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E7%BA%BF%E7%A8%8B%E6%B1%A0BIO.png" alt="图片" loading="lazy"></figure>
<h2 id="线程池-bio">线程池 BIO</h2>
<h3 id="代码-2">代码</h3>
<pre><code>package com.gupao;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ServerThreadPool {
    public static void main(String[] args) {
        // 线程池
        ExecutorService executor = Executors.newFixedThreadPool(2);

        RequestHandler requestHandler = new RequestHandler();
        // 监听
        try(ServerSocket serverSocket = new ServerSocket(9999)) {
            System.out.println(&quot;NIOServer has started, listening on port:&quot; + serverSocket.getLocalSocketAddress());
            while (true){
                Socket clientSocket = serverSocket.accept();
                System.out.println(&quot;Connection from &quot; + clientSocket.getRemoteSocketAddress());
                // 有客户端连接上来了，交给线程池处理
                executor.submit(new ClientHandler(clientSocket,requestHandler));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

package com.gupao;

import java.io.IOException;
import java.net.Socket;
import java.util.Scanner;

/**
 * 每个 Clinet 连接上来后，给它分配一个线程去执行对应的 Ruunable 任务
 */
public class ClientHandler implements Runnable {

    private final Socket clientSocket;
    private final RequestHandler requestHandler;

    public ClientHandler(Socket clientSocket, RequestHandler requestHandler) {
        this.clientSocket = clientSocket;
        this.requestHandler = requestHandler;
    }

    @Override
    public void run() {
        try(Scanner input = new Scanner(clientSocket.getInputStream())) {
            while (true){
                String request = input.nextLine();
                if(&quot;quit&quot;.equals(request)){
                    break;
                }
                System.out.println(String.format(&quot;From %s : %s&quot;, clientSocket.getRemoteSocketAddress(), request));
                // 真正的业务处理
                String response = requestHandler.handler(request);
                clientSocket.getOutputStream().write(response.getBytes());
            }
        } catch (IOException e) {
            System.out.println(&quot;Caught exception: &quot; + e);
            throw new RuntimeException(e);
        }
    }
}

package com.gupao;

/**
 * 业务处理代码
 */
public class RequestHandler {
    public String handler(String request){
        return &quot;From Server Hello &quot; + request + &quot;.\n&quot;;
    }
}
</code></pre>
<h3 id="运行结果-2">运行结果</h3>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/%E7%BA%BF%E7%A8%8B%E6%B1%A0BIO%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E7%BA%BF%E7%A8%8B%E6%B1%A0BIO%E7%BC%BA%E9%99%B7.png" alt="图片" loading="lazy"></figure>
<h1 id="顺其自带推导出nio的原理和代码实现">顺其自带推导出NIO的原理和代码实现</h1>
<h2 id="选择器-selector">选择器 Selector</h2>
<p>如果线程池的大小为 60，来了 60 个请求，Server 端正常应该可以同时处理这 60个请求。但是线程要想被执行的话， 一定要去抢到 CPU 的执行权，CPU 进行这 60 个线程的切换，<strong>频繁的线程上下文切换</strong>消耗 CPU 资源过多，利用率太低。多线程的情况下，线程的数量会影响 CPU 的性能，这就需要控制线程数量。</p>
<p><strong>线程创建的时机</strong></p>
<p>每来一个 Client 请求连接 accept()，就为它创建一个线程，这个线程会一直等待客户端的数据:input.nextLine();（<strong>阻塞</strong>）。</p>
<p><strong>有没有办法不阻塞</strong>？</p>
<p><strong>延迟线程创建的时机</strong>，<strong>等数据准备好以后，才去创建线程</strong>。线程的数量就会得到有效控制（有的 Client 只是连接，并不进行 IO）-&gt; CPU 用于上下文切换的时间减少 -&gt; CPU 利用率提升。</p>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/NIO%E9%80%89%E6%8B%A9%E5%99%A8.png" alt="图片" loading="lazy"></figure>
<p>注意看下面两段代码的注释：</p>
<pre><code>package com.gupao;

import java.io.IOException;
import java.net.Socket;
import java.util.Scanner;

/**
 * 每个 Clinet 连接上来后，给它分配一个线程去执行对应的 Ruunable 任务
 */
public class ClientHandler implements Runnable {

    private final Socket clientSocket;
    private final RequestHandler requestHandler;

    public ClientHandler(Socket clientSocket, RequestHandler requestHandler) {
        this.clientSocket = clientSocket;
        this.requestHandler = requestHandler;
    }

    @Override
    public void run() {
        // 说明线程已经创建了，
        try(Scanner input = new Scanner(clientSocket.getInputStream())) {
            while (true){
                // 等待客户端的输入数据 —— 阻塞的（当前虽然创建了一个线程，但它没有被用到，就浪费了。能不能等到真正处理 IO 的时候才去创建线程）
                String request = input.nextLine();
                if(&quot;quit&quot;.equals(request)){
                    break;
                }
                System.out.println(String.format(&quot;From %s : %s&quot;, clientSocket.getRemoteSocketAddress(), request));
                // 响应客户端
                String response = requestHandler.handler(request);
                clientSocket.getOutputStream().write(response.getBytes());
            }
        } catch (IOException e) {
            System.out.println(&quot;Caught exception: &quot; + e);
            throw new RuntimeException(e);
        }
    }
}
</code></pre>
<pre><code>package com.gupao;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ServerThreadPool {
    public static void main(String[] args) {
        // 线程池
        ExecutorService executor = Executors.newFixedThreadPool(2);

        RequestHandler requestHandler = new RequestHandler();
        // 监听
        try(ServerSocket serverSocket = new ServerSocket(9999)) {
            System.out.println(&quot;NIOServer has started, listening on port:&quot; + serverSocket.getLocalSocketAddress());
            while (true){
                Socket clientSocket = serverSocket.accept();
                System.out.println(&quot;Connection from &quot; + clientSocket.getRemoteSocketAddress());
                // 线程创建的时机——每个客户端来了就为它创建一个线程

//                map.put(clientSocket,&quot;Accepted&quot;);   // 不创建线程
//                什么时候创建线程 —— clientSocket 真正进行 IO 时，采取创建线程

                executor.submit(new ClientHandler(clientSocket,requestHandler));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h2 id="通道-channel">通道 Channel</h2>
<p>Client 与 Server 连接进行数据交互，然后数据再返回给 Client。</p>
<p>而在这个过程中，每次数据交互结束后，连接就会断开，</p>
<p>而建立连接需要三次握手很耗时，连接是很宝贵的，优化连接的方式：建立一条条<strong>通道</strong>。</p>
<p>连接和数据传输就在通道中进行，通道可以复用。</p>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/NIO%E9%80%9A%E9%81%93.png" alt="图片" loading="lazy"></figure>
<h2 id="缓存-buffer">缓存 Buffer</h2>
<p>阻塞/非阻塞 IO：实际上是针对的应用程序和 OS 数据之间交互的这样一种方式。</p>
<p>非阻塞 IO：OS 没有把所有数据全部传输完成，应用程序不会一直等待操作数据，应用程序允许 OS 一会传输一段数据。应用程序把每次接受到的一小段数据放到<strong>缓存</strong>内。</p>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/NIO%E7%BC%93%E5%AD%98.png" alt="图片" loading="lazy"></figure>
<p>很多情况下会发现，处理数据的时候，的确用的是多线程，但这个多线程不是为了解决 IO 阻塞问题。</p>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/NIO%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<h2 id="nio-代码">NIO 代码</h2>
<pre><code>package com.gupao;

import java.awt.image.DataBufferByte;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.util.Iterator;
import java.util.Set;

public class NIOServer {
    public static void main(String[] args) throws IOException {
        // 1.Channel 通道
        // 服务端 Channel
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        // 服务端 Channel 设置为非阻塞
        serverSocketChannel.configureBlocking(false);
        // Channel 绑定端口
        serverSocketChannel.bind(new InetSocketAddress(9999));
        System.out.println(&quot;NIOServer has started, listening on port: &quot; + serverSocketChannel.getLocalAddress());

        // 2.Selector 选择器：注册和选择哪个 Channel 进行读/写
        Selector selector = Selector.open();
        // 将连接上来的 Channel 注册到 Selector 选择器上，并且将默认状态设置为 “Accepted”
        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

        // 3.缓冲区 Buffer
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        RequestHandler requestHandler = new RequestHandler();
        // Selector 不断轮询监听有多少个客户端 Channel已经连接上了
        while (true){
            // 从 Selector 中拿到一个个客户端的 Channel
            int select = selector.select();
            if(select == 0){
                continue;
            }
            // Set 集合维护了 客户端-服务端 的 Channel（SelectionKey）
            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();
            // 迭代 set 集合，
            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();
            while (iterator.hasNext()){
                // 拿到一个 SelectionKey，SelectionKey 里面有：服务端的 ServerSocketChannel；客户端的 SocketChannel
                SelectionKey key = iterator.next();
                // 如果有一个客户端的 Channel 连接上来了（状态为“Accepted”），需要进行读/写操作
                if(key.isAcceptable()){
                    // 根据 SelectionKey 获得 ServerSocketChannel
                    ServerSocketChannel channel = (ServerSocketChannel) key.channel();
                    // 根据 ServerSocketChannel 获得 SocketChannel
                    SocketChannel clientChannel = channel.accept();
                    System.out.println(&quot;Connection from &quot; + clientChannel.getRemoteAddress());
                    // 客户端 Channel 设置为非阻塞
                    clientChannel.configureBlocking(false);
                    // 将 Channel 的状态改变为 READ，说明该 Channel 要读数据了
                    clientChannel.register(selector, SelectionKey.OP_READ);
                }

                // 如果 Channel 的状态为 Read，可以进行 读操作了。
                // 处理读操作：还是放在 main 线程中，而不是为这个 Client 请求创建一个新的线程
                if(key.isReadable()){
                    // 获取到 客户端 Channel
                    SocketChannel channel = (SocketChannel) key.channel();
                    // 数据放到 Buffer 中
                    channel.read(buffer);
                    String request = new String(buffer.array()).trim();
                    buffer.clear();
                    System.out.println(String.format(&quot;From %s : %s&quot;, channel.getRemoteAddress(),request));
                    // 给客户端一个响应
                    String response = requestHandler.handler(request);
                    channel.write(ByteBuffer.wrap(response.getBytes()));
                }
                iterator.remove();
            }
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL —— Explain 关键字]]></title>
        <id>https://epitomm.github.io/post/mysql-explain-guan-jian-zi/</id>
        <link href="https://epitomm.github.io/post/mysql-explain-guan-jian-zi/">
        </link>
        <updated>2020-04-18T15:17:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="explain-关键字">Explain 关键字</h1>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>列名</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">id</td>
<td style="text-align:left">在一个大的查询语句中每个SELECT关键字都对应一个唯一的id</td>
</tr>
<tr>
<td style="text-align:left">select_type</td>
<td style="text-align:left">SELECT关键字对应的那个查询的类型</td>
</tr>
<tr>
<td style="text-align:left">table</td>
<td style="text-align:left">表名</td>
</tr>
<tr>
<td style="text-align:left">partitions</td>
<td style="text-align:left">匹配的分区信息</td>
</tr>
<tr>
<td style="text-align:left"><strong>type</strong></td>
<td style="text-align:left"><strong>针对单表的访问方法</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>possible_keys</strong></td>
<td style="text-align:left"><strong>可能用到的索引</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>key</strong></td>
<td style="text-align:left"><strong>实际上使用的索引</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>key_len</strong></td>
<td style="text-align:left"><strong>实际使用到的索引长度</strong></td>
</tr>
<tr>
<td style="text-align:left">ref</td>
<td style="text-align:left">当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td>
</tr>
<tr>
<td style="text-align:left">rows</td>
<td style="text-align:left">预估的需要读取的记录条数</td>
</tr>
<tr>
<td style="text-align:left">filtered</td>
<td style="text-align:left">某个表经过搜索条件过滤后剩余记录条数的百分比</td>
</tr>
<tr>
<td style="text-align:left"><strong>Extra</strong></td>
<td style="text-align:left"><strong>一些额外的信息</strong></td>
</tr>
</tbody>
</table>
<h2 id="table">table</h2>
<p>表名</p>
<pre><code>mysql&gt; explain select * from t1 join t2; 
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/table.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">explain select * from t1 join t2; </p>
<h2 id="id">id</h2>
<p>我们写的查询语句一般都以SELECT关键字开头，比较简单的查询语句里只有一个SELECT关键字，但是下边两种情况下在一条查询语句中会出现多个SELECT关键字：</p>
<ul>
<li>查询中包含子查询的情况</li>
<li>查询中包含UNION语句的情况</li>
</ul>
<p>查询语句中每出现<strong>一个SELECT关键字</strong>，MySQL就会为它分配<strong>一个唯一的id值</strong>。这个id值就是EXPLAIN语句的第一个列。对于连接查询来说，一个SELECT关键字后边的<strong>FROM子句中可以跟随多个表</strong>，所以在连接查询的执行计划中，<strong>每个表都会对应一条记录，但是这些记录的id值都是相同的。</strong></p>
<pre><code>mysql&gt; explain select * from t1 join t2; 
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/id1.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">一个 select 关键字，两条记录 id 值相同</p>
<blockquote>
<p>在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，出现在前边的表是驱动表，出现在后边的表是被驱动表</p>
</blockquote>
<p>对于<strong>包含子查询的</strong>查询语句来说，就可能涉及<strong>多个SELECT</strong>关键字，所以在包含子查询的查询语句的执行计划中，<strong>每个SELECT关键字都会对应一个唯一的id值</strong>，比如这样：</p>
<pre><code>mysql&gt; explain select * from t1 where a in (select a from t2) or c = 'c'; 
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/id2.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体"> 两个 select 关键字，两个不同的 id  值</p>
<p>但是这里大家需要特别注意，<strong>查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询</strong>。所以如果我们想知道查询优化器对某个包含子查询的语句是否进行了重写，直接查看执行计划就好了，比如说：</p>
<pre><code>mysql&gt; explain select * from t1 where a in (select a from t2); 
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E5%B0%86%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E4%B8%BA%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">查询优化器将子查询优化为连接查询</p>
<p>可以看到，虽然我们的查询语句是一个子查询，但是执行计划中t1和t2表对应的记录的id值全部是1，这就表明了<strong>查询优化器将子查询转换为了连接查询</strong>。</p>
<p>对<strong>于包含UNION子句的查询语句来说，每个SELECT关键字对应一个id值</strong>也是没错的，不过还是有点儿特别的东西，比方说下边这个查询：</p>
<pre><code>mysql&gt; explain select * from t1 union select * from t2; 
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/UNION%E5%8E%BB%E9%87%8D.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">union 去重</p>
<p>这个语句的执行计划的第三条记录是什么？为什么id值是NULL？UNION会把多个查询的结果集合并起来并对结果集中的记录进行去重，怎么去重呢？MySQL使用的是内部的临时表。正如上边的查询计划中所示，<strong>UNION子句是为了把id为1的查询和id为2的查询的结果集合并起来并去重，所以在内部创建了一个名为的临时表</strong>（就是执行计划第三条记录的table列的名称），id为NULL表明这个临时表是为了合并两个查询的结果集而创建的。</p>
<p>跟UNION对比起来，<strong>UNION ALL就不需要为最终的结果集进行去重</strong>，它只是单纯的把多个查询的结果集中的记录合并成一个并返回给用户，所以也就不需要使用临时表。所以在包含UNION ALL子句的查询的执行计划中，就没有那个id为NULL的记录，如下所示：</p>
<pre><code>mysql&gt; explain select * from t1 union all select * from t2; 
+----+-------------+-------+------------+------+---------------+------+---------+----- 
-+------+----------+-------+ 
| id | select_type | table | partitions | type | possible_keys | key | key_len | ref  
| rows | filtered | Extra | 
+----+-------------+-------+------------+------+---------------+------+---------+----- 
-+------+----------+-------+ 
| 1 | PRIMARY | t1 | NULL | ALL | NULL | NULL | NULL | NULL 
| 8 | 100.00 | NULL | 
| 2 | UNION | t2 | NULL | ALL | NULL | NULL | NULL | NULL 
| 8 | 100.00 | NULL | 
+----+-------------+-------+------------+------+---------------+------+---------+----- 
-+------+----------+-------+ 
2 rows in set, 1 warning (0.00 sec) 
</code></pre>
<h2 id="select_type">select_type</h2>
<p>每一个SELECT关键字代表的小查询都定义了一个称之为select_type的属性，意思是我们只要知道了某个小查询的select_type属性，就知道了这个小查询在整个大查询中扮演了一个什么角色。</p>
<h3 id="simple">SIMPLE</h3>
<p>查询语句中<strong>不包含UNION或者子查询的查询</strong>都算作是SIMPLE类型。</p>
<pre><code>mysql&gt; explain select * from t1; 
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2SIMPLE.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">简单查询 select_type = SIMPLE</p>
<p>连接查询也算是SIMPLE类型</p>
<pre><code>mysql&gt; explain select * from t1 join t2; 
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2SIMPLE.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">连接查询 select_type = SIMPLE</p>
<h3 id="primary">PRIMARY</h3>
<p>对于包含UNION、UNION ALL或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的 select_type值就是PRIMARY，比方说：</p>
<pre><code>mysql&gt; explain select * from t1 where a in (select a from t2) or c = 'c'; 
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/PRIMARY.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">主查询的 select_type = PRIMARY；子查询的 select_type = SUBQUERY</p>
<p>从结果中可以看到，最左边的小查询select * from t1对应的是执行计划中的第一条记录，它的select_type值就是 PRIMARY。</p>
<h3 id="union">UNION</h3>
<p>对于包含UNION或者UNION ALL的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外， 其余的小查询的select_type值就是UNION。</p>
<pre><code>mysql&gt; explain select * from t1 union select * from t2; 
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/UNION.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">UNION 查询的最左边查询 select_type = RIMARY，其余小查询的 select_type = UNION</p>
<h3 id="union-result">UNION RESULT</h3>
<p>MySQL选择使用临时表来完成UNION查询的去重工作，针对该临时表的查询的select_type就是UNION RESULT，例子上边有。</p>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/UNION_RESULT.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">union 查询中临时表的 select_type = UNION RESULT</p>
<h3 id="subquery">SUBQUERY</h3>
<p><strong>非相关子查询</strong>，由于 select_type 为 SUBQUERY 的子查询由于会被物化，所以<strong>只需要执行一遍。</strong></p>
<pre><code>mysql&gt; explain select * from t1 where a in (select a from t2) or c = 'c'; 
</code></pre>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/SUBQUERY.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">非相关子查询 select_type = SUBQUERY</p>
<h3 id="dependent-subqurey">DEPENDENT SUBQUREY</h3>
<p><strong>相关子查询</strong>，select_type 为 DEPENDENT SUBQUERY 的查询可能<strong>会被执行多次</strong></p>
<pre><code>mysql&gt; explain select * from t1 where a in (select a from t2 where t1.a = t2.a) or c = 'c'; 
</code></pre>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/DEPENDENT_SUBQUREY.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">相关子查询 select_type = DEPENDENT SUBQUERY</p>
<h3 id="derived">DERIVED</h3>
<pre><code>mysql&gt; explain select * from (select a, count(*) from t2 group by a ) as deliver1; 
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/DERIVED.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">派生表 select_type = DRIVED </p>
<p>从执行计划中可以看出，id为2的记录就代表子查询的执行方式，它的select_type是DERIVED，说明该子查询是以物化的方式执行的。id为1的记录代表外层查询，大家注意看它的table列显示的是<derived2>，表示该查询是针对将派生表物化之后的表进行查询的。</p>
<h3 id="materialized">MATERIALIZED</h3>
<p>当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的 select_type属性就是MATERIALIZED。</p>
<pre><code>mysql&gt; explain select * from t1 where a in (select c from t2 where e = 1);
</code></pre>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/MATERIALIZED.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">物化表 select_type = MATERIALIZED </p>
<blockquote>
<p>将子查询出来的结果集放到一个物化表内，再将物化表与外层查询进行连接查询。</p>
</blockquote>
<h2 id="type">TYPE</h2>
<p>访问方法（全表扫描还是走哪个索引）</p>
<h3 id="system">system</h3>
<p>当<strong>表中只有一条记录并且该表使用的存储引擎的统计数据是精确</strong>的，比如MyISAM、Memory，那么对该表的访问方法就是system。比方说我们新建一个MyISAM表，并为其插入一条记录：</p>
<p>创建表 t</p>
<pre><code>mysql&gt; CREATE TABLE t(i int) Engine=MyISAM; 
Query OK, 0 rows affected (0.05 sec) 
</code></pre>
<p>向 t 表内插入一条数据</p>
<pre><code>mysql&gt; INSERT INTO t VALUES(1); 
Query OK, 1 row affected (0.01 sec)
</code></pre>
<p>执行 explain 语句</p>
<pre><code>mysql&gt; explain select * from t; 
</code></pre>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/system.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">表中只有一条数据、存储引擎精确统计 type = system</p>
<h3 id="const">const</h3>
<p>当我们根据<strong>主键</strong>或者<strong>唯一二级索引列</strong>与<strong>常数</strong>进行<strong>等值匹配时</strong>，对单表的访问方法就是const。</p>
<pre><code>mysql&gt; explain select * from t1 where a = 1; 
</code></pre>
<figure data-type="image" tabindex="16"><img src="https://epitomm.github.io/post-images/const.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">根据主键与常数进行等职匹配 type = const</p>
<h3 id="eq_ref">eq_ref</h3>
<p>在连接查询时，如果<strong>被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的</strong>（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是eq_ref</p>
<pre><code>mysql&gt; explain select * from t1 join t2 on t1.a = t2.a; 
</code></pre>
<figure data-type="image" tabindex="17"><img src="https://epitomm.github.io/post-images/eq_ref.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">被驱动表通过主键等值匹配的方式访问，被驱动表的 type = eq_ref</p>
<h3 id="ref">ref</h3>
<p>当通过<strong>普通的二级索引列</strong>与<strong>常量</strong>进行<strong>等值匹配</strong>时来查询某个表，那么对该表的访问方法就可能是ref。</p>
<p>查看所有索引：</p>
<pre><code>show keys for t1;
</code></pre>
<figure data-type="image" tabindex="18"><img src="https://epitomm.github.io/post-images/%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%B4%A2%E5%BC%95.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">查看所有索引</p>
<pre><code>mysql&gt; explain select * from t1 where b = 1; 
</code></pre>
<figure data-type="image" tabindex="19"><img src="https://epitomm.github.io/post-images/ref.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">当通过普通的二级索引列与常量进行等值匹配时来查询某个表 type = ref</p>
<h3 id="ref_of_null">ref_of_null</h3>
<p>当对<strong>普通二级索引进行等值匹配查询</strong>，<strong>该索引列的值也可以是NULL值</strong>时，那么对该表的访问方法就可能是 ref_or_null</p>
<pre><code>mysql&gt; explain select * from t1 where b = 1 or b is null; 
</code></pre>
<figure data-type="image" tabindex="20"><img src="https://epitomm.github.io/post-images/ref_of_null.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">对普通二级索引进行等值匹配查询，该索引列的值也可以是NULL值 type = ref_of_null</p>
<h3 id="index_merge">index_merge</h3>
<p><strong>索引合并</strong></p>
<pre><code>mysql&gt; explain select * from t1 where a = 1 or b = 1; 
</code></pre>
<figure data-type="image" tabindex="21"><img src="https://epitomm.github.io/post-images/index_merge.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">索引合并 type = index_merge</p>
<h3 id="unique_subquery">unique_subquery</h3>
<p>如果<strong>查询优化器决定将IN子查询转换为EXISTS子查询，<strong>而且</strong>子查询可以使用到主键进行等值匹配</strong>的话，那么该子查询执行计划的type列的值就是unique_subquery。</p>
<pre><code>mysql&gt; explain select * from t1 where c in (select a from t2 where t1.e = t2.e) or a = 1;
</code></pre>
<p>以上查询可以优化为 EXISTS 子查询：</p>
<pre><code>mysql&gt; explain select * from t1 where exists(select a from t2 where t1.e = t2.e and t1.c = t2.a) or a = 1
</code></pre>
<figure data-type="image" tabindex="22"><img src="https://epitomm.github.io/post-images/unique_subquery.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">查询优化器将IN子查询转换为EXISTS子查询，而且子查询可以使用到主键进行等值匹配 </p>
<p>type = unique_subquery</p>
<h3 id="index_subquery">index_subquery</h3>
<p>index_subquery与unique_subquery类似，只不过访问子查询中的表时使用的是普通的索引。</p>
<pre><code>mysql&gt; explain select * from t1 where c in (select b from t2 where t1.e = t2.e) or a = 1;
+----+--------------------+-------+------------+----------------+---------------+----- 
---------+---------+------+------+----------+-------------+ 
| id | select_type | table | partitions | type | possible_keys | key  
| key_len | ref | rows | filtered | Extra | 
+----+--------------------+-------+------------+----------------+---------------+----- 
---------+---------+------+------+----------+-------------+ 
| 1 | PRIMARY | t1 | NULL | ALL | PRIMARY | NULL  
| NULL | NULL | 9 | 100.00 | Using where | 
| 2 | DEPENDENT SUBQUERY | t2 | NULL | index_subquery | idx_t2_b_c_d | 
idx_t2_b_c_d | 5 | func | 1 | 12.50 | Using where | 
+----+--------------------+-------+------------+----------------+---------------+----- 
---------+---------+------+------+----------+-------------+ 
2 rows in set, 2 warnings (0.00 sec) 
</code></pre>
<h3 id="range">range</h3>
<p>范围查询</p>
<pre><code>mysql&gt; explain select * from t1 where a &gt; 1; 
</code></pre>
<figure data-type="image" tabindex="23"><img src="https://epitomm.github.io/post-images/%E5%A4%A7%E4%BA%8E_range.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">a > 1 type = range</p>
<pre><code>mysql&gt; explain select * from t1 where a in (1);
</code></pre>
<figure data-type="image" tabindex="24"><img src="https://epitomm.github.io/post-images/in_range.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">a in (1) type = const</p>
<pre><code>mysql&gt; explain select * from t1 where a in (1,2);
</code></pre>
<figure data-type="image" tabindex="25"><img src="https://epitomm.github.io/post-images/in_range2.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">a in (1,2) type = range</p>
<h3 id="index">index</h3>
<p>当我们可以使用覆盖索引，但<strong>需要扫描全部的索引记录</strong>时，该表的访问方法就是index。</p>
<p>遍历索引上的所有叶子节点，因为B+树所有数据都存储在叶子节点上，而非叶子结点是用来过滤筛选条件的。</p>
<pre><code>mysql&gt; explain select a from t1; 
</code></pre>
<figure data-type="image" tabindex="26"><img src="https://epitomm.github.io/post-images/index_1.png" alt="图片" loading="lazy"></figure>
<p>使用辅助索引没有使用主键索引的原因：辅助索引体积较小，辅助索引只存储字段b、c、d和主键a字段；而主索引存储所有字段值。</p>
<pre><code>mysql&gt; explain select b from t1;
</code></pre>
<figure data-type="image" tabindex="27"><img src="https://epitomm.github.io/post-images/index_2.png" alt="图片" loading="lazy"></figure>
<pre><code>mysql&gt; ecplain select e from t1;
</code></pre>
<figure data-type="image" tabindex="28"><img src="https://epitomm.github.io/post-images/index_3.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">e 字段没有索引，所以 type = ALL</p>
<h3 id="all">ALL</h3>
<p>全表扫描</p>
<h2 id="possible_keys-和-key">possible_keys 和 key</h2>
<p>possible_keys列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些，key列表示实际用到的索引有哪些。</p>
<p>不过有一点比较特别，就是在使用index访问方法来查询某个表时，possible_keys列是空的，而key列展示的是实际使用到的索引 。</p>
<blockquote>
<p>possible_keys列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长 时间，所以如果可以的话，尽量删除那些用不到的索引</p>
</blockquote>
<h2 id="key_len">key_len</h2>
<p>key_len列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度，它是由这三个部分构成的：</p>
<ul>
<li>对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是VARCHAR(100)，使用的字符集是 utf8，那么该列实际占用的最大存储空间就是100 × 3 = 300个字节。</li>
<li>如果该索引列可以存储NULL值，则key_len比不可以存储NULL值时多1个字节。</li>
<li>对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。</li>
</ul>
<figure data-type="image" tabindex="29"><img src="https://epitomm.github.io/post-images/key_len.png" alt="图片" loading="lazy"></figure>
<h2 id="ref-2">ref</h2>
<p>当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是const、eq_ref、ref、ref_or_null、 unique_subquery、index_subquery其中之一时，ref列展示的就是与索引列作等值匹配的东西是什么，比如只是一个常数或者是某个列。</p>
<pre><code>mysql&gt; explain select b from t1 where b = 1; 
</code></pre>
<figure data-type="image" tabindex="30"><img src="https://epitomm.github.io/post-images/ref_1.png" alt="图片" loading="lazy"></figure>
<pre><code>mysql&gt; explain select * from t1 where a in (select a from t2); 
</code></pre>
<figure data-type="image" tabindex="31"><img src="https://epitomm.github.io/post-images/ref_2.png" alt="图片" loading="lazy"></figure>
<h2 id="rows">rows</h2>
<p>如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的rows列就代表预计需要扫描的行数， 如果使用索引来执行查询时，执行计划的rows列就代表预计扫描的索引记录行数。</p>
<h2 id="filtered">filtered</h2>
<p>代表查询优化器预测在这扫描的记录中，有多少条记录满足其余的搜索条件。</p>
<pre><code>mysql&gt; explain select * from t1 where a &gt; 1 and e = 1; 
+----+-------------+-------+------------+-------+---------------+---------+---------+- 
-----+------+----------+-------------+ 
| id | select_type | table | partitions | type | possible_keys | key | key_len | 
ref | rows | filtered | Extra | 
+----+-------------+-------+------------+-------+---------------+---------+---------+- 
-----+------+----------+-------------+ 
| 1 | SIMPLE | t1 | NULL | range | PRIMARY | PRIMARY | 4 | 
NULL | 8 | 11.11 | Using where | 
+----+-------------+-------+------------+-------+---------------+---------+---------+- 
-----+------+----------+-------------+ 
1 row in set, 1 warning (0.00 sec) 
</code></pre>
<p>从执行计划的key列中可以看出来，该查询使用PRIMARY索引来执行查询，从rows列可以看出满足a &gt; 1的记录有 8条。执行计划的filtered列就代表查询优化器预测在这8条记录中，<strong>有多少条记录满足其余的搜索条件</strong>，也就是e = 1这个条件的百分比。此处filtered列的值是11.11，说明查询优化器预测在8条记录中有11.11%的记录满足e = 1 这个条件。<br>
对于单表查询来说，这个 filtered 列的值没什么意义，我们更关注在连接查询中驱动表对应的执行计划记录的  filtered 值，比方说下边这个查询：</p>
<pre><code>mysql&gt; explain select * from t1 join t2 on t1.a = t2.a where t1.e = 1; 
+----+-------------+-------+------------+--------+---------------+---------+--------- 
+------------+------+----------+-------------+ 
| id | select_type | table | partitions | type | possible_keys | key | key_len | 
ref | rows | filtered | Extra | 
+----+-------------+-------+------------+--------+---------------+---------+--------- 
+------------+------+----------+-------------+ 
| 1 | SIMPLE | t1 | NULL | ALL | PRIMARY | NULL | NULL | 
NULL | 9 | 11.11 | Using where | 
| 1 | SIMPLE | t2 | NULL | eq_ref | PRIMARY | PRIMARY | 4 | 
luban.t1.a | 1 | 100.00 | NULL | 
+----+-------------+-------+------------+--------+---------------+---------+--------- 
+------------+------+----------+-------------+ 
2 rows in set, 1 warning (0.00 sec) 
</code></pre>
<p>从执行计划中可以看出来，查询优化器打算把t1当作驱动表，t2当作被驱动表。我们可以看到驱动表t1表的执行计划的rows列为9， filtered 列为11.11，这意味着驱动表t1表经过条件过滤后有9 × 11.11% = 0.9999条记录，这说明还<strong>要对被驱动表执行大约1次(row * filtered)查询</strong>。</p>
<h2 id="extra">Extra</h2>
<p>Extra列是用来说明一些额外信息的，我们可以通过这些额外信息来更准确的理解MySQL到底将如何执行给定的查询语句。</p>
<h3 id="no-tables-used">No tables used</h3>
<p>当<strong>查询语句的没有FROM子句</strong>时将会提示该额外信息。</p>
<pre><code>mysql&gt; explain select 1; 
</code></pre>
<figure data-type="image" tabindex="32"><img src="https://epitomm.github.io/post-images/Notablesused.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">查询语句没有 FROM 子句时：Extra = No tables used</p>
<h3 id="impossible-where">Impossible WHERE</h3>
<p><strong>查询语句的WHERE子句永远为FALSE</strong>时将会提示该额外信息。</p>
<pre><code>mysql&gt; explain select b from t1 where 1=0; 
</code></pre>
<figure data-type="image" tabindex="33"><img src="https://epitomm.github.io/post-images/ImpossibleWHERE.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">WHERE 子句永远为 FALSE时：Extra = Impossible WHERE</p>
<h3 id="no-matching-minmax-row">No matching min/max row</h3>
<p>当<strong>查询列表处有MIN或者MAX聚集函数，但是并没有符合WHERE子句中的搜索条件的记录</strong>时，将会提示该额外信息。</p>
<pre><code>mysql&gt; explain select max(a) from t1 where a=100; 
</code></pre>
<figure data-type="image" tabindex="34"><img src="https://epitomm.github.io/post-images/No_matching_minmax_row.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">查询列表处有MIN或者MAX聚集函数，但是并没有符合WHERE子句中的搜索条件的记录时：Extra = No matching min/max row</p>
<h3 id="using-index">Using index</h3>
<p>当我们的<strong>查询列表以及搜索条件中只包含属于某个索引的列</strong>，也就是在<strong>可以使用索引覆盖</strong>的情况下，在Extra列将会提示该额外信息。</p>
<p>辅助索引包含 b、c、d 字段，根据查询条件 b=1 找到字段 d 的值，无需回表。</p>
<pre><code>mysql&gt; explain select d from t1 where b =1; 
</code></pre>
<figure data-type="image" tabindex="35"><img src="https://epitomm.github.io/post-images/UsingIndex.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">覆盖索引 Extra = Using index</p>
<h3 id="using-index-condition">Using index condition</h3>
<p>有些<strong>搜索条件中虽然出现了索引列，但却不能使用到索引</strong>（在MySQL 5.6版本后加入的新特性）</p>
<figure data-type="image" tabindex="36"><img src="https://epitomm.github.io/post-images/Using_index_condition.png" alt="图片" loading="lazy"></figure>
<pre><code>mysql&gt; explain select * from t1 where b =1 and c like '%1'; 
</code></pre>
<figure data-type="image" tabindex="37"><img src="https://epitomm.github.io/post-images/Using_index_condition2.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">搜索条件中虽然出现了索引列，但却不能使用到索引 Extra = Using index condition</p>
<h3 id="using-where">Using where</h3>
<p>当我们使用<strong>全表扫描来执行对某个表的查询，并且该语句的WHERE子句中有针对该表的搜索条件时</strong>，在Extra列中会提示上述额外信息。</p>
<pre><code>mysql&gt; explain select * from t1 where e = 1; 
</code></pre>
<figure data-type="image" tabindex="38"><img src="https://epitomm.github.io/post-images/UsingWhere.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">全表扫描来执行对某个表的查询，并且该语句的WHERE子句中有针对该表的搜索条件时：Extra = Using where</p>
<h3 id="using-joinbufferblock-nested-loop">Using joinbuffer(Block Nested Loop)</h3>
<p>在<strong>连接查询</strong>执行过程中，当被驱动表<strong>不能有效的利用索引</strong>加快访问速度，MySQL一般会为其分配一块名叫join buffer 的内存块来加快查询速度。</p>
<pre><code>mysql&gt; explain select * from t1 join t2 on t1.e = t2.e; 
</code></pre>
<figure data-type="image" tabindex="39"><img src="https://epitomm.github.io/post-images/Using_joinbuffer.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">连接查询不能用到索引，分配 join buffer 内存块：Extra = Using join buffer</p>
<p>可以在对t2表的执行计划的Extra列显示了两个提示：</p>
<ul>
<li>Using join buffer (Block Nested Loop)：这是因为对表t2的访问不能有效利用索引，只好退而求其次，使用join buffer来减少对t2表的访问次数，从而提高性能。</li>
<li>Using where：可以看到查询语句中有一个t1.e = t2.e条件，因为t1是驱动表，t2是被驱动表，所以在访问t2表时，t1.e的值已经确定下来了，所以实际上查询t2表的条件就是t2.e = 一个常数，所以提示了Using where额外信息。</li>
</ul>
<h3 id="using-filesort">Using filesort</h3>
<p>很多情况下排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）进行排序，这种<strong>在内存中或者磁盘上进行排序的方式统称为文件排序</strong>（英文名：filesort）。如果<strong>某个查询需要使用文件排序的方式执行查询</strong>，就会在执行计划的Extra列中显示Using filesort提示。</p>
<pre><code>mysql&gt; explain select * from t1 order by e; 
</code></pre>
<figure data-type="image" tabindex="40"><img src="https://epitomm.github.io/post-images/Using_filesort.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">排序 Extra = Using filesort</p>
<h3 id="using-temporary">Using temporary</h3>
<p>在许多查询的执行过程中，MySQL可能会借助<strong>临时表</strong>来完成一些功能，比如<strong>去重、排序</strong>之类的，比如我们在执行许多包含<strong>DISTINCT、GROUP BY、UNION</strong>等子句的查询过程中，如果<strong>不能</strong>有效<strong>利用索引</strong>来完成查询，MySQL很有可能寻求通过<strong>建立内部的临时表</strong>来执行查询。如果查询中使用到了内部的临时表，在执行计划的Extra列将会显示Using temporary提示。</p>
<p>能利用索引：</p>
<pre><code>mysql&gt; explain select distinct b from t1; 
</code></pre>
<figure data-type="image" tabindex="41"><img src="https://epitomm.github.io/post-images/Using_temporary.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">利用索引distinct：Extra = Using index</p>
<p>不能利用索引</p>
<pre><code>mysql&gt; explain select distinct e from t1; 
</code></pre>
<figure data-type="image" tabindex="42"><img src="https://epitomm.github.io/post-images/Using_temporary2.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">不能利用索引的 distinct，建立内部临时表：Extra = Using temporary</p>
<p>即有Using temporary，又有Using filesort，因为group by默认会先排序 （Using filesort）</p>
<pre><code>mysql&gt; explain select e, count(1) from t1 group by e; 
</code></pre>
<figure data-type="image" tabindex="43"><img src="https://epitomm.github.io/post-images/Using_temporary3.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">Extra = Using temporary; Using filesort</p>
<p>使用order by null禁用排序</p>
<pre><code>mysql&gt; explain select e, count(1) from t1 group by e order by null; 
</code></pre>
<figure data-type="image" tabindex="44"><img src="https://epitomm.github.io/post-images/Using_temporary4.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">禁用排序，Extra = Using temporary</p>
<h3 id="start-temporary-end-temporary">Start temporary、End temporary</h3>
<p><strong>查询优化器会优先尝试将IN子查询转换成semi-join</strong>，而semi-join又有好多种执行策略，当执行策略为 <strong>DuplicateWeedout <strong>时，也就是通过</strong>建立临时表</strong>来实现为外层查询中的记录进行<strong>去重</strong>操作时，<strong>驱动表</strong>查询执行计划的Extra列将显示<strong>Start temporary</strong>提示，<strong>被驱动表</strong>查询执行计划的Extra列将显示<strong>End temporary</strong>提示</p>
<pre><code>mysql&gt; explain select * from t1 where a in (select e from t2 where e = 1); 
</code></pre>
<figure data-type="image" tabindex="45"><img src="https://epitomm.github.io/post-images/Start_temporary.png" alt="图片" loading="lazy"></figure>
<h3 id="firstmatch表名">FirstMatch（表名）</h3>
<p>在将In子查询转为semi-join时，如果采用的是<strong>FirstMatch</strong>执行策略，则在<strong>被驱动表</strong>执行计划的Extra列就是显示 **FirstMatch(tbl_name)**提示。</p>
<pre><code>mysql&gt; explain select * from t1 where a in (select c from t2 where c = 1); 
</code></pre>
<figure data-type="image" tabindex="46"><img src="https://epitomm.github.io/post-images/FirstMatch.png" alt="图片" loading="lazy"></figure>
<h1 id="总结">总结</h1>
<h2 id="性能按-type-排序">性能按 type 排序</h2>
<p>system &gt; const &gt; eq_ref &gt; ref &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p>
<h2 id="性能按-extra-排序">性能按 Extra 排序</h2>
<ul>
<li>Using index：用了覆盖索引</li>
<li>Using index condition：用了条件索引（索引下推）</li>
<li>Using where：从索引查出来数据后继续用where条件过滤</li>
<li>Using join buffer (Block Nested Loop)：join的时候利用了join buffer（优化策略：去除外连接、增 大join buffer大小）</li>
<li>Using filesort：用了文件排序，排序的时候没有用到索引</li>
<li>Using temporary：用了临时表（优化策略：增加条件以减少结果集、增加索引，思路就是要么减少待排序的数量，要么就提前排好序）</li>
<li>Start temporary, End temporary：子查询的时候，可以优化成半连接，但是使用的是通过临时表来去重</li>
<li>FirstMatch(tbl_name)：子查询的时候，可以优化成半连接，但是使用的是直接进行数据比较来去重</li>
</ul>
<h2 id="常见的优化手段">常见的优化手段</h2>
<ol>
<li>SQL语句中IN包含的值不应过多，不能超过200个，200个以内查询优化器计算成本时比较精准，超过200 个是估算的成本，另外建议能用between就不要用in，这样就可以使用range索引了。</li>
<li>SELECT语句务必指明字段名称：SELECT * 增加很多不必要的消耗（cpu、io、内存、网络带宽）；增加了使用覆盖索引的可能性；当表结构发生改变时，前端也需要更新。所以要求直接在select后面接上字段名。</li>
<li>当只需要一条数据的时候，使用limit 1</li>
<li>排序时注意是否能用到索引</li>
<li>使用 or 时如果没有用到索引，可以改为union all 或者union</li>
<li>如果in不能用到索引，可以改成exists看是否能用到索引</li>
<li>使用合理的分页方式以提高分页的效率</li>
<li>不建议使用%前缀模糊查询</li>
<li>避免在where子句中对字段进行表达式操作</li>
<li>避免隐式类型转换 （字符 ‘a’ -&gt; 数字 0，数字 !-&gt; 字符）</li>
<li>对于联合索引来说，要遵守最左前缀法则</li>
<li>必要时可以使用force index来强制查询走某个索引</li>
<li>对于联合索引来说，如果存在范围查询，比如between,&gt;,&lt;等条件时，会造成后面的索引字段失效。</li>
<li>尽量使用inner join，避免left join，让查询优化器来自动选择小表作为驱动表</li>
<li>必要时刻可以使用straight_join来指定驱动表，前提条件是本身是inner join</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode53. 最大子序和]]></title>
        <id>https://epitomm.github.io/post/leetcode53-zui-da-zi-xu-he/</id>
        <link href="https://epitomm.github.io/post/leetcode53-zui-da-zi-xu-he/">
        </link>
        <updated>2020-04-16T14:01:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<h2 id="示例">示例:</h2>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>
输出: 6</p>
<p>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<p>进阶:<br>
如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<h2 id="分析">分析</h2>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>当前数字</strong></th>
<th style="text-align:center"><strong>连续子序列最大和 maxSum</strong></th>
<th style="text-align:center"><strong>子序列当前累加和 cur</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">-8</td>
<td style="text-align:center"></td>
<td style="text-align:center">-6</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">-3 &lt; 0, 更新 cur = 3</td>
</tr>
<tr>
<td style="text-align:center">-2</td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">-10</td>
<td style="text-align:center"></td>
<td style="text-align:center">-5</td>
</tr>
</tbody>
</table>
<ul>
<li>第一个数：2。连续子序列最大和 <code>maxSum = 2</code>；子序列当前累加和 <code>cur=2</code>；</li>
<li>第二个数：-8。<code>2 - 8 = -6 &lt; maxSum</code>，不更新 maxSum</li>
<li>第三个数：3。<code>-6 + 3 = -3 &lt; maxSum</code>，不更新 maxSum
<ul>
<li>如果不加 -6，而是让 3 自成一个子序列，<code>3 &gt; maxSum</code></li>
<li>maxSum = 3；cur = 3</li>
<li>如果前面累加的和为负数或零，对后面的求和不会有正向贡献，因此可以舍弃前面这段子序列的和，重新开始一个新的子序列。当前连续子序列的和记为 cur</li>
<li><code>if ( cur&lt;= 0 )</code>，就从当前元素重新开始一个新的子序列，当前和 cur 更新为当前的元素值 <code>cur = a[i];</code> 否则子序列就继续向前相加 <code>cur = cur + a[i]</code> 。每次子序列的和更新后，都要和最大值 maxSum 对比，以此更新最大值 <code>maxSum = max(maxSum, cur)</code>，这样遍历完数组，就能找到连续子序列的最大和</li>
</ul>
</li>
<li>第四个数：-2。<code>3 - 2 = 1</code>，<code>cur=1 &gt; 0</code>，于是保留 <code>cur=1</code>。<code>cur=1 &lt; maxSum=3</code>，不更新 maxSum</li>
<li>第五个数：4。<code>1+4=5 &gt; maxSum</code>，保留 <code>cur=5</code>，更新 maxSum=5</li>
<li>第六个数：-10。<code>5-10=-5 &lt; 5</code>，不更新 maxSum</li>
</ul>
<h3 id="复杂度分析">复杂度分析</h3>
<ul>
<li>T = O(n)<br>
遍历数组一遍，时间复杂度为 O(n)。</li>
<li>S = O(1)<br>
没有使用额外的存储空间，空间复杂度为 O(1)</li>
</ul>
<h2 id="代码">代码</h2>
<pre><code>class Solution {

  // Time: O(n), Space: O(1)
  public int maxSubArray(int[] nums) {
      // 初始化子序列最大和 max 和 子序列当前累加和
      int max = Integer.MIN_VALUE, cur = 0;
    // for 循环遍历数组
    for (int i = 0; i &lt; nums.length; ++i) {
      // 累加和 &lt;= 0，则用当前元素值 nums[i] 更新累加和，表示开始一个新的子序列；否则继续累加当前元素的值
      cur = cur &lt;= 0 ? nums[i] : (cur + nums[i]);
      // 更新当前子序列的最大值
      max = Math.max(max, cur);
    }
    return max;
  }

}
</code></pre>
<h2 id="来源">来源</h2>
<p>来源：力扣（LeetCode）<br>
链接：<a href="https://leetcode-cn.com/problems/maximum-subarray">https://leetcode-cn.com/problems/maximum-subarray</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入学习并发编程中的synchronized]]></title>
        <id>https://epitomm.github.io/post/shen-ru-xue-xi-bing-fa-bian-cheng-zhong-de-synchronized/</id>
        <link href="https://epitomm.github.io/post/shen-ru-xue-xi-bing-fa-bian-cheng-zhong-de-synchronized/">
        </link>
        <updated>2020-04-15T03:54:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第一章并发编程中的三个问题">第一章：并发编程中的三个问题</h1>
<h2 id="可见性">可见性</h2>
<p>可见性（Visibility）：是指<strong>一个线程对共享变量进行修改，另一个线程立即得到修改后的最新值</strong>。</p>
<h3 id="可见性演示">可见性演示</h3>
<p>案例演示：一个线程根据 <code>boolean</code> 类型的标记 <code>flag</code>， <code>while</code> 循环，另一个线程改变这个 <code>flag</code> 变量的值，这个线程并不会停止循环。</p>
<pre><code>package com.itheima.demo01_concurrent_problem;

/**
 *目标:演示可见性问题
 *     1.创建一个共享变量
 *     2.创建一个线程不断读取共享变量
 *     3.创建一饿线程修改共享变量
 */
public class Test01Visibility {
    // 1.创建一个共享变量
    private static boolean flag = true;

    public static void main(String[] args) throws InterruptedException {
        // 2.创建一个线程不断读取共享变量
        new Thread(() -&gt; {
            while (flag) {

            }
        }).start();

        Thread.sleep(2000);

        // 3.创建一个线程修改共享变量
        new Thread(() -&gt; {
            flag = false;
            System.out.println(&quot;线程修改了变量的值为false&quot;);
        }).start();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>线程修改了变量的值为false
（阻塞···）
</code></pre>
<h3 id="小结">小结</h3>
<p>并发编程时，会出现可见性问题，当一个线程对共享变量进行了修改，另外的线程并没有立即看到修改后的最新值。</p>
<h2 id="原子性">原子性</h2>
<p>原子性（Atomicity）：<strong>在一次或多次操作中，要么所有的操作都执行并且不会受其他因素干扰而中断，要么所有的操作都不执行</strong>。</p>
<h3 id="原子性演示">原子性演示</h3>
<p>案例演示:5个线程各执行1000次 i++;</p>
<pre><code>package com.itheima.demo01_concurrent_problem;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

/**
 * 目标:演示原子性问题
 *     1.定义一个共享变量number
 *     2.对number进行1000的++操作
 *     3.使用5个线程来进行
 */
public class Test02Atomicity {
    // 1.定义一个共享变量number
    private static int number = 0;

    public static void main(String[] args) throws InterruptedException {
        // 2.对number进行1000的++操作
        Runnable increment = () -&gt; {
            for (int i = 0; i &lt; 1000; i++) {
                number++;
            }
        };
        List&lt;Thread&gt; list = new ArrayList&lt;&gt;();
        // 3.使用5个线程来进行
        for (int i = 0; i &lt; 5; i++) {
            Thread t = new Thread(increment);
            t.start();
            list.add(t);
        }

        for (Thread t : list) {
            t.join();
        }

        System.out.println(&quot;number = &quot; + number);
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>number = 4955
</code></pre>
<p>使用<code>javap</code>反汇编<code>class</code>文件，得到下面的字节码指令：<br>
<img src="https://epitomm.github.io/post-images/%E5%8E%9F%E5%AD%90%E6%80%A7%E6%BC%94%E7%A4%BA.png" alt="图片" loading="lazy"></p>
<p>其中，对于 <code>number++</code> 而言（number 为静态变量），实际会产生如下的 JVM 字节码指令：</p>
<pre><code>9: getstatic #12    // 从类信息中加载 12 号 static 变量
12: iconst_1         // 把 int 类型常量 1 压入操作数栈
13: iadd               // 将操作数栈顶和次栈顶元素弹出并相加
14: putstatic #12 // 设置 12 号 static 变量
</code></pre>
<p>由此可见<code>number++</code>是由多条语句组成，以上多条指令在一个线程的情况下是不会出问题的，但是在多线程情况下就可能会出现问题。比如一个线程在执行<code>13: iadd</code>时，另一个线程又执行<code>9: getstatic</code>。会导致两次<code>number++</code>，实际上只加了1。</p>
<h3 id="小结-2">小结</h3>
<p>并发编程时，会出现原子性问题，当一个线程对共享变量操作到一半时，另外的线程也有可能来操作共享变量，干扰了前一个线程的操作。</p>
<h2 id="有序性">有序性</h2>
<p>有序性（Ordering）：是指程序中代码的执行顺序，Java在编译时和运行时会对代码进行优化，会导致<strong>程序最终的执行顺序不一定就是我们编写代码时的顺序</strong>。</p>
<pre><code>public static void main(String[] args) {
    int a = 10;
    int b = 20;
}
</code></pre>
<h3 id="有序性演示">有序性演示</h3>
<p><code>jcstress</code>是<code>Java</code>并发压测工具。<a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">https://wiki.openjdk.java.net/display/CodeTools/jcstress</a></p>
<p>修改pom文件，添加依赖：</p>
<pre><code>&lt;dependency&gt; 
  &lt;groupId&gt;org.openjdk.jcstress&lt;/groupId&gt; 
  &lt;artifactId&gt;jcstress-core&lt;/artifactId&gt; 
  &lt;version&gt;${jcstress.version}&lt;/version&gt; 
&lt;/dependency&gt;  
</code></pre>
<p>代码<br>
Test03Orderliness.java</p>
<pre><code>import org.openjdk.jcstress.annotations.*;
import org.openjdk.jcstress.infra.results.I_Result;
@JCStressTest
@Outcome(id = {&quot;1&quot;, &quot;4&quot;}, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)
@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;danger&quot;)
@State
public class Test03Orderliness {
    int num = 0;
    boolean ready = false;
    // 线程一执行的代码
    @Actor
    public void actor1(I_Result r) {
        if(ready) {
            r.r1 = num + num;
        } else {
            r.r1 = 1;
        }
    }
    // 线程2执行的代码
    @Actor
    public void actor2(I_Result r) {
        num = 2;
        ready = true;
    }
}
</code></pre>
<ul>
<li><code>I_Result</code> 是一个对象，有一个属性 <code>r1</code> 用来保存结果，在多线程情况下可能出现几种结果？
<ul>
<li>情况1：线程1先执行<code>actor1</code>，这时<code>ready = false</code>，所以进入else分支结果为1。</li>
<li>情况2：线程2执行到<code>actor2</code>，执行了<code>num = 2;</code>和<code>ready = true</code>，线程1执行，这回进入 if 分支，结果为 4。</li>
<li>情况3：线程2先执行<code>actor2</code>，只执行<code>num = 2</code>；但没来得及执行 <code>ready = true</code>，线程1执行，还是进入 else分支，结果为1。</li>
<li><strong>还有一种结果0</strong>。代码重排序将 <code>actor2</code> 中 <code>num = 2</code> 和 <code>ready = true</code> 反序。先执行 <code>actor2</code> 中的 <code>ready = true</code>，然后执行 <code>actor1</code> 中 if 判断，结果为 0 + 0 = 0。</li>
</ul>
</li>
</ul>
<p>运行测试：</p>
<pre><code>mvn clean install 
java -jar target/jcstress.jar
</code></pre>
<h3 id="小结-3">小结</h3>
<p>程序代码在执行过程中的先后顺序，由于<code>Java</code>在编译期以及运行期的优化，导致了代码的执行顺序未必就是开发者编写代码时的顺序。</p>
<h1 id="第二章java内存模型jmm">第二章：Java内存模型(JMM)</h1>
<p>在介绍Java内存模型之前，先来看一下到底什么是计算机内存模型。</p>
<h2 id="计算机结构">计算机结构</h2>
<h3 id="计算机结构简介">计算机结构简介</h3>
<p>冯诺依曼，提出计算机由五大组成部分，<strong>输入设备，输出设备，存储器，控制器，运算器</strong>。</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center">计算机结构</p>
<h3 id="cpu">CPU</h3>
<p>中央处理器，是计算机的<strong>控制和运算</strong>的核心，我们的程序最终都会变成指令让CPU去执行，处理程序中的数据。<br>
<img src="https://epitomm.github.io/post-images/CPU.png" alt="图片" loading="lazy"></p>
<p style = "text-align:center">CPU</p>
<h3 id="内存">内存</h3>
<p>我们的程序都是在内存中运行的，<strong>内存会保存程序运行时的数据</strong>，供CPU处理。</p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E5%86%85%E5%AD%98.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center">内存</p>
<h3 id="缓存">缓存</h3>
<p><strong>CPU的运算速度和内存的访问速度相差比较大</strong>。这就导致CPU每次操作内存都要耗费很多等待时间。内存的读写速度成为了计算机运行的瓶颈。于是就有了在CPU和主内存之间增加缓存的设计。最靠近CPU 的缓存称为L1，然后依次是 L2，L3和主内存，CPU缓存模型如图下图所示。</p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/CPU%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center">CPU 缓存模型</p>
<p>CPU Cache分成了三个级别: L1， L2， L3。级别越小越接近CPU，速度也更快，同时也代表着容量越小。</p>
<ol>
<li>L1是最接近CPU的，它容量最小，例如32K，速度最快，每个核上都有一个L1 Cache。</li>
<li>L2 Cache 更大一些，例如256K，速度要慢一些，一般情况下每个核上都有一个独立的L2 Cache。</li>
<li>L3 Cache是三级缓存中最大的一级，例如12MB，同时也是缓存中最慢的一级，在同一个CPU插槽之间的核共享一个L3 Cache。<br>
<img src="https://epitomm.github.io/post-images/CPU%E5%8F%82%E6%95%B0.png" alt="图片" loading="lazy"></li>
</ol>
<blockquote>
<p>Latency：延迟</p>
</blockquote>
<p>Cache的出现是为了解决<strong>CPU直接访问内存效率低下</strong>问题的，程序在运行的过程中，CPU接收到指令后，它会最先向CPU中的一级缓存（L1 Cache）去寻找相关的数据，如果命中缓存，CPU进行计算时就可以直接对CPU Cache中的数据进行读取和写入，当运算结束之后，再将CPU Cache中的最新数据刷新到主内存当中，CPU通过直接访问Cache的方式替代直接访问主存的方式极大地提高了CPU 的吞吐能力。但是由于一级缓存（L1 Cache）容量较小，所以不可能每次都命中。这时CPU会继续向下一级的二级缓存（L2 Cache）寻找，同样的道理，当所需要的数据在二级缓存中也没有的话，会继续转向L3 Cache、内存(主存)和硬盘。</p>
<h3 id="小结-4">小结</h3>
<p>计算机的主要组成：CPU，内存，输入设备，输出设备。</p>
<h2 id="java内存模型">Java内存模型</h2>
<p>Java Memory Molde (Java内存模型/JMM)，千万不要和Java内存结构混淆</p>
<p>关于“Java内存模型”的权威解释，请参考 <a href="https://download.oracle.com/otn-pub/jcp/memory_model-1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.pdf?AuthParam=1581232382_a0e88fb559ae2cdd224df3335e1eb9d3">https://download.oracle.com/otn-pub/jcp/memory_model-1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.pdf</a>。</p>
<p>Java 内存模型，是 Java 虚拟机规范中所定义的一种内存模型，Java 内存模型是标准化的，屏蔽掉了底层不同计算机的区别。</p>
<p>Java内存模型是一套规范，描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节，具体如下。</p>
<ul>
<li>主内存</li>
</ul>
<p>主内存是<strong>所有线程都共享</strong>的，都能访问的。所有的<strong>共享变量</strong>都存储于主内存。</p>
<ul>
<li>工作内存</li>
</ul>
<p><strong>每一个线程有自己的工作内存</strong>，工作内存只存储该线程对<strong>共享变量的副本</strong>。线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接访问对方工作内存中的变量。</p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center"> Java 内存模型</p>
<h3 id="java-内存模型的作用">Java 内存模型的作用</h3>
<p>Java内存模型是一套在多线程读写共享数据时，对共享数据的可见性、有序性、和原子性的规则和保障。</p>
<p>synchronized,volatile</p>
<h3 id="cpu缓存内存与-java-内存模型的关系">CPU缓存，内存与 Java 内存模型的关系</h3>
<p>通过对前面的CPU硬件内存架构、Java内存模型以及Java多线程的实现原理的了解，我们应该已经意识到，<strong>多线程的执行最终都会映射到硬件处理器上进行执行</strong>。</p>
<p>但 Java 内存模型和硬件内存架构并不完全一致。对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存和主内存之分，也就是说 Java 内存模型对内存的划分对硬件内存并没有任何影响， 因为 JMM 只是一种抽象的概念，是一组规则，不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说，Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种<strong>抽象概念划分与真实物理硬件的交叉</strong>。</p>
<p><strong>JMM内存模型与CPU硬件内存架构的关系：</strong></p>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/JMM%E4%B8%8ECPU%E7%A1%AC%E4%BB%B6%E5%86%85%E5%AD%98%E6%9E%B6%E6%9E%84%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="图片" loading="lazy"></figure>
<p><strong>小结</strong></p>
<p>Java 内存模型是一套<strong>规范</strong>，描述了 <strong>Java 程序中各种变量(线程共享变量)的访问规则</strong>，以及在 JVM 中将变量存储到内存和从内存中读取变量这样的底层细节，Java 内存模型是对共享数据的可见性、有序性、和原子性的规则和保障。</p>
<h2 id="主内存与工作内存之间的数据交互过程">主内存与工作内存之间的数据交互过程</h2>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E4%B8%BB%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E7%9A%84%E4%BA%A4%E4%BA%92.png" alt="图片" loading="lazy"></figure>
<p>Java内存模型中定义了以下8种操作来完成，主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的。</p>
<p>对应如下的流程图：</p>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E4%B8%BB%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E5%85%B7%E4%BD%93%E7%9A%84%E4%BA%A4%E4%BA%92%E5%8D%8F%E8%AE%AE.png" alt="图片" loading="lazy"></figure>
<ul>
<li>read：从主内存读取共享变量（<code>boolean x= true</code>）</li>
<li>load：将共享变量（<code>boolean x = tru</code>e）放入工作内存的变量副本中</li>
<li>use：把工作内存中一个变量的<strong>值</strong>（true）传递给执行引擎</li>
<li>assign：把一个从执行引擎接收到的值赋给工作内存的变量</li>
<li>store：把工作内存的一个共享变量传送到主内存中</li>
<li>write：在 store 之后执行，把 store 得到的值放入主内存的变量中</li>
<li>lock：作用于主内存的变量</li>
<li>unlock</li>
</ul>
<p>注意:</p>
<ol>
<li>
<p>如果对一个变量执行lock操作，将会<strong>清空工作内存中此变量的值</strong></p>
</li>
<li>
<p>对一个变量执行unlock操作之前，必须先<strong>把此变量同步到主内存中</strong></p>
</li>
</ol>
<h3 id="小结-5">小结</h3>
<p>主内存与工作内存之间的数据交互过程</p>
<pre><code>lock -&gt; read -&gt; load -&gt; use -&gt; assign -&gt; store -&gt; write -&gt; unlock
</code></pre>
<h1 id="第三章synchronized保证三大特性">第三章：synchronized保证三大特性</h1>
<p>synchronized能够保证在同一时刻最多只有一个线程执行该段代码，以达到保证并发安全的效果。</p>
<pre><code>synchronized (锁对象) { 
    // 受保护资源; 
}
</code></pre>
<h2 id="synchronized与原子性">synchronized与原子性</h2>
<h3 id="使用synchronized保证原子性">使用synchronized保证原子性</h3>
<p>案例演示:5个线程各执行1000次 i++;</p>
<pre><code>import java.util.ArrayList;
/**
 案例演示:5个线程各执行1000次 i++; 
 */
public class Test01Atomicity {
    private static int number = 0;
    public static void main(String[] args) throws InterruptedException {
        Runnable increment = new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i &lt; 1000; i++) {
                    synchronized (Test01Atomicity.class) {
                        number++;
                    }
                }
            }
        };
        ArrayList&lt;Thread&gt; ts = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 50; i++) {
            Thread t = new Thread(increment);
            t.start();
            ts.add(t);
        }
        for (Thread t : ts) {
            t.join();
        }
        System.out.println(&quot;number = &quot; + number);
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>number = 50000
</code></pre>
<p>主要代码：</p>
<pre><code>for (int i = 0; i &lt; 1000; i++) {
    synchronized (Test01Atomicity.class) {
        number++;
    }
}
</code></pre>
<h3 id="synchronized保证原子性的原理">synchronized保证原子性的原理</h3>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/synchronized%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8E%9F%E7%90%86.png" alt="图片" loading="lazy"></figure>
<p>对<code>number++</code>;增加同步代码块后，保证同一时间只有一个线程操作<code>number++</code>;。就不会出现安全问题。</p>
<h3 id="小结-6">小结</h3>
<p>synchronized保证原子性的原理：synchronized保证只有一个线程拿到锁，能够进入同步代码块。</p>
<h2 id="synchronized与可见性">synchronized与可见性</h2>
<h3 id="使用synchronized保证可见性">使用synchronized保证可见性</h3>
<p>案例演示：一个线程根据boolean类型的标记flag， while循环，另一个线程改变这个flag变量的值，使用 synchronized 加锁这个线程会停止循环。</p>
<pre><code>/*
    目标:演示可见性问题
        1.创建一个共享变量
        2.创建一个线程不断读取共享变量
        3.创建一个线程修改共享变量
 */
public class Test01Visibility {
    // 1.创建一个使用 volatile 修饰的共享变量
    private static boolean flag = true;
    private static Object obj = new Object();
    public static void main(String[] args) throws InterruptedException {
        // 2.创建一个线程不断读取共享变量
        new Thread(() -&gt; {
            while (flag) {
                synchronized (obj){

                }
            }
        }).start();

        Thread.sleep(2000);

        // 3.创建一个线程修改共享变量
        new Thread(() -&gt; {
            flag = false;
            System.out.println(&quot;线程修改了变量的值为false&quot;);
        }).start();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>线程修改了变量的值为false
</code></pre>
<p>分析：<br>
synchronized ：当线程 2 将 flag 的值改为 false 后，线程 1 再次执行 while 操作时：读取主内存变量到工作空间前，执行 Lock 操作，使工作内存内的共享变量失效，再次去主内存读取刷新共享变量的值。</p>
<p><strong>synchronized保证可见性的原理</strong><br>
<img src="https://epitomm.github.io/post-images/%E4%B8%BB%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E5%85%B7%E4%BD%93%E7%9A%84%E4%BA%A4%E4%BA%92%E5%8D%8F%E8%AE%AE.png" alt="图片" loading="lazy"></p>
<p>如果 while 方法内增加输出语句 <code>System.out.println(&quot;run = &quot; + run);</code>，即使不显式使用 <code>synchronized</code> 加锁也能终止死循环。</p>
<pre><code>/**
 案例演示:
 一个线程根据boolean类型的标记flag， while循环，另一个线程改变这个flag变量的值，
 另一个线程并不会停止循环.
 */
public class Test01Visibility {
    // 多个线程都会访问的数据，我们称为线程的共享数据
    private static boolean run = true;
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -&gt; {
            while (run) {
                // 增加对象共享数据的打印，println是同步方法
                System.out.println(&quot;run = &quot; + run);
            }
        });
        t1.start();
        Thread.sleep(1000);
        Thread t2 = new Thread(() -&gt; {
            run = false;
            System.out.println(&quot;时间到，线程2设置为false&quot;);
        });
        t2.start();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>run = true
run = true
run = true
······
run = true
run = true
run = true
时间到，线程2设置为false
</code></pre>
<p>分析：<br>
使用 sout 输出，程序会停止，而不是一直阻塞，因为 sout 内部使用了 synchronized</p>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/sout.png" alt="图片" loading="lazy"></figure>
<h3 id="使用-volatile-保证可见性">使用 volatile 保证可见性</h3>
<pre><code>package com.itheima.demo02_concurrent_problem;

/*
    目标:演示可见性问题
        1.创建一个共享变量
        2.创建一个线程不断读取共享变量
        3.创建一个线程修改共享变量
 */
public class Test01Visibility {
    // 1.创建一个使用 volatile 修饰的共享变量
    private static volatile boolean flag = true;
    private static Object obj = new Object();
    public static void main(String[] args) throws InterruptedException {
        // 2.创建一个线程不断读取共享变量
        new Thread(() -&gt; {
            while (flag) {

            }
        }).start();

        Thread.sleep(2000);

        // 3.创建一个线程修改共享变量
        new Thread(() -&gt; {
            flag = false;
            System.out.println(&quot;线程修改了变量的值为false&quot;);
        }).start();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>线程修改了变量的值为false
</code></pre>
<h3 id="小结-7">小结</h3>
<p>synchronized保证可见性的原理，执行synchronized时，会对应lock原子操作会刷新工作内存中共享变量的值</p>
<h2 id="synchronized与有序性">synchronized与有序性</h2>
<h3 id="为什么要重排序">为什么要重排序</h3>
<p>为了<strong>提高程序的执行效率</strong>，编译器和CPU会对程序中代码进行重排序。</p>
<h3 id="as-if-serial语义">as-if-serial语义</h3>
<p>as-if-serial语义的意思是：不管编译器和CPU如何重排序，必须保证在<strong>单线程情况下程序的结果是正确</strong>的。</p>
<p>以下数据有依赖关系，不能重排序。</p>
<p>写后读：</p>
<pre><code>int a = 1;
int b = a;
</code></pre>
<p>写后写：</p>
<pre><code>int a = 1;
int a = 2;
</code></pre>
<p>读后写：</p>
<pre><code>int a = 1;
int b = a;
int a = 2;
</code></pre>
<p>编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。</p>
<pre><code>int a = 1;
int b = 2;
int c = a + b;
</code></pre>
<p>上面3个操作的数据依赖关系如图所示：<br>
<img src="https://epitomm.github.io/post-images/%E4%B8%89%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.png" alt="图片" loading="lazy"></p>
<p>如上图所示 a 和 c 之间存在数据依赖关系，同时 b 和 c 之间也存在数据依赖关系。因此在最终执行的指令序列中，c 不能被重排序到 a 和 b 的前面。但 a 和 b 之间没有数据依赖关系，编译器和处理器可以重排序 a 和 b 之间的执行顺序。下图是该程序的两种执行顺序。</p>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/%E4%B8%89%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB2.png" alt="图片" loading="lazy"></figure>
<pre><code>可以这样：
int a = 1;
int b = 2;
int c = a + b;

也可以重排序这样：
int b = 2;
int a = 1;
int c = a + b; 
</code></pre>
<h3 id="使用-synchronized-保证有序性">使用 synchronized 保证有序性</h3>
<pre><code>package com.itheima.demo02_concurrent_problem;

import org.openjdk.jcstress.annotations.*;
import org.openjdk.jcstress.infra.results.I_Result;
@JCStressTest
@Outcome(id = {&quot;1&quot;}, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)
@Outcome(id = {&quot;4&quot;}, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;danger2&quot;)
@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;danger&quot;)
@State
public class Test03Ordering {
    private Object obj = new Object();
    volatile int num = 0;
    volatile boolean ready = false;
    // 线程1执行的代码
    @Actor
    public void actor1(I_Result r) {
        synchronized (obj){
            if (ready) {
                r.r1 = num + num;
            } else {
                r.r1 = 1;
            }
        }
    }
    // 线程2执行的代码
    @Actor
    public void actor2(I_Result r) {
        synchronized (obj){
            num = 2;
            ready = true;
        }
    }
}
</code></pre>
<p>运行结果只有 1 和 4，没有 0。</p>
<h3 id="synchronized保证有序性的原理">synchronized保证有序性的原理</h3>
<p>synchronized后，虽然进行了重排序，保证<strong>只有一个线程会进入同步代码块</strong>，也能保证有序性。</p>
<h3 id="小结-8">小结</h3>
<p>synchronized 保证有序性的原理，我们加 synchronized 后，依然会发生重排序，只不过，我们有同步代码块，可以保证只有一个线程执行同步代码中的代码，保证有序性。</p>
<h1 id="第四章synchronized的特性">第四章：synchronized的特性</h1>
<h2 id="可重入特性">可重入特性</h2>
<p>一个线程可以多次执行 synchronized, 重复获取同一把锁。</p>
<pre><code>package com.itheima.demo03_synchronized_nature;

/**
 * 目标:演示 synchronized 可重入
 *     1.自定义一个线程类
 *     2.在线程类的run方法中使用嵌套的同步代码块
 *     3.使用两个线程来执行
 */
public class Demo01 {
    public static void main(String[] args) {
        new MyThread().start();
        new MyThread().start();
    }
    public static void test01() {
        synchronized (MyThread.class) {
            String name = Thread.currentThread().getName();
            System.out.println(name + &quot;进入了同步代码块2&quot;);
        }
    }
}
// 1.自定义一个线程类
class MyThread extends Thread {
    @Override
    public void run() {
        synchronized (MyThread.class) {
            System.out.println(getName() + &quot;进入了同步代码块1&quot;);

            Demo01.test01();
        }
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>Thread-0进入了同步代码块1
Thread-0进入了同步代码块2
Thread-1进入了同步代码块1
Thread-1进入了同步代码块2
</code></pre>
<h3 id="可重入原理">可重入原理</h3>
<p>synchronized 的锁对象中有一个计数器（recursions变量）会<strong>记录线程获得几次锁</strong>。</p>
<h3 id="可重入的好处">可重入的好处</h3>
<ol>
<li>可以避免死锁</li>
<li>可以让我们更好的来封装代码</li>
</ol>
<h3 id="小结-9">小结</h3>
<p>synchronized 是可重入锁，内部锁对象中会有一个计数器记录线程获取几次锁了，在执行完同步代码块时，计数器的数量会-1，直到计数器的数量为0，就释放这个锁。</p>
<h2 id="不可中断特性">不可中断特性</h2>
<p>一个线程获得锁后，另一个线程想要获得锁，必须处于阻塞或等待状态，如果第一个线程不释放锁，第二个线程会一直<strong>阻塞或等待，不可被中断</strong>。</p>
<h3 id="synchronized不可中断演示">synchronized不可中断演示</h3>
<p>synchronized 是不可中断，处于阻塞状态的线程会一直等待锁。</p>
<pre><code>/*
    目标:演示synchronized不可中断
    1.定义一个Runnable
    2.在Runnable定义同步代码块
    3.先开启一个线程来执行同步代码块,保证不退出同步代码块
    4.后开启一个线程来执行同步代码块(阻塞状态)
    5.停止第二个线程
*/
public class Demo02_Uninterruptible {
    private static Object obj = new Object();
    public static void main(String[] args) throws InterruptedException {
        // 1.定义一个Runnable
        Runnable run = () -&gt; {
            // 2.在Runnable定义同步代码块
            synchronized (obj) {
                String name = Thread.currentThread().getName();
                System.out.println(name + &quot;进入同步代码块&quot;);
                // 保证不退出同步代码块
                try {
                    Thread.sleep(888888);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };
        // 3.先开启一个线程来执行同步代码块
        Thread t1 = new Thread(run);
        t1.start();
        Thread.sleep(1000);
        // 4.后开启一个线程来执行同步代码块(阻塞状态)
        Thread t2 = new Thread(run);
        t2.start();
        // 5.停止第二个线程
        System.out.println(&quot;停止线程前&quot;);
        t2.interrupt();
        System.out.println(&quot;停止线程后&quot;);
        System.out.println(t1.getState());
        System.out.println(t2.getState());
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>Thread-0进入同步代码块
停止线程前
停止线程后
TIMED_WAITING
BLOCKED//处于阻塞状态，不可被中断
</code></pre>
<h3 id="reentrantlock不可中断演示">ReentrantLock不可中断演示</h3>
<pre><code>package com.itheima.demo03_synchronized_nature;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 目标:演示Lock不可中断
 */
public class Demo03_Interruptible {
    private static Lock lock = new ReentrantLock();
    public static void main(String[] args) throws InterruptedException {
         test01();
    }

    // 演示Lock不可中断
    public static void test01() throws InterruptedException {
        Runnable run = () -&gt; {
            String name = Thread.currentThread().getName();
            try {
                lock.lock();
                System.out.println(name + &quot;获得锁,进入锁执行&quot;);
                Thread.sleep(88888);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
                System.out.println(name + &quot;释放锁&quot;);
            }
        };
        Thread t1 = new Thread(run);
        t1.start();
        Thread.sleep(1000);
        Thread t2 = new Thread(run);
        t2.start();

        System.out.println(&quot;停止t2线程前&quot;);
        t2.interrupt();
        System.out.println(&quot;停止t2线程后&quot;);
        Thread.sleep(1000);
        System.out.println(t1.getState());
        System.out.println(t2.getState());
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>Thread-0获得锁,进入锁执行
停止t2线程前
停止t2线程后
TIMED_WAITING
WAITING //t2 interrupt中断失败，一直处于等待状态
</code></pre>
<h3 id="reentrantlock可中断演示">ReentrantLock可中断演示</h3>
<pre><code>package com.itheima.demo03_synchronized_nature;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 目标:演示Lock可中断
 */
public class Demo03_Interruptible {
    private static Lock lock = new ReentrantLock();
    public static void main(String[] args) throws InterruptedException { 
        test02();
    }

    // 演示Lock可中断
    public static void test02() throws InterruptedException {
        Runnable run = () -&gt; {
            String name = Thread.currentThread().getName();
            boolean b = false;
            try {
                b = lock.tryLock(3, TimeUnit.SECONDS);
                if (b) {
                    System.out.println(name + &quot;获得锁,进入锁执行&quot;);
                    Thread.sleep(88888);
                } else {
                    System.out.println(name + &quot;在指定时间没有得到锁做其他操作&quot;);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                if (b) {
                    lock.unlock();
                    System.out.println(name + &quot;释放锁&quot;);
                }
            }
        };

        Thread t1 = new Thread(run);
        t1.start();
        Thread.sleep(1000);
        Thread t2 = new Thread(run);
        t2.start();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>Thread-0获得锁,进入锁执行
Thread-1在指定时间没有得到锁做其他操作
(阻塞很久)
Thread-0释放锁
</code></pre>
<h3 id="小结-10">小结</h3>
<p>不可中断是指，当一个线程获得锁后，另一个线程一直处于阻塞或等待状态，前一个线程不释放锁，后一个线程会一直阻塞或等待，不可被中断。</p>
<p><code>synchronized</code> 属于不可被中断</p>
<p><code>Lock</code> 的 <code>lock</code> 方法是不可中断的</p>
<p><code>Lock</code> 的 <code>tryLock</code> 方法是可中断的</p>
<h1 id="第五章synchronized-原理">第五章：synchronized 原理</h1>
<h2 id="javap-反汇编">javap 反汇编</h2>
<p>我们编写一个简单的synchronized代码，如下：</p>
<pre><code>public class Demo01 {
    private static Object obj = new Object();
    public static void main(String[] args) {
        synchronized (obj) {
            System.out.println(&quot;1&quot;);
        }
    }
    public synchronized void test() {
        System.out.println(&quot;a&quot;);
    }
}
</code></pre>
<p>我们要看 synchronized 的原理，但是 synchronized 是一个关键字，看不到源码。我们可以将class文件进行反汇编。</p>
<p>JDK自带的一个工具： javap ，对字节码进行反汇编，查看字节码指令。</p>
<p>在 DOS 命令行输入：</p>
<pre><code>javap -p -v C:\Users\Only\悄悄的努力\AQS\synchronized资料\案例\Synchronized\target\classes\com\itheima\demo04_synchronized_monitor\Demo01
</code></pre>
<p>反汇编后的效果如下：</p>
<pre><code>  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=3, args_size=1
         0: getstatic     #2                  // Field obj:Ljava/lang/Object;
         3: dup
         4: astore_1
         5: monitorenter
         6: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
         9: ldc           #4                  // String 1
        11: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        14: aload_1
        15: monitorexit
        16: goto          24
        19: astore_2
        20: aload_1
        21: monitorexit
        22: aload_2
        23: athrow
        24: return
      Exception table:
         from    to  target type
             6    16    19   any
            19    22    19   any
      LineNumberTable:
        line 7: 0
        line 8: 6
        line 9: 14
        line 10: 24
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      25     0  args   [Ljava/lang/String;
      StackMapTable: number_of_entries = 2
        frame_type = 255 /* full_frame */
          offset_delta = 19
          locals = [ class &quot;[Ljava/lang/String;&quot;, class java/lang/Object ]
          stack = [ class java/lang/Throwable ]
        frame_type = 250 /* chop */
          offset_delta = 4

  public synchronized void test();
    descriptor: ()V
    flags: (0x0021) ACC_PUBLIC, ACC_SYNCHRONIZED
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #6                  // String a
         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      LineNumberTable:
        line 13: 0
        line 14: 8
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       9     0  this   Lcom/itheima/demo04_synchronized_monitor/Demo01;
  static {};
    descriptor: ()V
    flags: (0x0008) ACC_STATIC
    Code:
      stack=2, locals=0, args_size=0
         0: new           #7                  // class java/lang/Object
         3: dup
         4: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
         7: putstatic     #2                  // Field obj:Ljava/lang/Object;
        10: return
      LineNumberTable:
        line 4: 0
}

SourceFile: &quot;Demo01.java&quot;
</code></pre>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97.png" alt="图片" loading="lazy"></figure>
<p>同步代码块</p>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/synchronized.png" alt="图片" loading="lazy"></figure>
<h3 id="monitorenter">monitorenter</h3>
<p><strong>首先我们来看一下JVM规范中对于monitorenter的描述：</strong></p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter</a></p>
<blockquote>
<p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner.<br>
The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref， as follows:<br>
If the entry count of the monitor associated with objectref is zero， the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.<br>
If the thread already owns the monitor associated with objectref， it reenters the monitor， incrementing its entry count.<br>
If another thread  already owns the monitor associated with objectref， the thread blocks until the monitor's entry count is zero， then tries again to gain ownership.</p>
</blockquote>
<p>翻译过来： 每一个对象都会和一个监视器 monitor 关联。监视器被占用时会被锁住，其他线程无法来获 取该 monitor。 当 JVM 执行某个线程的某个方法内部的 monitorenter 时，它会尝试去获取当前对象对应的 monitor 的所有权。其过程如下：</p>
<ol>
<li>若 monior 的进入数为 0，线程可以进入 monitor，并将 monitor 的进入数置为 1。当前线程成为 monitor 的owner（所有者）</li>
<li>若当前线程已拥有 monitor 的所有权，允许它重入 monitor，则进入 monitor 的进入数加 1</li>
<li>若其他线程已经占有 monitor 的所有权，那么当前尝试获取 monitor 的所有权的线程会被阻塞，直到 monitor 的进入数变为 0，才能重新尝试获取 monitor 的所有权。</li>
</ol>
<p><strong>monitorenter小结：</strong></p>
<p>synchronized 的锁对象会关联一个 monitor, 这个 monitor 不是我们主动创建的，是 JVM 的线程执行到这个同步代码块,发现锁对象没有 monitor 就会创建 monitor, monitor 内部有两个重要的成员变量 <strong>owner:拥有这把锁的线程</strong>, <strong>recursions会记录线程拥有锁的次数</strong>，当一个线程拥有 monito r后其他线程只能等待。</p>
<h3 id="monitorexit">monitorexit</h3>
<p><strong>首先我们来看一下JVM规范中对于monitorexit的描述：</strong></p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit</a></p>
<blockquote>
<p>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.<br>
The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero， the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p>
</blockquote>
<p>翻译过来：</p>
<ol>
<li>能执行 monitorexit 指令的线程一定是拥有当前对象的 monitor 的所有权的线程。</li>
<li>执行 monitorexit 时会将 monitor 的进入数减 1。当 monitor 的进入数减为 0 时，当前线程退出 monitor，不再拥有 monitor 的所有权，此时其他被这个 monitor 阻塞的线程可以尝试去获取这个 monitor 的所有权 。</li>
</ol>
<h4 id="monitorexit-释放锁">monitorexit 释放锁。</h4>
<p>monitorexit 插入在<strong>方法结束处</strong>和<strong>异常处</strong>，JVM保证每个 monitorenter 必须有对应的monitorexit。</p>
<h4 id="面试题-synchroznied-出现异常会释放锁吗">面试题 synchroznied 出现异常会释放锁吗?</h4>
<p>会释放锁</p>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/synchronized%E5%87%BA%E7%8E%B0%E5%BC%82%E5%B8%B8%E4%BC%9A%E9%87%8A%E6%94%BE%E9%94%81.png" alt="图片" loading="lazy"></figure>
<p>synchronized出现异常会释放锁</p>
<h3 id="同步方法">同步方法</h3>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10</a></p>
<p>可以看到同步方法在反汇编后，会增加 <code>ACC_SYNCHRONIZED</code> 修饰。会隐式调用 monitorenter 和 monitorexit。在执行同步方法前会调用 monitorenter，在执行完同步方法后会调用 monitorexit。</p>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center">同步方法</p>
<h3 id="小结-11">小结</h3>
<p>通过 javap 反汇编我们看到 synchronized 使用变成了 monitorenter 和 monitorexit 两个指令.每个锁对象都会关联一个 monitor(监视器,它才是真正的锁对象),它内部有两个重要的成员变量owner 会保存获得锁的线程，recursions 会保存线程获得锁的次数,当执行到 monitorexit 时,recursions 会 -1,当计数器减到 0 时这个线程就会释放锁。</p>
<h3 id="面试题synchronized与lock的区别">面试题：synchronized与Lock的区别</h3>
<ol>
<li>synchronized 是关键字，而 Lock 是一个接口。</li>
<li>synchronized 会自动释放锁，而 Lock 必须手动释放锁。</li>
<li>synchronized 是不可中断的，Lock 可以中断也可以不中断。</li>
<li>通过 Lock 可以知道线程有没有拿到锁（tryLock()的返回值），而 synchronized 不能。</li>
<li>synchronized 能锁住方法和代码块，而 Lock 只能锁住代码块。</li>
<li>Lock 可以使用读锁提高多线程读效率（ReentrantReadWriteLock）。</li>
<li>synchronized 是非公平锁，ReentrantLock 可以控制是否是公平锁。</li>
</ol>
<h2 id="深入jvm源码">深入JVM源码</h2>
<h3 id="jvm源码下载">JVM源码下载</h3>
<p><a href="http://openjdk.java.net/">http://openjdk.java.net/</a> --&gt; Mercurial --&gt; jdk8 --&gt; hotspot --&gt; zip</p>
<h3 id="ideclion-下载">IDE(Clion )下载</h3>
<p><a href="https://www.jetbrains.com/">https://www.jetbrains.com/</a></p>
<h3 id="monitor监视器锁">monitor监视器锁</h3>
<p>可以看出无论是 synchronized 代码块还是 synchronized 方法，其线程安全的语义实现最终依赖一个叫 monitor 的东西，那么这个神秘的东西是什么呢？下面让我们来详细介绍一下。</p>
<p>在 HotSpot 虚拟机中，monitor 是由 ObjectMonitor 实现的。其源码是用 C++ 来实现的，位于HotSpot 虚拟机源码 ObjectMonitor.hpp 文件中(src/share/vm/runtime/objectMonitor.hpp)。ObjectMonitor 主要数据结构如下：</p>
<pre><code>ObjectMonitor() { 
  _header = NULL; 
  _count = 0; 
  _waiters = 0， 
  _recursions = 0; // 线程的重入次数
  _object = NULL; // 存储该monitor的对象 
  _owner = NULL; // 标识拥有该monitor的线程 
  _WaitSet = NULL; // 处于wait状态的线程，会被加入到_WaitSet 
  _WaitSetLock = 0 ; 
  _Responsible = NULL; 
  _succ = NULL; 
  _cxq = NULL; // 多线程竞争锁时的单向列表 
  FreeNext = NULL; 
  _EntryList = NULL; // 处于等待锁block状态的线程，会被加入到该列表 
  _SpinFreq = 0; 
  _SpinClock = 0; 
  OwnerIsThread = 0; 
}
</code></pre>
<ol>
<li>_owner：初始时为NULL。当有<strong>线程占有该monitor</strong>时，owner 标记为该线程的唯一标识。当线程释放 monitor 时，owner又恢复为 NULL。owner 是一个临界资源，JVM 是通过 CAS 操作来保证其线程安全的。</li>
<li>_cxq：竞争队列，<strong>所有请求锁的线程</strong>首先会被放在这个队列中（单向链接）。_cxq 是一个临界资源，JVM 通过 CAS 原子指令来修改 _cxq 队列。修改前 _cxq 的旧值填入了 node 的 next 字段，_cxq 指向新值（新线程）。因此_cxq 是一个后进先出的 stack（栈）。</li>
<li>_EntryList：_cxq 队列中<strong>有资格成为候选资源的线程</strong>会被移动到该队列中。</li>
<li>_WaitSet：因为<strong>调用wait方法而被阻塞</strong>的线程会被放在该队列中。</li>
</ol>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/monitor%E7%9B%91%E8%A7%86%E5%99%A8.png" alt="图片" loading="lazy"></figure>
<p>每一个 Java 对象都可以与一个监视器 monitor 关联，我们可以把它理解成为一把锁，当一个线程想要执行一段被 synchronized 圈起来的同步方法或者代码块时，该线程得先获取到 synchronized 修饰的对象对应的 monitor。</p>
<p>我们的 Java 代码里不会显示地去创造这么一个 monitor 对象，我们也无需创建，事实上可以这么理解： monitor 并不是随着对象创建而创建的。我们是通过 synchronized 修饰符告诉 JVM 需要为我们的某个对象创建关联的 monitor 对象。每个线程都存在两个 ObjectMonitor 对象列表，分别为free 和 used 列表。 同时 JVM 中也维护着 global locklist。当线程需要 ObjectMonitor 对象时，首先从线程自身的 free 表中申请，若存在则使用，若不存在则从 global list 中申请。</p>
<p>ObjectMonitor 的数据结构中包含：_owner、_WaitSet 和 _EntryList，它们之间的关系转换可以用下图表示：</p>
<figure data-type="image" tabindex="16"><img src="https://epitomm.github.io/post-images/monitor%E7%9B%91%E8%A7%86%E5%99%A8%E9%94%812.png" alt="图片" loading="lazy"></figure>
<h3 id="monitor竞争">monitor竞争</h3>
<ul>
<li>什么时候会产生 monitor 竞争
<ul>
<li>两个线程同时执行 synchronized 时，会发生竞争。</li>
</ul>
</li>
</ul>
<p><strong>如何竞争</strong></p>
<ol>
<li>执行 monitorenter 时，会调用InterpreterRuntime.cpp</li>
</ol>
<p>(位于：src/share/vm/interpreter/interpreterRuntime.cpp) 的 InterpreterRuntime::monitorenter 函数。具体代码可参见 HotSpot 源码。</p>
<pre><code>IRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))
#ifdef ASSERT
  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);
#endif
  if (PrintBiasedLockingStatistics) {
    Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
  }
  Handle h_obj(thread, elem-&gt;obj());
  assert(Universe::heap()-&gt;is_in_reserved_or_null(h_obj()),
         &quot;must be NULL or an object&quot;);
  if (UseBiasedLocking) {//是否设置使用了偏向锁
    // Retry fast entry if bias is revoked to avoid unnecessary inflation
    ObjectSynchronizer::fast_enter(h_obj, elem-&gt;lock(), true, CHECK);
  } else {  // 使用重量级锁
    ObjectSynchronizer::slow_enter(h_obj, elem-&gt;lock(), CHECK);
  }
  assert(Universe::heap()-&gt;is_in_reserved_or_null(elem-&gt;obj()),
         &quot;must be NULL or an object&quot;);
</code></pre>
<ol>
<li>对于重量级锁，monitorenter 函数中会调用 ObjectSynchronizer::slow_enter</li>
<li>最终调用 ObjectMonitor::enter（位于：src/share/vm/runtime/objectMonitor.cpp），源码如下：</li>
</ol>
<pre><code>void ATTR ObjectMonitor::enter(TRAPS) { 
  // The following code is ordered to check the most common cases first 
  // and to reduce RTS-&gt;RTO cache line upgrades on SPARC and IA32 processors. 
  Thread * const Self = THREAD ; 
  void * cur ; 
  
  // 通过CAS操作尝试把monitor的_owner字段设置为当前线程 
  cur = Atomic::cmpxchg_ptr (Self， &amp;_owner， NULL) ; 
  if (cur == NULL) { 
    // Either ASSERT _recursions == 0 or explicitly set _recursions = 0. 
    assert (_recursions == 0 ， &quot;invariant&quot;) ; 
    assert (_owner == Self， &quot;invariant&quot;) ; 
    // CONSIDER: set or assert OwnerIsThread == 1 
    return ; 
  }
  // 线程重入，recursions++ 
  if (cur == Self) { 
    // TODO-FIXME: check for integer overflow! BUGID 6557169. 
    _recursions ++ ; 
    return ; 
  }
  
  // 如果当前线程是第一次进入该monitor，设置_recursions为1，_owner为当前线程
  if (Self-&gt;is_lock_owned ((address)cur)) {
    assert (_recursions == 0， &quot;internal state error&quot;);
    _recursions = 1 ;
    // Commute owner from a thread-specific on-stack BasicLockObject address to
    // a full-fledged &quot;Thread *&quot;.
    _owner = Self ;
    OwnerIsThread = 1 ;
    return ;
  }
  
  // 省略一些代码
  for (;;) {
    jt-&gt;set_suspend_equivalent();
    // cleared by handle_special_suspend_equivalent_condition()
    // or java_suspend_self()
    
    // 如果获取锁失败，则阻塞，等待锁的释放，进入_cxq列表；
    EnterI (THREAD) ;
    
    if (!ExitSuspendEquivalent(jt)) break ;

  //
  // We have acquired the contended monitor， but while we were
  // waiting another thread suspended us. We don't want to enter
  // the monitor while suspended because that would surprise the
  // thread that suspended us.
  //
      _recursions = 0 ;
    _succ = NULL ;
    exit (false， Self) ;
  
    jt-&gt;java_suspend_self();
  }
  Self-&gt;set_current_pending_monitor(NULL);
}
</code></pre>
<p>此处省略锁的自旋优化等操作，统一放在后面synchronzied优化中说。<br>
以上代码的具体流程概括如下：</p>
<ol>
<li>通过CAS尝试把 monitor 的 owner 字段设置为当前线程。</li>
<li>如果设置之前的 owner 指向当前线程，说明当前线程再次进入monitor，即重入锁，执行 _recursions++ ，记录重入的次数。</li>
<li>如果当前线程是第一次进入该 monitor，设置 _recursions 为 1，_owner 为当前线程，该线程成功获得锁并返回。</li>
<li>如果获取锁失败，则等待锁的释放。</li>
</ol>
<h3 id="monitor等待">monitor等待</h3>
<p>竞争失败等待调用的是 ObjectMonitor 对象的 EnterI 方法（位于：src/share/vm/runtime/objectMonitor.cpp），源码如下所示：</p>
<pre><code>void ATTR ObjectMonitor::EnterI (TRAPS) { 
  Thread * Self = THREAD ;
  
  // Try the lock - TATAS 
  if (TryLock (Self) &gt; 0) { 
    assert (_succ != Self , &quot;invariant&quot;) ; 
    assert (_owner == Self , &quot;invariant&quot;) ; 
    assert (_Responsible != Self , &quot;invariant&quot;) ; 
    return ; 
  }
  
  if (TrySpin (Self) &gt; 0) { 
    assert (_owner == Self , &quot;invariant&quot;) ; 
    assert (_succ != Self , &quot;invariant&quot;) ; 
    assert (_Responsible != Self , &quot;invariant&quot;) ; 
    return ; 
  }
  
  // 省略部分代码 
  
  // 当前线程被封装成ObjectWaiter对象node，状态设置成ObjectWaiter::TS_CXQ； 
  ObjectWaiter node(Self) ; 
  Self-&gt;_ParkEvent-&gt;reset() ; 
  node._prev = (ObjectWaiter *) 0xBAD ; 
  node.TState = ObjectWaiter::TS_CXQ ; 
  
  // 通过CAS把node节点push到_cxq列表中 
  ObjectWaiter * nxt ; 
  for (;;) { 
    node._next = nxt = _cxq ; 
    if (Atomic::cmpxchg_ptr (&amp;node， &amp;_cxq， nxt) == nxt) break ; 
    
    // Interference - the CAS failed because _cxq changed. Just retry. 
    // As an optional optimization we retry the lock. 
    if (TryLock (Self) &gt; 0) { 
      assert (_succ != Self ， &quot;invariant&quot;) ; 
      assert (_owner == Self ， &quot;invariant&quot;) ; 
      assert (_Responsible != Self ， &quot;invariant&quot;) ; 
      return ; 
    } 
  }
  
  // 省略部分代码 
  for (;;) { 
    // 线程在被挂起前做一下挣扎，看能不能获取到锁 
    if (TryLock (Self) &gt; 0) break ; 
    assert (_owner != Self， &quot;invariant&quot;) ; 
    if ((SyncFlags &amp; 2) &amp;&amp; _Responsible == NULL) { 
      Atomic::cmpxchg_ptr (Self， &amp;_Responsible， NULL) ; 
    }
    
    // park self 
    if (_Responsible == Self || (SyncFlags &amp; 1)) { 
      TEVENT (Inflated enter - park TIMED) ; 
      Self-&gt;_ParkEvent-&gt;park ((jlong) RecheckInterval) ; 
      // Increase the RecheckInterval， but clamp the value. 
      RecheckInterval *= 8 ; 
      if (RecheckInterval &gt; 1000) RecheckInterval = 1000 ; 
    } else { 
      TEVENT (Inflated enter - park UNTIMED) 
      // 通过park将当前线程挂起，等待被唤醒 
      Self-&gt;_ParkEvent-&gt;park() ; 
    }
    // 被唤醒后尝试获取锁
    if (TryLock(Self) &gt; 0) break ; 
    // 省略部分代码 
  }
  
  // 省略部分代码 
}
</code></pre>
<p>当该线程被唤醒时，会从挂起的点继续执行，通过 ObjectMonitor::TryLock 尝试获取锁，TryLock方法实现如下：</p>
<pre><code>int ObjectMonitor::TryLock (Thread * Self) { 
  for (;;) { 
    void * own = _owner ; 
    if (own != NULL) return 0 ; 
    // CAS 尝试获取锁
    if (Atomic::cmpxchg_ptr (Self， &amp;_owner， NULL) == NULL) { 
      // Either guarantee _recursions == 0 or set _recursions = 0. 
      assert (_recursions == 0， &quot;invariant&quot;) ; 
      assert (_owner == Self， &quot;invariant&quot;) ; 
      // CONSIDER: set or assert that OwnerIsThread == 1 
      return 1 ; 
    }
    // The lock had been free momentarily， but we lost the race to the lock. 
    // Interference -- the CAS failed. 
    // We can either return -1 or retry. 
    // Retry doesn't make as much sense because the lock was just acquired. 
    if (true) return -1 ; 
  } 
}
</code></pre>
<p>以上代码的具体流程概括如下：</p>
<ol>
<li>当前线程被封装成 ObjectWaiter 对象 node，状态设置成 ObjectWaiter::TS_CXQ。</li>
<li>在 for 循环中，通过 CAS 把 node 节点 push 到 _cxq 列表中，同一时刻可能有多个线程把自己的 node 节点 pus h到 _cxq 列表中。</li>
<li>node 节点 push 到 _cxq 列表之后，通过自旋尝试获取锁，如果还是没有获取到锁，则通过 park 将当前线程挂起，等待被唤醒。</li>
<li>当该线程被唤醒时，会从挂起的点继续执行，通过 ObjectMonitor::TryLock 尝试获取锁。</li>
</ol>
<h3 id="monitor释放">monitor释放</h3>
<p>当某个持有锁的线程执行完同步代码块时，会进行锁的释放，给其它线程机会执行同步代码，在 HotSpot 中，通过退出 monitor 的方式实现锁的释放，并通知被阻塞的线程，具体实现位于 ObjectMonitor 的 exit 方法中。（位于：src/share/vm/runtime/objectMonitor.cpp），源码如下所示：</p>
<pre><code>void ATTR ObjectMonitor::exit(bool not_suspended， TRAPS) { 
  Thread * Self = THREAD ; 
  // 省略部分代码 
  // 重入锁
  if (_recursions != 0) { 
    _recursions--; // this is simple recursive enterTEVENT (Inflated exit - recursive) ; 
    return ; 
  }
  
  // 省略部分代码 
  // 等待的线程用 ObjectWaiter 包装，使用变量 w 存放被唤醒的线程
  ObjectWaiter * w = NULL ; 
  int QMode = Knob_QMode ; 
  
  // qmode = 2：直接绕过EntryList队列，从cxq队列中获取线程用于竞争锁 
  if (QMode == 2 &amp;&amp; _cxq != NULL) { 
    w = _cxq ; // _cxq 的链表头赋值给 w
    assert (w != NULL， &quot;invariant&quot;) ; 
    assert (w-&gt;TState == ObjectWaiter::TS_CXQ， &quot;Invariant&quot;) ; 
    ExitEpilog (Self， w) ; // 唤醒线程
    return ; 
  }
  
  // qmode =3：cxq队列插入EntryList尾部； 
  if (QMode == 3 &amp;&amp; _cxq != NULL) { 
    w = _cxq ; 
    for (;;) { 
      assert (w != NULL， &quot;Invariant&quot;) ; 
      ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL， 
      &amp;_cxq， w) ; 
      if (u == w) break ; 
      w = u ; 
    }
    assert (w != NULL ， &quot;invariant&quot;) ; 
    
    ObjectWaiter * q = NULL ; 
    ObjectWaiter * p ; 
    for (p = w ; p != NULL ; p = p-&gt;_next) { 
      guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ， &quot;Invariant&quot;) ; 
      p-&gt;TState = ObjectWaiter::TS_ENTER ; 
      p-&gt;_prev = q ; 
      q = p ; 
    }
    ObjectWaiter * Tail ; 
    for (Tail = _EntryList ; Tail != NULL &amp;&amp; Tail-&gt;_next != NULL ; Tail = Tail-&gt;_next) ; 
    if (Tail == NULL) { 
      _EntryList = w ; 
    } else { 
      Tail-&gt;_next = w ; 
      w-&gt;_prev = Tail ; 
    } 
  }
  
  // qmode =4：cxq队列插入到_EntryList头部 
  if (QMode == 4 &amp;&amp; _cxq != NULL) { 
    w = _cxq ; 
    for (;;) { 
      assert (w != NULL， &quot;Invariant&quot;) ; 
      ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL， 
      &amp;_cxq， w) ; 
      if (u == w) break ; 
      w = u ;
    }
    assert (w != NULL ， &quot;invariant&quot;) ; 
    
    ObjectWaiter * q = NULL ; 
    ObjectWaiter * p ; 
    for (p = w ; p != NULL ; p = p-&gt;_next) { 
      guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ， &quot;Invariant&quot;) ; 
      p-&gt;TState = ObjectWaiter::TS_ENTER ; 
      p-&gt;_prev = q ; 
      q = p ; 
    }
    if (_EntryList != NULL) { 
      q-&gt;_next = _EntryList ; 
      _EntryList-&gt;_prev = q ; 
    }
    _EntryList = w ; 
  }
  w = _EntryList ; 
  if (w != NULL) { 
    assert (w-&gt;TState == ObjectWaiter::TS_ENTER， &quot;invariant&quot;) ; 
    ExitEpilog (Self， w) ; 
    return ; 
  }
  w = _cxq ; 
  if (w == NULL) continue ; 
  for (;;) { 
    assert (w != NULL， &quot;Invariant&quot;) ; 
    ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL， &amp;_cxq，w) ; 
    if (u == w) break ; 
    w = u ; 
  }
  TEVENT (Inflated exit - drain cxq into EntryList) ; 
  assert (w != NULL ， &quot;invariant&quot;) ; 
  assert (_EntryList == NULL ， &quot;invariant&quot;) ; 
  if (QMode == 1) { 
    // QMode == 1 : drain cxq to EntryList， reversing order 
    // We also reverse the order of the list. 
    ObjectWaiter * s = NULL ; 
    ObjectWaiter * t = w ; 
    ObjectWaiter * u = NULL ; 
    while (t != NULL) { 
      guarantee (t-&gt;TState == ObjectWaiter::TS_CXQ， &quot;invariant&quot;) ; 
      t-&gt;TState = ObjectWaiter::TS_ENTER ; 
      u = t-&gt;_next ; 
      t-&gt;_prev = u ; 
      t-&gt;_next = s ; 
      s = t; 
      t = u ; 
    }
    _EntryList = s ; 
    assert (s != NULL， &quot;invariant&quot;) ;
  } else { 
    // QMode == 0 or QMode == 2 
    _EntryList = w ; 
    ObjectWaiter * q = NULL ; 
    ObjectWaiter * p ; 
    for (p = w ; p != NULL ; p = p-&gt;_next) { 
      guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ， &quot;Invariant&quot;) ; 
      p-&gt;TState = ObjectWaiter::TS_ENTER ; 
      p-&gt;_prev = q ; 
      q = p ; 
      } 
    }
    if (_succ != NULL) continue; 
    
    w = _EntryList ; 
    if (w != NULL) { 
      guarantee (w-&gt;TState == ObjectWaiter::TS_ENTER， &quot;invariant&quot;) ; 
      ExitEpilog (Self， w) ; // 唤醒线程
      return ; 
    } 
  } 
}
</code></pre>
<ol>
<li>退出同步代码块时会让 _recursions 减 1，当 _recursions 的值减为0时，说明线程释放了锁。</li>
<li>根据不同的策略（由QMode指定），从 _cxq 或 EntryList 中获取头节点，通过ObjectMonitor::ExitEpilog 方法唤醒该节点封装的线程，唤醒操作最终由 unpark 完成，实现如下：</li>
</ol>
<pre><code>void ObjectMonitor::ExitEpilog (Thread * Self， ObjectWaiter * Wakee) { 
  assert (_owner == Self， &quot;invariant&quot;) ; 
  
  _succ = Knob_SuccEnabled ? Wakee-&gt;_thread : NULL ; 
  ParkEvent * Trigger = Wakee-&gt;_event ; 
  
  Wakee = NULL ; 
  
  // Drop the lock 
  OrderAccess::release_store_ptr (&amp;_owner， NULL) ; 
  OrderAccess::fence() ; // ST _owner vs LD in 
  unpark() 
  if (SafepointSynchronize::do_call_back()) { 
    TEVENT (unpark before SAFEPOINT) ; 
  }
  
  DTRACE_MONITOR_PROBE(contended__exit， this， object()， Self); 
  Trigger-&gt;unpark() ; // 唤醒之前被pack()挂起的线程. 
  
  // Maintain stats and report events to JVMTI 
  if (ObjectMonitor::_sync_Parks != NULL) { 
    ObjectMonitor::_sync_Parks-&gt;inc() ; 
  } 
}
</code></pre>
<p>被唤醒的线程，会回到 void ATTR ObjectMonitor::EnterI (TRAPS) 的第600行，继续执行monitor 的竞争。</p>
<pre><code>// park self 
if (_Responsible == Self || (SyncFlags &amp; 1)) { 
  TEVENT (Inflated enter - park TIMED) ; 
  Self-&gt;_ParkEvent-&gt;park ((jlong) RecheckInterval) ; 
  // Increase the RecheckInterval， but clamp the value. 
  RecheckInterval *= 8 ; 
  if (RecheckInterval &gt; 1000) RecheckInterval = 1000 ; 
} else { 
  TEVENT (Inflated enter - park UNTIMED) ; 
  Self-&gt;_ParkEvent-&gt;park() ; 
}
if (TryLock(Self) &gt; 0) break ;
</code></pre>
<h3 id="monitor是重量级锁">monitor是重量级锁</h3>
<p>可以看到 ObjectMonitor 的函数调用中会涉及到 Atomic::cmpxchg_ptr，Atomic::inc_ptr 等内核函数，执行同步代码块，没有竞争到锁的对象会 park() 被挂起，竞争到锁的线程会 unpark() 唤醒。这个时候就会存在操作系统<strong>用户态和内核态的转换</strong>，这种切换会消耗大量的系统资源。所以synchronized 是 Java 语言中是一个重量级(Heavyweight)的操作。</p>
<p>用户态和和内核态是什么东西呢？要想了解用户态和内核态还需要先了解一下 Linux 系统的体系架构：</p>
<figure data-type="image" tabindex="17"><img src="https://epitomm.github.io/post-images/Linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center">Linux系统的体系架构</p>
<p>从上图可以看出，Linux操作系统的体系架构分为：用户空间（应用程序的活动空间）和内核。</p>
<p><strong>内核</strong>：本质上可以理解为一种软件，控制计算机的硬件资源，并提供上层应用程序运行的环境。</p>
<p><strong>用户空间</strong>：上层应用程序活动的空间。应用程序的执行必须依托于内核提供的资源，包括CPU资源、存储资源、I/O资源等。</p>
<p><strong>系统调用</strong>：为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用。</p>
<p>所有进程初始都运行于用户空间，此时即为用户运行状态（简称：用户态）；但是当它调用系统调用执行某些操作时，例如 I/O调用，此时需要陷入内核中运行，我们就称进程处于内核运行态（或简称为内核态）。 系统调用的过程可以简单理解为：</p>
<ol>
<li>用户态程序将一些数据值放在寄存器中， 或者使用参数创建一个堆栈， 以此表明需要操作系统提供的服务。</li>
<li>用户态程序执行系统调用。</li>
<li>CPU切换到内核态，并跳到位于内存指定位置的指令。</li>
<li>系统调用处理器(system call handler)会读取程序放入内存的数据参数，并执行程序请求的服务。</li>
<li>系统调用完成后，操作系统会重置CPU为用户态并返回系统调用的结果。</li>
</ol>
<p>由此可见用户态切换至内核态需要传递许多变量，同时内核还需要保护好用户态在切换时的一些寄存器值、变量等，以备内核态切换回用户态。<strong>这种切换就带来了大量的系统资源消耗</strong>，这就是在 synchronized 未优化之前，效率低的原因。</p>
<h1 id="第六章jdk6-synchronized优化">第六章：JDK6 synchronized优化</h1>
<h2 id="cas">CAS</h2>
<p>CAS的全称是： Compare And Swap(比较相同再交换)。是现代CPU广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。</p>
<p>CAS的作用：CAS可以将比较和交换转换为原子操作，这个<strong>原子操作直接由CPU保证</strong>。CAS可以保证共享变量赋值时的原子操作。CAS操作依赖3个值：内存中的值V，旧的预估值X，要修改的新值B，如果旧的预估值X等于内存中的值V，就将新的值B保存到内存中。</p>
<p><strong>CAS 和 volatile 实现无锁并发</strong></p>
<pre><code>package com.itheima.demo05_cas;
import java.util.ArrayList;
import java.util.concurrent.atomic.AtomicInteger;
public class Demo01 {
    public static void main(String[] args) throws InterruptedException {
        AtomicInteger atomicInteger = new AtomicInteger();
        Runnable mr = () -&gt; {
            for (int i = 0; i &lt; 1000; i++) {
                atomicInteger.incrementAndGet();
            }
        };
        ArrayList&lt;Thread&gt; ts = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 5; i++) {
            Thread t = new Thread(mr);
            t.start();
            ts.add(t);
        }
        for (Thread t : ts) {
            t.join();
        }
        System.out.println(&quot;atomicInteger = &quot; + atomicInteger.get());
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>atomicInteger  = 5000
</code></pre>
<h3 id="cas原理">CAS原理</h3>
<p>通过刚才 AtomicInteger 的源码我们可以看到，Unsafe 类提供了原子操作。</p>
<p><strong>Unsafe类介绍</strong></p>
<p>Unsafe 类使 Java 拥有了像 C 语言的指针一样操作内存空间的能力，同时也带来了指针的问题。过度的使用 Unsafe 类会使得出错的几率变大，因此 Java 官方并不建议使用的，官方文档也几乎没有。Unsafe 对象不能直接调用，只能通过反射获得。</p>
<figure data-type="image" tabindex="18"><img src="https://epitomm.github.io/post-images/unsafe%E7%B1%BB.png" alt="图片" loading="lazy"></figure>
<pre><code>public class AtomicInteger extends Number implements java.io.Serializable {
    private static final long serialVersionUID = 6214790243416807050L;

    // setup to use Unsafe.compareAndSwapInt for updates
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    // value 的偏移地址
    private static final long valueOffset;

    static {
        try {
            valueOffset = unsafe.objectFieldOffset
                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));
        } catch (Exception ex) {
             throw new Error(ex); 
        }
    }
    // 数字保存在 value 中。根据 AtomicInteger 对象的内存地址 和 value 的偏移地址，找到 value 的值
    private volatile int value;
</code></pre>
<p><strong>Unsafe实现CAS</strong><br>
<img src="https://epitomm.github.io/post-images/unsafe%E5%AE%9E%E7%8E%B0CAS.png" alt="图片" loading="lazy"></p>
<h3 id="乐观锁和悲观锁">乐观锁和悲观锁</h3>
<p><strong>悲观锁</strong>从悲观的角度出发：</p>
<p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞。因此<strong>synchronized</strong>我们也将其称之为悲观锁。JDK中的<strong>ReentrantLock</strong>也是一种悲观锁。性能较差！</p>
<p><strong>乐观锁</strong>从乐观的角度出发:</p>
<p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，就算改了也没关系，再重试即可。所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去修改这个数据，如果没有人修改则更新，如果有人修改则重试。</p>
<p>CAS这种机制我们也可以将其称之为乐观锁。综合性能较好！</p>
<blockquote>
<p>CAS获取共享变量时，为了保证该变量的可见性，需要使用volatile修饰。结合CAS和volatile可以实现无锁并发，适用于竞争不激烈、多核 CPU 的场景下。</p>
<ol>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一。</li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响。</li>
</ol>
</blockquote>
<h3 id="小结-12">小结</h3>
<ul>
<li><strong>CAS的作用?</strong>
<ul>
<li>Compare And Swap，CAS可以将比较和交换转换为原子操作，这个原子操作直接由处理器保证。</li>
</ul>
</li>
<li><strong>CAS的原理？</strong>
<ul>
<li>CAS需要3个值:内存地址V，旧的预期值A，要修改的新值B，如果内存地址V和旧的预期值A相等就修改内存地址值为B</li>
</ul>
</li>
</ul>
<h2 id="synchronized锁升级过程">synchronized锁升级过程</h2>
<p>高效并发是从 JDK5 到 JDK6 的一个重要改进，HotSpot 虛拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术，包括偏向锁( Biased Locking )、轻量级锁( Lightweight Locking )和如适应性自旋(Adaptive Spinning)、锁消除( Lock Elimination)、锁粗化( Lock Coarsening )等，这些技术都是为了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。</p>
<p><strong>无锁 --&gt; 偏向锁 --&gt; 轻量级锁 –&gt; 重量级锁</strong></p>
<h2 id="java对象的布局">Java对象的布局</h2>
<p>术语参考: <a href="http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html">http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html</a></p>
<p>在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。如下图所示：</p>
<figure data-type="image" tabindex="19"><img src="https://epitomm.github.io/post-images/%E5%AF%B9%E8%B1%A1%E5%A4%B4.png" alt="图片" loading="lazy"></figure>
<h3 id="对象头">对象头</h3>
<p>当一个线程尝试访问 synchronized 修饰的代码块时，它首先要获得锁，那么这个锁到底存在哪里呢？是存在锁对象的对象头中的。</p>
<p>HotSpot 采用 instanceOopDesc 和 arrayOopDesc 来描述对象头，arrayOopDesc 对象用来描述数组类型。instanceOopDesc 的定义的在 Hotspot 源码的 instanceOop.hpp 文件中，另外，arrayOopDesc 的定义对应 arrayOop.hpp 。</p>
<pre><code>class instanceOopDesc : public oopDesc {
    public:
    // aligned header size.
    static int header_size() { return sizeof(instanceOopDesc)/HeapWordSize; }
    // If compressed, the offset of the fields of the instance may not be aligned.
    static int base_offset_in_bytes() {
    // offset computation code breaks if UseCompressedClassPointers
    // only is true
            return (UseCompressedOops &amp;&amp; UseCompressedClassPointers) ?
            klass_gap_offset_in_bytes() :
            sizeof(instanceOopDesc);
    }
    static bool contains_field_offset(int offset, int nonstatic_field_size) {
        int base_in_bytes = base_offset_in_bytes();
        return (offset &gt;= base_in_bytes &amp;&amp;
            (offset-base_in_bytes) &lt; nonstatic_field_size * heapOopSize);
    }
};
</code></pre>
<p>从 instanceOopDesc 代码中可以看到 instanceOopDesc 继承自 oopDesc，oopDesc 的定义在Hotspot 源码中的 oop.hpp 文件中。</p>
<pre><code>class oopDesc {
    friend class VMStructs;
   private:
    volatile markOop _mark;
    union _metadata {
        Klass* _klass;
        narrowKlass _compressed_klass;
    } _metadata;
// Fast access to barrier set. Must be initialized. 
    static BarrierSet* _bs;
// 省略其他代码 
};
</code></pre>
<p>在普通实例对象中，oopDesc 的定义包含两个成员，分别是 _mark 和 _metadata</p>
<p>_mark 表示<strong>对象标记</strong>、属于 markOop 类型，也就是接下来要讲解的 Mark World，它记录了<strong>对象和锁有关的信息</strong></p>
<p>_metadata 表示<strong>类元信息</strong>，类元信息存储的是<strong>对象指向它的类元数据(Klass)的首地址</strong>，其中 Klass 表示普通指针、 _compressed_klass 表示压缩类指针。</p>
<figure data-type="image" tabindex="20"><img src="https://epitomm.github.io/post-images/%E5%AF%B9%E8%B1%A1%E5%A4%B4.png" alt="图片" loading="lazy"></figure>
<p>对象头由两部分组成，一部分用于存储自身的运行时数据，称之为 Mark Word，另外一部分是类型指针，及对象指向它的类元数据的指针。</p>
<p><strong>Mark Word</strong></p>
<p>Mark Word用于存储<strong>对象自身的运行时数据</strong>，如<strong>哈希码（HashCode）、GC分代年龄、锁状态标志、 线程持有的锁、偏向线程ID、偏向时间戳</strong>等等，占用内存大小与虚拟机位长一致。Mark Word对应的类型是 markOop 。源码位于 markOop.hpp 中。</p>
<pre><code>// Bit-format of an object header (most significant first, big endian layout below): 
//
// 32 bits: 
// -------- 
// hash:25 ------------&gt;| age:4 biased_lock:1 lock:2 (normal object)// JavaThread*:23 epoch:2 age:4 biased_lock:1 lock:2 (biased object) 
// size:32 ------------------------------------------&gt;| (CMS free block) 
// PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object) 
//
// 64 bits: 
// -------- 
// unused:25 hash:31 --&gt;| unused:1 age:4 biased_lock:1 lock:2 (normal object) 
// JavaThread*:54 epoch:2 unused:1 age:4 biased_lock:1 lock:2 (biased object) 
// PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object) 
// size:64 -----------------------------------------------------&gt;| (CMS free block) 
// [JavaThread* | epoch | age | 1 | 01] lock is biased toward given thread 
// [0 | epoch | age | 1 | 01] lock is anonymously biased 
//
// - the two lock bits are used to describe three states: locked/unlocked and monitor. 
//
// [ptr | 00] locked ptr points to real header on stack 
// [header | 0 | 01] unlocked regular object header 
// [ptr | 10] monitor inflated lock (header is wapped out) 
// [ptr | 11] marked used by markSweep to mark an object 
// not valid at any other time 
</code></pre>
<figure data-type="image" tabindex="21"><img src="https://epitomm.github.io/post-images/%E5%AF%B9%E8%B1%A1%E5%A4%B42.png" alt="图片" loading="lazy"></figure>
<p>在64位虚拟机下，Mark Word 是 64bit 大小的，其存储结构如下：</p>
<figure data-type="image" tabindex="22"><img src="https://epitomm.github.io/post-images/64%E4%BD%8D%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E5%A4%B4.png" alt="图片" loading="lazy"></figure>
<p>在32位虚拟机下，Mark Word 是 32bit 大小的，其存储结构如下：</p>
<figure data-type="image" tabindex="23"><img src="https://epitomm.github.io/post-images/32%E4%BD%8D%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E5%A4%B4.png" alt="图片" loading="lazy"></figure>
<p><strong>klass pointer</strong></p>
<p>这一部分用于存储对象的类型指针，该指针指向它的类元数据，JVM通过这个指针确定对象是<strong>哪个类的实例</strong>。该指针的位长度为 JVM 的一个字大小，即 32 位的 JVM 为 32 位，64 位的 JVM 为 64 位。</p>
<p>如果应用的对象过多，使用 64 位的指针将浪费大量内存，统计而言，64 位的 JVM 将会比 32 位的 JVM 多耗费 50% 的内存。为了节约内存可以使用选项 <code>-XX:+UseCompressedOops</code> 开启指针压缩，其中，oop 即 ordinary object pointer 普通对象指针。开启该选项后，下列指针将压缩至 32 位：</p>
<ol>
<li>每个Class的属性指针（即静态变量）</li>
<li>每个对象的属性指针（即对象变量）</li>
<li>普通对象数组的每个元素指针</li>
</ol>
<p>当然，也不是所有的指针都会压缩，一些特殊类型的指针 JVM 不会优化，比如指向 PermGen 的 Class 对象指针(JDK8 中指向元空间的 Class 对象指针)、本地变量、堆栈元素、入参、返回值和 NULL 指针等。</p>
<p>对象头 = Mark Word + 类型指针（未开启指针压缩的情况下）</p>
<p>在32位系统中，Mark Word = 4 bytes，类型指针 = 4bytes，对象头 = 8 bytes = 64 bits；</p>
<p>在64位系统中，Mark Word = 8 bytes，类型指针 = 8bytes，对象头 = 16 bytes = 128bits；</p>
<h3 id="实例数据">实例数据</h3>
<p>就是类中定义的成员变量。</p>
<h3 id="对齐填充">对齐填充</h3>
<p>对齐填充并不是必然存在的，也没有什么特别的意义，他仅仅起着占位符的作用，由于 HotSpot VM 的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头正好是8字节的倍数，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h3 id="查看java对象布局">查看Java对象布局</h3>
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;
  &lt;artifactId&gt;jol-core&lt;/artifactId&gt;
  &lt;version&gt;0.9&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code>package com.itheima.demo06_object_layout;

public class LockObj {
    private int x;
    private boolean b;
}
</code></pre>
<pre><code>package com.itheima.demo06_object_layout;

import org.openjdk.jol.info.ClassLayout;

public class Demo01 {
    public static void main(String[] args) {
        LockObj obj = new LockObj();

        obj.hashCode();
        System.out.println(obj.hashCode());
        System.out.println(Integer.toHexString(obj.hashCode()));

        System.out.println(ClassLayout.parseInstance(obj).toPrintable());
    }
}
</code></pre>
<figure data-type="image" tabindex="24"><img src="https://epitomm.github.io/post-images/%E5%AF%B9%E8%B1%A1%E5%A4%B43.png" alt="图片" loading="lazy"></figure>
<h3 id="小结-13">小结</h3>
<p>Java对象由3部分组成，对象头，实例数据，对齐数据</p>
<p>对象头分成两部分：Mark World + Klass pointer</p>
<h2 id="偏向锁">偏向锁</h2>
<p>偏向锁是 JDK6 中的重要引进，因为HotSpot作者经过研究实践发现，在大多数情况下，<strong>锁不仅不存在多线程竞争，而且总是由同一线程多次获得</strong>，为了让线程获得锁的代价更低，引进了偏向锁。</p>
<p>偏向锁的“偏”，就是偏心的“偏”、偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程，会在对象头存储锁偏向的线程ID，以后该线程进入和退出同步块时只需要检查是否为偏向锁、锁标志位以 ThreadID 即可。</p>
<figure data-type="image" tabindex="25"><img src="https://epitomm.github.io/post-images/%E5%81%8F%E5%90%91%E9%94%81.png" alt="图片" loading="lazy"></figure>
<p>不过<strong>一旦出现多个线程竞争时必须撤销偏向锁</strong>，所以撤销偏向锁消耗的性能必须小于之前节省下来的CAS原子操作的性能消耗，不然就得不偿失了。</p>
<h3 id="偏向锁原理">偏向锁原理</h3>
<p>当线程第一次访问同步块并获取锁时，偏向锁处理流程如下：</p>
<ol>
<li>虚拟机将会把对象头中的标志位设为“01”，即偏向模式。</li>
<li>同时使用 CAS 操作把获取到这个锁的线程的 ID 记录在对象的 Mark Word 之中 ，如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。</li>
</ol>
<figure data-type="image" tabindex="26"><img src="https://epitomm.github.io/post-images/%E5%81%8F%E5%90%91%E9%94%81.png" alt="图片" loading="lazy"></figure>
<p>持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以<strong>不再进行任何同步操作</strong>，偏向锁的效率高。</p>
<h3 id="偏向锁的撤销">偏向锁的撤销</h3>
<ol>
<li>偏向锁的撤销动作必须等待<strong>全局安全点</strong> （所有线程都停下来的点。举例：统计 9 点某地有多少人，9 点让所有人停下来，不能进出，开始统计）</li>
<li><strong>暂停拥有偏向锁的线程</strong>，判断锁对象是否处于被锁定状态</li>
<li>撤销偏向锁，恢复到无锁（标志位为 <strong>01</strong>）或轻量级锁（标志位为 <strong>00</strong>）的状态</li>
</ol>
<p>偏向锁在 Java6 之后是默认启用的，但在应用程序启动几秒钟之后才激活，可以使用 <code>-XX:BiasedLockingStartupDelay=0</code> 参数关闭延迟，如果确定应用程序中所有锁通常情况下处于竞争状态，可以通过 <code>XX:-UseBiasedLocking=false</code> 参数关闭偏向锁。</p>
<h3 id="偏向锁好处">偏向锁好处</h3>
<p>偏向锁是在只有一个线程执行同步块时进一步提高性能，适用于<strong>一个线程反复获得同一锁</strong>的情况。偏向锁可以提高带有同步但无竞争的程序性能。</p>
<p>它同样是一个带有效益权衡性质的优化，也就是说，它并不一定总是对程序运行有利，如果程序中<strong>大多数的锁总是被多个不同的线程访问</strong>比如<strong>线程池</strong>，那偏向模式就是多余的。</p>
<p>在 JDK5 中偏向锁默认是关闭的，而到了 JDK6 中偏向锁已经默认开启。但在应用程序启动几秒钟之后才激活，可以使用 <code>-XX:BiasedLockingStartupDelay=0</code> 参数关闭延迟，如果确定应用程序中所有锁通常情况下处于竞争状态，可以通过 <code>XX:-UseBiasedLocking=false</code> 参数关闭偏向锁。</p>
<h3 id="小结-14">小结</h3>
<ul>
<li>偏向锁的原理是什么?</li>
</ul>
<p>当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，偏向锁设置为“1”，即偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中 ，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。</p>
<ul>
<li>偏向锁的好处是什么?</li>
</ul>
<p>偏向锁是在只有一个线程执行同步块时进一步提高性能，适用于<strong>一个线程反复获得同一锁</strong>的情况。偏向锁可以提高带有同步但无竞争的程序性能。</p>
<h2 id="轻量级锁">轻量级锁</h2>
<p>轻量级锁是 JDK6 之中加入的新型锁机制，它名字中的“轻量级”是相对于使用 monitor 的传统锁而言的，因此传统的锁机制就称为“重量级”锁。首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的。</p>
<p>引入轻量级锁的目的：在<strong>多线程交替执行同步块</strong>的情况下，尽量避免重量级锁引起的性能消耗，但是如果多个线程在同一时刻进入临界区，会导致轻量级锁膨胀升级重量级锁，所以轻量级锁的出现并非是要替代重量级锁。</p>
<h3 id="轻量级锁原理">轻量级锁原理</h3>
<figure data-type="image" tabindex="27"><img src="https://epitomm.github.io/post-images/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%86.png" alt="图片" loading="lazy"></figure>
<p>当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步骤如下： 获取锁</p>
<ol>
<li>判断当前对象是否处于无锁状态（hashcode、0、01），如果是，则 JVM 首先将在当前线程的<strong>栈帧</strong>中建立一个名为<strong>锁记录</strong>（Lock Record）的空间，用于存储<strong>锁对象目前的 Mark Word 的拷贝</strong>（官方把这份拷贝加了一个 Displaced 前缀，即 Displaced Mark Word），将对象的 Mark Word 复制到栈帧中的 Lock Record 中，将 Lock Reocrd 中的 owner 指向当前对象。</li>
<li>JVM 利用 CAS 操作尝试<strong>将对象的 Mark Word 更新为指向 Lock Record 的指针</strong>，如果<strong>成功</strong>表示<strong>竞争到锁</strong>，则将锁标志位变成 00，执行同步操作。</li>
<li>如果失败则<strong>判断当前对象的 Mark Word 是否指向当前线程的栈帧</strong>，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成 10，后面等待的线程将会进入阻塞状态。</li>
</ol>
<p><img src="https://epitomm.github.io/post-images/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81CAS%E6%93%8D%E4%BD%9C%E4%B9%8B%E5%89%8D%E5%A0%86%E6%A0%88%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81CAS%E6%93%8D%E4%BD%9C%E4%B9%8B%E5%90%8E%E5%A0%86%E6%A0%88%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="图片" loading="lazy"></p>
<h3 id="轻量级锁的释放">轻量级锁的释放</h3>
<p>轻量级锁的释放也是通过 CAS 操作来进行的，主要步骤如下：</p>
<ol>
<li>取出在获取轻量级锁保存在 Displaced Mark Word 中的数据。</li>
<li>用 CAS 操作将取出的数据替换当前对象的 Mark Word 中，如果成功，则说明释放锁成功。</li>
<li>如果 CAS 操作替换失败，说明有其他线程尝试获取该锁，则需要将轻量级锁需要膨胀升级为重量级锁。</li>
</ol>
<p>对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，<strong>在整个生命周期内都是不会存在竞争的</strong>”，如果打破这个依据则除了互斥的开销外，还有额外的 CAS 操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢。</p>
<h3 id="轻量级锁好处">轻量级锁好处</h3>
<p>在多线程<strong>交替</strong>执行同步块的情况下，可以避免重量级锁引起的性能消耗。</p>
<h3 id="小结-15">小结</h3>
<ul>
<li>轻量级锁的原理是什么？</li>
</ul>
<p>将对象的 Mark Word 复制到栈帧中的 Lock Recod 中。Mark Word 更新为指向 Lock Record 的指针。</p>
<ul>
<li>轻量级锁好处是什么？</li>
</ul>
<p>在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。</p>
<h2 id="自旋锁">自旋锁</h2>
<h3 id="自旋锁原理">自旋锁原理</h3>
<pre><code>synchronized (Demo01.class) {
  ...
  System.out.println(&quot;aaa&quot;);
}
</code></pre>
<p>前面我们讨论 monitor 实现锁的时候，知道monitor会阻塞和唤醒线程，线程的阻塞和唤醒需要CPU从用户态转为核心态，<strong>频繁的阻塞和唤醒对CPU来说是一件负担很重的工作</strong>，这些操作给系统的并发性能带来了很大的压力。同时，虚拟机的开发团队也注意到在许多应用上，<strong>共享数据的锁定状态只会持续很短的一段时间</strong>，为了这段时间阻塞和唤醒线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个<strong>忙循环(自旋) ,</strong> 这项技术就是所谓的<strong>自旋锁</strong>。<br>
自旋锁在 JDK1.4.2 中就已经引入 ，只不过默认是关闭的，可以使用 <code>-XX:+UseSpinning</code> 参数开启，在 JDK6 中就已经改为默认开启了。自旋等待不能代替阻塞，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，<strong>如果锁被占用的时间很短，自旋等待的效果就会非常好</strong>，反之，如果锁被占用的时间很长。那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。因此，自旋等待的时间必须要有一定的限度，如果在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是10次，用户可以使用参数 <code>-XX:PreBlockSpin</code>来更改。</p>
<h3 id="适应性自旋锁">适应性自旋锁</h3>
<p>在 JDK6 中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是<strong>由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</strong>。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100次循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虛拟机就会变得越来越“聪明”了。</p>
<pre><code>int ObjectMonitor::TrySpin_VaryDuration (Thread * Self) {

    // Dumb, brutal spin.  Good for comparative measurements against adaptive spinning.
    // 固定次数的自旋锁
    int ctr = Knob_FixedSpin ;
    if (ctr != 0) {
        while (--ctr &gt;= 0) {
            if (TryLock (Self) &gt; 0) return 1 ;
            SpinPause () ;
        }
        return 0 ;
    }
    // 适应性自旋锁
    for (ctr = Knob_PreSpin + 1; --ctr &gt;= 0 ; ) {
      // 如果抢到了锁
      if (TryLock(Self) &gt; 0) {
        // Increase _SpinDuration ...
        // Note that we don't clamp SpinDuration precisely at SpinLimit.
        // Raising _SpurDuration to the poverty line is key.
        int x = _SpinDuration ;
        if (x &lt; Knob_SpinLimit) {
           if (x &lt; Knob_Poverty) x = Knob_Poverty ;
           // 修改自旋时间
           _SpinDuration = x + Knob_BonusB ;
        }
        return 1 ;
      }
      SpinPause () ;
    }

    // 省略部分代码
}
</code></pre>
<h2 id="锁消除">锁消除</h2>
<p>锁消除是指虚拟机即时编译器（JIT）在运行时，对<strong>一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁</strong>进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中，<strong>堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行</strong>。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是程序员自己应该是很清楚的，怎么会在明知道不存在数据争用的情况下要求同步呢?实际上有许多同步措施并不是程序员自己加入的，同步的代码在Java程序中的普遍程度也许超过了大部分读者的想象。下面这段非常简单的代码仅仅是输出3个字符串相加的结果，无论是源码字面上还是程序语义上都没有同步。</p>
<pre><code>public class Demo01 {
    public static void main(String[] args) {
        contactString(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;);
    }

    public static String contactString(String s1, String s2, String s3) {
        return new StringBuffer().append(s1).append(s2).append(s3).toString();
    }
}
@Override
public synchronized StringBuffer append(String str) {
    toStringCache = null;
    super.append(str);
    return this;
}
</code></pre>
<p>StringBuffffer 的 append() 是一个同步方法，锁就是 this 也就是(new StringBuilder())。虚拟机发现它的动态作用域被限制在 concatString() 方法内部。也就是说, new StringBuilder()对象的引用永远不会“逃逸”到 concatString() 方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除掉，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了。</p>
<h2 id="锁粗化">锁粗化</h2>
<p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对<strong>同一个对象反复加锁和解锁</strong>，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p>
<pre><code>public class Demo01 {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i &lt; 100; i++) {
            sb.append(&quot;aa&quot;);
        }
        System.out.println(sb.toString());
    }
}
@Override
public synchronized StringBuffer append(String str) {
    toStringCache = null;
    super.append(str);
    return this;
 }
</code></pre>
<figure data-type="image" tabindex="28"><img src="https://epitomm.github.io/post-images/%E9%94%81%E7%B2%97%E5%8C%96.png" alt="图片" loading="lazy"></figure>
<h3 id="小结-16">小结</h3>
<p>什么是锁粗化？</p>
<p>JVM会探测到一连串细小的操作都使用同一个对象加锁，将同步代码块的范围放大，放到这串操作的外面，这样只需要加一次锁即可。</p>
<h2 id="平时写代码如何对synchronized优化">平时写代码如何对synchronized优化</h2>
<h3 id="减少-synchronized-的范围">减少 synchronized 的范围</h3>
<p>同步代码块中尽量短，减少同步代码块中代码的执行时间，减少锁的竞争。</p>
<pre><code>synchronized (Demo01.class) {
    System.out.println(&quot;aaa&quot;);
}
</code></pre>
<h3 id="降低synchronized锁的粒度">降低synchronized锁的粒度</h3>
<p>将一个锁拆分为多个锁提高并发度</p>
<pre><code>Hashtable hs = new Hashtable(); 
hs.put(&quot;aa&quot;, &quot;bb&quot;); 
hs.put(&quot;xx&quot;, &quot;yy&quot;);
</code></pre>
<figure data-type="image" tabindex="29"><img src="https://epitomm.github.io/post-images/Hashtable%E9%94%81%E5%AE%9A%E6%95%B4%E4%B8%AA%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="30"><img src="https://epitomm.github.io/post-images/ConcurrentHashMap%E5%B1%80%E9%83%A8%E9%94%81%E5%AE%9A.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="31"><img src="https://epitomm.github.io/post-images/LinkedBlockingQueue%E5%85%A5%E9%98%9F%E5%87%BA%E9%98%9F%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E9%94%81.png" alt="图片" loading="lazy"></figure>
<p>LinkedBlockingQueue入队和出队使用不同的锁，相对于读写只有一个锁效率要高</p>
<figure data-type="image" tabindex="32"><img src="https://epitomm.github.io/post-images/LinkedBlockingQueue%E5%85%A5%E9%98%9F%E5%87%BA%E9%98%9F%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E9%94%812.png" alt="图片" loading="lazy"></figure>
<h3 id="读写分离">读写分离</h3>
<p><strong>读取时不加锁，写入和删除时加锁</strong></p>
<p>ConcurrentHashMap，CopyOnWriteArrayList 和 ConyOnWriteSet</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode191. 位1的个数]]></title>
        <id>https://epitomm.github.io/post/leetcode-191-wei-1-de-ge-shu/</id>
        <link href="https://epitomm.github.io/post/leetcode-191-wei-1-de-ge-shu/">
        </link>
        <updated>2020-04-14T12:12:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p>
<h2 id="示例">示例</h2>
<p>示例 1：<br>
输入：00000000000000000000000000001011<br>
输出：3<br>
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。</p>
<p>示例 2：<br>
输入：00000000000000000000000010000000<br>
输出：1<br>
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。</p>
<p>示例 3：<br>
输入：11111111111111111111111111111101<br>
输出：31<br>
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。</p>
<p>提示：<br>
请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</p>
<h2 id="方法一">方法一</h2>
<h3 id="分析">分析</h3>
<p>利用与运算</p>
<pre><code>0 &amp; 0 = 0
0 &amp; 1 = 0
1 &amp; 0 = 0
1 &amp; 1 = 1
</code></pre>
<p>我们发现，1 与 任何数相与，结果为任何数。于是我们可以利用这个性质，首先初始化 count = 0，<strong>将二进制表达式中的每一位数字依次与 1 进行与运算</strong>，如果结果为 1，就代表此位二进制数为 1，count++；如果结果为 0，就代表此位二进制数为 0。最终返回 count 值即为二进制表达式中数字位数为 ‘1’ 的个数。</p>
<h3 id="实例分析">实例分析</h3>
<p>输入：00000000000000000000000000001011<br>
输出：3<br>
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。<br>
<img src="https://epitomm.github.io/post-images/leetcode191_1.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/leetcode191_2.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/leetcode191_3.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/leetcode191_4.png" alt="图片" loading="lazy"></p>
<h3 id="代码">代码</h3>
<pre><code>public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        // 字符 '1' 的个数 count 初始化为 0
        int count = 0;
        // 初始化掩码为 1
        int mark = 1;
        // 循环直至掩码左移 32 为后为 0
        while(mark != 0){
            // 将数字 n 的二进制表达式中每一位数字依次与 1 进行与运算
            if((n &amp; mark) != 0){ // 如果结果不为0，表示此位为 1
                count ++;
            }
            // 掩码左移，让前一位对应的数字与 1 进行与运算
            mark &lt;&lt;= 1;
        }
        return count;
    }
}
</code></pre>
<h3 id="复杂度分析">复杂度分析</h3>
<ul>
<li>T = O(m)<br>
遍历每一位二进制位，所以时间复杂度为 O(m)，m 为二进制位数的个数</li>
<li>S = O(1)<br>
没有使用额外的空间，所以空间复杂度为 O(1)</li>
</ul>
<h2 id="方法二">方法二</h2>
<h3 id="实例分析-2">实例分析</h3>
<p>输入：00000000000000000000000000001011<br>
输出：3<br>
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。</p>
<pre><code>n = 1011
n-1 = 1010
n &amp; n-1 = 1010
</code></pre>
<p>也就是说，对于整数 n ，n &amp; (n-1) 的效果是把 n 的二进制表示中最低位的 1 消除，有了这个特性，我们就只需不断去检查 n 是否为 0，不为 0 时，计数器 + 1，然后把它最低位的 1 消除，这样循环操作后，n 最后一定会变成 0，而计数器中保存的则是整数 n 二进制表示中 1 的个数 。<br>
<img src="https://epitomm.github.io/post-images/leetcode191_5.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/leetcode191_6.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/leetcode191_7.png" alt="图片" loading="lazy"></p>
<h3 id="代码-2">代码</h3>
<pre><code>public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int count = 0;
        while(n!= 0){
            ++count;
            n = n &amp; (n-1);
        }
        return count;
    }
}
</code></pre>
<h3 id="复杂度">复杂度</h3>
<ul>
<li>T：O(k)<br>
k 表示整数二进制表示中 1 的个数</li>
<li>S：O(1)</li>
</ul>
<h2 id="来源">来源</h2>
<p>来源：力扣（LeetCode）<br>
链接：<a href="https://leetcode-cn.com/problems/number-of-1-bits">https://leetcode-cn.com/problems/number-of-1-bits</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis 哨兵]]></title>
        <id>https://epitomm.github.io/post/redis-shao-bing/</id>
        <link href="https://epitomm.github.io/post/redis-shao-bing/">
        </link>
        <updated>2020-04-13T04:48:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="哨兵简介">哨兵简介</h1>
<h2 id="主机宕机">主机“宕机”</h2>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E4%B8%BB%E6%9C%BA%E5%AE%95%E6%9C%BA.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>master 宕机，需要选取一个 slave 作为 master</p>
</blockquote>
<ul>
<li>将宕机的 master 下线</li>
<li>找一个slave作为master</li>
<li>通知所有的 slave 连接新的 master</li>
<li>启动新的master与slave</li>
<li>全量复制<em>N+部分复制</em>N</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E5%93%A8%E5%85%B5.png" alt="图片" loading="lazy"></figure>
<ul>
<li>谁来确认 master 宕机了</li>
<li>找一个主？怎么找法？</li>
<li>修改配置后，原始的主恢复了怎么办？</li>
</ul>
<h2 id="哨兵">哨兵</h2>
<p>哨兵(sentinel) 是一个<strong>分布式系统</strong>，用于对主从结构中的每台服务器进行<strong>监控</strong>，当出现故障时通过<strong>投票</strong>机制选择新的 master并将所有slave连接到新的master。</p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%93%A8%E5%85%B5.png" alt="图片" loading="lazy"></figure>
<h2 id="哨兵的作用">哨兵的作用</h2>
<ul>
<li>监控
<ul>
<li>不断的检查master和slave是否正常运行。</li>
<li>master存活检测、master与slave运行情况检测</li>
</ul>
</li>
<li>通知（提醒）
<ul>
<li>当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知。</li>
</ul>
</li>
<li>自动故障转移
<ul>
<li>断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址</li>
</ul>
</li>
</ul>
<p>注意：</p>
<p>哨兵也是一台<strong>redis服务器</strong>，只是不提供数据服务</p>
<p>通常哨兵配置数量为<strong>单数</strong></p>
<h1 id="启用哨兵模式">启用哨兵模式</h1>
<h2 id="配置哨兵">配置哨兵</h2>
<p>清空 data 下数据</p>
<pre><code>[root@iZ2ze4u2bufi0915gyi843Z data]# rm -rf *
</code></pre>
<ul>
<li>配置一拖二的主从结构</li>
</ul>
<h3 id="1-一个-master">1. 一个 master</h3>
<p>（1）配置文件</p>
<pre><code>[root@iZ2ze4u2bufi0915gyi843Z conf]# vim redis-6379.conf 
port 6379
daemonize no
#logfile &quot;6379.log&quot;
dir /root/redis-5.0.7/data
dbfilename dump-6379.rdb
rdbcompression yes 
rdbchecksum yes 
appendonly yes
appendfsync everysec
appendfilename appendonly-6379.aof
bind 127.0.0.1
databases 16
</code></pre>
<p>（2）启动master:6379 redis 服务</p>
<pre><code>[root@iZ2ze4u2bufi0915gyi843Z conf]# redis-server redis-6379.conf
</code></pre>
<h3 id="2-两个-slave">2. 两个 slave</h3>
<p>（1）配置文件</p>
<pre><code>[root@iZ2ze4u2bufi0915gyi843Z conf]# vim redis-6380.conf 
port 6380
daemonize no
#logfile &quot;6379.log&quot;
dir &quot;/root/redis-5.0.7/data&quot;
replicaof 127.0.0.1 6379
[root@iZ2ze4u2bufi0915gyi843Z conf]# vim redis-6381.conf 
port 6381
daemonize no
#logfile &quot;6379.log&quot;
dir &quot;/root/redis-5.0.7/data&quot;
</code></pre>
<p>（2）启动 slave:6380、slave:6381 服务</p>
<pre><code>[root@iZ2ze4u2bufi0915gyi843Z conf]# redis-server redis-6380.conf
</code></pre>
<pre><code>[root@iZ2ze4u2bufi0915gyi843Z conf]# redis-server redis-6381.conf
</code></pre>
<h3 id="配置三个哨兵配置相同端口不同">配置三个哨兵（配置相同，端口不同）</h3>
<ul>
<li>参看sentinel.conf</li>
</ul>
<p>（1）查看 sentinel.conf 配置文件</p>
<pre><code>[root@iZ2ze4u2bufi0915gyi843Z redis-5.0.7]# cat sentinel.conf | grep -v &quot;#&quot; | grep -v &quot;^$&quot; // 过滤到注释和空行
port 26379
daemonize no
pidfile /var/run/redis-sentinel.pid
logfile &quot;&quot;
dir /tmp
sentinel monitor mymaster 127.0.0.1 6379 2
sentinel down-after-milliseconds mymaster 30000
sentinel parallel-syncs mymaster 1
sentinel failover-timeout mymaster 180000
sentinel deny-scripts-reconfig yes
</code></pre>
<p><img src="https://epitomm.github.io/post-images/sentinel.conf.png" alt="图片" loading="lazy"><br>
sentinel.conf</p>
<p>（2）将配置文件 复制到 redis-5.0.7/conf 目录下</p>
<pre><code>[root@iZ2ze4u2bufi0915gyi843Z redis-5.0.7]#cat sentinel.conf | grep -v &quot;#&quot; | grep -v &quot;^$&quot; &gt; ./conf/sentinel-26379.conf
</code></pre>
<p>（3）修改 sentinel-26379.conf 配置文件</p>
<pre><code>[root@iZ2ze4u2bufi0915gyi843Z conf]# vim sentinel-26379.conf 
port 26379
daemonize no
dir /root/redis-5.0.7/data
sentinel monitor mymaster 127.0.0.1 6379 2
sentinel down-after-milliseconds mymaster 30000
sentinel parallel-syncs mymaster 1
sentinel failover-timeout mymaster 180000
sentinel deny-scripts-reconfig yes
</code></pre>
<p>（4）复制生成 sentinel-26380.conf、 sentinel-26381.conf 两个配置文件</p>
<pre><code>[root@iZ2ze4u2bufi0915gyi843Z conf]# sed 's/26379/26380/g' sentinel-26379.conf &gt; sentinel-26380.conf
[root@iZ2ze4u2bufi0915gyi843Z conf]# sed 's/26379/26381/g' sentinel-26379.conf &gt; sentinel-26381.conf
</code></pre>
<h2 id="启动哨兵">启动哨兵</h2>
<pre><code>redis-sentinel sentinel-端口号.conf
</code></pre>
<p>启动三个哨兵：</p>
<pre><code>redis-sentinel sentinel-26379.conf

redis-sentinel sentinel-26380.conf

redis-sentinel sentinel-26381.conf
</code></pre>
<p>当 master:6379 下线后，哨兵投票选举出新的 master:6381</p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/master%E4%B8%8B%E7%BA%BF%E5%90%8E%EF%BC%8C%E5%93%A8%E5%85%B5%E6%8A%95%E7%A5%A8%E9%80%89%E4%B8%BE%E6%96%B0%E7%9A%84master.png" alt="图片" loading="lazy"></figure>
<p>master 下线后，哨兵投票选举新的 master</p>
<h2 id="配置哨兵-2">配置哨兵</h2>
<table>
<thead>
<tr>
<th style="text-align:left">配置项</th>
<th style="text-align:center">范例</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">sentinel auth-pass    &lt;服务器名称&gt; <password></td>
<td style="text-align:center">sentinel auth-pass mymaster   itcast</td>
<td style="text-align:left">连接服务器口令</td>
</tr>
<tr>
<td style="text-align:left">sentinel down-after-milliseconds &lt;自定义服务名称&gt;&lt;主机地址&gt;&lt;端口&gt;&lt;主从服务器总量&gt;</td>
<td style="text-align:center">sentinel monitor mymaster    192.168.194.131 6381 1</td>
<td style="text-align:left">设置哨兵监听的主服务器信息，最后的参数决定了最终参与选举的服务器 数量（-1）</td>
</tr>
<tr>
<td style="text-align:left">sentinel down-after-milliseconds    &lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td>
<td style="text-align:center">sentinel down-after  milliseconds mymaster 3000</td>
<td style="text-align:left">指定哨兵在监控Redis服务时，判定服务器挂掉的时间周期，默认30秒 （30000），也是主从切换的启动条件之一</td>
</tr>
<tr>
<td style="text-align:left">sentinel parallel-syncs    &lt;服务名称&gt;&lt;服务器数（整数）&gt;</td>
<td style="text-align:center">sentinel parallel-syncs    mymaster 1</td>
<td style="text-align:left">指定同时进行主从的slave数量，数值越大，要求网络资源越高，要求越小，同步时间越长</td>
</tr>
<tr>
<td style="text-align:left">sentinel failover-timeout    &lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td>
<td style="text-align:center">sentinel failover-timeout    mymaster 9000</td>
<td style="text-align:left">指定出现故障后，故障切换的最大超时时间，超过该值，认定切换失败，默认3分钟</td>
</tr>
<tr>
<td style="text-align:left">sentinel notification-script    &lt;服务名称&gt;&lt;脚本路径&gt;</td>
<td style="text-align:center"></td>
<td style="text-align:left">服务器无法正常联通时，设定的执行脚本，通常调试使用。</td>
</tr>
</tbody>
</table>
<h1 id="哨兵工作原理">哨兵工作原理</h1>
<h2 id="主从切换">主从切换</h2>
<ul>
<li>哨兵在进行主从切换过程中经历三个阶段
<ul>
<li>监控</li>
<li>通知</li>
<li>故障转移</li>
</ul>
</li>
</ul>
<h2 id="阶段一监控阶段">阶段一：监控阶段</h2>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/%E7%9B%91%E6%8E%A7%E9%98%B6%E6%AE%B5.png" alt="图片" loading="lazy"></figure>
<ul>
<li>用于同步各个节点的状态信息
<ul>
<li>获取各个sentinel的状态（是否在线）</li>
<li>获取master的状态
<ul>
<li>master属性
<ul>
<li>runid</li>
<li>role：master</li>
</ul>
</li>
<li>各个slave的详细信息</li>
</ul>
</li>
<li>获取所有slave的状态（根据master中的slave信息）
<ul>
<li>slave属性
<ul>
<li>runid</li>
<li>role：slave</li>
<li>master_host、master_port</li>
<li>offset</li>
<li>......</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E7%9B%91%E6%8E%A7%E9%98%B6%E6%AE%B52.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>① 第一个哨兵进去的时候，只有 master 和 slave 可以连，哨兵先<strong>连接 master</strong>，发送 info 指令。<br>
② 为了方便后期 master 和 sentinel 命令交换，<strong>建立了一个 cmd 连接</strong>，专门用于发送命令。<br>
在这个过程中，保存了所有哨兵状态 SentinelState，在哨兵端把所有信息进行记录；在 master 端记录 redis 实例对应信息：SentinelRedisInstance<br>
③ sentinel 根据从 master 获取的 slaves 信息<strong>去与每一个 slave 进行连接</strong>，发送 info 命令。<br>
④ 下一个 sentinel 进入，<strong>发送 info 命令连接 master</strong>，发现 master 端的 SentinelRedisInstance 中的 sentinels 有信息，知道了在它之前有对应的 sentinel 与master 建立了连接。<br>
⑤ sentinel <strong>与 master 建立 cmd 连接</strong>。<br>
在 sentinel 端创建 SentinelState（包含两个 sentinel 节点信息）。<br>
为了保证两个 sentinel 信息同步，在两个 sentinel 之间建立沟通的桥梁进行发布订阅，向这个通道发送信息大家可以互联，为了保证连接，两个 sentinel 还会互相发送 ping 命令看对方是不是还在<br>
⑥ sentinel 与 slave 连接</p>
</blockquote>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E7%9B%91%E6%8E%A7%E9%98%B6%E6%AE%B53.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>当第三个节点进来时，除了连接 master 和 slaves，还需要与现存的 sentinel 进行连接，此时三个 sentinel 组成了一个小的网络，彼此间交换信息，在这个网络中：哪个哨兵拿到信息，快速扩散给大家，由于每个 sentinel 之间都是信任的，一旦有一个 sentinel 发送信息，其他哨兵接收，发现和自己的信息不一致，就更新掉。</p>
</blockquote>
<p>监控阶段的信息获取：sentinel 会向 master、slave、其他的 sentinel 要状态，sentinel 之间会组建对应的频道，大家在这里发布、订阅、同步信息。</p>
<h2 id="阶段二通知阶段">阶段二：通知阶段</h2>
<p>信息的长期维护阶段</p>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/%E9%80%9A%E7%9F%A5%E9%98%B6%E6%AE%B5.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>三个 sentinel 组成了一个小群体，它们之间进行信息互通，提供数据的 master 和 slave 正常工作，sentinel 会通过 cmd 连接获取它们对应的工作状态，通过发布 hello 信息来获取，无论是哪个 sentinel 拿到结果，都会在 sentinel 内部网络进行信息互通，告诉其他 sentinel。</p>
</blockquote>
<h2 id="阶段三故障转移阶段">阶段三：故障转移阶段</h2>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E9%98%B6%E6%AE%B5.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>① sentinel 向 master 发送 hello 指令，master 没有回复，sentinel 就不停给 master 发送 hello，发送了到了一定阶段后，sentinel 认为 master 掉线了，给 master 标记为 S_DOWN 状态。<br>
② sentinel1 把这个信息传递到内网中。如果是某个 sentinel 断了导致无法和 master 建立连接，该 sentinel 把 master 状态标记为 S_DOWN，并把信息发送到内网时，发送失败（此 sentinel 断线了）。<br>
③ 当内网中的其他 sentinel 接收到 master 挂掉的信息后，于是去围观不停地给 master 发送 hello，仍然没有回复，该 master 果然掉线了。<br>
④ 于是把它们接收到的结果信息也传送到内网中确认 sentinel1 说的对，master 果然挂了。<br>
⑤ 此时所有 sentinel 都认为 master 挂了，master 端的状态信息更改为：O_DOWN。事实上，只要半数以上的 sentinel 认为 master 挂了，状态就标记为 O_DOWN，不必要等所有 sentinel 都确认。</p>
</blockquote>
<p>主观下线：一个 sentinel 认为 master 挂了。</p>
<p>客观下线：半数以上 sentinel 认为 master 挂了。</p>
<h3 id="1-投票选举-sentinel-代表">1. 投票选举 sentinel 代表</h3>
<p>客观下线后，进入下一环节：开始清理队伍。清理队伍前，需选出一个 sentinel 作为代表去清理。</p>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/%E6%8A%95%E7%A5%A8%E9%80%89%E4%B8%BE%E5%93%A8%E5%85%B5%E4%BB%A3%E8%A1%A8.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>所有 sentinel 同时发送指令表示我要作为代表去清理队伍。<br>
发送的指令中携带以下信息：</p>
<ol>
<li>挂的 ip</li>
<li>挂的端口</li>
<li>竞选次数（我在这方面处理的经验：参与竞选的次数）</li>
<li>自己的 runid</li>
</ol>
</blockquote>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/%E5%93%A8%E5%85%B5%E6%8A%95%E7%A5%A82.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>那么到底应该选哪一个呢？<br>
投票机制<br>
每一个 sentinel 作为参选者，同时也是投票者，每人有一票，当 sentinel1 和 sentinel4 同时把信息发送到微信群中时，sentinel2 先接收到谁的就把票投给谁。</p>
</blockquote>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/%E5%93%A8%E5%85%B5%E6%8A%95%E7%A5%A83.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>所有信息沟通完毕会得到一个投票结果，假如有一个 sentinel 获得超过半数以上的票，就当选，如果没有得到这样的一个结果，就重新投一轮，每增加一轮，竞选次数+1.</p>
</blockquote>
<h3 id="2-sentinel-代表从备选-slave-中选择一个当-master">2. sentinel 代表从备选 slave 中选择一个当 master</h3>
<ul>
<li>服务器列表中挑选备选master
<ul>
<li>在线的</li>
<li>响应慢的</li>
<li>与原master断开时间久的</li>
<li>优先原则
<ul>
<li>优先级</li>
<li>offset</li>
<li>runid</li>
</ul>
</li>
</ul>
</li>
<li>发送指令（ sentinel ）
<ul>
<li>向新的master发送slaveof no one</li>
<li>向其他slave发送slaveof 新masterIP端口</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93.png" alt="图片" loading="lazy"></figure>
<h3 id="主从切换过程总结">主从切换过程总结</h3>
<ul>
<li>监控
<ul>
<li>同步信息</li>
</ul>
</li>
<li>通知
<ul>
<li>保持联通</li>
</ul>
</li>
<li>故障转移
<ul>
<li>发现问题</li>
<li>竞选负责人</li>
<li>优选新master</li>
<li>新master上任，其他slave切换master，原master作为slave故障恢复后连接</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B%E6%97%A5%E5%BF%97.png" alt="图片" loading="lazy"></figure>
<p>主从切换过程日志信息</p>
<h1 id="总结">总结</h1>
<p><strong>哨兵模式</strong></p>
<ul>
<li>什么是哨兵 （监控整体工作过程）</li>
<li>哨兵模式搭建</li>
<li>哨兵工作原理
<ul>
<li>监控</li>
<li>通知</li>
<li>故障转移</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[dubbo]]></title>
        <id>https://epitomm.github.io/post/dubbo/</id>
        <link href="https://epitomm.github.io/post/dubbo/">
        </link>
        <updated>2020-04-10T14:34:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-基础知识">一、基础知识</h1>
<h2 id="1-分布式基础理论">1、分布式基础理论</h2>
<h3 id="11-什么是分布式系统">1.1）、什么是分布式系统？</h3>
<p>《分布式系统原理与范型》定义：</p>
<p>“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”</p>
<p>分布式系统（distributed system）是建立在网络之上的软件系统。</p>
<p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需<strong>一个治理系统</strong>确保架构有条不紊的演进。</p>
<h3 id="12-发展演变">1.2）、发展演变</h3>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E6%BC%94%E5%8F%98.png" alt="图片" loading="lazy"></figure>
<p><em>单一应用架构</em></p>
<p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。<br>
<img src="https://epitomm.github.io/post-images/%E5%8D%95%E4%B8%80%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84.png" alt="图片" loading="lazy"></p>
<pre><code>适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。

缺点： 1、性能扩展比较难 （如果修改或添加某个功能，都需要把整个应用重新打包，重新放部署到 服务器）

       2、协同开发问题（所有人都去修改一个应用，容易乱）

       3、不利于升级维护
</code></pre>
<blockquote>
<p>将多个功能放到一个应用内，打包后放到服务器上即可。访问量增大，一个服务器无法承受时，再添加一个服务器同时跑这个应用。</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E5%8D%95%E4%B8%80%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%842.png" alt="图片" loading="lazy"></figure>
<p><em>垂直应用架构</em></p>
<p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E5%9E%82%E7%9B%B4%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84.png" alt="图片" loading="lazy"></figure>
<pre><code>通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。

缺点： 公用模块无法重复利用，开发性的浪费
</code></pre>
<blockquote>
<p>将一个大应用拆分成几个独立的小应用，每一个应用都是从头到尾完成的（从页面到业务逻辑程序到数据库）。</p>
</blockquote>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E5%9E%82%E7%9B%B4%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%842.png" alt="图片" loading="lazy"></figure>
<p>垂直应用架构</p>
<blockquote>
<p>当某一块应用的访问量比较大时，将这个应用多扩展几个服务器。</p>
</blockquote>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/%E5%9E%82%E7%9B%B4%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%843.png" alt="图片" loading="lazy"></figure>
<p>扩展某个小应用即可</p>
<blockquote>
<p>好处：1）分工合作容易，每个人负责开发维护不同的应用，互不干扰。<br>
2）性能扩展容易，比如“用户”应用的访问量增大， 就把它多放几台服务器，扩展的是某个小应用，其他小应用无需变动。<br>
缺点：1）由于每个小应用都是完整的（界面+业务逻辑+数据库），但是界面要求经常变化，每个界面的变化都会导致应用的重新部署。无法做到页面 和 业务逻辑 的分离<br>
2） 随着应用的逐步增多，垂直应用会越来越多，这样的情况下，不可能理想的应用和应用之间互相独立，订单模块需要用户模块和商品模块信息，应用之间交互，不可能完全独立。</p>
</blockquote>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E5%9E%82%E7%9B%B4%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%844.png" alt="图片" loading="lazy"></figure>
<p>界面与业务逻辑无法分离，各个应用间需要交互</p>
<p><em>分布式服务架构</em></p>
<p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的<strong>分布式服务框架(RPC)是关键</strong>。</p>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%841.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>将用户抽取成“用户界面” 和 “用户业务”，订单抽取成 “订单界面” 和 “订单业务” 等。<br>
当业务逻辑不变的情况下，如果只想修改界面，重启界面服务器即可，核心业务逻辑还在其他服务器上，无需变动。<br>
<img src="https://epitomm.github.io/post-images/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%842.png" alt="图片" loading="lazy"></p>
</blockquote>
<blockquote>
<p>用户界面放在 A 服务器上，用户业务放在 B 服务器上，订单业务放在 C 服务器上，如果 A 服务器（用户界面）需要调用 B 服务器（用户业务）的功能。如果写在一个应用内，A 调用 B，直接“方法 A . 方法 B” 即可，直接调用，进程类通讯，都在一个服务器上，都是同一个 tomcat，同一个进程类通讯。但如果是分布式服务架构，A 和 B 在两台服务器上，这样的不同服务器间的互相调用称为 RPC（远程过程调用）。分布式服务架构的难点：如何进行远程过程调用，如果拆分应用，提升业务的复用程度。<br>
随着业务的不断增多，分拆的业务越来越多，成千上万的服务器在跑不同的服务，出现的资源浪费问题愈加严重，比如用户业务访问量较小，但却有 100 台服务器在跑，就造成了浪费；而 商品业务 访问量很大，但却只有 10 台服务器在跑。应该有一个基于访问压力的调度中心能够实时监控数据动态调度，提高资源利用率，让更多的服务器去跑业务量更大的业务。</p>
</blockquote>
<p><em>流动计算架构</em></p>
<p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于<strong>提高机器利用率的资源调度和治理中心(SOA)[ Service Oriented Architecture]是关键</strong>。</p>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/%E6%B5%81%E5%8A%A8%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>采用流动计算架构，引入调度中心，负责维护服务间的复杂关系，实时管理集群，比如 A 服务器访问量大了，给 A 多增加几台服务器，假设 第一台 有 100 个请求，第二台 有 2 个请求，第三台有 10000 个请求，那么下次请求进来，就应该找比较闲的第二台服务器来处理请求，以此提高整个集群利用率。</p>
</blockquote>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/%E6%B5%81%E5%8A%A8%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%842.png" alt="图片" loading="lazy"></figure>
<p>流动计算架构</p>
<h3 id="13-rpc">1.3）、RPC</h3>
<p><em>什么叫RPC</em></p>
<p>RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</p>
<p><em>RPC基本原理</em></p>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/RPC%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>需求：A 服务器客户端（client）有一个小功能，想要调用 B 服务器的一个小功能。<br>
实现：A 服务器客户端（client）先找一个小助手（client stub），这个小助手一看，A 服务器想要调用 B 服务器上的功能，先跟 B 服务器在网络上建立一个 sockets 连接，将要调用 B 的一些信息（比如要调用 B 的某个方法的方法名、参数）传递给 B 模型，B 服务器上的小助手（server stub）收到这些信息，知道了 A 服务器想要调用 我的一个方法，执行这个方法后，将返回值依次传回 A 客户端。</p>
</blockquote>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/RPC%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%862.png" alt="图片" loading="lazy"></figure>
<p>RPC两个核心模块：通讯，序列化。</p>
<p>RPC 框架有很多如：dubbo、gRPC、Thrift、HSF(High Speed Service Framework)</p>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/RPC%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%863.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>A 服务器上有一个 hello()方法，想要调用 B 服务器上的 hi() 方法，同时传入一个 User  对象，B 服务器上的 hi() 方法执行完了以后，返回一个 String 给 A 服务器，A服务器调完 B服务器的方法后，收到 B 服务器的返回值并在控制台打印。<br>
调用过程：A 服务器客户端（Client） 想要 调用 B 服务器的代码，A 服务器上有一个小助手（Client Stub）这个小助手一看 A 服务器 要调用 B 服务器，先与 B 服务器建议连接，建立连接后，由于调用方法要传递参数，这个参数要发给 B 服务器，参数对象要在网络间传递需要先序列化 ，序列化后将要调用的信息传递给 B 服务器的小助手（Server Stub），B 服务器的小助手收到信息，一看有来自外界的 A 服务器想要调用我的 hi() 方法，同时还传递来了一个参数值，由于是序列化传递过来的，如果使用则需反序列化成对象，B服务器上的小助手调用 B 服务器上的方法，拿到反序列化的对象、一些属性值，方法调用完就会有一个返回值，返回值过来要在网络间传递数据，将返回的 String 对象序列化传递给 A 服务器的小助手，Client Stub 收到后再反序列化，输出。<br>
整个过程两个核心：建立连接、传递数据（序列化和反序列化）。所以，影响一个 RPC 框架性能的重要两点：能否快速地在各个服务器间建立连接；序列化/反序列化机制的速度。</p>
</blockquote>
<h2 id="2-dubbo核心概念">2、dubbo核心概念</h2>
<h3 id="21-简介">2.1）、简介</h3>
<p>Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p>
<p>官网：</p>
<p><a href="http://dubbo.apache.org/zh-cn/">http://dubbo.apache.org/zh-cn/</a></p>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/dubbo%E7%89%B9%E6%80%A7.png" alt="图片" loading="lazy"></figure>
<ol>
<li><strong>面向接口代理的高性能 RPC 调用</strong></li>
</ol>
<p>使用 dubbo 时，A 服务器 要调用 B 服务器上的代码，只需将 B 功能方法的接口 InterfaceB拿过来，调用接口所在的方法 InterfaceB.fun()，就会自动去找服务器 B 上的代码代码调用，屏蔽了远程的调用细节。类似在用 Mybatis ，操作数据库时，只需要写一个 mapper 接口，调用接口的方法即可。</p>
<ol start="2">
<li><strong>智能负载均衡</strong></li>
</ol>
<p>比如用户业务访问量很大，就需要多放几台服务器，“用户界面” 想要调用 “用户业务” 的功能，调用 “用户业务” 的哪一台服务器都可以，假设 第一台用户业务服务器当前有 100 个请求， 第二台用户业务服务器当前有 2 个请求， 第三台用户业务服务器当前有 1000 个请求， 第四台用户业务服务器当前有 10 个请求，就应该找一个非常空闲的服务器快速处理这次响应，这个机制就叫做<strong>负载均衡</strong>，让每个服务器都有一个很均衡的负载，不要让某一台服务器做太多的响应，把它压垮，也不要让某一台服务器太闲，资源浪费。</p>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/%E6%99%BA%E8%83%BD%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png" alt="图片" loading="lazy"></figure>
<ol start="3">
<li><strong>服务自动注册与发现</strong></li>
</ol>
<p>想象这样一个场景：业务非常多，每一块的访问量都特别大，比如用户业务在 1、2、3、4 号服务器都有，支付业务在 9、11、13 号服务器都有，那么 订单web 想要调用支付业务，RPC 框架爱如何知道支付业务都在哪些服务器上呢？如果 11 号服务器出问题了，框架如何自动地知道这个事呢？引入<strong>注册中心</strong>机制。</p>
<p>为了能动态感知到每一个服务，可以将所有的服务都注册到注册中心，包括前端程序也可以都注册到注册中心内，注册中心相当于维护了一个 “业务 - 服务器” 清单，比如：用户业务：1、2、3、4 号服务器，如果 2 号服务器出问题了，就把它从清单中删掉。如果 订单web 要调用支付业务，先到注册中心的清单内找支付业务都在哪一台服务器上，然后随机选择或者选择请求量最少的一台服务器进行访问。</p>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.png" alt="图片" loading="lazy"></figure>
<ol start="4">
<li><strong>高度可扩展</strong></li>
</ol>
<p>微内核 + 插件</p>
<ol start="5">
<li><strong>运行期流量调度</strong></li>
</ol>
<p>内置条件、脚本等路由策略，通过配置不同的路由规则，轻松实现<strong>灰度发布</strong>，同机房优先等功能。</p>
<p>灰度发布：一个用户服务在 100 台服务器上跑，用户服务做了开发升级，先选定 20 台服务器，让它们先用新版本的服务，剩下的 80 台使用旧版本的服务，等这 20 台用着都没问题了，再选 20 台，这样逐步过渡，直到 100 台全用到新的用户服务。配置不同的路由规则，请求进来后，让一部分请求用新升级的服务，剩下的来用旧的服务，通过这种方式从旧服务转化成新服务的过程就叫做<strong>灰度发布</strong>。</p>
<ol start="6">
<li><strong>可视化的服务治理和运维</strong></li>
</ol>
<p>通过可视化的 WEB 界面动态查询服务的信息、调整一些参数。</p>
<h3 id="22-基本概念">2.2）、基本概念</h3>
<figure data-type="image" tabindex="16"><img src="https://epitomm.github.io/post-images/dubbo%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.png" alt="图片" loading="lazy"></figure>
<p><strong>服务提供者（Provider）</strong>：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</p>
<p><strong>服务消费者（Consumer）</strong>: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>
<p><strong>注册中心（Registry）</strong>：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</p>
<p><strong>监控中心（Monitor）</strong>：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p>
<p><strong>框架容器（Container</strong>）</p>
<ul>
<li>调用关系说明
<ul>
<li>服务容器负责启动，加载，运行服务提供者。</li>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。<br>
<img src="https://epitomm.github.io/post-images/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.png" alt="图片" loading="lazy"></li>
</ul>
</li>
</ul>
<p>用户业务是实际的业务功能，web 界面要去调用这些业务功能，所以，用户业务是一个服务提供者（Provider），而 web 界面是服务消费者（Consumer）</p>
<blockquote>
<p>运行流程：容器 Container 启动，初始化 init ，服务提供者 Provider 将自己提供的信息注册 register 到注册中心 Registry ，注册中心就知道有哪些服务上线了，当服务消费者 Consumer 启动，从注册中心订阅 subscribe 自己所需要的服务，如果服务提供者发生变更（3 号服务器下线了），注册中心将这次变更推送 notify 给消费者，消费者拿到所有它能调用的服务，调用的时候可以同步调用 invoke 服务提供者提供的服务，如果消费者要调用的服务有多台服务器在提供，消费者根据负载均衡算法选择一个进行调用。每次的调用信息会定时地每隔一分钟将信息发送到监控中心 Monitor，监控中心就能监控到服务的状态。<br>
0、1、2 这三步是在初始化、启动应用时完成的。<br>
3、5 是异步过程，<br>
4 服务消费者调用服务提供者提供的功能是一个同步的调用。<br>
了解了 dubbo 框架，在编写 dubbo 应用时：</p>
<ol>
<li>先写一个服务提供者，将服务提供者提供的服务注册到注册中心；</li>
<li>编写一个服务消费者，消费者从注册中心订阅提供者提供的服务；</li>
<li>测试消费者如何调用提供者提供的功能。</li>
</ol>
</blockquote>
<h2 id="3-dubbo环境搭建">3、dubbo环境搭建</h2>
<h3 id="31-windows-安装zookeeper">3.1）、【windows】-安装zookeeper</h3>
<table>
<thead>
<tr>
<th style="text-align:center">1、下载zookeeper网址 <a href="https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/">https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/</a></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2、解压zookeeper解压运行zkServer.cmd ，初次运行会报错，没有zoo.cfg配置文件</td>
</tr>
<tr>
<td style="text-align:center">3、修改zoo.cfg配置文件将conf下的zoo_sample.cfg复制一份改名为zoo.cfg即可。注意几个重要位置：dataDir=./   临时数据存储的目录（可写相对路径）clientPort=2181   zookeeper的端口号修改完成后再次启动zookeeper</td>
</tr>
<tr>
<td style="text-align:center">4、使用zkCli.cmd测试ls /：列出zookeeper根下保存的所有节点create –e /atguigu 123：创建一个atguigu节点，值为123get /atguigu：获取/atguigu节点的值</td>
</tr>
</tbody>
</table>
<p>注：记录一个小 bug</p>
<p>问题：【zookeeper】报错-Dzookeeper.log.dir=xxx&quot;' 不是内部或外部命令，也不是可运行的程序 或批处理文件的解决</p>
<p>解决：修改zkServer.cmd文件。将 call %JAVA% 改成 java</p>
<pre><code>java &quot;-Dzookeeper.log.dir=%ZOO_LOG_DIR%&quot; &quot;-Dzookeeper.root.logger=%ZOO_LOG4J_PROP%&quot; -cp &quot;%CLASSPATH%&quot; %ZOOMAIN% &quot;%ZOOCFG%&quot; %*
</code></pre>
<p>参考博客：<a href="https://blog.csdn.net/pangdongh/article/details/90208230">https://blog.csdn.net/pangdongh/article/details/90208230</a></p>
<h3 id="32-windows-安装dubbo-admin管理控制台">3.2）、【windows】-安装dubbo-admin管理控制台</h3>
<p>dubbo本身并不是一个服务软件。它其实就是一个jar包能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。所以你不用在Linux上启动什么dubbo服务。</p>
<p>但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序，不过这个监控即使不装也不影响使用。</p>
<p>1、下载dubbo-admin</p>
<p><a href="https://github.com/apache/incubator-dubbo-ops">https://github.com/apache/incubator-dubbo-ops</a></p>
<figure data-type="image" tabindex="17"><img src="https://epitomm.github.io/post-images/dubbo-admin%E4%B8%8B%E8%BD%BD.png" alt="图片" loading="lazy"></figure>
<p>2、进入目录，修改dubbo-admin配置</p>
<p>修改 src\main\resources\application.properties 指定zookeeper地址</p>
<figure data-type="image" tabindex="18"><img src="https://epitomm.github.io/post-images/dubbo-admin%E9%85%8D%E7%BD%AE.png" alt="图片" loading="lazy"></figure>
<p>3、打包dubbo-admin</p>
<pre><code>mvn clean package -Dmaven.test.skip=true 
</code></pre>
<p>4、运行dubbo-admin</p>
<pre><code>java -jar dubbo-admin-0.0.1-SNAPSHOT.jar
</code></pre>
<p><strong>注意：【有可能控制台看着启动了，但是网页打不开，需要在控制台按下ctrl+c即可】</strong></p>
<p>默认使用root/root 登陆</p>
<figure data-type="image" tabindex="19"><img src="https://epitomm.github.io/post-images/%E8%BF%90%E8%A1%8Cdubbo-admin.png" alt="图片" loading="lazy"></figure>
<h3 id="33-linux-安装zookeeper">3.3）、【linux】-安装zookeeper</h3>
<p><em>1、安装jdk</em></p>
<p>1、下载jdk</p>
<p><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p>
<figure data-type="image" tabindex="20"><img src="https://epitomm.github.io/post-images/%E4%B8%8B%E8%BD%BDjdk.png" alt="图片" loading="lazy"></figure>
<p>不要使用wget命令获取jdk链接，这是默认不同意，导致下载来的jdk压缩内容错误</p>
<p>2、上传到服务器并解压</p>
<figure data-type="image" tabindex="21"><img src="https://epitomm.github.io/post-images/jdk%E8%A7%A3%E5%8E%8B.png" alt="图片" loading="lazy"></figure>
<p>3、设置环境变量</p>
<pre><code>/usr/local/java/jdk1.8.0_171
</code></pre>
<figure data-type="image" tabindex="22"><img src="https://epitomm.github.io/post-images/%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" alt="图片" loading="lazy"></figure>
<p>文件末尾加入下面配置</p>
<pre><code>export JAVA_HOME=/usr/local/java/jdk1.8.0_171

export JRE_HOME=${JAVA_HOME}/jre

export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib

export PATH=${JAVA_HOME}/bin:$PATH
</code></pre>
<figure data-type="image" tabindex="23"><img src="https://epitomm.github.io/post-images/jdk%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F2.png" alt="图片" loading="lazy"></figure>
<p>4、使环境变量生效&amp;测试JDK</p>
<figure data-type="image" tabindex="24"><img src="https://epitomm.github.io/post-images/jdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%94%9F%E6%95%88.png" alt="图片" loading="lazy"></figure>
<p><em>2、安装zookeeper</em></p>
<p>1、下载zookeeper</p>
<p>网址 <a href="https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/">https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/</a></p>
<p>wget <a href="https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/zookeeper-3.4.11.tar.gz">https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/zookeeper-3.4.11.tar.gz</a></p>
<p>2、解压</p>
<figure data-type="image" tabindex="25"><img src="https://epitomm.github.io/post-images/%E8%A7%A3%E5%8E%8Bzk.png" alt="图片" loading="lazy"></figure>
<p>3、移动到指定位置并改名为zookeeper</p>
<figure data-type="image" tabindex="26"><img src="https://epitomm.github.io/post-images/zk%E7%A7%BB%E5%8A%A8%E5%91%BD%E5%90%8D.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="27"><img src="https://epitomm.github.io/post-images/zk%E6%9F%A5%E7%9C%8B%E7%9B%AE%E5%BD%95.png" alt="图片" loading="lazy"></figure>
<p><em>3、开机启动zookeeper</em></p>
<p>1）-复制如下脚本</p>
<pre><code>#!/bin/bash

#chkconfig:2345 20 90

#description:zookeeper

#processname:zookeeper

ZK_PATH=/usr/local/zookeeper

export JAVA_HOME=/usr/local/java/jdk1.8.0_171

case $1 in

         start) sh  $ZK_PATH/bin/zkServer.sh start;;

         stop)  sh  $ZK_PATH/bin/zkServer.sh stop;;

         status) sh  $ZK_PATH/bin/zkServer.sh status;;

         restart) sh $ZK_PATH/bin/zkServer.sh restart;;

         *)  echo &quot;require start|stop|status|restart&quot;  ;;

esac
</code></pre>
<figure data-type="image" tabindex="28"><img src="https://epitomm.github.io/post-images/%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8zk.png" alt="图片" loading="lazy"></figure>
<p>2）-把脚本注册为Service</p>
<figure data-type="image" tabindex="29"><img src="https://epitomm.github.io/post-images/%E8%84%9A%E6%9C%AC%E6%B3%A8%E5%86%8C%E4%B8%BAservice.png" alt="图片" loading="lazy"></figure>
<p>3）-增加权限</p>
<figure data-type="image" tabindex="30"><img src="https://epitomm.github.io/post-images/%E5%A2%9E%E5%8A%A0%E6%9D%83%E9%99%90.png" alt="图片" loading="lazy"></figure>
<p><em>4、配置zookeeper</em></p>
<p>1、初始化zookeeper配置文件</p>
<p>拷贝/usr/local/zookeeper/conf/zoo_sample.cfg</p>
<p>到同一个目录下改个名字叫zoo.cfg</p>
<figure data-type="image" tabindex="31"><img src="https://epitomm.github.io/post-images/%E5%88%9D%E5%A7%8B%E5%8C%96zk%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt="图片" loading="lazy"></figure>
<p>2、启动zookeeper</p>
<figure data-type="image" tabindex="32"><img src="https://epitomm.github.io/post-images/%E5%90%AF%E5%8A%A8zk.png" alt="图片" loading="lazy"></figure>
<h3 id="34-linux-安装dubbo-admin管理控制台">3.4）、【linux】-安装dubbo-admin管理控制台</h3>
<p><em>1、安装Tomcat8（旧版dubbo-admin是war，新版是jar不需要安装Tomcat）</em></p>
<p>1、下载Tomcat8并解压</p>
<p><a href="https://tomcat.apache.org/download-80.cgi">https://tomcat.apache.org/download-80.cgi</a></p>
<p>wget <a href="http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v8.5.32/bin/apache-tomcat-8.5.32.tar.gz">http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v8.5.32/bin/apache-tomcat-8.5.32.tar.gz</a></p>
<p>2、解压移动到指定位置</p>
<figure data-type="image" tabindex="33"><img src="https://epitomm.github.io/post-images/%E8%A7%A3%E5%8E%8Btomcat.png" alt="图片" loading="lazy"></figure>
<p>3、开机启动tomcat8</p>
<figure data-type="image" tabindex="34"><img src="https://epitomm.github.io/post-images/%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8tomcat.png" alt="图片" loading="lazy"></figure>
<p>复制如下脚本</p>
<pre><code>#!/bin/bash

#chkconfig:2345 21 90

#description:apache-tomcat-8

#processname:apache-tomcat-8

CATALANA_HOME=/opt/apache-tomcat-8.5.32

export JAVA_HOME=/opt/java/jdk1.8.0_171

case $1 in

start)

    echo &quot;Starting Tomcat...&quot;  

    $CATALANA_HOME/bin/startup.sh

    ;;

stop)

    echo &quot;Stopping Tomcat...&quot;  

    $CATALANA_HOME/bin/shutdown.sh

    ;;

restart)

    echo &quot;Stopping Tomcat...&quot;  

    $CATALANA_HOME/bin/shutdown.sh

    sleep 2

    echo  

    echo &quot;Starting Tomcat...&quot;  

    $CATALANA_HOME/bin/startup.sh

    ;;

*)

    echo &quot;Usage: tomcat {start|stop|restart}&quot;  

    ;; esac
</code></pre>
<p>4、注册服务&amp;添加权限</p>
<figure data-type="image" tabindex="35"><img src="https://uploader.shimo.im/f/sgrlw1jLRksvtDuA.png!thumbnail" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="36"><img src="https://uploader.shimo.im/f/yFBPAQA9wQcuLiLK.png!thumbnail" alt="图片" loading="lazy"></figure>
<p>5、启动服务&amp;访问tomcat测试</p>
<figure data-type="image" tabindex="37"><img src="https://uploader.shimo.im/f/PCItXvgg0c8lpyxk.png!thumbnail" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="38"><img src="https://uploader.shimo.im/f/UkCJSOTip08WixDn.png!thumbnail" alt="图片" loading="lazy"></figure>
<p><em>2、安装dubbo-admin</em></p>
<p>dubbo本身并不是一个服务软件。它其实就是一个jar包能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。所以你不用在Linux上启动什么dubbo服务。</p>
<p>但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序，不过这个监控即使不装也不影响使用。</p>
<p>1、下载dubbo-admin</p>
<p><a href="https://github.com/apache/incubator-dubbo-ops">https://github.com/apache/incubator-dubbo-ops</a></p>
<figure data-type="image" tabindex="39"><img src="https://uploader.shimo.im/f/NB3VdgOwTJUVLKd7.png!thumbnail" alt="图片" loading="lazy"></figure>
<p>2、进入目录，修改dubbo-admin配置</p>
<p>修改 src\main\resources\application.properties 指定zookeeper地址</p>
<figure data-type="image" tabindex="40"><img src="https://uploader.shimo.im/f/Ky405QqumK4BCVLb.png!thumbnail" alt="图片" loading="lazy"></figure>
<p>3、打包dubbo-admin</p>
<pre><code>mvn clean package -Dmaven.test.skip=true 
</code></pre>
<p>4、运行dubbo-admin</p>
<pre><code>java -jar dubbo-admin-0.0.1-SNAPSHOT.jar
</code></pre>
<p>默认使用root/root 登陆</p>
<figure data-type="image" tabindex="41"><img src="https://uploader.shimo.im/f/QwVB9l4fvmYkh6a2.png!thumbnail" alt="图片" loading="lazy"></figure>
<h2 id="4-dubbo-helloworld">4、dubbo-helloworld</h2>
<h3 id="41-提出需求">4.1）、提出需求</h3>
<p>某个电商系统，订单服务需要调用用户服务获取某个用户的所有地址；</p>
<p>我们现在 需要创建两个服务模块进行测试</p>
<table>
<thead>
<tr>
<th style="text-align:center">模块</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">订单服务web模块</td>
<td style="text-align:center">创建订单等</td>
</tr>
<tr>
<td style="text-align:center">用户服务service模块</td>
<td style="text-align:center">查询用户地址等</td>
</tr>
</tbody>
</table>
<p>测试预期结果：</p>
<p>订单服务web模块在A服务器，用户服务模块在B服务器，A可以远程调用B的功能。</p>
<figure data-type="image" tabindex="42"><img src="https://uploader.shimo.im/f/zu5t5nNfM7A5kcbM.png!thumbnail" alt="图片" loading="lazy"></figure>
<h3 id="42-工程架构">4.2）、工程架构</h3>
<p>根据 dubbo《服务化最佳实践》</p>
<p><em>1、分包</em></p>
<p>建议将服务接口，服务模型，服务异常等均放在 API 包中，因为服务模型及异常也是 API 的一部分，同时，这样做也符合分包原则：重用发布等价原则(REP)，共同重用原则(CRP)。</p>
<p>如果需要，也可以考虑在 API 包中放置一份 spring 的引用配置，这样使用方，只需在 spring 加载过程中引用此配置即可，配置建议放在模块的包目录下，以免冲突，如：com/alibaba/china/xxx/dubbo-reference.xml。</p>
<p><em>2、粒度</em></p>
<p>服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将面临分布式事务问题，Dubbo 暂未提供分布式事务支持。</p>
<p>服务接口建议以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。</p>
<p>不建议使用过于抽象的通用接口，如：Map query(Map)，这样的接口没有明确语义，会给后期维护带来不便。</p>
<figure data-type="image" tabindex="43"><img src="https://uploader.shimo.im/f/JGqDnycGLrAYNogH.png!thumbnail" alt="图片" loading="lazy"></figure>
<h3 id="43-创建模块">4.3）、创建模块</h3>
<p><em>1、gmall-interface：公共接口层（model，service，exception…）</em></p>
<p>作用：定义公共接口，也可以导入公共依赖</p>
<p>1、Bean模型</p>
<pre><code>public class UserAddress implements Serializable{
    private Integer id;
    private String userAddress;
    private String userId;
    private String consignee;
    private String phoneNum;
    private String isDefault;
    // getter、setter、Constructure、toString
}
</code></pre>
<p>2、Service接口<br>
UserService</p>
<pre><code>package com.atguigu.gmall.service;

import com.atguigu.gmall.bean.UserAddress;
import java.util.List;
// 用户服务
public interface UserService {
   /**
    * 按照用户id返回所有的收货地址
    * @param userId
    * @return
    */
   public List&lt;UserAddress&gt; getUserAddressList(String userId);
}
</code></pre>
<p>OrderService</p>
<pre><code>// 订单服务
public interface OrderService {
   /**
    * 初始化订单
    * @param userId
    */
   public void initOrder(String userId);
}
</code></pre>
<figure data-type="image" tabindex="44"><img src="https://uploader.shimo.im/f/wyNzvleAZIggOiT2.png!thumbnail" alt="图片" loading="lazy"></figure>
<p><em>2、gmall-user：用户模块（对用户接口的实现）</em></p>
<p>1、pom.xml</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.atguigu.gmall&lt;/groupId&gt;
        &lt;artifactId&gt;gmall-interface&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>2、Service</p>
<pre><code>public class UserServiceImpl implements UserService {
		
	@Override
	public List&lt;UserAddress&gt; getUserAddressList(String userId) {
		// TODO Auto-generated method stub
		return userAddressDao.getUserAddressById(userId);
	}
}
</code></pre>
<p><em>4、gmall-order-web：订单模块（调用用户模块）</em><br>
1、pom.xml</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.atguigu.gmall&lt;/groupId&gt;
        &lt;artifactId&gt;gmall-interface&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>2、测试</p>
<pre><code>public class OrderService {	
	UserService userService;	
	/**
	 * 初始化订单，查询用户的所有地址并返回
	 * @param userId
	 * @return
	 */
	public List&lt;UserAddress&gt; initOrder(String userId){
		return userService.getUserAddressList(userId);
	}
}
</code></pre>
<p>现在这样是无法进行调用的。我们gmall-order-web引入了gmall-interface，但是interface的实现是gmall-user，我们并没有引入，而且实际他可能还在别的服务器中。</p>
<h3 id="44-使用dubbo改造">4.4）、使用dubbo改造</h3>
<p><em>1、改造gmall-user作为服务提供者</em></p>
<p>1）导入 dubbo 依赖（2.6.2）、导入操作 zookeeper 的客户端（curator）</p>
<pre><code>		&lt;!-- 引入dubbo --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;com.alibaba&lt;/groupId&gt;
			&lt;artifactId&gt;dubbo&lt;/artifactId&gt;
			&lt;version&gt;2.6.2&lt;/version&gt;
		&lt;/dependency&gt;
	&lt;!-- 由于我们使用zookeeper作为注册中心，所以需要操作zookeeper
	dubbo 2.6以前的版本引入zkclient操作zookeeper 
	dubbo 2.6及以后的版本引入curator操作zookeeper
	下面两个zk客户端根据dubbo版本2选1即可
		&lt;dependency&gt;
			&lt;groupId&gt;com.101tec&lt;/groupId&gt;
			&lt;artifactId&gt;zkclient&lt;/artifactId&gt;
			&lt;version&gt;0.10&lt;/version&gt;
		&lt;/dependency&gt;
    --&gt;
		&lt;!-- curator-framework --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
			&lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
			&lt;version&gt;2.12.0&lt;/version&gt;
		&lt;/dependency&gt;
</code></pre>
<p>2）配置提供者</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd        http://dubbo.apache.org/schema/dubbo        http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;&gt;

    &lt;!-- 1.指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名） --&gt;
    &lt;dubbo:application name=&quot;user-service-provider&quot;  /&gt;

    &lt;!-- 2.指定注册中心的位置 --&gt;
    &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; /&gt;

    &lt;!-- 3.指定通信规则（通信协议、通信端口） --&gt;
    &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;

    &lt;!-- 4.暴露服务 ref：指向服务的真正实现对象--&gt;
    &lt;dubbo:service interface=&quot;com.atguigu.gmall.service.UserService&quot; ref=&quot;userServiceImpl&quot; /&gt;

    &lt;!-- 服务的实现  --&gt;
    &lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.atguigu.gmall.service.impl.UserServiceImpl&quot; /&gt;
&lt;/beans&gt;
</code></pre>
<p>3）启动服务</p>
<pre><code>package com.atguigu.gmall;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import java.io.IOException;
public class MainApplication {
    public static void main(String[] args) throws IOException {
        ClassPathXmlApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;provider.xml&quot;);
        ioc.start();
        System.in.read();
    }
}
</code></pre>
<figure data-type="image" tabindex="45"><img src="https://uploader.shimo.im/f/STJJRpsgwTkLRkmY.png!thumbnail" alt="图片" loading="lazy"></figure>
<p>4）测试</p>
<figure data-type="image" tabindex="46"><img src="https://uploader.shimo.im/f/reVohj16x2sHjsEN.png!thumbnail" alt="图片" loading="lazy"></figure>
<p><em>2、改造gmall-order-web作为服务消费者</em></p>
<p>1）引入dubbo</p>
<pre><code>		&lt;!-- 引入dubbo --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;com.alibaba&lt;/groupId&gt;
			&lt;artifactId&gt;dubbo&lt;/artifactId&gt;
			&lt;version&gt;2.6.2&lt;/version&gt;
		&lt;/dependency&gt;
	&lt;!-- 由于我们使用zookeeper作为注册中心，所以需要引入zkclient或curator操作zookeeper --&gt;
		&lt;!-- curator-framework --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
			&lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
			&lt;version&gt;2.12.0&lt;/version&gt;
		&lt;/dependency&gt;
</code></pre>
<p>2）配置消费者信息</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-4.3.xsd
       http://dubbo.apache.org/schema/dubbo
       http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!-- 1.指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名 --&gt;
    &lt;dubbo:application name=&quot;order-service-consumer&quot;  /&gt;

    &lt;!-- 2.注册中心地址 --&gt;
    &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; /&gt;

    &lt;!-- 3.声明需要调用的远程服务的接口 --&gt;
    &lt;dubbo:reference interface=&quot;com.atguigu.gmall.service.UserService&quot; id=&quot;userService&quot; /&gt;
    &lt;!-- 包扫描 --&gt;
    &lt;context:component-scan base-package=&quot;com.atguigu.gmall.service.impl&quot;&gt;&lt;/context:component-scan&gt;
&lt;/beans&gt;
</code></pre>
<p>3）Service 注解</p>
<pre><code>package com.atguigu.gmall.service.impl;

import com.atguigu.gmall.bean.UserAddress;
import com.atguigu.gmall.service.OrderService;
import com.atguigu.gmall.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * 1.让服务提供者注册到注册中心（暴露服务）
 *  1）导入 dubbo 依赖（2.6.2）、导入操作 zookeeper 的客户端（curator）
 *  2）配置服务提供者
 * 2.让消费者去注册中心订阅服务提供者的地址
 */
@Service
public class OrderServiceImpl implements OrderService {
    @Autowired
    UserService userService;
    @Override
    public void initOrder(String userId) {
        // 1. 查询用户收货地址
        List&lt;UserAddress&gt; list = userService.getUserAddressList(userId);
        System.out.println(list);
    }
}
</code></pre>
<p>4）main方法测试</p>
<pre><code>package com.atguigu.gmall;

import com.atguigu.gmall.service.OrderService;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import java.io.IOException;

public class MainApplication {
    public static void main(String[] args) throws IOException {
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;consumer.xml&quot;);
        OrderService orderService = applicationContext.getBean(OrderService.class);
        orderService.initOrder(&quot;1&quot;);
        System.out.println(&quot;调用结束...&quot;);

        System.in.read();
    }
}
</code></pre>
<p><em>3、测试调用</em><br>
访问gmall-order-web的initOrder请求，会调用UserService获取用户地址；</p>
<p>调用成功。说明我们order已经可以调用远程的UserService了；</p>
<p>运行结果：</p>
<pre><code>用户 id ：1
北京市昌平区宏福科技园综合楼3层
深圳市宝安区西部硅谷大厦B座3层（深圳分校）
调用结束...
</code></pre>
<figure data-type="image" tabindex="47"><img src="https://uploader.shimo.im/f/60BuhhwD1HUmxziW.png!thumbnail" alt="图片" loading="lazy"></figure>
<p><em>4、注解版</em></p>
<p>1、服务提供方</p>
<pre><code>&lt;dubbo:application name=&quot;gmall-user&quot;&gt;&lt;/dubbo:application&gt;  
&lt;dubbo:registry address=&quot;zookeeper://118.24.44.169:2181&quot; /&gt;  
&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;
&lt;dubbo:annotation package=*&quot;com.atguigu.gmall.user.impl&quot;/&gt;  

import com.alibaba.dubbo.config.annotation.Service;
import com.atguigu.gmall.bean.UserAddress;  
import com.atguigu.gmall.service.UserService;  
import com.atguigu.gmall.user.mapper.UserAddressMapper;

@Service //使用dubbo提供的service注解，注册暴露服务
public class UserServiceImpl implements UserService {	
     @Autowired		
    UserAddressMapper userAddressMapper; 
</code></pre>
<p>2、服务消费方</p>
<pre><code>&lt;dubbo:application name=&quot;gmall-order-web&quot;&gt;&lt;/dubbo:application&gt;  
&lt;dubbo:registry address=&quot;zookeeper://118.24.44.169:2181&quot; /&gt;  
&lt;dubbo:annotation package=&quot;com.atguigu.gmall.order.controller&quot;/&gt;

@Controller  
public class OrderController {  	  	
    @Reference  //使用dubbo提供的reference注解引用远程服务  	
    UserService userService; 
</code></pre>
<h2 id="5-监控中心">5、监控中心</h2>
<h3 id="51-dubbo-admin">5.1）、dubbo-admin</h3>
<p>图形化的服务管理页面；安装时需要指定注册中心地址，即可从注册中心中获取到所有的提供者/消费者进行配置管理</p>
<h3 id="52-dubbo-monitor-simple">5.2）、dubbo-monitor-simple</h3>
<p>简单的监控中心；</p>
<p><em>1、安装</em></p>
<table>
<thead>
<tr>
<th style="text-align:center">1、下载 dubbo-ops  <a href="https://github.com/apache/incubator-dubbo-ops">https://github.com/apache/incubator-dubbo-ops</a></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2、修改配置指定注册中心地址进入 dubbo-monitor-simple\src\main\resources\conf修改 dubbo.properties文件</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="48"><img src="https://uploader.shimo.im/f/hiBXL60A0HIHytCX.png!thumbnail" alt="图片" loading="lazy"></figure>
<table>
<thead>
<tr>
<th style="text-align:left">3、打包dubbo-monitor-simplemvn clean package -Dmaven.test.skip=true</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">4、解压 tar.gz 文件，并运行start.bat</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="49"><img src="https://uploader.shimo.im/f/3VuJjpqB1NQs3dTZ.png!thumbnail" alt="图片" loading="lazy"></figure>
<table>
<thead>
<tr>
<th style="text-align:left">如果缺少servlet-api，自行导入servlet-api再访问监控中心</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">5、启动访问8080</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="50"><img src="https://uploader.shimo.im/f/8yKt4JScy58YqdVP.png!thumbnail" alt="图片" loading="lazy"></figure>
<p><em>2、监控中心配置</em></p>
<table>
<thead>
<tr>
<th>所有服务配置连接监控中心，进行监控统计    <!-- 监控中心协议，如果为protocol="registry"，表示从注册中心发现监控中心地址，否则直连监控中心 -->  	<a href="dubbo:monitor%C2%A0protocol=%22registry%22">dubbo:monitor protocol=&quot;registry&quot;</a>&lt;/dubbo:monitor&gt;</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Simple Monitor 挂掉不会影响到 Consumer 和 Provider 之间的调用，所以用于生产环境不会有风险。</p>
<p>Simple Monitor 采用磁盘存储统计信息，请注意安装机器的磁盘限制，如果要集群，建议用mount共享磁盘。</p>
<h2 id="6-整合springboot">6、整合SpringBoot</h2>
<p>1）引入<strong>spring-boot-starter以及dubbo和curator的依赖</strong></p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt;
    &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;0.2.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>注意starter版本适配：<br>
<img src="https://uploader.shimo.im/f/d2JLjRxIZZsumBaC.png!thumbnail" alt="图片" loading="lazy"></p>
<p>2）配置application.properties</p>
<p><em>提供者配置：</em></p>
<pre><code>dubbo.application.name=gmall-user
dubbo.registry.protocol=zookeeper
dubbo.registry.address=192.168.67.159:2181
dubbo.scan.base-package=com.atguigu.gmall
dubbo.protocol.name=dubbo
dubbo.protocol.port=20880
dubbo.monitor.protocol=registry
## application.name就是服务名，不能跟别的dubbo提供端重复
## registry.protocol  是指定注册中心协议
## registry.address 是注册中心的地址加端口号
## protocol.name 是分布式固定是dubbo,不要改。
## base-package  注解方式要扫描的包
</code></pre>
<p><em>消费者配置：</em></p>
<pre><code>server.port=8081

dubbo.application.name=gmall-order-web
dubbo.registry.protocol=zookeeper
dubbo.registry.address=192.168.67.159:2181
dubbo.scan.base-package=com.atguigu.gmall
dubbo.protocol.name=dubbo
dubbo.monitor.protocol=registry
</code></pre>
<p>3、dubbo注解<br>
@Service、@Reference</p>
<p><strong>【如果没有在配置中写dubbo.scan.base-package,还需要在启动类使用@EnableDubbo注解】</strong></p>
<p>消费者：</p>
<pre><code>@Reference
UserService userService;
</code></pre>
<p>服务提供者：</p>
<pre><code>@com.alibaba.dubbo.config.annotation.Service // 暴露服务
@Service
public class UserServiceImpl implements UserService {
</code></pre>
<h1 id="二-dubbo配置">二、dubbo配置</h1>
<h2 id="1-配置原则">1、配置原则</h2>
<figure data-type="image" tabindex="51"><img src="https://uploader.shimo.im/f/B1hW7n2x1bYU1d7w.png!thumbnail" alt="图片" loading="lazy"></figure>
<p>JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。</p>
<p>XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。</p>
<p>Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。</p>
<h2 id="2-重试次数">2、重试次数</h2>
<p>失败自动切换，当出现失败，重试其它服务器，但重试会带来更长延迟。可通过 retries=&quot;2&quot; 来设置重试次数(不含第一次)。</p>
<p>重试次数配置如下：</p>
<pre><code>&lt;dubbo:service retries=&quot;2&quot; /&gt;
</code></pre>
<p>或</p>
<pre><code>&lt;dubbo:reference retries=&quot;2&quot; /&gt;
</code></pre>
<p>或</p>
<pre><code>&lt;dubbo:reference&gt;
    &lt;dubbo:method name=&quot;findFoo&quot; retries=&quot;2&quot; /&gt;
&lt;/dubbo:reference&gt;
</code></pre>
<blockquote>
<p>幂等操作（执行多次和执行一次效果相同：查询、删除、修改）可设置重试次数，非幂等操作（执行多次和执行一次效果不同：新增）不宜设置重试次数</p>
</blockquote>
<h2 id="3-超时时间">3、超时时间</h2>
<p>由于网络或服务端不可靠，会导致调用出现一种不确定的中间状态（超时）。为了避免超时导致客户端资源（线程）挂起耗尽，必须设置超时时间。</p>
<blockquote>
<p>服务消费方引用服务提供方时，可能有雨网络等原因，服务提供方要执行一个方法可能有很长时间，如果很长时间都没有返回，导致大量线程阻塞，可能会引起性能下降，为了解决这个问题，可以指定超时时间，只要这个方法在指定时间内没有返回，就立即终止，不让大量线程阻塞。设置单位 ms</p>
</blockquote>
<h3 id="1-dubbo消费端">1、Dubbo消费端</h3>
<p>全局超时配置</p>
<pre><code>&lt;dubbo:consumer timeout=&quot;5000&quot; /&gt;
</code></pre>
<p>指定接口以及特定方法超时配置</p>
<pre><code>&lt;dubbo:reference interface=&quot;com.foo.BarService&quot; timeout=&quot;2000&quot;&gt;
    &lt;dubbo:method name=&quot;sayHello&quot; timeout=&quot;3000&quot; /&gt;
&lt;/dubbo:reference&gt;
</code></pre>
<h3 id="2-dubbo服务端">2、Dubbo服务端</h3>
<p>全局超时配置</p>
<pre><code>&lt;dubbo:provider timeout=&quot;5000&quot; /&gt;
</code></pre>
<p>指定接口以及特定方法超时配置</p>
<pre><code>&lt;dubbo:provider interface=&quot;com.foo.BarService&quot; timeout=&quot;2000&quot;&gt;
    &lt;dubbo:method name=&quot;sayHello&quot; timeout=&quot;3000&quot; /&gt;
&lt;/dubbo:provider&gt;
</code></pre>
<h3 id="3-配置原则">3、配置原则</h3>
<p>dubbo推荐在Provider上尽量多配置Consumer端属性：</p>
<p>1、作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等</p>
<p>2、在Provider配置后，Consumer不配置则会使用Provider的配置值，即Provider配置可以作为Consumer的缺省值。否则，Consumer会使用Consumer端的全局设置，这对于Provider不可控的，并且往往是不合理的</p>
<p>配置的覆盖规则：</p>
<ol>
<li>
<p>方法级别配置优于接口级别，即小Scope优先</p>
</li>
<li>
<p>Consumer端配置 优于 Provider配置 优于 全局配置，</p>
</li>
</ol>
<p>3) 最后是Dubbo Hard Code的配置值（见配置文档）</p>
<figure data-type="image" tabindex="52"><img src="https://uploader.shimo.im/f/5xoy9sunaRc44qdE.png!thumbnail" alt="图片" loading="lazy"></figure>
<h2 id="4-版本号">4、版本号</h2>
<p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。</p>
<p>可以按照以下的步骤进行版本迁移：</p>
<p>在低压力时间段，先升级一半提供者为新版本</p>
<p>再将所有消费者升级为新版本</p>
<p>然后将剩下的一半提供者升级为新版本</p>
<p>老版本服务提供者配置：</p>
<pre><code>&lt;dubbo:service interface=&quot;com.foo.BarService&quot; version=&quot;1.0.0&quot; /&gt;
</code></pre>
<p>新版本服务提供者配置：</p>
<pre><code>&lt;dubbo:service interface=&quot;com.foo.BarService&quot; version=&quot;2.0.0&quot; /&gt;
</code></pre>
<p>老版本服务消费者配置：</p>
<pre><code>&lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;1.0.0&quot; /&gt;
</code></pre>
<p>新版本服务消费者配置：</p>
<pre><code>&lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;2.0.0&quot; /&gt;
</code></pre>
<p>如果不需要区分版本，可以按照以下的方式配置：</p>
<pre><code>&lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;*&quot; /&gt;
</code></pre>
<h2 id="5-启动时检查">5、启动时检查</h2>
<p>Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 check=&quot;true&quot;。</p>
<p>可以通过 check=&quot;false&quot; 关闭检查，比如，测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。</p>
<p>另外，如果你的 Spring 容器是懒加载的，或者通过 API 编程延迟引用服务，请关闭 check，否则服务临时不可用时，会抛出异常，拿到 null 引用，如果 check=&quot;false&quot;，总是会返回引用，当服务恢复时，能自动连上。</p>
<h3 id="示例">示例</h3>
<p><strong>通过 spring 配置文件</strong></p>
<p>关闭某个服务的启动时检查 (没有提供者时报错)：如果启动时没有提供者可以成功启动，但调用时因没有提供者调用失败会抛出异常</p>
<pre><code>&lt;dubbo:reference interface=&quot;com.foo.BarService&quot; check=&quot;false&quot; /&gt;
</code></pre>
<p>配置当前消费者的统一规则，所有的服务启动时都不检查：</p>
<pre><code>&lt;dubbo:consumer check=&quot;false&quot; /&gt;
</code></pre>
<p>关闭注册中心启动时检查 (注册订阅失败时报错)：</p>
<pre><code>&lt;dubbo:registry check=&quot;false&quot; /&gt;
</code></pre>
<p><strong>通过 dubbo.properties</strong></p>
<pre><code>dubbo.reference.com.foo.BarService.check=false
dubbo.reference.check=false
dubbo.consumer.check=false
dubbo.registry.check=false
</code></pre>
<h2 id="6-多版本">6、多版本</h2>
<p><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/multi-versions.html">http://dubbo.apache.org/zh-cn/docs/user/demos/multi-versions.html</a></p>
<blockquote>
<p>使用场景：某一个接口功能出现了不兼容的升级，先让一部分人使用新功能，另外一部分人还是先用旧版本，如果新功能版本都稳定了，再把所有老版本替换成新版本。</p>
</blockquote>
<p>服务提供方提供新旧两个版本供消费者使用</p>
<pre><code>&lt;!-- 4.暴露服务 ref：指向服务的真正实现对象--&gt;
&lt;dubbo:service interface=&quot;com.atguigu.gmall.service.UserService&quot; ref=&quot;userServiceImpl01&quot; version=&quot;1.0.0&quot;/&gt;
&lt;!-- 服务的实现  --&gt;
&lt;bean id=&quot;userServiceImpl01&quot; class=&quot;com.atguigu.gmall.service.impl.UserServiceImpl&quot; /&gt;
&lt;!-- 连接监控中心 --&gt;
&lt;dubbo:monitor protocol=&quot;registry&quot;&gt;&lt;/dubbo:monitor&gt;
&lt;!-- 检测多版本 --&gt;
&lt;dubbo:service interface=&quot;com.atguigu.gmall.service.UserService&quot; ref=&quot;userServiceImpl02&quot; version=&quot;2.0.0&quot;/&gt;
&lt;bean id=&quot;userServiceImpl02&quot; class=&quot;com.atguigu.gmall.service.impl.UserServiceImpl2&quot; /&gt;
</code></pre>
<p>服务消费方可选择哪一个版本</p>
<pre><code>&lt;!-- 3.声明需要调用的远程服务的接口 --&gt;
&lt;dubbo:reference interface=&quot;com.atguigu.gmall.service.UserService&quot; id=&quot;userService&quot; check=&quot;false&quot; version=&quot;2.0.0&quot;/&gt;
</code></pre>
<blockquote>
<p>由此实现灰度发布。</p>
</blockquote>
<h2 id="7-本地存根">7、本地存根</h2>
<p><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html">http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html</a></p>
<p>远程服务后，客户端通常只剩下接口，而实现全在服务器端，但提供方有些时候想在客户端也执行部分逻辑，比如：做 ThreadLocal 缓存，提前验证参数，调用失败后伪造容错数据等等，此时就需要在 API 中带上 Stub，客户端生成 Proxy 实例，会把 Proxy 通过构造函数传给 Stub <a href="http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html#fn1">[1]</a>，然后把 Stub 暴露给用户，Stub 可以决定要不要去调 Proxy。</p>
<figure data-type="image" tabindex="53"><img src="https://uploader.shimo.im/f/fCMOKYxIU74ZSiof.png!thumbnail" alt="图片" loading="lazy"></figure>
<p>在 spring 配置文件中按以下方式配置：</p>
<pre><code>&lt;dubbo:service interface=&quot;com.foo.BarService&quot; stub=&quot;true&quot; /&gt;
</code></pre>
<p>或</p>
<pre><code>&lt;dubbo:service interface=&quot;com.foo.BarService&quot; stub=&quot;com.foo.BarServiceStub&quot; /&gt;
</code></pre>
<p>提供 Stub 的实现 <a href="http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html#fn2">[2]</a>：</p>
<pre><code>package com.foo;
public class BarServiceStub implements BarService {
    private final BarService barService;
    
    // 构造函数传入真正的远程代理对象
    public BarServiceStub(BarService barService){
        this.barService = barService;
    }
 
    public String sayHello(String name) {
        // 此代码在客户端执行, 你可以在客户端做ThreadLocal本地缓存，或预先验证参数是否合法，等等
        try {
            return barService.sayHello(name);
        } catch (Exception e) {
            // 你可以容错，可以做任何AOP拦截事项
            return &quot;容错数据&quot;;
        }
    }
}
</code></pre>
<p>Stub 必须有可传入 Proxy 的构造函数。 <a href="http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html#fnref1">↩︎</a></p>
<ol>
<li>在 interface 旁边放一个 Stub 实现，它实现 BarService 接口，并有一个传入远程 BarService 实例的构造函数 <a href="http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html#fnref2">↩︎</a></li>
</ol>
<h2 id="8-springboot-与-dubbo-整合的三种方式">8、Springboot 与 dubbo 整合的三种方式</h2>
<p><strong>（1） application.properties</strong></p>
<p>导入 dubb-starter，在 application.properties 中配置属性，使用 @Service 暴露服务；使用 @Reference 引用服务</p>
<p>（注意 @EnableDubbo 开启基于注解的 dubbo 或在 properties 文件中包扫描）</p>
<p><strong>（2）保留 dubbo xml配置文件</strong></p>
<p>导入 dubb-starter，使用 @ImportResource 导入配置文件即可（不再使用 @EnableDubbo 注解，转而使用 @ImportResource(locations=&quot;classpath:provider.xml&quot;)</p>
<p>暴露 Service 也不再使用 @Service 了，因为 xml 中已经设置了暴露服务）</p>
<p><strong>（3）使用注解 API 方式</strong></p>
<p>将每一个组件手动创建到容器中，让 dubbo 来扫描其他的组件</p>
<pre><code>  @EnableDubbo(scanBasePackages=&quot;com.atguigu.gmall&quot;)
</code></pre>
<pre><code>package com.atguigu.gmall.config;

import com.alibaba.dubbo.config.*;
import com.atguigu.gmall.service.UserService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.ArrayList;
import java.util.List;

@Configuration
public class MyDubboConfig {

//        &lt;dubbo:application name=&quot;boot-user-service-provider&quot;  /&gt;
    @Bean
    public ApplicationConfig applicationConfig(){
        ApplicationConfig config = new ApplicationConfig();
        config.setName(&quot;boot-user-service-provider&quot;);
        return config;
    }

    // &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; /&gt;
    @Bean
    public RegistryConfig registryConfig(){
        System.out.println(&quot;--------&quot;);
        RegistryConfig registryConfig = new RegistryConfig();
        registryConfig.setProtocol(&quot;zookeeper&quot;);
        registryConfig.setAddress(&quot;127.0.0.1:2181&quot;);
        return registryConfig;
    }

    //&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20882&quot; /&gt;
    @Bean
    public ProtocolConfig protocolConfig(){
        ProtocolConfig config = new ProtocolConfig();
        config.setName(&quot;dubbo&quot;);
        config.setPort(20882);
        return config;
    }

    //    &lt;dubbo:service interface=&quot;com.atguigu.gmall.service.UserService&quot; ref=&quot;userServiceImpl01&quot;&gt;
    //        &lt;dubbo:method name=&quot;getUserAddressList&quot; timeout=&quot;1000&quot;&gt;&lt;/dubbo:method&gt;
    //    &lt;/dubbo:service&gt;
    @Bean
    public ServiceConfig&lt;UserService&gt; serviceConfig(UserService userService){
        ServiceConfig&lt;UserService&gt; config = new ServiceConfig&lt;&gt;();
        config.setInterface(UserService.class);
        config.setRef(userService);

        // 配置每一个 method 信息
        MethodConfig methodConfig = new MethodConfig();
        methodConfig.setName(&quot;getUserAddressList&quot;);
        methodConfig.setTimeout(1000);

        // 将 method 的设置关联到 servie 中
        List&lt;MethodConfig&gt; methods = new ArrayList&lt;&gt;();
        methods.add(methodConfig);
        config.setMethods(methods);

        return config;
    }

}
</code></pre>
<h1 id="三-高可用">三、高可用</h1>
<h2 id="1-zookeeper宕机与dubbo直连">1、zookeeper宕机与dubbo直连</h2>
<p>现象：zookeeper注册中心（zkServer.cmd）宕机，还可以消费dubbo暴露的服务。</p>
<p>原因：</p>
<p>健壮性</p>
<ul>
<li>监控中心宕掉不影响使用，只是丢失部分采样数据</li>
<li>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</li>
<li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li>
<li><strong>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</strong></li>
<li>服务提供者无状态，任意一台宕掉后，不影响使用</li>
<li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</li>
</ul>
<p><strong>高可用：通过设计，减少系统不能提供服务的时间；</strong></p>
<p><strong>dubbo 直连（绕过注册中心）</strong></p>
<pre><code>@Reference(url = &quot;127.0.0.1:20882&quot;)
UserService userService;
</code></pre>
<h2 id="2-集群下dubbo负载均衡配置">2、集群下dubbo负载均衡配置</h2>
<p><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/loadbalance.html">http://dubbo.apache.org/zh-cn/docs/user/demos/loadbalance.html</a></p>
<p>在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。</p>
<h3 id="负载均衡策略">负载均衡策略</h3>
<p><strong>Random LoadBalance</strong></p>
<p>随机，按权重设置随机概率。</p>
<p>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</p>
<figure data-type="image" tabindex="54"><img src="https://uploader.shimo.im/f/t9CCH4EHEeoW2iry.png!thumbnail" alt="图片" loading="lazy"></figure>
<blockquote>
<p>基于权重的随机负载均衡机制：orderService 想要调用 userService，userService 分别在 1、2、3 台机器内，分别为每一台机器的服务设置权重为 100、200、50，总权重 350，那么对于 1 号机器来说，它的概率就是 100/350 = 2/7，在负载均衡的情况下，大量请求过来，大约有 2/7 的请求会来到 1 号机器。第一次请求来调用的是 1 号机器，第二次来有可能还调用 1 号机器，但总体上，按照大量请求概率分布来看，1 号机器会占 2/7 的概率。</p>
</blockquote>
<p><strong>RoundRobin LoadBalance</strong></p>
<p>轮循，按公约后的权重设置轮循比率。</p>
<p>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</p>
<figure data-type="image" tabindex="55"><img src="https://uploader.shimo.im/f/fnw0VbVMqhIoKq6S.png!thumbnail" alt="图片" loading="lazy"></figure>
<blockquote>
<p>轮询负载均衡机制：orderService 想要调用 userService，第一个请求过来先用 1 号 userService 服务，第二个请求过来使用 2 号 userService 服务，下一个请求过来使用 3 号userService 服务，再下一次 1 号，再下一次 2 号...... 依次轮询。<br>
基于权重的轮询负载均衡机制：为每个服务设置权重，3 台服务器的权重分别为 2/7、4/7、1/7，按照轮询机制，第一个请求到来使用 1 号服务器，第二个请求使用 2 号服务器，第三个请求使用 3 号服务器，第四个请求使用 1 号服务器，第五个请求使用 2 号服务器，第六个请求本应使用 3 号服务器，<strong>但是</strong>，由于 3 号服务器的权重是 1/7（如果有 7 个请求，则 7 个之中的 1 个使用 3 号服务器），已经有第三个请求使用了 3 号服务器，第一个、第四个请求已经使用了 两次 1 号服务器，所以第六个请求只能使用 2 号服务器，同理，第七个请求也使用 2 号服务器。<br>
<strong>LeastActive LoadBalance</strong></p>
</blockquote>
<p>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</p>
<p>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</p>
<figure data-type="image" tabindex="56"><img src="https://uploader.shimo.im/f/S8G9zCwCrP81SVr3.png!thumbnail" alt="图片" loading="lazy"></figure>
<blockquote>
<p>最少活跃数：orderService 要调用 userService，在确定要使用几号 userService前，根据 “每一个服务器统计的上一次的调用时间”：三台服务器上一次请求的处理时间分别为 100ms、1000ms、300ms，说明 1 号服务器处理最快，于是此次请求会来到 1 号服务器。</p>
</blockquote>
<p><strong>ConsistentHash LoadBalance</strong></p>
<p>一致性 Hash，相同参数的请求总是发到同一提供者。</p>
<p>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：<a href="http://en.wikipedia.org/wiki/Consistent_hashing">http://en.wikipedia.org/wiki/Consistent_hashing</a></p>
<p>缺省只对第一个参数 Hash，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</p>
<p>缺省用 160 份虚拟节点，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</p>
<figure data-type="image" tabindex="57"><img src="https://uploader.shimo.im/f/TKBZTSuulaQxa01m.png!thumbnail" alt="图片" loading="lazy"></figure>
<blockquote>
<p>一致性 hash：orderService 想要调用 userService，都是调用的同一个 getUser 方法，将参数 hash 后的不同值分不到不同的服务器上。</p>
</blockquote>
<h3 id="负载均衡配置">负载均衡配置</h3>
<p>服务端服务级别，暴露服务时</p>
<pre><code>&lt;dubbo:service interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;
</code></pre>
<p>客户端服务级别，消费时</p>
<pre><code>&lt;dubbo:reference interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;
</code></pre>
<p>服务端方法级别</p>
<pre><code>&lt;dubbo:service interface=&quot;...&quot;&gt;
    &lt;dubbo:method name=&quot;...&quot; loadbalance=&quot;roundrobin&quot;/&gt;
&lt;/dubbo:service&gt;
</code></pre>
<p>客户端方法级别</p>
<pre><code>&lt;dubbo:reference interface=&quot;...&quot;&gt;
    &lt;dubbo:method name=&quot;...&quot; loadbalance=&quot;roundrobin&quot;/&gt;
&lt;/dubbo:reference&gt;
</code></pre>
<h2 id="3-整合hystrix服务熔断与降级处理">3、整合hystrix，服务熔断与降级处理</h2>
<h3 id="1-服务降级">1、服务降级</h3>
<p><strong>什么是服务降级？</strong></p>
<p><strong>当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。</strong></p>
<p>可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。</p>
<p>向注册中心写入动态配置覆盖规则：</p>
<pre><code>RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();
Registry registry = registryFactory.getRegistry(URL.valueOf(&quot;zookeeper://10.20.153.10:2181&quot;));
registry.register(URL.valueOf(&quot;override://0.0.0.0/com.foo.BarService?category=configurators&amp;dynamic=false&amp;application=foo&amp;mock=force:return+null&quot;));
</code></pre>
<p>其中：</p>
<ul>
<li>mock=force:return+null 表示消费方对该服务的方法调用都<strong>直接返回 null 值，不发起远程调用</strong>。用来屏蔽不重要服务不可用时对调用方的影响。</li>
<li>还可以改为 mock=fail:return+null 表示消费方对该服务的方法<strong>调用在失败后，再返回 null 值</strong>，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。</li>
</ul>
<h3 id="2-集群容错">2、集群容错</h3>
<p>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p>
<p><strong>集群容错模式</strong></p>
<p><strong>Failover Cluster</strong></p>
<p>失败自动切换，当<strong>出现失败，重试其它服务器</strong>。通常用于读操作，但重试会带来更长延迟。可通过 retries=&quot;2&quot; 来设置重试次数(不含第一次)。</p>
<blockquote>
<p>A 服务调用 B 服务，B 服务超时后，配置一个重试次数，可以重新切换到能提供 B服务的其他机器。</p>
</blockquote>
<p>重试次数配置如下：</p>
<pre><code>&lt;dubbo:service retries=&quot;2&quot; /&gt;
</code></pre>
<p>或</p>
<pre><code>&lt;dubbo:reference retries=&quot;2&quot; /&gt;
</code></pre>
<p>或</p>
<pre><code>&lt;dubbo:reference&gt;
    &lt;dubbo:method name=&quot;findFoo&quot; retries=&quot;2&quot; /&gt;
&lt;/dubbo:reference&gt;
</code></pre>
<p><strong>Failfast Cluster</strong></p>
<p>快速失败，只发起一次调用，<strong>失败立即报错</strong>。通常用于非幂等性的写操作，比如新增记录。</p>
<blockquote>
<p>A 服务调用 B服务，只发起一次调用，失败立即报错。</p>
</blockquote>
<p><strong>Failsafe Cluster</strong></p>
<p>失败安全，出现异常时，直接<strong>忽略</strong>。通常用于写入审计日志等操作。</p>
<p><strong>Failback Cluster</strong></p>
<p><strong>失败自动恢复，后台记录失败请求，定时重发</strong>。通常用于消息通知操作。</p>
<blockquote>
<p>A 服务调用 B 服务，失败后可以后台记录一下，隔一段时间定时再调用一次。适用于：一定要成功的服务调用</p>
</blockquote>
<p><strong>Forking Cluster</strong></p>
<p>并行调用多个服务器，只要一个成功即返回。通常用于<strong>实时性要求较高</strong>的读操作，但需要浪费更多服务资源。可通过 forks=&quot;2&quot; 来设置最大并行数。</p>
<blockquote>
<p>A 服务调用 B服务，有可能会失败，能提供 B 服务的在三台服务器上，同时给这三台服务器都发起请求，只要其中一个服务器响应成功就可以使用。</p>
</blockquote>
<p><strong>Broadcast Cluster</strong></p>
<p>广播调用所有提供者，逐个调用，任意一台报错则报错 [2]。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p>
<blockquote>
<p>A 服务调用 B服务，B 服务的提供者有四台机器，每一台机器都调用一遍，只要有任意一台出现错误，都认为这次调用是失败的。</p>
</blockquote>
<p><strong>集群模式配置</strong></p>
<p>按照以下示例在服务提供方和消费方配置集群模式</p>
<pre><code>&lt;dubbo:service cluster=&quot;failsafe&quot; /&gt;
</code></pre>
<p>或</p>
<pre><code>&lt;dubbo:reference cluster=&quot;failsafe&quot; /&gt;
</code></pre>
<h3 id="3-整合hystrix">3、整合hystrix</h3>
<p>Hystrix 旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能</p>
<p><em>1、配置spring-cloud-starter-netflix-hystrix</em></p>
<p>spring boot官方提供了对hystrix的集成，直接在pom.xml里加入依赖：</p>
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
  &lt;version&gt;1.4.4.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>然后在Application类上增加@EnableHystrix来启用hystrix starter：</p>
<pre><code>@SpringBootApplication
@EnableHystrix
public class ProviderApplication {
</code></pre>
<p><em>2、配置Provider端</em></p>
<p>在Dubbo的Provider上增加@HystrixCommand配置，这样子调用就会经过Hystrix代理。</p>
<pre><code>@Service(version = &quot;1.0.0&quot;)
public class HelloServiceImpl implements HelloService {
    @HystrixCommand(commandProperties = {
     @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;10&quot;),
     @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;2000&quot;) })
    @Override
    public String sayHello(String name) {
        // System.out.println(&quot;async provider received: &quot; + name);
        // return &quot;annotation: hello, &quot; + name;
        throw new RuntimeException(&quot;Exception to show hystrix enabled.&quot;);
    }
}
</code></pre>
<p><em>3、配置Consumer端</em></p>
<p>对于Consumer端，则可以增加一层method调用，并在method上配置@HystrixCommand。当调用出错时，会走到fallbackMethod = &quot;reliable&quot;的调用里。</p>
<pre><code>    @Reference(version = &quot;1.0.0&quot;)
    private HelloService demoService;
    @HystrixCommand(fallbackMethod = &quot;reliable&quot;)
    public String doSayHello(String name) {
        return demoService.sayHello(name);
    }
    public String reliable(String name) {
        return &quot;hystrix fallback value&quot;;
    }
</code></pre>
<h1 id="四-dubbo原理">四、dubbo原理</h1>
<h2 id="1-rpc原理">1、RPC原理</h2>
<figure data-type="image" tabindex="58"><img src="https://uploader.shimo.im/f/VT5w26Fy18AWw61q.png!thumbnail" alt="图片" loading="lazy"></figure>
<p>一次完整的RPC调用流程（同步调用，异步另说）如下：</p>
<p>**1）服务消费方（client）调用以本地调用方式调用服务； **</p>
<p>2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</p>
<p>3）client stub找到服务地址，并将消息发送到服务端；</p>
<p>4）server stub收到消息后进行解码；</p>
<p>5）server stub根据解码结果调用本地的服务；</p>
<p>6）本地服务执行并将结果返回给server stub；</p>
<p>7）server stub将返回结果打包成消息并发送至消费方；</p>
<p>8）client stub接收到消息，并进行解码；</p>
<p><strong>9）服务消费方得到最终结果。</strong></p>
<p>RPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明的，不可见的。</p>
<h2 id="2-netty通信原理">2、netty通信原理</h2>
<p>Netty是一个异步事件驱动的网络应用程序框架， 用于快速开发可维护的高性能协议服务器和客户端。它极大地简化并简化了TCP和UDP套接字服务器等网络编程。</p>
<p>BIO：(Blocking IO)</p>
<figure data-type="image" tabindex="59"><img src="https://uploader.shimo.im/f/2W5W02pWhRc1tfWH.png!thumbnail" alt="图片" loading="lazy"></figure>
<blockquote>
<p>BIO：阻塞式 IO。每一个请求进来，开一个 Socket 开一个线程来处理数据，读取到数据后业务逻辑操作完成后返回。服务器收到很多请求，同时操作，在这个业务逻辑完成前这个线程不能得到释放，服务器就不能同时处理大量请求，因为有大量线程在阻塞，等待业务逻辑的完成。</p>
</blockquote>
<p>NIO (Non-Blocking IO)</p>
<figure data-type="image" tabindex="60"><img src="https://uploader.shimo.im/f/i2Hhf1AEfLE0e9rK.png!thumbnail" alt="图片" loading="lazy"></figure>
<blockquote>
<p>Channel：通道，通道里面有 Buffer 用来进行数据传输。<br>
一个 Selector 注册进了很多通道，每个请求使用通道进行数据传递通信，Selector 通过监听多个通道，当发现某一个通道里的数据准备好了，Selector 执行相应操作。</p>
</blockquote>
<p>Selector 一般称 为<strong>选择器</strong> ，也可以翻译为 <strong>多路复用器，</strong></p>
<p>Connect（连接就绪）、Accept（接受就绪）、Read（读就绪）、Write（写就绪）</p>
<p>Netty基本原理：</p>
<figure data-type="image" tabindex="61"><img src="https://uploader.shimo.im/f/M16PnkZ6fGY7YG8J.png!thumbnail" alt="图片" loading="lazy"></figure>
<blockquote>
<p>Netty 服务器启动（ServerBootstrap.bind），绑定监听某一个端口，比如 dubbo 的20880端口，这样所有给这个端口发的数据 netty 就能收到，启动后初始化服务器的通道（NioServerSockerChannel），注册到 selector，selector 负责监听 accept 事件（当通道接收准备就绪后，处理通道里的信息），netty 与客户端建立连接， 生成 NioSocketChannel，把这个  通道注册到 Selector 里面，这个 selector 监听 read、write 事件（通道中数据读、写准备就绪），读写准备就绪后来处理这个事件，抛给用户队列，netty 把这个任务队列执行完</p>
</blockquote>
<h2 id="3-dubbo原理">3、dubbo原理</h2>
<h3 id="1-dubbo原理-框架设计">1、dubbo原理	-框架设计</h3>
<figure data-type="image" tabindex="62"><img src="https://uploader.shimo.im/f/mktdQ0QVP0s1eieu.png!thumbnail" alt="图片" loading="lazy"></figure>
<blockquote>
<p>dubbo 框架整体分层：</p>
<ol>
<li>Business 业务逻辑层：<br>
1.1 Service服务层：面向接口编程。接口、实现。想要远程调用只需要调用接口的方法，就自动调实现了。 对于用户编程，只需要关心这一层就结束了。<br>
2.RPC层：完成远程过程调用：<br>
2.1 Config 配置层，封装配置文件里解析出来的信息 ReferenceConfig、ServiceConfig；<br>
2.2 Proxy 服务代理层：利用代理的方式，生成客户端代理对象、服务端代理对象，代理对象互相调用方法；<br>
2.2 Registry 注册中心层：完成服务的发现和注册；很多服务要注册到注册中心，消费者要从注册中心订阅所需要的服务来调用；<br>
2.3 Cluster 路由层：负载均衡。invoker 调用者要调用很多的服务，服务在很多机器上跑，需要负载均衡；<br>
2.4 Monitor 监控层：每一次的调用信息都会向监控层发送一些数据；<br>
2.5 Protocol 远程调用层：封装 RPC 调用，RPC 调用核心的三个：Invoker、Protocol、Exporter；</li>
<li>Remoting 层：远程要调用就要跟 A、B两个服务器架起通信管道，通信以及在通信间传递数据<br>
3.1 Exchange 信息交换层：创建一个客户端 ExchangeClient、服务端 ExchangeServer<br>
两端架起网架进行数据的互联互通；<br>
3.2 Transport 传输层：真正传输数据用 Transporter 来封装传输的，Transporter 底层就是 netty 框架，netty 框架就是在这一层封装；<br>
3.3 Serialize 序列化层：序列化</li>
</ol>
</blockquote>
<ul>
<li>config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li>
<li>proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory</li>
<li>registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService</li>
<li>cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance</li>
<li>monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService</li>
<li>protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter</li>
<li>exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer</li>
<li>transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec</li>
<li>serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool</li>
</ul>
<h3 id="2-dubbo原理-启动解析-加载配置信息">2、dubbo原理	-启动解析、加载配置信息</h3>
<figure data-type="image" tabindex="63"><img src="https://uploader.shimo.im/f/iFVXso8DLkEuO0r6.png!thumbnail" alt="图片" loading="lazy"></figure>
<h3 id="3-dubbo原理-服务暴露">3、dubbo原理	-服务暴露</h3>
<figure data-type="image" tabindex="64"><img src="https://uploader.shimo.im/f/2ocFX7K06DopwxGs.png!thumbnail" alt="图片" loading="lazy"></figure>
<h3 id="4-dubbo原理-服务引用">4、dubbo原理	-服务引用</h3>
<figure data-type="image" tabindex="65"><img src="https://uploader.shimo.im/f/DxTlKd889QMR0jp1.png!thumbnail" alt="图片" loading="lazy"></figure>
<h3 id="5-dubbo原理-服务调用">5、dubbo原理	-服务调用</h3>
<figure data-type="image" tabindex="66"><img src="https://uploader.shimo.im/f/rugf4MklrfIiNoOW.png!thumbnail" alt="图片" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记一个面试题 —— 实现一个读写锁]]></title>
        <id>https://epitomm.github.io/post/ji-yi-ge-mian-shi-ti-shi-xian-yi-ge-du-xie-suo/</id>
        <link href="https://epitomm.github.io/post/ji-yi-ge-mian-shi-ti-shi-xian-yi-ge-du-xie-suo/">
        </link>
        <updated>2020-04-10T05:57:59.000Z</updated>
        <content type="html"><![CDATA[<h1 id="用共享对象实现写优先的读者写者锁">用共享对象实现写优先的读者写者锁</h1>
<p>首先，我们实现一个读者/写者锁。类似于一个普通的互斥锁，一个读者/写者锁(RWLock)保护共享数据。然而，它会做如下的优化。为了最大化性能，一个 RWLock 允许多个“读者”线程同时访问共享数据。任意数量的线程可以在同一时间安全地读共享数据，只要没有线程在修改数据。然而，任意时刻，至多只能有 1 个写者线程可以持有 RWLock（读者线程只能读共享数据，写者线程既可以写也可以读共享数据）。当一个写者线程持有 RWLock，它可以安全地修改数据，因为锁保证了不会有其他的线程同时持有该锁。读者写者锁常常被用于数据库，它们被用于支持对数据库的更快的搜索查询，同时也支持不太频繁的更新。另一个常见的应用是在操作系统内核中，核心的数据结构常常被许多线程读但更新却不太频繁。为了将我们的互斥锁一般化为一个读者/写者锁，我们实现了一个新类型的共享对象，RWLock，来保护对共享数据的访问。RWLock 采用了我们标准化的同步构建模块：互斥锁和条件变量来实现。<br>
一个线程想要（原子地）读共享数据，其过程如下：</p>
<pre><code>rwLock-&gt;startRead();
read shared data
rwLock-&gt;doneRead();
</code></pre>
<p>类似的，一个线程想要（原子地）写共享数据，其过程如下：</p>
<pre><code>rwLock-&gt;startWrite();
Read and write shared data
rwLock-&gt;doneWrite();
</code></pre>
<p>为了设计 RWLock 类，我们首先定义它的接口（如上面代码所示），和它的共享状态。这里，对象的行为可以通过<strong>正在读和正在写的线程的数量和等待读和等代写的线程的数量</strong>来刻画。所以，我们需要 4 个整数来追踪这些值。 代码 5.9 展示了 RWLock 类的成员和接口. 接下来，我们通过提出以下的问题来添加同步变量，“什么时候方法需要等待？”首先，我们添加一个互斥锁：保证当有线程在访问 RWLock 的方法的时候，其他访问 RWLock 的方法的线程必须等待。接下来，我们观察到 startRead 或 startWrite 可能需要等待，因此我们为每种情况添加了一个条件变量：readGo 和 writeGo.</p>
<h2 id="读者写者锁的接口和成员变量">读者/写者锁的接口和成员变量</h2>
<pre><code>class RWLock{
    private:
        //Synchronization variables
        Lock lock;
        CV readGo;
        CV writeGo;

        // State variables
        int activeReaders;
        int activeWriters;
        int waitingReaders;
        int waitingWriters;
    public:
        RWLock();
        ~RWLock(){};
        void startRead();
        void doneRead();
        void startWrite();
        void doneWrite();
    private:
        bool readShouldWait();
        bool writeShouldWait();
} 
</code></pre>
<p>代码 5.9：  我们的读者/写者锁的接口和成员变量<br>
RWLock: doneRead 和 doneWrite 不需要等待（不包括获取互斥锁）。因此，这些方法不需要额外的条件变量。<br>
现在我们实现 RWLock。<br>
首先，我们先给每个方法添加上锁的获取和锁的释放。如下图所示：</p>
<pre><code>void RWLock :: startRead(){
    lock.acquire();

    lock.release();
}

void RWLock::doneRead(){
    lock.acquire();

    lock.release();
}
</code></pre>
<p>RWLock::startWrite 和 RWLock::doneWrite 也类似。</p>
<p>由于我们知道 startRead 和 startWrite 必须等待，因此我们可以在每个方法的中间写上while(…){wait();}的循环。然后，我们开始思考其中的细节，例如循环等待的判断条件。代码 5.10 展示了完整的解法。</p>
<h2 id="读者写者锁完整代码">读者写者锁完整代码</h2>
<pre><code>// Wait until no active or waiting writers,then proceed
void RWLock::startRead(){
    lock.acquire();
    waitingReaders++;
    while(readShouldWait()){
        readGo.Wait(&amp;lock);
    }
    waitingReaders--;
    activeReaders++;
    lock.release();
}

// Done reading.If no other active readers,a write may proceed.
void RWLock::doneRead(){
    lock.acquire();
    activeReaders--;
    if(activeReaders == 0 &amp;&amp; waitingWriters &gt; 0){
        writeGo.signal();
    }
    lock.release();
}

// Read waits if any active or waiting write(&quot;writers preferred&quot;).
bool RWLock::readShouldWait(){
    return (activeWriters &gt; 0 || waitingWriters &gt; 0);
}

// Wait until no active read or write then proceed;
void RWLock::startWrite(){
    lock.acquire();
    waitingWriterw++;
    while(writeShouldWait()){
        writeGo.Wait(&amp;lock);
    }
    waitingWriters--;
    activeWriters++;
    lock.release();
}

// Done writing. A waiting write or read may proceed.
void RWLock::doneWrite(){
    lock.acquire();
    activeWriters--;
    assert(activeWriters == 0);
    if(waitingWriters &gt; 0){
        writeGo.signal();
    }else{
        readGo.broadcast();
    }
    lock.release();
}

// Write waits for active read or write.
bool RWLock::writeShouldWait(){
    return(activeWriters &gt; 0 || activeReaders &gt; 0);
}
</code></pre>
<p>代码 5.10：  一个读者写者锁的实现</p>
]]></content>
    </entry>
</feed>