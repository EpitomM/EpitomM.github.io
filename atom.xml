<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://epitomm.github.io</id>
    <title>SSM</title>
    <updated>2020-03-24T12:05:13.188Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://epitomm.github.io"/>
    <link rel="self" href="https://epitomm.github.io/atom.xml"/>
    <subtitle>热心善良的老学姐</subtitle>
    <logo>https://epitomm.github.io/images/avatar.png</logo>
    <icon>https://epitomm.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, SSM</rights>
    <entry>
        <title type="html"><![CDATA[面试题系列 —— Java 集合]]></title>
        <id>https://epitomm.github.io/post/mian-shi-ti-xi-lie-java-ji-he/</id>
        <link href="https://epitomm.github.io/post/mian-shi-ti-xi-lie-java-ji-he/">
        </link>
        <updated>2020-03-24T11:57:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-说一说-list-set-map-三者的区别">1. 说一说 List、Set、Map 三者的区别</h1>
<ul>
<li>List 是存储有序的集合</li>
<li>Set 集合元素不可重复</li>
<li>Map 是存储键值对的集合</li>
</ul>
<h1 id="2-arraylist-与-linkedlist-的区别">2. ArrayList 与 LinkedList 的区别</h1>
<ol>
<li>底层存储数据结构：</li>
</ol>
<ul>
<li>ArrayList 初始容量时 10，底层是 Object 数组，所以具有数组的特性，可随机访问，并且实现了RandomAccess 接口标识支持随机访问。</li>
<li>LinkedList 底层是双向链表，所以具有双向链表的特性，增删速度快，但每个节点都有维护前后两个指针，占用存储空间较大。</li>
</ul>
<ol start="2">
<li>增删查效率：</li>
</ol>
<ul>
<li>ArrayList 如果添加到末尾，时间复杂度 O(1)；如果添加中间到指定 i 位置，需要把 i ~ n 位置的元素统一向后移动，时间复杂度 O(n-i)。如果按下标查找，时间复杂度O(1)</li>
<li>LinkedList 如果添加末尾，时间复杂度 O(1)，如果插入到中间第 i 个位置，需要先查找到到 i 个位置的元素，查找效率 O(n)，然后执行添加操作，修改指针指向，复杂度 O(1)。如果按下标查找，需要判断下标是否大于当前 size/2 ，如果大于则从末尾向中间查找；否则从头向中间查找，时间复杂度 O(n)</li>
</ul>
<h1 id="3-arraylist-扩容机制">3. ArrayList 扩容机制</h1>
<pre><code>private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}
</code></pre>
<blockquote>
<p>上述代码基于 JDK1.8</p>
</blockquote>
<h1 id="4-arraylist-和-vector-的区别">4. ArrayList 和 Vector 的区别</h1>
<p>线程安全</p>
<ul>
<li>ArrayLis 线程不安全</li>
<li>Vector 方法都使用 synchronized 修饰，所以线程安全，同时效率也低。正因为 Vector 效率低，所以一般不会使用，如果想实现同步，可以使用 Collections.synchronizedList(new ArrayList&lt;&gt;());</li>
</ul>
<p>扩容机制：</p>
<ul>
<li>ArrayList 扩容后的容量为原来的 1.5 倍</li>
<li>Vector 扩容后的容量 是原来的 2 倍</li>
</ul>
<h1 id="5-hashmap-和-hashtable的区别">5. HashMap 和 Hashtable的区别</h1>
<p>线程安全：</p>
<ul>
<li>HashMap 线程不安全</li>
<li>Hashtable 的方法使用 synchronized 修饰，所以线程安全，也是正因为用 synchronized 修饰，所以效率较低。</li>
</ul>
<p>初始大小扩容机制：</p>
<ul>
<li>HashMap 的默认初始容量为 16（2 &lt;&lt; 4）；如果指定了初始容量，会把它扩充为 2 的幂次。扩容后容量为原来的 2n</li>
<li>Hashtable 默认初始容量时 11，如果指定初始容量，使用初始容量。扩容后容量为原来的 2n+1</li>
</ul>
<p>是否允许 null 键值</p>
<ul>
<li>HashMap 允许 null 键值</li>
<li>Hashtable 不允许 null 键值</li>
</ul>
<h1 id="6-hashmap-的-put-方法的具体流程">6. HashMap 的 put 方法的具体流程</h1>
<pre><code>public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node&lt;K,V&gt; e; K k;
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            e = p;
        else if (p instanceof TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        else {
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    if (++size &gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/put.png" alt="图片" loading="lazy"></figure>
<ol>
<li>如果散列表为 null，resize() 初始化散列表</li>
<li>没有发生碰撞，直接添加元素到散列表中</li>
<li>如果发生碰撞，判断时红黑树还是链表，然后调用相应的插入方法</li>
<li>HashMap 的 resize() 扩容方法</li>
</ol>
<h1 id="7-hashmap-的-resize-扩容方法">7. HashMap 的 resize() 扩容方法</h1>
<p>如果当前容量 &gt; 阈值（容量 * 装填因子），则扩容</p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/resize.png" alt="图片" loading="lazy"></figure>
<h1 id="8-hashmap-容量为什么是-2-的幂次">8. HashMap 容量为什么是 2 的幂次</h1>
<p>减少 hash 冲突，因为要用 hash &amp; (n-1) 确定元素存在数组中的下标位置，如果 n 是 2 的幂（1000），那么 n-1 得到的结果就全为 1 （10000 - 1 = 1111），这样 (n-1) &amp; hash 的值就是 hash。如果 n-1 中有某位为 0，那么 0 与任何数 &amp; 结果都为0，增加了hash 冲突的概率。</p>
<h1 id="9-hashmap-17-18-对比">9. HashMap 1.7 1.8 对比</h1>
<ul>
<li>JDK 1.7</li>
</ul>
<p>数据结构：数组+链表</p>
<p>JDK 1.7 hash 方法：9 次扰动（4 次位运算，5 次异或运算）</p>
<pre><code>static int hash(int h) {
    // This function ensures that hashCodes that differ only by
    // constant multiples at each bit position have a bounded
    // number of collisions (approximately 8 at default load factor).
    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
}
</code></pre>
<ul>
<li>JDK 1.8</li>
</ul>
<p>数据结构：数组 + 链表 + 红黑树</p>
<p>JDK 1.8 hash 方法：2 次扰动（1 次位运算，1 次异或运算）</p>
<pre><code>static final int hash(Object key) {
    int h;
    // key.hashCode()：返回散列值也就是hashcode
    // ^ ：按位异或
    // &gt;&gt;&gt;:⽆符号右移，忽略符号位，空位都以0补⻬
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}
</code></pre>
<p>贴一张比较详细的图：<br>
<img src="https://epitomm.github.io/post-images/hashmap.png" alt="图片" loading="lazy"></p>
<p>图片来源；<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247485685&amp;idx=2&amp;sn=b393e444487c88e8c204821faddff370&amp;chksm=ebd749f4dca0c0e257e15c656f4504f224456495ad78e8aeb9ea370214ebd4b5c455b15e6045&amp;token=1948873548&amp;lang=zh_CN#rd">https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247485685&amp;idx=2&amp;sn=b393e444487c88e8c204821faddff370&amp;chksm=ebd749f4dca0c0e257e15c656f4504f224456495ad78e8aeb9ea370214ebd4b5c455b15e6045&amp;token=1948873548&amp;lang=zh_CN#rd</a></p>
<h1 id="10-hashmap-是怎么解决哈希冲突的">10. HashMap 是怎么解决哈希冲突的</h1>
<p>什么是哈希冲突：两个不同的输入值，根据同一散列函数，计算出相同的散列值。</p>
<ul>
<li>使用<strong>拉链法</strong>来链接具有相同 hash 值的数据</li>
<li>使用<strong>两次扰动函数</strong>（hash 函数）来降低哈希冲突的概率，使得<strong>数据分布更均匀</strong></li>
<li>引入<strong>红黑树</strong>降低查找的时间复杂度</li>
</ul>
<h1 id="11-hashmap-17-18多线程操作导致死循环问题">11. HashMap 1.7 1.8多线程操作导致死循环问题</h1>
<p>参考链接：<a href="https://coolshell.cn/articles/9606.html">https://coolshell.cn/articles/9606.html</a></p>
<h1 id="12-hashmap-的-key-值要是为类对象则该类需要满足什么条件">12. HashMap 的 key 值要是为类对象则该类需要满⾜什么条件？</h1>
<p><strong>重写 hashCode() 和 equals() 方法。</strong></p>
<p>Hashmap 中放入相同的 key，会覆盖 value 值，而不是重新添加一个 key-value 对，这就要求我们判断 key 是否相同。</p>
<p>以下为 HashMap 的 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) 方法：</p>
<pre><code>if (p.hash == hash &amp;&amp;
    ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
</code></pre>
<p>从源码得知判断分为三个步骤：①判断 key 的 hash 值是否相同，这就要求我们重写 hashCode() 方法；② 通过 == 判断 key 对象引用是否相等；③ 使用 equals() 判断对象是否相等，这就要求我们重写 equals() 方法。</p>
<h1 id="13-concurrenthashmap-的底层实现方式">13. ConcurrentHashMap 的底层实现方式</h1>
<p>JDK 1.7</p>
<ul>
<li>数据结构：分段数组（Segment 继承了 ReentrantLock，每个段都有一个锁） + 链表（HashEntry）</li>
<li>线程安全：对整个桶数组进行了分割分段，每把锁只锁住一段，多线程访问其他段的数据时不会产生冲突。</li>
</ul>
<p>JDK 1.8</p>
<ul>
<li>数据结构：数组 + 链表 + 红黑树</li>
<li>线程安全：部分锁定 + CAS。synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发。</li>
</ul>
<h1 id="14-concurrenthashmap-和-hashtable-的区别">14. ConcurrentHashMap 和 Hashtable 的区别</h1>
<p>Hashtable 数据结构：数组 + 链表</p>
<p>Hashtable 实现线程安全：会锁住整个数组，某个线程在进行 put 操作时，其他线程只能阻塞。</p>
<h1 id="15-如何选用集合">15. 如何选用集合</h1>
<ul>
<li>如果存储键值对，选 Map 接口下的集合
<ul>
<li>如果需要排序，选择 TreeMap</li>
<li>如果不需要排序，优先选择 HashMap</li>
<li>如果需要线程安全，选择 ConcurrentHashMap</li>
</ul>
</li>
<li>只需要存放元素值时，选择 Collection 接口下的集合
<ul>
<li>如果需要顺序放取，选择 ArrayList</li>
<li>如果需要频繁增删，选择 LinkedList</li>
<li>如果需要元素不重复且排序，选择 TreeSet</li>
<li>如果需要元素不重复但无需排序，优先选择 HashSet</li>
</ul>
</li>
</ul>
<p>参考链接：</p>
<p><a href="https://github.com/ZhongFuCheng3y/3y">https://github.com/ZhongFuCheng3y/3y</a></p>
<p><a href="https://github.com/Snailclimb/JavaGuide">https://github.com/Snailclimb/JavaGuide</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试题系列 —— Zookeeper]]></title>
        <id>https://epitomm.github.io/post/zookeeper-mian-shi-ti/</id>
        <link href="https://epitomm.github.io/post/zookeeper-mian-shi-ti/">
        </link>
        <updated>2020-03-14T15:40:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-谈谈你对-zookeeper-的认识">1. 谈谈你对 Zookeeper 的认识</h1>
<p><code>Zookeeper</code> 是一个<strong>分布式协调服务</strong>的开源框架。主要用来解决分布式集群中应用系统的<strong>一致性</strong>问题，例如怎样避免同时操作同一数据造成脏读的问题。</p>
<p><strong><code>ZooKeeper</code> 本质上是一个分布式的小文件存储系统</strong>。提供基于类似于文件系统的目录树方式的数据存储，并且可以对树中的节点进行有效管理。从而用来维护和监控你存储的数据的状态变化。通过监控这些数据状态的变化，从而可以达到基于数据的集群管理。诸如：统一命名服务、分布式配置管理、分布式消息队列、分布式锁、分布式协调等功能。</p>
<h1 id="2-zookeeper-特性">2. ZooKeeper 特性</h1>
<ol>
<li><strong>全局数据一致</strong>：集群中每个服务器保存一份相同的数据副本，<code>client</code> 无论连接到哪个服务器，展示的数据都是一致的，这是最重要的特征；</li>
<li><strong>可靠性</strong>：如果消息【<strong>增、删、改、查</strong>】被其中一台服务器接受，那么将被所有的服务器接受。</li>
<li><strong>顺序性</strong>：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息 a 在消息 b 前发布，则在所有 <code>Server</code> 上消息 a 都将在消息 b 前被发布；偏序是指如果一个消息 b 在消息 a 后被同一个发送者发布，a 必将排在 b 前面。</li>
<li><strong>数据更新原子性</strong>：一次数据更新要么成功（半数以上节点成功），要么失败，不存在中间状态。</li>
<li><strong>实时性</strong>：<code>Zookeeper</code> 保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。</li>
</ol>
<h1 id="3-zookeeper-数据模型">3． ZooKeeper 数据模型</h1>
<p><code>ZooKeeper</code> 的数据模型，在结构上和标准文件系统的非常相似，拥有一个层次的命名空间，都是采用<strong>树形层次结构</strong>，<code>ZooKeeper</code> 树中的每个节点被称为— <strong><code>Znode</code></strong>。和文件系统的目录树一样，<code>ZooKeeper</code> 树中的每个节点可以拥有子节点。但也有不同之处：</p>
<ol>
<li><strong><code>Znode</code> 兼具文件和目录两种特点</strong>。既像文件一样维护着数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分，并可以具有子 <code>Znode</code>。用户对 <code>Znode</code> 具有增、删、改、查等操作（权限允许的情况下）。</li>
<li><strong><code>Znode</code> 具有原子性操作</strong>，读操作将获取与节点相关的所有数据，写操作也将替换掉节点的所有数据。另外，每一个节点都拥有自己的 ACL(访问控制列表)，这个列表规定了用户的权限，即限定了特定用户对目标节点可以执行的操作。</li>
<li><strong><code>Znode</code> 存储数据大小有限制</strong>。<code>ZooKeeper</code> 虽然可以关联一些数据，但并没有被设计为常规的数据库或者大数据存储，相反的是，它用来管理调度数据，比如分布式应用中的配置文件信息、状态信息、汇集位置等等。这些数据的共同特性就是它们都是很小的数据，<strong>通常以 KB 为大小单位</strong>。ZooKeeper 的服务器和客户端都被设计为严格检查并限制每个 Znode 的数据大小至多 1M，当时常规使用中应该远小于此值。</li>
<li><strong><code>Znode</code> 通过路径引用</strong>，如同 <code>Unix</code> 中的文件路径。<strong>路径必须是绝对的</strong>，因此他们必须<strong>由斜杠字符来开头</strong>。除此以外，他们必须是唯一的，也就是说每一个路径只有一个表示，因此这些路径不能改变。在 <code>ZooKeeper</code> 中，路径由 <code>Unicode</code> 字符串组成，并且有一些限制。字符串&quot;/zookeeper&quot;用以保存管理信息，比如关键配额信息。</li>
</ol>
<h2 id="31数据结构图">3.1．数据结构图</h2>
<p><img src="https://epitomm.github.io/post-images/1584240732240.jpg" alt="" loading="lazy"><br>
图中的每个节点称为一个 <code>Znode</code>。 每个 <code>Znode</code> 由 3 部分组成:</p>
<ul>
<li><code>stat</code>：此为状态信息, 描述该 <code>Znode</code> 的版本, 权限等信息</li>
<li><code>data</code>：与该 <code>Znode</code> 关联的数据</li>
<li><code>children</code>：该 <code>Znode</code> 下的子节点</li>
</ul>
<h2 id="32节点类型">3.2．节点类型</h2>
<p><code>Znode</code> 有两种，分别为<strong>临时节点</strong>和<strong>永久节点</strong>。</p>
<p>节点的类型<strong>在创建时即被确定，并且不能改变。</strong></p>
<p><strong>临时节点</strong>：该节点的生命周期依赖于创建它们的会话。一旦<strong>会话结束，临时节点将被自动删除</strong>，当然可以也可以手动删除。<strong>临时节点不允许拥有子节点</strong>。</p>
<p><strong>永久节点</strong>：该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，他们才能被删除。</p>
<p><code>Znode</code> 还有一个<strong>序列化</strong>的特性，如果创建的时候指定的话，该 <code>Znode</code> 的名字后面会<strong>自动追加一个不断增加的序列号</strong>。序列号对于此节点的父节点来说是唯一的，这样便会<strong>记录每个子节点创建的先后顺序</strong>。它的格式为“%10d”(10 位数字，没有数值的数位用 0 补充，例如“0000000001”)。</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/1584240804281.jpg" alt="" loading="lazy"></figure>
<p>这样便会存在四种类型的 <code>Znode</code> 节点，分别对应：</p>
<ul>
<li><code>PERSISTENT</code>：永久节点</li>
<li><code>EPHEMERAL</code>：临时节点</li>
<li><code>PERSISTENT_SEQUENTIAL</code>：永久节点、序列化</li>
<li><code>EPHEMERAL_SEQUENTIAL</code>：临时节点、序列化</li>
</ul>
<h1 id="4-zookeeper-watcher">4． ZooKeeper Watcher</h1>
<p><code>ZooKeeper</code> 提供了分布式数据<strong>发布/订阅功能</strong>，一个典型的发布/订阅模型系统定义了一种一对多的订阅关系，能让多个订阅者同时监听某一个主题对象，当这个主题对象自身状态变化时，会通知所有订阅者，使他们能够做出相应的处理。</p>
<p><code>ZooKeeper</code> 中，引入了 <strong>Watcher 机制来实现这种分布式的通知功能</strong> 。 <code>ZooKeeper</code> 允许客户端向服务端注册一个 <code>Watcher</code> 监听，当服务端的一些事件触发了这个 <code>Watcher</code>，那么就会向指定客户端发送一个事件通知来实现分布式的通知功能。</p>
<p>触发事件种类很多，如：节点创建，节点删除，节点改变，子节点改变等。</p>
<p>总的来说可以概括 <code>Watcher</code> 为以下三个过程：<strong>客户端向服务端注册 <code>Watcher</code>、服务端事件发生触发 <code>Watcher</code>、客户端回调 <code>Watcher</code> 得到触发事件情况</strong></p>
<h2 id="41-watch-机制特点">4.1． Watch 机制特点</h2>
<h3 id="一次性触发"><strong>一次性触发</strong></h3>
<p>事件发生触发监听，一个 <code>watcher event</code> 就会被发送到设置监听的客户端，这种效果是一次性的，后续再次发生同样的事件，不会再次触发。</p>
<h3 id="事件封装"><strong>事件封装</strong></h3>
<p><code>ZooKeeper</code> 使用 <code>WatchedEvent</code> 对象来封装服务端事件并传递。</p>
<p><code>WatchedEvent</code> 包含了每一个事件的三个基本属性：</p>
<p><strong>通知状态（<code>keeperState</code>），事件类型（<code>EventType</code>）和节点路径（<code>path</code>）</strong></p>
<h3 id="event-异步发送"><strong>event 异步发送</strong></h3>
<p><code>watcher</code> 的通知事件从服务端发送到客户端是异步的。</p>
<h3 id="先注册再触发"><strong>先注册再触发</strong></h3>
<p><code>Zookeeper</code> 中的 <code>watch</code> 机制，必须客户端先去服务端注册监听，这样事件发送才会触发监听，通知给客户端。</p>
<h1 id="5-zookeeper-选举机制">5． ZooKeeper 选举机制</h1>
<p><code>zookeeper</code> 默认的算法是 <code>FastLeaderElection</code>，采用投票数大于半数则胜出的逻辑。</p>
<h2 id="51-概念">5.1． 概念</h2>
<p><strong>服务器 ID</strong></p>
<ul>
<li>比如有三台服务器，编号分别是 1,2,3。</li>
<li>编号越大在选择算法中的权重越大。</li>
</ul>
<p><strong>选举状态</strong></p>
<ul>
<li><code>LOOKING</code>，竞选状态。</li>
<li><code>FOLLOWING</code>，随从状态，同步 <code>leader</code> 状态，参与投票。</li>
<li><code>OBSERVING</code>，观察状态,同步 <code>leader</code> 状态，不参与投票。</li>
<li><code>LEADING</code>，领导者状态。</li>
</ul>
<p><strong>数据 ID</strong></p>
<ul>
<li>服务器中存放的最新数据 <code>version</code>。</li>
<li>值越大说明数据越新，在选举算法中数据越新权重越大。</li>
</ul>
<p><strong>逻辑时钟</strong></p>
<p>也叫投票的次数，同一轮投票过程中的逻辑时钟值是相同的。每投完一次票这个数据就会增加，然后与接收到的其它服务器返回的投票信息中的数值相比，根据不同的值做出不同的判断。</p>
<h2 id="52-全新集群选举">5.2． 全新集群选举</h2>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/1584240883089.png" alt="" loading="lazy"></figure>
<p>假设目前有 5 台服务器，<strong>每台服务器均没有数据</strong>，它们的编号分别是1,2,3,4,5,<strong>按编号依次启动</strong>，它们的选择举过程如下：</p>
<ul>
<li>服务器 1 启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器 1 的状态一直属于 <code>Looking</code>。</li>
<li>服务器 2 启动，给自己投票，同时与之前启动的服务器 1 交换结果，由于服务器 2 的编号大所以服务器 2 胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是 <code>LOOKING</code>。</li>
<li>服务器 3 启动，给自己投票，同时与之前启动的服务器 1,2 交换信息，由于服务器 3 的编号最大所以服务器 3 胜出，此时投票数正好大于半数，所以服务器 3 成为领导者，服务器 1,2 成为小弟。</li>
<li>服务器 4 启动，给自己投票，同时与之前启动的服务器 1,2,3 交换信息，尽管服务器 4 的编号大，但之前服务器 3 已经胜出，所以服务器 4 只能成为小弟。</li>
<li>服务器 5 启动，后面的逻辑同服务器 4 成为小弟。</li>
</ul>
<h2 id="53-非全新集群选举">5.3． 非全新集群选举</h2>
<p>对于运行正常的 <code>zookeeper</code> 集群，中途有机器 <code>down</code> 掉，需要重新选举时，选举过程就需要加入<strong>数据 ID</strong>、<strong>服务器 ID</strong> 和<strong>逻辑时钟</strong>。</p>
<p>数据 ID：数据新的 <code>version</code> 就大，数据每次更新都会更新 <code>version</code>。</p>
<p>服务器 ID：就是我们配置的 <code>myid</code> 中的值，每个机器一个。</p>
<p>逻辑时钟：这个值从 0 开始递增,每次选举对应一个值。 如果在同一次选举中,这个值是一致的。</p>
<p>这样选举的标准就变成：</p>
<p>1、逻辑时钟小的选举结果被忽略，重新投票；</p>
<p>2、统一逻辑时钟后，数据 id 大的胜出；</p>
<p>3、数据 id 相同的情况下，服务器 id 大的胜出；根据这个规则选出 <code>leader</code>。</p>
<h1 id="6-zookeeper-典型应用">6． ZooKeeper 典型应用</h1>
<h2 id="61-数据发布与订阅配置中心">6.1． 数据发布与订阅（配置中心）</h2>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/1584241030128.png" alt="" loading="lazy"></figure>
<p>发布与订阅模型，即所谓的配置中心，顾名思义就是<strong>发布者将数据发布到 ZK节点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新</strong>。</p>
<p>应用在启动的时候会主动来获取一次配置，同时，在节点上注册一个 <code>Watcher</code>，这样一来，以后每次配置有更新的时候，都会实时通知到订阅的客户端，从来达到获取最新配置信息的目的。比如：</p>
<p>分布式搜索服务中，索引的元信息和服务器集群机器的节点状态存放在 ZK 的一些指定节点，供各个客户端订阅使用。</p>
<p>注意：适合<strong>数据量很小的场景</strong>，这样数据更新可能会比较快。</p>
<h2 id="62-命名服务naming-service">6.2． 命名服务(Naming Service)</h2>
<p>在分布式系统中，<strong>通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息</strong>。<strong>被命名的实体通常可以是集群中的机器，提供的服务地址，远程对象等等——这些我们都可以统称他们为名字（Name）</strong>。其中较为常见的就是一些分布式服务框架中的服务地址列表。通过调用 ZK 提供的创建节点的 API，能够很容易创建一个<strong>全局唯一的 path</strong>，这个 path 就可以作为一个名称。</p>
<p>阿里巴巴集团开源的分布式服务框架 <strong>Dubbo 中使用 ZooKeeper 来作为其命名服务</strong>，维护全局的服务地址列表。</p>
<h2 id="63-分布式锁">6.3． 分布式锁</h2>
<p>分布式锁，这个主要得益于 <code>ZooKeeper</code> 保证了数据的强一致性。锁服务可以分为两类，一个是<strong>保持独占</strong>，另一个是<strong>控制时序</strong>。</p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/1584241059824.png" alt="" loading="lazy"></figure>
<p>所谓<strong>保持独占</strong>，就是所有试图来获取这个锁的客户端，最终只有一个可以成功获得这把锁。通常的做法是把 zk 上的一个 <code>znode</code> 看作是一把锁，通过 <code>create znode</code> 的方式来实现。所有客户端都去创建 <code>/distribute_lock</code> <strong>临时非序列化</strong>节点，最终成功创建的那个客户端也即拥有了这把锁。</p>
<p><strong>控制时序</strong>，就是所有试图来获取这个锁的客户端，最终都是会被安排执行，只是有个全局时序了。做法和上面基本类似，只是这里<code>/distribute_lock</code> 已经预先存在，客户端在它下面创建<strong>临时有序</strong>节点（这个可以通过节点的属性控制：<code>CreateMode.EPHEMERAL_SEQUENTIAL</code> 来指定）。Zk 的父节点（<code>/distribute_lock</code>）</p>
<p>维持一份 <code>sequence</code>,保证子节点创建的时序性，从而也形成了每个客户端的全局时序。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Gridea 检测远程连接失败]]></title>
        <id>https://epitomm.github.io/post/gridea-jian-ce-yuan-cheng-lian-jie-shi-bai/</id>
        <link href="https://epitomm.github.io/post/gridea-jian-ce-yuan-cheng-lian-jie-shi-bai/">
        </link>
        <updated>2020-02-18T16:09:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="问题一">问题一</h1>
<h3 id="我的环境">我的环境</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows10</td>
</tr>
<tr>
<td>软件版本</td>
<td>0.9.1</td>
</tr>
<tr>
<td>主题名称</td>
<td>Notes</td>
</tr>
</tbody>
</table>
<h2 id="问题描述">问题描述</h2>
<p>根据教程设置好一系列信息，经测试域名可访问，并且确保其他信息均正确</p>
<p>检查远程连接错误：<strong>远程连接失败,请检查仓库、用户名和 token 设置</strong></p>
<h2 id="问题分析">问题分析</h2>
<ol>
<li>先查看 <code>Gridea</code> 文件存储目录：C:\Users\Only\Documents\Gridea\output.git 下的 config 文件，看是否有 [remote &quot;origin&quot;] 信息，如果没有自行添加</li>
</ol>
<pre><code>[remote &quot;origin&quot;]
	url = https://你的github用户名:Token@github.com/你的github用户/仓库名
	fetch = +refs/heads/*:refs/remotes/origin/*
</code></pre>
<p>附：查看<code>Gridea</code>文件存储目录<br>
<img src="https://epitomm.github.io/post-images/1582604204611.png" alt="" loading="lazy"></p>
<ol start="2">
<li>检查错误信息：<br>
<img src="https://epitomm.github.io/post-images/1582041933549.png" alt="" loading="lazy"></li>
</ol>
<blockquote>
<p>[<em>&quot;fatal: unable to access 'https://github.com/Epitom…led to connect to github.com port 443: Timed out↵&quot;</em>]</p>
</blockquote>
<h2 id="问题解决">问题解决</h2>
<ol>
<li>谷歌 433 错误，得知是<strong>没有设置代理服务器</strong>的原因。</li>
</ol>
<p>以下为网上一高赞解决方式，可自行尝试，（不过对我的问题无效果）<br>
参考链接：<a href="https://blog.csdn.net/runningman2012/article/details/54633677">https://blog.csdn.net/runningman2012/article/details/54633677</a></p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/1582604339501.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>再次谷歌 git 如何设置代理服务器</li>
</ol>
<pre><code>git config --global http.proxy 'socks5://127.0.0.1:1080'

git config --global https.proxy 'socks5://127.0.0.1:1080'
</code></pre>
<p>参考：<a href="https://blog.csdn.net/isea533/article/details/84748009">https://blog.csdn.net/isea533/article/details/84748009</a></p>
<ol start="3">
<li>再次尝试检测远程连接成功</li>
</ol>
<p>接下来同步查看效果完成后就可以开启开心的写作之旅啦~</p>
<h1 id="问题二">问题二</h1>
<h3 id="我的环境-2">我的环境</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows10</td>
</tr>
<tr>
<td>软件版本</td>
<td>0.9.2</td>
</tr>
<tr>
<td>主题名称</td>
<td>Notes</td>
</tr>
</tbody>
</table>
<h2 id="问题描述-2">问题描述</h2>
<p>版本更新到 0.9.2 后重新安装了 Gridea ，再次检测远程连接失败</p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/1582604400732.png" alt="" loading="lazy"></figure>
<p>错误信息</p>
<pre><code>connect ETIMEDOUT 140.82.114.4:443
</code></pre>
<h2 id="问题分析-2">问题分析</h2>
<ol>
<li>cmd 命令行 ping github.com 失败。代理问题</li>
</ol>
<h2 id="问题解决-2">问题解决</h2>
<ol start="2">
<li>
<p>使用 ping 检测工具找一个能够 ping 通 github.com 的 IP，检测工具网址如下：</p>
<p><a href="http://ping.chinaz.com/github.com">http://ping.chinaz.com/github.com</a></p>
</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/1582041969896.png" alt="" loading="lazy"></figure>
<ol start="3">
<li>选择一个响应较快的 IP，添加到 C:\Windows\System32\drivers\etc\host 文件末尾：</li>
</ol>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/1582041983918.png" alt="" loading="lazy"></figure>
<pre><code>140.82.113.3 github.com
</code></pre>
<ol start="4">
<li>再次检测远程连接，成功。</li>
</ol>
]]></content>
    </entry>
</feed>