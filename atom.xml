<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://epitomm.github.io</id>
    <title>SSM</title>
    <updated>2020-04-28T09:48:14.530Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://epitomm.github.io"/>
    <link rel="self" href="https://epitomm.github.io/atom.xml"/>
    <subtitle>热心善良的老学姐</subtitle>
    <logo>https://epitomm.github.io/images/avatar.png</logo>
    <icon>https://epitomm.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, SSM</rights>
    <entry>
        <title type="html"><![CDATA[Java 并发——并发锁和并发工具]]></title>
        <id>https://epitomm.github.io/post/java-bing-fa-bing-fa-suo-he-bing-fa-gong-ju/</id>
        <link href="https://epitomm.github.io/post/java-bing-fa-bing-fa-suo-he-bing-fa-gong-ju/">
        </link>
        <updated>2020-04-28T08:13:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-并发锁">一、并发锁</h1>
<h2 id="reentrantlock">ReentrantLock</h2>
<ul>
<li>一个<strong>可重入互斥Lock</strong>，具有与使用synchronized方法和语句访问的隐式监视锁相同的基本行为和语义，但具有<strong>扩展功能</strong>。</li>
</ul>
<pre><code class="language-java"> class X { 
   
   private final ReentrantLock lock = new ReentrantLock(); 
   // ... 
   
   public void m() { 
     lock.lock(); // block until condition holds 
     try { 
       // ... method body 
     } finally { 
       lock.unlock() 
     } 
  } 
  
} 
</code></pre>
<ul>
<li>构造方法：
<ul>
<li>ReentrantLock()：创建一个 ReentrantLock的实例。</li>
<li>ReentrantLock(boolean fair)：根据给定的<strong>公平</strong>政策创建一个 ReentrantLock的实例。</li>
</ul>
</li>
</ul>
<h2 id="reentrantreadwritelock">ReentrantReadWriteLock</h2>
<ul>
<li>ReadWriteLock</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/ReentrantReadWriteLock.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">ReadWriteLock 类的方法</center>
<ul>
<li>write.unlock()写锁释放之前要加读锁read.lock()：锁降级：从写锁降级到读锁</li>
</ul>
<h1 id="二-并发工具">二、并发工具</h1>
<p>航班查询：APP ---&gt;多个线程到不同的公司查询 ---&gt; 全部线程都查询完毕后，整理结果 result 返回给前台用户。</p>
<h2 id="1-countdownlatch">1. CountDownLatch</h2>
<h3 id="countdownlatch-用法">CountDownLatch 用法</h3>
<ul>
<li>CountDownLatch 类位于java.util.concurrent包下，利用它可以实现类似<strong>计数器</strong>的功能。</li>
<li>比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch 来实现这种功能了。</li>
<li>CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。</li>
</ul>
<h3 id="countdownlatch-如何工作">CountDownLatch 如何工作</h3>
<ul>
<li>构造方法
<ul>
<li>CountDownLatch(int count)：构造一个以给定计数初始化的CountDownLatch。</li>
<li>构造器的计数值（count）实际上就是闭锁需要等待的线程数量。这个值只能被设置一次，而且CountDownLatch 没有提供任何机制去重新设置这个计数值。</li>
<li>与CountDownLatch的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用CountDownLatch.await() 方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</li>
<li>其他N个线程必须引用闭锁对象，因为他们需要通知CountDownLatch对象，他们已经完成了各自的任务。这种通知机制是通过CountDownLatch.countDown() 方法来完成的；每调用一次这个方法，在构造函数中初始化的count值就减1。所以当N个线程都调用了这个方法，count的值等于0，然后主线程就能通过await() 方法，恢复执行自己的任务。</li>
</ul>
</li>
<li>await()
<ul>
<li>使当前线程在锁存器倒计时至零前一直等待，除非线程被中断。</li>
<li>当 count 减少到零时，唤醒当前线程</li>
</ul>
</li>
<li>countDown()
<ul>
<li>递减锁存器的计数，如果计数达到零，则释放所有等待。</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/CountDownLatch.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">CountDownLatch 航班查询流程图</center>
<h3 id="示例">示例</h3>
<pre><code class="language-java">package luban;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
public class FightQueryDemo {
    private static List&lt;String&gt; company = Arrays.asList(&quot;东方航空&quot;,&quot;南方航空&quot;,&quot;海南航空&quot;);
    // 结果列表
    private static List&lt;String&gt; fightList = new ArrayList&lt;&gt;();
    public static void main(String[] args) throws InterruptedException {
        // 出发地
        String origin = &quot;BJ&quot;;
        // 目的地
        String dest = &quot;SH&quot;;
        // 定义门闩
        CountDownLatch latch = new CountDownLatch(company.size());
        // 创建线程池
        ExecutorService service = Executors.newCachedThreadPool();
        // 创建线程
        for (int i = 0; i &lt; company.size(); i++) {
            String name = company.get(i);
            service.execute(() -&gt; {
                // 获取公司名称
                System.out.println(name + &quot;查询从&quot; + origin + &quot;到&quot; + dest + &quot;的机票&quot;);
                // 生成随机数表示此公司机票数量
                int val = new Random().nextInt(10);
                try {
                    TimeUnit.SECONDS.sleep(val);
                    fightList.add(name + &quot;:&quot; + val);
                    System.out.println(name + &quot;查询成功！&quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 这个公司查询完毕，门闩 - 1
                latch.countDown();
            });
        }
        service.shutdown();
        // 等待所有线程结束
        latch.await();
        System.out.println(&quot;==== 查询结果如下 ====&quot;);
        System.out.println(fightList);
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>东方航空查询从BJ到SH的机票
海南航空查询从BJ到SH的机票
南方航空查询从BJ到SH的机票
海南航空查询成功！
南方航空查询成功！
东方航空查询成功！
==== 查询结果如下 ====
[海南航空:6, 南方航空:7, 东方航空:7]
</code></pre>
<h2 id="2-cyclicbarries">2. CyclicBarries</h2>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/CyclicBarries.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">CyclieBarries 模拟运动员跑步比赛</center>
<h3 id="cyclicbarrier用法">CyclicBarrier用法</h3>
<ul>
<li>字面意思<strong>回环栅栏</strong>，通过它可以实现让一组线程等待至某个状态之后再<strong>全部同时执行</strong>。</li>
<li>叫做回环是因为<strong>当所有等待线程都被释放以后</strong>，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用awai() 方法之后，线程就处于barrier了。</li>
<li>赛跑：
<ul>
<li>需要所有的子任务都完成时，才执行主任务，这个时候就可以选择使用CyclicBarrier。</li>
</ul>
</li>
</ul>
<h3 id="基本原理">基本原理：</h3>
<ul>
<li>每个线程执行时，都会碰到一个屏障，直到所有线程执行结束，然后屏障便会打开，使所有线程继续往下执行。</li>
<li>在 CyclicBarrier 的内部定义了一个 Lock 对象，每当一个线调用 await 方法时，将拦截的线程数加减 1，然后判断计数器当前是否等于 0 ，如果不是，进入Lock对象的条件队列等待。如果是，执行 barrierAction 对象的 Runnable 方法，然后将锁的条件队列中的所有线程放入锁等待队列中，这些线程会依次的获取锁、释放锁。</li>
<li>CyclicBarrier的两个<strong>构造函数</strong>：
<ul>
<li>CyclicBarrier（int parties）：声明需要拦截的线程数</li>
<li>CyclicBarrier（int parties，Runnable barierAction）：声明需要拦截的线程数，定义一个等待所有线程到达屏障优先执行的Runnable对象。</li>
</ul>
</li>
</ul>
<pre><code class="language-java">package luban;
import java.util.Random;
import java.util.concurrent.*;
public class RaceDemo {
    public static void main(String[] args) {
        CyclicBarrier barrier = new CyclicBarrier(8);
        ExecutorService service = Executors.newCachedThreadPool();
        for(int i = 0 ; i &lt; 8 ; i++){
            service.execute(() -&gt; {
                try {
                    TimeUnit.SECONDS.sleep(new Random().nextInt(10));
                    System.out.println(Thread.currentThread().getName() + &quot;准备好了&quot;);
                    // 此线程已经准备好，唤醒其他线程
                    barrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
                System.out.println(&quot;选手&quot; + Thread.currentThread().getName() + &quot;起跑&quot;);
            });
        }
        service.shutdown();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>pool-1-thread-8准备好了
pool-1-thread-4准备好了
pool-1-thread-5准备好了
pool-1-thread-2准备好了
pool-1-thread-1准备好了
pool-1-thread-7准备好了
pool-1-thread-3准备好了
pool-1-thread-6准备好了
选手pool-1-thread-6起跑
选手pool-1-thread-8起跑
选手pool-1-thread-5起跑
选手pool-1-thread-4起跑
选手pool-1-thread-3起跑
选手pool-1-thread-7起跑
选手pool-1-thread-1起跑
选手pool-1-thread-2起跑
</code></pre>
<ul>
<li>一般情况下对于两个非常相似的类，我们一般都会想当然地去把他们进行类比。对于CountDownLatch 和CyclicBarrier 两个类，我们可以看到CountDownLatch 类都是一个类似于集结点的概念，很多个线程做完事情之后等待其他线程完成，全部线程完成之后再恢复运行。不同的是CountDownLatch 类需要你自己调用countDown() 方法减少一个计数，然后调用await() 方法即可。而CyclicBarrier 则直接调用await() 方法即可。</li>
<li>所以从上面来看，CountDownLatch更倾向于多个线程合作的情况，等你所有东西都准备好了，我这边就自动执行了。而CyclicBarrier则是我们都在一个地方等你，大家到齐了，大家再一起执行。</li>
</ul>
<h2 id="3-semaphore">3. Semaphore</h2>
<ul>
<li>资源有限共享</li>
<li>停车场为例：</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/Semaphore.png" alt="图片" loading="lazy"></figure>
<pre><code class="language-java">package com.ssm;

import java.util.Random;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

public class CarDemo {
    public static void main(String[] args) throws InterruptedException {
        // 创建 Semaphore
        Semaphore semaphore = new Semaphore(3);
        Thread [] cars = new Thread[10];
        for (int i = 0; i &lt; 10; i++) {
            cars[i] = new Thread(()-&gt;{
                try {
                    // 请求许可
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName() + &quot;可以进入停车场&quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                // 使用资源
                try {
                    int val = new Random().nextInt(5);
                    TimeUnit.SECONDS.sleep(val);
                    System.out.println(Thread.currentThread().getName()+&quot;停留了&quot;+val+&quot;秒&quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 离开（释放资源）
                semaphore.release();
                System.out.println(Thread.currentThread().getName() + &quot;离开了停车场&quot;);
            },&quot;car[&quot;+i+&quot;]&quot;);
            cars[i].start();
        }
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>car[0]可以进入停车场
car[2]可以进入停车场
car[7]可以进入停车场
car[0]停留了0秒
car[0]离开了停车场
car[4]可以进入停车场
car[7]停留了2秒
car[7]离开了停车场
car[8]可以进入停车场
car[2]停留了3秒
car[8]停留了1秒
car[3]可以进入停车场
car[2]离开了停车场
car[5]可以进入停车场
car[8]离开了停车场
car[4]停留了4秒
car[4]离开了停车场
car[1]可以进入停车场
car[3]停留了2秒
car[3]离开了停车场
car[9]可以进入停车场
car[9]停留了0秒
car[9]离开了停车场
car[6]可以进入停车场
car[6]停留了0秒
car[6]离开了停车场
car[1]停留了1秒
car[1]离开了停车场
car[5]停留了3秒
car[5]离开了停车场
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP系列（四）安全的HTTPS]]></title>
        <id>https://epitomm.github.io/post/http-xi-lie-si-an-quan-de-https/</id>
        <link href="https://epitomm.github.io/post/http-xi-lie-si-an-quan-de-https/">
        </link>
        <updated>2020-04-28T04:18:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-http-与-https">一、HTTP 与 HTTPS</h1>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/HTTPS_1.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/HTTPS_2.png" alt="图片" loading="lazy"></figure>
<p>HTTP 协议：超文本传输协议，应用层协议，HTTP 协议通过 请求-响应的方式，在客户端和服务端之间进行通信。HTTP 协议传输<strong>明文</strong>，不安全。</p>
<h2 id="明文信息传输">明文信息传输</h2>
<p>小风向向小萌发出一个请求 “小萌，我喜欢你！” 来表白。</p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E6%98%8E%E6%96%87%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93.png" alt="图片" loading="lazy"></figure>
<h3 id="中间人攻击">中间人攻击</h3>
<p>但是由于传输信息是明文，这个信息可能被某个中间人恶意拦截甚至篡改：<strong>中间人攻击</strong>。</p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E6%98%8E%E6%96%87%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93_%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB.png" alt="图片" loading="lazy"></figure>
<h2 id="加密信息传输">加密信息传输</h2>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93.png" alt="图片" loading="lazy"></figure>
<h3 id="加密算法">加密算法</h3>
<ul>
<li>对称加密：加密、解密使用同一个秘钥</li>
<li>非对称加密：加密、解密使用不同的秘钥，公钥加密私钥解密</li>
</ul>
<h3 id="对称加密传输">对称加密传输</h3>
<p>小风和小萌事先约定好一种加密方式，并且约定一个随机生成的秘钥，后续通信信息的发送方使用秘钥对信息进行加密，信息的接收方使用同一个秘钥对接收到的密文进行解密。</p>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>小风发送聊天请求，小萌回复给小风一个秘钥，小风后面发送的信息都先使用秘钥加密后再发送。后续发送信息都是不可读的密文了。</p>
</blockquote>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93_2.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>如果不知道秘钥，即使拦截到了信息，也没有办法解析和篡改。<br>
但是这样做并不是绝对安全的，虽然在后续的通信中对明文进行了加密，但是<strong>第一次约定加密方式、约定加密方式之后的秘钥的传输</strong>还是用明文。如果第一次通信就已经被拦截了，那么秘钥就会泄露给中间人， 中间人仍可以解密后续所有通信内容。</p>
</blockquote>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93_%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB.png" alt="图片" loading="lazy"></figure>
<h2 id="非对称加密传输">非对称加密传输</h2>
<p>非对称加密的一组秘钥中包含一个公钥和一个私钥，既可以公钥加密私钥解密，也可以私钥加密公钥解密。</p>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_1.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>在小风和小萌建立通信时，小萌首先把自己的公钥 KEY1 发送给小风。</p>
</blockquote>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_2.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>收到小萌的公钥后，小风自己生成一个用于对称加密的公钥 KEY2，这个秘钥是为了后续聊天加密来用的，就是上次被中间人发现的那个秘钥，为了安全不再明文约定发送，而是用刚才接收到的公钥 KEY1 对 KEY2 进行加密，得到 VA3=KEY1(KEY2)，把 VA3 发送给小萌。</p>
</blockquote>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_3.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>小萌可以用自己的非对称加密的私钥，解开公钥 KEY1 的加密，获得了 KEY2 的内容，从此以后用 KEY2 进行加密通信。</p>
</blockquote>
<p>在这个通信过程中，即使中间人一开始就截获了公钥 KEY1，由于不知道私钥是什么，也没有办法去解密。</p>
<h3 id="总结">总结</h3>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_%E6%80%BB%E7%BB%93.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>发送方和接收方都有一套自己的公钥和私钥，公钥是所有人都知道的，私钥只有自己知道。<br>
<strong>发送方使用接收方的公钥进行加密，接收方使用自己的私钥对接收的密文进行解密。</strong></p>
</blockquote>
<h3 id="中间人攻击-2">中间人攻击</h3>
<p>中间人不知道小萌的私钥是什么，但是它截获了小萌的公钥 KEY1 后，可以自己另外生成一对公钥和私钥，把自己的公钥 KEY3 发送给小风，</p>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB_1.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>小风以为 KEY3 就是小萌的公钥，用 KEY3 加密自己生成的对称加密的公钥 KEY2 得到 VA4=KEY3(KEY2)，发送给小萌，中间人用自己的私钥解开 KEY3 加密，获得了 KEY2，然后用小萌发来的 KEY1 重新加密，得到 VAL5，发给小萌。</p>
</blockquote>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93_%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB_2.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>两个人的后续通信尽管一直在用 KEY2 做对称加密，但是中间人已经掌握了 KEY2，就可以轻松地解密获取内容了。</p>
</blockquote>
<h2 id="证书机构">证书机构</h2>
<p><img src="https://epitomm.github.io/post-images/%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84_2.png" alt="图片" loading="lazy"></p>
<blockquote>
<p>小萌把自己的公钥 KEY1 发给证书颁发机构去申请证书，证书颁发机构自己有一对公钥和私钥，机构利用自己的私钥来加密 KEY1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过了机构的私钥加密，这样制作完成一个证书，机构把这个证书发给服务端小萌。</p>
</blockquote>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84_3.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>当后续小风向小萌请求通信时，小萌不再返回自己的公钥，而是直接把自己申请的证书返回给小风。</p>
</blockquote>
<figure data-type="image" tabindex="16"><img src="https://epitomm.github.io/post-images/%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84_4.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>小风收到证书后， 验证证书的真伪，各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥，所以，小风只需要知道是哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书的签名。接下来小风按照同样的签名规则，自己生成一个证书签名，如果两个签名一致，说明证书有效，验证成功后，小风就可以放心地再次利用机构的公钥解密出服务端小萌的公钥 KEY1，小风生成自己对应的对称加密的秘钥 KEY2，并且用服务端公钥 KEY1 加密 KEY2 生成 VA3，发送给小萌。</p>
</blockquote>
<figure data-type="image" tabindex="17"><img src="https://epitomm.github.io/post-images/%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84_5.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>小萌用自己的私钥解开加密得到对称加密的秘钥 KEY2，于是两个人可以开始用 KEY2 进行对称加密通信。</p>
</blockquote>
<h1 id="二-https-协议概述">二、HTTPS 协议概述</h1>
<ul>
<li>HTTPS可以认为是HTTP+TLS。</li>
<li>TLS是传输层加密协议，它的前身是SSL协议。</li>
</ul>
<blockquote>
<p>我们默认 TLS 和 SSL 指的是一个东西。</p>
</blockquote>
<figure data-type="image" tabindex="18"><img src="https://epitomm.github.io/post-images/SSL.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>TLS 建立在 传输层和应用层之间，TLS 实际上是 TCP 之上建立了一个加密通道，TLS 协议主要有五个部分：应用数据层协议、握手协议、报警协议、加密消息确认协议、心跳协议。<br>
目前常用的 HTTP 协议是 HTTP1.1，常用的 TLS 协议版本有：TLS1.2、TLS1.1、TLS1.0 和 SSL3.0 这样几个版本。其中 SSL3.0 由于某种攻击，认为 SSL3.0 协议是不安全的。TLS1.0 也存在部分安全漏洞，TLS1.1 和 TLS1.2 暂时没有已知的安全漏洞。</p>
</blockquote>
<h2 id="https-功能介绍">HTTPS 功能介绍</h2>
<blockquote>
<p>HTTP 本身是明文传输，没有经过任何安全处理，比如在百度搜索一个关键字：小米手机，中间人能够查看这个消息并且有可能打电话推销；在使用百度的过程中，搜索返回的结果页面有广告。这里的中间者主要指网络节点，用户数据在浏览器和百度服务器中间传输必须要经过的那些节点。比如 wifi 热点、路由器、防火墙、反向代理、缓存服务器等，在 HTTP 协议下，中间人可随意窃听用户的搜索内容，窃取客户隐私甚至篡改网页，HTTPS 协议就是这些攻击的克星。</p>
</blockquote>
<ul>
<li>内容加密</li>
</ul>
<blockquote>
<p>浏览器到服务器的内容是以加密的形式传输的，中间者无法查看。</p>
<ul>
<li>非对称秘钥交换</li>
<li>对称内容加密<br>
对称加密的第一步：协商加密算法和秘钥，中间人依然可以在第一次通信时，截获加密方式和秘钥，这样有对称内容加密就安全了一些。<br>
非对称加密用公钥和私钥的方式把正常通信的秘钥 KEY2 协商好，但是在协商过程中，有一步骤是服务器把自己的公钥 KEY1 用明文传给客户端，</li>
</ul>
</blockquote>
<ul>
<li>身份认证</li>
</ul>
<blockquote>
<p>证书的存在保证用户访问的是你想访问的服务，在使用慕课看视频，HTTPS 证书保证了此时访问的一定是慕课网，即使被 DNS 劫持到了第三方站点，也会提醒用户没有访问慕课服务，有可能被劫持。</p>
</blockquote>
<ul>
<li>数据完整性</li>
</ul>
<blockquote>
<p>防止内容被第三方冒充或篡改。</p>
</blockquote>
<h2 id="https-原理介绍">HTTPS 原理介绍</h2>
<ul>
<li>内容加密</li>
</ul>
<p>非对称密钥交换</p>
<blockquote>
<p>非对称加密：公钥和私钥的方式把正常通信的 KEY2 协商好，协商的过程中，服务器把自己的公钥 KEY1 用明文传递给客户端，这里面涉及很多高级算法：对称加密的两种模式：流式加密、分组加密。在秘钥交换的过程中，中间人可以截获 KEY1，换成自己的公钥 KEY3，这样一来中间人依然可以获取正常通信时的秘钥，于是引入了数字证书。</p>
</blockquote>
<p>对称内容加密</p>
<blockquote>
<p>对称加密：协商加密算法和秘钥，中间人可以在第一次通信时拦截加密方式和秘钥。</p>
</blockquote>
<ul>
<li>身份认证</li>
</ul>
<p>数字证书</p>
<blockquote>
<p>服务端向权威机构申请证书。<br>
客户端和服务端通信时，服务端先把证书传递给客户端，客户端收到证书后，用证书机构的公钥解密证书签名，然后用签名生成的规则再生成一个签名，对比一致就是真整数，不一致就是假证书。<br>
如果确认是真证书，解密服务器公钥 KEY1，再生成通信用的秘钥 KEY2，用服务器端的公钥 KEY1 加密，发给服务端。</p>
</blockquote>
<h1 id="三-https-使用成本">三、HTTPS 使用成本</h1>
<ul>
<li>证书费用以及更新维护</li>
<li>HTTPS 降低用户访问速度</li>
<li>消耗CPU资源，需要增加大量机器</li>
</ul>
<h1 id="四-https-对性能的影响">四、HTTPS 对性能的影响</h1>
<ul>
<li>协议交互所增加的网络RTT</li>
</ul>
<blockquote>
<p>RTT：往返时延。从发送端发送数据开始，到发送端收到来自接收端的确认总共经过的时延。</p>
</blockquote>
<ul>
<li>加解密相关的计算耗时</li>
</ul>
<h2 id="网络耗时">网络耗时</h2>
<figure data-type="image" tabindex="19"><img src="https://epitomm.github.io/post-images/HTTP%E7%BD%91%E7%BB%9C%E8%80%97%E6%97%B6.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>HTTP 协议访问网站，交互延迟如上图，用户只需要完成 TCP 三次握手，建立 TCP 连接就能直接发送 HTTP 请求获取应用层数据了。除此之外在访问网络的过程中，也没有需要消耗计算资源的地方。</p>
</blockquote>
<figure data-type="image" tabindex="20"><img src="https://epitomm.github.io/post-images/HTTPS%E7%BD%91%E7%BB%9C%E8%80%97%E6%97%B6.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>HTTPS 访问流程如上图。<br>
① TCP 三次握手建立连接，一个 RTT<br>
② HTTP GET 请求服务端返回 302跳转到 HTTPS，一个 RTT 和 302 跳转时延。因为用户不会手动输入 https 访问网站，比如说百度，用户一般输入 baidu.com，而不会直接输入：https://www.baidu.com，所以服务端只能返回 302 强制浏览器跳转到 HTTPS。<br>
③ 而浏览器处理 302 跳转本身也需要耗时，这个耗时暂且不算，302 跳转到 https 服务器之后，由于端口和服务器不一样，所以需要重新完成三次握手，建立 TCP 连接。耗时一个 RTT。<br>
④ TLS 完全握手阶段1，耗时一个 RTT，这个阶段主要完成加密套件的协商和证书的身份确认。这个阶段下，服务端和浏览器会协商出来相同的秘钥交换算法、对称加密算法、内容一致性校验算法、证书签名算法等。<br>
浏览器获取到证书后，校验证书的有效性，比如证书是否过期，是否撤销等，浏览器首先获取证书里的 CA 域名，如果 CA 域名没有命中缓存的话，浏览器需要解析 CA 域名的 DNS，这个 DNS 解析至少耗费一个 RTT。DNS 解析到 ip 后，三次握手，建立 CA 站点的 TCP 连接，耗时一个 RTT，接着浏览器发送 Ocsp 请求获取响应，耗时一个 RTT,<br>
Ocsp：在线证书状态协议，维护服务器和其他网络资源安全性的两种普遍模式之一。另外一个叫做 CRL 证书注销列表。当用户试图访问一个服务器时，在线证书状态协议发送一个对于证书状态信息的请求，服务器会回复一个有效、过期或者未知的响应。协议规定了服务器和客户端应用程序的通信语法，在线证书状态协议给用户到期的证书一个宽限期，这样他们就可以在更新以前的一段时间继续访问到这个服务器。这里就需要发起对于证书状态信息的请求，也需要消耗一个 RTT。<br>
⑤ TLS 完全握手阶段2：秘钥协商，耗时一个 RTT 和计算时间，这个完全握手结束后，浏览器和服务器之间进行应用层也就是 HTTP 的数据传输。这和 HTTP 的方式几乎是相同的。<br>
一共耗时 7 个 RTT。<br>
如果不是第一次请求，比如 CA 域名解析，如果有缓存的话，就无需进行 DNS 解析，就可以减少一个 RTT。</p>
</blockquote>
<h2 id="计算耗时">计算耗时</h2>
<ul>
<li>浏览器计算耗时</li>
</ul>
<blockquote>
<p>浏览器解析证书签名，秘钥交换，应用层数据加密、解密，一致性的交换</p>
</blockquote>
<ul>
<li>服务端计算耗时</li>
</ul>
<blockquote>
<p>秘钥交换，应用层数据加密、解密耗时。<br>
由于客户端 CPU 和操作系统种类比较多，所以计算耗时不能一概而论。</p>
</blockquote>
<h1 id="五-https-常见问题">五、HTTPS 常见问题</h1>
<ul>
<li>https加密是不是需要我在电脑上安装证书/保存密码？</li>
</ul>
<blockquote>
<p>不需要，操作系统、浏览器把这些操作都做好了</p>
</blockquote>
<ul>
<li>https 不就是在http后面加个s，很难么？</li>
</ul>
<blockquote>
<p>HTTPS 包含证书、流量转发、负载均衡......<br>
小型网站不难，大型网站很难</p>
</blockquote>
<ul>
<li>https 解决了所有劫持问题吗？</li>
</ul>
<blockquote>
<p>https 是为了解决中间人攻击，假设在 https 页面中加载了 http 资源，http 资源还是有劫持的风险，客户端、局域网的风险也很大，恶意插件、木马、路由器、DNS 也都非常脆弱。HTTPS 能够在绝大部分下保证互联网访问数据传输的安全性。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP 系列（三）熟悉 HTTP 协议结构和通讯原理]]></title>
        <id>https://epitomm.github.io/post/http-xi-lie-san-shou-xi-http-xie-yi-jie-gou-he-tong-xun-yuan-li/</id>
        <link href="https://epitomm.github.io/post/http-xi-lie-san-shou-xi-http-xie-yi-jie-gou-he-tong-xun-yuan-li/">
        </link>
        <updated>2020-04-27T04:12:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="http-协议之身份认证">HTTP 协议之身份认证</h1>
<h2 id="身份认证信息">身份认证信息</h2>
<ul>
<li>密码</li>
</ul>
<blockquote>
<p>只有本人才知道的字符串信息</p>
</blockquote>
<ul>
<li>动态令牌</li>
</ul>
<blockquote>
<p>仅限本人持有的设备内显示的一次性密码</p>
</blockquote>
<ul>
<li>数字证书</li>
</ul>
<blockquote>
<p>只有本人终端持有的信息</p>
</blockquote>
<ul>
<li>生物认证</li>
</ul>
<blockquote>
<p>指纹、虹膜</p>
</blockquote>
<ul>
<li>IC 卡等</li>
</ul>
<blockquote>
<p>仅限本人持有的</p>
</blockquote>
<blockquote>
<p>身份认证信息时用来核对只有登陆者本人才知道、拥有的信息内容，但是即便对方是假冒用户，只要能够通过用户认证，HTTP 服务器就会默认这是出自于本人的行为。因此掌控机密性的密码不能让其他人得到，更不能轻易被破解。</p>
</blockquote>
<h2 id="常见认证方式">常见认证方式</h2>
<ul>
<li>BASIC 认证（基本认证）</li>
<li>DIGEST 认证（摘要认证）</li>
<li>SSL 客户端认证</li>
<li>FormBase 认证（基于表单认证）</li>
</ul>
<h2 id="basic-认证">BASIC 认证</h2>
<h3 id="什么是-basic-认证">什么是 BASIC 认证</h3>
<ul>
<li>从 HTTP1.0 就定义的一种认证方式，现在仍有一部分网站在使用。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/BASIC%E8%AE%A4%E8%AF%81.png" alt="图片" loading="lazy"></figure>
<ul>
<li>WEB 服务器与通信客户端之间进行的统一认证方式。</li>
</ul>
<h3 id="basic-认证过程">BASIC 认证过程</h3>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/BASIC%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<ul>
<li>客户端发送需要 BASIC 认证的请求资源</li>
<li>当请求的资源需要 BASIC 认证时，服务器会随状态码 401 返回一个 Authorization Required，告诉客户端需要身份认证</li>
<li>接收到状态码 401 的客户端为了通过 BASIC 认证，需要将用户名、密码发送给服务器，发送的字符和内容形式为是用户名和密码，中间用 “：” 拼接，将其经过 Base64 的编码后写入到首部字段 Authorization，并在前面加上“Basic ”，表明要执行的是 Basic 认证，发送给服务器。</li>
<li>服务器端接收到包含首部字段 Authorization 的请求后，会去认证信息的正确性，如果验证通过，返回包含 Request URI 的资源响应，返回的是 200；如果认证失败，继续返回 401，表示认证未通过。</li>
</ul>
<blockquote>
<p>BASIC 认证虽然采用 Base64 的编码方式，但是这不是加密处理，不需要任何附加信息就可以对 Base64 进行解码，由于明文解码后就是用户名和密码，在 HTTP 这样非加密通信的线路上，进行 BASIC 认证的过程中，如果不小心被别人窃听了，被盗的可能性就会非常大。<br>
BASIC 认证在使用上不够便捷灵活，而且不安全，所以并不常用。</p>
</blockquote>
<h2 id="digest-认证">DIGEST 认证</h2>
<h3 id="什么是digest认证">什么是DIGEST认证？</h3>
<ul>
<li>为弥补BASIC认证存在的弱点，从HTTP/1.1起就有了DIGEST认证。</li>
<li>DIGEST 认证同样使用质询/响应的方式，但不会像BASIC认证那样直接发送明文密码。</li>
</ul>
<blockquote>
<p>质询-响应方式：一方先发送认证要求给另一方，使用从另一方接收到的质询码，计算生成响应码，最后将响应码返回给对方进行认证。<br>
因为发送给对方的只是响应摘要，以及由质询码产生的计算结果，所以比 BASIC 认证多了一层保护，密码泄露的可能性也就降低了。</p>
</blockquote>
<h3 id="digest-认证过程">DIGEST 认证过程</h3>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/DIGEST%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<ul>
<li>客户端发送需要 DIGEST 认证的请求</li>
<li>服务端返回状态码 401，同时里面包含一个头部字段，包含质询-响应认证方式所需要的临时质询码，质询码是一个随机数 nonce，一次返回都是 401 响应生成的任意随机的 Base64 编码的字符串，多数情况下，由一串数字、或一串字符或一串其他的组成</li>
<li>接收到 401 状态码的客户端返回的响应中包含 DIGEST 认证必须要的头部字段 Authorization，包含这些信息：Digest username=&quot;xxx&quot;, realm=&quot;DIGEST&quot;, nonce=&quot;xxxxx&quot;, url=&quot;&quot;, response=&quot;&quot; ，其中 realm 和 nonce 就是从服务器端接收和响应的字段。username 是 realm 限定范围内可进行认证的内容，response 存放经过 MD5 算法运算生成的密码字符串。</li>
<li>服务器接收到包含首部字段的 Authorization，服务器端接收到这个请求会确认认证信息的正确性</li>
</ul>
<blockquote>
<p>DIGEST 认证提供了高于 BASIC 认证的安全等级，但是和 HTTPS 客户端认证相比还是很弱。DIGEST 认证提供了 <strong>“防止密码被窃听</strong>” 的保护机制，但是并不存在 “<strong>防止用户伪装</strong>” 的保护机制。DIGEST 认证和 BASIC 认证一样，使用上不那么便捷灵活，安全性不够，适用范围有限。<br>
使用用户名、密码的认证方式，只要二者的内容正确就可以认为是本人的行为，但是如果用户名和密码被盗，就很有可能<strong>被第三方冒充</strong>。所以利用 SSL 客户端认证，就可以避免这种情况的发生。</p>
</blockquote>
<h2 id="ssl客户端认证">SSL客户端认证</h2>
<ul>
<li>SSL 客户端认证是借由HTTPS的客户端<strong>证书</strong>完成认证的方式。凭借客户端证书认证，服务器可确认访问是否来自已登录的客户端。</li>
</ul>
<blockquote>
<p>银行网银：先输入用户名、密码，输入正确后下载它们的证书，下载好之后，以后每次登录会把证书也通过 HTTP 报文的方式发给服务器，开始通信。<br>
细节过程：①当服务器接收到需要认证资源的请求，服务器给客户端发送一个报文要求客户端提供客户端证书，②用户选择将发送的客户端证书后，客户端会把客户端证书信息以报文方式发送给服务器，③服务器验证客户端证书，验证通过后，就可以领取证书内客户端的公开秘钥，然后开始 HTTPS 的加密通信。</p>
</blockquote>
<h2 id="基于表单的认证">基于表单的认证</h2>
<ul>
<li>基于表单的认证方法并不是在HTTP协议中定义的。</li>
<li>使用由Web应用程序各自实现基于表单的认证方式。</li>
<li>通过Cookie和Session的方式来保持用户的状态。</li>
</ul>
<h1 id="http-的长连接与短连接">HTTP 的长连接与短连接</h1>
<blockquote>
<p>资源消耗的优化：长连接。<br>
连接好比从 A 地到 B 地的交通方式，想从 A 地到 B 地，打车过去，这样是一个短连接，就连通了一下，没办法让更多的人上车；后来发现从 A 去 B 的人很多，于是开通了一条地铁线，建立了一条长连接，很多人都可以复用这个连接。<br>
能一次性节约很多资源的、服务很多次的是长连接。</p>
</blockquote>
<ul>
<li>HTTP协议是基于请求/响应模式的，因此只要服务端给了响应，本次HTTP请求就结束了。</li>
<li>HTTP的长连接和短连接本质上是<strong>TCP长连接和短连接</strong>。</li>
</ul>
<blockquote>
<p>HTTP 协议是应用层协议，传输层使用的是 TCP 协议，网络层使用的是IP 协议，IP 协议主要解决网络路由、寻址的问题， TCP 协议解决的是如何在 IP 层之上可靠的传递数据包，使得在接收端能收到发送方发送的所有包，并且顺序与发出顺序一致。<br>
HTTP 分成长连接和短连接，本质上就是 TCP 连接。TCP 连接是一个双向通道，可以保持一段时间不关闭，因此 TCP 连接才有真正的长连接和短连接。</p>
</blockquote>
<ul>
<li>HTTP/1.0中，默认使用的是<strong>短连接</strong>。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，结束就中断。</li>
</ul>
<blockquote>
<p>如果客户端浏览器访问某个 html，该 html 内包含其他 js、css、img 资源，当浏览器每遇到一个 web 资源，就会建立一个 HTTP 会话。</p>
</blockquote>
<ul>
<li>HTTP/1.1起，默认使用<strong>长连接</strong>，用以保持连接特性。</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/HTTP%E9%95%BF%E8%BF%9E%E6%8E%A5.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>使用长连接的情况时，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接，这个 keep-alive 不会永久保持连接，有一个保持时间，在不同的服务器软件可以设置。</p>
</blockquote>
<ul>
<li>短连接：</li>
</ul>
<p>建立连接一数据传输一关闭连接..建立连接一数据传输一关闭连接</p>
<blockquote>
<p>客户端向服务器发送连接请求，Server 接到请求，双方建立连接，客户端向 Server 发送消息，Server 回应 Client，一次读写就完成了，这时候双方任何一个都可以发起 close 关闭的操作，一般都是 Client 先发起 close。短连接一般只会在 Client-Server 间传递一次读写操作。</p>
</blockquote>
<ul>
<li>长连接：</li>
</ul>
<p>建立连接—数据传输…（保持连接）.…数据传输——关闭连接</p>
<blockquote>
<p>Client 向 Server 发起连接请求，Server 接受 Client 的请求，双方建立连接，Client 与 Server 完成一次读写之后，它们之间的连接不会主动关闭，后续的读写操作会继续使用这个连接。<br>
短连接对于服务器来说，它的管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段，但如果客户请求频繁，将在 TCP 建立和关闭的操作上浪费时间也浪费带宽，响应的反应速度就会变慢，客户体验感不好。<br>
长连接可以省去较多的 TCP 连接和关闭的时间，减少浪费、节约时间，对于频繁请求资源的客户来说，比较适合使用长连接。在长连接的应用场景下， Client 端一般不会主动关闭连接，与短连接不同，Client 与 Server 之间的连接如果一直不关闭的话，就会存在问题：随着客户端连接越来越多，Server 承受不住，这时 Server 端需要采取一些策略，比如说，关闭一些长时间没有读写事件发生的连接，可以避免一些恶意连接导致 Server 端服务受损。</p>
</blockquote>
<h1 id="http-中介之代理">HTTP 中介之代理</h1>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/HTTP%E4%B8%AD%E4%BB%8B%E4%B9%8B%E4%BB%A3%E7%90%86.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>一般情况下是客户端直接与服务器连接，但是出于不方便或是其他的特殊原因，可能会通过一个中间人与服务器连接。这个中间人就叫做 <strong>web 代理</strong>，这个中间人<strong>既是客户端、又是服务端</strong>，对于服务器来说，由于请求是从代理访问过来的，所以在这个过程中，代理起到了客户端的作用；而对于真正的客户端来说，请求是发给代理的，所以代理起到了服务器的作用。</p>
</blockquote>
<h2 id="代理的作用">代理的作用</h2>
<ul>
<li>抓包</li>
</ul>
<blockquote>
<p>为了能够更好的分析 HTTP 请求，或者达到安全措施的目的，只有使用代理才可以更好的对客户端的数据包进行拦截，在这里代理的名字有另外一种叫法：拦截服务器</p>
</blockquote>
<ul>
<li>FQ</li>
</ul>
<blockquote>
<p>如果想通过计算机访问 facebook，由于长城防火墙屏蔽了 facebook、YouTube 这些网站，不可直接访问，就要通过代理翻墙。</p>
</blockquote>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/FQ.png" alt="图片" loading="lazy"></figure>
<ul>
<li>匿名访问</li>
</ul>
<blockquote>
<p>HTTP 协议本身具有匿名性，HTTP 代理服务器通过删除 HTTP 报文中的身份特性，比如客户端的 IP 地址、Cookie、会话 ID 等，从而对远端的服务器隐藏原始用户的 IP 地址以及其他细节，同时 HTTP 代理服务器上也不会记录原始用户访问记录，就使得代理上网的客户可以在更加安全隐秘的环境中访问网络。</p>
</blockquote>
<ul>
<li>过滤器</li>
</ul>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E8%BF%87%E6%BB%A4%E5%99%A8.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>HTTP 协议并不知道在访问网络的是谁，即便是个小朋友登上父母的账号进行访问，认证起来我们也认为他就是他的父母。通过代理服务器进行分析和部分请求的拦截，进一步加强对网络的控制。</p>
</blockquote>
<h1 id="http-中介之网关">HTTP 中介之网关</h1>
<ul>
<li>网关可以作为某种翻译器使用，它抽象出了一种能够到达资源的方法。网关是资源和应用程序之间的粘合剂。</li>
<li>网关扮演的是“协议转换器”的角色。</li>
</ul>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/HTTP%E4%B8%AD%E4%BB%8B%E4%B9%8B%E7%BD%91%E5%85%B3.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>代理连接的是两个或多个使用相同协议的应用程序。<br>
网关连接的是两个或多个使用不同协议的端点，网关扮演的是 “<strong>协议转换器</strong>” 的角色，网关可以向数据库发送查询数据、发邮件、生成动态内容。</p>
</blockquote>
<h2 id="web-网关">WEB 网关</h2>
<ul>
<li>Web网关在一侧使用HTTP协议，在另一侧使用另一种协议。</li>
</ul>
<p>&lt;客户端协议&gt;/&lt;服务器端协议&gt;</p>
<p>①（HTTP/）服务器端网关：通过HTTP协议与客户端对话，通过其他协议与服务器通信。</p>
<blockquote>
<p>发邮件就是服务器端网关，客户端是 HTTP 协议，邮件服务器是 SMTP 协议</p>
</blockquote>
<p>②（/HTTP）客户端网关：通过其他协议与客户端对话，通过HTTP协议与服务器通信。</p>
<h2 id="常见的网关类型">常见的网关类型</h2>
<ul>
<li>（HTTP/*）服务器端Web网关</li>
</ul>
<blockquote>
<p>客户端发送 HTTP 请求，服务器端 web网关会把这个请求转换为其他协议与服务器进行连接，完成获取资源后，会将对象放在一条 HTTP 响应中，发送给客户端：发邮件。</p>
</blockquote>
<ul>
<li>（HTTP/HTTPS）服务器端安全网关</li>
</ul>
<blockquote>
<p>客户端发送 HTTP 请求，网关自动进行加密，加密来自客户端的请求，然后再发送给服务器，为了安全问题。</p>
</blockquote>
<ul>
<li>（HTTPS/HTTP）客户端安全加速器网关</li>
</ul>
<blockquote>
<p>客户端发送的请求是经过加密的安全的 HTTPS ，通过网关进行解密后再向 web 服务器发送普通的 HTTP 请求。</p>
</blockquote>
<ul>
<li>资源网关</li>
</ul>
<blockquote>
<p>客户端通过 HTTP 连接到应用程序的服务器，服务器并不回送文件，而是将请求通过网关 API 发送给运行在服务器上的应用程序，应用程序将请求资源回送给客户端。</p>
</blockquote>
<h1 id="http-缓存">HTTP 缓存</h1>
<h2 id="为什么要使用http缓存">为什么要使用HTTP缓存？</h2>
<p>请求一次服务器，请求头大小 1KB，响应头大小 1KB，请求的文件大小 10KB，一次请求的流量就是 12KB，10 次就是 120KB，n 次请求就是 12*n KB。</p>
<ul>
<li><strong>客户端</strong>每次都要请求服务器，浪费<strong>流量</strong>。</li>
<li><strong>服务器</strong>每次都提供查找、下载，请求用户基数如果太大，服务器就会存在很大<strong>压力</strong>。</li>
<li><strong>客户端</strong>每次请求完都要进行页面渲染，<strong>用户体验差</strong>。</li>
</ul>
<p>是否可以将请求的文件存放起来使用：HTTP 缓存。</p>
<h2 id="缓存的内容又是什么">缓存的内容又是什么？</h2>
<p>主要针对样式：CSS、JS、图片这一系列更新频率不大的<strong>静态文件</strong>进行缓存。</p>
<blockquote>
<p>缓存是通过什么实现的？请求头-响应头</p>
</blockquote>
<h2 id="http缓存头部字段">HTTP缓存头部字段</h2>
<ul>
<li>Cache-Control请求/响应头，缓存控制字段</li>
</ul>
<blockquote>
<p>控制 HTTP 缓存的最高指令，要不要缓存也是 Cache-Control 说了算。</p>
</blockquote>
<p>no-store：所有内容都不缓存。</p>
<p>no-cache：缓存，但是浏览器使用缓存前，都会请求服务器判断缓存资源是否是最新。</p>
<p>max-age=X（单位秒）请求缓存后的X秒不再发起请求。</p>
<p>s-maxage=X（单位秒）代理服务器请求源站缓存后的X秒不再发起请求，只对CDN缓存有效。</p>
<p>public：客户端和代理服务器（CDN）都可缓存。</p>
<p>private：只有客户端可以缓存。</p>
<ul>
<li>Expires</li>
</ul>
<p>响应头，代表资源过期时间，由服务器返回提供，是http1.0的属性，在与max-age共存的情况下，优先级要低。</p>
<ul>
<li>Last-Modified</li>
</ul>
<p>响应头，资源最新修改时间，由服务器告诉浏览器。</p>
<ul>
<li>if-Modified-Since</li>
</ul>
<p>请求头，资源最新修改时间，由浏览器告诉服务器，和Last-Modified是一对，它两会进行对比。</p>
<ul>
<li>Etag</li>
</ul>
<p>响应头，资源标识，由服务器告诉浏览器。</p>
<ul>
<li>if-None-Match</li>
</ul>
<p>请求头，缓存资源标识，由浏览器告诉服务器（其实就是上次服务器给的Etag），和Etag是一对，它两会进行对比。</p>
<h2 id="http缓存工作方式">HTTP缓存工作方式</h2>
<h3 id="expires">Expires</h3>
<ul>
<li>场景一：让服务器与浏览器约定一个文件过期时间一Expires</li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/Expires.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>① 第一次请求时，浏览器向服务器请求一个 f.js 文件<br>
② 服务器说文件给你，我们约定一个时间，通过响应头返回一个 Expires 过期约定时间，同时返回了 f.js<br>
③ 后续请求浏览器先对比当前时间是否已经大于 Expires，判断缓存的文件是否超过了约定的过期时间，时间没过的话，不发起请求，直接使用本地缓存；时间过期了，就发起请求，再返回到步骤 ①。<br>
假设 Expires 已经过期，浏览器请求服务器，但是 f.js 并未改变，如何避免这时发起请求呢？</p>
</blockquote>
<h3 id="last-modified-与-if-modified-since">Last-Modified 与 if-Modified-Since</h3>
<ul>
<li>场景二：让服务器与浏览器在约定文件过期时间的基础上，再加一个文件最新修改时间的对比——Last-Modified 与 if-Modified-Since</li>
</ul>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/Last-Modified.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>① 浏览器向服务器请求 f.js，并要一个过期时间<br>
② 服务器返回给浏览器 f.js 和 一个过期时间，再给一个文件最新修改时间 Last-Modified，通过设置响应头返回给浏览器，文件过期后，双方核对文件修改时间<br>
后续浏览器可能有如下三种情况：</p>
<ol>
<li>Expires 还未过期，浏览器使用本地缓存</li>
<li>Expires 过期，浏览器请求服务器时带上文件最新修改时间，在请求头里面加上 if-Modified-Since，也就是上次请求服务器返回的 Last-Modified，把这个值又带回去。服务器把这个 if-Modified-Since（请求头里的文件最近修改时间） 和 服务器上的文件最新修改时间 Last-Modified 作对比，如果两个值不相等，服务器查找最新的 f.js + Expires + Last-Modified 返回给浏览器；如果相等，服务器返回状态码 304：文件未修改过，你还是用你的本地缓存吧。</li>
</ol>
</blockquote>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/Last-Modified_2.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>浏览器端可以随意修改 Expires，很极端的情况下，Last-Modified 只能精确到秒，假设文件在 1秒 内发生变化，Last-Modified 无法感知这个文件的变化，这样情况下，浏览器永远无法拿到最新文件。</p>
</blockquote>
<h3 id="etag与lf-none-match">Etag与lf-None-Match</h3>
<ul>
<li>场景三：让服务器与浏览器在过期时间Expires+Last-Modified的基础上，增加一个文件内容唯一对比标记——Etag与lf-None-Match。Expires不稳定，再加入一个max-age来加以代替。</li>
</ul>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/Etag.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>① 浏览器请求 f.js<br>
② 服务器将 f.js + max-age(过期时间) + Last-Modified + Etag（文件内容的唯一标识）<br>
③ 浏览器 60s 内不发起请求，直接使用本地缓存，<br>
max-age=60代表成功缓存后的 60s 内不再向服务器发起请求，与 Expires 相似，但 max-age 优先级比 Expires 高，max-age 存在时 Expires 就没用了。</p>
<blockquote>
<p>④ 60s 后，浏览器带上 If-Modified-Since 和 If-None-Match 向服务器发起请求，服务器对比 If-None-Match 与服务器端的 Etag，这时候尽管给出了 If-Modified-Since，但是不会再对比 If-Modified-Since 和 Last-Modified 了，因为 Etag 优先级比 Last-Modified 高，Etag 就是为了解决 1s 内文件发生改变的问题。如果 If-None-Match 与 Etag 不相等，说明 f.js 这个内容被修改过，服务器返回给浏览器最新的 f.js + 全新的 Etag + max-age +Last-Modified（没什么用了，优先级 &lt; Etag） + Expires（没什么用了，优先级&lt;max-age）；如果 Etag 与 If-None-Match 相等，返回 304 告诉浏览器继续使用之前的本地缓存。</p>
</blockquote>
</blockquote>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/Etag_2.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>max-age 或 Expires 不过期的时候，浏览器没有办法主动感知服务器的文件变化。<br>
如果服务端改变了文件，怎样让客户端知道呢？</p>
</blockquote>
<h2 id="缓存改进方案">缓存改进方案</h2>
<h3 id="md5hash缓存">md5/hash缓存</h3>
<p>通过不缓存html，为静态文件添加MD5或者hash标识，解决浏览器无法跳过缓存过期时间主动感知文件变化的问题。</p>
<blockquote>
<p>HTTP 缓存方案：服务器与浏览器的文件修改时间对比，文件内容标识对比，前提的基础都是建立在两者文件路径完全相同的基础上，请求的都是 f.js，这才能够解读这样的缓存，但是如果第一次要获取的名字是 f-hash1.js，下一次文件修改了就变成了 f-hash2.js，这是两个完全不同的文件。<br>
浏览器第一次加载页面，请求并缓存了 f-hash1,js，第二次加载同样一个地方文件指向 f-hash2.js，浏览器不会询问缓存了，因为本地没有这个缓存，浏览器会直接重新请求 f-hash2.js，因为这就是两个不同的文件。<br>
通过这种方式就可以解决过期时间没到，浏览器无法主动请求服务器的问题，只需要在在项目每次发布迭代的时候，将修改过的静态文件添加不同的 MD5 或者 hash 标识即可。</p>
</blockquote>
<h3 id="cdn缓存">CDN缓存</h3>
<p>CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</p>
<blockquote>
<p>假设多年前，我们所在的城市只有一个火车站，每次春运整个城市的人都得去这个火车站买票， 人流量及购票需求激增，为了缓解这个问题，城市的不同区都出现了火车票的代售点，这样每个区的人都可以就近买票，火车站总站的压力大大减轻。<br>
可以把每个区的售票点称之为 CDN 节点，也就是前面所说的 代理服务器，简而言之，可以把 CDN 理解成浏览器与服务器之间的临时站点，它会替服务器处理部分浏览器请求，从而减轻总服务器上的压力。静态资源也是一样的，可以分成多个临时站点来存储。<br>
把 CDN 的价值归纳为：<br>
①通过分流大大减轻了原站（服务器端）的压力。<br>
②解决了跨地区访问问题（就近站点访问）。</p>
</blockquote>
<h3 id="cdn-缓存工作方式">CDN 缓存工作方式</h3>
<ul>
<li>第一次请求</li>
</ul>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/CDN%E7%BC%93%E5%AD%98%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AF%B7%E6%B1%82.png" alt="图片" loading="lazy"></figure>
<ul>
<li>后续请求</li>
</ul>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/CDN%E7%BC%93%E5%AD%98%E5%90%8E%E7%BB%AD%E8%AF%B7%E6%B1%82.png" alt="图片" loading="lazy"></figure>
<p>可能出现以下几种情况：</p>
<p>① CDN 节点自己缓存的文件还没过期，于是返回 304 给浏览器，打回了这次请求</p>
<p>② CND 节点发现自己缓存的文件过期了，为了保险起见，自己发送请求给服务器，成功拿回最新数据，然后交还给浏览器。</p>
<p>CND 缓存的问题和 HTTP 缓存的问题一样，CDN 缓存时间不过期，浏览器始终被拦截，无法拿到最新的文件。回归 HTTP 缓存本身，缓存本身针对于更新频率不高的静态文件，CDN 缓存提供了分流、访问加速等。</p>
<p>CDN 与 HTTP 缓存不一样的是：CDN 类似于一个平台，可以通过登录手动更新 CDN 缓存，变相解决了浏览器缓存无法手动控制的问题。</p>
<h2 id="浏览器操作对http缓存的影响">浏览器操作对HTTP缓存的影响</h2>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>用户操作</strong></th>
<th style="text-align:left"><strong>Expires/Cache-Control</strong></th>
<th style="text-align:left"><strong>Last-Modihed/Etag</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">地址栏回车</td>
<td style="text-align:left">有效</td>
<td style="text-align:left">有效</td>
</tr>
<tr>
<td style="text-align:left">页面链接跳转</td>
<td style="text-align:left">有效</td>
<td style="text-align:left">有效</td>
</tr>
<tr>
<td style="text-align:left">新开窗口</td>
<td style="text-align:left">有效</td>
<td style="text-align:left">有效</td>
</tr>
<tr>
<td style="text-align:left">前进、后退</td>
<td style="text-align:left">有效</td>
<td style="text-align:left">有效</td>
</tr>
<tr>
<td style="text-align:left">F5刷新</td>
<td style="text-align:left">无效</td>
<td style="text-align:left">有效</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+F5刷新</td>
<td style="text-align:left">无效</td>
<td style="text-align:left">无效</td>
</tr>
</tbody>
</table>
<h1 id="内容协商机制">内容协商机制</h1>
<blockquote>
<p>访问谷歌，同一个 URL，在国内打开谷歌是中文，在国外打开是英文的。</p>
</blockquote>
<ul>
<li>指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言，字符集，编码方式等作为判断的基准。</li>
</ul>
<h2 id="内容协商方式">内容协商方式</h2>
<ul>
<li>客户端驱动</li>
</ul>
<p>客户端发起请求，服务器发送可选项列表，客户端作出选择后在发送第二次请求。</p>
<ul>
<li>服务器驱动</li>
</ul>
<p>服务器检查客户端的请求头部集并决定提供哪个版本的页面。</p>
<ul>
<li>透明协商</li>
</ul>
<p>某个中间设备（通常是缓存代理）代表客户端进行协商。</p>
<h2 id="服务器驱动内容协商-请求首部集">服务器驱动内容协商-请求首部集</h2>
<ul>
<li>Accept：告知服务器发送何种媒体类型</li>
<li>Accept-Language：告知服务器发送何种语言</li>
<li>Accept-Charset：告知服务器发送何种字符集</li>
<li>Accept-Encoding：告知服务器采用何种编码</li>
</ul>
<h2 id="服务器驱动内容协商-请求首部集-2">服务器驱动内容协商-请求首部集</h2>
<ul>
<li>Content-Type</li>
<li>Content-Language</li>
<li>Content-Type</li>
<li>Content-Encoding</li>
</ul>
<h2 id="服务器驱动内容协商-近似匹配">服务器驱动内容协商-近似匹配</h2>
<blockquote>
<p>客户端的 Accept-Language 指的是西班牙语，服务器端只有英语和法语，这个客户端希望在没有西班牙语的时候优先返回英语。这就意味着需要一种 HTTP 机制更详细的描述偏好：近似匹配方式。</p>
</blockquote>
<p>Accept-Language:en; q=0.5, fr; q=0.0, nl; q=1.0, tr; q=0.0</p>
<blockquote>
<p>上述首部表示用户最愿意接受 nl：荷兰语(nl; q=1.0)；其次，如果没有荷兰语的话，英文也行：en;q=0.5；不接受法语：fr;q=0.0 ，不接受土耳其语：tr;q=0.0</p>
</blockquote>
<p>q 值的范围是 0-1，不代表所有权重和为 1，不是权重的概念，只是优先级的概念。</p>
<blockquote>
<p>如果服务端既没有 nl 也没有 en，服务器端猜测，服务器端设置默认值。</p>
</blockquote>
<h2 id="断点续传和多线程下载">断点续传和多线程下载</h2>
<ul>
<li>断点续传？多线程下载？</li>
</ul>
<blockquote>
<p>下载文件时，下载到一半，突然网络不太好，下载中断了；<br>
或者主动暂停下载；<br>
用迅雷下载一个大文件，会分成好多块分开下载。<br>
上述叫断点续传。</p>
<ul>
<li>HTTP是通过在Header里两个参数实现的，客户端发请求时对应的是Range，服务器端响应时对应的是Content-Range。<br>
不论是断点续传还是迅雷的多线程分块下载，如果续传成功，返回 206，如果文件有变动，返回 200 和新文件的内容。</li>
</ul>
</blockquote>
<p>Range</p>
<ul>
<li>用于请求头中，指定第一个字节的位置和最后一个字节的位置，一般格式：</li>
<li>Range:（unit=first byte pos）-[last byte pos] 左开右闭区间
<ul>
<li>Range:bytes=0-499</li>
<li>Range:bytes=500-999</li>
<li>Range:bytes=-500  后 500 个字节的内容</li>
<li>imooc Range:bytes=500-   从第 500 字节开始，到文件结束部分</li>
<li>Range:bytes=500-600,601-999</li>
</ul>
</li>
</ul>
<p>Content-Range</p>
<ul>
<li>用于响应头中，在发出带 Range的请求后，服务器会在Content-Range 头部返回当前接受的范围和文件总大小。一般格式：
<ul>
<li>Content-Range:bytes（unit first byte pos）-[last byte pos]/[entity legth]</li>
</ul>
</li>
<li>而在响应完成后，返回的响应头内容也不同：
<ul>
<li>HTTP/1.1200 Ok（不使用断点续传方式）</li>
<li>HTTP/1.1 206 Partial Content（使用断点续传方式）</li>
</ul>
</li>
</ul>
<h2 id="断点续传过程">断点续传过程</h2>
<p>1.客户端下载一个1024K的文件，已经下载了其中512K。</p>
<p>2.网络中断，客户端请求续传，因此需要在HTTP头中申明本次需要续传的片段：Range:bytes=512000-</p>
<p>这个头通知服务端从文件的512K位置开始传输文件。</p>
<p>3.服务端收到断点续传请求，从文件的512K位置开始传输，并且在HTTP头中增加：</p>
<p>Content-Range:bytes 512000-/1024000并且此时服务端返回的HTTP状态码应该是206，而不是200。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM 垃圾回收]]></title>
        <id>https://epitomm.github.io/post/jvm-la-ji-hui-shou/</id>
        <link href="https://epitomm.github.io/post/jvm-la-ji-hui-shou/">
        </link>
        <updated>2020-04-24T14:54:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-如何判断对象可以回收">一、如何判断对象可以回收</h1>
<h2 id="11-引用计数法">1.1 引用计数法</h2>
<p>如果一个对象被其他变量引用，计数器 +1，如果某个变量不再引用，计数器 -1。如果一个对象的<strong>引用次数为 0</strong>，就可以被回收。</p>
<h3 id="循环引用问题">循环引用问题</h3>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png" alt="图片" loading="lazy"></figure>
<p>A 对象引用 B 对象，B 对象的引用计数 = 1；B 对象引用了 A 对象，A 对象的引用计数 = 1，但是没有其他对象在引用它们两个，它们本应被回收，却因彼此循环引用，计数器不为 0 ，不能被回收，造成内存泄露。</p>
<h2 id="12-可达性分析算法">1.2 可达性分析算法</h2>
<ul>
<li>Java 虚拟机中的垃圾回收器采用<strong>可达性分析</strong>来探索所有存活的对象</li>
<li>扫描<strong>堆</strong>中的对象，看是否能够沿着 <strong>GC Root对象为起点的引用链找到该对象</strong>，找不到，表示可以回收</li>
</ul>
<h3 id="哪些对象可以作为-gc-root">哪些对象可以作为 GC Root ?</h3>
<ul>
<li>虚拟机栈中局部变量引用的对象</li>
<li>本地方法栈中 JNI 中引用的对象</li>
<li>方法去区静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
</ul>
<h2 id="13-四种引用">1.3 四种引用</h2>
<h3 id="131-强引用">1.3.1. 强引用</h3>
<blockquote>
<p>一个对象通过等号赋值运算符赋值给变量，如：List<String> list = new ArrayList&lt;&gt;();<br>
变量 list 强引用了对象 ArrayList。只要沿着 GC Root 能够找到这个对象，这个对象就不会被垃圾回收。</p>
</blockquote>
<ul>
<li>只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E5%BC%BA%E5%BC%95%E7%94%A8.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E5%BC%BA%E5%BC%95%E7%94%A82.png" alt="图片" loading="lazy"></figure>
<pre><code>package cn.itcast.jvm.t2;

import java.io.IOException;
import java.lang.ref.SoftReference;
import java.util.ArrayList;
import java.util.List;

/**
 * 演示强引用
 * -Xmx20m -XX:+PrintGCDetails -verbose:gc
 */
public class Demo2_3 {
    private static final int _4MB = 4 * 1024 * 1024;
    public static void main(String[] args) throws IOException {
      List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
      for (int i = 0; i &lt; 5; i++) {
          list.add(new byte[_4MB]);// 读取图片放到 list 集合中进行显示，但是图片资源并不属于核心业务资源，如果图片过多，用强引用就会导致溢出。不太重要的资源能不能在内存紧张时把它占用的内存释放掉，以后如果再用到的话再读取一遍呢？采用软引用。
      } 
      System.in.read();
    }
}
</code></pre>
<p>通过 <code>-Xmx20m -XX:+PrintGCDetails -verbose:gc</code> 设置堆空间大小为 20M 并且打印 GC 信息，创建 list 变量强引用 ArrayLsit 对象，向 ArrayList 内放入 20M 对象，由于程序一直未被终止，所以 list 不能被回收，导致 堆内存溢出异常 <code>OutOfMemoryError: Java heap space</code>。</p>
<p>运行结果：</p>
<pre><code>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space
	at cn.itcast.jvm.t2.Demo2_3.main(Demo2_3.java:21)
</code></pre>
<h3 id="132-软引用softreference">1.3.2. 软引用（SoftReference）</h3>
<ul>
<li>仅有软引用引用该对象时，在<strong>垃圾回收后，内存仍不足</strong>时会再次触发垃圾回收，回收软引用对象</li>
<li>可以配合<strong>引用队列</strong>来释放软引用自身</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E8%BD%AF%E5%BC%95%E7%94%A8.png" alt="图片" loading="lazy"></figure>
<pre><code>package cn.itcast.jvm.t2;

import java.io.IOException;
import java.lang.ref.SoftReference;
import java.util.ArrayList;
import java.util.List;

/**
 * 演示软引用
 * -Xmx20m -XX:+PrintGCDetails -verbose:gc
 */
public class Demo2_3 {

    private static final int _4MB = 4 * 1024 * 1024;

    public static void main(String[] args) throws IOException {
        soft();
    }

    public static void soft() {
        // list --&gt; SoftReference --&gt; byte[]
        // list 和 SoftReference 之间是强引用，SoftReference 和 byte[] 之间是软引用
        List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 5; i++) {
            SoftReference&lt;byte[]&gt; ref = new SoftReference&lt;&gt;(new byte[_4MB]);
            System.out.println(ref.get());
            list.add(ref);
            System.out.println(list.size());

        }
        System.out.println(&quot;循环结束：&quot; + list.size());
        for (SoftReference&lt;byte[]&gt; ref : list) {
            System.out.println(ref.get());
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/%E8%BD%AF%E5%BC%95%E7%94%A8GC.png" alt="图片" loading="lazy"></figure>
<p><strong>清理无用的软引用：引用队列</strong></p>
<p>软引用对象被释放后，没必要再保存在 list 中了，希望把<strong>软引用本身做一个清理</strong>，从 list 集合中清理掉。</p>
<pre><code>package cn.itcast.jvm.t2;

import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.SoftReference;
import java.util.ArrayList;
import java.util.List;

/**
 * 演示软引用, 配合引用队列
 */
public class Demo2_4 {
    private static final int _4MB = 4 * 1024 * 1024;

    public static void main(String[] args) {
        List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();

        // 引用队列
        ReferenceQueue&lt;byte[]&gt; queue = new ReferenceQueue&lt;&gt;();
        for (int i = 0; i &lt; 5; i++) {
            // 关联了引用队列， 当软引用所关联的 byte[]被回收时，软引用自己会加入到 queue 中去
            SoftReference&lt;byte[]&gt; ref = new SoftReference&lt;&gt;(new byte[_4MB], queue);
            System.out.println(ref.get());
            list.add(ref);
            System.out.println(list.size());
        }

        // 从队列中获取无用的 软引用对象，并移除
        Reference&lt;? extends byte[]&gt; poll = queue.poll();
        while( poll != null) {
            list.remove(poll);
            poll = queue.poll();
        }

        System.out.println(&quot;===========================&quot;);
        for (SoftReference&lt;byte[]&gt; reference : list) {
            System.out.println(reference.get());
        }

    }
}
</code></pre>
<p>运行结果：值为空的软引用都被从 list 集合中清除了</p>
<pre><code>[B@6d6f6e28
1
[B@135fbaa4
2
[B@45ee12a7
3
[B@330bedb4
4
[B@2503dbd3
5
===========================
[B@2503dbd3
</code></pre>
<h3 id="133-弱引用weakreference">1.3.3. 弱引用（WeakReference）</h3>
<ul>
<li>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</li>
<li>可以配合引用队列来释放弱引用自身</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E5%BC%B1%E5%BC%95%E7%94%A8.png" alt="图片" loading="lazy"></figure>
<p>引用队列：</p>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E5%BC%B1%E5%BC%95%E7%94%A8%E5%BC%95%E7%94%A8%E9%98%9F%E5%88%97.png" alt="图片" loading="lazy"></figure>
<p>当软引用的对象被回收后，软引用自身也是一个对象，如果在创建时给他分配了一个引用队列，那在它<strong>引用的对象被回收</strong>时，软引用就会进入这个<strong>引用队列</strong>。当弱引用的对象被垃圾回收后，弱引用如果被分配了引用队列的话， 弱引用也会进入引用队列。因为软引用、弱引用自身也要占用一定内存，如果要对它俩占用的内存进一步释放，需要使用引用队列来找到它们。</p>
<pre><code>package cn.itcast.jvm.t2;

import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.List;

/**
 * 演示弱引用
 * -Xmx20m -XX:+PrintGCDetails -verbose:gc
 */
public class Demo2_5 {
    private static final int _4MB = 4 * 1024 * 1024;

    public static void main(String[] args) {
        //  list --&gt; WeakReference --&gt; byte[]
        List&lt;WeakReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 10; i++) {
            WeakReference&lt;byte[]&gt; ref = new WeakReference&lt;&gt;(new byte[_4MB]);
            list.add(ref);
            for (WeakReference&lt;byte[]&gt; w : list) {
                System.out.print(w.get()+&quot; &quot;);
            }
            System.out.println();

        }
        System.out.println(&quot;循环结束：&quot; + list.size());
    }
}
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/%E5%BC%B1%E5%BC%95%E7%94%A8GC.png" alt="图片" loading="lazy"></figure>
<p>在<strong>垃圾回收时，会把弱引用所占用的内存释放掉</strong>，弱引用自身占用的内存要释放的话，要结合引用队列来实现。</p>
<h3 id="134-虚引用phantomreference">1.3.4. 虚引用（PhantomReference）</h3>
<p>虚引用和终结器引用必须配合引用队列使用。<strong>当创建虚引用和终结器引用时，都会关联一个引用队列。</strong></p>
<ul>
<li>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队， 由 Reference Handler 线程调用虚引用相关方法<strong>释放直接内存</strong></li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/%E8%99%9A%E5%BC%95%E7%94%A8.png" alt="图片" loading="lazy"></figure>
<p>创建 ByteBuffer 的实现对象时，会创建一个名为 Cleaner 的<strong>虚引用对象</strong>，ByteBuffer 会分配一块直接内存，并且会把直接内存的地址传递给虚引用对象。将来 ByteBuffer 没有被强引用引用时，ByteBuffer 就会被垃圾回收，但是给他分配的<strong>直接内存并不能被 Java 垃圾回收</strong>管理。</p>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/%E8%99%9A%E5%BC%95%E7%94%A82.png" alt="图片" loading="lazy"></figure>
<p>所以在 ByteBuffer 被回收时，让虚引用对象进入引用队列，虚引用所在的引用队列会由 ReferenceHandler 线程定时到这个引用队列中找看有没有新入队的 Cleaner，如果有，就会调用 Cleaner 中的 clean() 方法，根据前面记录的直接内存的地址调用 Unsafe.freeMemory()，<strong>释放直接内存</strong>。</p>
<h3 id="135-终结器引用finalreference">1.3.5. 终结器引用（FinalReference）</h3>
<ul>
<li>无需手动编码，但其内部<strong>配合引用队列使用</strong>，在<strong>垃圾回收</strong>时，<strong>终结器引用入队</strong>（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并<strong>调用它的 finalize 方法</strong>，<strong>第二次 GC 时才能回收被引用对象</strong></li>
</ul>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/%E7%BB%88%E7%BB%93%E5%99%A8%E5%BC%95%E7%94%A8.png" alt="图片" loading="lazy"></figure>
<p>所有的 Java 对象都会继承在 Object 父类，Object 类中有一个 finalize() 终结方法。某个对象<strong>重写了 finalize() 方法</strong>，当没有强引用引用它时，就由虚拟机创建它对应的终结器引用，当这个对象要被垃圾回收时，就会把这个<strong>终结器引用加入引用队列</strong>，再由一个<strong>优先级很低的线程 <strong>（finalize() 迟迟未能被调用，导致对象很久不能被真正回收，所以不推荐使用 finalize() 释放资源）finalizeHandler 线程查看引用队列中是否有终结器引用，如果有，就会根据终结器引用找到那个</strong>要被垃圾回收的对象</strong>，并且<strong>调用它的 finalize()方法</strong>，调用完了，<strong>下一次垃圾回收时就可以把这个对象占用的内存真正回收了</strong>。</p>
<h1 id="二-垃圾回收算法">二、垃圾回收算法</h1>
<h2 id="21-标记清除">2.1 标记清除</h2>
<p>定义： Mark Sweep</p>
<ul>
<li>速度快</li>
<li>会造成内存碎片</li>
</ul>
<h3 id="标记清除流程">标记清除流程</h3>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png" alt="图片" loading="lazy"></figure>
<p><strong>标记</strong>：沿着 GC Root 的引用链去找，扫描整个堆对象的过程中，如果发现某个堆对象确实被引用了，那么这个堆对象是非垃圾对象，如果某个对<strong>象没有任何一个 GC Root 直接或间接引用</strong>它，那么把它<strong>标记为垃圾对象</strong>。</p>
<p><strong>清除</strong>：将被标记为垃圾对象所占用的空间释放掉。这里说的释放不是把这个对象所占用的内存的每个字节清零，只需要把垃<strong>圾对象占用内存的起始、结束地址记录下来，放在一个空闲地址列表</strong>，下次分配新对象时，到空闲地址列表中找是否有一块足够的空间能容纳新对象。</p>
<h3 id="优点">优点</h3>
<p><strong>速度快</strong>，只需把垃圾对象的起始、结束地址记录下来。</p>
<h3 id="缺点">缺点</h3>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E5%86%85%E7%A2%8E%E7%89%87.png" alt="图片" loading="lazy"></figure>
<p>易产生<strong>内存碎片</strong>。清除垃圾对象后不会对内存空间进行整理，如果分配了一个较大的对象，比如数组，数组需要一段连续的内存。每个小的空闲空间都不足以容纳下这个较大的新对象，虽然总的空闲空间足够，但由于<strong>不连续</strong>，造成新对象不能被保存。</p>
<h2 id="22-标记整理">2.2 标记整理</h2>
<p>定义：Mark Compact</p>
<ul>
<li>速度慢</li>
<li>没有内存碎片</li>
</ul>
<h3 id="标记整理流程">标记整理流程</h3>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png" alt="图片" loading="lazy"></figure>
<p><strong>标记</strong>：没有任何 GC Root 直接或间接指向的堆对象被标记为垃圾对象。</p>
<p><strong>整理</strong>：避免标记清除时的内存碎片问题，在清理垃圾的过程中，会把可用的对象向前移动，让内存更为<strong>紧凑</strong>，连续的内存空间就更大了。</p>
<h3 id="优点-2">优点</h3>
<p><strong>没有内碎片</strong>。</p>
<h3 id="缺点-2">缺点</h3>
<p>由于整理牵扯到对象的移动，<strong>效率降低</strong>。</p>
<p>对象在整理过程中发生移动，如果有其他局部变量引用了这个被移动的对象，就需要改变这些引用的地址。</p>
<h2 id="23-复制">2.3 复制</h2>
<p>定义：Copy</p>
<ul>
<li>不会有内存碎片</li>
<li>需要占用双倍内存空间</li>
</ul>
<h3 id="复制流程">复制流程</h3>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/%E5%A4%8D%E5%88%B61.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">标记垃圾对象</p>
<figure data-type="image" tabindex="16"><img src="https://epitomm.github.io/post-images/%E5%A4%8D%E5%88%B62.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">复制 FROM 区域的非垃圾对象到 TO 区域</p>
<figure data-type="image" tabindex="17"><img src="https://epitomm.github.io/post-images/%E5%A4%8D%E5%88%B63.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">清空 FROM 区域剩余的垃圾对象后交换 FROM 和 TO 区域</p>
<p>将内存区域划分成两块大小相等的区域，FROM 和 TO（空闲）。</p>
<p><strong>标记</strong>：找到那些不被引用的对象标记为垃圾对象。</p>
<p><strong>复制</strong>：把 <strong>FROM 区域上的非垃圾对象复制到 TO 区域</strong>中，复制的过程中完成碎片整理。复制完成后，<strong>FROM 区域</strong>都是垃圾对象，<strong>全部清除</strong>，并且<strong>交换 FROM 和 TO 区域</strong>。</p>
<h3 id="优点-3">优点</h3>
<p><strong>不会产生碎片。</strong></p>
<h3 id="缺点-3">缺点</h3>
<p><strong>占用双倍内存空间。</strong></p>
<h1 id="三-分代垃圾回收">三、分代垃圾回收</h1>
<p><strong>堆内存划分</strong></p>
<ul>
<li>新生代：用完了就丢弃。<strong>朝生夕死</strong>的对象
<ul>
<li>伊甸园 Eden</li>
<li>幸存区 FROM</li>
<li>幸存区 TO</li>
</ul>
</li>
<li>老年代：长时间使用的对象。<strong>长期存活</strong>的对象</li>
</ul>
<blockquote>
<p>有一栋居民楼，类似 Java 虚拟机中的堆内存，居民楼中每家每户每天要产生一些垃圾，需要保洁工人来处理，如果保洁工人挨家挨户去收垃圾，效率低，所以设立一个垃圾场（新生代），存放生命周期短的垃圾，比如盒饭、包装袋等，都是回收更为频繁的垃圾，保洁工人需要每天打扫了一次。 每家每户里存储的垃圾（老年代），比如用旧的椅子，暂存在家里，将来空间紧张到放不下时，找保洁员清理这些垃圾。</p>
</blockquote>
<figure data-type="image" tabindex="18"><img src="https://epitomm.github.io/post-images/%E5%A0%86%E5%86%85%E5%AD%98%E5%88%92%E5%88%86.png" alt="图片" loading="lazy"></figure>
<ul>
<li><strong>对象首先分配在伊甸园区域</strong></li>
<li><strong>新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1并且交换 from、to</strong></li>
<li><strong>minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</strong>
<ul>
<li>对象的复制会更改对象地址，如果用户线程仍在运行，就会造成访问原来对象的地址找不到。</li>
</ul>
</li>
<li><strong>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15</strong>（对象头中占用 4bit：1111B）</li>
<li><strong>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时间更长，如果之后空间仍不足，就会内存溢出。</strong></li>
</ul>
<h2 id="31-分代垃圾回收机制原理">3.1 分代垃圾回收机制原理</h2>
<figure data-type="image" tabindex="19"><img src="https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_1.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">当伊甸园被占满时要添加新对象，触发 minor gc</p>
<figure data-type="image" tabindex="20"><img src="https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_2.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">将伊甸园区的对象进行标记后，非垃圾对象复制到幸存区 TO，并且将这些非垃圾对象的寿命 +1，清空伊甸园内剩余的垃圾对象</p>
<figure data-type="image" tabindex="21"><img src="https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_3.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">交换 FROM 和 TO</p>
<p>创建一个新对象，存放到<strong>伊甸园</strong>，当伊甸园被占满时，触发 <strong>minor gc</strong>，先对伊甸园区域内的对象进行<strong>标记</strong>，标记结束后，采用<strong>复制算法</strong>，将非垃圾对象<strong>复制</strong>到幸存区 TO，并让这些对象的寿命+1，伊甸园剩余的垃圾对象回收掉，<strong>交换</strong> FROM 和 TO，第一次 minor gc 结束。</p>
<figure data-type="image" tabindex="22"><img src="https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_4.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">将伊甸园和幸存区 FROM 中的非垃圾对象复制到幸存区 TO，并将这些对象的寿命 +1，清空伊甸园和幸存区 FROM 中的非垃圾对象，交换 FROM 和 TO。将新对象放入伊甸园。</p>
<p>继续创建对象向伊甸园添加，伊甸园再次被填满，再次触发 minor gc，除了要将伊甸园中的非垃圾对象找到以外，还要把<strong>幸存区 FROM</strong> 中的非垃圾对象找到，将非垃圾对象复制到幸存区 TO，并让这些对象的寿命 +1，伊甸园和幸存区 FROM 的垃圾对象清除，交换 FROM 和 TO，第二次 minor gc 结束。</p>
<figure data-type="image" tabindex="23"><img src="https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_5.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">当幸存区对象的寿命 = 15时，将此对对象移动到老年代。</p>
<figure data-type="image" tabindex="24"><img src="https://epitomm.github.io/post-images/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_6.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">当老年代空间不足，触发 FULL GC，对整个堆进行清理。</p>
<h2 id="32-相关-vm-参数">3.2 相关 VM 参数</h2>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>含义</strong></th>
<th style="text-align:left"><strong>参数</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">堆初始大小</td>
<td style="text-align:left">-Xms</td>
</tr>
<tr>
<td style="text-align:left">堆最大大小</td>
<td style="text-align:left">-Xmx 或 -XX:MaxHeapSize=size</td>
</tr>
<tr>
<td style="text-align:left">新生代大小</td>
<td style="text-align:left">-Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )</td>
</tr>
<tr>
<td style="text-align:left">幸存区比例（动态）</td>
<td style="text-align:left">-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</td>
</tr>
<tr>
<td style="text-align:left">幸存区比例</td>
<td style="text-align:left">-XX:SurvivorRatio=ratio</td>
</tr>
<tr>
<td style="text-align:left">晋升阈值</td>
<td style="text-align:left">-XX:MaxTenuringThreshold=threshold</td>
</tr>
<tr>
<td style="text-align:left">晋升详情</td>
<td style="text-align:left">-XX:+PrintTenuringDistribution</td>
</tr>
<tr>
<td style="text-align:left">GC详情</td>
<td style="text-align:left">-XX:+PrintGCDetails -verbose:gc</td>
</tr>
<tr>
<td style="text-align:left">FullGC 前 MinorGC</td>
<td style="text-align:left">-XX:+ScavengeBeforeFullGC</td>
</tr>
</tbody>
</table>
<ol>
<li>没有运行任何代码时，虚拟机参数 <code>-Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</code> 的堆内存占用情况</li>
</ol>
<pre><code>public class Demo2_1 {
    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc
    // -Xms20M：初始堆空间20M；
    // -Xmx20M：最大堆空间20M；
    // -Xmn10M：新生代10M；
    // -XX:+UseSerialGC：垃圾回收器，幸存区比例不会动态调整
    // -XX:+PrintGCDetails -verbose:gc：打印 gc 详情
    public static void main(String[] args) throws InterruptedException {


    }
</code></pre>
<figure data-type="image" tabindex="25"><img src="https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B0.png" alt="图片" loading="lazy"></figure>
<p>2.Eden 区域不足时，触发 minor gc 时的堆内存占用</p>
<pre><code>package cn.itcast.vm.t2;
import java.util.ArrayList;
public class Demo2_1 {
    private static final int _7MB = 7 * 1024 * 1024;

    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC
    public static void main(String[] args) throws InterruptedException {
        ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
        list.add(new byte[_7MB]);
    }
}
</code></pre>
<p>因为 Eden 共 8M，类加载时创建一些对象占用了 29% 的空间，大概剩余 6M 空间，创建一个 7M 的对象，加入 Eden，Eden 内存不足，会触发垃圾回收。<br>
<img src="https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B02.png" alt="图片" loading="lazy"></p>
<pre><code>package cn.itcast.jvm.t2;

import java.util.ArrayList;

/**
 *  演示内存的分配策略
 */
public class Demo2_1 {
    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * 1024 * 1024;
    private static final int _7MB = 7 * 1024 * 1024;
    private static final int _8MB = 8 * 1024 * 1024;

    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC
    public static void main(String[] args) throws InterruptedException {
        ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
        list.add(new byte[_7MB]);
        list.add(new byte[_512KB]);
    }
}
</code></pre>
<figure data-type="image" tabindex="26"><img src="https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B03.png" alt="图片" loading="lazy"></figure>
<ol start="3">
<li>新生代区域内存不足创建对象，放入老年代</li>
</ol>
<pre><code>package cn.itcast.jvm.t2;

import java.util.ArrayList;

/**
 *  演示内存的分配策略
 */
public class Demo2_1 {
    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * 1024 * 1024;
    private static final int _7MB = 7 * 1024 * 1024;
    private static final int _8MB = 8 * 1024 * 1024;

    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC
    public static void main(String[] args) throws InterruptedException {
        ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
        list.add(new byte[_7MB]);
        list.add(new byte[_512KB]);
        list.add(new byte[_512KB]);
    }
}
</code></pre>
<figure data-type="image" tabindex="27"><img src="https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B04.png" alt="图片" loading="lazy"></figure>
<ol start="4">
<li>添加的对象比新生代总内存大，直接放入老年代且不触发 GC。</li>
</ol>
<pre><code>package cn.itcast.jvm.t2;
import java.util.ArrayList;
public class Demo2_1 {
    private static final int _8MB = 8 * 1024 * 1024;
    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC
    public static void main(String[] args) throws InterruptedException {
        ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
        list.add(new byte[_8MB]);
    }
}
</code></pre>
<figure data-type="image" tabindex="28"><img src="https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B05.png" alt="图片" loading="lazy"></figure>
<ol start="5">
<li>内存溢出</li>
</ol>
<pre><code>package cn.itcast.jvm.t2;

import java.util.ArrayList;

/**
 *  演示内存的分配策略
 */
public class Demo2_1 {
    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * 1024 * 1024;
    private static final int _7MB = 7 * 1024 * 1024;
    private static final int _8MB = 8 * 1024 * 1024;

    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC
    public static void main(String[] args) throws InterruptedException {
        ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
        list.add(new byte[_8MB]);
        list.add(new byte[_8MB]);
    }
}
</code></pre>
<figure data-type="image" tabindex="29"><img src="https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B06.png" alt="图片" loading="lazy"></figure>
<ol start="6">
<li>当内存溢出发生在子线程中，是否会导致 java 进程结束？</li>
</ol>
<pre><code>package cn.itcast.jvm.t2;

import java.util.ArrayList;

/**
 *  演示内存的分配策略
 */
public class Demo2_1 {
    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * 1024 * 1024;
    private static final int _7MB = 7 * 1024 * 1024;
    private static final int _8MB = 8 * 1024 * 1024;

    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails 
    public static void main(String[] args) throws InterruptedException {
        new Thread(() -&gt; {
            ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
            list.add(new byte[_8MB]);
            list.add(new byte[_8MB]);

        }).start();

        System.out.println(&quot;sleep....&quot;);
        Thread.sleep(1000L);  
    }
}
</code></pre>
<figure data-type="image" tabindex="30"><img src="https://epitomm.github.io/post-images/VM%E5%8F%82%E6%95%B07.png" alt="图片" loading="lazy"></figure>
<h1 id="四-垃圾回收器">四、垃圾回收器</h1>
<ol>
<li>串行</li>
</ol>
<ul>
<li>单线程</li>
<li>堆内存较小，适合个人电脑</li>
</ul>
<ol start="2">
<li>吞吐量优先</li>
</ol>
<ul>
<li>多线程</li>
<li>堆内存较大，多核 cpu</li>
<li>让单位时间内，STW 的时间最短。两次垃圾回收：0.2+0.2 = 0.4，<strong>垃圾回收时间占比最低，这样就称吞吐量高</strong></li>
</ul>
<ol start="3">
<li>响应时间优先</li>
</ol>
<ul>
<li>多线程</li>
<li>堆内存较大，多核 cpu</li>
<li>尽可能让<strong>单次 STW 的时间最短</strong>。五次垃圾回收：0.1+0.1+0.1+0.1+0.1 = 0.5</li>
</ul>
<h2 id="41-串行">4.1 串行</h2>
<pre><code>-XX:+UseSerialGC = Serial + SerialOld
</code></pre>
<p>Serial：工作在<strong>新生代</strong>。<strong>复制</strong>算法<br>
SerialOld：工作在<strong>老年代</strong>。<strong>标记整理</strong>算法</p>
<figure data-type="image" tabindex="31"><img src="https://epitomm.github.io/post-images/%E4%B8%B2%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="图片" loading="lazy"></figure>
<p>四个 CPU 在运行，某时刻堆内存不足，触发垃圾回收。触发垃圾回收时，需要让这些线程到达一个<strong>安全点</strong>再停下，因为在垃圾回收的过程中，可能对象的地址发生改变，为了保证安全地使用这些对象地址，需要所有正在工作的用户线程到达这个安全点在停下。因为 Serial、SerialOld 都是<strong>单线程</strong>的垃圾回收器，因此在一个垃圾回收线程运行时，其他的用户线程都要<strong>阻塞</strong>，等到垃圾回收线程结束后，其他的用户线程再恢复运行。</p>
<h2 id="42-吞吐量优先">4.2 吞吐量优先</h2>
<p><strong>吞吐量</strong>：CPU 用于运行用户程序的时间与总时间的比值。</p>
<pre><code>-XX:+UseParallelGC ~ -XX:+UseParallelOldGC
-XX:+UseAdaptiveSizePolicy
-XX:GCTimeRatio=ratio 
-XX:MaxGCPauseMillis=ms 
-XX:ParallelGCThreads=n 
</code></pre>
<p><code>-XX:+UseParallelGC ~ -XX:+UseParallelOldGC</code>：JDK 1.8 默认使用 ParallelGC <strong>并行</strong>的垃圾回收器。<br>
UseParallelGC 并行的新生代垃圾回收器，采用<strong>复制</strong>算法；UseParallelOldGC 并行的老年代垃圾回收器，采用<strong>标记整理</strong>算法。</p>
<p><code>-XX:+UseAdaptiveSizePolicy</code>：自适应大小调整（新生代：Eden 和 Survival）策略</p>
<p><code>-XX:GCTimeRatio=ratio</code>：根据设置目标调整堆的大小以达到期望的目标。吞吐量：垃圾回收时间和总时间占比。1/(1+ratio)。一般堆调大，减少垃圾回收次数。</p>
<p><code>-XX:MaxGCPauseMillis=ms</code>：最大暂停毫秒数（每一次垃圾回收耗时）</p>
<p><code>-XX:ParallelGCThreads=n</code> ：控制 ParallelGC 运行时的<strong>线程数</strong>。</p>
<figure data-type="image" tabindex="32"><img src="https://epitomm.github.io/post-images/%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="图片" loading="lazy"></figure>
<p>四个 CPU 在运行，某一时刻内存不足触发垃圾回收，用户线程就会到达安全点然后停下来，垃圾回收器<strong>开启多个线程进行垃圾回收</strong>。垃圾回收线程个数默认和 CPU 核数相关。回收结束后再恢复其他的线程运行。在垃圾回收时，四核 CPU 都去进行垃圾回收了，<strong>CPU 占用率</strong>会一下达到 100%。</p>
<h2 id="43-响应时间优先">4.3 响应时间优先</h2>
<pre><code>-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld 
-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads 
-XX:CMSInitiatingOccupancyFraction=percent 
-XX:+CMSScavengeBeforeRemark
</code></pre>
<p><code>-XX:+UseConcMarkSweepGC</code> ：<strong>并发标记清除</strong>。垃圾回收器工作的同时，其他用户线程也能同时进行。垃圾回收线程和用户线程并发执行，都要去抢占 CPU。<br>
<code>-XX:+UseParNewGC</code>：工作在新生代，复制算法。 <strong>SerialOld</strong>：老年代垃圾回收器由并发退化为单线程 （基于标记整理的老年垃圾回收器）。<br>
<img src="https://epitomm.github.io/post-images/%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="图片" loading="lazy"></p>
<p>多个 CPU 并行执行，老年代内存不足，所有进程到达安全点，执行<strong>初始标记</strong>，用户线程阻塞，STW；初始标记结束后，用户线程开始运行，停止 STW，与此同时垃圾回收线程<strong>并发标记</strong>，把剩余的垃圾找出来；并发标记结束后，进行<strong>重新标记</strong>，这个过程 STW，因为并发标记的过程用户线程可能对垃圾回收做了干扰，所以并发标记结束后还要再做一次重新标记；重新标记结束后，用户线程继续运行，垃圾回收线程<strong>并发清理</strong>。</p>
<h2 id="44-g1">4.4 G1</h2>
<p>定义：Garbage First</p>
<ul>
<li>2004 论文发布</li>
<li>2009 JDK 6u14 体验</li>
<li>2012 JDK 7u4 官方支持</li>
<li>2017 JDK 9 默认。G1 取代了 CMS</li>
</ul>
<p>适用场景</p>
<ul>
<li>同时注重<strong>吞吐量</strong>（Throughput）和<strong>低延迟</strong>（Low latency），默认的暂停目标是 200 ms</li>
<li>并发的垃圾回收器，和 CMS 一样追求低延迟，可以在用户线程工作的同时垃圾回收线程也并发执行。另外还借鉴了 Parallel：注重吞吐量垃圾回收器的思想，可以进行调整，设置默认暂停目标（<code>-XX:MaxGCPauseMillis</code>）。</li>
<li><strong>超大堆内存</strong>，会<strong>将堆划分为多个大小相等的 Region</strong></li>
</ul>
<p>随着堆内存容量的增大，G1 与 CMS 相比优势更加明显。</p>
<p>将堆划分为多个大小相等的 Region：每个区域都可以独立地作为 Eden、survive、老年代。</p>
<p><code>-XX:G1HeapRegionSize</code>：设置区域的大小，必须是2的幂。如果堆内存过大，回收速度会变慢，因为会涉及对象的复制标记，而分成小的区域进行管理，可以化整为零，进行一些优化加快标记拷贝的速度。</p>
<ul>
<li>整体上是 <strong>标记+整理</strong> 算法（避免标记清除算法产生的内碎片），两个区域之间是复制算法</li>
</ul>
<p>相关 JVM 参数</p>
<pre><code>-XX:+UseG1GC 
-XX:G1HeapRegionSize=size 
-XX:MaxGCPauseMillis=time
</code></pre>
<figure data-type="image" tabindex="33"><img src="https://epitomm.github.io/post-images/G1_2.png" alt="图片" loading="lazy"></figure>
<h3 id="1-g1-垃圾回收阶段">1) G1 垃圾回收阶段</h3>
<figure data-type="image" tabindex="34"><img src="https://epitomm.github.io/post-images/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%98%B6%E6%AE%B5.png" alt="图片" loading="lazy"></figure>
<p>刚开始新生代垃圾收集，如果某时刻老年代内存超过阈值了，在新生代垃圾收集的同时进行并发标记，这个阶段结束后会进行混合收集：会对新生代、幸存区、老年代都进行收集。混合收集结束，Eden 内存释放掉，会再进入新生代垃圾收集。</p>
<h3 id="2-young-collection">2) Young Collection</h3>
<ul>
<li>会 STW</li>
</ul>
<figure data-type="image" tabindex="35"><img src="https://epitomm.github.io/post-images/G1%E5%88%86%E5%8C%BA.png" alt="图片" loading="lazy"></figure>
<p>G1 垃圾回收器把<strong>堆内存划分成大小相等的一个个区域</strong>，每个区域都可独立作为伊甸园、幸存区、老年代。刚开始白色的区域表示是空闲的区域，类加载时新创建的对象刚开始会分配到伊甸园区，绿色的 E 就代表 Eden 区，当 Eden 区域逐渐被占满，就会触发新生代的垃圾回收。</p>
<figure data-type="image" tabindex="36"><img src="https://epitomm.github.io/post-images/G1%E6%96%B0%E7%94%9F%E4%BB%A3%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="图片" loading="lazy"></figure>
<p>新生代垃圾回收会把非垃圾对象以复制算法放入幸存区。</p>
<figure data-type="image" tabindex="37"><img src="https://epitomm.github.io/post-images/G1%E8%80%81%E5%B9%B4%E4%BB%A3.png" alt="图片" loading="lazy"></figure>
<p>当幸存区对象放不下，或幸存区对象寿命达到一定值，会触发垃圾回收，幸存区一部分对象会晋升到老年代，而寿命未达到阈值的会拷贝到另一个幸存区，新生代的非垃圾对象也会复制到这个幸存区。</p>
<h3 id="3-young-collection-cm">3) Young Collection + CM</h3>
<p>CM：Concurrent mark：并发标记</p>
<p><strong>初始标记</strong>：找到那些根对象，标记根对象。</p>
<p><strong>并发标记</strong>：从根对象出发，顺着引用链找到其他非垃圾对象，标记那些其他非垃圾对象。</p>
<ul>
<li>在 Young GC 时会进行 GC Root 的<strong>初始标记</strong></li>
<li>老年代占用堆空间比例达到阈值时，进行<strong>并发标记</strong>（不会 STW），由下面的 JVM 参数决定</li>
</ul>
<pre><code>-XX:InitialtingHeapOccupancyPercent=percent（默认45%）
</code></pre>
<p>老年代占用堆空间内存达到 45% 时，会进行并发标记。<br>
<img src="https://epitomm.github.io/post-images/G1%E8%80%81%E5%B9%B4%E4%BB%A3%E8%BF%87%E5%A4%9A%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0.png" alt="图片" loading="lazy"></p>
<p>E：Eden</p>
<p>S：Survive</p>
<p>O：Old</p>
<h3 id="4-mixed-collection">4) Mixed Collection</h3>
<p>会对 E、S、O 进行<strong>全面垃圾回收</strong></p>
<ul>
<li>最终标记（Remark）会 STW</li>
<li>拷贝存活（Evacuation）会 STW</li>
</ul>
<p>-XX:MaxGCPauseMillis=ms</p>
<figure data-type="image" tabindex="38"><img src="https://epitomm.github.io/post-images/G1%E5%85%A8%E9%9D%A2%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png" alt="图片" loading="lazy"></figure>
<p>Eden 区域的非垃圾对象被复制到 Survive 区域，Survive 区域寿命未达到阈值的非垃圾对象被复制到另一个 Survive 区域，寿命达到阈值的晋升到老年代区域。一部分老年代区域的幸存对象通过复制算法复制到新的的老年代区域，为什么没有把所有老年代都通过箭头指向新的老年代呢？因为 G1 会根据最大暂停时间有选择地进行回收，有时候堆内存空间太大了，老年代的垃圾回收可能时间比较长（复制算法大量对象的复制），就达不到<strong>最大暂停时间</strong>的目标了，为了达到这个目标，G1 会从老年代中挑出<strong>回收价值最高</strong>的区域（垃圾回收后能释放空间多的区域），只从老年代中挑选一部分区域复制，复制的区域少了，就可以达到暂停时间的目标了。如果老年代没有那么多，可以达到最大暂停时间的话， 就会把所有区域都进行复制。</p>
<h3 id="5-full-gc">5) Full GC</h3>
<ul>
<li>SerialGC：串行
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足发生的垃圾收集 - full gc</li>
</ul>
</li>
<li>ParallelGC：并行
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足发生的垃圾收集 - full gc</li>
</ul>
</li>
<li>CMS
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足
<ul>
<li>并发收集失败后 Full GC</li>
</ul>
</li>
</ul>
</li>
<li>G1
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足
<ul>
<li>有一个阈值，当老年代内存达到阈值，就会触发并发标记、混合收集阶段。如果垃圾回收的速度高于新的用户线程产生垃圾的速度，就处于并发垃圾收集阶段，这阶段还不算 Full GC。</li>
<li>当垃圾回收的速度跟不上垃圾产生的速度，并发收集失败，就会触发串行收集，这阶段叫做 Full GC。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-young-collection-跨代引用">6) Young Collection 跨代引用</h3>
<p>新生代回收的跨代引用（老年代引用新生代）问题</p>
<figure data-type="image" tabindex="39"><img src="https://epitomm.github.io/post-images/Card.png" alt="图片" loading="lazy"></figure>
<p>新生代垃圾回收：找到根对象，沿着引用链找到存活对象，存活对象进行复制到幸存区。要找新生代对象的根对象，<strong>根对象有一部分来自于老年代</strong>，老年代的存活对象非常多，如果遍历老年代找根对象效率低，因此把<strong>老年代区域再进行细分</strong>，分成一个个 Card，每个 Card 是512KB，如果老年代其中有一个 <strong>Card 中的对象引用了新生代的某一个对象</strong>，就把这个 <strong>Card 标记为脏</strong>，这样以后，做 GC Root 遍历的时候就不用去找整个老年代了，只需要关注那些脏 Card 即可，减少搜索范围，<strong>提高扫描根对象的效率</strong>。</p>
<ul>
<li>卡表与 Remembered Set</li>
<li>在引用变更时通过 post-write barrier + dirty card queue</li>
<li>concurrent refinement threads 更新 Remembered Set</li>
</ul>
<figure data-type="image" tabindex="40"><img src="https://epitomm.github.io/post-images/Card2.png" alt="图片" loading="lazy"></figure>
<p>粉色的 Card 都是<strong>脏卡区</strong>，Card 内有对象指向新生代区域的对象，新生代会记录 <strong>Remembered Set：从外部对我的引用</strong>，将来对新生代 Eden 进行垃圾回收时，就可以先通过 Remembered Set 知道它对应的哪些脏 Card，然后在到这些脏卡区遍历对象找到 GC Root。通过 <strong>post-write barrier</strong>：写屏障在每次<strong>对象的引用发生变更时，去更新脏 Card</strong>，这个过程是<strong>异步</strong>操作，不会立刻完成脏卡的更新，会把更新指令放在 <strong>dirty card queue 脏卡队列</strong>中，将来由一个线程完成脏卡更新的操作。</p>
<h3 id="7-remark-重标记阶段">7) Remark 重标记阶段</h3>
<ul>
<li>pre-write barrier + satb_mark_queue</li>
</ul>
<p><code>pre-write barrier</code>：写屏障：在对象引用改变前，将对象加入到 <code>satb_mark_queue</code> 队列，将来 remark 从队列中取出对象进一步判断。</p>
<figure data-type="image" tabindex="41"><img src="https://epitomm.github.io/post-images/%E9%87%8D%E6%A0%87%E8%AE%B0_1.png" alt="图片" loading="lazy"></figure>
<p>并发标记阶段对象的 true 和 false，其中图中<strong>黑色</strong>表示已经处理完成，并且有引用在引用它们，在垃圾回收后会被<strong>保留</strong>下来。<strong>灰色</strong>的是正在<strong>触发中</strong>，灰色的因为有强引用黑色的在指向它，所以最终会变成黑色，<strong>白色</strong>的是<strong>尚未处理</strong>，如果有强引用指向它最后会变成黑色，如果没有引用指向它最终还是白色，会被当成垃圾回收。垃圾回收结束后，会根据对象的黑白状态区分它到底应该存活还是被回收。</p>
<p><img src="https://epitomm.github.io/post-images/%E9%87%8D%E6%A0%87%E8%AE%B0_2.png" alt="图片" loading="lazy"><br>
<img src="https://epitomm.github.io/post-images/%E9%87%8D%E6%A0%87%E8%AE%B0_3.png" alt="图片" loading="lazy"></p>
<p><strong>Remark 流程：</strong><br>
<img src="https://epitomm.github.io/post-images/%E9%87%8D%E6%A0%87%E8%AE%B0_4.png" alt="图片" loading="lazy"></p>
<h3 id="8-jdk-8u20-字符串去重">8) JDK 8u20 字符串去重</h3>
<ul>
<li>优点：节省大量内存</li>
<li>缺点：略微多占用了 cpu 时间，新生代回收时间略微增加</li>
</ul>
<p><code>-XX:+UseStringDeduplication</code></p>
<pre><code>String s1 = new String(&quot;hello&quot;); // char[]{'h','e','l','l','o'} 
String s2 = new String(&quot;hello&quot;); // char[]{'h','e','l','l','o'}
</code></pre>
<ul>
<li>将所有新分配的字符串放入一个<strong>队列</strong></li>
<li>当新生代回收时，G1并发检查队列中是否有字符串重复</li>
<li>如果它们值一样，让它们<strong>引用同一个 char[]</strong></li>
<li>注意，与 String.intern() 不一样
<ul>
<li>String.intern() 关注的是<strong>字符串对象</strong></li>
<li>而字符串去重关注的是 <strong>char[]</strong></li>
<li>在 JVM 内部，使用了不同的字符串表</li>
</ul>
</li>
</ul>
<h3 id="9-jdk-8u40-并发标记类卸载">9) JDK 8u40 并发标记类卸载</h3>
<p>所有对象都经过并发标记后，就能知道<strong>哪些类不再被使用</strong>，当一个类加载器的所有类都不再使用，则<strong>卸载它所加载的所有类</strong></p>
<p><code>-XX:+ClassUnloadingWithConcurrentMark</code> 默认启用</p>
<h3 id="10-jdk-8u60-回收巨型对象">10) JDK 8u60 回收巨型对象</h3>
<figure data-type="image" tabindex="42"><img src="https://epitomm.github.io/post-images/%E5%9B%9E%E6%94%B6%E5%B7%A8%E5%9E%8B%E5%AF%B9%E8%B1%A1.png" alt="图片" loading="lazy"></figure>
<p>Region 区域内粉色的 H 就是巨型对象。</p>
<ul>
<li>一个对象<strong>大于 region 的一半</strong>时，称之为巨型对象</li>
<li>G1 <strong>不会对巨型对象进行拷贝</strong></li>
<li><strong>回收时被优先考虑</strong></li>
<li>G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0 的巨型对象就可以在新生代垃圾回收时处理掉</li>
</ul>
<figure data-type="image" tabindex="43"><img src="https://epitomm.github.io/post-images/%E5%9B%9E%E6%94%B6%E5%B7%A8%E5%9E%8B%E5%AF%B9%E8%B1%A1_2.png" alt="图片" loading="lazy"></figure>
<h3 id="11-jdk-9-并发标记起始时间的调整">11) JDK 9 并发标记起始时间的调整</h3>
<p>如果垃圾回收的速度跟不上垃圾产生的速度，最终会退化为 Full GC。G1 的 Full GC 是多线程的，Full GC 的 STW 过程很长，因此要尽可能避免 Full GC 的发生。如何减少 Full GC 呢？提前让垃圾回收开始，并发标记、混合收集提前开始，就能减少 Full GC 发生的几率。</p>
<ul>
<li>并发标记必须在堆空间占满前完成，否则退化为 FullGC</li>
<li>JDK 9 之前需要使用 <code>-XX:InitiatingHeapOccupancyPercent</code>：老年代在堆内存的占比，当超过设置的这个阈值时，就会触发并发垃圾回收。</li>
<li>JDK 9 可以动态调整
<ul>
<li><code>-XX:InitiatingHeapOccupancyPercent</code> 用来设置<strong>初始值</strong></li>
<li>进行<strong>数据采样</strong>并<strong>动态调整</strong></li>
<li>总会添加一个安全的空档空间</li>
</ul>
</li>
</ul>
<h3 id="12-jdk-9-更高效的回收">12) JDK 9 更高效的回收</h3>
<p>250+增强</p>
<p>180+bug修复</p>
<p><a href="https://docs.oracle.com/en/java/javase/12/gctuning">https://docs.oracle.com/en/java/javase/12/gctuning</a></p>
<h1 id="五-垃圾回收调优">五、垃圾回收调优</h1>
<p>预备知识</p>
<ul>
<li>掌握 GC 相关的 VM 参数，会基本的空间调整</li>
<li>掌握相关工具</li>
<li>明白一点：调优跟应用、环境有关，没有放之四海而皆准的法则</li>
</ul>
<p>查看虚拟机运行参数：</p>
<pre><code>&quot;C:\Program Files\Java\jdk1.8.0_172\bin\java&quot; -XX:+PrintFlagsFinal -version | findstr &quot;GC&quot;
</code></pre>
<figure data-type="image" tabindex="44"><img src="https://epitomm.github.io/post-images/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%B0%83%E4%BC%98.png" alt="图片" loading="lazy"></figure>
<h2 id="51-调优领域">5.1 调优领域</h2>
<ul>
<li>内存</li>
<li>锁竞争</li>
<li>cpu 占用</li>
<li>io</li>
</ul>
<h2 id="52-确定目标">5.2 确定目标</h2>
<ul>
<li>【低延迟】还是【高吞吐量】，选择合适的回收器</li>
<li>CMS，G1，ZGC：低延迟</li>
<li>ParallelGC：高吞吐量</li>
<li>Zing</li>
</ul>
<h2 id="53-最快的-gc-是不发生-gc">5.3 最快的 GC 是不发生 GC</h2>
<p>答案是不发生 GC</p>
<ul>
<li>查看 FullGC 前后的内存占用，考虑下面几个问题
<ul>
<li>数据是不是太多？
<ul>
<li><code>resultSet = statement.executeQuery(&quot;select * from 大表 limit n&quot;)</code></li>
</ul>
</li>
<li>数据表示是否太臃肿？
<ul>
<li>对象图</li>
<li>对象大小 16 Integer 24 int 4</li>
</ul>
</li>
<li>是否存在内存泄漏？
<ul>
<li>static Map map 不断向里面放数据</li>
<li>软</li>
<li>弱</li>
<li>第三方缓存实现</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="54-新生代调优">5.4 新生代调优</h2>
<h3 id="新生代的特点">新生代的特点</h3>
<ul>
<li>所有的 new 操作的内存分配非常廉价
<ul>
<li>TLAB thread-local allocation buffer
<ul>
<li>在 Eden 中给<strong>每个线程分配一块私有缓冲区 TLAB</strong>，new 对象时会首先检查 TLAB 缓冲区内是否有空白区域，如果有就优先在 TLAB 这块内存分配。因为线程安全问题，比如线程 1 要用这块内存，分配还没结束时，线程 2 不能也要用这块内存，造成内存分配混乱，  因此在对象的内存分配时，要做线程安全的保护，<strong>减少线程之间对分配时的并发冲突</strong>：TLAB  ：线程局部分配缓冲区。每个线程用自己私有的 Eden 内存来进行内存分配，多个线程即使同时创建对象，也不会产生对内存占用的干扰。</li>
</ul>
</li>
</ul>
</li>
<li>死亡对象的回收代价是零
<ul>
<li>新生代发生垃圾回收时，垃圾回收器复制算法：把 Eden、幸存区 FROM 中的幸存对象都复制到幸存区 TO，Eden、FROM 中的内存就被释放了，因此死亡对象的回收代价是零。</li>
</ul>
</li>
<li>新生代大部分对象用过即死</li>
<li>Minor GC 的时间远远低于 Full GC</li>
</ul>
<h3 id="新生代越大越好吗">新生代越大越好吗？</h3>
<p>-Xmn</p>
<blockquote>
<p>Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery).<br>
GC is performed in this region more often than in other regions. If the size for the young<br>
generation is too small, then a lot of minor garbage collections are performed. If the size is too  large, then only full garbage collections are performed, which can take a long time to complete.<br>
Oracle recommends that you keep the size for the young generation greater than 25% and less than 50% of the overall heap size.</p>
</blockquote>
<p>-Xmn：设置堆中新生代的初始和最大值。<strong>新生代设置小</strong>了，<strong>可用空间少</strong>，创建对象时一旦发现新生代的空间不足就会触发新生代的 <strong>minor gc</strong>。如果新<strong>生代内存太大</strong>了，<strong>老年代的可用空间相对少了</strong>，老年代的空间少了，将来新生代觉得我空闲空间很多，新创建的对象都还不会触发垃圾回收，但是老年代的空间紧张，再触发垃圾回收，就是 full gc，<strong>full gc 的暂停时间比 minor gc 时间更长</strong>。<strong>新生代大于堆内存的 1/4 ,小于 1/2 即可</strong>。</p>
<figure data-type="image" tabindex="45"><img src="https://epitomm.github.io/post-images/%E6%96%B0%E7%94%9F%E4%BB%A3-%E5%90%9E%E5%90%90%E9%87%8F.png" alt="图片" loading="lazy"></figure>
<p><strong>吞吐量</strong>：单位时间能响应的请求数量。</p>
<p>随着新生代空间越来越大，吞吐量越来越高，垃圾回收占用整个 CPU 计算的时间比例少了，CPU时间更多用来处理请求了，吞吐量就变高了，但是到了一定的大小后，会有一个下降：<strong>新生代空间大了，意味着回收的时间较长</strong>。</p>
<p><strong>新生代调整尽可能大</strong>，新生代的垃圾回收都是复制算法，复制算法分成：标记、复制两个阶段，复制阶段花费的时间更多，而<strong>新生代的对象，绝大部分都是朝生夕死的，最终只有少量的对象会存活下来，复制所占用的时间也是相对较短的</strong>，而标记时间相对于复制时间来讲，就显得不是很重要了，所以<strong>新生代调大的情况下，主要时间还是耗费在复制上，即使增得很大，效率也不会有很明显的下降</strong>。</p>
<h3 id="新生代的大小设置">新生代的大小设置</h3>
<ul>
<li><strong>新生代能容纳并发量 *  (一次请求-响应过程产生的对象)的数据</strong>
<ul>
<li>并发量 * 请求 - 响应过程中所产生的的对象</li>
<li>如果一次 请求-响应 过程中产生的对象是 512KB，并发量是 1000，那么新生代理想的内存就是 1000* 512KB = 521M。因为一次 请求-响应的过程，在这次 请求-响应 结束后，大多数对象都会被回收，只要这一次 请求-响应 占用的内存不超过新生代的内存，就不会触发新生代的垃圾回收</li>
</ul>
</li>
<li><strong>幸存区大到能保留当前活跃对象+需要晋升对象</strong>
<ul>
<li>幸存区中有两类对象：<strong>①生命周期较短，下一次垃圾回收就把它回收掉了</strong>，但由于现在还在使用，暂时不能回收；<strong>②将来会被晋升到老年代</strong>，但是由于年龄不够，所以暂时存放在幸存区中。</li>
<li><strong>如果幸存区较小，就会由 JVM 动态调整晋升阈值</strong>，也许本来有些对象不应该晋升的，但是由于幸存区内存不够，导致会提前<strong>把本应回收的对象晋升到老年代</strong>。如果存活时间短的对象被晋升到了老年代，需要等到老年代内存不足，触发 Full GC 时才能把它当做垃圾进行回收，延长了对象的生存时间。</li>
</ul>
</li>
<li><strong>晋升阈值配置得当，让长时间存活对象尽快晋升</strong>
<ul>
<li>如果是一个<strong>长期存活的对象</strong>，把它<strong>留到幸存区里</strong>，只会<strong>耗费幸存区的内存</strong>，并且新生代垃圾回收都是复制算法，要把幸存区的存活对象从 FROM 复制到 TO，如果大量长时间存活的对象不能及早晋升，那么就要留在幸存区被<strong>复制来复制去</strong>。调整晋升阈值，让<strong>长时间存活的对象尽快晋升到老年代</strong>。</li>
</ul>
</li>
</ul>
<p>调整最大晋升阈值：</p>
<pre><code>-XX:MaxTenuringThreshold=threshold 
</code></pre>
<p>显示幸存区对象详情：</p>
<pre><code>-XX:+PrintTenuringDistribution 
</code></pre>
<pre><code>Desired survivor size 48286924 bytes, new threshold 10 (max 10) 
- age 1: 28992024 bytes, 28992024 total 
- age 2: 1366864 bytes, 30358888 total 
- age 3: 1425912 bytes, 31784800 total 
...
</code></pre>
<h2 id="55-老年代调优">5.5 老年代调优</h2>
<h3 id="以-cms-为例">以 CMS 为例</h3>
<p>CMS 垃圾回收器：<strong>低响应时间、并发的</strong>（垃圾回收线程在工作的同时其他用户线程也能在并发的执行：垃圾回收的同时其他用户线程也在运行，就会产生新的浮动垃圾，如果浮动垃圾产生导致内存不足，就会造成 CMS 并发失败，CMS 垃圾回收器退化为 串行老年代垃圾回收器：STW）</p>
<ul>
<li>CMS 的<strong>老年代内存越大越好</strong>
<ul>
<li>预留更多空间，避免浮动垃圾引起的并发失败</li>
</ul>
</li>
<li><strong>先尝试不做调优</strong>，如果没有 Full GC 那么已经可以了，否则先尝试调优新生代</li>
<li>观察<strong>发生 Full GC 时老年代内存占用</strong>，将老年代内存预设调大 1/4 ~ 1/3</li>
</ul>
<pre><code>-XX:CMSInitiatingOccupancyFraction=percent
</code></pre>
<p>老年代的空间占用达到老年代的 percent% 时，触发垃圾回收 percent 越小，老年代垃圾回收触发时间越早。</p>
<h2 id="56-案例">5.6 案例</h2>
<h3 id="案例1-full-gc-和-minor-gc频繁空间紧张">案例1 Full GC 和 Minor GC频繁：空间紧张</h3>
<ul>
<li>问题分析：</li>
</ul>
<p>新生代空间紧张：当业务高峰期来了，大量对象被创建，<strong>新生代被填满</strong>，<strong>幸存区空间紧张</strong>了，<strong>晋升对象的阈值就会降低</strong>，导致很多原来<strong>生存周期很短的对象被晋升到老年代</strong>了，老年代存了大量生存周期很短的对象，进一步触发老年代 <strong>Full GC</strong> 发生。</p>
<ul>
<li>问题解决：</li>
</ul>
<p><strong>增大新生代内存</strong>，新生代内存增大了，内存充裕，新生代的垃圾回收不那么频繁了，增大了幸存区的空间以及晋升阈值，生命周期较短的对象尽可能在幸存区被回收，而不要晋升到老年代，减少老年代 Full GC。</p>
<h3 id="案例2-请求高峰期发生-full-gc单次暂停时间特别长-cms">案例2 请求高峰期发生 Full GC，单次暂停时间特别长 （CMS）</h3>
<ul>
<li>问题分析：</li>
</ul>
<p>查看日志，看 CMS 哪个阶段耗费时间长</p>
<figure data-type="image" tabindex="46"><img src="https://epitomm.github.io/post-images/%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="图片" loading="lazy"></figure>
<p>初始标记和并发标记都是比较快的，<strong>重新标记比较慢</strong>， 查看 GC 日志会把每一阶段耗费的时间显示。</p>
<ul>
<li>问题解决：</li>
</ul>
<p>重新标记会扫描整个内存，不光是要扫描老年代对象，也要同时扫描新生代对象，如果是业务高峰期，新生代对象比较多，扫描标记时间就会很长，因为要根据对象找它的引用，能不能<strong>在重新标记前把新生代的对象做一次垃圾回收</strong>，减少新生代对象的数量，减少重新标记阶段耗费的时间。通过设置：<code>-XX:+CMSScavengeBeforeRemark</code>：在重新标记发生之前，先对新生代进行一次垃圾清理。</p>
<h3 id="案例3-老年代充裕情况下发生-full-gc-cms-jdk17">案例3 老年代充裕情况下，发生 Full GC （CMS jdk1.7）</h3>
<ul>
<li>问题分析：</li>
</ul>
<p>CMS 可能由于空间不足导致并发失败，或者由于空间碎片多都会产生 Full GC。但是经过排查，在 GC 日志没有并发失败或者碎片过多的提示。说明老年代空间充裕，不是由于老年代空间不足产生的 Full GC。<strong>JDK1.7 及以前采用永久代作为方法区的实现，永久代空间不足也会导致 Full GC 发生</strong>，1.8 以后使用元空间就不是由 Java 控制了，所以元空间使用操作系统的空间一般情况是比较充裕的。1.7 以前永久代空间设置小了就会触发整个堆的 Full GC。</p>
<ul>
<li>问题解决：</li>
</ul>
<p>增大永久代的初始值和最大值</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP 系列（二）熟悉 HTTP 协议结构和通讯原理]]></title>
        <id>https://epitomm.github.io/post/http-xi-lie-er-shou-xi-http-xie-yi-jie-gou-he-tong-xun-yuan-li/</id>
        <link href="https://epitomm.github.io/post/http-xi-lie-er-shou-xi-http-xie-yi-jie-gou-he-tong-xun-yuan-li/">
        </link>
        <updated>2020-04-23T06:24:08.000Z</updated>
        <content type="html"><![CDATA[<h1 id="http-特点">HTTP 特点</h1>
<h2 id="支持-客户服务器-模式">支持 客户/服务器 模式</h2>
<p>客户/服务器模式工作的方式是由客户端向服务器发出请求，服务器端响应请求，并进行相应服务。</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/client-server.png" alt="图片" loading="lazy"></figure>
<h2 id="简单快速">简单快速</h2>
<ul>
<li>客户向服务器请求服务时，只需传送<strong>请求方法和路径</strong></li>
<li>请求方法常用的有<strong>GET、HEAD、POST</strong>。每种方法规定了客户与服务器联系的类型不同</li>
<li>由于HTTP协议简单，使得HTTP服务器的程序规模小，因而<strong>通信速度很快</strong></li>
</ul>
<h2 id="灵活">灵活</h2>
<ul>
<li><strong>HTTP允许传输任意类型的数据对象</strong></li>
<li>正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记</li>
</ul>
<h2 id="无连接">无连接</h2>
<ul>
<li>无连接的含义是限制<strong>每次连接只处理一个请求</strong></li>
<li>服务器处理完客户的请求，并收到客户的应答后，即断开连接</li>
<li>采用这种方式可以<strong>节省传输时间</strong></li>
</ul>
<h2 id="无状态">无状态</h2>
<ul>
<li>HTTP协议是无状态协议</li>
<li>无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大</li>
<li>另一方面，在服务器不需要先前信息时它的应答就较快</li>
</ul>
<h1 id="uri-与-url">URI 与 URL</h1>
<p>Q：我们输入在浏览器里的Web地址应该叫URL还是URI？</p>
<p>小A：我们访问的就是<strong>URL</strong>！</p>
<p>小B：不！其实那时<strong>URI</strong>好不好！</p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/URI.png" alt="图片" loading="lazy"></figure>
<ul>
<li>URI：一个紧凑的字符串用来标示抽象或物理资源</li>
<li>A URI 可以进一步被分为定位符、名字或两者都是</li>
<li>术语&quot;Uniform Resource Locator&quot;（URL）是URI的子集，除了确定一个资源，还提供一种定位该资源的主要访问机制（如其网络“位置”）</li>
</ul>
<h2 id="维基百科解释">维基百科解释</h2>
<ul>
<li>URI可以分为URL，URN或同时具备locators 和names特性的一个东西</li>
<li>URN作用就好像一个人的<strong>名字</strong>，URL就像一个人的<strong>地址</strong></li>
<li>换句话说：URN确定了东西的身份，URL提供了找到它的方式</li>
</ul>
<blockquote>
<p>一家公司的总经理有一张名片，上面写了 “北京 xxx 公司总经理张三”、办公室地址 “北京市海淀区长安街35号 xx 楼 xxx 办公室”。<br>
头衔：北京 xxx 公司总经理 —— 张三，建立一个映射，这个头衔就是 URI，<strong>只要看到一个 URI 就知道它代表什么</strong>。<br>
<a href="http://www.baidu.cn">www.baidu.cn</a> —— 百度网，<a href="http://www.baidu.com">www.baidu.com</a> 就是一个 URI<br>
admin@qq.com —— 代表某个人的 QQ 邮箱，admin@qq.com 也是一个 URI<br>
<strong>URI 是一个网络资源的头衔</strong>，是一个统称，通过 URI 可以把网络世界里的每一个事务都加以标记并且区分开来。<br>
“北京 xxx 公司总经理” 是一个 URI，我们知道这个头衔对应的是张三，但是我们不能去找到这个人，因为不知道他的地址，要定位到他就必须要知道他的办公室地址。反映到网络世界，网络世界中的每个资源不只有头衔，还要能够被人访问，所以网络地址也是必须的，否则这个网络资源的存在就没有任何意义了，这个<strong>网络地址就叫做 URL</strong>。</p>
</blockquote>
<ul>
<li>URL是URI的一种，但不是所有的URI都是URL</li>
<li>URI和URL最大的差别是“访问机制（HTTP 还是 FTP）&quot;</li>
<li>URN 是唯一标识的一部分，是身份信息</li>
</ul>
<h2 id="安能辨我是雌雄">安能辨我是雌雄</h2>
<ul>
<li>ftp://ftp.is.co.za/rfc/rfc1808.txt
<ul>
<li>URL，提供了访问机制是 FTP</li>
</ul>
</li>
<li>http://www.ietf.org/rfc/rfc2396.txt
<ul>
<li>URL，提供了访问机制是 HTTP</li>
</ul>
</li>
<li>Idap://[2001:db8::7]/c=GB?objectClass?one
<ul>
<li>URL，提供了访问机制 LDAP</li>
</ul>
</li>
<li>mailto:John.Doe@example.com
<ul>
<li>URL，通过邮件进行访问</li>
</ul>
</li>
<li>news:comp.infosystems.www.servers.unix
<ul>
<li>URL</li>
</ul>
</li>
<li>tel:+1-816-555-1212
<ul>
<li>URI：电话号码可以标识某一个人，但是没有访问机制</li>
</ul>
</li>
<li>telnet://192.0.2.16:80/
<ul>
<li>URL，访问机制 telnet</li>
</ul>
</li>
<li>urn:oasis:names:specification:docbook:dtd:xml:4.1.2
<ul>
<li>URL，地址中已经显示了 urn，没有自己的访问方式</li>
</ul>
</li>
</ul>
<h1 id="http-报文结构分析-请求报文">HTTP 报文结构分析 - 请求报文</h1>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png" alt="图片" loading="lazy"></figure>
<blockquote>
<p>报文头和报文体中间有一行空行<br>
报文体内是表单的数据，不同参数之间使用 &amp; 进行拼接</p>
</blockquote>
<h2 id="http-报文头">HTTP 报文头</h2>
<ul>
<li>HTTP的报文头大体可以分为四类，分别是：通用报文头、请求报文头、响应报文头和实体报文头</li>
<li>在HTTP/1.1里一共规范了47种报文头字段</li>
</ul>
<h3 id="通用报文头">通用报文头</h3>
<table>
<thead>
<tr>
<th style="text-align:left">首部字段名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Cache-Control</td>
<td style="text-align:left">控制缓存的行为</td>
</tr>
<tr>
<td style="text-align:left">Connection</td>
<td style="text-align:left">逐跳首部、连接的管理</td>
</tr>
<tr>
<td style="text-align:left">Date</td>
<td style="text-align:left">创建报文的日期时间</td>
</tr>
<tr>
<td style="text-align:left">Pragma</td>
<td style="text-align:left">报文指令</td>
</tr>
<tr>
<td style="text-align:left">Trailer</td>
<td style="text-align:left">报文末端的首部一览</td>
</tr>
<tr>
<td style="text-align:left">Transfer-Encoding</td>
<td style="text-align:left">指定报文主体的传输编码方式</td>
</tr>
<tr>
<td style="text-align:left">Upgrade</td>
<td style="text-align:left">升级为其他协议</td>
</tr>
<tr>
<td style="text-align:left">Via</td>
<td style="text-align:left">代理服务器的相关信息</td>
</tr>
<tr>
<td style="text-align:left">Warning</td>
<td style="text-align:left">错误通知</td>
</tr>
</tbody>
</table>
<h3 id="请求报文头">请求报文头</h3>
<table>
<thead>
<tr>
<th style="text-align:left">首部字段名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Accept</td>
<td style="text-align:left">用户代理可处理的媒体类型</td>
</tr>
<tr>
<td style="text-align:left">Accept-Charset</td>
<td style="text-align:left">优先的字符集</td>
</tr>
<tr>
<td style="text-align:left">Accept-Encoding</td>
<td style="text-align:left">优先的内容编码</td>
</tr>
<tr>
<td style="text-align:left">Accept-Language</td>
<td style="text-align:left">优先的语言（自然语言）</td>
</tr>
<tr>
<td style="text-align:left">Authorization</td>
<td style="text-align:left">Web 认证信息</td>
</tr>
<tr>
<td style="text-align:left">Expect</td>
<td style="text-align:left">期待服务器的特定行为</td>
</tr>
<tr>
<td style="text-align:left">From</td>
<td style="text-align:left">用户的电子邮箱地址</td>
</tr>
<tr>
<td style="text-align:left">Host</td>
<td style="text-align:left">请求资源所在服务器</td>
</tr>
<tr>
<td style="text-align:left">If-Match</td>
<td style="text-align:left">比较实体标记（ETag）</td>
</tr>
<tr>
<td style="text-align:left">If-Modified-Since</td>
<td style="text-align:left">比较资源的更新时间</td>
</tr>
<tr>
<td style="text-align:left">If-None-Match</td>
<td style="text-align:left">比较实体标记（与 If-Match 相反）</td>
</tr>
<tr>
<td style="text-align:left">If-Range</td>
<td style="text-align:left">资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td style="text-align:left">If-Unmodified-Since</td>
<td style="text-align:left">比较资源的更新时间（与 If-Modified-Since相反）</td>
</tr>
<tr>
<td style="text-align:left">Max-Forwards</td>
<td style="text-align:left">最大传输逐跳数</td>
</tr>
<tr>
<td style="text-align:left">Proxy-Authorization</td>
<td style="text-align:left">代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td style="text-align:left">Range</td>
<td style="text-align:left">实体的字节范围请求</td>
</tr>
<tr>
<td style="text-align:left">Referrer</td>
<td style="text-align:left">对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td style="text-align:left">TE</td>
<td style="text-align:left">传输编码的优先级</td>
</tr>
<tr>
<td style="text-align:left">User-Agent</td>
<td style="text-align:left">HTTP 客户端程序的信息</td>
</tr>
</tbody>
</table>
<h3 id="响应报文头">响应报文头</h3>
<table>
<thead>
<tr>
<th style="text-align:left">首部字段名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Accept-Ranges</td>
<td style="text-align:left">是否接受字节范围请求</td>
</tr>
<tr>
<td style="text-align:left">Age</td>
<td style="text-align:left">推算资源创建经过时间</td>
</tr>
<tr>
<td style="text-align:left">ETag</td>
<td style="text-align:left">资源的匹配信息</td>
</tr>
<tr>
<td style="text-align:left">Location</td>
<td style="text-align:left">令客户端重定向至指定 URI</td>
</tr>
<tr>
<td style="text-align:left">Proxy-Authenticate</td>
<td style="text-align:left">代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td style="text-align:left">Retry-After</td>
<td style="text-align:left">对再次发起请求的时机要求</td>
</tr>
<tr>
<td style="text-align:left">Server</td>
<td style="text-align:left">HTTP服务器的安装信息</td>
</tr>
<tr>
<td style="text-align:left">Vary</td>
<td style="text-align:left">代理服务器缓存的管理信息</td>
</tr>
<tr>
<td style="text-align:left">WWW-Authenticate</td>
<td style="text-align:left">服务器对客户端的认证信息</td>
</tr>
</tbody>
</table>
<h3 id="实体报文头">实体报文头</h3>
<table>
<thead>
<tr>
<th style="text-align:left">首部字段名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Allow</td>
<td style="text-align:left">资源可支持的 HTTP 方法</td>
</tr>
<tr>
<td style="text-align:left">Content-Encoding</td>
<td style="text-align:left">实体主体使用的编码方式</td>
</tr>
<tr>
<td style="text-align:left">Content-Language</td>
<td style="text-align:left">实体主体的自然语言</td>
</tr>
<tr>
<td style="text-align:left">Content-Length</td>
<td style="text-align:left">实体主体的大小（单位：字节）</td>
</tr>
<tr>
<td style="text-align:left">Content-Location</td>
<td style="text-align:left">替代对应资源的 URI</td>
</tr>
<tr>
<td style="text-align:left">Content-MD5</td>
<td style="text-align:left">实体主体的报文摘要</td>
</tr>
<tr>
<td style="text-align:left">Content-Range</td>
<td style="text-align:left">实体主体的位置范围</td>
</tr>
<tr>
<td style="text-align:left">Content-Type</td>
<td style="text-align:left">实体主体的媒体类型</td>
</tr>
<tr>
<td style="text-align:left">Expires</td>
<td style="text-align:left">实体主体过期的日期时间</td>
</tr>
<tr>
<td style="text-align:left">Last-Modified</td>
<td style="text-align:left">资源的最后修改日期时间</td>
</tr>
</tbody>
</table>
<h2 id="accept">ACCEPT</h2>
<ul>
<li>作用：<strong>浏览器端可以接受的媒体类型</strong></li>
</ul>
<p>Accept:<strong>text/html</strong> 代表浏览器可以接受服务器回发的类型为 text/html 也就是我们常说的 html 文档，如果服务器无法返回 text/html 类型的数据，服务器应该返回一个406错误（Non Acceptable）</p>
<p>如果想要给显示的媒体类型增加优先级，则使用q=来额外表示权重值）；重值 q 的范围是0~1（可精确到小数点后 3 位），且 1 为最大值。不指定权重 q 值时，默认权重为 q=1.0。当服务器提供多种内容时，将会首先返回权重值最高的媒体类型。</p>
<h2 id="accept-encoding">Accept-Encoding</h2>
<ul>
<li>作用：浏览器申明自己接收的<strong>编码方法</strong>，通常指定<strong>压缩</strong>方法，是否支持压缩，支持什么压缩方法（gzip，deflate）
<ul>
<li>Accept-Encoding:gzip，deflate</li>
</ul>
</li>
<li>作用：浏览器申明自己接收的语言
<ul>
<li>Accept-Language:zh-cn, zh; q=0.7, en-us, en; q=0.3</li>
<li>客户端在服务器有中文版资源的情况下，会请求其返回中文版对应的响应，没有中文版时，则请求返回英文版响应</li>
</ul>
</li>
<li><strong>Connection:keep-alive</strong> ：当一个网页打开完成后，客户端和服务器之间<strong>用于传输HTTP数据的TCP连接不会关闭</strong>，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。</li>
<li>Connection:close 代表<strong>一个Request</strong>完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭，当客户端再次发送Request，需要重新建立TCP连接</li>
</ul>
<h2 id="host">Host</h2>
<ul>
<li>作用：请求报头域主要用于指定被请求资源的 <strong>Internet主机和端口号</strong>，它通常从HTTP URL中提取出来的</li>
</ul>
<p>我们在浏览器中输入：http://www.fljf.com:8080 刘览器发送的请求消息中，就会包含Host请求报头域，如下：Host：www.fljf.com:8080</p>
<h2 id="referer">Referer</h2>
<p>当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理</p>
<h2 id="user-agent">User-Agent</h2>
<ul>
<li>作用：告诉HTTP服务器，客户端使用的操作系统和浏览器的名称和版本</li>
<li>很多情况下我们会通过User-Agnet来判断浏览器类型，从而进行不同的兼容设计</li>
</ul>
<h2 id="content-type">Content-Type</h2>
<ul>
<li>作用：说明了报文体内对象的媒体类型</li>
</ul>
<p>text/html：HTML格式</p>
<p>text/plain：纯文本格式</p>
<p>text/xml：XML格式</p>
<p>image/gif：gif图片格式</p>
<p>image/jpeg：jpg图片格式</p>
<p>image/png：png图片格式</p>
<p>application/xhtml+xml：XHTML格式</p>
<p>application/xml：XML数据格式</p>
<p>application/atom+xml：Atom XML聚合格式</p>
<p>application/json：JSON数据格式</p>
<p>application/pdf：pdf格式</p>
<p>application/msword：Word文档格式</p>
<p>application/octet-stream：二进制流数据（如常见的文件下载）</p>
<p>application/x-www-form-urlencoded：表单提交</p>
<h1 id="http-报文结构分析-响应报文">HTTP 报文结构分析 - 响应报文</h1>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.png" alt="图片" loading="lazy"></figure>
<h1 id="http-请求方法剖析">HTTP 请求方法剖析</h1>
<p>HTTP/1.1常用方法</p>
<p>①GET</p>
<p>② POST</p>
<p>③ PUT</p>
<p>④HEAD</p>
<p>⑤ DELETE</p>
<p>⑥OPTIONS</p>
<p>⑦TRACE</p>
<p>③ CONNECT</p>
<h2 id="get-获取资源">GET 获取资源</h2>
<ul>
<li>GET方法用来请求访问已被URI识别的资源</li>
<li>指定的资源经服务器端解析后返回响应内容</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/GET%E8%AF%B7%E6%B1%82.png" alt="图片" loading="lazy"></figure>
<ul>
<li>GET方法也可以用来提交表单和其他数据</li>
<li>http://localhost/login.php?username=aa&amp;password=1234 从上面的 URL 请求中，很容易就可以辩认出表单提交的内容</li>
</ul>
<h2 id="post">POST</h2>
<ul>
<li>POST 方法与 GET 功能类似，一般用来<strong>传输实体的主体</strong></li>
<li>POST 方法的主要目的不是获取响应主体的内容</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/POST%E8%AF%B7%E6%B1%82.png" alt="图片" loading="lazy"></figure>
<h3 id="说下-get-和-post-的区别">说下 GET 和 POST 的区别？</h3>
<p>GET 和 POST 本质都是 HTTP 请求，只不过对它们的作用做了界定和适配，并且让他们适应各自的场景。</p>
<ul>
<li>本质区别：GET 只是一次 HTTP请求，POST 先发请求头再发请求体，实际上是两次请求。</li>
<li>从功能上讲，GET 一般用来<strong>从服务器上获取资源</strong>，POST 一般用来<strong>更新服务器上的资源</strong>；</li>
<li>从 REST 服务角度上说，<strong>GET 是幂等</strong>的，即读取同一个资源，总是得到相同的数据，而 <strong>POST 不是幂等</strong>的，因为每次请求对资源的改变并不是相同的；进一步地，GET 不会改变服务器上的资源，而 POST 会对服务器资源进行改变；</li>
<li>从请求参数形式上看，<strong>GET 请求的数据会附在 URL 之后</strong>，即将请求数据放置在 HTTP 报文的 请求头 中，以 ? 分割 URL 和传输数据，参数之间以 &amp; 相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用 BASE64 加密，得出如：%E4%BD%A0%E5%A5%BD，其中 ％XX 中的 XX 为该符号以 16 进制表示的 ASCII)；而 **POST 请求会把提交的数据则放置在是 HTTP 请求报文的 **<strong>请求体</strong> 中；</li>
<li>就安全性而言，<strong>POST 的安全性要比 GET 的安全性高</strong>，因为 GET 请求提交的数据将明文出现在 URL 上，而且 POST 请求参数则被包装到请求体中，相对更安全；</li>
<li>从请求的大小看，GET 请求的长度受限于浏览器或服务器对 URL 长度的限制，允许发送的数据量比较小，而 POST 请求则是没有大小限制的。</li>
</ul>
<h2 id="put">PUT</h2>
<ul>
<li>从客户端向服务器传送的数据<strong>取代指定的文档的内容</strong></li>
<li>PUT方法与POST方法最大的不同是：PUT是幂等的，而POST是不幂等的</li>
<li>因此，我们更多时候将PUT方法用作传输资源</li>
</ul>
<blockquote>
<p>创建对象用 POST，更新对象用 PUT。<br>
但是，HTTP1.1 的 PUT 方法不带有验证机制，存在一定的安全问题，所以一般不使用 PUT，更新对象可以使用 POST 请求，然后在后端代码逻辑处理。</p>
</blockquote>
<h2 id="headdelete">HEAD/DELETE</h2>
<ul>
<li>HEAD类似于GET请求，只不过返回的响应中没有具体的内容，用于<strong>获取报头</strong>。</li>
<li>DELETE请求服务器删除指定的资源。</li>
</ul>
<blockquote>
<p>DELETE 方法没有验证机制，所以一般不使用。</p>
</blockquote>
<h2 id="options">OPTIONS</h2>
<p>用来查询针对请求URI指定的资源支持的方法</p>
<blockquote>
<p>不知道对方支持什么方法，询问一下。</p>
</blockquote>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/OPTIONS%E8%AF%B7%E6%B1%82.png" alt="图片" loading="lazy"></figure>
<h2 id="traceconnect">TRACE/CONNECT</h2>
<ul>
<li>TRACE：回显服务器收到的请求，主要用于测试或诊断</li>
</ul>
<blockquote>
<p>容易引发 XSP 攻击，所以一般不使用 TRACE 请求</p>
</blockquote>
<ul>
<li>CONNECT：开启一个客户端与所请求资源之间的双向沟通的通道，它可以用来创建隧道</li>
</ul>
<blockquote>
<p>代理服务器访问互联网时，就是用 CONNECT 方法。<br>
浏览器向代理服务器发送 CONNECT 请求，代理服务器返回状态码 200，浏览器就和服务器三次握手交换数据，代理服务器只负责传输彼此的数据包，并不能读取数据内容。</p>
</blockquote>
<h1 id="状态码">状态码</h1>
<p>是用以表示网页服务器超文本传输协议响应状态的3位数字代码。</p>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/%E7%8A%B6%E6%80%81%E7%A0%81.png" alt="图片" loading="lazy"></figure>
<h2 id="http-状态码详解">HTTP 状态码详解</h2>
<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1XX</td>
<td style="text-align:left">表示消息。这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。</td>
</tr>
<tr>
<td style="text-align:left">2XX</td>
<td style="text-align:left">表示<strong>成功</strong>。这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。</td>
</tr>
<tr>
<td style="text-align:left">3XX</td>
<td style="text-align:left">表示<strong>重定向</strong>。这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。</td>
</tr>
<tr>
<td style="text-align:left">4XX</td>
<td style="text-align:left">表示<strong>请求错误</strong>。这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。</td>
</tr>
<tr>
<td style="text-align:left">5XX</td>
<td style="text-align:left">表示<strong>服务器错误</strong>。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。</td>
</tr>
</tbody>
</table>
<h3 id="常用http状态码">常用HTTP状态码</h3>
<p>2XX 状态码：</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">状态码英文名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">200</td>
<td style="text-align:left">OK</td>
<td style="text-align:left">请求已成功，请求所希望的响应头或数据体将随此响应返回</td>
</tr>
<tr>
<td style="text-align:left">202</td>
<td style="text-align:left">Accepted</td>
<td style="text-align:left">已接受，已经接受请求，但未处理完成</td>
</tr>
<tr>
<td style="text-align:left">206</td>
<td style="text-align:left">Partial Content</td>
<td style="text-align:left">部分内容，服务器成功处理了部分GET请求</td>
</tr>
</tbody>
</table>
<p>3XX 状态码：</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">状态码英文名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">301</td>
<td style="text-align:left">Moved Permanently</td>
<td style="text-align:left"><strong>永久移动</strong>，请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替（<strong>更换域名</strong>）</td>
</tr>
<tr>
<td style="text-align:left">302</td>
<td style="text-align:left">Found</td>
<td style="text-align:left">临时移动，与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
</tbody>
</table>
<p>4XX 状态码：</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">状态码英文名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left">Bad Request</td>
<td style="text-align:left">客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td style="text-align:left">401</td>
<td style="text-align:left">Unauthorized</td>
<td style="text-align:left">请求要求用户的身份认证</td>
</tr>
<tr>
<td style="text-align:left">403</td>
<td style="text-align:left">Forbidden</td>
<td style="text-align:left">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td style="text-align:left">404</td>
<td style="text-align:left">Not Found</td>
<td style="text-align:left">服务器无法根据客户端的请求找到资源（网页）。</td>
</tr>
</tbody>
</table>
<p>5XX 状态码：</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">状态码英文名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left">Internal Server Error</td>
<td style="text-align:left">服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td style="text-align:left">502</td>
<td style="text-align:left">Bad Gateway</td>
<td style="text-align:left">充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</td>
</tr>
</tbody>
</table>
<h1 id="http状态管理cookie与session">HTTP状态管理：Cookie与Session</h1>
<p>HTTP 是无状态协议，每个请求都是独立的，如果后续处理需要前面的信息，必须重传，就会导致连接传送的数据量增大，于是引入 Cookie 和 Session 保存 HTTP 连接状态。</p>
<h2 id="cookie">Cookie</h2>
<ul>
<li>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就向客户端浏览器颁发一个Cookie。</li>
<li><strong>客户端浏览器</strong>会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态<br>
<img src="https://epitomm.github.io/post-images/cookie.png" alt="图片" loading="lazy"></li>
</ul>
<blockquote>
<p>在浏览器地址栏输入 www.baidu.com ，浏览器向百度服务器发送读取网页的请求，并且把结果显示回显示器上。<br>
发送之前，这个网页在本机电脑上寻找百度网站设置的 cookie 文件，如果找到，浏览器会把 cookie 文件中的数据连同 url 一同发送给百度服务器，服务器收到数据，就会在它的数据库中检索 id、搜索记录等信息，并且记录下这次新的内容，增加到数据库和 cookie 文件中。如果没有检测到 cookie，或者 cookie 信息与数据库信息不符合，说明这是第一次浏览这个网站，服务器就会创建一个新的 id，并且保存到数据库，并给浏览器下发一个 cookie，这样下一次访问就会像前面描述的那样查到 cookie 记录了。</p>
</blockquote>
<h2 id="cookie-工作原理">Cookie 工作原理</h2>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/cookie%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="图片" loading="lazy"></figure>
<p>1.浏览器发送请求到服务器</p>
<p>2.如果是第一次访问这个服务器，服务器 set-cookie</p>
<p>3.服务器通过 set-cookie 这样的一个响应头把 cookie 发送给客户端</p>
<p>4.客户端读取到 set-cookie 之后，把 cookie 存储到本地的文本文件中</p>
<p>5.再次发送请求，会把 cookie 一起发送到服务器端</p>
<p>6.服务器接收到这个 cookie，检查 cookie，证明没问题，确实是我已经存在的用户了，返回响应结果。</p>
<h2 id="session">Session</h2>
<ul>
<li>Session是另一种记录客户状态的机制，保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上</li>
<li>客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了</li>
</ul>
<p>##Session 工作原理<br>
<img src="https://epitomm.github.io/post-images/session%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="图片" loading="lazy"></p>
<blockquote>
<p>用户访问一个服务器，如果服务器启用 session，服务器就要为这个用户创建一个 session，在创建这个 session 的时候，服务器首先检查这个用户发来的请求里，是否包含一个 sessionID，如果包含了，就说明这个用户此前已经登陆过，并且已经创建过 session，就按照这个 sessionID 把 session 从服务器的内存中查找出来。如果查找不到或客户端请求就不包含这个 sessionID，就为这个客户端创建一个新的 session，并且生成一个与此 session 相关的 sessionID，这个 sessionID 在服务端是唯一的，这个 sessionID会在这一次响应中返回到客户端进行保存，保存这个 sessionID 的正是 cookie。</p>
</blockquote>
<h2 id="保存session-id的方式">保存Session ID的方式</h2>
<ul>
<li>Cookie</li>
<li>URL重写：
<ul>
<li>https://.../xxx?sessionID=BpRZx3lQx33ccEoU6QZcEb64（参数）</li>
<li>https://.../xxx;SessionID=BpRZx3lQx33ccEoU6QZcEb64（路径附加信息）</li>
</ul>
</li>
<li>隐藏表单</li>
</ul>
<h2 id="session的有效期">Session的有效期</h2>
<ul>
<li>Session超时失效
<ul>
<li>服务器空间有限，设置 session 有效时间，防止更多的用户访问造成服务器内存溢出</li>
</ul>
</li>
<li>程序调用HttpSession.invalidate()
<ul>
<li>点击退出，手动调用 session 失效方法</li>
</ul>
</li>
<li>服务器进程被停止</li>
<li>Cokie 与 Session理存放位置不同
<ul>
<li>Cookie 保存在客户端</li>
<li>Session 保存在服务端</li>
</ul>
</li>
<li>安全性（隐私策略）的不同
<ul>
<li>Cookie 存储在浏览器，对客户端可见，客户端的程序可修改 Cookie 中的内容</li>
<li>Session 存储在服务器端，对客户端来说是透明的，不存在敏感信息泄露的风险</li>
</ul>
</li>
<li>有效期的不同
<ul>
<li>设置 Cookie 的过期时间为很大的数字，Cookie 就可以在浏览器保存很长时间</li>
<li>服务器端会定时清理超时的 sessionID，避免出现过大的压力</li>
<li>session 依赖名为 sessionID 这样类似的 cookie，而 cookie 的 sessionID 过期时间默许是 -1，所以只要关闭了浏览器，也就是<strong>一次会话</strong>结束，这个 session 就失效了。</li>
</ul>
</li>
<li>对服务器压力的不同
<ul>
<li>session 保管在服务器端，每个用户都保存一个 session，耗费大量内存。</li>
<li>cookie 保存在客户端，不太占用服务器的资源。</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode876. 链表的中间结点]]></title>
        <id>https://epitomm.github.io/post/leetcode876-lian-biao-de-zhong-jian-jie-dian/</id>
        <link href="https://epitomm.github.io/post/leetcode876-lian-biao-de-zhong-jian-jie-dian/">
        </link>
        <updated>2020-04-23T02:57:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个带有头结点 head 的非空单链表，返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<h2 id="示例">示例</h2>
<p>示例 1：</p>
<p>输入：[1,2,3,4,5]<br>
输出：此列表中的结点 3 (序列化形式：[3,4,5])<br>
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。<br>
注意，我们返回了一个 ListNode 类型的对象 ans，这样：<br>
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.</p>
<p>示例 2：</p>
<p>输入：[1,2,3,4,5,6]<br>
输出：此列表中的结点 4 (序列化形式：[4,5,6])<br>
由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</p>
<p>提示：</p>
<p>给定链表的结点数介于 1 和 100 之间。</p>
<h2 id="方法一遍历两次链表">方法一：遍历两次链表</h2>
<h3 id="问题分析">问题分析</h3>
<ul>
<li>
<p>遍历链表，记录下链表长度 length。</p>
</li>
<li>
<p>再遍历链表返回第 length/2 个节点。</p>
</li>
</ul>
<h3 id="复杂度分析">复杂度分析</h3>
<ul>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
</ul>
<p>链表节点数为奇数个时：</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9.png" alt="图片" loading="lazy"></figure>
<p>链表节点数为偶数个时：</p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B92.png" alt="图片" loading="lazy"></figure>
<h3 id="代码">代码</h3>
<pre><code>public class AlgoCasts {
  public class ListNode {
    int val;
    ListNode next;
    ListNode(int x) {
      val = x;
    }
  }
  // Time: O(n), Space: O(1)
  public ListNode getMiddleNodeTwoPass(ListNode head) {
    ListNode p = head;
    int len = 0;
    for (; p != null; p = p.next) ++len;
    p = head;
    for (int i = 0; i &lt; len/2; ++i) p = p.next;
    return p;
  }
}
</code></pre>
<h2 id="方法二快慢指针">方法二：快慢指针</h2>
<h3 id="问题分析-2">问题分析</h3>
<p>快指针一次走两步，慢指针一次走一步，<strong>当快指针遍历完链表时，慢指针正好指向中间节点</strong>。</p>
<h3 id="复杂度分析-2">复杂度分析</h3>
<ul>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
</ul>
<pre><code>while(fast != nul &amp;&amp; fast.next != null){
  fast = fast.next.next; // 快指针移动两步
  slow = slow.next; // 慢指针移动一步
}  
</code></pre>
<p>链表节点数为奇数个时：<br>
<img src="https://epitomm.github.io/post-images/%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9_%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%881.png" alt="图片" loading="lazy"></p>
<p>链表节点数为偶数个时：<br>
<img src="https://epitomm.github.io/post-images/%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9_%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%882.png" alt="图片" loading="lazy"></p>
<h3 id="代码-2">代码</h3>
<pre><code>public class AlgoCasts {
  public class ListNode {
    int val;
    ListNode next;
    ListNode(int x) {
      val = x;
    }
  }
  // Time: O(n), Space: O(1)
  public ListNode getMiddleNodeOnePass(ListNode head) {
    ListNode fast = head, slow = head;
    while (fast != null &amp;&amp; fast.next != null) {
      fast = fast.next.next;
      slow = slow.next;
    }
    return slow;
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP系列（一）了解 HTTP 协议]]></title>
        <id>https://epitomm.github.io/post/httpyi-liao-jie-http-xie-yi/</id>
        <link href="https://epitomm.github.io/post/httpyi-liao-jie-http-xie-yi/">
        </link>
        <updated>2020-04-21T09:10:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="浏览器背后的故事">浏览器背后的故事</h1>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%85%E4%BA%8B.png" alt="图片" loading="lazy"></figure>
<ol>
<li>在浏览器地址栏<strong>输入域名</strong>想要访问某个网站，但是真正标识服务器的而是 IP 地址。</li>
<li>根据域名到 <strong>DNS 服务器中查询目标服务器对应的 IP 地址</strong></li>
<li>浏览器根据查询到的 IP 地址<strong>与 WEB 服务器进行通信</strong>，通信的协议就是 HTTP 协议。</li>
</ol>
<blockquote>
<p>把这个过程类比为电话通信的过程。如果我们想要给某个人打电话。</p>
<ol>
<li>从通讯录翻到这个人的名字（域名）</li>
<li>实际拨打过去的电话号（IP 地址）<br>
我们很容易记住姓名，但很难记住每个人的电话号。</li>
<li>打通电话后需要进行对话，就需要两个人使用共同的语言（HTTP 协议）。</li>
</ol>
</blockquote>
<ol>
<li>WEB 服务器收到请求，到后端进行执行，将执行结果以<strong>响应报文</strong>的形式回传到浏览器，如果直接将响应报文展示出来，是一串串代码，普通人难以理解。</li>
<li>浏览器对响应报文进行<strong>渲染</strong>，使用 HTML 描述对应数据，把网页资源的源代码转换为图像结果。</li>
</ol>
<h2 id="http">HTTP</h2>
<ul>
<li>超文本传输协议（HTTP）是一种<strong>通信协议</strong>，它允许将超文本标记语言（HTML）文档从Web服务器传送到客户端的浏览器。</li>
</ul>
<blockquote>
<p>超文本传输协议：传输超文本（HTML）的协议。在服务端和客户端传输 HTML 要遵守的<strong>规则</strong>。</p>
</blockquote>
<ul>
<li>HTTP是一个属于<strong>应用层的面向对象的协议</strong>，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展</li>
</ul>
<h2 id="web-与-http">WEB 与 HTTP</h2>
<ul>
<li>WEB是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式<strong>图形信息系统</strong>。</li>
<li>建立在Internet上的一种<strong>网络服务</strong>，为浏览者在Internet上查找和浏览信息提供了图形化的、易于访问的直观界面，其中的文档及超级链接将Internet上的信息节点组织成一个互为关联的网状结构。</li>
</ul>
<h1 id="http-协议的前世今生">HTTP 协议的前世今生</h1>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.png" alt="图片" loading="lazy"></figure>
<h1 id="透过-tcpip-看-http">透过 TCP/IP 看 HTTP</h1>
<ul>
<li>HTTP协议是构建在 <strong>TCP/IP</strong> 协议之上的，是TCP/IP协议的一个子集</li>
<li>为了更好的理解HTTP协议，我们先了解一下TCP/IP的相关知识。</li>
</ul>
<h2 id="tcpip协议族">TCP/IP协议族</h2>
<ul>
<li>TCP/IP 协议其实是一系列与互联网相关联的协议集合起来的总称</li>
<li>分层管理是 TCP/IP 协议的重要特征</li>
</ul>
<h2 id="tcpip协议族分层">TCP/IP协议族分层</h2>
<ul>
<li>TCP/IP协议族是由一个四层协议组成的系统，这四层分别为：和数据链路层、网络层、运输层、应用层</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E5%9B%9B%E5%B1%82%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84.png" alt="图片" loading="lazy"></figure>
<h3 id="应用层">应用层</h3>
<ul>
<li>应用层一般是我们编写的应用程序，决定了向用户提供的应用服务。应用层可以通过系统调用与传输层进行通信。</li>
<li>如：<strong>FTP、DNS、HTTP</strong>等。</li>
</ul>
<h3 id="传输层">传输层</h3>
<ul>
<li>传输层通过系统调用向应用层提供处于网络连接中的两台计算机之间的数据传输功能。</li>
<li>在传输层有两个性质不同的协议：**TCP **和 <strong>UDP</strong>。</li>
</ul>
<h3 id="网络层">网络层</h3>
<ul>
<li>网络层用来处理在网络上流动的数据包，数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（<strong>传输路线</strong>）到达对方计算机，并把数据包传输给对方。</li>
</ul>
<h3 id="链路层">链路层</h3>
<ul>
<li>链路层用来处理连接网络的<strong>硬件</strong>部分，包括控制操作系统、硬件设备驱动、NIC（Network Interface Card，网络适配器）以及光纤等物理可见部分。硬件上的范畴均在链路层的作用范围之内。</li>
</ul>
<h2 id="数据包的封装过程">数据包的封装过程</h2>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%B0%81%E8%A3%85%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<h2 id="http-数据传输过程">HTTP 数据传输过程</h2>
<p>发送端发送数据时，数据会从上层传输到下层，且每经过一层都会被打上该层的头部信息。而接收端接收数据时，数据会从下层传输到上层，传输前会把下层的头部信息删除</p>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/HTTP%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<p>发送端从应用层向下走，接收端从链路层向上走。</p>
<ul>
<li>作为发送端的客户端，在<strong>应用层</strong>，通过 HTTP 协议发出一个请求，</li>
<li>为了传输方便，在<strong>传输层</strong>，通过 TCP 协议把应用层收到的数据（HTTP 请求报文）进行分割并且在各个报文上打上标记序号、端口号等信息，发送到网络层</li>
<li>在<strong>网络层</strong>，通过 IP 协议，增加作为目的地的 MAC 地址，转发给链路层。</li>
<li><strong>链路层</strong>添加帧头、帧尾后，通过电信号传输给接收端。</li>
<li><strong>接收端</strong>的服务器在链路层接收到请求的数据，按顺序向上层发送，一直发送到应用层。</li>
</ul>
<h2 id="传输层-tcp-三次握手">传输层 —— TCP 三次握手</h2>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="图片" loading="lazy"></figure>
<p>使用TCP协议进行通信的双方必须先建立连接，然后才能开始传输数据。为了确保连接双方可靠性，在双方建立连接时，TCP协议采用了三次握手策略。</p>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B2.png" alt="图片" loading="lazy"></figure>
<ul>
<li><strong>第一次握手</strong>：客户端发送带有 SYN 标志的连接请求报文段，然后进入SYN_SEND状态，等待服务端的确认。</li>
</ul>
<blockquote>
<p>客户端：客户端发送能力正常<br>
服务端：客户端发送能力正常、服务端接收能力正常</p>
</blockquote>
<ul>
<li><strong>第二次握手</strong>：服务端接收到客户端的 SYN 报文段后，需要发送 ACK 信息对这个 SYN 报文段进行确认。同时，还要发送自己的 SYN 请求信息。服务端会将上述的信息放到一个报文段（SYN+ACK报文段）中，一并发送给客户端，此时服务端将会进入SYN_RECV状态。</li>
</ul>
<blockquote>
<p>客户端：客户端发送能力正常、服务端接收能力正常、客户端接收能力正常、服务端发送能力正常<br>
服务端：客户端发送能力正常、服务端接收能力正常</p>
</blockquote>
<ul>
<li><strong>第三次握手</strong>：客户端接收到服务端的 SYN+ACK 报文段后，会向服务端发送 ACK 确认报文段，这个报文段发送完毕后，客户端和服务端都进入 ESTABLISHED 状态，完成 TCP 三次握手。</li>
</ul>
<blockquote>
<p>客户端：客户端发送能力正常、服务端接收能力正常、客户端接收能力正常、服务端发送能力正常<br>
服务端：客户端发送能力正常、服务端接收能力正常、客户端端接收能力正常、服务端发送能力正常</p>
</blockquote>
<p>三次握手结束后，发送、接收双方都确认了彼此的发送和接收能力都正常。</p>
<h3 id="为什么两次握手不可以">为什么两次握手不可以？</h3>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8D%E5%8F%AF%E4%BB%A5.png" alt="图片" loading="lazy"></figure>
<p>为了防止已经失效的连接请求报文段突然又传送到了 B，因而产生错误。比如下面这种情况：A 发出的第一个连接请求报文段并没有丢失，而是在网路结点长时间滞留了，以致于延误到连接释放以后的某个时间段才到达 B。本来这是一个早已失效的报文段。但是 B 收到此失效的链接请求报文段后，就<strong>误认为 A 又发出一次新的连接请求</strong>。于是就向 A 发出确认报文段，同意建立连接。</p>
<p>对于上面这种情况，如果不进行第三次握手，<strong>B 发出确认后就认为新的运输连接已经建立了</strong>，并一直等待 A 发来数据。B 的许多资源就这样白白浪费了。</p>
<p>如果采用了三次握手，由于 A 实际上并没有发出建立连接请求，所以不会理睬 B 的确认，也不会向 B 发送数据。B 由于收不到确认，就知道 A 并没有要求建立连接。</p>
<h1 id="dns-域名解析">DNS 域名解析</h1>
<ul>
<li>已经介绍了与HTTP协议有着密切关系的TCP/IP协议，接下来介绍的DNS服务也是与HTTP协议有着密不可分的关系。</li>
<li>通常我们访问一个网站，使用的是主机名或者域名来进行访问的。因为相对于IP地址（一组纯数字），域名更容易让人记住。 但TCP/IP协议使用的是IP地址进行访问的，所以必须有个机制或服务把域名转换成IP地址。<strong>DNS</strong>服务就是用来解决这个问题的，它提供<strong>域名到IP地址之间的解析</strong>服务。</li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.png" alt="图片" loading="lazy"></figure>
<p>DNS 服务解析是有层次的，就近原则。</p>
<ul>
<li>本地电脑会将经常使用的域名和 IP 地址建立映射关系并且保存到<strong>系统文件</strong>中，在进行 DNS 解析时，系统会优先从 <strong>hosts 文件</strong>去寻找对应的 IP 地址，如果找到，直接使用 hosts 文件中的 IP 地址。</li>
<li>如果本地 hosts 文件没有找到该域名对应的 IP 地址的映射，向<strong>本地 DNS 服务器</strong>发送请求，查询域名对应的 IP 地址，本地域名服务器找到对应的 IP 地址，响应给浏览器。本地 DNS 服务有限，如果没有找到，依次向上层 DNS 服务器发起请求，</li>
<li>直到 <strong>DNS 根服务器</strong>，如果找到则返回。</li>
</ul>
<h2 id="dns-解析过程">DNS 解析过程</h2>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<h1 id="回溯-http-事务处理过程">回溯 HTTP 事务处理过程</h1>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/HTTP%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<p>当客户端访问Web站点时，首先会通过DNS服务查询到域名的IP地址。然后浏览器生成HTTP请求，并通过TCP/IP协议发送给Web服务器。Web服务器接收到请求后会根据请求生成响应内容，并通过TCP/IP协议返回给客户端。</p>
<h2 id="http-事务处理完整过程">HTTP 事务处理完整过程</h2>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/HTTP%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<ul>
<li>如果使用客户端浏览器浏览页面，需要从中分解出协议名、主机名、端口、对象路径等，得到协议是 HTTP 协议、主机是 mooc.com 主机、端口是 80 端口、路径是 mooc 的根节点。在这一步需要通过 DNS 服务器解析出它的 <strong>IP 地址</strong>。</li>
<li><strong>封装 HTTP 请求的数据包</strong>，把以上部分结合自己的本机信息封装成一个 HTTP 请求的数据包。</li>
<li>数据报向下封装成 <strong>TCP 包</strong>，<strong>三次握手建立 TCP 连接</strong>。</li>
<li>客户端<strong>发送请求</strong>给服务器</li>
<li>服务器进行<strong>响应</strong>，消息体有状态码、版本号</li>
<li><strong>释放 TCP 连接</strong></li>
</ul>
<h1 id="实验">实验</h1>
<ul>
<li>现在，我们已经了解了HTTP协议的基本概念，也知道了我们是如何从浏览器访问到我们想要的网站资源的。</li>
<li>那么对于浏览器来说，HTTP请求到底是什么样子的呢？让我们一起来跟踪查看一下！</li>
</ul>
<h2 id="环境搭建">环境搭建</h2>
<p>下载抓包工具：<a href="https://www.wireshark.org/">https://www.wireshark.org/</a></p>
<h2 id="实验过程">实验过程</h2>
<p>1.因为连接的是 WIFI，所以选择 WLAN，如下：</p>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/wireshark%E9%80%89%E6%8B%A9WLAN.png" alt="图片" loading="lazy"></figure>
<p>2.浏览器栏输入域名 <a href="http://www.baidu.com">www.baidu.com</a>（HTTPS协议）</p>
<p><a href="http://www.jszg.edu.cn/portal/home/index">http://www.jszg.edu.cn/portal/home/index</a>（HTTP协议）</p>
<p>3.Wireshark 点击停止</p>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/wireshark%E5%81%9C%E6%AD%A2.png" alt="图片" loading="lazy"></figure>
<p>4.分析处理过程</p>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/wrieshark%E5%88%86%E6%9E%90%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL 索引详解]]></title>
        <id>https://epitomm.github.io/post/mysql-suo-yin-xiang-jie/</id>
        <link href="https://epitomm.github.io/post/mysql-suo-yin-xiang-jie/">
        </link>
        <updated>2020-04-20T02:53:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="存储引擎">存储引擎</h2>
<p><code>InnoDB</code>：不加任何条件 <code>select</code> 出来的数据是排好序的（按主键字段排序）——聚簇索引。<code>MySQL</code>默认的存储引擎是 <code>InnoDB</code>。</p>
<p><code>MyISAM</code>：不加任何条件 <code>select</code> 出来的数据是没有排序的（按照插入顺序输出）——堆表</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"><code>MyISAM</code></th>
<th style="text-align:center"><code>InnoDB</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>锁级别</strong></td>
<td style="text-align:center">只有<strong>表级锁</strong></td>
<td style="text-align:center">支持<strong>行级锁和表级锁</strong>，默认为行级锁</td>
</tr>
<tr>
<td style="text-align:center">查询性能</td>
<td style="text-align:center">强调的是性能，每次查询具有原子性，执行速度快</td>
<td style="text-align:center">使用了聚簇索引、或需要访问的数据可以放入内存的应用下速度快</td>
</tr>
<tr>
<td style="text-align:center"><strong>是否支持事务</strong></td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center"><strong>是否支持崩溃后的安全恢复</strong></td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">支持。事务、回滚、崩溃修复能力和事务安全型表</td>
</tr>
<tr>
<td style="text-align:center">是否支持外键</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center">是否支持 <code>MVCC</code></td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">支持。应对高并发事务，<code>MVCC</code>比单纯的加锁更高效。<code>MVCC</code>只在<code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作；<code>MVCC</code> 可以使用乐观锁和悲观锁来实现。</td>
</tr>
<tr>
<td style="text-align:center">其他功能</td>
<td style="text-align:center">全文索引、压缩、空间函数</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="索引的分类">索引的分类</h2>
<h3 id="哈希索引">哈希索引</h3>
<ul>
<li>Hash索引底层的数据结构是<strong>哈希表</strong>。</li>
<li>Hash 索引仅仅能满足 &quot;=&quot;、&quot;IN&quot; 的<strong>等值查询</strong>，不能使用范围查询。</li>
<li>Hash 索引不能利用组合索引的<strong>部分索引键</strong>查询。</li>
<li>Hash 索引遇到大量 Hash 值相等的情况后会发生<strong>碰撞</strong>，性能不一定会比 B+树 高。</li>
</ul>
<h3 id="b树-索引">B+树 索引</h3>
<ul>
<li>B+树 索引底层的数据结构是 <strong>B+树</strong>。</li>
<li>B+树 索引支持<strong>范围查询</strong></li>
<li>B+树 索引可以使用组合索引的<strong>部分索引</strong>键查询。</li>
</ul>
<h4 id="innodb-的-b树聚簇索引"><code>InnoDB</code> 的 B+树：聚簇索引</h4>
<p><code>InnoDB</code> 中索引即数据，也就是聚簇索引的B+树的叶子节点中包含完整的数据记录。</p>
<p><code>InnoDB</code> 的 B+Tree 索引分为主索引和辅助索引。</p>
<p>主索引的叶子节点 data 域记录着<strong>完整的数据记录</strong>，这种索引方式被称为<strong>聚簇索引</strong>。</p>
<p>辅助索引的叶子节点的 data 域记录着<strong>主键的值</strong>，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>
<h5 id="聚簇索引">聚簇索引</h5>
<p>聚簇索引的特点：</p>
<ol>
<li>按<strong>主键值的大小</strong>进行记录和页的排序：</li>
</ol>
<ul>
<li>
<p>数据页(叶子节点)里的记录是按照主键值从小到大排序的一个单向链表。</p>
</li>
<li>
<p>数据页(叶子节点)之间也是是按照主键值从小到大排序的一个双向链表。</p>
</li>
<li>
<p>B+树中同一个层的页目录也是按照主键值从小到大排序的一个双向链表。</p>
</li>
</ul>
<ol start="2">
<li>B+树的<strong>叶子节点</strong>存储的是完整的用户记录，就是指这个记录中<strong>存储了所有列的值</strong>（包括隐藏列）。</li>
</ol>
<p>具有这两种特性的B+树称为<strong>聚簇索引</strong>，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在<code>MySQL</code>语句中显式的使用<code>INDEX</code>语句去创建。<code>InnoDB</code>存储引擎会自动的为我们创建聚簇索引。在<code>InnoDB</code>存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的<strong>索引即数据</strong>，数据即索引。</p>
<h4 id="myisam-的-b树非聚簇索引"><code>MyISAM</code> 的 B+树：非聚簇索引</h4>
<p><code>InnoDB</code> 中索引即数据，也就是聚簇索引的那棵B+树的叶子节点中已经把所有完整的用户记录都包含了，而<code>MyISAM</code> 的索引方案虽然也使用树形结构，但是却将<strong>索引和数据分开存储</strong>：</p>
<ul>
<li>
<p>将表中的记录按照记录的<strong>插入顺序</strong>单独存储在一个文件中，称之为数据文件。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。我们可以通过<strong>行号</strong>而快速访问到一条记录。</p>
</li>
<li>
<p>使用 <code>MyISAM</code> 存储引擎的表会把索引信息另外存储到一个称为<strong>索引文件</strong>的另一个文件中。<code>MyISAM</code>会单独为表的主键创建一个索引，只不过在索引的<strong>叶子节点</strong>中存储的不是完整的用户记录，而是<strong>主键值+行号</strong>的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录！这一点和<code>InnoDB</code>是完全不相同的，在<code>lnnoDB</code>存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在<code>MyISAM</code>中却需要进行一次回表操作，意味着<code>MyISAM</code>中建立的索引相当于全部都是二级索引！</p>
</li>
<li>
<p>如果有需要的话，我们也可以对其它的列分别建立索引或者建立联合索引，原理和<code>InnoDB</code>中的索引差不多，不过在叶子节点处存储的是相应的<strong>列+行号</strong>。这些索引也全部都是二级索引。</p>
</li>
</ul>
<blockquote>
<p>为什么不自动为每个列都建立个索引呢？</p>
<p>① 当对表中的数据进行增加、删除和修改的时候，索引也要<strong>动态的维护</strong>，这样就降低了数据的维护速度。</p>
<p>② 索引需要占<strong>物理空间</strong>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p>
<p>③ 创建索引和维护索引要<strong>耗费时间</strong>，这种时间随着数据量的增加而增加。</p>
</blockquote>
<h3 id="二级索引辅助索引">二级索引（辅助索引）</h3>
<p>聚簇索引只能在搜索条件是主键值时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。当我们想以别的列作为搜索条件时我们可以多建几棵B+树，不同的B+树中的数据采用不同的排序规则。</p>
<p>二级索引与聚簇索引有几处不同：</p>
<ol>
<li>
<p>按<strong>指定的索引列的值</strong>来进行排序</p>
</li>
<li>
<p><strong>叶子节点</strong>存储的不是完整的用户记录，而只是<strong>索引列+主键</strong>。</p>
</li>
<li>
<p>目录项记录中不是主键+页号，变成了<strong>索引列+页号</strong>。</p>
</li>
<li>
<p>在对二级索引进行查找数据时，需要根据主键值去聚簇索引中再查找一遍完整的用户记录，这个过程叫做 <strong>回表</strong></p>
</li>
</ol>
<h3 id="联合索引">联合索引</h3>
<p>以多个列的大小为排序规则建立的 B+树 称为联合索引，本质上也是一个二级索引。</p>
<h2 id="覆盖索引">覆盖索引</h2>
<h3 id="什么是覆盖索引">什么是覆盖索引</h3>
<p>如果<strong>一个索引包含（或者说覆盖）所有需要查询的字段的值</strong>，我们就称之为“覆盖索引”。我们知道在<code>InnoDB</code>存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>
<h3 id="覆盖索引使用实例">覆盖索引使用实例</h3>
<p>现在我创建了索引(username,age)，在查询数据的时候：<code>select username , age from user where username = 'Java' and age = 22</code>。要查询出的列在叶子节点都存在！所以，就不用回表。</p>
<h2 id="目录项记录的唯一性">目录项记录的唯一性</h2>
<p>我们需要保证在 B+树 的同一层内节点的目录项记录除页号这个字段以外是唯一的。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p>
<ul>
<li>
<p>索引列的值</p>
</li>
<li>
<p>主键值</p>
</li>
<li>
<p>页号</p>
</li>
</ul>
<h2 id="b树的索引总结">B+树的索引总结</h2>
<ol>
<li>
<p>每个索引都对应一棵<strong>B+树</strong>。用户记录都存储在 B+树 的叶子节点，所有目录记录都存储在非叶子节点。</p>
</li>
<li>
<p><code>InnoDB</code>存储引擎会自动为<strong>主键</strong>（如果没有它会自动帮我们添加）建立<strong>聚簇索引</strong>，聚簇索引的叶子节点包含完整的用户记录。</p>
</li>
<li>
<p>可以为指定的列建立二级索引，二级索引的叶子节点包含的用户记录由<strong>索引列 + 主键</strong>组成，所以如果想通过二级索引来查找完整的用户记录的话，需要通过<strong>回表</strong>操作，也就是在通过二级索引找到主键值之后再到聚簇索引中查找完整的用户记录。</p>
</li>
<li>
<p>B+树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是联合索引的话，则页面和记录先按照联合索引前边的列排序，如果该列值相同，再按照联合索引后边的列排序。</p>
</li>
<li>
<p>通过索引查找记录是从 B+树 的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了页目录，所以在这些页面中的查找非常快。</p>
</li>
</ol>
<p>表：</p>
<pre><code class="language-sql">create table t1(
  a int primary key, 
  b int,
  c int,
  d int, 
  e varchar(20)
)engine=InnoDB;
</code></pre>
<p>表记录：</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E8%A1%A8%E8%AE%B0%E5%BD%95.png" alt="图片" loading="lazy"></figure>
<p>创建索引：</p>
<pre><code class="language-sql">create index idx_t1_bcd on t1(b,c,d);
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B4%A2%E5%BC%95.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">自行创建索引</p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">主键索引</p>
<h2 id="索引的代价">索引的代价</h2>
<h3 id="空间上的代价">空间上的代价</h3>
<p>每建立一个索引都为要它建立一棵 B+树，每一棵 <strong>B+树 的每一个节点都是一个数据页</strong>，一个页默认会占用 <strong>16KB</strong> 的存储空间，一棵很大的 B+树 由许多数据页组成，那是很大的一片存储空间。</p>
<h3 id="时间上的代价">时间上的代价</h3>
<p>每次对表中的数据进行增、删、改操作时，都需要去修改各个 B+树 索引。而且我们讲过，B+树 每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收啥的操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的 B+树 都要进行相关的维护操作。</p>
<h2 id="b树索引实战">B+树索引实战</h2>
<h3 id="全值匹配">全值匹配</h3>
<p>如果我们的搜索条件中的列和索引列一致的话，这种情况就称为全值匹配，比方说下边这个查找语句：</p>
<pre><code class="language-sql">select * from t1 where b=1 and c=1 and d=1；
</code></pre>
<p><code>MySQL</code>中有查询优化器，会分析这些搜索条件并且按照可以使用的索引中列的顺序来决定先使用哪个搜索条件。</p>
<h3 id="匹配左边的列">匹配左边的列</h3>
<pre><code class="language-sql">select * from t1 where b=1；
select * from t1 where b=1 and c=1；
</code></pre>
<p>下面这个<code>sql</code>是用不到索引的</p>
<pre><code class="language-sql">select * from t1 where c = 1；
</code></pre>
<p>因为 B+树 的数据页和记录先是按照 b 列的值排序的，在 b 列的值相同的情况下才使用 c 列进行排序，也就是说 b 列的值不同的记录中 c 的值可能是无序的。而现在你跳过 b 列直接根据 c 的值去查找，这是做不到的。</p>
<h3 id="匹配列前缀"><strong>匹配列前缀</strong></h3>
<p>但是需要注意的是，如果只给出后缀或者中间的某个字符串，比如这样：</p>
<pre><code class="language-sql">select * from t1 where b like ''%101%';
</code></pre>
<p>MySQL 就无法快速定位记录位置了，所以只能全表扫描了。有时候我们有一些匹配某些字符串后缀的需求，比方说某个表有一个url列，该列中存储了许多url：</p>
<pre><code>www.baidu.com 

www.google.com 

www.qq.com
</code></pre>
<p>假设已经对该 url 列创建了索引，如果我们想查询以 com 为后缀的网址的话可以这样写查询条件：WHERE url LIKE '%com'，但是这样的话无法使用该 url 列的索引。为了在查询时用到这个索引而不至于全表扫描，我们可以把后缀查询改写成前缀查询，不过我们就得把表中的数据全部逆序存储一下，也就是说我们可以这样保存 url 列中的数据：</p>
<pre><code>moc.udiab.www 

moc.e1goog.www

moc.qq.www
</code></pre>
<p>这样再查找以com为后缀的网址时搜索条件便可以这么写：WHERE url LIKE 'moc%'，这样就可以用到索引了。</p>
<h3 id="匹配范围值">匹配范围值</h3>
<p>查询方式：</p>
<ul>
<li>
<p>辅助索引查询成本+回表成本</p>
</li>
<li>
<p>全表扫描成本</p>
</li>
</ul>
<p>所有记录都是按照索引列的值从小到大的顺序排好序的，所以这极大的方便我们查找索引列的值在某个范围内的记录。比方说下边这个查询语句：</p>
<pre><code>select * from t1 where b &gt; 1 and b &lt; 2000;
</code></pre>
<p>由于B+树中的数据页和记录是先按 b 列排序的，所以我们上边的查询过程其实是这样的：</p>
<ul>
<li>
<p>找到 b 值为 1 的记录。</p>
</li>
<li>
<p>找到 b 值为 20000 的记录。</p>
</li>
<li>
<p>由于所有记录都是由链表连起来的（记录之间用单链表，数据页之间用双链表），所以他们之间的记录都可以很容易的取出来</p>
</li>
<li>
<p>找到这些记录的主键值，再到聚簇索引中回表查找完整的记录。</p>
</li>
</ul>
<p>不过在使用联合进行范围查找的时候需要注意，如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到 B+树 索引，比方说这样：</p>
<pre><code class="language-sql">select * from t1 where b &gt; 1 and c &gt; 1;
</code></pre>
<p>上边这个查询可以分成两个部分：</p>
<ol>
<li>
<p>通过条件 b&gt;1 来对 b 进行范围查找，查找的结果可能有多条 b 值不同的记录，</p>
</li>
<li>
<p>对这些 b 值不同的记录继续通过 c&gt;1 继续过滤。</p>
</li>
</ol>
<p>这样子对于联合索引来说，只能用到 b 列的部分，而用不到 c 列的部分，因为只有 b 值相同的情况下才能用 c 列的值进行排序（select * from t1 where b = 1 and c &gt;1），而这个查询中通过 b 进行范围查找的记录中可能并不是按照 c 列进行排序的，所以在搜索条件中继续以 c 列进行查找时是用不到这个B+树索引的。</p>
<h3 id="精确匹配某一列并范围匹配另外一列">精确匹配某一列并范围匹配另外一列</h3>
<p>对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找，比方说这样：</p>
<pre><code class="language-sql">select * from t1 where b=1 and c&gt;1；
</code></pre>
<h3 id="排序">排序</h3>
<p>我们在写查询语句的时候经常需要对查询出来的记录通过 ORDER BY 子句按照某种规则进行排序。一般情况下，我们只能把记录都加载到内存中，再用一些排序算法，比如快速排序、归并排序等等在内存中对这些记录进行排序，有的时候可能查询的结果集太大以至于不能在内存中进行排序的话，还可能暂时借助磁盘的空间来存放中间结果，排序操作完成后再把排好序的结果集返回到客户端。在MySQL中，把这种在内存中或者磁盘上进行排序的方式统称为<strong>文件排序</strong>（英文名：filesort），这些排序操作非常慢。但是如果 ORDER BY 子句里使用到了我们的索引列，就有可能省去在内存或文件中排序的步骤，比如下边这个简单的查询语句：</p>
<pre><code class="language-sql">select * from t1 order by b，c，d
</code></pre>
<p>这个查询的结果集需要先按照 b 值排序，如果记录的 b 值相同，则需要按照 c 来排序，如果 c 的值相同，则需要按照 d 排序。因为这个 B+ 树索引本身就是按照上述规则排好序的，所以直接从索引中提取数据，然后进行回表操作取出该索引中不包含的列就好了。</p>
<h3 id="分组">分组</h3>
<pre><code class="language-sql">select b，c，d，count（*）from t1 group by b，c，d；
</code></pre>
<p>这个查询语句相当于做了3次分组操作：</p>
<ol>
<li>
<p>先把记录按照b值进行分组，所有 b 值相同的记录划分为一组。</p>
</li>
<li>
<p>将每个 b 值相同的分组里的记录再按照 c 的值进行分组，将 title 值相同的记录放到一个小分组里，所以看起来就像在一个大分组里又化分了好多小分组。</p>
</li>
<li>
<p>再将上一步中产生的小分组按照 d 的值分成更小的分组，所以整体上看起来就像是先把记录分成一个大分组，然后把大分组分成若干个小分组，然后把若干个小分组再细分成更多的小小分组。</p>
</li>
</ol>
<p>然后针对那些小小分组进行统计，比如在我们这个查询语句中就是统计每个小小分组包含的记录条数。如果没有索引的话，这个分组过程全部需要在内存里实现，而如果有了索引的话，恰巧这个分组顺序又和我们的 B+树 中的索引列的顺序是一致的，而我们的 B+树 索引又是按照索引列排好序的，所以可以直接使用 B+树 索引进行分组。</p>
<p>和使用 B+树 索引进行排序是一个道理，分组列的顺序也需要和索引列的顺序一致，也可以只使用索引列中左边的列进行分组。</p>
<h3 id="使用联合索引进行排序或分组的注意事项">使用联合索引进行排序或分组的注意事项</h3>
<p>对于联合索引有个问题需要注意，ORDER BY 的子句后边的列的顺序也必须按照索引列的顺序给出，如果给出 order by c，b 的顺序，那也是用不了 B+树 索引的。</p>
<p>同理，order by b，order by b，c 这种匹配索引左边的列的形式可以使用部分的 B+树 索引。当联合索引左边列的值为常量，也可以使用后边的列进行排序，比如这样：</p>
<pre><code class="language-sql">select * from t1 where b=1 order by c，d；
</code></pre>
<p>这个查询能使用联合索引进行排序是因为 b 列的值相同的记录是按照 c，d 排序的。</p>
<h3 id="不可以使用索引进行排序或分组的几种情况">不可以使用索引进行排序或分组的几种情况</h3>
<p><code>ASC</code>、<code>DESC</code>混用</p>
<p>对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是 <code>ASC</code> 规则排序，要么都是 <code>DESC</code> 规则排序。</p>
<blockquote>
<p>ORDER BY 子句后的列如果不加 <code>ASC</code> 或者 <code>DESC</code> 默认是按照 <code>ASC</code> 排序规则排序的，也就是升序排序的。</p>
</blockquote>
<pre><code class="language-sql">select * from t1 order by b ASC，c DESC；
</code></pre>
<p>这个查询时用不到索引的。</p>
<h2 id="如何建立索引">如何建立索引</h2>
<h3 id="考虑索引选择性">考虑索引选择性</h3>
<p>索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数的比值：</p>
<pre><code>选择性=基数/记录数
</code></pre>
<p>选择性的取值范围为（0，1]，选择性越高的索引价值越大。如果选择性等于1，就代表这个列的不重复值和表记录数是一样的，那么对这个列建立索引是非常合适的，如果选择性非常小，那么就代表这个列的重复值是很多的，不适合建立索引。</p>
<h3 id="考虑前缀索引">考虑前缀索引</h3>
<p>用列的前缀代替整个列作为索引 key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引 key 变短而减少了索引文件的大小和维护开销。</p>
<blockquote>
<p>使用mysql官网提供的示例数据库：<a href="https://dev.mysql.com/doc/employee/en/employees-installation.html">https://dev.mysql.com/doc/employee/en/employees-installation.html</a></p>
<p>github地址：<a href="https://github.com/datacharmer/test_db">https://github.com/datacharmer/test_db</a></p>
</blockquote>
<p>employees表只有一个索引&lt;emp_no&gt;，那么如果我们想按名字搜索一个人，就只能全表扫描了：</p>
<pre><code class="language-sql">EXPLAIN SELECT * FROM employees.employees WHERE first_name='Eric' AND last_name='Anido';
</code></pre>
<p>那么可以对 &lt;first_name&gt; 或 &lt;first_name，last_name&gt; 建立索引，看下两个索引的选择性：</p>
<pre><code class="language-sql">SELECT count(DISTINCT(first_name))/count(*) AS Selectivity FROM employees.employees; -- 0.0042

SELECT count(DISTINCT(concat(first_name, last_name)))/count(*) AS Selectivity FROM employees.employees; -- 0.9313
</code></pre>
<p>&lt;first_name&gt;显然选择性太低，&lt;first_name，last_name&gt;选择性很好，但是first_name和last_name加起来长度为30，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如&lt;first_name, left(last_name, 3)&gt;，看看其选择性：</p>
<pre><code class="language-sql">SELECT count(DISTINCT(concat(first_name, left(last_name, 3))))/count(*) AS Selectivity FROM employees.employees; -- 0.7879
</code></pre>
<p>选择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4：</p>
<pre><code class="language-sql">SELECT count(DISTINCT(concat(first_name, left(last_name, 4))))/count(*) AS Selectivity FROM employees.employees; -- 0.9007
</code></pre>
<p>这时选择性已很理想了，而这个索引的长度只有18，比&lt;first_name，last_name&gt;短了接近一半，建立前缀索引的方式为：</p>
<pre><code class="language-sql">ALTER TABLE employees.employees ADD INDEX first_name_last_name4 (first_name,last_name(4));
</code></pre>
<p>前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于 OFRDER BY 和 GROUP BY 操作，也不能用于覆盖索引。</p>
<h3 id="总结">总结</h3>
<ul>
<li>
<p>索引列的类型尽量小</p>
</li>
<li>
<p>利用索引字符串值的前缀</p>
</li>
<li>
<p>主键自增</p>
</li>
<li>
<p>定位并删除表中的重复和冗余索引</p>
</li>
<li>
<p>尽量使用覆盖索引进行查询，避免回表带来的性能损耗。</p>
</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<p>https://cyc2018.github.io/CS-Notes/#/notes/MySQL</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一篇文章彻底搞定 NIO]]></title>
        <id>https://epitomm.github.io/post/yi-pian-wen-zhang-che-di-gao-ding-nio/</id>
        <link href="https://epitomm.github.io/post/yi-pian-wen-zhang-che-di-gao-ding-nio/">
        </link>
        <updated>2020-04-19T06:58:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="用发展的眼光看看-bio">用发展的眼光看看 BIO</h1>
<h2 id="jdk14">JDK1.4</h2>
<ul>
<li>java.io包  XXX 类</li>
<li>BIO：Blocking IO：同步阻塞的 IO</li>
<li>Socket 应用程序：
<ul>
<li>监听端口：ServerSocket(9999);</li>
<li>获取客户端的 Socket：serverSocket.accept();</li>
<li>获取 IO 流对象，进行服务端和客户端的数据交互：socket.getInputStream()、getOutputStream()</li>
</ul>
</li>
</ul>
<h2 id="jdk14-之后">JDK1.4 之后</h2>
<ul>
<li>NIO：Non-Blocking IO 同步非阻塞</li>
<li>java.nio 包</li>
<li>对 NIO 做一个封装：netty</li>
</ul>
<h1 id="图解与代码展现bio及问题所在">图解与代码展现BIO及问题所在</h1>
<h2 id="单线程-bio">单线程 BIO</h2>
<h3 id="代码">代码</h3>
<pre><code>package com.gupao;
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
public class BIOServer {
    public static void main(String[] args) {
        byte [] bs = new byte[1024];
        List&lt;Socket&gt; list = new ArrayList&lt;&gt;();
        try(ServerSocket serverSocket = new ServerSocket(9999)) {
            System.out.println(&quot;BIOServer has started, listening on port:&quot; + serverSocket.getLocalSocketAddress());
            while (true){
                Socket clientSocket = serverSocket.accept();
                System.out.println(&quot;Connection from &quot; + clientSocket.getRemoteSocketAddress());
                // 业务处理的代码   
                try(Scanner input = new Scanner(clientSocket.getInputStream())) {
                    while (true){
                        String request = input.nextLine();
                        if(&quot;quit&quot;.equals(request)){
                            break;
                        }
                        System.out.println(String.format(&quot;From %s : %s&quot;, clientSocket.getRemoteSocketAddress(), request));
                        String response = &quot;From BIOServer Hello &quot; + request + &quot;.\n&quot;;
                        clientSocket.getOutputStream().write(response.getBytes());
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h3 id="运行结果">运行结果</h3>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/%E5%8D%95%E7%BA%BF%E7%A8%8BBIO%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="图片" loading="lazy"></figure>
<h3 id="分析">分析</h3>
<ul>
<li>第一个 Server 启动， 阻塞在 accept() 方法上，等待第二个 Server 的连接；</li>
<li>第二个 Server 连接上后，第一个 Server 不再阻塞在 accept() 上，继续向下运行，阻塞在 Scanner 的 nextLine() 方法上，等待第二个 Server 发送数据；</li>
<li>第二个 Server 数据准备好后，给第一个 Server 发送数据，第一个 Server 的 nextLine() 方法不再阻塞，继续向下运行，再次进行 while 循环，重新阻塞在 “等待数据准备好” 的方法上。</li>
<li>第三个 Server 进行连接，第一个 Server 无法接收到第三个 Server 连接成功请求，第三个 Server 也无法向第一个 Server 发送数据。
<ul>
<li>只有第二个 Server 通过 &quot;quit&quot; 与第一个 Server 断开连接后，第三个 Server 才能与第一个 Server 进行交互</li>
</ul>
</li>
</ul>
<p><strong>总结：不能使用两个客户端同时连接一个 Server 进行操作</strong></p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/%E5%8D%95%E7%BA%BF%E7%A8%8BBIO%E5%88%86%E6%9E%90.png" alt="图片" loading="lazy"></figure>
<h1 id="仔细想想bio的核心问题及解决方案">仔细想想BIO的核心问题及解决方案</h1>
<h2 id="多线程">多线程</h2>
<p><strong>那么如何同时处理多个客户端数据交互请求呢？</strong></p>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/%E5%A4%9A%E7%BA%BF%E7%A8%8BBIO.png" alt="图片" loading="lazy"></figure>
<h2 id="线程池">线程池</h2>
<p>Client 越来越多， Server 端的线程就会越来越多，但是 Server 端的线程受 Server 端资源、CPU 影响，不能无限增大。就需要有效地<strong>控制线程的数量</strong>。</p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E7%BA%BF%E7%A8%8B%E6%B1%A0BIO.png" alt="图片" loading="lazy"></figure>
<h2 id="线程池-bio">线程池 BIO</h2>
<h3 id="代码-2">代码</h3>
<pre><code>package com.gupao;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ServerThreadPool {
    public static void main(String[] args) {
        // 线程池
        ExecutorService executor = Executors.newFixedThreadPool(2);

        RequestHandler requestHandler = new RequestHandler();
        // 监听
        try(ServerSocket serverSocket = new ServerSocket(9999)) {
            System.out.println(&quot;NIOServer has started, listening on port:&quot; + serverSocket.getLocalSocketAddress());
            while (true){
                Socket clientSocket = serverSocket.accept();
                System.out.println(&quot;Connection from &quot; + clientSocket.getRemoteSocketAddress());
                // 有客户端连接上来了，交给线程池处理
                executor.submit(new ClientHandler(clientSocket,requestHandler));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

package com.gupao;

import java.io.IOException;
import java.net.Socket;
import java.util.Scanner;

/**
 * 每个 Clinet 连接上来后，给它分配一个线程去执行对应的 Ruunable 任务
 */
public class ClientHandler implements Runnable {

    private final Socket clientSocket;
    private final RequestHandler requestHandler;

    public ClientHandler(Socket clientSocket, RequestHandler requestHandler) {
        this.clientSocket = clientSocket;
        this.requestHandler = requestHandler;
    }

    @Override
    public void run() {
        try(Scanner input = new Scanner(clientSocket.getInputStream())) {
            while (true){
                String request = input.nextLine();
                if(&quot;quit&quot;.equals(request)){
                    break;
                }
                System.out.println(String.format(&quot;From %s : %s&quot;, clientSocket.getRemoteSocketAddress(), request));
                // 真正的业务处理
                String response = requestHandler.handler(request);
                clientSocket.getOutputStream().write(response.getBytes());
            }
        } catch (IOException e) {
            System.out.println(&quot;Caught exception: &quot; + e);
            throw new RuntimeException(e);
        }
    }
}

package com.gupao;

/**
 * 业务处理代码
 */
public class RequestHandler {
    public String handler(String request){
        return &quot;From Server Hello &quot; + request + &quot;.\n&quot;;
    }
}
</code></pre>
<h3 id="运行结果-2">运行结果</h3>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/%E7%BA%BF%E7%A8%8B%E6%B1%A0BIO%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="图片" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E7%BA%BF%E7%A8%8B%E6%B1%A0BIO%E7%BC%BA%E9%99%B7.png" alt="图片" loading="lazy"></figure>
<h1 id="顺其自带推导出nio的原理和代码实现">顺其自带推导出NIO的原理和代码实现</h1>
<h2 id="选择器-selector">选择器 Selector</h2>
<p>如果线程池的大小为 60，来了 60 个请求，Server 端正常应该可以同时处理这 60个请求。但是线程要想被执行的话， 一定要去抢到 CPU 的执行权，CPU 进行这 60 个线程的切换，<strong>频繁的线程上下文切换</strong>消耗 CPU 资源过多，利用率太低。多线程的情况下，线程的数量会影响 CPU 的性能，这就需要控制线程数量。</p>
<p><strong>线程创建的时机</strong></p>
<p>每来一个 Client 请求连接 accept()，就为它创建一个线程，这个线程会一直等待客户端的数据:input.nextLine();（<strong>阻塞</strong>）。</p>
<p><strong>有没有办法不阻塞</strong>？</p>
<p><strong>延迟线程创建的时机</strong>，<strong>等数据准备好以后，才去创建线程</strong>。线程的数量就会得到有效控制（有的 Client 只是连接，并不进行 IO）-&gt; CPU 用于上下文切换的时间减少 -&gt; CPU 利用率提升。</p>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/NIO%E9%80%89%E6%8B%A9%E5%99%A8.png" alt="图片" loading="lazy"></figure>
<p>注意看下面两段代码的注释：</p>
<pre><code>package com.gupao;

import java.io.IOException;
import java.net.Socket;
import java.util.Scanner;

/**
 * 每个 Clinet 连接上来后，给它分配一个线程去执行对应的 Ruunable 任务
 */
public class ClientHandler implements Runnable {

    private final Socket clientSocket;
    private final RequestHandler requestHandler;

    public ClientHandler(Socket clientSocket, RequestHandler requestHandler) {
        this.clientSocket = clientSocket;
        this.requestHandler = requestHandler;
    }

    @Override
    public void run() {
        // 说明线程已经创建了，
        try(Scanner input = new Scanner(clientSocket.getInputStream())) {
            while (true){
                // 等待客户端的输入数据 —— 阻塞的（当前虽然创建了一个线程，但它没有被用到，就浪费了。能不能等到真正处理 IO 的时候才去创建线程）
                String request = input.nextLine();
                if(&quot;quit&quot;.equals(request)){
                    break;
                }
                System.out.println(String.format(&quot;From %s : %s&quot;, clientSocket.getRemoteSocketAddress(), request));
                // 响应客户端
                String response = requestHandler.handler(request);
                clientSocket.getOutputStream().write(response.getBytes());
            }
        } catch (IOException e) {
            System.out.println(&quot;Caught exception: &quot; + e);
            throw new RuntimeException(e);
        }
    }
}
</code></pre>
<pre><code>package com.gupao;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ServerThreadPool {
    public static void main(String[] args) {
        // 线程池
        ExecutorService executor = Executors.newFixedThreadPool(2);

        RequestHandler requestHandler = new RequestHandler();
        // 监听
        try(ServerSocket serverSocket = new ServerSocket(9999)) {
            System.out.println(&quot;NIOServer has started, listening on port:&quot; + serverSocket.getLocalSocketAddress());
            while (true){
                Socket clientSocket = serverSocket.accept();
                System.out.println(&quot;Connection from &quot; + clientSocket.getRemoteSocketAddress());
                // 线程创建的时机——每个客户端来了就为它创建一个线程

//                map.put(clientSocket,&quot;Accepted&quot;);   // 不创建线程
//                什么时候创建线程 —— clientSocket 真正进行 IO 时，采取创建线程

                executor.submit(new ClientHandler(clientSocket,requestHandler));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h2 id="通道-channel">通道 Channel</h2>
<p>Client 与 Server 连接进行数据交互，然后数据再返回给 Client。</p>
<p>而在这个过程中，每次数据交互结束后，连接就会断开，</p>
<p>而建立连接需要三次握手很耗时，连接是很宝贵的，优化连接的方式：建立一条条<strong>通道</strong>。</p>
<p>连接和数据传输就在通道中进行，通道可以复用。</p>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/NIO%E9%80%9A%E9%81%93.png" alt="图片" loading="lazy"></figure>
<h2 id="缓存-buffer">缓存 Buffer</h2>
<p>阻塞/非阻塞 IO：实际上是针对的应用程序和 OS 数据之间交互的这样一种方式。</p>
<p>非阻塞 IO：OS 没有把所有数据全部传输完成，应用程序不会一直等待操作数据，应用程序允许 OS 一会传输一段数据。应用程序把每次接受到的一小段数据放到<strong>缓存</strong>内。</p>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/NIO%E7%BC%93%E5%AD%98.png" alt="图片" loading="lazy"></figure>
<p>很多情况下会发现，处理数据的时候，的确用的是多线程，但这个多线程不是为了解决 IO 阻塞问题。</p>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/NIO%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt="图片" loading="lazy"></figure>
<h2 id="nio-代码">NIO 代码</h2>
<pre><code>package com.gupao;

import java.awt.image.DataBufferByte;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.util.Iterator;
import java.util.Set;

public class NIOServer {
    public static void main(String[] args) throws IOException {
        // 1.Channel 通道
        // 服务端 Channel
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        // 服务端 Channel 设置为非阻塞
        serverSocketChannel.configureBlocking(false);
        // Channel 绑定端口
        serverSocketChannel.bind(new InetSocketAddress(9999));
        System.out.println(&quot;NIOServer has started, listening on port: &quot; + serverSocketChannel.getLocalAddress());

        // 2.Selector 选择器：注册和选择哪个 Channel 进行读/写
        Selector selector = Selector.open();
        // 将连接上来的 Channel 注册到 Selector 选择器上，并且将默认状态设置为 “Accepted”
        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

        // 3.缓冲区 Buffer
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        RequestHandler requestHandler = new RequestHandler();
        // Selector 不断轮询监听有多少个客户端 Channel已经连接上了
        while (true){
            // 从 Selector 中拿到一个个客户端的 Channel
            int select = selector.select();
            if(select == 0){
                continue;
            }
            // Set 集合维护了 客户端-服务端 的 Channel（SelectionKey）
            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();
            // 迭代 set 集合，
            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();
            while (iterator.hasNext()){
                // 拿到一个 SelectionKey，SelectionKey 里面有：服务端的 ServerSocketChannel；客户端的 SocketChannel
                SelectionKey key = iterator.next();
                // 如果有一个客户端的 Channel 连接上来了（状态为“Accepted”），需要进行读/写操作
                if(key.isAcceptable()){
                    // 根据 SelectionKey 获得 ServerSocketChannel
                    ServerSocketChannel channel = (ServerSocketChannel) key.channel();
                    // 根据 ServerSocketChannel 获得 SocketChannel
                    SocketChannel clientChannel = channel.accept();
                    System.out.println(&quot;Connection from &quot; + clientChannel.getRemoteAddress());
                    // 客户端 Channel 设置为非阻塞
                    clientChannel.configureBlocking(false);
                    // 将 Channel 的状态改变为 READ，说明该 Channel 要读数据了
                    clientChannel.register(selector, SelectionKey.OP_READ);
                }

                // 如果 Channel 的状态为 Read，可以进行 读操作了。
                // 处理读操作：还是放在 main 线程中，而不是为这个 Client 请求创建一个新的线程
                if(key.isReadable()){
                    // 获取到 客户端 Channel
                    SocketChannel channel = (SocketChannel) key.channel();
                    // 数据放到 Buffer 中
                    channel.read(buffer);
                    String request = new String(buffer.array()).trim();
                    buffer.clear();
                    System.out.println(String.format(&quot;From %s : %s&quot;, channel.getRemoteAddress(),request));
                    // 给客户端一个响应
                    String response = requestHandler.handler(request);
                    channel.write(ByteBuffer.wrap(response.getBytes()));
                }
                iterator.remove();
            }
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL —— Explain 关键字]]></title>
        <id>https://epitomm.github.io/post/mysql-explain-guan-jian-zi/</id>
        <link href="https://epitomm.github.io/post/mysql-explain-guan-jian-zi/">
        </link>
        <updated>2020-04-18T15:17:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="explain-关键字">Explain 关键字</h1>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>列名</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">id</td>
<td style="text-align:left">在一个大的查询语句中每个SELECT关键字都对应一个唯一的id</td>
</tr>
<tr>
<td style="text-align:left">select_type</td>
<td style="text-align:left">SELECT关键字对应的那个查询的类型</td>
</tr>
<tr>
<td style="text-align:left">table</td>
<td style="text-align:left">表名</td>
</tr>
<tr>
<td style="text-align:left">partitions</td>
<td style="text-align:left">匹配的分区信息</td>
</tr>
<tr>
<td style="text-align:left"><strong>type</strong></td>
<td style="text-align:left"><strong>针对单表的访问方法</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>possible_keys</strong></td>
<td style="text-align:left"><strong>可能用到的索引</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>key</strong></td>
<td style="text-align:left"><strong>实际上使用的索引</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>key_len</strong></td>
<td style="text-align:left"><strong>实际使用到的索引长度</strong></td>
</tr>
<tr>
<td style="text-align:left">ref</td>
<td style="text-align:left">当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td>
</tr>
<tr>
<td style="text-align:left">rows</td>
<td style="text-align:left">预估的需要读取的记录条数</td>
</tr>
<tr>
<td style="text-align:left">filtered</td>
<td style="text-align:left">某个表经过搜索条件过滤后剩余记录条数的百分比</td>
</tr>
<tr>
<td style="text-align:left"><strong>Extra</strong></td>
<td style="text-align:left"><strong>一些额外的信息</strong></td>
</tr>
</tbody>
</table>
<h2 id="table">table</h2>
<p>表名</p>
<pre><code>mysql&gt; explain select * from t1 join t2; 
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/table.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">explain select * from t1 join t2; </p>
<h2 id="id">id</h2>
<p>我们写的查询语句一般都以SELECT关键字开头，比较简单的查询语句里只有一个SELECT关键字，但是下边两种情况下在一条查询语句中会出现多个SELECT关键字：</p>
<ul>
<li>查询中包含子查询的情况</li>
<li>查询中包含UNION语句的情况</li>
</ul>
<p>查询语句中每出现<strong>一个SELECT关键字</strong>，MySQL就会为它分配<strong>一个唯一的id值</strong>。这个id值就是EXPLAIN语句的第一个列。对于连接查询来说，一个SELECT关键字后边的<strong>FROM子句中可以跟随多个表</strong>，所以在连接查询的执行计划中，<strong>每个表都会对应一条记录，但是这些记录的id值都是相同的。</strong></p>
<pre><code>mysql&gt; explain select * from t1 join t2; 
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/id1.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">一个 select 关键字，两条记录 id 值相同</p>
<blockquote>
<p>在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，出现在前边的表是驱动表，出现在后边的表是被驱动表</p>
</blockquote>
<p>对于<strong>包含子查询的</strong>查询语句来说，就可能涉及<strong>多个SELECT</strong>关键字，所以在包含子查询的查询语句的执行计划中，<strong>每个SELECT关键字都会对应一个唯一的id值</strong>，比如这样：</p>
<pre><code>mysql&gt; explain select * from t1 where a in (select a from t2) or c = 'c'; 
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/id2.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体"> 两个 select 关键字，两个不同的 id  值</p>
<p>但是这里大家需要特别注意，<strong>查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询</strong>。所以如果我们想知道查询优化器对某个包含子查询的语句是否进行了重写，直接查看执行计划就好了，比如说：</p>
<pre><code>mysql&gt; explain select * from t1 where a in (select a from t2); 
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E5%B0%86%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E4%B8%BA%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">查询优化器将子查询优化为连接查询</p>
<p>可以看到，虽然我们的查询语句是一个子查询，但是执行计划中t1和t2表对应的记录的id值全部是1，这就表明了<strong>查询优化器将子查询转换为了连接查询</strong>。</p>
<p>对<strong>于包含UNION子句的查询语句来说，每个SELECT关键字对应一个id值</strong>也是没错的，不过还是有点儿特别的东西，比方说下边这个查询：</p>
<pre><code>mysql&gt; explain select * from t1 union select * from t2; 
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://epitomm.github.io/post-images/union%E5%8E%BB%E9%87%8D.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">union 去重</p>
<p>这个语句的执行计划的第三条记录是什么？为什么id值是NULL？UNION会把多个查询的结果集合并起来并对结果集中的记录进行去重，怎么去重呢？MySQL使用的是内部的临时表。正如上边的查询计划中所示，<strong>UNION子句是为了把id为1的查询和id为2的查询的结果集合并起来并去重，所以在内部创建了一个名为的临时表</strong>（就是执行计划第三条记录的table列的名称），id为NULL表明这个临时表是为了合并两个查询的结果集而创建的。</p>
<p>跟UNION对比起来，<strong>UNION ALL就不需要为最终的结果集进行去重</strong>，它只是单纯的把多个查询的结果集中的记录合并成一个并返回给用户，所以也就不需要使用临时表。所以在包含UNION ALL子句的查询的执行计划中，就没有那个id为NULL的记录，如下所示：</p>
<pre><code>mysql&gt; explain select * from t1 union all select * from t2; 
+----+-------------+-------+------------+------+---------------+------+---------+----- 
-+------+----------+-------+ 
| id | select_type | table | partitions | type | possible_keys | key | key_len | ref  
| rows | filtered | Extra | 
+----+-------------+-------+------------+------+---------------+------+---------+----- 
-+------+----------+-------+ 
| 1 | PRIMARY | t1 | NULL | ALL | NULL | NULL | NULL | NULL 
| 8 | 100.00 | NULL | 
| 2 | UNION | t2 | NULL | ALL | NULL | NULL | NULL | NULL 
| 8 | 100.00 | NULL | 
+----+-------------+-------+------------+------+---------------+------+---------+----- 
-+------+----------+-------+ 
2 rows in set, 1 warning (0.00 sec) 
</code></pre>
<h2 id="select_type">select_type</h2>
<p>每一个SELECT关键字代表的小查询都定义了一个称之为select_type的属性，意思是我们只要知道了某个小查询的select_type属性，就知道了这个小查询在整个大查询中扮演了一个什么角色。</p>
<h3 id="simple">SIMPLE</h3>
<p>查询语句中<strong>不包含UNION或者子查询的查询</strong>都算作是SIMPLE类型。</p>
<pre><code>mysql&gt; explain select * from t1; 
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://epitomm.github.io/post-images/%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2SIMPLE.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">简单查询 select_type = SIMPLE</p>
<p>连接查询也算是SIMPLE类型</p>
<pre><code>mysql&gt; explain select * from t1 join t2; 
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://epitomm.github.io/post-images/%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2SIMPLE.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">连接查询 select_type = SIMPLE</p>
<h3 id="primary">PRIMARY</h3>
<p>对于包含UNION、UNION ALL或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的 select_type值就是PRIMARY，比方说：</p>
<pre><code>mysql&gt; explain select * from t1 where a in (select a from t2) or c = 'c'; 
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://epitomm.github.io/post-images/PRIMARY.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">主查询的 select_type = PRIMARY；子查询的 select_type = SUBQUERY</p>
<p>从结果中可以看到，最左边的小查询select * from t1对应的是执行计划中的第一条记录，它的select_type值就是 PRIMARY。</p>
<h3 id="union">UNION</h3>
<p>对于包含UNION或者UNION ALL的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外， 其余的小查询的select_type值就是UNION。</p>
<pre><code>mysql&gt; explain select * from t1 union select * from t2; 
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://epitomm.github.io/post-images/UNION.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">UNION 查询的最左边查询 select_type = RIMARY，其余小查询的 select_type = UNION</p>
<h3 id="union-result">UNION RESULT</h3>
<p>MySQL选择使用临时表来完成UNION查询的去重工作，针对该临时表的查询的select_type就是UNION RESULT，例子上边有。</p>
<figure data-type="image" tabindex="10"><img src="https://epitomm.github.io/post-images/UNION_RESULT.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">union 查询中临时表的 select_type = UNION RESULT</p>
<h3 id="subquery">SUBQUERY</h3>
<p><strong>非相关子查询</strong>，由于 select_type 为 SUBQUERY 的子查询由于会被物化，所以<strong>只需要执行一遍。</strong></p>
<pre><code>mysql&gt; explain select * from t1 where a in (select a from t2) or c = 'c'; 
</code></pre>
<figure data-type="image" tabindex="11"><img src="https://epitomm.github.io/post-images/SUBQUERY.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">非相关子查询 select_type = SUBQUERY</p>
<h3 id="dependent-subqurey">DEPENDENT SUBQUREY</h3>
<p><strong>相关子查询</strong>，select_type 为 DEPENDENT SUBQUERY 的查询可能<strong>会被执行多次</strong></p>
<pre><code>mysql&gt; explain select * from t1 where a in (select a from t2 where t1.a = t2.a) or c = 'c'; 
</code></pre>
<figure data-type="image" tabindex="12"><img src="https://epitomm.github.io/post-images/DEPENDENT_SUBQUREY.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">相关子查询 select_type = DEPENDENT SUBQUERY</p>
<h3 id="derived">DERIVED</h3>
<pre><code>mysql&gt; explain select * from (select a, count(*) from t2 group by a ) as deliver1; 
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://epitomm.github.io/post-images/DERIVED.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">派生表 select_type = DRIVED </p>
<p>从执行计划中可以看出，id为2的记录就代表子查询的执行方式，它的select_type是DERIVED，说明该子查询是以物化的方式执行的。id为1的记录代表外层查询，大家注意看它的table列显示的是<derived2>，表示该查询是针对将派生表物化之后的表进行查询的。</p>
<h3 id="materialized">MATERIALIZED</h3>
<p>当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的 select_type属性就是MATERIALIZED。</p>
<pre><code>mysql&gt; explain select * from t1 where a in (select c from t2 where e = 1);
</code></pre>
<figure data-type="image" tabindex="14"><img src="https://epitomm.github.io/post-images/MATERIALIZED.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">物化表 select_type = MATERIALIZED </p>
<blockquote>
<p>将子查询出来的结果集放到一个物化表内，再将物化表与外层查询进行连接查询。</p>
</blockquote>
<h2 id="type">TYPE</h2>
<p>访问方法（全表扫描还是走哪个索引）</p>
<h3 id="system">system</h3>
<p>当<strong>表中只有一条记录并且该表使用的存储引擎的统计数据是精确</strong>的，比如MyISAM、Memory，那么对该表的访问方法就是system。比方说我们新建一个MyISAM表，并为其插入一条记录：</p>
<p>创建表 t</p>
<pre><code>mysql&gt; CREATE TABLE t(i int) Engine=MyISAM; 
Query OK, 0 rows affected (0.05 sec) 
</code></pre>
<p>向 t 表内插入一条数据</p>
<pre><code>mysql&gt; INSERT INTO t VALUES(1); 
Query OK, 1 row affected (0.01 sec)
</code></pre>
<p>执行 explain 语句</p>
<pre><code>mysql&gt; explain select * from t; 
</code></pre>
<figure data-type="image" tabindex="15"><img src="https://epitomm.github.io/post-images/system.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">表中只有一条数据、存储引擎精确统计 type = system</p>
<h3 id="const">const</h3>
<p>当我们根据<strong>主键</strong>或者<strong>唯一二级索引列</strong>与<strong>常数</strong>进行<strong>等值匹配时</strong>，对单表的访问方法就是const。</p>
<pre><code>mysql&gt; explain select * from t1 where a = 1; 
</code></pre>
<figure data-type="image" tabindex="16"><img src="https://epitomm.github.io/post-images/const.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">根据主键与常数进行等值匹配 type = const</p>
<h3 id="eq_ref">eq_ref</h3>
<p>在连接查询时，如果<strong>被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的</strong>（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是eq_ref</p>
<pre><code>mysql&gt; explain select * from t1 join t2 on t1.a = t2.a; 
</code></pre>
<figure data-type="image" tabindex="17"><img src="https://epitomm.github.io/post-images/eq_ref.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">被驱动表通过主键等值匹配的方式访问，被驱动表的 type = eq_ref</p>
<h3 id="ref">ref</h3>
<p>当通过<strong>普通的二级索引列</strong>与<strong>常量</strong>进行<strong>等值匹配</strong>时来查询某个表，那么对该表的访问方法就可能是ref。</p>
<p>查看所有索引：</p>
<pre><code>show keys for t1;
</code></pre>
<figure data-type="image" tabindex="18"><img src="https://epitomm.github.io/post-images/%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%B4%A2%E5%BC%95.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">查看所有索引</p>
<pre><code>mysql&gt; explain select * from t1 where b = 1; 
</code></pre>
<figure data-type="image" tabindex="19"><img src="https://epitomm.github.io/post-images/ref.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">当通过普通的二级索引列与常量进行等值匹配时来查询某个表 type = ref</p>
<h3 id="ref_of_null">ref_of_null</h3>
<p>当对<strong>普通二级索引进行等值匹配查询</strong>，<strong>该索引列的值也可以是NULL值</strong>时，那么对该表的访问方法就可能是 ref_or_null</p>
<pre><code>mysql&gt; explain select * from t1 where b = 1 or b is null; 
</code></pre>
<figure data-type="image" tabindex="20"><img src="https://epitomm.github.io/post-images/ref_of_null.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">对普通二级索引进行等值匹配查询，该索引列的值也可以是NULL值 type = ref_of_null</p>
<h3 id="index_merge">index_merge</h3>
<p><strong>索引合并</strong></p>
<pre><code>mysql&gt; explain select * from t1 where a = 1 or b = 1; 
</code></pre>
<figure data-type="image" tabindex="21"><img src="https://epitomm.github.io/post-images/index_merge.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">索引合并 type = index_merge</p>
<h3 id="unique_subquery">unique_subquery</h3>
<p>如果<strong>查询优化器决定将IN子查询转换为EXISTS子查询，<strong>而且</strong>子查询可以使用到主键进行等值匹配</strong>的话，那么该子查询执行计划的type列的值就是unique_subquery。</p>
<pre><code>mysql&gt; explain select * from t1 where c in (select a from t2 where t1.e = t2.e) or a = 1;
</code></pre>
<p>以上查询可以优化为 EXISTS 子查询：</p>
<pre><code>mysql&gt; explain select * from t1 where exists(select a from t2 where t1.e = t2.e and t1.c = t2.a) or a = 1
</code></pre>
<figure data-type="image" tabindex="22"><img src="https://epitomm.github.io/post-images/unique_subquery.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">查询优化器将IN子查询转换为EXISTS子查询，而且子查询可以使用到主键进行等值匹配 </p>
<p>type = unique_subquery</p>
<h3 id="index_subquery">index_subquery</h3>
<p>index_subquery与unique_subquery类似，只不过访问子查询中的表时使用的是普通的索引。</p>
<pre><code>mysql&gt; explain select * from t1 where c in (select b from t2 where t1.e = t2.e) or a = 1;
+----+--------------------+-------+------------+----------------+---------------+----- 
---------+---------+------+------+----------+-------------+ 
| id | select_type | table | partitions | type | possible_keys | key  
| key_len | ref | rows | filtered | Extra | 
+----+--------------------+-------+------------+----------------+---------------+----- 
---------+---------+------+------+----------+-------------+ 
| 1 | PRIMARY | t1 | NULL | ALL | PRIMARY | NULL  
| NULL | NULL | 9 | 100.00 | Using where | 
| 2 | DEPENDENT SUBQUERY | t2 | NULL | index_subquery | idx_t2_b_c_d | 
idx_t2_b_c_d | 5 | func | 1 | 12.50 | Using where | 
+----+--------------------+-------+------------+----------------+---------------+----- 
---------+---------+------+------+----------+-------------+ 
2 rows in set, 2 warnings (0.00 sec) 
</code></pre>
<h3 id="range">range</h3>
<p>范围查询</p>
<pre><code>mysql&gt; explain select * from t1 where a &gt; 1; 
</code></pre>
<figure data-type="image" tabindex="23"><img src="https://epitomm.github.io/post-images/%E5%A4%A7%E4%BA%8E_range.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">a > 1 type = range</p>
<pre><code>mysql&gt; explain select * from t1 where a in (1);
</code></pre>
<figure data-type="image" tabindex="24"><img src="https://epitomm.github.io/post-images/in_range.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">a in (1) type = const</p>
<pre><code>mysql&gt; explain select * from t1 where a in (1,2);
</code></pre>
<figure data-type="image" tabindex="25"><img src="https://epitomm.github.io/post-images/in_range2.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">a in (1,2) type = range</p>
<h3 id="index">index</h3>
<p>当我们可以使用覆盖索引，但<strong>需要扫描全部的索引记录</strong>时，该表的访问方法就是index。</p>
<p>遍历索引上的所有叶子节点，因为B+树所有数据都存储在叶子节点上，而非叶子结点是用来过滤筛选条件的。</p>
<pre><code>mysql&gt; explain select a from t1; 
</code></pre>
<figure data-type="image" tabindex="26"><img src="https://epitomm.github.io/post-images/index_1.png" alt="图片" loading="lazy"></figure>
<p>使用辅助索引没有使用主键索引的原因：辅助索引体积较小，辅助索引只存储字段b、c、d和主键a字段；而主索引存储所有字段值。</p>
<pre><code>mysql&gt; explain select b from t1;
</code></pre>
<figure data-type="image" tabindex="27"><img src="https://epitomm.github.io/post-images/index_2.png" alt="图片" loading="lazy"></figure>
<pre><code>mysql&gt; ecplain select e from t1;
</code></pre>
<figure data-type="image" tabindex="28"><img src="https://epitomm.github.io/post-images/index_3.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">e 字段没有索引，所以 type = ALL</p>
<h3 id="all">ALL</h3>
<p>全表扫描</p>
<h2 id="possible_keys-和-key">possible_keys 和 key</h2>
<p>possible_keys列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些，key列表示实际用到的索引有哪些。</p>
<p>不过有一点比较特别，就是在使用index访问方法来查询某个表时，possible_keys列是空的，而key列展示的是实际使用到的索引 。</p>
<blockquote>
<p>possible_keys列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长 时间，所以如果可以的话，尽量删除那些用不到的索引</p>
</blockquote>
<h2 id="key_len">key_len</h2>
<p>key_len列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度，它是由这三个部分构成的：</p>
<ul>
<li>对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是VARCHAR(100)，使用的字符集是 utf8，那么该列实际占用的最大存储空间就是100 × 3 = 300个字节。</li>
<li>如果该索引列可以存储NULL值，则key_len比不可以存储NULL值时多1个字节。</li>
<li>对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。</li>
</ul>
<figure data-type="image" tabindex="29"><img src="https://epitomm.github.io/post-images/key_len.png" alt="图片" loading="lazy"></figure>
<h2 id="ref-2">ref</h2>
<p>当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是const、eq_ref、ref、ref_or_null、 unique_subquery、index_subquery其中之一时，ref列展示的就是与索引列作等值匹配的东西是什么，比如只是一个常数或者是某个列。</p>
<pre><code>mysql&gt; explain select b from t1 where b = 1; 
</code></pre>
<figure data-type="image" tabindex="30"><img src="https://epitomm.github.io/post-images/ref_1.png" alt="图片" loading="lazy"></figure>
<pre><code>mysql&gt; explain select * from t1 where a in (select a from t2); 
</code></pre>
<figure data-type="image" tabindex="31"><img src="https://epitomm.github.io/post-images/ref_2.png" alt="图片" loading="lazy"></figure>
<h2 id="rows">rows</h2>
<p>如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的rows列就代表预计需要扫描的行数， 如果使用索引来执行查询时，执行计划的rows列就代表预计扫描的索引记录行数。</p>
<h2 id="filtered">filtered</h2>
<p>代表查询优化器预测在这扫描的记录中，有多少条记录满足其余的搜索条件。</p>
<pre><code>mysql&gt; explain select * from t1 where a &gt; 1 and e = 1; 
+----+-------------+-------+------------+-------+---------------+---------+---------+- 
-----+------+----------+-------------+ 
| id | select_type | table | partitions | type | possible_keys | key | key_len | 
ref | rows | filtered | Extra | 
+----+-------------+-------+------------+-------+---------------+---------+---------+- 
-----+------+----------+-------------+ 
| 1 | SIMPLE | t1 | NULL | range | PRIMARY | PRIMARY | 4 | 
NULL | 8 | 11.11 | Using where | 
+----+-------------+-------+------------+-------+---------------+---------+---------+- 
-----+------+----------+-------------+ 
1 row in set, 1 warning (0.00 sec) 
</code></pre>
<p>从执行计划的key列中可以看出来，该查询使用PRIMARY索引来执行查询，从rows列可以看出满足a &gt; 1的记录有 8条。执行计划的filtered列就代表查询优化器预测在这8条记录中，<strong>有多少条记录满足其余的搜索条件</strong>，也就是e = 1这个条件的百分比。此处filtered列的值是11.11，说明查询优化器预测在8条记录中有11.11%的记录满足e = 1 这个条件。<br>
对于单表查询来说，这个 filtered 列的值没什么意义，我们更关注在连接查询中驱动表对应的执行计划记录的  filtered 值，比方说下边这个查询：</p>
<pre><code>mysql&gt; explain select * from t1 join t2 on t1.a = t2.a where t1.e = 1; 
+----+-------------+-------+------------+--------+---------------+---------+--------- 
+------------+------+----------+-------------+ 
| id | select_type | table | partitions | type | possible_keys | key | key_len | 
ref | rows | filtered | Extra | 
+----+-------------+-------+------------+--------+---------------+---------+--------- 
+------------+------+----------+-------------+ 
| 1 | SIMPLE | t1 | NULL | ALL | PRIMARY | NULL | NULL | 
NULL | 9 | 11.11 | Using where | 
| 1 | SIMPLE | t2 | NULL | eq_ref | PRIMARY | PRIMARY | 4 | 
luban.t1.a | 1 | 100.00 | NULL | 
+----+-------------+-------+------------+--------+---------------+---------+--------- 
+------------+------+----------+-------------+ 
2 rows in set, 1 warning (0.00 sec) 
</code></pre>
<p>从执行计划中可以看出来，查询优化器打算把t1当作驱动表，t2当作被驱动表。我们可以看到驱动表t1表的执行计划的rows列为9， filtered 列为11.11，这意味着驱动表t1表经过条件过滤后有9 × 11.11% = 0.9999条记录，这说明还<strong>要对被驱动表执行大约1次(row * filtered)查询</strong>。</p>
<h2 id="extra">Extra</h2>
<p>Extra列是用来说明一些额外信息的，我们可以通过这些额外信息来更准确的理解MySQL到底将如何执行给定的查询语句。</p>
<h3 id="no-tables-used">No tables used</h3>
<p>当<strong>查询语句的没有FROM子句</strong>时将会提示该额外信息。</p>
<pre><code>mysql&gt; explain select 1; 
</code></pre>
<figure data-type="image" tabindex="32"><img src="https://epitomm.github.io/post-images/Notablesused.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">查询语句没有 FROM 子句时：Extra = No tables used</p>
<h3 id="impossible-where">Impossible WHERE</h3>
<p><strong>查询语句的WHERE子句永远为FALSE</strong>时将会提示该额外信息。</p>
<pre><code>mysql&gt; explain select b from t1 where 1=0; 
</code></pre>
<figure data-type="image" tabindex="33"><img src="https://epitomm.github.io/post-images/ImpossibleWHERE.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">WHERE 子句永远为 FALSE时：Extra = Impossible WHERE</p>
<h3 id="no-matching-minmax-row">No matching min/max row</h3>
<p>当<strong>查询列表处有MIN或者MAX聚集函数，但是并没有符合WHERE子句中的搜索条件的记录</strong>时，将会提示该额外信息。</p>
<pre><code>mysql&gt; explain select max(a) from t1 where a=100; 
</code></pre>
<figure data-type="image" tabindex="34"><img src="https://epitomm.github.io/post-images/No_matching_minmax_row.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">查询列表处有MIN或者MAX聚集函数，但是并没有符合WHERE子句中的搜索条件的记录时：Extra = No matching min/max row</p>
<h3 id="using-index">Using index</h3>
<p>当我们的<strong>查询列表以及搜索条件中只包含属于某个索引的列</strong>，也就是在<strong>可以使用索引覆盖</strong>的情况下，在Extra列将会提示该额外信息。</p>
<p>辅助索引包含 b、c、d 字段，根据查询条件 b=1 找到字段 d 的值，无需回表。</p>
<pre><code>mysql&gt; explain select d from t1 where b =1; 
</code></pre>
<figure data-type="image" tabindex="35"><img src="https://epitomm.github.io/post-images/UsingIndex.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">覆盖索引 Extra = Using index</p>
<h3 id="using-index-condition">Using index condition</h3>
<p>有些<strong>搜索条件中虽然出现了索引列，但却不能使用到索引</strong>（在MySQL 5.6版本后加入的新特性）</p>
<figure data-type="image" tabindex="36"><img src="https://epitomm.github.io/post-images/Using_index_condition.png" alt="图片" loading="lazy"></figure>
<pre><code>mysql&gt; explain select * from t1 where b =1 and c like '%1'; 
</code></pre>
<figure data-type="image" tabindex="37"><img src="https://epitomm.github.io/post-images/Using_index_condition2.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">搜索条件中虽然出现了索引列，但却不能使用到索引 Extra = Using index condition</p>
<h3 id="using-where">Using where</h3>
<p>当我们使用<strong>全表扫描来执行对某个表的查询，并且该语句的WHERE子句中有针对该表的搜索条件时</strong>，在Extra列中会提示上述额外信息。</p>
<pre><code>mysql&gt; explain select * from t1 where e = 1; 
</code></pre>
<figure data-type="image" tabindex="38"><img src="https://epitomm.github.io/post-images/UsingWhere.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">全表扫描来执行对某个表的查询，并且该语句的WHERE子句中有针对该表的搜索条件时：Extra = Using where</p>
<h3 id="using-joinbufferblock-nested-loop">Using joinbuffer(Block Nested Loop)</h3>
<p>在<strong>连接查询</strong>执行过程中，当被驱动表<strong>不能有效的利用索引</strong>加快访问速度，MySQL一般会为其分配一块名叫join buffer 的内存块来加快查询速度。</p>
<pre><code>mysql&gt; explain select * from t1 join t2 on t1.e = t2.e; 
</code></pre>
<figure data-type="image" tabindex="39"><img src="https://epitomm.github.io/post-images/Using_joinbuffer.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">连接查询不能用到索引，分配 join buffer 内存块：Extra = Using join buffer</p>
<p>可以在对t2表的执行计划的Extra列显示了两个提示：</p>
<ul>
<li>Using join buffer (Block Nested Loop)：这是因为对表t2的访问不能有效利用索引，只好退而求其次，使用join buffer来减少对t2表的访问次数，从而提高性能。</li>
<li>Using where：可以看到查询语句中有一个t1.e = t2.e条件，因为t1是驱动表，t2是被驱动表，所以在访问t2表时，t1.e的值已经确定下来了，所以实际上查询t2表的条件就是t2.e = 一个常数，所以提示了Using where额外信息。</li>
</ul>
<h3 id="using-filesort">Using filesort</h3>
<p>很多情况下排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）进行排序，这种<strong>在内存中或者磁盘上进行排序的方式统称为文件排序</strong>（英文名：filesort）。如果<strong>某个查询需要使用文件排序的方式执行查询</strong>，就会在执行计划的Extra列中显示Using filesort提示。</p>
<pre><code>mysql&gt; explain select * from t1 order by e; 
</code></pre>
<figure data-type="image" tabindex="40"><img src="https://epitomm.github.io/post-images/Using_filesort.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">排序 Extra = Using filesort</p>
<h3 id="using-temporary">Using temporary</h3>
<p>在许多查询的执行过程中，MySQL可能会借助<strong>临时表</strong>来完成一些功能，比如<strong>去重、排序</strong>之类的，比如我们在执行许多包含<strong>DISTINCT、GROUP BY、UNION</strong>等子句的查询过程中，如果<strong>不能</strong>有效<strong>利用索引</strong>来完成查询，MySQL很有可能寻求通过<strong>建立内部的临时表</strong>来执行查询。如果查询中使用到了内部的临时表，在执行计划的Extra列将会显示Using temporary提示。</p>
<p>能利用索引：</p>
<pre><code>mysql&gt; explain select distinct b from t1; 
</code></pre>
<figure data-type="image" tabindex="41"><img src="https://epitomm.github.io/post-images/Using_temporary.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">利用索引distinct：Extra = Using index</p>
<p>不能利用索引</p>
<pre><code>mysql&gt; explain select distinct e from t1; 
</code></pre>
<figure data-type="image" tabindex="42"><img src="https://epitomm.github.io/post-images/Using_temporary2.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">不能利用索引的 distinct，建立内部临时表：Extra = Using temporary</p>
<p>即有Using temporary，又有Using filesort，因为group by默认会先排序 （Using filesort）</p>
<pre><code>mysql&gt; explain select e, count(1) from t1 group by e; 
</code></pre>
<figure data-type="image" tabindex="43"><img src="https://epitomm.github.io/post-images/Using_temporary3.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">Extra = Using temporary; Using filesort</p>
<p>使用order by null禁用排序</p>
<pre><code>mysql&gt; explain select e, count(1) from t1 group by e order by null; 
</code></pre>
<figure data-type="image" tabindex="44"><img src="https://epitomm.github.io/post-images/Using_temporary4.png" alt="图片" loading="lazy"></figure>
<p style = "text-align:center;font-family:楷体">禁用排序，Extra = Using temporary</p>
<h3 id="start-temporary-end-temporary">Start temporary、End temporary</h3>
<p><strong>查询优化器会优先尝试将IN子查询转换成semi-join</strong>，而semi-join又有好多种执行策略，当执行策略为 <strong>DuplicateWeedout <strong>时，也就是通过</strong>建立临时表</strong>来实现为外层查询中的记录进行<strong>去重</strong>操作时，<strong>驱动表</strong>查询执行计划的Extra列将显示<strong>Start temporary</strong>提示，<strong>被驱动表</strong>查询执行计划的Extra列将显示<strong>End temporary</strong>提示</p>
<pre><code>mysql&gt; explain select * from t1 where a in (select e from t2 where e = 1); 
</code></pre>
<figure data-type="image" tabindex="45"><img src="https://epitomm.github.io/post-images/Start_temporary.png" alt="图片" loading="lazy"></figure>
<h3 id="firstmatch表名">FirstMatch（表名）</h3>
<p>在将In子查询转为semi-join时，如果采用的是<strong>FirstMatch</strong>执行策略，则在<strong>被驱动表</strong>执行计划的Extra列就是显示 **FirstMatch(tbl_name)**提示。</p>
<pre><code>mysql&gt; explain select * from t1 where a in (select c from t2 where c = 1); 
</code></pre>
<figure data-type="image" tabindex="46"><img src="https://epitomm.github.io/post-images/FirstMatch.png" alt="图片" loading="lazy"></figure>
<h1 id="总结">总结</h1>
<h2 id="性能按-type-排序">性能按 type 排序</h2>
<p>system &gt; const &gt; eq_ref &gt; ref &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p>
<h2 id="性能按-extra-排序">性能按 Extra 排序</h2>
<ul>
<li>Using index：用了覆盖索引</li>
<li>Using index condition：用了条件索引（索引下推）</li>
<li>Using where：从索引查出来数据后继续用where条件过滤</li>
<li>Using join buffer (Block Nested Loop)：join的时候利用了join buffer（优化策略：去除外连接、增 大join buffer大小）</li>
<li>Using filesort：用了文件排序，排序的时候没有用到索引</li>
<li>Using temporary：用了临时表（优化策略：增加条件以减少结果集、增加索引，思路就是要么减少待排序的数量，要么就提前排好序）</li>
<li>Start temporary, End temporary：子查询的时候，可以优化成半连接，但是使用的是通过临时表来去重</li>
<li>FirstMatch(tbl_name)：子查询的时候，可以优化成半连接，但是使用的是直接进行数据比较来去重</li>
</ul>
<h2 id="常见的优化手段">常见的优化手段</h2>
<ol>
<li>SQL语句中IN包含的值不应过多，不能超过200个，200个以内查询优化器计算成本时比较精准，超过200 个是估算的成本，另外建议能用between就不要用in，这样就可以使用range索引了。</li>
<li>SELECT语句务必指明字段名称：SELECT * 增加很多不必要的消耗（cpu、io、内存、网络带宽）；增加了使用覆盖索引的可能性；当表结构发生改变时，前端也需要更新。所以要求直接在select后面接上字段名。</li>
<li>当只需要一条数据的时候，使用limit 1</li>
<li>排序时注意是否能用到索引</li>
<li>使用 or 时如果没有用到索引，可以改为union all 或者union</li>
<li>如果in不能用到索引，可以改成exists看是否能用到索引</li>
<li>使用合理的分页方式以提高分页的效率</li>
<li>不建议使用%前缀模糊查询</li>
<li>避免在where子句中对字段进行表达式操作</li>
<li>避免隐式类型转换 （字符 ‘a’ -&gt; 数字 0，数字 !-&gt; 字符）</li>
<li>对于联合索引来说，要遵守最左前缀法则</li>
<li>必要时可以使用force index来强制查询走某个索引</li>
<li>对于联合索引来说，如果存在范围查询，比如between,&gt;,&lt;等条件时，会造成后面的索引字段失效。</li>
<li>尽量使用inner join，避免left join，让查询优化器来自动选择小表作为驱动表</li>
<li>必要时刻可以使用straight_join来指定驱动表，前提条件是本身是inner join</li>
</ol>
]]></content>
    </entry>
</feed>