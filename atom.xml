<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://epitomm.github.io</id>
    <title>SSM</title>
    <updated>2020-03-15T11:10:44.874Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://epitomm.github.io"/>
    <link rel="self" href="https://epitomm.github.io/atom.xml"/>
    <subtitle>热心善良的老学姐</subtitle>
    <logo>https://epitomm.github.io/images/avatar.png</logo>
    <icon>https://epitomm.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, SSM</rights>
    <entry>
        <title type="html"><![CDATA[面试题系列 —— Zookeeper]]></title>
        <id>https://epitomm.github.io/post/zookeeper-mian-shi-ti/</id>
        <link href="https://epitomm.github.io/post/zookeeper-mian-shi-ti/">
        </link>
        <updated>2020-03-14T15:40:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-谈谈你对-zookeeper-的认识">1. 谈谈你对 Zookeeper 的认识</h1>
<p><code>Zookeeper</code> 是一个<strong>分布式协调服务</strong>的开源框架。主要用来解决分布式集群中应用系统的<strong>一致性</strong>问题，例如怎样避免同时操作同一数据造成脏读的问题。</p>
<p><strong><code>ZooKeeper</code> 本质上是一个分布式的小文件存储系统</strong>。提供基于类似于文件系统的目录树方式的数据存储，并且可以对树中的节点进行有效管理。从而用来维护和监控你存储的数据的状态变化。通过监控这些数据状态的变化，从而可以达到基于数据的集群管理。诸如：统一命名服务、分布式配置管理、分布式消息队列、分布式锁、分布式协调等功能。</p>
<h1 id="2-zookeeper-特性">2. ZooKeeper 特性</h1>
<ol>
<li><strong>全局数据一致</strong>：集群中每个服务器保存一份相同的数据副本，<code>client</code> 无论连接到哪个服务器，展示的数据都是一致的，这是最重要的特征；</li>
<li><strong>可靠性</strong>：如果消息【<strong>增、删、改、查</strong>】被其中一台服务器接受，那么将被所有的服务器接受。</li>
<li><strong>顺序性</strong>：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息 a 在消息 b 前发布，则在所有 <code>Server</code> 上消息 a 都将在消息 b 前被发布；偏序是指如果一个消息 b 在消息 a 后被同一个发送者发布，a 必将排在 b 前面。</li>
<li><strong>数据更新原子性</strong>：一次数据更新要么成功（半数以上节点成功），要么失败，不存在中间状态。</li>
<li><strong>实时性</strong>：<code>Zookeeper</code> 保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。</li>
</ol>
<h1 id="3-zookeeper-数据模型">3． ZooKeeper 数据模型</h1>
<p><code>ZooKeeper</code> 的数据模型，在结构上和标准文件系统的非常相似，拥有一个层次的命名空间，都是采用<strong>树形层次结构</strong>，<code>ZooKeeper</code> 树中的每个节点被称为— <strong><code>Znode</code></strong>。和文件系统的目录树一样，<code>ZooKeeper</code> 树中的每个节点可以拥有子节点。但也有不同之处：</p>
<ol>
<li><strong><code>Znode</code> 兼具文件和目录两种特点</strong>。既像文件一样维护着数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分，并可以具有子 <code>Znode</code>。用户对 <code>Znode</code> 具有增、删、改、查等操作（权限允许的情况下）。</li>
<li><strong><code>Znode</code> 具有原子性操作</strong>，读操作将获取与节点相关的所有数据，写操作也将替换掉节点的所有数据。另外，每一个节点都拥有自己的 ACL(访问控制列表)，这个列表规定了用户的权限，即限定了特定用户对目标节点可以执行的操作。</li>
<li><strong><code>Znode</code> 存储数据大小有限制</strong>。<code>ZooKeeper</code> 虽然可以关联一些数据，但并没有被设计为常规的数据库或者大数据存储，相反的是，它用来管理调度数据，比如分布式应用中的配置文件信息、状态信息、汇集位置等等。这些数据的共同特性就是它们都是很小的数据，<strong>通常以 KB 为大小单位</strong>。ZooKeeper 的服务器和客户端都被设计为严格检查并限制每个 Znode 的数据大小至多 1M，当时常规使用中应该远小于此值。</li>
<li><strong><code>Znode</code> 通过路径引用</strong>，如同 <code>Unix</code> 中的文件路径。<strong>路径必须是绝对的</strong>，因此他们必须<strong>由斜杠字符来开头</strong>。除此以外，他们必须是唯一的，也就是说每一个路径只有一个表示，因此这些路径不能改变。在 <code>ZooKeeper</code> 中，路径由 <code>Unicode</code> 字符串组成，并且有一些限制。字符串&quot;/zookeeper&quot;用以保存管理信息，比如关键配额信息。</li>
</ol>
<h2 id="31数据结构图">3.1．数据结构图</h2>
<p><img src="https://epitomm.github.io/post-images/1584240732240.jpg" alt="" loading="lazy"><br>
图中的每个节点称为一个 <code>Znode</code>。 每个 <code>Znode</code> 由 3 部分组成:</p>
<ul>
<li><code>stat</code>：此为状态信息, 描述该 <code>Znode</code> 的版本, 权限等信息</li>
<li><code>data</code>：与该 <code>Znode</code> 关联的数据</li>
<li><code>children</code>：该 <code>Znode</code> 下的子节点</li>
</ul>
<h2 id="32节点类型">3.2．节点类型</h2>
<p><code>Znode</code> 有两种，分别为<strong>临时节点</strong>和<strong>永久节点</strong>。</p>
<p>节点的类型<strong>在创建时即被确定，并且不能改变。</strong></p>
<p><strong>临时节点</strong>：该节点的生命周期依赖于创建它们的会话。一旦<strong>会话结束，临时节点将被自动删除</strong>，当然可以也可以手动删除。<strong>临时节点不允许拥有子节点</strong>。</p>
<p><strong>永久节点</strong>：该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，他们才能被删除。</p>
<p><code>Znode</code> 还有一个<strong>序列化</strong>的特性，如果创建的时候指定的话，该 <code>Znode</code> 的名字后面会<strong>自动追加一个不断增加的序列号</strong>。序列号对于此节点的父节点来说是唯一的，这样便会<strong>记录每个子节点创建的先后顺序</strong>。它的格式为“%10d”(10 位数字，没有数值的数位用 0 补充，例如“0000000001”)。</p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/1584240804281.jpg" alt="" loading="lazy"></figure>
<p>这样便会存在四种类型的 <code>Znode</code> 节点，分别对应：</p>
<ul>
<li><code>PERSISTENT</code>：永久节点</li>
<li><code>EPHEMERAL</code>：临时节点</li>
<li><code>PERSISTENT_SEQUENTIAL</code>：永久节点、序列化</li>
<li><code>EPHEMERAL_SEQUENTIAL</code>：临时节点、序列化</li>
</ul>
<h1 id="4-zookeeper-watcher">4． ZooKeeper Watcher</h1>
<p><code>ZooKeeper</code> 提供了分布式数据<strong>发布/订阅功能</strong>，一个典型的发布/订阅模型系统定义了一种一对多的订阅关系，能让多个订阅者同时监听某一个主题对象，当这个主题对象自身状态变化时，会通知所有订阅者，使他们能够做出相应的处理。</p>
<p><code>ZooKeeper</code> 中，引入了 <strong>Watcher 机制来实现这种分布式的通知功能</strong> 。 <code>ZooKeeper</code> 允许客户端向服务端注册一个 <code>Watcher</code> 监听，当服务端的一些事件触发了这个 <code>Watcher</code>，那么就会向指定客户端发送一个事件通知来实现分布式的通知功能。</p>
<p>触发事件种类很多，如：节点创建，节点删除，节点改变，子节点改变等。</p>
<p>总的来说可以概括 <code>Watcher</code> 为以下三个过程：<strong>客户端向服务端注册 <code>Watcher</code>、服务端事件发生触发 <code>Watcher</code>、客户端回调 <code>Watcher</code> 得到触发事件情况</strong></p>
<h2 id="41-watch-机制特点">4.1． Watch 机制特点</h2>
<h3 id="一次性触发"><strong>一次性触发</strong></h3>
<p>事件发生触发监听，一个 <code>watcher event</code> 就会被发送到设置监听的客户端，这种效果是一次性的，后续再次发生同样的事件，不会再次触发。</p>
<h3 id="事件封装"><strong>事件封装</strong></h3>
<p><code>ZooKeeper</code> 使用 <code>WatchedEvent</code> 对象来封装服务端事件并传递。</p>
<p><code>WatchedEvent</code> 包含了每一个事件的三个基本属性：</p>
<p><strong>通知状态（<code>keeperState</code>），事件类型（<code>EventType</code>）和节点路径（<code>path</code>）</strong></p>
<h3 id="event-异步发送"><strong>event 异步发送</strong></h3>
<p><code>watcher</code> 的通知事件从服务端发送到客户端是异步的。</p>
<h3 id="先注册再触发"><strong>先注册再触发</strong></h3>
<p><code>Zookeeper</code> 中的 <code>watch</code> 机制，必须客户端先去服务端注册监听，这样事件发送才会触发监听，通知给客户端。</p>
<h1 id="5-zookeeper-选举机制">5． ZooKeeper 选举机制</h1>
<p><code>zookeeper</code> 默认的算法是 <code>FastLeaderElection</code>，采用投票数大于半数则胜出的逻辑。</p>
<h2 id="51-概念">5.1． 概念</h2>
<p><strong>服务器 ID</strong></p>
<ul>
<li>比如有三台服务器，编号分别是 1,2,3。</li>
<li>编号越大在选择算法中的权重越大。</li>
</ul>
<p><strong>选举状态</strong></p>
<ul>
<li><code>LOOKING</code>，竞选状态。</li>
<li><code>FOLLOWING</code>，随从状态，同步 <code>leader</code> 状态，参与投票。</li>
<li><code>OBSERVING</code>，观察状态,同步 <code>leader</code> 状态，不参与投票。</li>
<li><code>LEADING</code>，领导者状态。</li>
</ul>
<p><strong>数据 ID</strong></p>
<ul>
<li>服务器中存放的最新数据 <code>version</code>。</li>
<li>值越大说明数据越新，在选举算法中数据越新权重越大。</li>
</ul>
<p><strong>逻辑时钟</strong></p>
<p>也叫投票的次数，同一轮投票过程中的逻辑时钟值是相同的。每投完一次票这个数据就会增加，然后与接收到的其它服务器返回的投票信息中的数值相比，根据不同的值做出不同的判断。</p>
<h2 id="52-全新集群选举">5.2． 全新集群选举</h2>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/1584240883089.png" alt="" loading="lazy"></figure>
<p>假设目前有 5 台服务器，<strong>每台服务器均没有数据</strong>，它们的编号分别是1,2,3,4,5,<strong>按编号依次启动</strong>，它们的选择举过程如下：</p>
<ul>
<li>服务器 1 启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器 1 的状态一直属于 <code>Looking</code>。</li>
<li>服务器 2 启动，给自己投票，同时与之前启动的服务器 1 交换结果，由于服务器 2 的编号大所以服务器 2 胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是 <code>LOOKING</code>。</li>
<li>服务器 3 启动，给自己投票，同时与之前启动的服务器 1,2 交换信息，由于服务器 3 的编号最大所以服务器 3 胜出，此时投票数正好大于半数，所以服务器 3 成为领导者，服务器 1,2 成为小弟。</li>
<li>服务器 4 启动，给自己投票，同时与之前启动的服务器 1,2,3 交换信息，尽管服务器 4 的编号大，但之前服务器 3 已经胜出，所以服务器 4 只能成为小弟。</li>
<li>服务器 5 启动，后面的逻辑同服务器 4 成为小弟。</li>
</ul>
<h2 id="53-非全新集群选举">5.3． 非全新集群选举</h2>
<p>对于运行正常的 <code>zookeeper</code> 集群，中途有机器 <code>down</code> 掉，需要重新选举时，选举过程就需要加入<strong>数据 ID</strong>、<strong>服务器 ID</strong> 和<strong>逻辑时钟</strong>。</p>
<p>数据 ID：数据新的 <code>version</code> 就大，数据每次更新都会更新 <code>version</code>。</p>
<p>服务器 ID：就是我们配置的 <code>myid</code> 中的值，每个机器一个。</p>
<p>逻辑时钟：这个值从 0 开始递增,每次选举对应一个值。 如果在同一次选举中,这个值是一致的。</p>
<p>这样选举的标准就变成：</p>
<p>1、逻辑时钟小的选举结果被忽略，重新投票；</p>
<p>2、统一逻辑时钟后，数据 id 大的胜出；</p>
<p>3、数据 id 相同的情况下，服务器 id 大的胜出；根据这个规则选出 <code>leader</code>。</p>
<h1 id="6-zookeeper-典型应用">6． ZooKeeper 典型应用</h1>
<h2 id="61-数据发布与订阅配置中心">6.1． 数据发布与订阅（配置中心）</h2>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/1584241030128.png" alt="" loading="lazy"></figure>
<p>发布与订阅模型，即所谓的配置中心，顾名思义就是<strong>发布者将数据发布到 ZK节点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新</strong>。</p>
<p>应用在启动的时候会主动来获取一次配置，同时，在节点上注册一个 <code>Watcher</code>，这样一来，以后每次配置有更新的时候，都会实时通知到订阅的客户端，从来达到获取最新配置信息的目的。比如：</p>
<p>分布式搜索服务中，索引的元信息和服务器集群机器的节点状态存放在 ZK 的一些指定节点，供各个客户端订阅使用。</p>
<p>注意：适合<strong>数据量很小的场景</strong>，这样数据更新可能会比较快。</p>
<h2 id="62-命名服务naming-service">6.2． 命名服务(Naming Service)</h2>
<p>在分布式系统中，<strong>通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息</strong>。<strong>被命名的实体通常可以是集群中的机器，提供的服务地址，远程对象等等——这些我们都可以统称他们为名字（Name）</strong>。其中较为常见的就是一些分布式服务框架中的服务地址列表。通过调用 ZK 提供的创建节点的 API，能够很容易创建一个<strong>全局唯一的 path</strong>，这个 path 就可以作为一个名称。</p>
<p>阿里巴巴集团开源的分布式服务框架 <strong>Dubbo 中使用 ZooKeeper 来作为其命名服务</strong>，维护全局的服务地址列表。</p>
<h2 id="63-分布式锁">6.3． 分布式锁</h2>
<p>分布式锁，这个主要得益于 <code>ZooKeeper</code> 保证了数据的强一致性。锁服务可以分为两类，一个是<strong>保持独占</strong>，另一个是<strong>控制时序</strong>。</p>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/1584241059824.png" alt="" loading="lazy"></figure>
<p>所谓<strong>保持独占</strong>，就是所有试图来获取这个锁的客户端，最终只有一个可以成功获得这把锁。通常的做法是把 zk 上的一个 <code>znode</code> 看作是一把锁，通过 <code>create znode</code> 的方式来实现。所有客户端都去创建 <code>/distribute_lock</code> <strong>临时非序列化</strong>节点，最终成功创建的那个客户端也即拥有了这把锁。</p>
<p><strong>控制时序</strong>，就是所有试图来获取这个锁的客户端，最终都是会被安排执行，只是有个全局时序了。做法和上面基本类似，只是这里<code>/distribute_lock</code> 已经预先存在，客户端在它下面创建<strong>临时有序</strong>节点（这个可以通过节点的属性控制：<code>CreateMode.EPHEMERAL_SEQUENTIAL</code> 来指定）。Zk 的父节点（<code>/distribute_lock</code>）</p>
<p>维持一份 <code>sequence</code>,保证子节点创建的时序性，从而也形成了每个客户端的全局时序。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Gridea 检测远程连接失败]]></title>
        <id>https://epitomm.github.io/post/gridea-jian-ce-yuan-cheng-lian-jie-shi-bai/</id>
        <link href="https://epitomm.github.io/post/gridea-jian-ce-yuan-cheng-lian-jie-shi-bai/">
        </link>
        <updated>2020-02-18T16:09:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="问题一">问题一</h1>
<h3 id="我的环境">我的环境</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows10</td>
</tr>
<tr>
<td>软件版本</td>
<td>0.9.1</td>
</tr>
<tr>
<td>主题名称</td>
<td>Notes</td>
</tr>
</tbody>
</table>
<h2 id="问题描述">问题描述</h2>
<p>根据教程设置好一系列信息，经测试域名可访问，并且确保其他信息均正确</p>
<p>检查远程连接错误：<strong>远程连接失败,请检查仓库、用户名和 token 设置</strong></p>
<h2 id="问题分析">问题分析</h2>
<ol>
<li>先查看 <code>Gridea</code> 文件存储目录：C:\Users\Only\Documents\Gridea\output.git 下的 config 文件，看是否有 [remote &quot;origin&quot;] 信息，如果没有自行添加</li>
</ol>
<pre><code>[remote &quot;origin&quot;]
	url = https://你的github用户名:Token@github.com/你的github用户/仓库名
	fetch = +refs/heads/*:refs/remotes/origin/*
</code></pre>
<p>附：查看<code>Gridea</code>文件存储目录<br>
<img src="https://epitomm.github.io/post-images/1582604204611.png" alt="" loading="lazy"></p>
<ol start="2">
<li>检查错误信息：<br>
<img src="https://epitomm.github.io/post-images/1582041933549.png" alt="" loading="lazy"></li>
</ol>
<blockquote>
<p>[<em>&quot;fatal: unable to access 'https://github.com/Epitom…led to connect to github.com port 443: Timed out↵&quot;</em>]</p>
</blockquote>
<h2 id="问题解决">问题解决</h2>
<ol>
<li>谷歌 433 错误，得知是<strong>没有设置代理服务器</strong>的原因。</li>
</ol>
<p>以下为网上一高赞解决方式，可自行尝试，（不过对我的问题无效果）<br>
参考链接：<a href="https://blog.csdn.net/runningman2012/article/details/54633677">https://blog.csdn.net/runningman2012/article/details/54633677</a></p>
<figure data-type="image" tabindex="1"><img src="https://epitomm.github.io/post-images/1582604339501.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>再次谷歌 git 如何设置代理服务器</li>
</ol>
<pre><code>git config --global http.proxy 'socks5://127.0.0.1:1080'

git config --global https.proxy 'socks5://127.0.0.1:1080'
</code></pre>
<p>参考：<a href="https://blog.csdn.net/isea533/article/details/84748009">https://blog.csdn.net/isea533/article/details/84748009</a></p>
<ol start="3">
<li>再次尝试检测远程连接成功</li>
</ol>
<p>接下来同步查看效果完成后就可以开启开心的写作之旅啦~</p>
<h1 id="问题二">问题二</h1>
<h3 id="我的环境-2">我的环境</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows10</td>
</tr>
<tr>
<td>软件版本</td>
<td>0.9.2</td>
</tr>
<tr>
<td>主题名称</td>
<td>Notes</td>
</tr>
</tbody>
</table>
<h2 id="问题描述-2">问题描述</h2>
<p>版本更新到 0.9.2 后重新安装了 Gridea ，再次检测远程连接失败</p>
<figure data-type="image" tabindex="2"><img src="https://epitomm.github.io/post-images/1582604400732.png" alt="" loading="lazy"></figure>
<p>错误信息</p>
<pre><code>connect ETIMEDOUT 140.82.114.4:443
</code></pre>
<h2 id="问题分析-2">问题分析</h2>
<ol>
<li>cmd 命令行 ping github.com 失败。代理问题</li>
</ol>
<h2 id="问题解决-2">问题解决</h2>
<ol start="2">
<li>
<p>使用 ping 检测工具找一个能够 ping 通 github.com 的 IP，检测工具网址如下：</p>
<p><a href="http://ping.chinaz.com/github.com">http://ping.chinaz.com/github.com</a></p>
</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://epitomm.github.io/post-images/1582041969896.png" alt="" loading="lazy"></figure>
<ol start="3">
<li>选择一个响应较快的 IP，添加到 C:\Windows\System32\drivers\etc\host 文件末尾：</li>
</ol>
<figure data-type="image" tabindex="4"><img src="https://epitomm.github.io/post-images/1582041983918.png" alt="" loading="lazy"></figure>
<pre><code>140.82.113.3 github.com
</code></pre>
<ol start="4">
<li>再次检测远程连接，成功。</li>
</ol>
]]></content>
    </entry>
</feed>